diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 850ddb8399..bef6944d49 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -39,16 +39,17 @@
 import com.graphhopper.reader.osgb.hn.OsHnReader;
 import com.graphhopper.reader.osgb.itn.OsItnReader;
 import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.EscapePrivateWeighting;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.RoutingAlgorithm;
 import com.graphhopper.routing.RoutingAlgorithmFactory;
 import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.util.BanPrivateWeighting;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.EscapePrivateWeighting;
 import com.graphhopper.routing.util.FastestWeighting;
 import com.graphhopper.routing.util.FastestWithAvoidancesWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -924,39 +925,44 @@ public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder
 		String weighting = weightingMap.getWeighting();
 		Weighting result;
 
+		String avoidanceString = weightingMap.get("avoidances","");
+		System.err.println("AVOID:" + avoidanceString);
+		boolean avoidancesEnabled = avoidanceString.length()>0;
 		if ("shortest".equalsIgnoreCase(weighting))
 		{
-			result = new ShortestWeighting();
-		} else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
-		{
-			if (encoder.supports(PriorityWeighting.class))
-				result = new PriorityWeighting(encoder);
-			else
-				result = new FastestWeighting(encoder);
-		} else if ("fastavoid".equalsIgnoreCase(weighting))
-		{
-			String avoidanceString = weightingMap.get("avoidances", "cliff");
-			String[] avoidances = avoidanceString.split(",");
-			if (encoder.supports(PriorityWeighting.class))
-			{
+			if(avoidancesEnabled) {
 				AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
 						.getExtension();
-				result = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension,
-						avoidances);
-			} else
-			{
-				AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
-						.getExtension();
-				result = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
+				String[] avoidances = avoidanceString.split(",");
+				result = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
+			} else {
+				result = new ShortestWeighting();
 			}
-		} else if ("shortavoid".equalsIgnoreCase(weighting))
+		} else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
 		{
-			AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
-					.getExtension();
-			String avoidanceString = weightingMap.get("avoidances", "cliff");
-			String[] avoidances = avoidanceString.split(",");
-			result = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
-		} else
+			if (encoder.supports(PriorityWeighting.class)) {
+				if(avoidancesEnabled) {
+					AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
+							.getExtension();
+					String[] avoidances = avoidanceString.split(",");
+					result = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
+				}
+				else {
+					result = new PriorityWeighting(encoder);
+				}
+			}
+			else {
+				if(avoidancesEnabled) {
+					AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
+							.getExtension();
+					String[] avoidances = avoidanceString.split(",");
+					result = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension,
+							avoidances);
+				} else {
+					result = new FastestWeighting(encoder);
+				}
+			}
+		}  else
 		{
 			throw new UnsupportedOperationException(
 					"Weighting "
@@ -977,14 +983,19 @@ public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEnco
 	}
 	
 	/**
-	 * Potentially wraps the specified weighting into a EscapePrivateWeighting instance.
+	 * Potentially wraps the specified weighting into a Weighting which specifies how it handles roads marked as private access.
+	 * This will be a EscapePrivateWeighting or a BanPrivateWeighting
 	 * @param includeNoThrough 
 	 */
-	public Weighting createEscapePrivateWeighting( Weighting weighting, GHRequest request , Graph graph, FlagEncoder encoder )
+	public Weighting createPrivateWeighting( Weighting weighting, GHRequest request , Graph graph, FlagEncoder encoder )
 	{
 		boolean includeNoThrough = checkForNoThroughAccess(request);
-		if (includeNoThrough && encoder.supports(EscapePrivateWeighting.class))
-			return new EscapePrivateWeighting(graph, encoder, weighting);
+		if(encoder.supports(EscapePrivateWeighting.class)) {
+			if (includeNoThrough)
+				return new EscapePrivateWeighting(graph, encoder, weighting);
+			else 
+				return new BanPrivateWeighting(encoder, weighting);
+		}
 		return weighting;
 	}
 
@@ -1099,7 +1110,7 @@ public GHResponse route( GHRequest request )
 			return Collections.emptyList();
 		}
 		weighting = createTurnWeighting(weighting, queryGraph, encoder);
-		weighting = createEscapePrivateWeighting(weighting, request, queryGraph, encoder);
+		weighting = createPrivateWeighting(weighting, request, queryGraph, encoder);
 
 		double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
 		String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
index 53a0e14ed4..068c6def98 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
@@ -224,6 +224,9 @@ private String getOsmMappedTypeName(String roadType) {
         case "Ferry Crossing":
             typeName = "ferry";
             break;
+        case "No Physical Manifestation":
+        	typeName = "nohighway";
+        	break;
         default:
             break;
         }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/rightofway/BridleWay.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/rightofway/BridleWay.java
index fa5cc0ee66..5a0f377a9b 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/rightofway/BridleWay.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/rightofway/BridleWay.java
@@ -16,7 +16,6 @@
     public void applyAttributes(RoutingElement way)
     {
         way.setTag("designation", "public_bridleway");
-        way.setTag("highway", "bridleway");
 
         way.setTag("foot", "yes");
         way.setTag("horse", "yes");
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/rightofway/Footpath.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/rightofway/Footpath.java
index 8e122e2249..eca5cefc04 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/rightofway/Footpath.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/rightofway/Footpath.java
@@ -16,7 +16,6 @@
     public void applyAttributes(RoutingElement way)
     {
         way.setTag("designation", "public_footpath");
-        way.setTag("highway", "footway");
         way.setTag("foot", "yes");
     }
 
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java b/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java
index 104d08b18d..99932e4d4e 100755
--- a/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java
@@ -147,8 +147,8 @@
 	public class ProcessVisitor
 	{
 		public void process( ProcessData processData, OsItnInputFile in )
-		        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-		        TransformException
+				throws XMLStreamException, MismatchedDimensionException, FactoryException,
+				TransformException
 		{
 		}
 	}
@@ -246,7 +246,7 @@ public OsItnReader( GraphStorage storage, CmdArgs commandLineArguments )
 		super(storage);
 		this.commandLineArguments = commandLineArguments;
 		String addAdditionalTowerNodesString = graphStorage.getProperties().get(
-		        "add.additional.tower.nodes");
+				"add.additional.tower.nodes");
 		if (addAdditionalTowerNodesString != null && addAdditionalTowerNodesString.length() > 0)
 		{
 			// Only parse this if it has been explicitly set otherwise set to
@@ -267,7 +267,7 @@ public OsItnReader( GraphStorage storage, CmdArgs commandLineArguments )
 
 	@Override
 	protected void preProcessSingleFile( File itnFile ) throws XMLStreamException, IOException,
-	        MismatchedDimensionException, FactoryException, TransformException
+	MismatchedDimensionException, FactoryException, TransformException
 	{
 		OsItnInputFile in = null;
 		try
@@ -283,7 +283,7 @@ protected void preProcessSingleFile( File itnFile ) throws XMLStreamException, I
 	}
 
 	private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException,
-	        MismatchedDimensionException, FactoryException, TransformException
+	MismatchedDimensionException, FactoryException, TransformException
 	{
 		logger.error("==== preProcessSingleFile");
 		long tmpWayCounter = 1;
@@ -310,8 +310,8 @@ private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException
 					if (++tmpWayCounter % 500000 == 0)
 					{
 						logger.info(PREPROCESS_OSM_ID_MAP_MB_FORMAT, nf(tmpWayCounter),
-						        nf(getNodeMap().getSize()), getNodeMap().getMemoryUsage(),
-						        Helper.getMemInfo());
+								nf(getNodeMap().getSize()), getNodeMap().getMemoryUsage(),
+								Helper.getMemInfo());
 					}
 				}
 			}
@@ -322,11 +322,11 @@ private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException
 				// item.getTag(OSITNElement.TAG_KEY_TYPE) + " meta?" +
 				// relation.isMetaRelation());
 				if (!relation.isMetaRelation()
-				        && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
+						&& relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
 					prepareWaysWithRelationInfo(relation);
 
 				if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
-				        OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
+						OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
 					prepareRestrictionRelation(relation);
 
 				if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_NOENTRY))
@@ -337,9 +337,9 @@ private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException
 				// If this way is prohibited then we want to make a note of it
 				// so we don't include it in later route generation
 				if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
-				        OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED)
-				        || relation.hasTag(OSITNElement.TAG_KEY_TYPE,
-				                OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED))
+						OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED)
+						|| relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+								OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED))
 				{
 					prepareAccessProhibitedRelation(relation);
 				}
@@ -363,7 +363,7 @@ private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException
 				if (++tmpRelationCounter % 50000 == 0)
 				{
 					logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:"
-					        + nf(getOsmWayIdToRouteWeightMap().size()) + " " + Helper.getMemInfo());
+							+ nf(getOsmWayIdToRouteWeightMap().size()) + " " + Helper.getMemInfo());
 				}
 
 			}
@@ -388,7 +388,7 @@ private void prepareRestrictionRelation( Relation relation )
 	private void prepareAccessProhibitedRelation( Relation relation )
 	{
 		if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
-		        && !encodingManager.isVehicleQualifierTypeIncluded(relation))
+				&& !encodingManager.isVehicleQualifierTypeIncluded(relation))
 		{
 			ArrayList<? extends RelationMember> members = relation.getMembers();
 			// There will be only one
@@ -437,7 +437,7 @@ private void prepareRoadDirectionRelation( Relation relation )
 		// Check if this vehicle has an exception meaning we shouldn't handle
 		// one way
 		if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
-		        && !encodingManager.isVehicleQualifierTypeIncluded(relation))
+				&& !encodingManager.isVehicleQualifierTypeIncluded(relation))
 		{
 			// This will be "-1" the first time this is called
 			String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION);
@@ -488,7 +488,7 @@ private void prepareNoEntryRelation( Relation relation )
 		// Check if this vehicle has an exception meaning we shouldn't handle no
 		// entry
 		if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
-		        && !encodingManager.isVehicleQualifierTypeIncluded(relation))
+				&& !encodingManager.isVehicleQualifierTypeIncluded(relation))
 		{
 			long flags = 1l; // (+) orientation
 			String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_NOENTRY_ORIENTATION);
@@ -522,7 +522,7 @@ private void prepareNoEntryRelation( Relation relation )
 				}
 				// now put the flag in there
 				logger.info(EDGE_ID_COORDS_TO_NODE_FLAGS_MAP_PUT_FORMAT, wayId, xCoord, yCoord,
-				        flags);
+						flags);
 
 				yCoordMap.put(yCoord, flags);
 			}
@@ -637,7 +637,7 @@ protected void writeOsm2Graph( File osmFile )
 	{
 		int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
 		logger.error(CREATING_GRAPH_FOUND_NODES_PILLAR_TOWER_FORMAT, nf(getNodeMap().getSize()),
-		        Helper.getMemInfo());
+				Helper.getMemInfo());
 		graphStorage.create(tmp);
 
 		ProcessData processData = new ProcessData();
@@ -647,8 +647,8 @@ protected void writeOsm2Graph( File osmFile )
 			{
 				@Override
 				public void process( ProcessData processData, OsItnInputFile in )
-				        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-				        TransformException
+						throws XMLStreamException, MismatchedDimensionException, FactoryException,
+						TransformException
 				{
 					logger.error("PROCESS STAGE 1");
 					processStageOne(processData, in);
@@ -662,8 +662,8 @@ public void process( ProcessData processData, OsItnInputFile in )
 			{
 				@Override
 				public void process( ProcessData processData, OsItnInputFile in )
-				        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-				        TransformException
+						throws XMLStreamException, MismatchedDimensionException, FactoryException,
+						TransformException
 				{
 					logger.error("PROCESS STAGE 2");
 					processStageTwo(processData, in);
@@ -675,8 +675,8 @@ public void process( ProcessData processData, OsItnInputFile in )
 			{
 				@Override
 				public void process( ProcessData processData, OsItnInputFile in )
-				        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-				        TransformException
+						throws XMLStreamException, MismatchedDimensionException, FactoryException,
+						TransformException
 				{
 					logger.error("PROCESS STAGE 3");
 					processStageThree(processData, in);
@@ -693,12 +693,12 @@ public void process( ProcessData processData, OsItnInputFile in )
 		finishedReading();
 		if (graphStorage.getNodes() == 0)
 			throw new IllegalStateException("osm must not be empty. read " + processData.counter
-			        + " lines and " + locations + " locations");
+					+ " lines and " + locations + " locations");
 	}
 
 	private void writeOsm2GraphFromDirOrFile( File osmFile, ProcessData processData,
-	        ProcessVisitor processVisitor ) throws XMLStreamException, IOException,
-	        MismatchedDimensionException, FactoryException, TransformException
+			ProcessVisitor processVisitor ) throws XMLStreamException, IOException,
+			MismatchedDimensionException, FactoryException, TransformException
 	{
 		if (osmFile.isDirectory())
 		{
@@ -716,8 +716,8 @@ private void writeOsm2GraphFromDirOrFile( File osmFile, ProcessData processData,
 	}
 
 	private void writeOsm2GraphFromSingleFile( File osmFile, ProcessData processData,
-	        ProcessVisitor processVisitor ) throws XMLStreamException, IOException,
-	        MismatchedDimensionException, FactoryException, TransformException
+			ProcessVisitor processVisitor ) throws XMLStreamException, IOException,
+			MismatchedDimensionException, FactoryException, TransformException
 	{
 		OsItnInputFile in = null;
 		try
@@ -735,8 +735,8 @@ private void writeOsm2GraphFromSingleFile( File osmFile, ProcessData processData
 	}
 
 	private void processStageOne( ProcessData processData, OsItnInputFile in )
-	        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-	        TransformException
+			throws XMLStreamException, MismatchedDimensionException, FactoryException,
+			TransformException
 	{
 		logger.error("==== processStageOne");
 		RoutingElement item;
@@ -777,7 +777,7 @@ private void processStageOne( ProcessData processData, OsItnInputFile in )
 			if (++processData.counter % 5000000 == 0)
 			{
 				logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations),
-				        skippedLocations, Helper.getMemInfo());
+						skippedLocations, Helper.getMemInfo());
 			}
 		}
 	}
@@ -816,7 +816,7 @@ protected DataReader createReader( GraphStorage tmpGraph )
 					}
 
 				}.setOSMFile(hnPath).setGraphHopperLocation(hnGraphLocation)
-				        .setEncodingManager(encodingManager).setCHEnable(false).setAsHnReader();
+				.setEncodingManager(encodingManager).setCHEnable(false).setAsHnReader();
 				hnGraphHopper.importOrLoad();
 				// OsHnReader hnReader = new OsHnReader(hnGraphHopper.getGraph());
 				logger.error("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<=================================================");
@@ -826,8 +826,8 @@ protected DataReader createReader( GraphStorage tmpGraph )
 	}
 
 	private void processStageTwo( ProcessData processData, OsItnInputFile in )
-	        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-	        TransformException
+			throws XMLStreamException, MismatchedDimensionException, FactoryException,
+			TransformException
 	{
 		logger.error("==== processStageTwo");
 		RoutingElement item;
@@ -856,16 +856,16 @@ private void processStageTwo( ProcessData processData, OsItnInputFile in )
 			if (++processData.counter % 5000000 == 0)
 			{
 				logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations),
-				        skippedLocations, Helper.getMemInfo());
+						skippedLocations, Helper.getMemInfo());
 			}
 		}
 	}
 
 	private List<OSITNNode> prepareWaysNodes( RoutingElement item, LongIntMap nodeFilter )
-	        throws MismatchedDimensionException, FactoryException, TransformException
-	{
+			throws MismatchedDimensionException, FactoryException, TransformException
+			{
 		List<OSITNNode> evaluateWayNodes = ((OSITNWay) item)
-		        .evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
+				.evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
 		for (OSITNNode ositnNode : evaluateWayNodes)
 		{
 			nodeFilter.put(ositnNode.getId(), PILLAR_NODE);
@@ -873,11 +873,11 @@ private void processStageTwo( ProcessData processData, OsItnInputFile in )
 		}
 		logger.info(WE_HAVE_EVALUATED_WAY_NODES_FORMAT, evaluateWayNodes.size());
 		return evaluateWayNodes;
-	}
+			}
 
 	private void processStageThree( ProcessData processData, OsItnInputFile in )
-	        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-	        TransformException
+			throws XMLStreamException, MismatchedDimensionException, FactoryException,
+			TransformException
 	{
 		logger.error("==== processStageThree");
 		RoutingElement item;
@@ -899,7 +899,7 @@ private void processStageThree( ProcessData processData, OsItnInputFile in )
 			if (++processData.counter % 5000000 == 0)
 			{
 				logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations),
-				        skippedLocations, Helper.getMemInfo());
+						skippedLocations, Helper.getMemInfo());
 			}
 		}
 	}
@@ -946,18 +946,18 @@ private void processWay( OSITNWay way, List<OSITNNode> wayNodes )
 			// attributes
 			if ((attributeBits & ATTRIBUTE_BIT_FORD) != 0)
 			{
-				System.err.println("FORD_NBIT");
+				// System.err.println("FORD_NBIT");
 				way.setTag(OSITNElement.TAG_VALUE_CLASSIFICATION_FORD, "yes");
 			}
 			if ((attributeBits & ATTRIBUTE_BIT_GATE) != 0)
 			{
-				System.err.println("GATE_NBIT");
+				// System.err.println("GATE_NBIT");
 				way.setTag("barrier", OSITNElement.TAG_VALUE_CLASSIFICATION_GATE);
 			}
 			if ((attributeBits & ATTRIBUTE_BIT_LEVEL_CROSSING) != 0)
 			{
 				way.setTag(OSITNElement.TAG_KEY_CLASSIFICATION,
-				        OSITNElement.TAG_VALUE_CLASSIFICATION_LEVEL_CROSSING);
+						OSITNElement.TAG_VALUE_CLASSIFICATION_LEVEL_CROSSING);
 			}
 		}
 
@@ -1011,12 +1011,12 @@ private void processWay( OSITNWay way, List<OSITNNode> wayNodes )
 			double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
 			double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
 			if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat)
-			        && !Double.isNaN(lastLon))
+					&& !Double.isNaN(lastLon))
 			{
 				double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
 				way.setTag("estimated_distance", estimatedDist);
 				way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2,
-				        (firstLon + lastLon) / 2));
+						(firstLon + lastLon) / 2));
 			}
 		}
 
@@ -1042,7 +1042,7 @@ private void processWay( OSITNWay way, List<OSITNNode> wayNodes )
 	}
 
 	private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay way,
-	        List<OSITNNode> wayNodes, long wayFlags, long wayOsmId )
+			List<OSITNNode> wayNodes, long wayFlags, long wayOsmId )
 	{
 		// if (osmNodeIds.size()>2) {
 		List<EdgeIteratorState> startCreatedEdges = new ArrayList<EdgeIteratorState>();
@@ -1097,8 +1097,8 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 	 * @return
 	 */
 	private List<EdgeIteratorState> processNoEntry( OSITNWay way, List<OSITNNode> wayNodes,
-	        TLongList osmNodeIds, long wayFlags, long wayOsmId )
-	{
+			TLongList osmNodeIds, long wayFlags, long wayOsmId )
+			{
 		List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
 		int lastNoEntry = -1;
 		List<EdgeIteratorState> noEntryCreatedEdges = new ArrayList<EdgeIteratorState>();
@@ -1130,7 +1130,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 
 				// create zero length edge for barrier to the next node
 				Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId,
-				        wayFlags, nodeFlags, wayOsmId);
+						wayFlags, nodeFlags, wayOsmId);
 				// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 				// newBarriers.size());
 				noEntryCreatedEdges.addAll(newBarriers);
@@ -1148,10 +1148,10 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 			{
 				failedStartNoEntries++;
 				errors_logger
-				        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
-				                + nodeId + " on way " + way.getId() + " for START Node "
-				                + osmNodeIds.toString() + " (" + successfulStartNoEntries
-				                + " succeeded, " + failedStartNoEntries + " failed)");
+				.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+						+ nodeId + " on way " + way.getId() + " for START Node "
+						+ osmNodeIds.toString() + " (" + successfulStartNoEntries
+						+ " succeeded, " + failedStartNoEntries + " failed)");
 			}
 		}
 		// Process Way Nodes
@@ -1190,7 +1190,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 
 					// create zero length edge for barrier to the next node
 					Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId,
-					        wayFlags, nodeFlags, wayOsmId);
+							wayFlags, nodeFlags, wayOsmId);
 					// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 					// newBarriers.size());
 					noEntryCreatedEdges.addAll(newBarriers);
@@ -1210,7 +1210,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 					// TODO end of way we will have issues
 					// run edge from real first node to shadow node
 					Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId, newNodeId,
-					        wayFlags, nodeFlags, wayOsmId);
+							wayFlags, nodeFlags, wayOsmId);
 					// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 					// newBarriers.size());
 					noEntryCreatedEdges.addAll(newBarriers);
@@ -1242,7 +1242,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 					long transfer[] = osmNodeIds.toArray(lastNoEntry, size - lastNoEntry - 1);
 					nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
 					Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor,
-					        wayFlags, wayOsmId);
+							wayFlags, wayOsmId);
 					// logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
 					// newEdges.size());
 					createdEdges.addAll(newEdges);
@@ -1275,7 +1275,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 
 				// create zero length edge for barrier to the next node
 				Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId,
-				        wayFlags, nodeFlags, wayOsmId);
+						wayFlags, nodeFlags, wayOsmId);
 				// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 				// newBarriers.size());
 				noEntryCreatedEdges.addAll(newBarriers);
@@ -1294,10 +1294,10 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 				// TODO Figure out why there are some end nodes that don't have
 				// internal node ids
 				errors_logger
-				        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
-				                + nodeId + " on way " + way.getId() + " for END Node "
-				                + osmNodeIds.toString() + " (" + successfulEndNoEntries
-				                + " succeeded, " + failedEndNoEntries + " failed)");
+				.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+						+ nodeId + " on way " + way.getId() + " for END Node "
+						+ osmNodeIds.toString() + " (" + successfulEndNoEntries
+						+ " succeeded, " + failedEndNoEntries + " failed)");
 			}
 		}
 
@@ -1336,7 +1336,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 			}
 		}
 		return createdEdges;
-	}
+			}
 
 	/**
 	 *
@@ -1350,7 +1350,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 		// x, y combination
 		long key = wayId;
 		TDoubleObjectMap<TDoubleLongMap> xToYToNodeFlagsMap = getEdgeIdToXToYToNodeFlagsMap().get(
-		        key);
+				key);
 		if (xToYToNodeFlagsMap != null)
 		{
 			String[] coordParts = wayCoord.split(",");
@@ -1404,8 +1404,8 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 	 * @return
 	 */
 	private List<EdgeIteratorState> processBarriers( Way way, TLongList osmNodeIds, long wayFlags,
-	        long wayOsmId )
-	{
+			long wayOsmId )
+			{
 		List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
 		// look for barriers along the way
 		final int size = osmNodeIds.size();
@@ -1443,14 +1443,14 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 						transfer[transfer.length - 1] = newNodeId;
 						TLongList partIds = new TLongArrayList(transfer);
 						Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags,
-						        wayOsmId);
+								wayOsmId);
 						// logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
 						// newWays.size());
 						createdEdges.addAll(newWays);
 
 						// create zero length edge for barrier
 						Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId,
-						        nodeId, wayFlags, nodeFlags, wayOsmId);
+								nodeId, wayFlags, nodeFlags, wayOsmId);
 						// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 						// newBarriers.size());
 						createdEdges.addAll(newBarriers);
@@ -1458,7 +1458,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 					{
 						// run edge from real first node to shadow node
 						Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId,
-						        newNodeId, wayFlags, nodeFlags, wayOsmId);
+								newNodeId, wayFlags, nodeFlags, wayOsmId);
 						// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 						// newBarriers.size());
 						createdEdges.addAll(newBarriers);
@@ -1500,7 +1500,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 
 			// An index < TOWER_NODE means it is a tower node.
 			boolean doInsertAdditionalTowerNodes = addAdditionalTowerNodes
-			        && (graphIndex < TOWER_NODE);
+					&& (graphIndex < TOWER_NODE);
 
 			// logger.error("doInsertAdditionalTowerNodes is " +
 			// doInsertAdditionalTowerNodes + " for lastNodeId "+ lastNodeId );
@@ -1518,7 +1518,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 			}
 
 			Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor, wayFlags,
-			        wayOsmId);
+					wayOsmId);
 
 			createdEdges.addAll(newEdges);
 			if (doInsertAdditionalTowerNodes)
@@ -1535,7 +1535,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 			encodingManager.applyWayTags(way, edge);
 		}
 		return createdEdges;
-	}
+			}
 
 	private String getWayName( long id )
 	{
@@ -1579,17 +1579,17 @@ public void processRelation( Relation relation ) throws XMLStreamException
 				getOsmIdStoreRequiredSet().add(toId);
 
 				logger.info(TURN_FROM_TO_VIA_FORMAT, turnRelation.getOsmIdFrom(),
-				        turnRelation.getOsmIdTo(), turnRelation.getVia());
+						turnRelation.getOsmIdTo(), turnRelation.getVia());
 				GraphExtension extendedStorage = graphStorage.getExtension();
 				if (extendedStorage instanceof TurnCostExtension)
 				{
 					TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
 					Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(
-					        turnRelation, this);
+							turnRelation, this);
 					for (ITurnCostTableEntry entry : entries)
 					{
 						tcs.addTurnInfo(entry.getEdgeFrom(), entry.getVia(), entry.getEdgeTo(),
-						        entry.getFlags());
+								entry.getFlags());
 					}
 				}
 			}
@@ -1830,7 +1830,7 @@ private int addTowerNode( long osmId, double lat, double lon, double ele )
 
 				if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
 					throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", "
-					        + osmId);
+							+ osmId);
 
 				if (tmpNode > -TOWER_NODE)
 				{
@@ -1868,15 +1868,15 @@ private int addTowerNode( long osmId, double lat, double lon, double ele )
 	}
 
 	EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags,
-	        long wayOsmId )
+			long wayOsmId )
 	{
 		// sanity checks
 		if (fromIndex < 0 || toIndex < 0)
 			throw new AssertionError("to or from index is invalid for this edge " + fromIndex
-			        + "->" + toIndex + ", points:" + pointList);
+					+ "->" + toIndex + ", points:" + pointList);
 		if (pointList.getDimension() != nodeAccess.getDimension())
 			throw new AssertionError("Dimension does not match for pointList vs. nodeAccess "
-			        + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
+					+ pointList.getDimension() + " <-> " + nodeAccess.getDimension());
 
 		double towerNodeDistance = 0;
 		double prevLat = pointList.getLatitude(0);
@@ -1918,7 +1918,7 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
 		}
 		logger.info("Add edge flags:" + flags);
 		EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
-		        .setDistance(towerNodeDistance).setFlags(flags);
+				.setDistance(towerNodeDistance).setFlags(flags);
 		if (nodes > 2)
 		{
 			if (doSimplify)
@@ -1949,7 +1949,7 @@ private void storeOSMWayID( int edgeId, long osmWayID )
 	 * @return converted tower node
 	 */
 	private int handlePillarNode( int tmpNode, long osmId, PointList pointList,
-	        boolean convertToTowerNode )
+			boolean convertToTowerNode )
 	{
 		logger.info(CONVERTING_PILLAR_TO_PILLAR_FORMAT, osmId, convertToTowerNode);
 		tmpNode = tmpNode - 3;
@@ -1958,7 +1958,7 @@ private int handlePillarNode( int tmpNode, long osmId, PointList pointList,
 		double ele = pillarInfo.getElevation(tmpNode);
 		if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
 			throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
-			        + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+					+ "osmId:" + osmId + " pillarIndex:" + tmpNode);
 
 		if (convertToTowerNode)
 		{
@@ -2042,8 +2042,8 @@ private long createNewNodeId()
 	 * Add a zero length edge with reduced routing options to the graph.
 	 */
 	private Collection<EdgeIteratorState> addBarrierEdge( long fromId, long toId, long flags,
-	        long nodeFlags, long wayOsmId )
-	{
+			long nodeFlags, long wayOsmId )
+			{
 		// clear barred directions from routing flags
 		flags &= ~nodeFlags;
 		// add edge
@@ -2051,7 +2051,7 @@ private long createNewNodeId()
 		barrierNodeIds.add(fromId);
 		barrierNodeIds.add(toId);
 		return addOSMWay(barrierNodeIds, flags, wayOsmId);
-	}
+			}
 
 	/**
 	 * Creates an OSM turn relation out of an unspecified OSM relation
@@ -2062,7 +2062,7 @@ private long createNewNodeId()
 	OSITNTurnRelation createTurnRelation( Relation relation )
 	{
 		OSMTurnRelation.Type type = OSITNTurnRelation.getRestrictionType(relation
-		        .getTag(OSITNElement.TAG_KEY_RESTRICTION));
+				.getTag(OSITNElement.TAG_KEY_RESTRICTION));
 
 		// Handle No Turn and Mandatory Turn Exceptions. This is done by
 		// selectively ignoring restrictions based on excluded/included vehicle
@@ -2078,7 +2078,7 @@ OSITNTurnRelation createTurnRelation( Relation relation )
 		{
 			// There is a no entry or mandatory turn
 			if (encodingManager.isVehicleQualifierTypeExcluded(relation)
-			        || encodingManager.isVehicleQualifierTypeIncluded(relation))
+					|| encodingManager.isVehicleQualifierTypeIncluded(relation))
 			{
 				// The current encoder vehicle is excluded from this restriction
 				// so remove it OR (except buses=false)
@@ -2120,7 +2120,7 @@ OSITNTurnRelation createTurnRelation( Relation relation )
 				if (-1 < foundViaNode)
 				{
 					OSITNTurnRelation osmTurnRelation = new OSITNTurnRelation(fromWayID,
-					        foundViaNode, toWayID, type);
+							foundViaNode, toWayID, type);
 					return osmTurnRelation;
 				}
 			}
@@ -2182,8 +2182,8 @@ private TLongLongHashMap getOsmWayIdToRouteWeightMap()
 	private void printInfo( String str )
 	{
 		logger.info(PRINT_INFO_FORMAT, str, graphStorage.getNodes(), getNodeMap().getSize(),
-		        getNodeMap().getMemoryUsage(), getNodeFlagsMap().size(),
-		        getOsmWayIdToRouteWeightMap().size(), Helper.getMemInfo());
+				getNodeMap().getMemoryUsage(), getNodeFlagsMap().size(),
+				getOsmWayIdToRouteWeightMap().size(), Helper.getMemInfo());
 	}
 
 	private long findViaNode( long fromOsm, long toOsm )
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index c29870bb26..5f36844529 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -24,6 +24,7 @@
 
 import java.util.PriorityQueue;
 
+import com.graphhopper.routing.util.EscapePrivateWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index b6c2051342..acc33d9280 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.EscapePrivateWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index 6b016d5d09..904165b42d 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -22,6 +22,7 @@
 
 import java.util.PriorityQueue;
 
+import com.graphhopper.routing.util.EscapePrivateWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
diff --git a/core/src/main/java/com/graphhopper/routing/util/BanPrivateWeighting.java b/core/src/main/java/com/graphhopper/routing/util/BanPrivateWeighting.java
new file mode 100644
index 0000000000..0f86af2c4e
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/BanPrivateWeighting.java
@@ -0,0 +1,32 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class BanPrivateWeighting implements Weighting
+{
+
+	private FlagEncoder encoder;
+	private Weighting innerWeighting;
+
+	public BanPrivateWeighting( FlagEncoder encoder, Weighting weighting )
+	{
+		this.encoder = encoder;
+		this.innerWeighting = weighting;
+	}
+
+	@Override
+	public double getMinWeight( double distance )
+	{
+		return innerWeighting.getMinWeight(distance);
+	}
+
+	@Override
+	public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+	{
+		if(encoder.getLong(edgeState.getFlags(), EscapePrivateWeighting.KEY)>0) {
+			return Double.POSITIVE_INFINITY;
+		}
+		return innerWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+	}
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 7085eb4317..9b40084948 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -176,6 +176,7 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         setHighwaySpeed("secondary_link", 18);
         setHighwaySpeed("tertiary", 18);
         setHighwaySpeed("tertiary_link", 18);
+        setHighwaySpeed("nohighway",6);
 
         // special case see tests and #191
         setHighwaySpeed("motorway", 18);
diff --git a/core/src/main/java/com/graphhopper/routing/util/BusFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BusFlagEncoder.java
index 2372d544d0..d8a254eda5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BusFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BusFlagEncoder.java
@@ -12,356 +12,341 @@
 
 public class BusFlagEncoder extends AbstractFlagEncoder
 {
-    protected final Map<String, Integer> trackTypeSpeedMap = new HashMap<String, Integer>();
-    protected final Set<String> badSurfaceSpeedMap = new HashSet<String>();
-    /**
-     * A map which associates string to speed. Get some impression:
-     * http://www.itoworld.com/map/124#fullscreen
-     * http://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed
-     */
-    protected final Map<String, Integer> defaultSpeedMap = new HashMap<String, Integer>();
-
-    /**
-     * Should be only instantied via EncodingManager
-     */
-    public BusFlagEncoder()
-    {
-        this(5, 5, 0);
-    }
-
-    public BusFlagEncoder( String propertiesStr )
-    {
-        this((int) parseLong(propertiesStr, "speedBits", 5),
-                parseDouble(propertiesStr, "speedFactor", 5),
-                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
-    }
-
-    public BusFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
-    {
-        super(speedBits, speedFactor, maxTurnCosts);
-        restrictions.addAll(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
-        
-        restrictedValues.add("private");
-        restrictedValues.add("agricultural");
-        restrictedValues.add("forestry");
-        restrictedValues.add("no");
-        restrictedValues.add("restricted");
-        restrictedValues.add("delivery");
-
-        intendedValues.add("yes");
-        intendedValues.add("permissive");
-
-        potentialBarriers.add("gate");
-        potentialBarriers.add("lift_gate");
-        potentialBarriers.add("kissing_gate");
-        potentialBarriers.add("swing_gate");
-
-        absoluteBarriers.add("bollard");
-        absoluteBarriers.add("stile");
-        absoluteBarriers.add("turnstile");
-        absoluteBarriers.add("cycle_barrier");
-        absoluteBarriers.add("motorcycle_barrier");
-        absoluteBarriers.add("block");
-
-        trackTypeSpeedMap.put("grade1", 20); // paved
-        trackTypeSpeedMap.put("grade2", 15); // now unpaved - gravel mixed with ...
-        trackTypeSpeedMap.put("grade3", 10); // ... hard and soft materials
-        trackTypeSpeedMap.put("grade4", 5); // ... some hard or compressed materials
-        trackTypeSpeedMap.put("grade5", 5); // ... no hard materials. soil/sand/grass
-
-        badSurfaceSpeedMap.add("cobblestone");
-        badSurfaceSpeedMap.add("grass_paver");
-        badSurfaceSpeedMap.add("gravel");
-        badSurfaceSpeedMap.add("sand");
-        badSurfaceSpeedMap.add("paving_stones");
-        badSurfaceSpeedMap.add("dirt");
-        badSurfaceSpeedMap.add("ground");
-        badSurfaceSpeedMap.add("grass");
-
-        // autobahn
-        defaultSpeedMap.put("motorway", 100);
-        defaultSpeedMap.put("motorway_link", 70);
-        defaultSpeedMap.put("motorroad", 90);
-        // bundesstraße
-        defaultSpeedMap.put("trunk", 70);
-        defaultSpeedMap.put("trunk_link", 65);
-        // linking bigger town
-        defaultSpeedMap.put("primary", 65);
-        defaultSpeedMap.put("primary_link", 60);
-        // linking towns + villages
-        defaultSpeedMap.put("secondary", 60);
-        defaultSpeedMap.put("secondary_link", 50);
-        // streets without middle line separation
-        defaultSpeedMap.put("tertiary", 50);
-        defaultSpeedMap.put("tertiary_link", 40);
-        defaultSpeedMap.put("unclassified", 30);
-        defaultSpeedMap.put("residential", 30);
-        // spielstraße
-        defaultSpeedMap.put("living_street", 5);
-        defaultSpeedMap.put("service", 20);
-        // unknown road
-        defaultSpeedMap.put("road", 20);
-        // forestry stuff
-        defaultSpeedMap.put("track", 15);
-        
-        defaultSpeedMap.put("Motorway", 100);
-        defaultSpeedMap.put("A Road", 55);
-        defaultSpeedMap.put("B Road", 35);
-        defaultSpeedMap.put("Minor Road", 35);
-        defaultSpeedMap.put("Local Street", 35);
-        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("A Road-Single Carriageway", 55);
-        defaultSpeedMap.put("B Road", 35);
-        defaultSpeedMap.put("Minor Road", 35);
-        defaultSpeedMap.put("Local Street", 35);
-        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("Motorway", 100);
-        defaultSpeedMap.put("A Road", 55);
-        defaultSpeedMap.put("B Road", 35);
-        defaultSpeedMap.put("Minor Road", 35);
-        defaultSpeedMap.put("Local Street", 35);
-        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("A Road-Dual Carriageway", 55);
-        defaultSpeedMap.put("B Road", 35);
-        defaultSpeedMap.put("Minor Road", 35);
-        defaultSpeedMap.put("Local Street", 35);
-        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("Motorway-Slip Road", 100);
-        defaultSpeedMap.put("A Road-Slip Road", 55);
-        defaultSpeedMap.put("B Road", 35);
-        defaultSpeedMap.put("Minor Road", 35);
-        defaultSpeedMap.put("Local Street", 35);
-        defaultSpeedMap.put("Alley", 35);
-        defaultSpeedMap.put("Motorway-Roundabout", 100);
-        defaultSpeedMap.put("A Road-Roundabout", 55);
-        defaultSpeedMap.put("B Road-Roundabout", 35);
-        defaultSpeedMap.put("Minor Road-Roundabout", 35);
-        defaultSpeedMap.put("Local Street-Roundabout", 35);
-        
-        // Should we be including these in car flags?
-        defaultSpeedMap.put("Pedestrianised Street", 0);
-        defaultSpeedMap.put("Private Road - Restricted Access", 35);
-        defaultSpeedMap.put("Private Road - Publicly Accessible", 35);
-        defaultSpeedMap.put("Alley", 0);
-        
-        // osgb:type
-//        vehicleQualifierTypeExclusions.add("Buses");
-        vehicleQualifierTypeExclusions.add("Coaches");
-        vehicleQualifierTypeExclusions.add("Mopeds");
-        vehicleQualifierTypeExclusions.add("Motor Cycles");
-        vehicleQualifierTypeExclusions.add("HGV's");
-        vehicleQualifierTypeExclusions.add("LGV's");
-        vehicleQualifierTypeExclusions.add("Towed Caravans");
-        vehicleQualifierTypeExclusions.add("Cycles");
-        vehicleQualifierTypeExclusions.add("Tracked Vehicles");
-        // osgb:use
-        vehicleQualifierTypeExclusions.add("Taxi");
-        vehicleQualifierTypeExclusions.add("Taxis"); // Added from analysing the actual data
-        vehicleQualifierTypeExclusions.add("School Bus");
-        vehicleQualifierTypeExclusions.add("Patron");
-        vehicleQualifierTypeExclusions.add("Access");
-        vehicleQualifierTypeExclusions.add("Resident");
-        vehicleQualifierTypeExclusions.add("Emergency Vehicle");
-//        vehicleQualifierTypeExclusions.add("Public Transport");
-        vehicleQualifierTypeExclusions.add("Authorised Vehicle");
-//        vehicleQualifierTypeExclusions.add("Local Bus");
-//        vehicleQualifierTypeExclusions.add("Local Buses"); // Added from analysing the actual data
-        vehicleQualifierTypeExclusions.add("Escorted Traffic");
-        vehicleQualifierTypeExclusions.add("Loading And Unloading"); // Added from analysing the actual data
-        
-
-        
-        vehicleQualifierTypeInclusions.add("Motor Vehicles");
-        vehicleQualifierTypeInclusions.add("All Vehicles");
-        // temp inclusions for testing
-        vehicleQualifierTypeInclusions.add("Buses");
-
-        vehicleQualifierTypeInclusions.add("Local Bus");
-        vehicleQualifierTypeInclusions.add("Local Buses");
-        vehicleQualifierTypeInclusions.add("Public Transport");
-
-    }
-
-    /**
-     * Define the place of the speedBits in the edge flags for car.
-     */
-    @Override
-    public int defineWayBits( int index, int shift )
-    {
-        // first two bits are reserved for route handling in superclass
-        shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), defaultSpeedMap.get("motorway"));
-        return shift + speedEncoder.getBits();
-    }
-
-    protected double getSpeed( Way way )
-    {
-        String highwayValue = way.getTag("highway");
-        Integer speed = defaultSpeedMap.get(highwayValue);
-        if (speed == null)
-            throw new IllegalStateException(toString() + ", no speed found for:" + highwayValue);
-
-        if (highwayValue.equals("track"))
-        {
-            String tt = way.getTag("tracktype");
-            if (!Helper.isEmpty(tt))
-            {
-                Integer tInt = trackTypeSpeedMap.get(tt);
-                if (tInt != null)
-                    speed = tInt;
-            }
-        }
-
-        return speed;
-    }
-
-    @Override
-    public long acceptWay( Way way )
-    {
-        String highwayValue = way.getTag("highway");
-        if (highwayValue == null)
-        {
-            if (way.hasTag("route", ferries))
-            {
-                String motorcarTag = way.getTag("motorcar");
-                if (motorcarTag == null)
-                    motorcarTag = way.getTag("motor_vehicle");
-
-                if (motorcarTag == null && !way.hasTag("foot") && !way.hasTag("bicycle") || "yes".equals(motorcarTag))
-                    return acceptBit | ferryBit;
-            }
-            return 0;
-        }
-
-        if ("track".equals(highwayValue))
-        {
-            String tt = way.getTag("tracktype");
-            if (tt != null && !tt.equals("grade1"))
-                return 0;
-        }
-
-        if (!defaultSpeedMap.containsKey(highwayValue))
-            return 0;
-
-        if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
-            return 0;
-
-        // do not drive street cars into fords
-        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
-        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
-            return 0;
-
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
-            return 0;
-
-        // do not drive cars over railways (sometimes incorrectly mapped!)
-        if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
-            return 0;        
-        
-        return acceptBit;
-    }
-
-//    @Override
-//    public long handleRelationTags( Relation relation, long oldRelationFlags )
-//    {
-//        long flags = oldRelationFlags;
-//        
-//        // check access limited and access prohibited restrictions
-//        System.out.println("acceptWay for id " + relation.getId());
-//        if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED)||relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED) ) {
-//            System.out.println("OUR WAY HAS PROHIBITED OR LIMITED ACCESS");
-//            if (isVehicleQualifierTypeExcluded(relation) || isVehicleQualifierTypeIncluded(relation)) {
-//                System.out.println("WE ARE BLOCKING THIS ROAD....");
-//                flags = this.setBool(flags, K_FORWARD, false);
-//                flags = this.setBool(flags, K_BACKWARD, false);      
-//            }
-//        }
-//        return flags;
-//    }
-
-    @Override
-    public long handleWayTags( Way way, long allowed, long relationFlags )
-    {
-        if (!isAccept(allowed))
-            return 0;
-
-        long encoded;
-        if (!isFerry(allowed))
-        {
-            // get assumed speed from highway type
-            double speed = getSpeed(way);
-            speed = applyMaxSpeed(way, speed, true);
-
-            // limit speed to max 30 km/h if bad surface
-            if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
-                speed = 30;
-
-            encoded = setSpeed(0, speed);
-
-            boolean isRoundabout = way.hasTag("junction", "roundabout");
-            if (isRoundabout)
-                encoded = setBool(encoded, K_ROUNDABOUT, true);
-
-            if (way.hasTag("oneway", oneways) || isRoundabout)
-            {
-                if (way.hasTag("oneway", "-1"))
-                    encoded |= backwardBit;
-                else
-                    encoded |= forwardBit;
-            } else
-                encoded |= directionBitMask;
-            
-        } else
-        {
-            encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
-            encoded |= directionBitMask;
-        }
-
-        return encoded;
-    }
-
-    public String getWayInfo(Way way )
-    {
-        String str = "";
-        String highwayValue = way.getTag("highway");
-        // for now only motorway links
-        if ("motorway_link".equals(highwayValue))
-        {
-            String destination = way.getTag("destination");
-            if (!Helper.isEmpty(destination))
-            {
-                int counter = 0;
-                for (String d : destination.split(";"))
-                {
-                    if (d.trim().isEmpty())
-                        continue;
-
-                    if (counter > 0)
-                        str += ", ";
-
-                    str += d.trim();
-                    counter++;
-                }
-            }
-        }
-        if (str.isEmpty())
-            return str;
-        // I18N
-        if (str.contains(","))
-            return "destinations: " + str;
-        else
-            return "destination: " + str;
-    }
-    
-    @Override
-    public String toString()
-    {
-        return "bus";
-    }
-
-    @Override
-    public long handleRelationTags(Relation relation, long oldRelationFlags) {
-        return oldRelationFlags;
-    }
+	protected final Map<String, Integer> trackTypeSpeedMap = new HashMap<String, Integer>();
+	protected final Set<String> badSurfaceSpeedMap = new HashSet<String>();
+	/**
+	 * A map which associates string to speed. Get some impression:
+	 * http://www.itoworld.com/map/124#fullscreen
+	 * http://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed
+	 */
+	protected final Map<String, Integer> defaultSpeedMap = new HashMap<String, Integer>();
+
+	/**
+	 * Should be only instantied via EncodingManager
+	 */
+	public BusFlagEncoder()
+	{
+		this(5, 5, 0);
+	}
+
+	public BusFlagEncoder( String propertiesStr )
+	{
+		this((int) parseLong(propertiesStr, "speedBits", 5), parseDouble(propertiesStr,
+		        "speedFactor", 5), parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+	}
+
+	public BusFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+	{
+		super(speedBits, speedFactor, maxTurnCosts);
+		restrictions.addAll(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
+
+		restrictedValues.add("private");
+		restrictedValues.add("agricultural");
+		restrictedValues.add("forestry");
+		restrictedValues.add("no");
+		restrictedValues.add("restricted");
+		restrictedValues.add("delivery");
+
+		intendedValues.add("yes");
+		intendedValues.add("permissive");
+
+		potentialBarriers.add("gate");
+		potentialBarriers.add("lift_gate");
+		potentialBarriers.add("kissing_gate");
+		potentialBarriers.add("swing_gate");
+
+		absoluteBarriers.add("bollard");
+		absoluteBarriers.add("stile");
+		absoluteBarriers.add("turnstile");
+		absoluteBarriers.add("cycle_barrier");
+		absoluteBarriers.add("motorcycle_barrier");
+		absoluteBarriers.add("block");
+
+		trackTypeSpeedMap.put("grade1", 20); // paved
+		trackTypeSpeedMap.put("grade2", 15); // now unpaved - gravel mixed with ...
+		trackTypeSpeedMap.put("grade3", 10); // ... hard and soft materials
+		trackTypeSpeedMap.put("grade4", 5); // ... some hard or compressed materials
+		trackTypeSpeedMap.put("grade5", 5); // ... no hard materials. soil/sand/grass
+
+		badSurfaceSpeedMap.add("cobblestone");
+		badSurfaceSpeedMap.add("grass_paver");
+		badSurfaceSpeedMap.add("gravel");
+		badSurfaceSpeedMap.add("sand");
+		badSurfaceSpeedMap.add("paving_stones");
+		badSurfaceSpeedMap.add("dirt");
+		badSurfaceSpeedMap.add("ground");
+		badSurfaceSpeedMap.add("grass");
+
+		// autobahn
+		defaultSpeedMap.put("motorway", 100);
+		defaultSpeedMap.put("motorway_link", 70);
+		defaultSpeedMap.put("motorroad", 90);
+		// bundesstraße
+		defaultSpeedMap.put("trunk", 70);
+		defaultSpeedMap.put("trunk_link", 65);
+		// linking bigger town
+		defaultSpeedMap.put("primary", 65);
+		defaultSpeedMap.put("primary_link", 60);
+		// linking towns + villages
+		defaultSpeedMap.put("secondary", 60);
+		defaultSpeedMap.put("secondary_link", 50);
+		// streets without middle line separation
+		defaultSpeedMap.put("tertiary", 50);
+		defaultSpeedMap.put("tertiary_link", 40);
+		defaultSpeedMap.put("unclassified", 30);
+		defaultSpeedMap.put("residential", 30);
+		// spielstraße
+		defaultSpeedMap.put("living_street", 5);
+		defaultSpeedMap.put("service", 20);
+		// unknown road
+		defaultSpeedMap.put("road", 20);
+		// forestry stuff
+		defaultSpeedMap.put("track", 15);
+
+		defaultSpeedMap.put("Motorway", 100);
+		defaultSpeedMap.put("A Road", 55);
+		defaultSpeedMap.put("B Road", 35);
+		defaultSpeedMap.put("Minor Road", 35);
+		defaultSpeedMap.put("Local Street", 35);
+		defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("A Road-Single Carriageway", 55);
+		defaultSpeedMap.put("B Road", 35);
+		defaultSpeedMap.put("Minor Road", 35);
+		defaultSpeedMap.put("Local Street", 35);
+		defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("Motorway", 100);
+		defaultSpeedMap.put("A Road", 55);
+		defaultSpeedMap.put("B Road", 35);
+		defaultSpeedMap.put("Minor Road", 35);
+		defaultSpeedMap.put("Local Street", 35);
+		defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("A Road-Dual Carriageway", 55);
+		defaultSpeedMap.put("B Road", 35);
+		defaultSpeedMap.put("Minor Road", 35);
+		defaultSpeedMap.put("Local Street", 35);
+		defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("Motorway-Slip Road", 100);
+		defaultSpeedMap.put("A Road-Slip Road", 55);
+		defaultSpeedMap.put("B Road", 35);
+		defaultSpeedMap.put("Minor Road", 35);
+		defaultSpeedMap.put("Local Street", 35);
+		defaultSpeedMap.put("Alley", 35);
+		defaultSpeedMap.put("Motorway-Roundabout", 100);
+		defaultSpeedMap.put("A Road-Roundabout", 55);
+		defaultSpeedMap.put("B Road-Roundabout", 35);
+		defaultSpeedMap.put("Minor Road-Roundabout", 35);
+		defaultSpeedMap.put("Local Street-Roundabout", 35);
+
+		// Should we be including these in car flags?
+		defaultSpeedMap.put("Pedestrianised Street", 0);
+		defaultSpeedMap.put("Private Road - Restricted Access", 35);
+		defaultSpeedMap.put("Private Road - Publicly Accessible", 35);
+		defaultSpeedMap.put("Alley", 0);
+
+		// osgb:type
+		// vehicleQualifierTypeExclusions.add("Buses");
+		vehicleQualifierTypeExclusions.add("Coaches");
+		vehicleQualifierTypeExclusions.add("Mopeds");
+		vehicleQualifierTypeExclusions.add("Motor Cycles");
+		vehicleQualifierTypeExclusions.add("HGV's");
+		vehicleQualifierTypeExclusions.add("LGV's");
+		vehicleQualifierTypeExclusions.add("Towed Caravans");
+		vehicleQualifierTypeExclusions.add("Cycles");
+		vehicleQualifierTypeExclusions.add("Tracked Vehicles");
+		// osgb:use
+		vehicleQualifierTypeExclusions.add("Taxi");
+		vehicleQualifierTypeExclusions.add("Taxis"); // Added from analysing the actual data
+		vehicleQualifierTypeExclusions.add("School Bus");
+		vehicleQualifierTypeExclusions.add("Patron");
+		vehicleQualifierTypeExclusions.add("Access");
+		vehicleQualifierTypeExclusions.add("Resident");
+		vehicleQualifierTypeExclusions.add("Emergency Vehicle");
+		// vehicleQualifierTypeExclusions.add("Public Transport");
+		vehicleQualifierTypeExclusions.add("Authorised Vehicle");
+		// vehicleQualifierTypeExclusions.add("Local Bus");
+		// vehicleQualifierTypeExclusions.add("Local Buses"); // Added from analysing the actual
+		// data
+		vehicleQualifierTypeExclusions.add("Escorted Traffic");
+		vehicleQualifierTypeExclusions.add("Loading And Unloading"); // Added from analysing the
+																	 // actual data
+
+		vehicleQualifierTypeInclusions.add("Motor Vehicles");
+		vehicleQualifierTypeInclusions.add("All Vehicles");
+		// temp inclusions for testing
+		vehicleQualifierTypeInclusions.add("Buses");
+
+		vehicleQualifierTypeInclusions.add("Local Bus");
+		vehicleQualifierTypeInclusions.add("Local Buses");
+		vehicleQualifierTypeInclusions.add("Public Transport");
+
+	}
+
+	/**
+	 * Define the place of the speedBits in the edge flags for car.
+	 */
+	@Override
+	public int defineWayBits( int index, int shift )
+	{
+		// first two bits are reserved for route handling in superclass
+		shift = super.defineWayBits(index, shift);
+		speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor,
+		        defaultSpeedMap.get("secondary"), defaultSpeedMap.get("motorway"));
+		return shift + speedEncoder.getBits();
+	}
+
+	protected double getSpeed( Way way )
+	{
+		String highwayValue = way.getTag("highway");
+		Integer speed = defaultSpeedMap.get(highwayValue);
+		if (speed == null)
+			throw new IllegalStateException(toString() + ", no speed found for:" + highwayValue);
+
+		if (highwayValue.equals("track"))
+		{
+			String tt = way.getTag("tracktype");
+			if (!Helper.isEmpty(tt))
+			{
+				Integer tInt = trackTypeSpeedMap.get(tt);
+				if (tInt != null)
+					speed = tInt;
+			}
+		}
+
+		return speed;
+	}
+
+	@Override
+	public long acceptWay( Way way )
+	{
+		String highwayValue = way.getTag("highway");
+		if (highwayValue == null)
+		{
+			if (way.hasTag("route", ferries))
+			{
+				String motorcarTag = way.getTag("motorcar");
+				if (motorcarTag == null)
+					motorcarTag = way.getTag("motor_vehicle");
+
+				if (motorcarTag == null && !way.hasTag("foot") && !way.hasTag("bicycle")
+				        || "yes".equals(motorcarTag))
+					return acceptBit | ferryBit;
+			}
+			return 0;
+		}
+
+		if ("track".equals(highwayValue))
+		{
+			String tt = way.getTag("tracktype");
+			if (tt != null && !tt.equals("grade1"))
+				return 0;
+		}
+
+		if (!defaultSpeedMap.containsKey(highwayValue))
+			return 0;
+
+		if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
+			return 0;
+
+		// do not drive street cars into fords
+		boolean carsAllowed = way.hasTag(restrictions, intendedValues);
+		if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
+			return 0;
+
+		// check access restrictions
+		if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+			return 0;
+
+		// do not drive cars over railways (sometimes incorrectly mapped!)
+		if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
+			return 0;
+
+		return acceptBit;
+	}
+
+	@Override
+	public long handleWayTags( Way way, long allowed, long relationFlags )
+	{
+		if (!isAccept(allowed))
+			return 0;
+
+		long encoded;
+		if (!isFerry(allowed))
+		{
+			// get assumed speed from highway type
+			double speed = getSpeed(way);
+			speed = applyMaxSpeed(way, speed, true);
+
+			// limit speed to max 30 km/h if bad surface
+			if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
+				speed = 30;
+
+			encoded = setSpeed(0, speed);
+
+			boolean isRoundabout = way.hasTag("junction", "roundabout");
+			if (isRoundabout)
+				encoded = setBool(encoded, K_ROUNDABOUT, true);
+
+			if (way.hasTag("oneway", oneways) || isRoundabout)
+			{
+				if (way.hasTag("oneway", "-1"))
+					encoded |= backwardBit;
+				else
+					encoded |= forwardBit;
+			} else
+				encoded |= directionBitMask;
+
+		} else
+		{
+			encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"),
+			        defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
+			encoded |= directionBitMask;
+		}
+
+		return encoded;
+	}
+
+	public String getWayInfo( Way way )
+	{
+		String str = "";
+		String highwayValue = way.getTag("highway");
+		// for now only motorway links
+		if ("motorway_link".equals(highwayValue))
+		{
+			String destination = way.getTag("destination");
+			if (!Helper.isEmpty(destination))
+			{
+				int counter = 0;
+				for (String d : destination.split(";"))
+				{
+					if (d.trim().isEmpty())
+						continue;
+
+					if (counter > 0)
+						str += ", ";
+
+					str += d.trim();
+					counter++;
+				}
+			}
+		}
+		if (str.isEmpty())
+			return str;
+		// I18N
+		if (str.contains(","))
+			return "destinations: " + str;
+		else
+			return "destination: " + str;
+	}
+
+	@Override
+	public String toString()
+	{
+		return "bus";
+	}
+
+	@Override
+	public long handleRelationTags( Relation relation, long oldRelationFlags )
+	{
+		return oldRelationFlags;
+	}
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 2f4f4ab9d9..ef022992ae 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -30,7 +30,7 @@
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
  * <p>
- * 
+ *
  * @author Peter Karich
  * @author Nop
  */
@@ -65,7 +65,7 @@ public CarFlagEncoder()
 	public CarFlagEncoder( String propertiesStr )
 	{
 		this((int) parseLong(propertiesStr, "speedBits", 5), parseDouble(propertiesStr,
-		        "speedFactor", 5), parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+				"speedFactor", 5), parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
 		this.setBlockFords(parseBoolean(propertiesStr, "blockFords", true));
 	}
 
@@ -167,7 +167,7 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
 		vehicleQualifierTypeExclusions.add("Local Buses"); // Added from analysing the actual data
 		vehicleQualifierTypeExclusions.add("Escorted Traffic");
 		vehicleQualifierTypeExclusions.add("Loading And Unloading"); // Added from analysing the
-																	 // actual data
+		                                                             // actual data
 
 		vehicleQualifierTypeInclusions.add("Motor Vehicles");
 		vehicleQualifierTypeInclusions.add("All Vehicles");
@@ -228,7 +228,7 @@ public int defineWayBits( int index, int shift )
 		// first two bits are reserved for route handling in superclass
 		shift = super.defineWayBits(index, shift);
 		speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor,
-		        defaultSpeedMap.get("secondary"), maxPossibleSpeed);
+				defaultSpeedMap.get("secondary"), maxPossibleSpeed);
 		return shift + speedEncoder.getBits();
 	}
 
@@ -242,7 +242,7 @@ protected double getSpeed( Way way )
 			speed = defaultSpeedMap.get(highwayValue);
 			if (speed == null)
 				throw new IllegalStateException(toString() + ", no speed found for: "
-				        + highwayValue + ", tags: " + way);
+						+ highwayValue + ", tags: " + way);
 
 			if (highwayValue.equals("track"))
 			{
@@ -271,7 +271,7 @@ public long acceptWay( Way way )
 					motorcarTag = way.getTag("motor_vehicle");
 
 				if (motorcarTag == null && !way.hasTag("foot") && !way.hasTag("bicycle")
-				        || "yes".equals(motorcarTag))
+						|| "yes".equals(motorcarTag))
 					return acceptBit | ferryBit;
 			}
 			return 0;
@@ -334,7 +334,6 @@ public long handleWayTags( Way way, long allowed, long relationFlags )
 				String maxSpeed = environmentMaxSpeedMap.get(environment);
 				if (!Helper.isEmpty(maxSpeed))
 				{
-					// System.out.println(">>>>>>>>>>>>>>> Set max speed to " + maxSpeed);
 					way.setTag("maxspeed", maxSpeed);
 				}
 			}
@@ -350,14 +349,14 @@ public long handleWayTags( Way way, long allowed, long relationFlags )
 				encoded = setBool(encoded, K_ROUNDABOUT, true);
 
 			boolean isOneway = way.hasTag("oneway", oneways) || way.hasTag("vehicle:backward")
-			        || way.hasTag("vehicle:forward") || way.hasTag("motor_vehicle:backward")
-			        || way.hasTag("motor_vehicle:forward");
+					|| way.hasTag("vehicle:forward") || way.hasTag("motor_vehicle:backward")
+					|| way.hasTag("motor_vehicle:forward");
 
 			if (isOneway || isRoundabout)
 			{
 				boolean isBackward = way.hasTag("oneway", "-1")
-				        || way.hasTag("vehicle:forward", "no")
-				        || way.hasTag("motor_vehicle:forward", "no");
+						|| way.hasTag("vehicle:forward", "no")
+						|| way.hasTag("motor_vehicle:forward", "no");
 				if (isBackward)
 					encoded |= backwardBit;
 				else
@@ -368,7 +367,7 @@ public long handleWayTags( Way way, long allowed, long relationFlags )
 		} else
 		{
 			encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"),
-			        defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
+					defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
 			encoded |= directionBitMask;
 		}
 
diff --git a/core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java b/core/src/main/java/com/graphhopper/routing/util/EscapePrivateWeighting.java
similarity index 93%
rename from core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java
rename to core/src/main/java/com/graphhopper/routing/util/EscapePrivateWeighting.java
index 0751ed6efe..98d67923cb 100644
--- a/core/src/main/java/com/graphhopper/routing/EscapePrivateWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EscapePrivateWeighting.java
@@ -1,7 +1,5 @@
-package com.graphhopper.routing;
+package com.graphhopper.routing.util;
 
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java
index 9349376514..3cb551e0c7 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java
@@ -1,7 +1,6 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.Way;
-import com.graphhopper.routing.EscapePrivateWeighting;
 
 public class OsCarFlagEncoder extends CarFlagEncoder {
 	
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index 8f078d918d..c17e10b185 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -22,6 +22,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.when;
 
 import java.io.File;
 import java.io.IOException;
@@ -32,11 +33,26 @@
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.Mockito;
 
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.util.BanPrivateWeighting;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.EscapePrivateWeighting;
+import com.graphhopper.routing.util.FastestWeighting;
+import com.graphhopper.routing.util.FastestWithAvoidancesWeighting;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.PriorityWeighting;
+import com.graphhopper.routing.util.PriorityWithAvoidancesWeighting;
+import com.graphhopper.routing.util.ShortestWeighting;
+import com.graphhopper.routing.util.ShortestWithAvoidancesWeighting;
+import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.WeightingMap;
+import com.graphhopper.storage.AvoidanceAttributeExtension;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
@@ -543,4 +559,82 @@ public void testVia()
         assertEquals(5, rsp.getInstructions().size());
         assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().get(1).getSign());
     }
+    
+    @Test
+    public void testCreateWeightingWithoutPriority() {
+    	instance = new GraphHopper();
+        GraphStorage graph = Mockito.mock(GraphStorage.class);
+		instance.setGraph(graph );
+        GraphExtension avoidanceExtension = Mockito.mock(AvoidanceAttributeExtension.class);
+		when(graph.getExtension()).thenReturn(avoidanceExtension );
+        FlagEncoder encoder = Mockito.mock(FlagEncoder.class);
+		WeightingMap weightingMap = new WeightingMap("fastest");
+		Weighting createdWeighting = instance.createWeighting(weightingMap , encoder );
+		assertEquals(FastestWeighting.class, createdWeighting.getClass());
+		
+		weightingMap = new WeightingMap("shortest");
+		createdWeighting = instance.createWeighting(weightingMap , encoder );
+		assertEquals(ShortestWeighting.class, createdWeighting.getClass());
+		
+		weightingMap = new WeightingMap("fastest").put("avoidances", "cliff");
+		System.err.println("WEIGHTING" + weightingMap.get("avoidances", ""));
+		createdWeighting = instance.createWeighting(weightingMap , encoder );
+		assertEquals(FastestWithAvoidancesWeighting.class, createdWeighting.getClass());
+    
+		
+		weightingMap = new WeightingMap("shortest").put("avoidances", "cliff");
+		createdWeighting = instance.createWeighting(weightingMap , encoder );
+		assertEquals(ShortestWithAvoidancesWeighting.class, createdWeighting.getClass());
+    }
+    
+    @Test
+    public void testCreateWeightingWithPriority() {
+    	instance = new GraphHopper();
+        GraphStorage graph = Mockito.mock(GraphStorage.class);
+		instance.setGraph(graph );
+        GraphExtension avoidanceExtension = Mockito.mock(AvoidanceAttributeExtension.class);
+		when(graph.getExtension()).thenReturn(avoidanceExtension );
+        FlagEncoder encoder = Mockito.mock(FlagEncoder.class);
+        
+        when(encoder.supports(PriorityWeighting.class)).thenReturn(true);
+		WeightingMap weightingMap = new WeightingMap("fastest");
+		Weighting createdWeighting = instance.createWeighting(weightingMap , encoder );
+		assertEquals(PriorityWeighting.class, createdWeighting.getClass());
+		
+		weightingMap = new WeightingMap("shortest");
+		createdWeighting = instance.createWeighting(weightingMap , encoder );
+		assertEquals(ShortestWeighting.class, createdWeighting.getClass());
+		
+		weightingMap = new WeightingMap("fastest").put("avoidances", "cliff");
+		System.err.println("WEIGHTING" + weightingMap.get("avoidances", ""));
+		createdWeighting = instance.createWeighting(weightingMap , encoder );
+		assertEquals(PriorityWithAvoidancesWeighting.class, createdWeighting.getClass());
+    
+		
+		weightingMap = new WeightingMap("shortest").put("avoidances", "cliff");
+		createdWeighting = instance.createWeighting(weightingMap , encoder );
+		assertEquals(ShortestWithAvoidancesWeighting.class, createdWeighting.getClass());
+    }
+    
+    @Test
+    public void testCreatePrivateWeightingWithPriority() {
+    	instance = new GraphHopper();
+        GraphStorage graph = Mockito.mock(GraphStorage.class);
+        Weighting weighting = Mockito.mock(Weighting.class);
+        FlagEncoder supportedEncoder = Mockito.mock(FlagEncoder.class);
+        FlagEncoder unsupportedEncoder = Mockito.mock(FlagEncoder.class);
+        when(supportedEncoder.supports(EscapePrivateWeighting.class)).thenReturn(true);
+        when(unsupportedEncoder.supports(EscapePrivateWeighting.class)).thenReturn(false);
+		instance.setGraph(graph );
+		GHRequest request = new GHRequest();
+		Weighting privateWeighting = instance.createPrivateWeighting(weighting, request , graph, supportedEncoder);
+		assertEquals(EscapePrivateWeighting.class, privateWeighting.getClass());
+		
+		request.getHints().put("private", "false");
+		privateWeighting = instance.createPrivateWeighting(weighting, request , graph, supportedEncoder);
+		assertEquals(BanPrivateWeighting.class, privateWeighting.getClass());
+		
+		privateWeighting = instance.createPrivateWeighting(weighting, request , graph, unsupportedEncoder);
+		assertEquals(weighting.getClass(), privateWeighting.getClass());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java
index 920a09938e..807971e08b 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java
@@ -15,7 +15,6 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.osgb.itn.OsItnReader;
-import com.graphhopper.routing.EscapePrivateWeighting;
 import com.graphhopper.routing.util.AbstractFlagEncoder;
 import com.graphhopper.routing.util.BikeFlagEncoder;
 import com.graphhopper.routing.util.BusFlagEncoder;
@@ -23,6 +22,7 @@
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.EscapePrivateWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.Graph;
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
index a794e2dc3f..31330b8cb8 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
@@ -167,7 +167,7 @@ protected InstructionList route(GraphHopper graphHopper, double lat1, double lon
         GHRequest ghRequest = new GHRequest(start, end);
         ghRequest.setVehicle("foot");
         if (null != avoid && !Helper.isEmpty(avoid)) {
-            ghRequest.setWeighting("fastavoid");
+            ghRequest.setWeighting("fastest");
             ghRequest.getHints().put("avoidances", avoid);
         }
         GHResponse ghResponse = graphHopper.route(ghRequest);
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/dpn/rightOfWay/BridleWayTest.java b/core/src/test/java/com/graphhopper/reader/osgb/dpn/rightOfWay/BridleWayTest.java
index 71d2089282..2684322f44 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/dpn/rightOfWay/BridleWayTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/dpn/rightOfWay/BridleWayTest.java
@@ -32,7 +32,6 @@ public void init() {
     public void testVisitWayAttribute() {
         visitor.visitWayAttribute("bridleway", way);
         verify(way).setTag("designation", "public_bridleway");
-        verify(way).setTag("highway", "bridleway");
         verify(way).setTag("foot", "yes");
         verify(way).setTag("horse", "yes");
         verify(way).setTag("bicycle", "yes");
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/dpn/rightOfWay/FootpathTest.java b/core/src/test/java/com/graphhopper/reader/osgb/dpn/rightOfWay/FootpathTest.java
index 56cf2206b2..249a368090 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/dpn/rightOfWay/FootpathTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/dpn/rightOfWay/FootpathTest.java
@@ -32,7 +32,6 @@ public void init() {
     public void testVisitWayAttribute() {
         visitor.visitWayAttribute("footpath", way);
         verify(way).setTag("designation", "public_footpath");
-        verify(way).setTag("highway", "footway");
         verify(way).setTag("foot", "yes");
         verifyNoMoreInteractions(way);
     }
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 34c0f1bf3d..fbfccc7d24 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -33,6 +33,7 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EmergencyVehicleFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.EscapePrivateWeighting;
 import com.graphhopper.routing.util.FastestWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.ShortestWeighting;
diff --git a/core/src/test/java/com/graphhopper/routing/util/BanPrivateWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/BanPrivateWeightingTest.java
new file mode 100644
index 0000000000..099b6111eb
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/BanPrivateWeightingTest.java
@@ -0,0 +1,60 @@
+package com.graphhopper.routing.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class BanPrivateWeightingTest {
+	@Mock
+	FlagEncoder encoder;
+	
+	@Mock
+	Weighting innerWeighting;
+	
+	@Mock
+	EdgeIteratorState edge;
+	
+	@Before
+	public void configureMocks() {
+		MockitoAnnotations.initMocks(this);
+		configureInner();
+	}
+
+	@Test
+	public void testAllowNonPrivate() {
+		when(encoder.getLong(anyLong(), eq(EscapePrivateWeighting.KEY))).thenReturn(0L);
+		BanPrivateWeighting weighting = new BanPrivateWeighting(encoder, innerWeighting);
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertEquals("Traversable Edges should have innerweightings weight", 10D, (weighting.calcWeight(edge, reverse , prevOrNextEdgeId)),0);
+	}
+	
+	@Test
+	public void testDisallowPrivate() {
+		when(encoder.getLong(anyLong(), eq(EscapePrivateWeighting.KEY))).thenReturn(1L);
+		BanPrivateWeighting weighting = new BanPrivateWeighting(encoder, innerWeighting);
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Private Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+
+	/**
+	 * Sets up :-
+	 *  inner weighting so only effect of BanPrivateWeighting should stop access
+	 */
+	private void configureInner() {
+		when(innerWeighting.calcWeight((EdgeIteratorState)any(),anyBoolean(),anyInt())).thenReturn(10D);
+	}
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoderTest.java
index c25c4aadc5..0d7fd3e039 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoderTest.java
@@ -187,7 +187,7 @@ public void testMaxSpeed()
         way.setTag("maxspeed", "500");
         long allowed = encoder.acceptWay(way);
         long encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
+        assertEquals(110, encoder.getSpeed(encoded), 1e-1);
 
         way = new OSMWay(1);
         way.setTag("highway", "primary");
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 78da9f1895..117d67ebaa 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -65,12 +65,12 @@
 	protected boolean internalErrorsAllowed;
 
 	protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONObject json )
-	        throws JSONException, IOException
+			throws JSONException, IOException
 	{
 		String type = getParam(req, "type", "json");
 		res.setCharacterEncoding("UTF-8");
 		boolean debug = getBooleanParam(req, "debug", false)
-		        || getBooleanParam(req, "pretty", false);
+				|| getBooleanParam(req, "pretty", false);
 		if ("jsonp".equals(type))
 		{
 			res.setContentType("application/javascript");
@@ -178,8 +178,8 @@ protected double getDoubleParam( HttpServletRequest req, String string, double _
 	}
 
 	protected List<GHPoint> getPoints( HttpServletRequest req, String key )
-	        throws InvalidParameterException
-	{
+			throws InvalidParameterException
+			{
 		String[] pointsAsStr = getParams(req, key);
 		final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
 		for (String str : pointsAsStr)
@@ -190,18 +190,19 @@ protected double getDoubleParam( HttpServletRequest req, String string, double _
 				infoPoints.add(point);
 			} else
 			{
+				System.out.println("Throw an exception");
 				throw new InvalidParameterException(
-				        "Point "
-				                + str
-				                + " is not a valid point. Point must be a comma separated coordinate in WGS84 projection.");
+						"Point "
+								+ str
+								+ " is not a valid point. Point must be a comma separated coordinate in WGS84 projection.");
 			}
 		}
 
 		return infoPoints;
-	}
+			}
 
 	protected void processResponseErrors( GHResponse rsp, Map<String, Object> json,
-			boolean internalErrorsAllowed )
+	        boolean internalErrorsAllowed )
 	{
 		if (rsp.hasErrors())
 		{
@@ -232,7 +233,7 @@ protected void processResponseErrors( GHResponse rsp, Map<String, Object> json,
 	}
 
 	protected String createGPXString( HttpServletRequest req, HttpServletResponse res,
-			GHResponse rsp )
+	        GHResponse rsp )
 	{
 		boolean includeElevation = getBooleanParam(req, "elevation", false);
 		res.setCharacterEncoding("UTF-8");
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
index 4e910d80da..f4db15496c 100644
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -33,12 +33,15 @@
 	protected Map<String, String> params = new HashMap<String, String>();
 	protected final CmdArgs args;
 
+	public static String INVALID_REGEX1 = "^((?![.]html|css|js|png|gif).)*$";
+	public static String INVALID_REGEX2 = "([^\\/])";
+
 	public GHServletModule( CmdArgs args )
 	{
 		this.args = args;
 		params.put("mimeTypes", "text/html," + "text/plain," + "text/xml,"
-		        + "application/xhtml+xml," + "text/css," + "application/json,"
-		        + "application/javascript," + "image/svg+xml");
+				+ "application/xhtml+xml," + "text/css," + "application/json,"
+				+ "application/javascript," + "image/svg+xml");
 	}
 
 	@Override
@@ -52,14 +55,18 @@ protected void configureServlets()
 
 		filter("*").through(IPFilter.class);
 		bind(IPFilter.class).toInstance(
-		        new IPFilter(args.get("jetty.whiteips", ""), args.get("jetty.blackips", "")));
+				new IPFilter(args.get("jetty.whiteips", ""), args.get("jetty.blackips", "")));
+
+		// Convert all parameters to lower case
+		filter("*").through(LowerCaseParameterFilter.class, params);
+		bind(LowerCaseParameterFilter.class).in(Singleton.class);
 
 		serve("/i18n", "/i18n/").with(I18NServlet.class);
 		bind(I18NServlet.class).in(Singleton.class);
 
 		serve("/info", "/info/").with(InfoServlet.class);
 		bind(InfoServlet.class).in(Singleton.class);
-		//
+
 		serve("/route", "/route/").with(GraphHopperServlet.class);
 		bind(GraphHopperServlet.class).in(Singleton.class);
 
@@ -71,8 +78,8 @@ protected void configureServlets()
 		serve("/nearest", "/nearest/").with(NearestServlet.class);
 		bind(NearestServlet.class).in(Singleton.class);
 
-		// Serve files that don't contain cetain file extensions
-		serveRegex("^((?![.]html|css|js|png|gif).)*$").with(InvalidRequestServlet.class);
+		// Serve files that don't contain certain file extensions
+		serveRegex(INVALID_REGEX1).with(InvalidRequestServlet.class);
 		bind(InvalidRequestServlet.class).in(Singleton.class);
 	}
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 5ab2336158..b6c0a56855 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -46,7 +46,6 @@
 import com.graphhopper.routing.util.AbstractFlagEncoder;
 import com.graphhopper.routing.util.EncoderDecorator;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.InstructionList;
@@ -73,13 +72,13 @@
 
 	@Override
 	public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
-	        throws ServletException, IOException
+			throws ServletException, IOException
 	{
 		getGHResponse(httpReq, httpRes);
 	}
 
 	public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse httpRes )
-	        throws JSONException, IOException
+			throws JSONException, IOException
 	{
 		boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
 		double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
@@ -91,7 +90,7 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 		String vehicleStr = getParam(httpReq, "vehicle", null);
 		String weighting = getParam(httpReq, "weighting", "fastest");
 		String algoStr = getParam(httpReq, "algorithm", null);
-		String localeStr = getParam(httpReq, "locale", "en").replace('-', '_');
+		String localeStr = getParam(httpReq, "locale", "en_GB").replace('-', '_');
 
 		StopWatch sw = new StopWatch().start();
 
@@ -104,46 +103,41 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 		String noThroughAccessString = getParam(httpReq, "private", "true");
 
 		GHResponse ghRsp = null;
-		List<GHPoint> infoPoints;
+		List<GHPoint> infoPoints = null;
 
 		try
 		{
 			infoPoints = getPoints(httpReq, "point");
-		} catch (InvalidParameterException e)
-		{
-			return new GHResponse().addError(e);
-		}
 
-		try
-		{
 			ApiResource.ROUTE.checkAllRequestParameters(httpReq);
 
 			// we can reduce the path length based on the maximum differences to the original
 			// coordinates
 
 			if (!new CaseInsensitiveStringListValidator()
-			        .isValid(localeStr, TranslationMap.LOCALES))
+			.isValid(localeStr, TranslationMap.LOCALES))
 			{
 				String errMesg = buildErrorMessageString(localeStr, "locale",
-				        TranslationMap.LOCALES);
+						TranslationMap.LOCALES);
 				ghRsp = new GHResponse()
-				        .addError(new InvalidParameterException(errMesg.toString()));
+				.addError(new InvalidParameterException(errMesg.toString()));
 			} else if (null != algoStr
-			        && !new CaseInsensitiveStringListValidator().isValid(algoStr,
-			                AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
-			                AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
-			                AlgorithmOptions.DIJKSTRA_ONE_TO_MANY))
+					&& !new CaseInsensitiveStringListValidator().isValid(algoStr,
+							AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
+							AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
+							AlgorithmOptions.DIJKSTRA_ONE_TO_MANY))
 			{
 				String errMesg = buildErrorMessageString(algoStr, "algorithm",
-				        AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
-				        AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
-				        AlgorithmOptions.DIJKSTRA_ONE_TO_MANY);
+						AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
+						AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
+						AlgorithmOptions.DIJKSTRA_ONE_TO_MANY);
 				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (null != weighting
-			        && !new CaseInsensitiveStringListValidator().isValid(weighting,
-			                "fastest","shortest" ))
+					&& !new CaseInsensitiveStringListValidator().isValid(weighting, "fastest",
+			                "shortest"))
 			{
-				String errMesg = buildErrorMessageString(weighting, "weighting","fastest","shortest");
+				String errMesg = buildErrorMessageString(weighting, "weighting", "fastest",
+				        "shortest");
 				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (!new BooleanValidator().isValid(instructionsString))
 			{
@@ -152,7 +146,7 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 			} else if (!new BooleanValidator().isValid(pointsEncodedString))
 			{
 				String errMesg = buildBooleanErrorMessageString(pointsEncodedString,
-				        "points_encoded");
+						"points_encoded");
 				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (!new BooleanValidator().isValid(calcPointsString))
 			{
@@ -170,18 +164,18 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 			{
 				String supported = hopper.getGraph().getEncodingManager().toString();
 				String errMesg = String.format(
-				        "Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr,
-				        supported);
+						"Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr,
+						supported);
 				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-			} else if (!new BooleanValidator().isValid(noThroughAccessString)) 
+			} else if (!new BooleanValidator().isValid(noThroughAccessString))
 			{
 				String errMesg = buildBooleanErrorMessageString(noThroughAccessString, "private");
 				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
-			
+
 			} else if (enableElevation && !hopper.hasElevation())
 			{
 				ghRsp = new GHResponse().addError(new InvalidParameterException(
-				        "Elevation not supported!"));
+						"Elevation not supported!"));
 			} else
 			{
 				FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
@@ -195,7 +189,7 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 					{
 						AbstractFlagEncoder abstractFlagEncoder = (AbstractFlagEncoder) algoVehicle;
 						List<EncoderDecorator> encoderDecorators = abstractFlagEncoder
-						        .getEncoderDecorators();
+								.getEncoderDecorators();
 						if (encoderDecorators != null)
 						{
 							for (EncoderDecorator encoderDecorator : encoderDecorators)
@@ -204,8 +198,8 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 								{
 									AbstractAvoidanceDecorator abstractAvoidanceDecorator = (AbstractAvoidanceDecorator) encoderDecorator;
 									allowedAvoidances.addAll(Arrays
-									        .asList(abstractAvoidanceDecorator
-									                .getEdgeAttributesOfInterestNames()));
+											.asList(abstractAvoidanceDecorator
+													.getEdgeAttributesOfInterestNames()));
 								}
 							}
 						}
@@ -216,9 +210,9 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 						if (!allowedAvoidances.contains(avoidance.trim()))
 						{
 							String errMesg = buildErrorMessageString(avoidance, "avoidances",
-							        allowedAvoidances);
+									allowedAvoidances);
 							ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg
-							        .toString()));
+									.toString()));
 						}
 					}
 				}
@@ -229,32 +223,31 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 
 					initHints(request, httpReq.getParameterMap());
 					request.setVehicle(algoVehicle.toString()).setWeighting(weighting)
-					        .setAlgorithm(algoStr).setLocale(localeStr).getHints()
-					        .put("calcPoints", calcPoints).put("instructions", enableInstructions)
-					        .put("wayPointMaxDistance", minPathPrecision);
+					.setAlgorithm(algoStr).setLocale(localeStr).getHints()
+					.put("calcPoints", calcPoints).put("instructions", enableInstructions)
+					.put("wayPointMaxDistance", minPathPrecision);
 					ghRsp = hopper.route(request);
 				}
 			}
-		} catch (NoSuchParameterException | MissingParameterException | InvalidParameterException e)
+		} catch (Exception e)
 		{
 			ghRsp = new GHResponse().addError(e);
 		} finally
 		{
-
 			float took = sw.stop().getSeconds();
 			String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " "
-			        + httpReq.getHeader("User-Agent");
+					+ httpReq.getHeader("User-Agent");
 			String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
-			        + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+					+ took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
 
-			if (ghRsp.hasErrors()) {
+			if (ghRsp.hasErrors())
+			{
 				logger.error(logStr + ", errors:" + ghRsp.getErrors());
 				logger.info("GraphHopperServlet.getGHResponse(ERROR)");
-			}
-			else
+			} else
 				logger.info(logStr + ", distance: " + ghRsp.getDistance() + ", time:"
-				        + Math.round(ghRsp.getTime() / 60000f) + "min, points:"
-				        + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
+						+ Math.round(ghRsp.getTime() / 60000f) + "min, points:"
+						+ ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
 
 			if (writeGPX)
 			{
@@ -268,19 +261,17 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 			} else
 			{
 				String type = getParam(httpReq, "type", "json");
-				System.err.println("TYPE:" + type) ;
 				if (!"json".equalsIgnoreCase(type)
-				        || (!"jsonp".equalsIgnoreCase(type) && jsonpAllowed))
+						|| (!"jsonp".equalsIgnoreCase(type) && jsonpAllowed))
 				{
 					String errorMessage = type
-					        + " is not a valid value for parameter type. Valid values are ";
+							+ " is not a valid value for parameter type. Valid values are ";
 					errorMessage += jsonpAllowed ? "JSON, GPX or JSONP." : "GPX or JSON.";
 					ghRsp.addError(new InvalidParameterException(errorMessage));
 				}
-				logger.info("GraphHopperServlet.getGHResponse("+ enableInstructions
-						+ ")");
+				logger.info("GraphHopperServlet.getGHResponse(" + enableInstructions + ")");
 				Map<String, Object> map = createJson(ghRsp, calcPoints, pointsEncoded,
-				        enableElevation, enableInstructions);
+						enableElevation, enableInstructions);
 				Object infoMap = map.get("info");
 				if (infoMap != null)
 					((Map) infoMap).put("took", Math.round(took * 1000));
@@ -301,21 +292,21 @@ public GHResponse getGHResponse( HttpServletRequest httpReq, HttpServletResponse
 	private String buildBooleanErrorMessageString( String paramValue, String paramName )
 	{
 		return buildErrorMessageString(paramValue, paramName,
-		        Arrays.asList(new String[] { Boolean.TRUE.toString(), Boolean.FALSE.toString() }));
+				Arrays.asList(new String[] { Boolean.TRUE.toString(), Boolean.FALSE.toString() }));
 	}
 
 	private String buildErrorMessageString( String paramValue, String paramName,
-	        String... validValues )
+			String... validValues )
 	{
 		return buildErrorMessageString(paramValue, paramName, Arrays.asList(validValues));
 	}
 
 	private String buildErrorMessageString( String paramValue, String paramName,
-	        List<String> validValues )
+			List<String> validValues )
 	{
 		StringBuilder errMesg = new StringBuilder(paramValue)
-		        .append(" is not a valid value for parameter ").append(paramName)
-		        .append(". Valid values are ");
+		.append(" is not a valid value for parameter ").append(paramName)
+		.append(". Valid values are ");
 		for (int i = 0; i < validValues.size(); i++)
 		{
 			String validStr = validValues.get(i);
@@ -333,8 +324,8 @@ private String buildErrorMessageString( String paramValue, String paramName,
 	}
 
 	protected Map<String, Object> createJson( GHResponse rsp, boolean calcPoints,
-	        boolean pointsEncoded, boolean includeElevation, boolean enableInstructions )
-	{
+			boolean pointsEncoded, boolean includeElevation, boolean enableInstructions )
+			{
 		Map<String, Object> json = new HashMap<String, Object>();
 
 		if (rsp.hasErrors())
@@ -361,7 +352,7 @@ private String buildErrorMessageString( String paramValue, String paramName,
 				{
 					BBox maxBounds = hopper.getGraph().getBounds();
 					BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon,
-					        maxBounds.minLat, maxBounds.maxLat);
+							maxBounds.minLat, maxBounds.maxLat);
 					jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
 				}
 
@@ -376,7 +367,7 @@ private String buildErrorMessageString( String paramValue, String paramName,
 			json.put("paths", Collections.singletonList(jsonPath));
 		}
 		return json;
-	}
+			}
 
 	protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
 	{
diff --git a/web/src/main/java/com/graphhopper/http/LowerCaseParameterFilter.java b/web/src/main/java/com/graphhopper/http/LowerCaseParameterFilter.java
new file mode 100644
index 0000000000..48c9abbf99
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/LowerCaseParameterFilter.java
@@ -0,0 +1,118 @@
+package com.graphhopper.http;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.FilterConfig;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletRequestWrapper;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Servlet Filter to convert all request parameters into lower case
+ *
+ * @author phopkins
+ *
+ */
+public class LowerCaseParameterFilter implements Filter
+{
+
+	protected static Logger LOG = LoggerFactory.getLogger(LowerCaseParameterFilter.class);
+
+	protected static class LowerCaseRequest extends HttpServletRequestWrapper
+	{
+
+		private Map<String, String[]> lowerCaseParams = new HashMap<>();
+
+		public LowerCaseRequest( final HttpServletRequest request )
+		{
+			super(request);
+			Map<String, String[]> orignalParams = request.getParameterMap();
+			for (String name : orignalParams.keySet())
+			{
+				String lower = name.toLowerCase();
+				if (!lowerCaseParams.containsKey(lower))
+				{
+					lowerCaseParams.put(lower, new String[0]);
+				}
+				lowerCaseParams.put(lower,
+						concat(lowerCaseParams.get(lower), orignalParams.get(name)));
+			}
+		}
+
+		@Override
+		public Map<String, String[]> getParameterMap()
+		{
+
+			return Collections.unmodifiableMap(lowerCaseParams);
+		}
+
+		@Override
+		public String getParameter( final String name )
+		{
+			String[] values = getParameterValues(name);
+			if (values != null)
+			{
+				return values[0];
+			} else
+			{
+				return null;
+			}
+		}
+
+		@Override
+		public Enumeration<String> getParameterNames()
+		{
+			return Collections.enumeration(lowerCaseParams.keySet());
+		}
+
+		@Override
+		public String[] getParameterValues( final String name )
+		{
+			return lowerCaseParams.get(name);
+		}
+
+		public static <T> T[] concat( T[] first, T[] second )
+		{
+			T[] result = Arrays.copyOf(first, first.length + second.length);
+			System.arraycopy(second, 0, result, first.length, second.length);
+			return result;
+		}
+	}
+
+	@Override
+	public void doFilter( final ServletRequest request, final ServletResponse response,
+			final FilterChain chain ) throws IOException, ServletException
+	{
+		if (request instanceof HttpServletRequest)
+		{
+			chain.doFilter(new LowerCaseRequest((HttpServletRequest) request), response);
+		} else
+		{
+			chain.doFilter(request, response);
+		}
+	}
+
+	@Override
+	public void init( FilterConfig filterConfig ) throws ServletException
+	{
+
+	}
+
+	@Override
+	public void destroy()
+	{
+
+	}
+}
\ No newline at end of file
diff --git a/web/src/main/webapp/index.html b/web/src/main/webapp/index.html
index 53544259f1..5481be6886 100644
--- a/web/src/main/webapp/index.html
+++ b/web/src/main/webapp/index.html
@@ -56,6 +56,15 @@
                             </tr> 
                             <tr><td><input class="weighting" type="radio" name="weighting" value="fastest" >Fastest  
                             </td></tr><tr><td><input class="weighting" type="radio" name="weighting" value="shortest" >Shortest
+                            </td></tr>
+                           </table>
+                        <table>
+                        <table>
+                            <tr>
+                                <th>Private Access Allowed For Normal Cars</th>
+                            </tr> 
+                            <tr><td><input class="access" type="radio" name="access" value="allow" >Start/End Allowed
+                            </td></tr><tr><td><input class="access" type="radio" name="access" value="disallow" >Start/End Not Allowed
                            </td></tr>
                            </table>
                         <table>
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index 5e8c5d4535..61f18979e3 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -453,14 +453,13 @@ GHRequest.prototype.createPath = function (url) {
     	this.weighting = "fastest";
     }
     if(checkedValue.length>0) {
-    	if(this.weighting==="fastest") {
-    		this.weighting = "fastavoid";
-    	}
-    	else {
-    		this.weighting="shortavoid";
-    	}
     	url += "&avoidances=" + checkedValue;
     }
+    if(document.routeoptions.access[1].checked == true){
+    	this.access = "false";
+    } else {
+    	this.access = "true";
+    }
     
     if (this.weighting && this.weighting !== "fastest")
         url += "&weighting=" + this.weighting;
@@ -480,6 +479,8 @@ GHRequest.prototype.createPath = function (url) {
         url += "&elevation=true";
     if (this.debug)
         url += "&debug=true";
+    if (this.access  && this.access !== "true")
+        url += "&private=false";
 
     for (var key in this.api_params) {
         url += "&" + key + "=" + this.api_params[key];
diff --git a/web/src/main/webapp/js/main-bng.js b/web/src/main/webapp/js/main-bng.js
index 52abe2d0ef..7c4a120fde 100644
--- a/web/src/main/webapp/js/main-bng.js
+++ b/web/src/main/webapp/js/main-bng.js
@@ -422,6 +422,12 @@ function getTopLeftCorners() {
         continuousWorld: true,
         attribution: '&copy; <a href="http://os.uk/">Ordnance Survey</a> '
      });
+    
+    var osLeisure = new L.TileLayer(url + '?height=256&width=256&tilematrixSet=EPSG%3A27700&version=1.0.0&style=&layer=Raster ZoomMap&SERVICE=WMTS&REQUEST=GetTile&format=image/png&TileMatrix=EPSG:27700:{z}&TileRow={y}&TileCol={x}',{
+        tileSize: 256,
+        continuousWorld: true,
+        attribution: '&copy; <a href="http://os.uk/">Ordnance Survey</a> '
+     });
 
     var lyrk = L.tileLayer('https://tiles.lyrk.org/' + tp + '/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077', {
         attribution: osmAttr + ', <a href="https://geodienste.lyrk.de/">Lyrk</a>',
@@ -482,7 +488,8 @@ function getTopLeftCorners() {
 
     var baseMaps = {
     	"OS Classic": osClassic,
-    	"OS Consumer": osConsumer
+    	"OS Consumer": osConsumer,
+    	"OS Leisure": osLeisure
     };
 
     var defaultLayer = baseMaps[selectLayer];
@@ -1246,7 +1253,7 @@ function addInstruction(main, instr, instrIndex, lngLat) {
 
     if (sign !== "continue") {
         var indiPic = "<img class='pic' style='vertical-align: middle' src='" +
-                window.location.pathname + "img/" + sign + ".png'/>";
+                window.location.pathname.replace('index.html','') + "img/" + sign + ".png'/>";
         str = "<td class='instr_pic'>" + indiPic + "</td>" + str;
     } else
         str = "<td class='instr_pic'/>" + str;
diff --git a/web/src/test/java/com/graphhopper/http/LowerCaseParameterFilterTest.java b/web/src/test/java/com/graphhopper/http/LowerCaseParameterFilterTest.java
new file mode 100644
index 0000000000..46656639ac
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/LowerCaseParameterFilterTest.java
@@ -0,0 +1,168 @@
+package com.graphhopper.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Matchers;
+import org.mockito.Mockito;
+
+public class LowerCaseParameterFilterTest
+{
+
+	private HttpServletRequest originalRequest;
+
+	@Before
+	public void setup()
+	{
+		originalRequest = Mockito.mock(HttpServletRequest.class);
+	}
+
+	@Test
+	public void testLowerCaseRequest_singlePoint()
+	{
+		Map<String, String[]> origParameters = new HashMap<>();
+		origParameters.put("POINT", new String[] { "123,456" });
+		when(originalRequest.getParameterMap()).thenReturn(origParameters);
+
+		LowerCaseParameterFilter.LowerCaseRequest request = new LowerCaseParameterFilter.LowerCaseRequest(
+		        originalRequest);
+		Map<String, String[]> resultParameters = request.getParameterMap();
+		// Check the original value is no longer there
+		assertNull(resultParameters.get("POINT"));
+		// Check that the lower case value is as expected
+		assertNotNull(resultParameters.get("point"));
+		assertEquals(1, resultParameters.get("point").length);
+		assertEquals("123,456", resultParameters.get("point")[0]);
+	}
+
+	@Test
+	public void testLowerCaseRequest_multiPoint()
+	{
+		Map<String, String[]> origParameters = new HashMap<>();
+		origParameters.put("POINT", new String[] { "123,456" });
+		origParameters.put("pOiNt", new String[] { "789,321" });
+		when(originalRequest.getParameterMap()).thenReturn(origParameters);
+
+		LowerCaseParameterFilter.LowerCaseRequest request = new LowerCaseParameterFilter.LowerCaseRequest(
+		        originalRequest);
+		Map<String, String[]> resultParameters = request.getParameterMap();
+		assertNull(resultParameters.get("POINT"));
+		assertNull(resultParameters.get("pOiNt"));
+
+		assertNotNull(resultParameters.get("point"));
+		assertEquals(2, resultParameters.get("point").length);
+		assertEquals("123,456", resultParameters.get("point")[0]);
+		assertEquals("789,321", resultParameters.get("point")[1]);
+	}
+
+	@Test
+	public void testLowerCaseRequest_getParameterValues()
+	{
+		Map<String, String[]> origParameters = new HashMap<>();
+		origParameters.put("POINT", new String[] { "123,456" });
+		origParameters.put("pOiNt", new String[] { "789,321" });
+		when(originalRequest.getParameterMap()).thenReturn(origParameters);
+
+		LowerCaseParameterFilter.LowerCaseRequest request = new LowerCaseParameterFilter.LowerCaseRequest(
+				originalRequest);
+		assertNull(request.getParameterValues("POINT"));
+		assertNull(request.getParameterValues("pOiNt"));
+
+		assertNotNull(request.getParameterValues("point"));
+		String[] parameterValues = request.getParameterValues("point");
+
+		assertEquals(2, parameterValues.length);
+		assertEquals("123,456", parameterValues[0]);
+		assertEquals("789,321", parameterValues[1]);
+	}
+
+	@Test
+	public void testLowerCaseRequest_getParameterNames()
+	{
+		Map<String, String[]> origParameters = new HashMap<>();
+		origParameters.put("POINT", new String[] { "123,456" });
+		when(originalRequest.getParameterMap()).thenReturn(origParameters);
+
+		LowerCaseParameterFilter.LowerCaseRequest request = new LowerCaseParameterFilter.LowerCaseRequest(
+		        originalRequest);
+
+		Enumeration<String> enumer = request.getParameterNames();
+
+		assertTrue(enumer.hasMoreElements());
+		assertEquals("point", enumer.nextElement());
+		assertFalse(enumer.hasMoreElements());
+	}
+
+	@Test
+	public void testLowerCaseRequest_concat()
+	{
+		String[] result = LowerCaseParameterFilter.LowerCaseRequest.concat(
+		        new String[] { "123,456" }, new String[] { "789,321" });
+		assertNotNull(result);
+		assertEquals(2, result.length);
+		assertEquals("123,456", result[0]);
+		assertEquals("789,321", result[1]);
+	}
+
+	/**
+	 * When a HttpServletRequest is passed into LowerCaseParameterFilter.doFilter the
+	 * FilterChain.doFilter method will get passed a LowerCaseParameterFilter.LowerCaseRequest
+	 *
+	 * @throws IOException
+	 * @throws ServletException
+	 */
+	@Test
+	public void testLowerCaseParameterFilter_doFilter_HttpServletRequest() throws IOException,
+	        ServletException
+	{
+		LowerCaseParameterFilter filter = new LowerCaseParameterFilter();
+		FilterChain filterChainMock = Mockito.mock(FilterChain.class);
+
+		filter.doFilter(originalRequest, null, filterChainMock);
+
+		verify(filterChainMock).doFilter(
+				Matchers.isA(LowerCaseParameterFilter.LowerCaseRequest.class),
+				(ServletResponse) Matchers.any());
+	}
+
+	/**
+	 * When a not HttpServletRequest is passed into LowerCaseParameterFilter.doFilter the
+	 * FilterChain.doFilter method will get passed the servletRequest passed to the
+	 * LowerCaseParameterFilter.doFilter method
+	 *
+	 * @throws IOException
+	 * @throws ServletException
+	 */
+	@Test
+	public void testLowerCaseParameterFilter_doFilter_ServletRequest() throws IOException,
+	        ServletException
+	{
+		LowerCaseParameterFilter filter = new LowerCaseParameterFilter();
+		ServletRequest servletRequest = Mockito.mock(ServletRequest.class);
+		FilterChain filterChainMock = Mockito.mock(FilterChain.class);
+
+		filter.doFilter(servletRequest, null, filterChainMock);
+
+		verify(filterChainMock).doFilter(Matchers.eq(servletRequest),
+				(ServletResponse) Matchers.any());
+	}
+
+}
