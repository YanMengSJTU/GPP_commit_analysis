diff --git a/.gitignore b/.gitignore
index 3510c9e6d2..83ce38371f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,22 +1,17 @@
 target/
 *~
-*largeEWD.txt.gz
 TODO.txt
 *-gh/
 *.osm
-docs/
 nbactions-*.xml
 config.properties
 build.xml
 queries.sh
 maven/
 measurement*.properties
-live_graphhopper.sh
 gen/
 bin/
 *.map
-scripts/googlecode_upload.py
-deploy.sh
 android/libs/graphhopper-*-android.jar
 */nbactions.xml
 .idea/
@@ -25,4 +20,16 @@ debug.sh
 *.pbf
 *.dem
 *.log
-core/TODO*.txt
\ No newline at end of file
+core/TODO*.txt
+srtmprovider/
+core/docs/
+.*#
+cgiarprovider/
+/nbactions.xml
+tools/nb-configuration.xml
+android/build/
+android/app/build/
+android/.gradle
+.settings/
+.classpath
+.project
diff --git a/.travis.yml b/.travis.yml
index 3ba3964d7f..178e6f4a75 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,12 +1,14 @@
 language: java
 jdk:
   - openjdk7
-  - openjdk6
   - oraclejdk7
-# fails with GZIPInputStream creation (readHeader)  - oraclejdk8
+  - oraclejdk8
 # do not install anything instead return true via unix command true
 install: true
 script: ./core/files/travis-build.sh
 notifications:
   email:
-    - github@graphhopper.com
\ No newline at end of file
+    - github@graphhopper.com
+
+# enable container-based stack
+sudo: false
\ No newline at end of file
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index d95203c129..4ce4c879f4 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,24 +1,36 @@
 Submit a new issue only if you are sure it is a missing feature or a bug. Otherwise discuss the topic on the 
-[mailing list](http://graphhopper.com/#developers) first.
+[mailing list](http://graphhopper.com/#developers) first. For new translations or fixes to existing translations
+please refer to [this documentation](https://github.com/graphhopper/graphhopper/blob/master/docs/core/translations.md).
 
-We love pull requests. Here's a quick guide:
+Issues for newcomers are tagged with 
+['good first issue'](https://github.com/graphhopper/graphhopper/labels/good%20first%20issue) 
+and documentation issues are taged with 
+['documentation'](https://github.com/graphhopper/graphhopper/labels/documentation).
 
-1. [Fork the repo](https://help.github.com/articles/fork-a-repo), optionally create a feature branch
+## We love pull requests. Here's a quick guide:
 
-2. Run the tests. We only take pull requests with passing tests: `mvn test`
+1. [Fork the repo](https://help.github.com/articles/fork-a-repo) and create a branch for your new feature or bug fix.
 
-3. Add a test for your change. Only refactoring and documentation changes
-require no new tests. If you are adding functionality or fixing a bug, we need
-a test!
+2. Run the tests. We only take pull requests with passing tests: `mvn clean test verify`
 
-4. Make the test pass.
+3. Add at least one test for your change. Only refactoring and documentation changes
+require no new tests. Also make sure you submit a change specific to exactly one issue. If you have ideas for multiple 
+changes please create separate pull requests.
 
-5. Push to your fork and [submit a pull request](https://help.github.com/articles/using-pull-requests)
+4. Make the test(s) pass.
 
+5. Push to your fork and [submit a pull request](https://help.github.com/articles/using-pull-requests). A button should
+appear on your fork its github page afterwards.
 
-Syntax:
+## License Agreement
 
-* Tell this your IDE or just use NetBeans which picks the format from pom.xml. E.g. no tabs - use 4 spaces instead!!
+For contributions like pull requests, bug fixes and translations please read and electronically sign 
+the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>,
+which gives not away your rights but it will make sure for others that you agree to the Apache License, Version 2.
+
+## Syntax:
+
+* Tell this your IDE or just use NetBeans which picks the format from pom.xml. E.g. no tabs - use 4 spaces instead!
 * Follow the conventions you see used in the source already.
 
 And in case we didn't emphasize it enough: we love tests!
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 830e7aba02..30a472952d 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -1,13 +1,27 @@
 [Members](https://github.com/graphhopper?tab=members) and [Contributors](https://github.com/graphhopper/graphhopper/contributors)
 
+ * AnahitaS
  * agouge, discussion and API refactoring
+ * b3nn0, Android improvements
+ * cgarreau, increase of routing success rate via subnetwork cleanup
  * daisy1754, fixed usage of graphhopper.sh script
+ * dardin88, instructions improved
+ * dewos
+ * lmar, improved instructions information
  * fredao, translations
+ * jansoe, one of the core developers
  * jansonhanson, general host config
- * karussell, lead developer
- * khuebner, pushes turn instructions forward
+ * JohannesPelzer, improved GPX information and various other things
+ * karussell, one of the core developers
+ * khuebner, pushed turn instructions forward
  * lmar, improved instructions
  * NopMap, massive improvements regarding OSM, parsing and encoding, route relations
  * ocampana, initial implementation for instructions
- * ratrun, route relations and bike handling
- * rodo, more descriptions
\ No newline at end of file
+ * ratrun, route relations, GPX information, bike handling etc
+ * rodneyodonnell, improved dead end removal
+ * rodo, more descriptions
+
+# Translations
+
+A lot people helped to create translations - thanks!
+See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
\ No newline at end of file
diff --git a/NOTICE.md b/NOTICE.md
index a7918942a1..85b2bf59be 100644
--- a/NOTICE.md
+++ b/NOTICE.md
@@ -1,6 +1,6 @@
 GraphHopper licensed under the Apache license, Version 2.0
 
-Copyright 2012-2013 Peter Karich
+Copyright 2012-2015 Peter Karich
 
 The core product includes the following software
  * slf4j.org - SLF4J distributed under the MIT license. 
@@ -10,6 +10,7 @@ The core product includes the following software
  * protobuf - New BSD license
  * OSM-binary - LGPL license
  * Osmosis - public domain, see osmosis-copying.txt under core/files
+ * XMLGraphics-Commons for CGIAR elevation files - (Apache License)
 
 tools
  * apache-compress
@@ -18,5 +19,7 @@ web
  * org.json, MIT style license
  * com.google.inject, Apache License 2.0
  * images from mapbox https://www.mapbox.com/maki/, BSD License, see core/files
+
+android
  * android, Apache License 2.0
  * org.mapsforge, LGPL
diff --git a/README.md b/README.md
index c51da1c8d9..177e708507 100644
--- a/README.md
+++ b/README.md
@@ -1,21 +1,44 @@
-# GraphHopper [![Build Status](https://secure.travis-ci.org/graphhopper/graphhopper.png?branch=master)](http://travis-ci.org/graphhopper/graphhopper)
+# GraphHopper Route Planner
+
+[![Build Status](https://secure.travis-ci.org/graphhopper/graphhopper.png?branch=master)](http://travis-ci.org/graphhopper/graphhopper)
 
 GraphHopper is a fast and memory efficient Java road routing engine released under Apache License 2.0.
-It is tuned towards road networks with OpenStreetMap data but can be useful for public transport problems as well.
+Per default it uses OpenStreetMap data but can import other data sources.
+
+GraphHopper for the Web
+--------------
+
+See GraphHopper in action on [GraphHopper Maps](https://graphhopper.com/maps)
 
+[![GraphHopper Maps](https://karussell.files.wordpress.com/2014/12/graphhopper-maps-0-4-preview.png)](https://graphhopper.com/maps)
 
-Get Started & Contribute
+GraphHopper Maps uses the [Directions API for Business](https://graphhopper.com/#directions-api), which provides 
+routing and matrix routing through GraphHopper and also a fast address search via [Photon](https://github.com/komoot/photon).
+Additionally the map tiles from various Providers like [Lyrk](https://geodienste.lyrk.de/pakete)
+are used and all is available for free and through HTTPS for a secure route planning experience!
+
+
+GraphHopper for Mobile
 ---------------
 
-Read through our [wiki](https://github.com/graphhopper/graphhopper/wiki/), 
-[how to contribute](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md) and 
+There are subprojects to make GraphHopper working offline
+on [Android](https://github.com/graphhopper/graphhopper/tree/master/android)
+and [iOS](http://github.com/graphhopper/graphhopper-ios)
+
+
+Get Started
+---------------
+
+Read through our Documentation ([0.4](https://github.com/graphhopper/graphhopper/blob/0.4/docs/index.md), [unstable](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md)), 
 ask questions on [Stackoverflow](http://stackoverflow.com/questions/tagged/graphhopper)
-or sign up to the [mailing list](http://graphhopper.com/#developers).
+and sign up to the [mailing list](http://graphhopper.com/#developers).
 
-**Please only email me directly if you need consultancy** or can't explain your problem in the public.
 
-There are subprojects to make GraphHopper working on [Android](https://github.com/graphhopper/graphhopper/wiki/Android) or 
-as a [web application](https://github.com/graphhopper/graphhopper/tree/master/web). Have a look into our [live application](http://graphhopper.com/maps)
+Contribute
+---------------
+
+Read through [how to contribute](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md)
+like finding and fixing bugs and improving our documentation or translations!
 
 
 Features
@@ -25,6 +48,6 @@ Features
  * Open Source
  * Memory efficient and fast
  * Highly customizable
- * Works on the desktop, as a web service and offline on Android
- * Well tested
- * [... more](http://graphhopper.com/#overview)
\ No newline at end of file
+ * Works on the desktop, as a web service and offline on Android or iOS
+ * Large test suite
+ * [... more](http://graphhopper.com/#overview)
diff --git a/android/.classpath b/android/.classpath
deleted file mode 100644
index 194cfe2d8c..0000000000
--- a/android/.classpath
+++ /dev/null
@@ -1,13 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6">
-		<attributes>
-			<attribute name="maven.pomderived" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/android/.project b/android/.project
deleted file mode 100644
index 7ce2f2637d..0000000000
--- a/android/.project
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>GraphHopper</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.m2e.core.maven2Builder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.m2e.core.maven2Nature</nature>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/android/.settings/org.eclipse.jdt.core.prefs b/android/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index b080d2ddc8..0000000000
--- a/android/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,4 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/android/README.md b/android/README.md
index b482c1b545..f896af0373 100644
--- a/android/README.md
+++ b/android/README.md
@@ -1,6 +1,6 @@
-This is a simple Eclipse project which uses graphhoppers routing and mapsforge to display the map.
-
-* Download the apk [here](http://graphhopper.com/#download)
-* More information about setup, maps creation etc is [in the wiki](https://github.com/graphhopper/graphhopper/wiki/Android)
+This maven module can be used for various IDEs like NetBeans or Eclipse to
+make GraphHopper offline routing working on Android. For offline
+maps the mapsforge project is used. For more information see the 
+[android docs](https://github.com/graphhopper/graphhopper/blob/master/docs/android/index.md).
 
 ![simple routing](http://karussell.files.wordpress.com/2012/09/graphhopper-android.png)
diff --git a/android/app/build.gradle b/android/app/build.gradle
new file mode 100644
index 0000000000..f22f47f714
--- /dev/null
+++ b/android/app/build.gradle
@@ -0,0 +1,51 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "21.1.2"
+
+    defaultConfig {
+        applicationId "com.graphhopper.android"
+        minSdkVersion 8
+        targetSdkVersion 19
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        /* CGIARProvider refers to java.awt
+         * Helper7 refers to java.lang.management
+         * HeightTile refers to javax.imageio and java.awt
+         * OSMElement refers to javax.xml.stream
+         */
+        disable 'InvalidPackage'
+    }
+}
+
+/** only necessary if you need to use latest SNAPSHOT
+configurations.all {
+    // check for updates every build
+    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
+}
+ **/
+
+dependencies {
+    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.4-SNAPSHOT') {
+       exclude group: 'com.google.protobuf', module: 'protobuf-java'
+       exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
+       exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
+    }
+
+    compile group: 'org.mapsforge', name: 'mapsforge-core', version: '0.5.0'
+    compile group: 'org.mapsforge', name: 'mapsforge-map', version: '0.5.0'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-android', version: '0.5.0'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-reader', version: '0.5.0'
+
+    compile group: 'org.slf4j', name: 'slf4j-android', version: '1.7.10'
+    compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.10'
+}
diff --git a/android/pom.xml b/android/app/pom.xml
similarity index 71%
rename from android/pom.xml
rename to android/app/pom.xml
index 7dac89ca38..6a825a16b5 100644
--- a/android/pom.xml
+++ b/android/app/pom.xml
@@ -4,7 +4,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-android</artifactId>
-    <version>0.3-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <name>GraphHopper Android</name>
     <packaging>apk</packaging>    
     <organization>
@@ -13,11 +13,13 @@
     </organization>
     
     <parent>
+        <relativePath>../..</relativePath>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.3-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
-    <properties>        
+    <properties>
+        <mapsforge.version>0.5.0</mapsforge.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
@@ -31,18 +33,12 @@
             <version>${project.parent.version}</version>            
             <type>jar</type>
             <exclusions>
+                <!--
                 <exclusion>
                     <groupId>org.slf4j</groupId>
                     <artifactId>slf4j-api</artifactId>                    
-                </exclusion>
-                <exclusion>
-                    <groupId>org.slf4j</groupId>
-                    <artifactId>slf4j-log4j12</artifactId>                    
-                </exclusion>
-                <exclusion>
-                    <groupId>log4j</groupId>
-                    <artifactId>log4j</artifactId>                    
-                </exclusion>
+                </exclusion> 
+                -->
                 <exclusion>
                     <groupId>com.google.protobuf</groupId>
                     <artifactId>protobuf-java</artifactId>                    
@@ -51,23 +47,49 @@
                     <groupId>org.openstreetmap.osmosis</groupId>
                     <artifactId>osmosis-osm-binary</artifactId>                    
                 </exclusion>
+                <exclusion>
+                    <groupId>org.apache.xmlgraphics</groupId>
+                    <artifactId>xmlgraphics-commons</artifactId>
+                </exclusion>
             </exclusions>
         </dependency>        
           
-        <!-- see scripts/maven-install-mapsforge.sh !
-            if we would use system dep it doesn't work (classnotfound). See also script for more infos.
-        -->              
+        <!-- see scripts/maven-install-mapsforge.sh if downloading from
+             maven central does not work (it should). 
+             if we would use system dep it doesn't work (classnotfound). See also script for more infos.
+        -->          
+        <dependency>
+            <groupId>org.mapsforge</groupId>            
+            <artifactId>mapsforge-core</artifactId>
+            <version>${mapsforge.version}</version>
+        </dependency>    
+        <dependency>
+            <groupId>org.mapsforge</groupId>            
+            <artifactId>mapsforge-map</artifactId>
+            <version>${mapsforge.version}</version>
+        </dependency>
         <dependency>
-            <groupId>com.graphhopper</groupId>            
-            <artifactId>mapsforge-gh</artifactId>
-            <version>0.3-0.3.1-SNAPSHOT</version>
+            <groupId>org.mapsforge</groupId>            
+            <artifactId>mapsforge-map-android</artifactId>
+            <version>${mapsforge.version}</version>
+        </dependency>        
+        <dependency>
+            <groupId>org.mapsforge</groupId>            
+            <artifactId>mapsforge-map-reader</artifactId>
+            <version>${mapsforge.version}</version>
         </dependency>
         
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-android</artifactId>
-            <version>1.6.1-RC1</version>
-        </dependency>        
+            <version>1.7.10</version>
+        </dependency>
+        
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-api</artifactId>
+            <version>1.7.10</version>
+        </dependency>
 
         <!-- Make sure this is above (!) the android dependencies -->
         <!--
@@ -88,31 +110,24 @@
     </dependencies>
 
     <build>
-        <!-- 
-        1. Use src/test/java for JUnit tests that don't call any Android APIs (directly or transitively)
-        2. Use src/main/java for JUnit tests that call Android APIs  
-        -->
-        <sourceDirectory>src</sourceDirectory>        
         <finalName>${project.artifactId}</finalName>        
-
+        
         <plugins>     
-            <!-- android (apache harmony) is nearly java but not really 1.6 -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
                 <configuration>
                     <!-- <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
-                    <source>1.5</source>
-                    <target>1.5</target>
+                    <source>1.7</source>
+                    <target>1.7</target>
                 </configuration>
             </plugin>       
             <plugin>
                 <!-- See http://code.google.com/p/maven-android-plugin/ -->
                 <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.6.0</version>
+                <version>4.0.0-rc.2</version>
                 <extensions>true</extensions>
                 <configuration>
                     <sdk>
@@ -121,6 +136,7 @@
                     </sdk>
                     <deleteConflictingFiles>true</deleteConflictingFiles>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
+		    
                     <!--
                     bug in maven plugin I think
                     <extractDuplicates>true</extractDuplicates>
diff --git a/android/project.properties b/android/app/project.properties
similarity index 96%
rename from android/project.properties
rename to android/app/project.properties
index b7c2081d56..6e18427a42 100644
--- a/android/project.properties
+++ b/android/app/project.properties
@@ -11,4 +11,4 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-10
+target=android-21
diff --git a/android/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
similarity index 90%
rename from android/AndroidManifest.xml
rename to android/app/src/main/AndroidManifest.xml
index ad4cf4c96f..4908215b43 100644
--- a/android/AndroidManifest.xml
+++ b/android/app/src/main/AndroidManifest.xml
@@ -3,17 +3,16 @@
           android:versionCode="1"
           android:versionName="0.1" >
 
-    <!-- mapsforge cache  -->
+    <!-- mapsforge cache and saving maps -->
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     
     <!-- necessary to easily download maps via wifi -->
     <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /> 
-    
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />    
 
     <uses-sdk
         android:minSdkVersion="8"
-        android:targetSdkVersion="17" />
+        android:targetSdkVersion="19" />
 
     <application
         android:allowBackup="true"
diff --git a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
new file mode 100644
index 0000000000..63f874629a
--- /dev/null
+++ b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
@@ -0,0 +1,58 @@
+package com.graphhopper.android;
+
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.ProgressListener;
+import com.graphhopper.util.Unzipper;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class AndroidDownloader extends Downloader {
+
+    public AndroidDownloader() {
+        super("GraphHopper Android");
+    }
+
+    public void downloadAndUnzip(String url, String toFolder, final ProgressListener progressListener) throws IOException {
+        HttpEntity entity = getEntity(url);
+        InputStream iStream = entity.getContent();
+        final long length = entity.getContentLength();
+
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener() {
+            @Override
+            public void update(long sumBytes) {
+                progressListener.update((int) (100 * sumBytes / length));
+            }
+        });
+    }
+
+    private HttpEntity getEntity(String url) {
+        // there is something broken with HTTPS and Android HttpURLConnection
+        HttpClient httpclient = new DefaultHttpClient();
+        HttpGet httpget = new HttpGet(url);
+        try {
+            HttpResponse response = httpclient.execute(httpget);
+            HttpEntity entity = response.getEntity();
+            if (entity == null)
+                throw new RuntimeException("no entity for URL " + url);
+
+            return entity;
+
+        } catch (Exception ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    @Override
+    public String downloadAsString(String url) throws IOException {
+        return Helper.isToString(getEntity(url).getContent());
+    }
+}
diff --git a/android/src/com/graphhopper/android/AndroidHelper.java b/android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
similarity index 100%
rename from android/src/com/graphhopper/android/AndroidHelper.java
rename to android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
diff --git a/android/src/com/graphhopper/android/GHAsyncTask.java b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
similarity index 99%
rename from android/src/com/graphhopper/android/GHAsyncTask.java
rename to android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
index e1b0276a94..62923ec579 100644
--- a/android/src/com/graphhopper/android/GHAsyncTask.java
+++ b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
@@ -20,8 +20,6 @@ protected C doInBackground( A... params )
         }
     }
 
-    ;
-
 	public boolean hasError()
     {
         return error != null;
diff --git a/android/src/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
similarity index 64%
rename from android/src/com/graphhopper/android/MainActivity.java
rename to android/app/src/main/java/com/graphhopper/android/MainActivity.java
index c252d5be2b..dd66542c54 100644
--- a/android/src/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -7,33 +7,36 @@
 import java.util.Map;
 import java.util.TreeMap;
 
-import org.mapsforge.android.maps.MapActivity;
-import org.mapsforge.android.maps.MapView;
-import org.mapsforge.android.maps.Projection;
-import org.mapsforge.android.maps.overlay.ListOverlay;
-import org.mapsforge.android.maps.overlay.Marker;
-import org.mapsforge.android.maps.overlay.PolygonalChain;
-import org.mapsforge.android.maps.overlay.Polyline;
-import org.mapsforge.core.model.GeoPoint;
-import org.mapsforge.map.reader.header.FileOpenResult;
-
+import org.mapsforge.core.graphics.Bitmap;
+import org.mapsforge.core.graphics.Paint;
+import org.mapsforge.core.graphics.Style;
+import org.mapsforge.core.model.LatLong;
+import org.mapsforge.core.model.MapPosition;
+import org.mapsforge.core.model.Point;
+import org.mapsforge.map.android.graphics.AndroidGraphicFactory;
+import org.mapsforge.map.android.util.AndroidUtil;
+import org.mapsforge.map.android.view.MapView;
+import org.mapsforge.map.layer.Layers;
+import org.mapsforge.map.layer.cache.TileCache;
+import org.mapsforge.map.layer.overlay.Marker;
+import org.mapsforge.map.layer.overlay.Polyline;
+import org.mapsforge.map.layer.renderer.TileRendererLayer;
+import org.mapsforge.map.rendertheme.InternalRenderTheme;
+
+import android.app.Activity;
 import android.app.ProgressDialog;
 import android.content.Intent;
 import android.graphics.Color;
-import android.graphics.DashPathEffect;
-import android.graphics.Paint;
 import android.graphics.Path;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.os.AsyncTask;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Environment;
 import android.util.Log;
-import android.view.GestureDetector;
-import android.view.GestureDetector.SimpleOnGestureListener;
 import android.view.Menu;
 import android.view.MenuItem;
-import android.view.MotionEvent;
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.view.Window;
@@ -47,83 +50,74 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
-import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.util.Constants;
-import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.ProgressListener;
 import com.graphhopper.util.StopWatch;
 
-public class MainActivity extends MapActivity
+public class MainActivity extends Activity
 {
     private MapView mapView;
-    private GraphHopperAPI hopper;
-    private GeoPoint start;
-    private GeoPoint end;
+    private GraphHopper hopper;
+    private LatLong start;
+    private LatLong end;
     private Spinner localSpinner;
     private Button localButton;
     private Spinner remoteSpinner;
     private Button remoteButton;
-    private ListOverlay pathOverlay = new ListOverlay();
     private volatile boolean prepareInProgress = false;
     private volatile boolean shortestPathRunning = false;
     private String currentArea = "berlin";
-    private String fileListURL = "http://graphhopper.com/public/maps/0.3/";
+    private String fileListURL = "https://graphhopper.com/public/maps/0.5/";
     private String prefixURL = fileListURL;
     private String downloadURL;
-    private String mapsFolder;
-    private String mapFile;
-    private SimpleOnGestureListener gestureListener = new SimpleOnGestureListener()
+    private File mapsFolder;
+    private TileCache tileCache;
+
+    protected boolean onMapTap( LatLong tapLatLong, Point layerXY, Point tapXY )
     {
-        // why does this fail? public boolean onDoubleTap(MotionEvent e) {};
-        public boolean onSingleTapConfirmed( MotionEvent motionEvent )
+        if (!isReady())
+            return false;
+
+        if (shortestPathRunning)
         {
-            if (!initFiles(currentArea))
-            {
-                return false;
-            }
+            logUser("Calculation still in progress");
+            return false;
+        }
+        Layers layers = mapView.getLayerManager().getLayers();
 
-            if (shortestPathRunning)
+        if (start != null && end == null)
+        {
+            end = tapLatLong;
+            shortestPathRunning = true;
+            Marker marker = createMarker(tapLatLong, R.drawable.flag_red);
+            if (marker != null)
             {
-                logUser("Calculation still in progress");
-                return false;
+                layers.add(marker);
             }
-            float x = motionEvent.getX();
-            float y = motionEvent.getY();
-            Projection p = mapView.getProjection();
-            GeoPoint tmpPoint = p.fromPixels((int) x, (int) y);
 
-            if (start != null && end == null)
+            calcPath(start.latitude, start.longitude, end.latitude,
+                    end.longitude);
+        } else
+        {
+            start = tapLatLong;
+            end = null;
+            // remove all layers but the first one, which is the map
+            while (layers.size() > 1)
             {
-                end = tmpPoint;
-                shortestPathRunning = true;
-                Marker marker = createMarker(tmpPoint, R.drawable.flag_red);
-                if (marker != null)
-                {
-                    pathOverlay.getOverlayItems().add(marker);
-                    mapView.redraw();
-                }
+                layers.remove(1);
+            }
 
-                calcPath(start.latitude, start.longitude, end.latitude,
-                        end.longitude);
-            } else
+            Marker marker = createMarker(start, R.drawable.flag_green);
+            if (marker != null)
             {
-                start = tmpPoint;
-                end = null;
-                pathOverlay.getOverlayItems().clear();
-                Marker marker = createMarker(start, R.drawable.flag_green);
-                if (marker != null)
-                {
-                    pathOverlay.getOverlayItems().add(marker);
-                    mapView.redraw();
-                }
+                layers.add(marker);
             }
-            return true;
         }
-    };
-    private GestureDetector gestureDetector = new GestureDetector(
-            gestureListener);
+        return true;
+    }
 
     @Override
     protected void onCreate( Bundle savedInstanceState )
@@ -131,29 +125,32 @@ protected void onCreate( Bundle savedInstanceState )
         requestWindowFeature(Window.FEATURE_NO_TITLE);
         super.onCreate(savedInstanceState);
         setContentView(R.layout.main);
-        mapView = new MapView(this)
-        {
-            @Override
-            public boolean onTouchEvent( MotionEvent event )
-            {
-                if (gestureDetector.onTouchEvent(event))
-                {
-                    return true;
-                }
-                return super.onTouchEvent(event);
-            }
-        };
+        AndroidGraphicFactory.createInstance(getApplication());
+
+        mapView = new MapView(this);
         mapView.setClickable(true);
         mapView.setBuiltInZoomControls(true);
 
+        tileCache = AndroidUtil.createTileCache(this, getClass().getSimpleName(), mapView.getModel().displayModel.getTileSize(),
+                1f, mapView.getModel().frameBufferModel.getOverdrawFactor());
+
         final EditText input = new EditText(this);
         input.setText(currentArea);
-        mapsFolder = Environment.getExternalStorageDirectory()
-                .getAbsolutePath() + "/graphhopper/maps/";
-        if (!new File(mapsFolder).exists())
+        boolean greaterOrEqKitkat = Build.VERSION.SDK_INT >= 19;
+        if (greaterOrEqKitkat)
         {
-            new File(mapsFolder).mkdirs();
-        }
+            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))
+            {
+                logUser("GraphHopper is not usable without an external storage!");
+                return;
+            }
+            mapsFolder = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
+                    "/graphhopper/maps/");
+        } else
+            mapsFolder = new File(Environment.getExternalStorageDirectory(), "/graphhopper/maps/");
+
+        if (!mapsFolder.exists())
+            mapsFolder.mkdirs();
 
         TextView welcome = (TextView) findViewById(R.id.welcome);
         welcome.setText("Welcome to GraphHopper " + Constants.VERSION + "!");
@@ -168,7 +165,19 @@ public boolean onTouchEvent( MotionEvent event )
         chooseAreaFromLocal();
     }
 
-    private boolean initFiles( String area )
+    @Override
+    protected void onDestroy()
+    {
+        super.onDestroy();
+        if (hopper != null)
+            hopper.close();
+
+        hopper = null;
+        // necessary?
+        System.gc();
+    }
+
+    boolean isReady()
     {
         // only return true if already loaded
         if (hopper != null)
@@ -179,16 +188,21 @@ private boolean initFiles( String area )
             logUser("Preparation still in progress");
             return false;
         }
+        logUser("Prepare finished but hopper not ready. This happens when there was an error while loading the files");
+        return false;
+    }
+
+    private void initFiles( String area )
+    {
         prepareInProgress = true;
         currentArea = area;
         downloadingFiles();
-        return false;
     }
 
     private void chooseAreaFromLocal()
     {
         List<String> nameList = new ArrayList<String>();
-        String[] files = new File(mapsFolder).list(new FilenameFilter()
+        String[] files = mapsFolder.list(new FilenameFilter()
         {
             @Override
             public boolean accept( File dir, String filename )
@@ -224,7 +238,7 @@ private void chooseAreaFromRemote()
             protected List<String> saveDoInBackground( Void... params )
                     throws Exception
             {
-                String[] lines = new Downloader("GraphHopper Android").downloadAsString(fileListURL).split("\n");
+                String[] lines = new AndroidDownloader().downloadAsString(fileListURL).split("\n");
                 List<String> res = new ArrayList<String>();
                 for (String str : lines)
                 {
@@ -234,10 +248,8 @@ private void chooseAreaFromRemote()
                         index += 6;
                         int lastIndex = str.indexOf(".ghz", index);
                         if (lastIndex >= 0)
-                        {
                             res.add(prefixURL + str.substring(index, lastIndex)
                                     + ".ghz");
-                        }
                     }
                 }
 
@@ -247,24 +259,25 @@ private void chooseAreaFromRemote()
             @Override
             protected void onPostExecute( List<String> nameList )
             {
-                if (hasError())
+                if(nameList.isEmpty())
+                {
+                    logUser("No maps created for your version!? " + fileListURL);
+                    return;
+                } else if (hasError())
                 {
-                    logUser("To get downloadable areas restart when connected to internet. "
-                            + "Problem while fetching remote area list: "
+                    getError().printStackTrace();
+                    logUser("Are you connected to the internet? Problem while fetching remote area list: "
                             + getErrorMessage());
                     return;
                 }
                 MySpinnerListener spinnerListener = new MySpinnerListener()
                 {
                     @Override
-                    public void onSelect( String selectedArea,
-                            String selectedFile )
+                    public void onSelect( String selectedArea, String selectedFile )
                     {
                         if (selectedFile == null
-                                || new File(mapsFolder + selectedArea + ".ghz")
-                                .exists()
-                                || new File(mapsFolder + selectedArea + "-gh")
-                                .exists())
+                                || new File(mapsFolder, selectedArea + ".ghz").exists()
+                                || new File(mapsFolder, selectedArea + "-gh").exists())
                         {
                             downloadURL = null;
                         } else
@@ -304,7 +317,7 @@ private void chooseArea( Button button, final Spinner spinner,
             public void onClick( View v )
             {
                 Object o = spinner.getSelectedItem();
-                if (o != null && o.toString().length() > 0)
+                if (o != null && o.toString().length() > 0 && !nameToFullName.isEmpty())
                 {
                     String area = o.toString();
                     mylistener.onSelect(area, nameToFullName.get(area));
@@ -323,9 +336,10 @@ public void onClick( View v )
 
     void downloadingFiles()
     {
-        if (downloadURL == null)
+        final File areaFolder = new File(mapsFolder, currentArea + "-gh");
+        if (downloadURL == null || areaFolder.exists())
         {
-            loadMap();
+            loadMap(areaFolder);
             return;
         }
 
@@ -342,9 +356,11 @@ protected Object saveDoInBackground( Void... _ignore )
                     throws Exception
             {
                 String localFolder = Helper.pruneFileEnd(AndroidHelper.getFileName(downloadURL));
-                localFolder = mapsFolder + localFolder + "-gh";
+                localFolder = new File(mapsFolder, localFolder + "-gh").getAbsolutePath();
                 log("downloading & unzipping " + downloadURL + " to " + localFolder);
-                new Downloader("GraphHopper Android").downloadAndUnzip(downloadURL, localFolder,
+                AndroidDownloader downloader = new AndroidDownloader();
+                downloader.setTimeout(30000);
+                downloader.downloadAndUnzip(downloadURL, localFolder,
                         new ProgressListener()
                         {
                             @Override
@@ -372,27 +388,36 @@ protected void onPostExecute( Object _ignore )
                     logUser(str);
                 } else
                 {
-                    loadMap();
+                    loadMap(areaFolder);
                 }
             }
         }.execute();
     }
 
-    void loadMap()
+    void loadMap( File areaFolder )
     {
         logUser("loading map");
-        mapFile = mapsFolder + currentArea + "-gh/" + currentArea + ".map";
-        FileOpenResult fileOpenResult = mapView.setMapFile(new File(mapFile));
-        if (!fileOpenResult.isSuccess())
-        {
-            logUser(fileOpenResult.getErrorMessage());
-            finishPrepare();
-            return;
-        }
+        File mapFile = new File(areaFolder, currentArea + ".map");
+
+        mapView.getLayerManager().getLayers().clear();
+
+        TileRendererLayer tileRendererLayer = new TileRendererLayer(tileCache, mapView.getModel().mapViewPosition,
+                false,
+                true, AndroidGraphicFactory.INSTANCE)
+                {
+                    @Override
+                    public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
+                    {
+                        return onMapTap(tapLatLong, layerXY, tapXY);
+                    }
+                };
+        tileRendererLayer.setMapFile(mapFile);
+        tileRendererLayer.setTextScale(1.5f);
+        tileRendererLayer.setXmlRenderTheme(InternalRenderTheme.OSMARENDER);
+        mapView.getModel().mapViewPosition.setMapPosition(new MapPosition(tileRendererLayer.getMapDatabase().getMapFileInfo().boundingBox.getCenterPoint(), (byte) 15));
+        mapView.getLayerManager().getLayers().add(tileRendererLayer);
+
         setContentView(mapView);
-        // TODO sometimes the center is wrong
-        mapView.getOverlays().clear();
-        mapView.getOverlays().add(pathOverlay);
         loadGraphStorage();
     }
 
@@ -404,8 +429,7 @@ void loadGraphStorage()
             protected Path saveDoInBackground( Void... v ) throws Exception
             {
                 GraphHopper tmpHopp = new GraphHopper().forMobile();
-                tmpHopp.setCHShortcuts("fastest");
-                tmpHopp.load(mapsFolder + currentArea);
+                tmpHopp.load(new File(mapsFolder, currentArea).getAbsolutePath());
                 log("found graph " + tmpHopp.getGraph().toString() + ", nodes:" + tmpHopp.getGraph().getNodes());
                 hopper = tmpHopp;
                 return null;
@@ -419,7 +443,7 @@ protected void onPostExecute( Path o )
                             + getErrorMessage());
                 } else
                 {
-                    logUser("Finished loading graph. Touch to route.");
+                    logUser("Finished loading graph. Press long to define where to start and end the route.");
                 }
 
                 finishPrepare();
@@ -434,31 +458,34 @@ private void finishPrepare()
 
     private Polyline createPolyline( GHResponse response )
     {
-        int points = response.getPoints().getSize();
-        List<GeoPoint> geoPoints = new ArrayList<GeoPoint>(points);
+        Paint paintStroke = AndroidGraphicFactory.INSTANCE.createPaint();
+        paintStroke.setStyle(Style.STROKE);
+        paintStroke.setColor(Color.argb(200, 0, 0xCC, 0x33));
+        paintStroke.setDashPathEffect(new float[]
+        {
+            25, 15
+        });
+        paintStroke.setStrokeWidth(8);
+
+        // TODO: new mapsforge version wants an mapsforge-paint, not an android paint.
+        // This doesn't seem to support transparceny
+        //paintStroke.setAlpha(128);
+        Polyline line = new Polyline((org.mapsforge.core.graphics.Paint) paintStroke, AndroidGraphicFactory.INSTANCE);
+        List<LatLong> geoPoints = line.getLatLongs();
         PointList tmp = response.getPoints();
         for (int i = 0; i < response.getPoints().getSize(); i++)
         {
-            geoPoints.add(new GeoPoint(tmp.getLatitude(i), tmp.getLongitude(i)));
+            geoPoints.add(new LatLong(tmp.getLatitude(i), tmp.getLongitude(i)));
         }
-        PolygonalChain polygonalChain = new PolygonalChain(geoPoints);
-        Paint paintStroke = new Paint(Paint.ANTI_ALIAS_FLAG);
-        paintStroke.setStyle(Paint.Style.STROKE);
-        paintStroke.setColor(Color.BLUE);
-        paintStroke.setAlpha(128);
-        paintStroke.setStrokeWidth(8);
-        paintStroke.setPathEffect(new DashPathEffect(new float[]
-        {
-            25, 15
-        }, 0));
 
-        return new Polyline(polygonalChain, paintStroke);
+        return line;
     }
 
-    private Marker createMarker( GeoPoint p, int resource )
+    private Marker createMarker( LatLong p, int resource )
     {
         Drawable drawable = getResources().getDrawable(resource);
-        return new Marker(p, Marker.boundCenterBottom(drawable));
+        Bitmap bitmap = AndroidGraphicFactory.convertToBitmap(drawable);
+        return new Marker(p, bitmap, 0, -bitmap.getHeight() / 2);
     }
 
     public void calcPath( final double fromLat, final double fromLon,
@@ -474,9 +501,9 @@ protected GHResponse doInBackground( Void... v )
             {
                 StopWatch sw = new StopWatch().start();
                 GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
-                        setAlgorithm("dijkstrabi").
-                        putHint("instructions", false).
-                        putHint("douglas.minprecision", 1);
+                        setAlgorithm(AlgorithmOptions.DIJKSTRA_BI);
+                req.getHints().
+                        put("instructions", "false");
                 GHResponse resp = hopper.route(req);
                 time = sw.stop().getSeconds();
                 return resp;
@@ -493,8 +520,8 @@ protected void onPostExecute( GHResponse resp )
                     logUser("the route is " + (int) (resp.getDistance() / 100) / 10f
                             + "km long, time:" + resp.getMillis() / 60000f + "min, debug:" + time);
 
-                    pathOverlay.getOverlayItems().add(createPolyline(resp));
-                    mapView.redraw();
+                    mapView.getLayerManager().getLayers().add(createPolyline(resp));
+                    //mapView.redraw();
                 } else
                 {
                     logUser("Error:" + resp.getErrors());
@@ -516,6 +543,7 @@ private void log( String str, Throwable t )
 
     private void logUser( String str )
     {
+        log(str);
         Toast.makeText(this, str, Toast.LENGTH_LONG).show();
     }
     private static final int NEW_MENU_ID = Menu.FIRST + 1;
diff --git a/android/res/drawable/flag_green.png b/android/app/src/main/res/drawable/flag_green.png
similarity index 100%
rename from android/res/drawable/flag_green.png
rename to android/app/src/main/res/drawable/flag_green.png
diff --git a/android/res/drawable/flag_red.png b/android/app/src/main/res/drawable/flag_red.png
similarity index 100%
rename from android/res/drawable/flag_red.png
rename to android/app/src/main/res/drawable/flag_red.png
diff --git a/android/res/drawable/logo.png b/android/app/src/main/res/drawable/logo.png
similarity index 100%
rename from android/res/drawable/logo.png
rename to android/app/src/main/res/drawable/logo.png
diff --git a/android/res/layout/main.xml b/android/app/src/main/res/layout/main.xml
similarity index 100%
rename from android/res/layout/main.xml
rename to android/app/src/main/res/layout/main.xml
diff --git a/android/res/values-large/dimens.xml b/android/app/src/main/res/values-large/dimens.xml
similarity index 100%
rename from android/res/values-large/dimens.xml
rename to android/app/src/main/res/values-large/dimens.xml
diff --git a/android/res/values/dimens.xml b/android/app/src/main/res/values/dimens.xml
similarity index 100%
rename from android/res/values/dimens.xml
rename to android/app/src/main/res/values/dimens.xml
diff --git a/android/res/values/strings.xml b/android/app/src/main/res/values/strings.xml
similarity index 100%
rename from android/res/values/strings.xml
rename to android/app/src/main/res/values/strings.xml
diff --git a/android/res/values/styles.xml b/android/app/src/main/res/values/styles.xml
similarity index 100%
rename from android/res/values/styles.xml
rename to android/app/src/main/res/values/styles.xml
diff --git a/android/build.gradle b/android/build.gradle
new file mode 100644
index 0000000000..fd24035602
--- /dev/null
+++ b/android/build.gradle
@@ -0,0 +1,19 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+buildscript {
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        /*jcenter()*/
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.0.0'
+    }
+}
+
+allprojects {
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        /*jcenter()*/
+    }
+}
diff --git a/android/gradle/wrapper/gradle-wrapper.jar b/android/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..8c0fb64a86
Binary files /dev/null and b/android/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..0c71e760dc
--- /dev/null
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/android/gradlew b/android/gradlew
new file mode 100755
index 0000000000..91a7e269e1
--- /dev/null
+++ b/android/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/android/gradlew.bat b/android/gradlew.bat
new file mode 100644
index 0000000000..8a0b282aa6
--- /dev/null
+++ b/android/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/android/libs/mapsforge-0.3.1-SNAPSHOT.jar b/android/libs/mapsforge-0.3.1-SNAPSHOT.jar
deleted file mode 100644
index 94313b4332..0000000000
Binary files a/android/libs/mapsforge-0.3.1-SNAPSHOT.jar and /dev/null differ
diff --git a/android/libs/slf4j-android-1.6.1-RC1.jar b/android/libs/slf4j-android-1.6.1-RC1.jar
deleted file mode 100644
index 9bb01355a4..0000000000
Binary files a/android/libs/slf4j-android-1.6.1-RC1.jar and /dev/null differ
diff --git a/android/local.properties b/android/local.properties
new file mode 100644
index 0000000000..efc8662bc7
--- /dev/null
+++ b/android/local.properties
@@ -0,0 +1,7 @@
+## This file must *NOT* be checked into Version Control Systems,
+# as it contains information specific to your local configuration.
+#
+# Location of the SDK. This is only used by Gradle.
+#
+#Mon Jan 19 09:31:41 CET 2015
+sdk.dir=/home/peterk/Programme/adt-bundle-linux-x86/sdk
diff --git a/android/nb-configuration.xml b/android/nb-configuration.xml
index 94309b4d48..f677015e2a 100644
--- a/android/nb-configuration.xml
+++ b/android/nb-configuration.xml
@@ -16,8 +16,7 @@
         That way multiple projects can share the same settings (useful for formatting rules for example).
         Any value defined here will override the pom.xml file value but is only applicable to the current project.
         -->
-        <org-netbeans-modules-editor-indent.CodeStyle.usedProfile>project</org-netbeans-modules-editor-indent.CodeStyle.usedProfile>       
-        <netbeans.hint.jdkPlatform>JDK_1.6</netbeans.hint.jdkPlatform>
-        <netbeans.compile.on.save>all</netbeans.compile.on.save>        
+        <org-netbeans-modules-editor-indent.CodeStyle.usedProfile>project</org-netbeans-modules-editor-indent.CodeStyle.usedProfile>
+        <netbeans.compile.on.save>all</netbeans.compile.on.save>
     </properties>
 </project-shared-configuration>
diff --git a/android/proguard-project.txt b/android/proguard-project.txt
deleted file mode 100644
index f2fe1559a2..0000000000
--- a/android/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/android/scripts/googlecode_upload.py b/android/scripts/googlecode_upload.py
deleted file mode 100644
index 16912361ee..0000000000
--- a/android/scripts/googlecode_upload.py
+++ /dev/null
@@ -1,256 +0,0 @@
-#!/usr/bin/env python
-#
-# Copyright 2006, 2007 Google Inc. All Rights Reserved.
-# Author: danderson@google.com (David Anderson)
-#
-# Script for uploading files to a Google Code project.
-#
-# This is intended to be both a useful script for people who want to
-# streamline project uploads and a reference implementation for
-# uploading files to Google Code projects.
-#
-# To upload a file to Google Code, you need to provide a path to the
-# file on your local machine, a small summary of what the file is, a
-# project name, and a valid account that is a member or owner of that
-# project.  You can optionally provide a list of labels that apply to
-# the file.  The file will be uploaded under the same name that it has
-# in your local filesystem (that is, the "basename" or last path
-# component).  Run the script with '--help' to get the exact syntax
-# and available options.
-#
-# Note that the upload script requests that you enter your
-# googlecode.com password.  This is NOT your Gmail account password!
-# This is the password you use on googlecode.com for committing to
-# Subversion and uploading files.  You can find your password by going
-# to http://code.google.com/hosting/settings when logged in with your
-# Gmail account. If you have already committed to your project's
-# Subversion repository, the script will automatically retrieve your
-# credentials from there (unless disabled, see the output of '--help'
-# for details).
-#
-# If you are looking at this script as a reference for implementing
-# your own Google Code file uploader, then you should take a look at
-# the upload() function, which is the meat of the uploader.  You
-# basically need to build a multipart/form-data POST request with the
-# right fields and send it to https://PROJECT.googlecode.com/files .
-# Authenticate the request using HTTP Basic authentication, as is
-# shown below.
-#
-# Licensed under the terms of the Apache Software License 2.0:
-#  http://www.apache.org/licenses/LICENSE-2.0
-#
-# Questions, comments, feature requests and patches are most welcome.
-# Please direct all of these to the Google Code users group:
-#  http://groups.google.com/group/google-code-hosting
-
-"""Google Code file uploader script.
-"""
-
-__author__ = 'danderson@google.com (David Anderson)'
-
-import httplib
-import os.path
-import optparse
-import getpass
-import base64
-import sys
-
-
-def upload(file, project_name, user_name, password, summary, labels=None):
-  """Upload a file to a Google Code project's file server.
-
-  Args:
-    file: The local path to the file.
-    project_name: The name of your project on Google Code.
-    user_name: Your Google account name.
-    password: The googlecode.com password for your account.
-              Note that this is NOT your global Google Account password!
-    summary: A small description for the file.
-    labels: an optional list of label strings with which to tag the file.
-
-  Returns: a tuple:
-    http_status: 201 if the upload succeeded, something else if an
-                 error occured.
-    http_reason: The human-readable string associated with http_status
-    file_url: If the upload succeeded, the URL of the file on Google
-              Code, None otherwise.
-  """
-  # The login is the user part of user@gmail.com. If the login provided
-  # is in the full user@domain form, strip it down.
-  if user_name.endswith('@gmail.com'):
-    user_name = user_name[:user_name.index('@gmail.com')]
-
-  form_fields = [('summary', summary)]
-  if labels is not None:
-    form_fields.extend([('label', l.strip()) for l in labels])
-
-  content_type, body = encode_upload_request(form_fields, file)
-
-  upload_host = '%s.googlecode.com' % project_name
-  upload_uri = '/files'
-  auth_token = base64.b64encode('%s:%s'% (user_name, password))
-  headers = {
-    'Authorization': 'Basic %s' % auth_token,
-    'User-Agent': 'Googlecode.com uploader v0.9.4',
-    'Content-Type': content_type,
-    }
-
-  server = httplib.HTTPSConnection(upload_host)
-  server.request('POST', upload_uri, body, headers)
-  resp = server.getresponse()
-  server.close()
-
-  if resp.status == 201:
-    location = resp.getheader('Location', None)
-  else:
-    location = None
-  return resp.status, resp.reason, location
-
-
-def encode_upload_request(fields, file_path):
-  """Encode the given fields and file into a multipart form body.
-
-  fields is a sequence of (name, value) pairs. file is the path of
-  the file to upload. The file will be uploaded to Google Code with
-  the same file name.
-
-  Returns: (content_type, body) ready for httplib.HTTP instance
-  """
-  BOUNDARY = '----------Googlecode_boundary_reindeer_flotilla'
-  CRLF = '\r\n'
-
-  body = []
-
-  # Add the metadata about the upload first
-  for key, value in fields:
-    body.extend(
-      ['--' + BOUNDARY,
-       'Content-Disposition: form-data; name="%s"' % key,
-       '',
-       value,
-       ])
-
-  # Now add the file itself
-  file_name = os.path.basename(file_path)
-  f = open(file_path, 'rb')
-  file_content = f.read()
-  f.close()
-
-  body.extend(
-    ['--' + BOUNDARY,
-     'Content-Disposition: form-data; name="filename"; filename="%s"'
-     % file_name,
-     # The upload server determines the mime-type, no need to set it.
-     'Content-Type: application/octet-stream',
-     '',
-     file_content,
-     ])
-
-  # Finalize the form body
-  body.extend(['--' + BOUNDARY + '--', ''])
-
-  return 'multipart/form-data; boundary=%s' % BOUNDARY, CRLF.join(body)
-
-
-def upload_find_auth(file_path, project_name, summary, labels=None,
-                     user_name=None, password=None, tries=3):
-  """Find credentials and upload a file to a Google Code project's file server.
-
-  file_path, project_name, summary, and labels are passed as-is to upload.
-
-  Args:
-    file_path: The local path to the file.
-    project_name: The name of your project on Google Code.
-    summary: A small description for the file.
-    labels: an optional list of label strings with which to tag the file.
-    config_dir: Path to Subversion configuration directory, 'none', or None.
-    user_name: Your Google account name.
-    tries: How many attempts to make.
-  """
-  if user_name is None or password is None:
-    from netrc import netrc
-    authenticators = netrc().authenticators("code.google.com")
-    if authenticators:
-      if user_name is None:
-        user_name = authenticators[0]
-      if password is None:
-        password = authenticators[2]
-
-  while tries > 0:
-    if user_name is None:
-      # Read username if not specified or loaded from svn config, or on
-      # subsequent tries.
-      sys.stdout.write('Please enter your googlecode.com username: ')
-      sys.stdout.flush()
-      user_name = sys.stdin.readline().rstrip()
-    if password is None:
-      # Read password if not loaded from svn config, or on subsequent tries.
-      print 'Please enter your googlecode.com password.'
-      print '** Note that this is NOT your Gmail account password! **'
-      print 'It is the password you use to access Subversion repositories,'
-      print 'and can be found here: http://code.google.com/hosting/settings'
-      password = getpass.getpass()
-
-    status, reason, url = upload(file_path, project_name, user_name, password,
-                                 summary, labels)
-    # Returns 403 Forbidden instead of 401 Unauthorized for bad
-    # credentials as of 2007-07-17.
-    if status in [httplib.FORBIDDEN, httplib.UNAUTHORIZED]:
-      # Rest for another try.
-      user_name = password = None
-      tries = tries - 1
-    else:
-      # We're done.
-      break
-
-  return status, reason, url
-
-
-def main():
-  parser = optparse.OptionParser(usage='googlecode-upload.py -s SUMMARY '
-                                 '-p PROJECT [options] FILE')
-  parser.add_option('-s', '--summary', dest='summary',
-                    help='Short description of the file')
-  parser.add_option('-p', '--project', dest='project',
-                    help='Google Code project name')
-  parser.add_option('-u', '--user', dest='user',
-                    help='Your Google Code username')
-  parser.add_option('-w', '--password', dest='password',
-                    help='Your Google Code password')
-  parser.add_option('-l', '--labels', dest='labels',
-                    help='An optional list of comma-separated labels to attach '
-                    'to the file')
-
-  options, args = parser.parse_args()
-
-  if not options.summary:
-    parser.error('File summary is missing.')
-  elif not options.project:
-    parser.error('Project name is missing.')
-  elif len(args) < 1:
-    parser.error('File to upload not provided.')
-  elif len(args) > 1:
-    parser.error('Only one file may be specified.')
-
-  file_path = args[0]
-
-  if options.labels:
-    labels = options.labels.split(',')
-  else:
-    labels = None
-
-  status, reason, url = upload_find_auth(file_path, options.project,
-                                         options.summary, labels,
-                                         options.user, options.password)
-  if url:
-    print 'The file was uploaded successfully.'
-    print 'URL: %s' % url
-    return 0
-  else:
-    print 'An error occurred. Your file was not uploaded.'
-    print 'Google Code upload server said: %s (%s)' % (reason, status)
-    return 1
-
-
-if __name__ == '__main__':
-  sys.exit(main())
diff --git a/android/scripts/maven-install-mapsforge.sh b/android/scripts/maven-install-mapsforge.sh
deleted file mode 100755
index 3ba883fbbe..0000000000
--- a/android/scripts/maven-install-mapsforge.sh
+++ /dev/null
@@ -1,16 +0,0 @@
-# do the following
-# git clone https://code.google.com/p/mapsforge/
-# cd mapsforge; and fix http://code.google.com/p/mapsforge/issues/detail?id=461
-# mvn clean install
-# cp mapsforge-map/target/mapsforge-map-0.3.1-SNAPSHOT-jar-with-dependencies.jar graphhopper/android/libs/mapsforge-0.3.1-SNAPSHOT.jar
-
-# if we would do it via normal maven dependency management we run into strange things which I was not able to fix
-# http://stackoverflow.com/a/8315600/194609
-
-MAPSFORGE=`ls ./libs/mapsforge*.jar`
-echo "installing file: $MAPSFORGE"
-ARGS="-DgroupId=com.graphhopper -DartifactId=mapsforge-gh -Dversion=0.3-0.3.1-SNAPSHOT -Dpackaging=jar -Dfile=$MAPSFORGE"
-    
-$MAVEN_HOME/bin/mvn install:install-file $ARGS
-
-# $MAVEN_HOME/bin/mvn -DperformRelease=true -DskipTests=true -Dpgp.secretkey=keyring:id=54EA4B68 deploy:deploy-file $ARGS
\ No newline at end of file
diff --git a/android/settings.gradle b/android/settings.gradle
new file mode 100644
index 0000000000..e7b4def49c
--- /dev/null
+++ b/android/settings.gradle
@@ -0,0 +1 @@
+include ':app'
diff --git a/config-example.properties b/config-example.properties
index 4fa91a635e..29f56a2fcb 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -1,38 +1,49 @@
-#################
-### OSMReader ###
-
-# graph.dataaccess=MMAP_STORE_SYNC
+##### Vehicles #####
+#
+# Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
+# bike2 takes elevation data into account (like up-hill is slower than down-hill)
+# and requires enabling graph.elevation.provider below
+graph.flagEncoders=car
+
+# Enable turn restrictions for car or motorcycle. 
+# Currently you need to additionally set prepare.chWeighting=no before using this (see below and #270)
+# graph.flagEncoders=car|turnCosts=true
+
+
+##### Elevation #####
+#
+# To populate your graph with elevation data use SRTM, default is noop
+# graph.elevation.provider=srtm
+#
+# default location for cache is /tmp/srtm
+# graph.elevation.cachedir=./srtmprovider/
+#
+# If you have a slow disk or plenty of RAM change the default MMAP to:
+# graph.elevation.dataaccess=RAM_STORE
+
+
+
+##### Storage #####
+#
+# configure the memory access, use RAM_STORE for well equipped servers, 
+# MMAP_STORE_SYNC could be used otherwise but will be a lot slower
 graph.dataaccess=RAM_STORE
 
-# The high-resolution index is bigger and slightly slower but a lot more precise. see #17.
-# Resolution is in meter, decrease from 1000 to 500 in order to speed up queries (but will increase size)
-#index.highResolution=-1
-index.highResolution=500
-
-
-# use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
-# uncomment this if you need more control of you algorithm. then use graphhopper.chShortcuts(false, false)
-prepare.chShortcuts=fastest
-
-# advanced options:
-# prepare.updates.periodic=3
-# prepare.updates.lazy=10
-# prepare.updates.neighbor=20
-
-
-# increase from 1 to 5, to reduce way geometry e.g. for android
-osmreader.wayPointMaxDistance=1
-
-# possible options: CAR,FOOT,BIKE,MTB,RACINGBIKE (comma separated)
-# when using two or three option together remeber to set "prepare.chShortcuts=no" above
-osmreader.acceptWay=CAR
-
-# if you want to reduce storage size and you don't need instructions for a path uncomment this
+# if you want to reduce storage size and you don't need instructions for the resulting path use:
 # osmreader.instructions=false
 
-### default algorithm can be overwritten via the URL parameter &algorithm=<algo>
-### if you use fast routing you have to use dijkstrabi (bidirectional dijkstra)
-#web.defaultAlgorithm=astarbi
-#web.defaultAlgorithm=astar
-routing.defaultAlgorithm=dijkstrabi
-
+#### Speed-up Mode vs. Flexibility Mode ####
+#
+# By default the speed-up mode with the 'fastest' weighting is used. Internally a graph preparation via
+# contraction hierarchies is done to speed routing up. This requires more RAM/disc space for holding the
+# graph but less for every request. Also only the first vehicle of the flagEncoders list will be prepared.
+# prepare.chWeighting=fastest
+#
+# Disable the speed-up mode (contraction hierarchies, CH) via enabling the flexibility mode:
+# prepare.chWeighting=no
+
+
+##### Web #####
+# if you want to support jsonp response type you need to add it explicitely here. By default it is disabled for 
+# stronger security.
+# web.jsonpAllowed=true
diff --git a/core/files/N43E007hgt.zip b/core/files/N43E007hgt.zip
new file mode 100644
index 0000000000..e9e8bc8863
Binary files /dev/null and b/core/files/N43E007hgt.zip differ
diff --git a/core/files/N49E011hgt.zip b/core/files/N49E011hgt.zip
new file mode 100644
index 0000000000..0ffd881667
Binary files /dev/null and b/core/files/N49E011hgt.zip differ
diff --git a/core/files/N50E011hgt.zip b/core/files/N50E011hgt.zip
new file mode 100644
index 0000000000..623adc98a9
Binary files /dev/null and b/core/files/N50E011hgt.zip differ
diff --git a/core/files/N55W003hgt.zip b/core/files/N55W003hgt.zip
new file mode 100644
index 0000000000..265f900068
Binary files /dev/null and b/core/files/N55W003hgt.zip differ
diff --git a/core/files/N55W004hgt.zip b/core/files/N55W004hgt.zip
new file mode 100644
index 0000000000..3073befc2f
Binary files /dev/null and b/core/files/N55W004hgt.zip differ
diff --git a/core/files/S29W072hgt.zip b/core/files/S29W072hgt.zip
new file mode 100644
index 0000000000..fb536a1de7
Binary files /dev/null and b/core/files/S29W072hgt.zip differ
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 6faed098cc..7ffdcfced2 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,10 +1,69 @@
+0.4.0    
+    translation key turn changed and merged with left etc into turn_left, turn_right etc
+    create location index before preparation in the GraphHopper class
+    encodingManager.getSingle() is removed and flagEncoder list is no longer sorted, the first vehicle is used for CH preparation    
+    removed LocationIndexTreeSC, use new LocationIndexTree(levelGraph.getBaseGraph(), directory) instead
+    getLevel and setLevel do no longer automatically increase node count, use getNodeAccess.ensureNode for that
+    normal algorithms are now possible on prepared graph use getBaseGraph, see #116
+    GHResponse no longer has isFound method, use !hasErrors instead
+    merged unused Edge class into EdgeEntry
+    astar and astarbi are now both none-heuristic and take parameters for beeline approximation: astar.approximation=BeelineSimplification|BeelineAccurate or astarbi.approximation=...
+    making GPX export according to the schema to support import from various tools like basecamp
+    refactoring: AllEdgesIterator.getMaxId is now named getCount
+    major change of internal API: moved method "Path RoutingAlgorithm.calcPath(QueryResult,QueryResult)" to a helper method QueryGraph.lookup, call queryResult.getClosestNode for the calcPath(nodeFrom,nodeTo) method
+    no cachedWays and cachedPoints in Path anymore
+    Path.findInstruction was moved to InstructionList.find
+    if start and end point are identical an algorithm will find the path consisting only of one node, one point and one instruction (finish instruction), but without edges
+    astarbi has new default values for approximation (false) and approximation_factor (1.2) in RoutingAlgorithmFactorySimple
+    instead of strings use the variables in AlgorithmOptions to specify an algorithm
+    use RoutingAlgorithmFactorySimple instead of RoutingAlgorithmFactory, also more constistent algorithm preparation handling due to new AlgorithmOptions, therefor removed NoOpAlgorithmPreparation
+    GHResponse.getXX methods now fail fast (throw an exception) if an error while route calculation occured. See #287
+    renamed less often used URL parameter 'min_path_precision' to way_point_max_distance which makes it identical to the setWayPointMaxDistance method used for simplification at OSMImport
+    removed douglas.minprecision from Java API ghRequest.hints => use wayPointMaxDistance instead
+    encoder.supportTurnCost is replaced by encoder.supports(TurnWeighting.class)
+    CmdArgs is now a Map<String, String> instead Map<String, Object>. The value will be parsed up on every getXY call, makes storing string vs. object less error-prone
+    removed GHRequest.getHint, instead use the provided methods in GHRequest.getHints().getXY and GHRequest.getHints().put
+    important graph incompatibility as properties cannot be loaded. renamed osmreader.bytesForFlags to graph.bytesForFlags, renamed config property osmreader.acceptWay to graph.flagEncoders
+    default weighting is now fastest, fixing #261
+    moved method GraphHopper.main into tools module and class com.graphhopper.tools.Import, see #250
+    refactored GraphHopper.createWeighting to accept more than one configuration option, see #237
+    refactored GraphHopper.disableCHShortcuts to setCHEnable(boolean)
+    moving the boolean parameter of GraphHopper.setInMemory into a separate method setStoreOnFlush
+    renaming of GraphHopper.setCHShortcuts to setCHWeighting, as well as the property prepare.chShortcuts to prepare.chWeighting
+    jsonp is disabled by default. You need to enable it in the config.properties, see the config-example.properties
+    EncodingManager cannot be null in GraphHopperStorage. If you need to parse EncodingManager configuration from existing graph use EncodingManager.create
+    no reflection done in EncodingManager which improves portability and makes configuration of encoders possible before adding to manager
+    removed dijkstraNativebi as no performance advantage but maintenance disadvantage and similar to oneToManyDijkstra
+    to provide context for turn costs we needed to add prevEdgeId into Weighting.calcWeight, see new documentation
+    with the introduction of lock protection mechanism (see #112) GraphHopper needs always write access, see also #217
+    new GraphHopper.clean method to remove the graph directory via Java API    
+
 0.3.0
+    introduced prefer bits, now bike uses more bits and 3 bike encoder do not fit into 32 bit anymore, will be fixed later
+    moved Translation argument into Path.calcInstruction for more fine grained control, instructions are now uncached and GHRequest: new locale parameter
+    CoordTrig and the like are removed, GHPlace is mostly replaced by GHPoint and so GHRequest has now methods ala addPoint instead
+    removed isBoth from AbstractFlagEncoder, moved canBeOverwritten and associated test to PrepareEncoder
+    removed unused directory.rename
+    refactor edge.copyProperties into copyPropertiesTo to have similar semantics as Graph.copyTo
+    calcWeight now contains reverse boolean to calculate correct direction dependent weight
+    completely different web API response format. see docs/web
+    swapDirections is renamed to reverseFlags (EncodingManager and FlagEncoders)
+    edgeState.detach has now a reverse parameter, just use false to get previous results
+    web api: buildDate contains now timezone, algoType is replaced with weighting
+    dijkstraNative is now dijkstraNativebi
+    fixed #151
+    calcWeight now contains reverse boolean to calculate correct direction dependent weight
+    EncodingManager always takes the encoders in constructor, to force always init
+    GraphHopper.setMemory(true, true/false) was refactored to GraphHopper.setMemory(true/false), use mmap config via GraphHopper.setMemoryMapped()
+    incompatible edges => you need to re-import data and/or update the edges file
     the instructions of the web response does not contain times (string) but instead millis (long)
     PrepareContractionHierarchies.setPeriodicUpdates is now in percentage not in absolute counts
-    gpx export via API or HTTP (route?type=gpx)
-    breaking: The web response, Path.time and GHResponse.time change to milliseconds and 'long' (instead of seconds and double)
+    improved bike routing #132, #138, #139, #150
+    gpx export via API, HTTP (route?type=gpx) and web interface is possible: #113, #136, #141   
 
 0.2.0
+23 Nov 2013
+
     change inconsistent default settings for contraction hierarchies in the API - see https://lists.openstreetmap.org/pipermail/graphhopper/2013-December/000585.html
     fixed issues with android:
         graphhopper: use maps from 0.2 path; updated maps
diff --git a/core/files/circle-bug.osm.gz b/core/files/circle-bug.osm.gz
new file mode 100644
index 0000000000..b78469536b
Binary files /dev/null and b/core/files/circle-bug.osm.gz differ
diff --git a/core/files/licenses/D3-LICENSE.txt b/core/files/licenses/D3-LICENSE.txt
new file mode 100644
index 0000000000..fb7d95d70b
--- /dev/null
+++ b/core/files/licenses/D3-LICENSE.txt
@@ -0,0 +1,26 @@
+Copyright (c) 2014, Michael Bostock
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* The name Michael Bostock may not be used to endorse or promote products
+  derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/core/files/live_measurement.sh b/core/files/live_measurement.sh
deleted file mode 100755
index f37d9ab726..0000000000
--- a/core/files/live_measurement.sh
+++ /dev/null
@@ -1,59 +0,0 @@
-#!/bin/bash
-
-# before execution do
-# 1. cp files/measurement.sh files/live_measurement.sh
-#    to ensure that you have your customized measurement.sh file available and git has no problems to switch versions
-# 2. adapt memory usage in JAVA_OPTS
-# 3. adapt the OSM location GH_MAIN
-# 4. adapt last_commits
-
-GH_HOME=$(dirname $0)/..
-cd $GH_HOME
-
-JAVA=$JAVA_HOME/bin/java
-if [ "x$JAVA_HOME" = "x" ]; then
- JAVA=java
-fi
-
-VERSION=`grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<' -f1`
-JAR=target/graphhopper-$VERSION-jar-with-dependencies.jar
-
-# make sure this stays the same for all measurements
-JAVA_OPTS="-Xmx1000m -Xms1000m" 
-
-GH_MAIN=/media/SAMSUNG/maps/unterfranken
-
-# should we call?
-# mvn clean install assembly:single
-
-# import graph
-OSM_XML=$GH_MAIN.osm
-GL=$GH_MAIN-gh
-ARGS="osmreader.graph-location=$GL osmreader.osm=$OSM_XML osmreader.chShortcuts=fastest osmreader.type=CAR"
-echo -e "\ncreate graph via $ARGS, $JAR"
-$JAVA $JAVA_OPTS -cp $JAR com.graphhopper.reader.OSMReader $ARGS osmreader.doPrepare=false
-
-function startMeasurement {
-  COUNT=5000
-  ARGS="$ARGS osmreader.doPrepare=true measurement.count=$COUNT measurement.location=$M_FILE_NAME"
-  echo -e "\nperform measurement via $ARGS, $JAR"
-  $JAVA $JAVA_OPTS -cp $JAR com.graphhopper.util.Measurement $ARGS
-}
-
-# use current version
-mvn -DskipTests clean install assembly:single  
-startMeasurement
-exit
-
-# use git
-last_commits=1
-commits=$(git rev-list HEAD -n $last_commits)
-for commit in $commits; do
-  git checkout $commit -q
-  M_FILE_NAME=`git log -n 1 --pretty=oneline | grep -o "\ .*" |  tr " ,;" "_"`
-  M_FILE_NAME="measurement$M_FILE_NAME.properties"
-  echo -e "\nusing commit $commit and $M_FILE_NAME"
-  
-  mvn -DskipTests clean install assembly:single
-  startMeasurement
-done
diff --git a/core/files/north-bayreuth.osm.gz b/core/files/north-bayreuth.osm.gz
new file mode 100644
index 0000000000..53404479bc
Binary files /dev/null and b/core/files/north-bayreuth.osm.gz differ
diff --git a/core/files/release.sh b/core/files/release.sh
deleted file mode 100755
index 4ecc63bdd1..0000000000
--- a/core/files/release.sh
+++ /dev/null
@@ -1,79 +0,0 @@
-#!/bin/bash
-
-# assumptions:
-# 1. you have run unit and integration tests successfully
-# 2. no changes on master
-
-# TODO when we understand the commands we can use the release plugin
-# mvn release:clean 
-# # Prepare: build, test, release version update, commit, tag, next snapshot version update, commit
-# mvn release:prepare -DgenerateBackupPoms=false
-# # Perform: export a release from SCM, run the deploy goal
-# mvn release:perform
-# https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide
-
-GH_CORE_HOME=$(dirname $0)/..
-cd $GH_CORE_HOME
-VERSION=0.1
-NEW_VERSION=0.2-SNAPSHOT
-TARGET=./target
-GIT_E=true
-
-mvn versions:set -DnewVersion=$VERSION -DgenerateBackupPoms=false
-# as android is not referenced in parent we need to do it manually
-cd android
-mvn versions:set -DnewVersion=$VERSION -DgenerateBackupPoms=false
-cd ..
-
-if [ "x$GIT_E" = "xtrue" ]; then
-  git checkout -b $VERSION
-  git add .
-  git commit -m "releasing $VERSION"
-fi
-
-
-##############################
-# create jar and android files
-mvn -DskipTests=true clean install assembly:single
-
-if [ $? -ne 0 ]; then
-  echo "cannot install jars?"
-  exit
-fi  
-
-# now create binary distribution where no maven is necessary to run import
-cp ../graphhopper.sh $TARGET/graphhopper.sh
-JAR=`cd $TARGET && ls -1 *-with-dependencies.jar`
-# use @ instead of the common / to avoid problems with paths in $JAR
-sed -i "s@JAR=.*@JAR=$JAR@g" $TARGET/graphhopper.sh
-# if you use -x option use backslash avoids shell substitution e.g. -x \*~
-zip -j $TARGET/graphhopper-$VERSION-bin.zip $TARGET/graphhopper.sh $TARGET/$JAR ../config-example.properties ../*.txt ../*.md
-
-
-########################
-# deployment to sonatype
-$MVN install deploy
-
-if [ $? -ne 0 ]; then
-  echo "cannot deploy to sonatype?"
-  exit
-fi    
-
-cd android
-export ANDROID_HOME=/install/android/sdk
-$MVN clean install deploy
-cd ..
-
-
-##########################
-# deployment to our server
-
-# TODO
-
-mvn versions:set -DnewVersion=$NEW_VERSION -DgenerateBackupPoms=false
-
-if [ "x$GIT_E" = "xtrue" ]; then
-  git checkout master
-  git add .
-  git commit -m "new development version $NEW_VERSION"
-fi
diff --git a/core/files/travis-build.sh b/core/files/travis-build.sh
index 7ff63eb41d..5f7138d9b3 100755
--- a/core/files/travis-build.sh
+++ b/core/files/travis-build.sh
@@ -1,20 +1,22 @@
 HOME=$(dirname $0)
 cd $HOME/../..
 
-modules="core web tools"
-for module in $modules; do
-  echo "====== INSTALL $module ====="
-  mvn -pl $module install -DskipTests=true
-  EXIT_VAL="$?"    
-  if [[ "x$EXIT_VAL" != "x0" ]]; then
-    exit $EXIT_VAL
-  fi 
-  
-  echo "====== TEST $module ====="
-  # verify necessary for failsafe, otherwise it won't fail the build!?
-  mvn -pl $module test failsafe:integration-test verify  
-  EXIT_VAL="$?"
-  if [[ "x$EXIT_VAL" != "x0" ]]; then
-    exit $EXIT_VAL
-  fi
-done
+mvn clean test verify
+
+#modules="core web tools"
+#for module in $modules; do
+#  echo "====== INSTALL $module ====="
+#  mvn -pl $module clean install -DskipTests=true
+#  EXIT_VAL="$?"    
+#  if [[ "x$EXIT_VAL" != "x0" ]]; then
+#    exit $EXIT_VAL
+#  fi 
+#  
+#  echo "====== TEST $module ====="
+#  # verify necessary for failsafe, otherwise it won't fail the build!?
+#  mvn -pl $module test failsafe:integration-test verify  
+#  EXIT_VAL="$?"
+#  if [[ "x$EXIT_VAL" != "x0" ]]; then
+#    exit $EXIT_VAL
+#  fi
+#done
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index 53eb2827ae..4bea556c07 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,11 +3,12 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP de_DE ro pt_PT bg es ru ja fr si tr SKIP SKIP"
+translations="en_US SKIP bg ca de_DE el es fil fi fr gl he it ja ne nl pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
 file=$1
-#file=/tmp/gh.csv
-#rm $file
-#wget -O $file "https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc&pli=1&output=csv"
+
+# You can execute the following
+# curl "https://docs.google.com/spreadsheet/pub?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc&single=true&gid=0&output=txt" > tmp.tsv
+# ./files/update-translations.sh tmp.tsv && rm tmp.tsv
 
 INDEX=1
 for tr in $translations; do
@@ -15,6 +16,6 @@ for tr in $translations; do
   if [[ "x$tr" = "xSKIP" ]]; then
     continue
   fi
-   
-  tail -n+6 "$file" | cut -d',' -s -f1,$INDEX --output-delimiter='=' > $destination/$tr.txt
+  echo -e '# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh\n' > $destination/$tr.txt
+  tail -n+5 "$file" | cut -s -f1,$INDEX --output-delimiter='=' >> $destination/$tr.txt
 done
diff --git a/core/nb-configuration.xml b/core/nb-configuration.xml
index 1286047075..c95ec72546 100644
--- a/core/nb-configuration.xml
+++ b/core/nb-configuration.xml
@@ -19,7 +19,6 @@
         That way multiple projects can share the same settings (useful for formatting rules for example).
         Any value defined here will override the pom.xml file value but is only applicable to the current project.
         -->
-        <netbeans.hint.jdkPlatform>JDK_1.6</netbeans.hint.jdkPlatform>
         <org-netbeans-modules-whitelist.whitelist-oracle>false</org-netbeans-modules-whitelist.whitelist-oracle>
         <netbeans.compile.on.save>all</netbeans.compile.on.save>
     </properties>
diff --git a/core/nbactions.xml b/core/nbactions.xml
index 7e7600b52f..79681aad55 100644
--- a/core/nbactions.xml
+++ b/core/nbactions.xml
@@ -18,7 +18,7 @@
         </goals>
         <properties>
             <exec.classpathScope>runtime</exec.classpathScope>
-            <exec.args>-classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=../extract.osm</exec.args>
+            <exec.args>-classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=./files/moscow.osm.gz</exec.args>
             <exec.executable>java</exec.executable>
         </properties>
     </action>
@@ -30,7 +30,7 @@
         </goals>
         <properties>
             <exec.classpathScope>runtime</exec.classpathScope>
-            <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=../extract.osm</exec.args>
+            <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=./files/moscow.osm.gz</exec.args>
             <jpda.listen>true</jpda.listen>
             <exec.executable>java</exec.executable>
         </properties>
@@ -42,7 +42,7 @@
             <goal>org.codehaus.mojo:exec-maven-plugin:1.1.1:exec</goal>
         </goals>
         <properties>
-            <exec.args>-classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=../extract.osm</exec.args>
+            <exec.args>-classpath %classpath com.graphhopper.GraphHopper config=../config.properties osmreader.osm=./files/moscow.osm.gz</exec.args>
             <profiler.action>profile</profiler.action>
             <exec.executable>${profiler.java}</exec.executable>
         </properties>
diff --git a/core/pom.xml b/core/pom.xml
index afb0d2658d..451f8706ad 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper</artifactId>
     <name>GraphHopper</name>
-    <version>0.3-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <packaging>jar</packaging> 
     <description>
         GraphHopper is a fast and memory efficient Java road routing engine 
@@ -15,12 +15,12 @@
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.3-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
         
     <properties>  
         <netbeans.hint.license>apache20</netbeans.hint.license>        
-        <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm</maven.build.timestamp.format>        
+        <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>        
         <builddate>${maven.build.timestamp}</builddate>        
     </properties>
     <licenses>
@@ -49,7 +49,7 @@
             <groupId>ch.qos.logback</groupId>
             <artifactId>logback-classic</artifactId>
             <version>1.0.13</version>
-            <scope>runtime</scope>
+            <scope>test</scope>
         </dependency>
         -->
         
@@ -57,25 +57,41 @@
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-log4j12</artifactId>
             <version>${slf4j.version}</version>
-            <scope>runtime</scope>
+            <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>log4j</groupId>
             <artifactId>log4j</artifactId>
             <version>${log4j.version}</version>
-            <scope>runtime</scope>
+            <scope>test</scope>
+        </dependency>
+        
+        <!-- for using CGIAR: elevation data importing via tif files-->
+        <dependency>
+            <groupId>org.apache.xmlgraphics</groupId>
+            <artifactId>xmlgraphics-commons</artifactId>
+            <version>1.5</version>
         </dependency>
         
         <dependency>
             <groupId>com.google.protobuf</groupId>
             <artifactId>protobuf-java</artifactId>
-            <version>2.5.0</version>
+            <version>2.6.1</version>
         </dependency>        
         <dependency>
             <groupId>org.openstreetmap.osmosis</groupId>
             <artifactId>osmosis-osm-binary</artifactId>
             <version>0.43.1</version>
         </dependency>
+
+        <dependency>
+            <groupId>org.json</groupId>
+            <artifactId>json</artifactId>
+            <!-- keep oldish version as we want to support 1.5 for a while -->
+            <version>20140107</version>
+            <scope>test</scope>
+        </dependency>
+        
     </dependencies>
         
     <build>
@@ -84,56 +100,18 @@
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-assembly-plugin</artifactId>
-                    <version>2.4</version>
-                    <configuration>
-                        <archive>
-                            <manifest>
-                                <mainClass>com.graphhopper.reader.OSMReader</mainClass>
-                            </manifest>
-                        </archive>
+                    <configuration>                     
                         <!-- for usage on android -->
                         <descriptors>
                             <descriptor>src/main/assembly/android.xml</descriptor>
                         </descriptors>
-	                    
-                        <!-- for standalone usage -->
-                        <descriptorRefs>
-                            <descriptorRef>jar-with-dependencies</descriptorRef>
-                        </descriptorRefs>
-                    </configuration>
-                </plugin>
-                <plugin>
-                    <groupId>org.apache.maven.plugins</groupId>
-                    <artifactId>maven-site-plugin</artifactId>
-                    <version>3.3</version>
-                    <configuration>
-                        <reportPlugins>
-                            <plugin>
-                                <!-- either call mvn compile site or mvn findbugs:gui -->
-                                <groupId>org.codehaus.mojo</groupId>
-                                <artifactId>findbugs-maven-plugin</artifactId>
-                                <version>2.5.2</version>
-                                <configuration>
-                                    <!-- <xmlOutput>true</xmlOutput> -->
-                                    <!-- Optional directory to put FindBugs xdoc xml report -->
-                                    <xmlOutputDirectory>target/site</xmlOutputDirectory>
-                                    <threshold>Normal</threshold>
-                                    <effort>Default</effort>
-                                    <!--
-                                    <threshold>High|Normal|Low|Exp|Ignore</threshold>
-                                    <effort>Min|Default|Max</effort>
-                                    -->
-                                </configuration>
-                            </plugin>
-                        </reportPlugins>
                     </configuration>
-                </plugin>
+                </plugin>                
                 
                 <!-- create jar with test classes to be reused in other projects -->                
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-jar-plugin</artifactId>
-                    <version>2.4</version>
                     <executions>
                         <execution>
                             <goals>
diff --git a/core/src/main/assembly/android.xml b/core/src/main/assembly/android.xml
index 92561e7f09..b3bdba3373 100644
--- a/core/src/main/assembly/android.xml
+++ b/core/src/main/assembly/android.xml
@@ -11,11 +11,10 @@
             <unpack>true</unpack>
             <scope>runtime</scope>
             <excludes>
-                <exclude>org.slf4j:slf4j-api</exclude>
-                <exclude>org.slf4j:slf4j-log4j12</exclude>
-                <exclude>log4j:log4j</exclude>
+                <!-- <exclude>org.slf4j:slf4j-api</exclude>-->                
                 <exclude>com.google.protobuf:protobuf-java</exclude>
                 <exclude>org.openstreetmap.osmosis:osmosis-osm-binary</exclude>
+                <exclude>org.apache.xmlgraphics:xmlgraphics-commons</exclude>
             </excludes>
         </dependencySet>
     </dependencySets>
diff --git a/core/src/main/java/com/graphhopper/GHRequest.java b/core/src/main/java/com/graphhopper/GHRequest.java
index c8e4055bef..f68f7cf332 100644
--- a/core/src/main/java/com/graphhopper/GHRequest.java
+++ b/core/src/main/java/com/graphhopper/GHRequest.java
@@ -17,67 +17,91 @@
  */
 package com.graphhopper;
 
-import com.graphhopper.util.shapes.GHPlace;
-import java.util.HashMap;
-import java.util.Map;
+import com.graphhopper.routing.util.WeightingMap;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
 
 /**
  * GraphHopper request wrapper to simplify requesting GraphHopper.
  * <p/>
  * @author Peter Karich
+ * @author ratrun
  */
 public class GHRequest
 {
-    private String algo = "dijkstrabi";
-    private GHPlace from;
-    private GHPlace to;
-    private Map<String, Object> hints = new HashMap<String, Object>(5);
-    private String vehicle = "CAR";
-    private String weighting = "shortest";
+    private String algo = "";
+    private List<GHPoint> points;
+    private final WeightingMap hints = new WeightingMap();
+    private String vehicle = "";
+    private boolean possibleToAdd = false;
+    private Locale locale = Locale.US;
+
+    public GHRequest()
+    {
+        this(5);
+    }
+
+    public GHRequest( int size )
+    {
+        points = new ArrayList<GHPoint>(size);
+        possibleToAdd = true;
+    }
 
     /**
-     * Calculate the path from specified startPoint (fromLat, fromLon) to endPoint (toLat, toLon).
+     * Calculate the path from specified startPlace (fromLat, fromLon) to endPlace (toLat, toLon).
      */
     public GHRequest( double fromLat, double fromLon, double toLat, double toLon )
     {
-        this(new GHPlace(fromLat, fromLon), new GHPlace(toLat, toLon));
+        this(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon));
     }
 
     /**
-     * Calculate the path from specified startPoint to endPoint.
+     * Calculate the path from specified startPlace to endPlace.
      */
-    public GHRequest( GHPlace startPoint, GHPlace endPoint )
+    public GHRequest( GHPoint startPlace, GHPoint endPlace )
     {
-        this.from = startPoint;
-        this.to = endPoint;
+        if (startPlace == null)
+            throw new IllegalStateException("'from' cannot be null");
+
+        if (endPlace == null)
+            throw new IllegalStateException("'to' cannot be null");
+        points = new ArrayList<GHPoint>(2);
+        points.add(startPlace);
+        points.add(endPlace);
     }
 
-    public void check()
+    public GHRequest( List<GHPoint> points )
     {
-        if (from == null)
-            throw new IllegalStateException("the 'from' point needs to be initialized but was null");
-
-        if (to == null)
-            throw new IllegalStateException("the 'to' point needs to be initialized but was null");
+        this.points = points;
     }
 
-    public GHPlace getFrom()
+    public GHRequest addPoint( GHPoint point )
     {
-        return from;
+        if (point == null)
+            throw new IllegalArgumentException("point cannot be null");
+        if (!possibleToAdd)
+            throw new IllegalStateException("Please call empty constructor if you intent to use "
+                    + "more than two places via addPlace method.");
+
+        points.add(point);
+        return this;
     }
 
-    public GHPlace getTo()
+    public List<GHPoint> getPoints()
     {
-        return to;
+        return points;
     }
 
     /**
-     * Possible values: astar (A* algorithm, default), astarbi (bidirectional A*) dijkstra
-     * (Dijkstra), dijkstrabi and dijkstraNative (a bit faster bidirectional Dijkstra).
+     * For possible values see AlgorithmOptions.*
      */
     public GHRequest setAlgorithm( String algo )
     {
-        this.algo = algo;
+        if (algo != null)
+            this.algo = algo;
         return this;
     }
 
@@ -86,48 +110,44 @@ public String getAlgorithm()
         return algo;
     }
 
-    public GHRequest putHint( String key, Object value )
+    public Locale getLocale()
     {
-        Object old = hints.put(key, value);
-        if (old != null)
-            throw new RuntimeException("Key is already associated with " + old + ", your value:" + value);
-
-        return this;
+        return locale;
     }
 
-    @SuppressWarnings("unchecked")
-    public <T> T getHint( String key, T defaultValue )
+    public GHRequest setLocale( Locale locale )
     {
-        Object obj = hints.get(key);
-        if (obj == null)
-            return defaultValue;
-
-        return (T) obj;
+        if (locale != null)
+            this.locale = locale;
+        return this;
     }
 
-    @Override
-    public String toString()
+    public GHRequest setLocale( String localeStr )
     {
-        return from + " " + to + " (" + algo + ")";
+        return setLocale(Helper.getLocale(localeStr));
     }
 
     /**
-     * By default it supports fastest and shortest
+     * By default it supports fastest and shortest. Or specify empty to use default.
      */
     public GHRequest setWeighting( String w )
     {
-        this.weighting = w;
+        hints.setWeighting(w);
         return this;
     }
 
     public String getWeighting()
     {
-        return weighting;
+        return hints.getWeighting();
     }
 
+    /**
+     * Specifiy car, bike or foot. Or specify empty to use default.
+     */
     public GHRequest setVehicle( String vehicle )
     {
-        this.vehicle = vehicle;
+        if (vehicle != null)
+            this.vehicle = vehicle;
         return this;
     }
 
@@ -135,4 +155,23 @@ public String getVehicle()
     {
         return vehicle;
     }
+
+    @Override
+    public String toString()
+    {
+        String res = "";
+        for (GHPoint point : points)
+        {
+            if (res.isEmpty())
+                res = point.toString();
+            else
+                res += "; " + point.toString();
+        }
+        return res + "(" + algo + ")";
+    }
+
+    public WeightingMap getHints()
+    {
+        return hints;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index 2f13f0c526..0d6f70f1b9 100644
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -20,7 +20,6 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -31,26 +30,74 @@
  */
 public class GHResponse
 {
+    private String debugInfo = "";
+    private final List<Throwable> errors = new ArrayList<Throwable>(4);
     private PointList list = PointList.EMPTY;
     private double distance;
+    private double routeWeight;
     private long time;
-    private String debugInfo = "";
-    private final List<Throwable> errors = new ArrayList<Throwable>(4);
-    private InstructionList instructions = new InstructionList(0);
-    private boolean found;
+    private InstructionList instructions = null;
 
     public GHResponse()
     {
     }
 
+    public String getDebugInfo()
+    {
+        check("getDebugInfo");
+        return debugInfo;
+    }
+
+    public GHResponse setDebugInfo( String debugInfo )
+    {
+        if (debugInfo != null)
+            this.debugInfo = debugInfo;
+        return this;
+    }
+
+    private void check( String method )
+    {
+        if (hasErrors())
+        {
+            throw new RuntimeException("You cannot call " + method + " if response contains errors. Check this with ghResponse.hasErrors(). "
+                    + "Errors are: " + getErrors());
+        }
+    }
+
+    /**
+     * @return true if one or more error found
+     */
+    public boolean hasErrors()
+    {
+        return !errors.isEmpty();
+    }
+
+    public List<Throwable> getErrors()
+    {
+        return errors;
+    }
+
+    @SuppressWarnings("unchecked")
+    public GHResponse addError( Throwable error )
+    {
+        errors.add(error);
+        return this;
+    }
+
     public GHResponse setPoints( PointList points )
     {
         list = points;
         return this;
     }
 
+    /**
+     * This method returns all points on the path. Keep in mind that calculating the distance from
+     * these point might yield different results compared to getDistance as points could have been
+     * simplified on import or after querying.
+     */
     public PointList getPoints()
     {
+        check("getPoints");
         return list;
     }
 
@@ -61,10 +108,14 @@ public GHResponse setDistance( double distance )
     }
 
     /**
+     * This method returns the distance of the path. Always prefer this method over
+     * getPoints().calcDistance
+     * <p>
      * @return distance in meter
      */
     public double getDistance()
     {
+        check("getDistance");
         return distance;
     }
 
@@ -79,23 +130,34 @@ public GHResponse setMillis( long timeInMillis )
      */
     public long getMillis()
     {
+        check("getMillis");
         return time;
     }
 
-    public GHResponse setFound( boolean found )
+    public GHResponse setRouteWeight( double weight )
     {
-        this.found = found;
+        this.routeWeight = weight;
         return this;
     }
 
-    public boolean isFound()
+    /**
+     * This method returns a double value which is better than the time for comparison of routes but
+     * only if you know what you are doing, e.g. only to compare routes gained with the same query
+     * parameters like vehicle.
+     */
+    public double getRouteWeight()
     {
-        return found;
+        check("getRouteWeight");
+        return routeWeight;
     }
 
+    /**
+     * Calculates the bounding box of this route response
+     */
     public BBox calcRouteBBox( BBox _fallback )
     {
-        BBox bounds = BBox.INVERSE.clone();
+        check("calcRouteBBox");
+        BBox bounds = BBox.createInverse(_fallback.hasElevation());
         int len = list.getSize();
         if (len == 0)
             return _fallback;
@@ -104,55 +166,29 @@ public BBox calcRouteBBox( BBox _fallback )
         {
             double lat = list.getLatitude(i);
             double lon = list.getLongitude(i);
-            if (lat > bounds.maxLat)
-                bounds.maxLat = lat;
-
-            if (lat < bounds.minLat)
-                bounds.minLat = lat;
-
-            if (lon > bounds.maxLon)
-                bounds.maxLon = lon;
-
-            if (lon < bounds.minLon)
-                bounds.minLon = lon;
+            if (bounds.hasElevation())
+            {
+                double ele = list.getEle(i);
+                bounds.update(lat, lon, ele);
+            } else
+            {
+                bounds.update(lat, lon);
+            }
         }
         return bounds;
     }
 
-    public String getDebugInfo()
-    {
-        return debugInfo;
-    }
-
-    public GHResponse setDebugInfo( String debugInfo )
-    {
-        this.debugInfo = debugInfo;
-        return this;
-    }
-
-    /**
-     * @return true if one or more error found
-     */
-    public boolean hasErrors()
-    {
-        return !errors.isEmpty();
-    }
-
-    public List<Throwable> getErrors()
-    {
-        return errors;
-    }
-
-    public GHResponse addError( Throwable error )
-    {
-        errors.add(error);
-        return this;
-    }
-
     @Override
     public String toString()
     {
-        return "found:" + isFound() + ", nodes:" + list.getSize() + ": " + list.toString();
+        String str = "nodes:" + list.getSize() + ": " + list.toString();
+        if (!instructions.isEmpty())
+            str += ", " + instructions.toString();
+
+        if (hasErrors())
+            str += ", " + errors.toString();
+
+        return str;
     }
 
     public void setInstructions( InstructionList instructions )
@@ -162,6 +198,10 @@ public void setInstructions( InstructionList instructions )
 
     public InstructionList getInstructions()
     {
+        check("getInstructions");
+        if (instructions == null)
+            throw new IllegalArgumentException("To access instructions you need to enable creation before routing");
+
         return instructions;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index bf3ca63bbf..66b26d64dc 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -17,83 +17,90 @@
  */
 package com.graphhopper;
 
+import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.OSMReader;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.reader.dem.CGIARProvider;
+import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.*;
 import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
 
 import java.io.File;
 import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicLong;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Main wrapper of the offline API for a simple and efficient usage.
+ * Easy to use access point to configure import and (offline) routing.
  * <p/>
  * @see GraphHopperAPI
  * @author Peter Karich
  */
 public class GraphHopper implements GraphHopperAPI
 {
-    public static void main( String[] strs ) throws Exception
-    {
-        CmdArgs args = CmdArgs.read(strs);
-        GraphHopper hopper = new GraphHopper().init(args);
-        hopper.importOrLoad();
-        RoutingAlgorithmSpecialAreaTests tests = new RoutingAlgorithmSpecialAreaTests(hopper);
-        if (args.getBool("graph.testIT", false))
-            tests.start();
-    }
-
     private final Logger logger = LoggerFactory.getLogger(getClass());
     // for graph:
     private GraphStorage graph;
+    private EncodingManager encodingManager;
+    private int defaultSegmentSize = -1;
     private String ghLocation = "";
-    private DAType dataAccessType = DAType.RAM;
+    private DAType dataAccessType = DAType.RAM_STORE;
     private boolean sortGraph = false;
     boolean removeZipped = true;
-    // for routing:
-    private boolean simplifyRequest = true;
-    // for index:
+    private boolean elevation = false;
+    private LockFactory lockFactory = new NativeFSLockFactory();
+    private final String fileLockName = "gh.lock";
+    private boolean allowWrites = true;
+    boolean enableInstructions = true;
+    private boolean fullyLoaded = false;
+    // for routing
+    private double defaultWeightLimit = Double.MAX_VALUE;
+    private boolean simplifyResponse = true;
+    private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private String defaultVehicleStr;
+    private RoutingAlgorithmFactory algoFactory;
+    // for index
     private LocationIndex locationIndex;
-    private int preciseIndexResolution = 500;
-    private boolean searchRegion = true;
+    private int preciseIndexResolution = 300;
+    private int maxRegionSearch = 4;
     // for prepare
     private int minNetworkSize = 200;
-    // for CH prepare
-    private AlgorithmPreparation prepare;
+    private int minOneWayNetworkSize = 0;
+    // for CH prepare    
     private boolean doPrepare = true;
     private boolean chEnabled = true;
-    private String chWeighting = "fastest";
-    private int periodicUpdates = 20;
-    private int lazyUpdates = 10;
-    private int neighborUpdates = 20;
-    private double logMessages = 20;
-    // for OSM import:
+    private String chWeightingStr = "fastest";
+    private int periodicUpdates = -1;
+    private int lazyUpdates = -1;
+    private int neighborUpdates = -1;
+    private double logMessages = -1;
+    // for OSM import
     private String osmFile;
-    private EncodingManager encodingManager;
-    private long expectedCapacity = 100;
-    private double wayPointMaxDistance = 1;
+    private double osmReaderWayPointMaxDistance = 1;
     private int workerThreads = -1;
-    private int defaultSegmentSize = -1;
-    private boolean turnCosts = false;
-    private boolean enableInstructions = true;
     private boolean calcPoints = true;
-    private boolean fullyLoaded = false;
+    // utils    
+    private final TranslationMap trMap = new TranslationMap().doImport();
+    private ElevationProvider eleProvider = ElevationProvider.NOOP;
+    private final AtomicLong visitedSum = new AtomicLong(0);
 
     public GraphHopper()
     {
     }
 
     /**
-     * For testing
+     * For testing only
      */
-    GraphHopper loadGraph( GraphStorage g )
+    protected GraphHopper loadGraph( GraphStorage g )
     {
         this.graph = g;
         fullyLoaded = true;
@@ -101,37 +108,112 @@ GraphHopper loadGraph( GraphStorage g )
         return this;
     }
 
-    public GraphHopper setEncodingManager( EncodingManager acceptWay )
+    /**
+     * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
+     * how data from every vehicle is written (und read) into edges of the graph.
+     */
+    public GraphHopper setEncodingManager( EncodingManager em )
     {
         ensureNotLoaded();
-        this.encodingManager = acceptWay;
+        this.encodingManager = em;
+        if (em.needsTurnCostsSupport())
+            traversalMode = TraversalMode.EDGE_BASED_2DIR;
+
         return this;
     }
 
+    FlagEncoder getDefaultVehicle()
+    {
+        if (encodingManager == null)
+        {
+            throw new IllegalStateException("No encoding manager specified or loaded");
+        }
+
+        return encodingManager.fetchEdgeEncoders().get(0);
+    }
+
     public EncodingManager getEncodingManager()
     {
         return encodingManager;
     }
 
+    public GraphHopper setElevationProvider( ElevationProvider eleProvider )
+    {
+        if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
+            setElevation(false);
+        else
+            setElevation(true);
+        this.eleProvider = eleProvider;
+        return this;
+    }
+
+    /**
+     * Threads for data reading.
+     */
+    protected int getWorkerThreads()
+    {
+        return workerThreads;
+    }
+
+    /**
+     * Return maximum distance (in meter) to reduce points via douglas peucker while OSM import.
+     */
+    protected double getWayPointMaxDistance()
+    {
+        return osmReaderWayPointMaxDistance;
+    }
+
+    /**
+     * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
+     * value means more details, unit is meter. Default is 1. Disable via 0.
+     */
+    public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
+    {
+        this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
+        return this;
+    }
+
+    /**
+     * Sets the default traversal mode used for the algorithms and preparation.
+     */
+    public GraphHopper setTraversalMode( TraversalMode traversalMode )
+    {
+        this.traversalMode = traversalMode;
+        return this;
+    }
+
+    public TraversalMode getTraversalMode()
+    {
+        return traversalMode;
+    }
+
+    /**
+     * Configures the underlying storage and response to be used on a well equipped server. Result
+     * also optimized for usage in the web module i.e. try reduce network IO.
+     */
     public GraphHopper forServer()
     {
-        // simplify to reduce network IO
-        setSimplifyRequest(true);
-        setPreciseIndexResolution(500);
-        return setInMemory(true, true);
+        setSimplifyResponse(true);
+        return setInMemory();
     }
 
+    /**
+     * Configures the underlying storage to be used on a Desktop computer or within another Java
+     * application with enough RAM but no network latency.
+     */
     public GraphHopper forDesktop()
     {
-        setSimplifyRequest(false);
-        setPreciseIndexResolution(500);
-        return setInMemory(true, true);
+        setSimplifyResponse(false);
+        return setInMemory();
     }
 
+    /**
+     * Configures the underlying storage to be used on a less powerful machine like Android or
+     * Raspberry Pi with only few MB of RAM.
+     */
     public GraphHopper forMobile()
     {
-        setSimplifyRequest(false);
-        setPreciseIndexResolution(500);
+        setSimplifyResponse(false);
         return setMemoryMapped();
     }
 
@@ -147,92 +229,132 @@ public GraphHopper setPreciseIndexResolution( int precision )
         return this;
     }
 
-    public GraphHopper setInMemory( boolean inMemory, boolean storeOnFlush )
+    public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
+    {
+        this.minNetworkSize = minNetworkSize;
+        this.minOneWayNetworkSize = minOneWayNetworkSize;
+    }
+
+    /**
+     * This method call results in an in-memory graph.
+     */
+    public GraphHopper setInMemory()
     {
         ensureNotLoaded();
-        if (inMemory)
-        {
-            if (storeOnFlush)
-                dataAccessType = DAType.RAM_STORE;
-            else
-                dataAccessType = DAType.RAM;
-        } else
-        {
-            setMemoryMapped();
-        }
+        dataAccessType = DAType.RAM_STORE;
         return this;
     }
 
-    public GraphHopper setMemoryMapped()
+    /**
+     * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
+     * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
+     * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
+     * <p>
+     * @param storeOnFlush true by default
+     */
+    public GraphHopper setStoreOnFlush( boolean storeOnFlush )
     {
         ensureNotLoaded();
-        dataAccessType = DAType.MMAP;
+        if (storeOnFlush)
+            dataAccessType = DAType.RAM_STORE;
+        else
+            dataAccessType = DAType.RAM;
         return this;
     }
 
-    // not yet stable enough to offer it for everyone
-    private GraphHopper setUnsafeMemory()
+    /**
+     * Enable memory mapped configuration if not enough memory is available on the target platform.
+     */
+    public GraphHopper setMemoryMapped()
     {
         ensureNotLoaded();
-        dataAccessType = DAType.UNSAFE_STORE;
+        dataAccessType = DAType.MMAP;
         return this;
     }
 
-    public GraphHopper setDoPrepare( boolean doPrepare )
+    /**
+     * Not yet stable enough to offer it for everyone
+     */
+    private GraphHopper setUnsafeMemory()
     {
-        this.doPrepare = doPrepare;
+        ensureNotLoaded();
+        dataAccessType = DAType.UNSAFE_STORE;
         return this;
     }
 
     /**
-     * Enables the use of contraction hierarchies to reduce query times.
+     * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p/>
      * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
-     * @see #disableCHShortcuts()
+     * @see #setCHEnable(boolean)
      */
-    public GraphHopper setCHShortcuts( String weighting )
+    public GraphHopper setCHWeighting( String weighting )
     {
         ensureNotLoaded();
-        chEnabled = true;
-        chWeighting = weighting;
+        chWeightingStr = weighting;
         return this;
     }
 
     public String getCHWeighting()
     {
-        return chWeighting;
+        return chWeightingStr;
+    }
+
+    /**
+     * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
+     * the full usage of CH use setCHEnable(false) instead.
+     */
+    public GraphHopper setDoPrepare( boolean doPrepare )
+    {
+        this.doPrepare = doPrepare;
+        return this;
     }
 
     /**
-     * Disables contraction hierarchies. Enabled by default.
+     * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
+     * Disabling CH is only recommended for short routes or in combination with
+     * setDefaultWeightLimit and called flexibility mode
+     * <p>
+     * @see #setDefaultWeightLimit(double)
      */
-    public GraphHopper disableCHShortcuts()
+    public GraphHopper setCHEnable( boolean enable )
     {
         ensureNotLoaded();
-        chEnabled = false;
+        algoFactory = null;
+        chEnabled = enable;
         return this;
     }
 
+    /**
+     * This methods stops the algorithm from searching further if the resulting path would go over
+     * specified weight, important if CH is disabled. The unit is defined by the used weighting
+     * created from createWeighting, e.g. distance for shortest or seconds for the standard
+     * FastestWeighting implementation.
+     */
+    public void setDefaultWeightLimit( double defaultWeightLimit )
+    {
+        this.defaultWeightLimit = defaultWeightLimit;
+    }
+
     public boolean isCHEnabled()
     {
         return chEnabled;
     }
 
     /**
-     * @return if import of turn restrictions is enabled
+     * @return true if storing and fetching elevation data is enabled. Default is false
      */
-    public boolean isEnableTurnRestrictions()
+    public boolean hasElevation()
     {
-        return turnCosts;
+        return elevation;
     }
 
     /**
-     * This method specifies if the import should include turn restrictions if available
+     * Enable storing and fetching elevation data. Default is false
      */
-    public GraphHopper setEnableTurnRestrictions( boolean b )
+    public GraphHopper setElevation( boolean includeElevation )
     {
-        ensureNotLoaded();
-        turnCosts = b;
+        this.elevation = includeElevation;
         return this;
     }
 
@@ -260,9 +382,9 @@ public GraphHopper setEnableCalcPoints( boolean b )
      * This method specifies if the returned path should be simplified or not, via douglas-peucker
      * or similar algorithm.
      */
-    private GraphHopper setSimplifyRequest( boolean doSimplify )
+    private GraphHopper setSimplifyResponse( boolean doSimplify )
     {
-        this.simplifyRequest = doSimplify;
+        this.simplifyResponse = doSimplify;
         return this;
     }
 
@@ -273,7 +395,7 @@ public GraphHopper setGraphHopperLocation( String ghLocation )
     {
         ensureNotLoaded();
         if (ghLocation == null)
-            throw new NullPointerException("graphhopper location cannot be null");
+            throw new IllegalArgumentException("graphhopper location cannot be null");
 
         this.ghLocation = ghLocation;
         return this;
@@ -303,7 +425,12 @@ public String getOSMFile()
         return osmFile;
     }
 
-    public Graph getGraph()
+    /**
+     * The underlying graph used in algorithms.
+     * <p>
+     * @throws IllegalStateException if graph is not instantiated.
+     */
+    public GraphStorage getGraph()
     {
         if (graph == null)
             throw new IllegalStateException("Graph not initialized");
@@ -316,6 +443,16 @@ public void setGraph( GraphStorage graph )
         this.graph = graph;
     }
 
+    protected void setLocationIndex( LocationIndex locationIndex )
+    {
+        this.locationIndex = locationIndex;
+    }
+
+    /**
+     * The location index created from the graph.
+     * <p>
+     * @throws IllegalStateException if index is not initialized
+     */
     public LocationIndex getLocationIndex()
     {
         if (locationIndex == null)
@@ -324,13 +461,8 @@ public LocationIndex getLocationIndex()
         return locationIndex;
     }
 
-    public AlgorithmPreparation getPreparation()
-    {
-        return prepare;
-    }
-
     /**
-     * Sorts the graph which requires more RAM while import.
+     * Sorts the graph which requires more RAM while import. See #12
      */
     public GraphHopper setSortGraph( boolean sortGraph )
     {
@@ -339,23 +471,34 @@ public GraphHopper setSortGraph( boolean sortGraph )
         return this;
     }
 
-    /*
-     * Command line configuration overwrites the ones in the config file
+    /**
+     * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
+     * possible to create a lock file and so we can avoid write locks.
      */
-    protected CmdArgs mergeArgsFromConfig( CmdArgs args ) throws IOException
+    public GraphHopper setAllowWrites( boolean allowWrites )
     {
-        if (!Helper.isEmpty(args.get("config", "")))
-        {
-            CmdArgs tmp = CmdArgs.readFromConfig(args.get("config", ""), "graphhopper.config");
-            tmp.merge(args);
-            return tmp;
-        }
-        return args;
+        this.allowWrites = allowWrites;
+        return this;
+    }
+
+    public boolean isAllowWrites()
+    {
+        return allowWrites;
     }
 
-    public GraphHopper init( CmdArgs args ) throws IOException
+    public TranslationMap getTranslationMap()
     {
-        args = mergeArgsFromConfig(args);
+        return trMap;
+    }
+
+    /**
+     * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
+     * args) ala CmdArgs.read(args) or via configuration file ala
+     * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
+     */
+    public GraphHopper init( CmdArgs args )
+    {
+        args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
         String tmpOsmFile = args.get("osmreader.osm", "");
         if (!Helper.isEmpty(tmpOsmFile))
             osmFile = tmpOsmFile;
@@ -371,42 +514,53 @@ public GraphHopper init( CmdArgs args ) throws IOException
 
         // graph
         setGraphHopperLocation(graphHopperFolder);
-        expectedCapacity = args.getLong("graph.expectedCapacity", expectedCapacity);
         defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
-        String dataAccess = args.get("graph.dataaccess", "RAM_STORE").toUpperCase();
-        if (dataAccess.contains("MMAP"))
-        {
-            setMemoryMapped();
-        } else if (dataAccess.contains("UNSAFE"))
-        {
-            setUnsafeMemory();
-        } else
-        {
-            if (dataAccess.contains("SAVE") || dataAccess.contains("INMEMORY"))
-                throw new IllegalStateException("configuration names for dataAccess changed. Use eg. RAM or RAM_STORE");
-
-            if (dataAccess.contains("RAM_STORE"))
-                setInMemory(true, true);
-            else
-                setInMemory(true, false);
-        }
 
-        if (dataAccess.contains("SYNC"))
-            dataAccessType = new DAType(dataAccessType, true);
+        String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
+        dataAccessType = DAType.fromString(graphDATypeStr);
 
         sortGraph = args.getBool("graph.doSort", sortGraph);
         removeZipped = args.getBool("graph.removeZipped", removeZipped);
-        turnCosts = args.getBool("graph.turnCosts", turnCosts);
+        int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
+        if (args.get("graph.locktype", "native").equals("simple"))
+            lockFactory = new SimpleFSLockFactory();
+        else
+            lockFactory = new NativeFSLockFactory();
+
+        // elevation
+        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
+        boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
+        String cacheDirStr = args.get("graph.elevation.cachedir", "");
+        String baseURL = args.get("graph.elevation.baseurl", "");
+        DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
+        ElevationProvider tmpProvider = ElevationProvider.NOOP;
+        if (eleProviderStr.equalsIgnoreCase("srtm"))
+        {
+            tmpProvider = new SRTMProvider();
+        } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
+        {
+            CGIARProvider cgiarProvider = new CGIARProvider();
+            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
+            tmpProvider = cgiarProvider;
+        }
+
+        tmpProvider.setCalcMean(eleCalcMean);
+        tmpProvider.setCacheDir(new File(cacheDirStr));
+        if (!baseURL.isEmpty())
+            tmpProvider.setBaseURL(baseURL);
+        tmpProvider.setDAType(elevationDAType);
+        setElevationProvider(tmpProvider);
 
         // optimizable prepare
         minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
+        minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
 
         // prepare CH
         doPrepare = args.getBool("prepare.doPrepare", doPrepare);
-        String chShortcuts = args.get("prepare.chShortcuts", "fastest");
-        chEnabled = "true".equals(chShortcuts) || "fastest".equals(chShortcuts) || "shortest".equals(chShortcuts);
+        String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
+        chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
         if (chEnabled)
-            setCHShortcuts(chShortcuts);
+            setCHWeighting(tmpCHWeighting);
 
         periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
         lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
@@ -414,29 +568,41 @@ public GraphHopper init( CmdArgs args ) throws IOException
         logMessages = args.getDouble("prepare.logmessages", logMessages);
 
         // osm import
-        wayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", wayPointMaxDistance);
-        String flagEncoders = args.get("osmreader.acceptWay", "CAR");
-        encodingManager = new EncodingManager(flagEncoders);
+        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
+        String flagEncoders = args.get("graph.flagEncoders", "");
+        if (!flagEncoders.isEmpty())
+            setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
+
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
         // index
         preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
+        maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+
+        // routing
+        defaultWeightLimit = args.getDouble("routing.defaultWeightLimit", defaultWeightLimit);
         return this;
     }
 
     private void printInfo()
     {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
+        if (graph != null)
+            logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
     }
 
+    /**
+     * Imports provided data from disc and creates graph. Depending on the settings the resulting
+     * graph will be stored to disc so on a second call this method will only load the graph from
+     * disc which is usually a lot faster.
+     */
     public GraphHopper importOrLoad()
     {
         if (!load(ghLocation))
         {
             printInfo();
-            process(ghLocation, osmFile);
+            process(ghLocation);
         } else
         {
             printInfo();
@@ -447,47 +613,76 @@ public GraphHopper importOrLoad()
     /**
      * Creates the graph from OSM data.
      */
-    private GraphHopper process( String graphHopperLocation, String osmFileStr )
+    private GraphHopper process( String graphHopperLocation )
     {
-        if (encodingManager == null)
-            throw new IllegalStateException("No encodingManager was specified");
-
         setGraphHopperLocation(graphHopperLocation);
-
+        Lock lock = null;
         try
         {
-            importOSM(osmFileStr);
-        } catch (IOException ex)
+            if (graph.getDirectory().getDefaultType().isStoring())
+            {
+                lockFactory.setLockDir(new File(graphHopperLocation));
+                lock = lockFactory.create(fileLockName, true);
+                if (!lock.tryLock())
+                    throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
+            }
+
+            try
+            {
+                importData();
+                graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
+            } catch (IOException ex)
+            {
+                throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
+            }
+            cleanUp();
+            optimize();
+            postProcessing();
+            flush();
+        } finally
         {
-            throw new RuntimeException("Cannot parse OSM file " + osmFileStr, ex);
+            if (lock != null)
+                lock.release();
         }
-        cleanUp();
-        optimize();
-        postProcessing();
-        flush();
         return this;
     }
 
-    protected OSMReader importOSM( String _osmFile ) throws IOException
+    protected DataReader importData() throws IOException
     {
+        ensureWriteAccess();
         if (graph == null)
             throw new IllegalStateException("Load graph before importing OSM data");
 
-        setOSMFile(_osmFile);
-        File osmTmpFile = new File(osmFile);
-        if (!osmTmpFile.exists())
-        {
-            throw new IllegalStateException("Your specified OSM file does not exist:" + osmTmpFile.getAbsolutePath());
-        }
+        if (osmFile == null)
+            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
+                    + " but also cannot import from OSM file as it wasn't specified!");
 
-        logger.info("start creating graph from " + osmFile);
-        OSMReader reader = new OSMReader(graph, expectedCapacity).setWorkerThreads(workerThreads).setEncodingManager(encodingManager)
-                .setWayPointMaxDistance(wayPointMaxDistance).setEnableInstructions(enableInstructions);
+        encodingManager.setEnableInstructions(enableInstructions);
+        DataReader reader = createReader(graph);
         logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
-        reader.doOSM2Graph(osmTmpFile);
+        reader.readGraph();
         return reader;
     }
 
+    protected DataReader createReader( GraphStorage tmpGraph )
+    {
+        return initOSMReader(new OSMReader(tmpGraph));
+    }
+
+    protected OSMReader initOSMReader( OSMReader reader )
+    {
+        if (osmFile == null)
+            throw new IllegalArgumentException("No OSM file specified");
+
+        logger.info("start creating graph from " + osmFile);
+        File osmTmpFile = new File(osmFile);
+        return reader.setOSMFile(osmTmpFile).
+                setElevationProvider(eleProvider).
+                setWorkerThreads(workerThreads).
+                setEncodingManager(encodingManager).
+                setWayPointMaxDistance(osmReaderWayPointMaxDistance);
+    }
+
     /**
      * Opens existing graph.
      * <p/>
@@ -509,7 +704,7 @@ public boolean load( String graphHopperFolder )
         } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
         {
             throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-        } else if (graphHopperFolder.indexOf(".") < 0)
+        } else if (!graphHopperFolder.contains("."))
         {
             if (new File(graphHopperFolder + "-gh").exists())
                 graphHopperFolder += "-gh";
@@ -528,189 +723,293 @@ public boolean load( String graphHopperFolder )
                 }
             }
         }
+
         setGraphHopperLocation(graphHopperFolder);
 
-        GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
+        if (encodingManager == null)
+            setEncodingManager(EncodingManager.create(ghLocation));
+
+        if (!allowWrites && dataAccessType.isMMap())
+            dataAccessType = DAType.MMAP_RO;
 
+        GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
         if (chEnabled)
-            graph = new LevelGraphStorage(dir, encodingManager);
-        else if (turnCosts)
-            graph = new GraphHopperStorage(dir, encodingManager, new TurnCostStorage());
+            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
+        else if (encodingManager.needsTurnCostsSupport())
+            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
         else
-            graph = new GraphHopperStorage(dir, encodingManager);
+            graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
 
         graph.setSegmentSize(defaultSegmentSize);
-        if (!graph.loadExisting())
-            return false;
 
-        postProcessing();
-        fullyLoaded = true;
-        return true;
+        Lock lock = null;
+        try
+        {
+            // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
+            // (e.g. on a read only filesystem locks would fail)
+            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+            {
+                lockFactory.setLockDir(new File(ghLocation));
+                lock = lockFactory.create(fileLockName, false);
+                if (!lock.tryLock())
+                    throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
+            }
+
+            if (!graph.loadExisting())
+                return false;
+
+            postProcessing();
+            fullyLoaded = true;
+            return true;
+        } finally
+        {
+            if (lock != null)
+                lock.release();
+        }
     }
 
+    public RoutingAlgorithmFactory getAlgorithmFactory()
+    {
+        if (algoFactory == null)
+            this.algoFactory = new RoutingAlgorithmFactorySimple();
+
+        return algoFactory;
+    }
+
+    public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
+    {
+        this.algoFactory = algoFactory;
+    }
+
+    /**
+     * Sets EncodingManager, does the preparation and creates the locationIndex
+     */
     protected void postProcessing()
     {
-        encodingManager = graph.getEncodingManager();
+        initLocationIndex();
         if (chEnabled)
-            initCHPrepare();
+            algoFactory = createPrepare();
+        else
+            algoFactory = new RoutingAlgorithmFactorySimple();
 
         if (!isPrepared())
             prepare();
-        initLocationIndex();
     }
-    
-    private boolean isPrepared() {
+
+    private boolean isPrepared()
+    {
         return "true".equals(graph.getProperties().get("prepare.done"));
     }
 
-    protected void initCHPrepare()
+    protected RoutingAlgorithmFactory createPrepare()
     {
-        FlagEncoder encoder = encodingManager.getSingle();
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
-                createWeighting(chWeighting, encoder));
+        FlagEncoder defaultVehicle = getDefaultVehicle();
+        Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
+        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph,
+                defaultVehicle, weighting, traversalMode);
         tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
                 setLazyUpdates(lazyUpdates).
                 setNeighborUpdates(neighborUpdates).
                 setLogMessages(logMessages);
 
-        prepare = tmpPrepareCH;
-        prepare.setGraph(graph);
+        return tmpPrepareCH;
+    }
+
+    /**
+     * Based on the weightingParameters and the specified vehicle a Weighting instance can be
+     * created. Note that all URL parameters are available in the weightingParameters as String if
+     * you use the GraphHopper Web module.
+     * <p>
+     * @see WeightingMap
+     * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
+     * GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
+     * @param encoder the required vehicle
+     * @return the weighting to be used for route calculation
+     */
+    public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
+    {
+        String weighting = weightingMap.getWeighting();
+        Weighting result;
+
+        if ("shortest".equalsIgnoreCase(weighting))
+        {
+            result = new ShortestWeighting();
+        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
+        {
+            if (encoder.supports(PriorityWeighting.class))
+                result = new PriorityWeighting(encoder);
+            else
+                result = new FastestWeighting(encoder);
+        } else
+        {
+            throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+        }
+        return result;
     }
 
-    protected Weighting createWeighting( String weighting, FlagEncoder encoder )
+    /**
+     * Potentially wraps the specified weighting into a TurnWeighting instance.
+     */
+    public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEncoder encoder )
     {
-        // ignore case
-        weighting = weighting.toLowerCase();
-        if ("shortest".equals(weighting))
-            return new ShortestWeighting();
-        return new FastestWeighting(encoder);
+        if (encoder.supports(TurnWeighting.class))
+            return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
+        return weighting;
     }
 
     @Override
     public GHResponse route( GHRequest request )
     {
-        request.check();
+        GHResponse response = new GHResponse();
+        List<Path> paths = getPaths(request, response);
+        if (response.hasErrors())
+            return response;
+
+        boolean tmpEnableInstructions = request.getHints().getBool("instructions", enableInstructions);
+        boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
+        double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
+        Locale locale = request.getLocale();
+        DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
+
+        new PathMerger().
+                setCalcPoints(tmpCalcPoints).
+                setDouglasPeucker(peucker).
+                setEnableInstructions(tmpEnableInstructions).
+                setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).
+                doWork(response, paths, trMap.getWithFallBack(locale));
+        return response;
+    }
+
+    protected List<Path> getPaths( GHRequest request, GHResponse rsp )
+    {
         if (graph == null || !fullyLoaded)
             throw new IllegalStateException("Call load or importOrLoad before routing");
 
-        StopWatch sw = new StopWatch().start();
-        GHResponse rsp = new GHResponse();
+        if (graph.isClosed())
+            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
 
-        if (!encodingManager.supports(request.getVehicle()))
+        String vehicle = request.getVehicle();
+        if (vehicle.isEmpty())
+            vehicle = getDefaultVehicle().toString();
+
+        if (!encodingManager.supports(vehicle))
         {
-            rsp.addError(new IllegalArgumentException("Vehicle " + request.getVehicle() + " unsupported. Supported are: "
-                    + getEncodingManager()));
-            return rsp;
+            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
+                    + "Supported are: " + getEncodingManager()));
+            return Collections.emptyList();
         }
 
-        FlagEncoder encoder = encodingManager.getEncoder(request.getVehicle());
-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-        QueryResult fromRes = locationIndex.findClosest(request.getFrom().lat, request.getFrom().lon, edgeFilter);
-        QueryResult toRes = locationIndex.findClosest(request.getTo().lat, request.getTo().lon, edgeFilter);
+        TraversalMode tMode;
+        String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
+        try
+        {
+            tMode = TraversalMode.fromString(tModeStr);
+        } catch (Exception ex)
+        {
+            rsp.addError(ex);
+            return Collections.emptyList();
+        }
 
-        String debug = "idLookup:" + sw.stop().getSeconds() + "s";
+        List<GHPoint> points = request.getPoints();
+        if (points.size() < 2)
+        {
+            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
+            return Collections.emptyList();
+        }
 
-        if (!fromRes.isValid())
-            rsp.addError(new IllegalArgumentException("Cannot find point 1: " + request.getFrom()));
+        visitedSum.set(0);
 
-        if (!toRes.isValid())
-            rsp.addError(new IllegalArgumentException("Cannot find point 2: " + request.getTo()));
+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
 
-        sw = new StopWatch().start();
-        RoutingAlgorithm algo = null;
-        if (chEnabled)
+        StopWatch sw = new StopWatch().start();
+        List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
+        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++)
         {
-            if (prepare == null)
-                throw new IllegalStateException(
-                        "Preparation object is null. CH-preparation wasn't done or did you forgot to call disableCHShortcuts()?");
-
-            if (request.getAlgorithm().equals("dijkstrabi"))
-                algo = prepare.createAlgo();
-            else if (request.getAlgorithm().equals("astarbi"))
-                algo = ((PrepareContractionHierarchies) prepare).createAStar();
-            else
-                rsp.addError(new IllegalStateException(
-                        "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
+            GHPoint point = points.get(placeIndex);
+            QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+            if (!res.isValid())
+                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
+
+            qResults.add(res);
+        }
+
+        if (rsp.hasErrors())
+            return Collections.emptyList();
+
+        String debug = "idLookup:" + sw.stop().getSeconds() + "s";
 
+        QueryGraph queryGraph;
+        RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
+        if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
+        {
+            // fall back to normal traversing
+            tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
+            queryGraph = new QueryGraph(graph.getBaseGraph());
         } else
         {
-            Weighting weighting = createWeighting(request.getWeighting(), encoder);
-            prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, request.getAlgorithm(), encoder, weighting);
-            algo = prepare.createAlgo();
+            queryGraph = new QueryGraph(graph);
         }
 
-        if (rsp.hasErrors())
-            return rsp;
+        queryGraph.lookup(qResults);
 
-        debug += ", algoInit:" + sw.stop().getSeconds() + "s";
-        sw = new StopWatch().start();
+        List<Path> paths = new ArrayList<Path>(points.size() - 1);
+        QueryResult fromQResult = qResults.get(0);
+        Weighting weighting = createWeighting(request.getHints(), encoder);
+        weighting = createTurnWeighting(weighting, queryGraph, encoder);
 
-        Path path = algo.calcPath(fromRes, toRes);
-        debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
+        double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
+        String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().
+                algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+                build();
 
-        calcPoints = request.getHint("calcPoints", calcPoints);
-        if (calcPoints)
+        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
         {
-            PointList points = path.calcPoints();
-            rsp.setFound(points.getSize() > 1);
-            simplifyRequest = request.getHint("simplifyRequest", simplifyRequest);
-            if (simplifyRequest)
-            {
-                sw = new StopWatch().start();
-                int orig = points.getSize();
-                double minPathPrecision = request.getHint("douglas.minprecision", 1d);
-                if (minPathPrecision > 0)
-                    new DouglasPeucker().setMaxDistance(minPathPrecision).simplify(points);
+            QueryResult toQResult = qResults.get(placeIndex);
+            sw = new StopWatch().start();
+            RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
+            algo.setWeightLimit(weightLimit);
+            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
+
+            sw = new StopWatch().start();
+            Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
+            if (path.getMillis() < 0)
+                throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
+
+            paths.add(path);
+            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
+
+            visitedSum.addAndGet(algo.getVisitedNodes());
+            fromQResult = toQResult;
+        }
 
-                debug += ", simplify (" + orig + "->" + points.getSize() + "):" + sw.stop().getSeconds() + "s";
-            }
-            rsp.setPoints(points);
+        if (rsp.hasErrors())
+            return Collections.emptyList();
 
-            enableInstructions = request.getHint("instructions", enableInstructions);
-            if (enableInstructions)
-            {
-                sw = new StopWatch().start();
-                rsp.setInstructions(path.calcInstructions());
-                debug += ", instructions:" + sw.stop().getSeconds() + "s";
-            }
-        } else
-            rsp.setFound(path.isFound());
+        if (points.size() - 1 != paths.size())
+            throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
 
-        return rsp.setDistance(path.getDistance()).setMillis(path.getMillis()).setDebugInfo(debug);
+        rsp.setDebugInfo(debug);
+        return paths;
     }
 
     protected LocationIndex createLocationIndex( Directory dir )
     {
-        LocationIndex tmpIndex;
-        if (preciseIndexResolution > 0)
-        {
-            LocationIndexTree tmpNIndex;
-            if (graph instanceof LevelGraph)
-            {
-                tmpNIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-            } else
-            {
-                tmpNIndex = new LocationIndexTree(graph, dir);
-            }
-            tmpNIndex.setResolution(preciseIndexResolution);
-            tmpNIndex.setSearchRegion(searchRegion);
-            tmpIndex = tmpNIndex;
-        } else
-        {
-            tmpIndex = new Location2IDQuadtree(graph, dir);
-            tmpIndex.setResolution(Helper.calcIndexSize(graph.getBounds()));
-        }
-
+        LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
+        tmpIndex.setResolution(preciseIndexResolution);
+        tmpIndex.setMaxRegionSearch(maxRegionSearch);
         if (!tmpIndex.loadExisting())
+        {
+            ensureWriteAccess();
             tmpIndex.prepareIndex();
+        }
 
         return tmpIndex;
     }
 
     /**
-     * Initializes the location index. Currently this has to be done after the ch-preparation!
-     * Because - to improve performance - certain edges won't be available in a ch-graph and the
-     * index needs to know this and selects the correct nodes which still see the correct neighbors.
+     * Initializes the location index after the import is done.
      */
     protected void initLocationIndex()
     {
@@ -727,30 +1026,28 @@ protected void optimize()
         logger.info("finished optimize (" + Helper.getMemInfo() + ")");
 
         // Later: move this into the GraphStorage.optimize method
-        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet https://github.com/graphhopper/graphhopper/issues/12
+        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
         if (sortGraph)
         {
-            if(graph instanceof LevelGraph && isPrepared())
+            if (graph instanceof LevelGraph && isPrepared())
                 throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
-            
-            logger.info("sorting ... (" + Helper.getMemInfo() + ")");
+
             GraphStorage newGraph = GHUtility.newStorage(graph);
             GHUtility.sortDFS(graph, newGraph);
+            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
             graph = newGraph;
         }
     }
 
     protected void prepare()
     {
-        boolean tmpPrepare = doPrepare && prepare != null;
+        boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
         if (tmpPrepare)
         {
-            if (prepare instanceof PrepareContractionHierarchies && encodingManager.getVehicleCount() > 1)
-                throw new IllegalArgumentException("Contraction hierarchies preparation "
-                        + "requires (at the moment) only one vehicle. But was:" + encodingManager);
-
-            logger.info("calling prepare.doWork ... (" + Helper.getMemInfo() + ")");
-            prepare.doWork();
+            ensureWriteAccess();
+            logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
+            ((PrepareContractionHierarchies) algoFactory).doWork();
+            graph.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
         graph.getProperties().put("prepare.done", tmpPrepare);
     }
@@ -760,12 +1057,13 @@ protected void cleanUp()
         int prev = graph.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
+        preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
         int n = graph.getNodes();
         // calculate remaining subnetworks
         int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
+        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
                 + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
     }
 
@@ -776,6 +1074,10 @@ protected void flush()
         fullyLoaded = true;
     }
 
+    /**
+     * Releases all associated resources like memory or files. But it does not remove them. To
+     * remove the files created in graphhopperLocation you have to call clean().
+     */
     public void close()
     {
         if (graph != null)
@@ -783,6 +1085,34 @@ public void close()
 
         if (locationIndex != null)
             locationIndex.close();
+
+        try
+        {
+            lockFactory.forceRemove(fileLockName, true);
+        } catch (Exception ex)
+        {
+            // silently fail e.g. on Windows where we cannot remove an unreleased native lock
+        }
+    }
+
+    /**
+     * Removes the on-disc routing files. Call only after calling close or before importOrLoad or
+     * load
+     */
+    public void clean()
+    {
+        if (getGraphHopperLocation().isEmpty())
+            throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
+
+        File folder = new File(getGraphHopperLocation());
+        Helper.removeDir(folder);
+    }
+
+    // make sure this is identical to buildDate used in pom.xml
+    // <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
+    private String formatDateTime( Date date )
+    {
+        return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
     }
 
     protected void ensureNotLoaded()
@@ -790,4 +1120,19 @@ protected void ensureNotLoaded()
         if (fullyLoaded)
             throw new IllegalStateException("No configuration changes are possible after loading the graph");
     }
+
+    protected void ensureWriteAccess()
+    {
+        if (!allowWrites)
+            throw new IllegalStateException("Writes are not allowed!");
+    }
+
+    /**
+     * Returns the current sum of the visited nodes while routing. Mainly for statistic and
+     * debugging purposes.
+     */
+    long getVisitedSum()
+    {
+        return visitedSum.get();
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopperAPI.java b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
index 338f86506f..9f76e601b5 100644
--- a/core/src/main/java/com/graphhopper/GraphHopperAPI.java
+++ b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
@@ -20,27 +20,6 @@
 /**
  * Wrapper of the graphhopper online or offline API. Provides read only access.
  * <p/>
- * Usage:
- * <pre>
- *
- * // init offline graph
- * GraphHopperAPI gh = new GraphHopper().setInMemory(true, true);
- * gh.load("graph-hopper-folder");
- *
- * // init online service
- * GraphHopperAPI gh = new GraphHopperWeb();
- * gh.load("http://your-graphhopper-service.com/api");
- *
- * gh.algorithm("astar");
- * GHResponse ph = gh.route(new GHRequest(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon)));
- * print(ph.distance() + " " + ph.time());
- * PointList points = response.getPoints();
- * for(int i = 0; i &lt; points.size(); i++) {
- *    add(point.latitude(i), point.longitude(i));
- * }
- *
- * </pre>
- * <p/>
  * @author Peter Karich
  */
 public interface GraphHopperAPI
@@ -54,7 +33,7 @@
     boolean load( String urlOrFile );
 
     /**
-     * Calculates the path from specified request with startPoint to endPoint.
+     * Calculates the path from specified request visiting the specified locations.
      * <p/>
      * @return the response with the route and possible errors
      */
diff --git a/core/src/main/java/com/graphhopper/coll/CompressedArray.java b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
index 6c89e3e3cd..4036672e37 100644
--- a/core/src/main/java/com/graphhopper/coll/CompressedArray.java
+++ b/core/src/main/java/com/graphhopper/coll/CompressedArray.java
@@ -20,7 +20,6 @@
 import com.graphhopper.geohash.SpatialKeyAlgo;
 import com.graphhopper.storage.VLongStorage;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.shapes.CoordTrig;
 import com.graphhopper.util.shapes.GHPoint;
 import java.io.ByteArrayOutputStream;
 import java.util.ArrayList;
diff --git a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
index 359735b7b8..faee1ee386 100644
--- a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
@@ -81,6 +81,9 @@ public int peekKey()
      */
     public int pollKey()
     {
+        if (map.isEmpty())
+            throw new IllegalStateException("Cannot poll collection is empty!");
+
         long key = map.pollFirstEntry().getKey();
         return (int) (key & 0xFFFFFFFFL);
     }
diff --git a/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java b/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java
index 523a8a22d8..76ec7291cf 100644
--- a/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java
+++ b/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java
@@ -51,10 +51,11 @@ public int getSize()
         return size;
     }
 
-    public int size() {
+    public int size()
+    {
         return size;
     }
-    
+
     @Override
     public boolean isEmpty()
     {
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
index 75ca1bcfee..906242e37b 100644
--- a/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
+++ b/core/src/main/java/com/graphhopper/coll/OSMIDMap.java
@@ -75,10 +75,10 @@ public int put( long key, int value )
             return oldValue;
         }
 
-        values.incCapacity(size + 4);
+        values.ensureCapacity(size + 4);
         values.setInt(size, value);
         long doubleSize = size * 2;
-        keys.incCapacity(doubleSize + 8);
+        keys.ensureCapacity(doubleSize + 8);
 
         // store long => double of the orig size
         byte[] longBytes = bitUtil.fromLong(key);
diff --git a/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
index c4045989e1..6d8c2f96a2 100644
--- a/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/KeyAlgo.java
@@ -17,24 +17,25 @@
  */
 package com.graphhopper.geohash;
 
-import com.graphhopper.util.shapes.CoordTrig;
+import com.graphhopper.util.shapes.GHPoint;
 
 /**
- * Defines the mapping between a one dimensional 'number' and a point (lat, lon)
- * which is limited to a defined bounds.
+ * Defines the mapping between a one dimensional 'number' and a point (lat, lon) which is limited to
+ * a defined bounds.
  * <p/>
  * @author Peter Karich
  */
-public interface KeyAlgo {
+public interface KeyAlgo
+{
 
     /**
      * Sets the bounds of the underlying key algorithm.
      */
-    KeyAlgo setBounds(double minLonInit, double maxLonInit, double minLatInit, double maxLatInit);
+    KeyAlgo setBounds( double minLonInit, double maxLonInit, double minLatInit, double maxLatInit );
 
-    long encode(CoordTrig coord);
+    long encode( GHPoint coord );
 
-    long encode(double lat, double lon);
+    long encode( double lat, double lon );
 
-    void decode(long spatialKey, CoordTrig latLon);
+    void decode( long spatialKey, GHPoint latLon );
 }
diff --git a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
index 32e1d36ff6..06f694cbae 100644
--- a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
@@ -18,7 +18,7 @@
 package com.graphhopper.geohash;
 
 import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.CoordTrig;
+import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * This class maps lat,lon to a (tile)number unlike SpatialKeyAlgo.
@@ -61,7 +61,7 @@ public LinearKeyAlgo setBounds( double minLonInit, double maxLonInit, double min
 
     public LinearKeyAlgo setBounds( BBox bounds )
     {
-        setBounds(bounds.minLon, bounds.maxLat, bounds.minLat, bounds.maxLat);
+        setBounds(bounds.minLon, bounds.maxLon, bounds.minLat, bounds.maxLat);
         return this;
     }
 
@@ -71,7 +71,7 @@ protected void setWorldBounds()
     }
 
     @Override
-    public long encode( CoordTrig coord )
+    public long encode( GHPoint coord )
     {
         return encode(coord.lat, coord.lon);
     }
@@ -87,8 +87,8 @@ public final long encode( double lat, double lon )
         lat = Math.min(Math.max(lat, bounds.minLat), bounds.maxLat);
         lon = Math.min(Math.max(lon, bounds.minLon), bounds.maxLon);
         // introduce a minor correction to round to lower grid entry!
-        int latIndex = (int) ((lat - bounds.minLat) / latDelta * C);
-        int lonIndex = (int) ((lon - bounds.minLon) / lonDelta * C);
+        long latIndex = (long) ((lat - bounds.minLat) / latDelta * C);
+        long lonIndex = (long) ((lon - bounds.minLon) / lonDelta * C);
         return latIndex * lonUnits + lonIndex;
     }
 
@@ -98,11 +98,22 @@ public final long encode( double lat, double lon )
      * @param linearKey is the input
      */
     @Override
-    public final void decode( long linearKey, CoordTrig latLon )
+    public final void decode( long linearKey, GHPoint latLon )
     {
         double lat = linearKey / lonUnits * latDelta + bounds.minLat;
         double lon = linearKey % lonUnits * lonDelta + bounds.minLon;
         latLon.lat = lat + latDelta / 2;
         latLon.lon = lon + lonDelta / 2;
     }
+
+    public double getLatDelta()
+    {
+        return latDelta;
+    }
+
+    public double getLonDelta()
+    {
+        return lonDelta;
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
index 1e25589c48..74d3b73abd 100644
--- a/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/SpatialKeyAlgo.java
@@ -18,7 +18,7 @@
 package com.graphhopper.geohash;
 
 import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.CoordTrig;
+import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * This class implements the idea of a geohash but in 'binary form' - to avoid confusion this is
@@ -135,7 +135,7 @@ protected void setWorldBounds()
     }
 
     @Override
-    public long encode( CoordTrig coord )
+    public long encode( GHPoint coord )
     {
         return encode(coord.lat, coord.lon);
     }
@@ -162,13 +162,13 @@ public final long encode( double lat, double lon )
             if (minLatTmp < maxLatTmp)
             {
                 double midLat = (minLatTmp + maxLatTmp) / 2;
-                if (lat > midLat)
+                if (lat < midLat)
                 {
-                    hash |= 1;
-                    minLatTmp = midLat;
+                    maxLatTmp = midLat;
                 } else
                 {
-                    maxLatTmp = midLat;
+                    hash |= 1;
+                    minLatTmp = midLat;
                 }
             }
             i++;
@@ -182,13 +182,13 @@ public final long encode( double lat, double lon )
             if (minLonTmp < maxLonTmp)
             {
                 double midLon = (minLonTmp + maxLonTmp) / 2;
-                if (lon > midLon)
+                if (lon < midLon)
                 {
-                    hash |= 1;
-                    minLonTmp = midLon;
+                    maxLonTmp = midLon;
                 } else
                 {
-                    maxLonTmp = midLon;
+                    hash |= 1;
+                    minLonTmp = midLon;
                 }
             }
             i++;
@@ -206,7 +206,7 @@ public final long encode( double lat, double lon )
      * @param spatialKey is the input
      */
     @Override
-    public final void decode( long spatialKey, CoordTrig latLon )
+    public final void decode( long spatialKey, GHPoint latLon )
     {
         // Performance: calculating 'midLon' and 'midLat' on the fly is not slower than using 
         // precalculated values from arrays and for 'bits' a precalculated array is even slightly slower!
diff --git a/core/src/main/java/com/graphhopper/trees/CoordResolver.java b/core/src/main/java/com/graphhopper/reader/DataReader.java
similarity index 51%
rename from core/src/main/java/com/graphhopper/trees/CoordResolver.java
rename to core/src/main/java/com/graphhopper/reader/DataReader.java
index 37ebd8051c..d820a2ab7f 100644
--- a/core/src/main/java/com/graphhopper/trees/CoordResolver.java
+++ b/core/src/main/java/com/graphhopper/reader/DataReader.java
@@ -1,29 +1,30 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.trees;
+package com.graphhopper.reader;
 
-import com.graphhopper.util.shapes.CoordTrig;
-import java.util.Collection;
+import java.io.IOException;
 
 /**
  * @author Peter Karich
  */
-public interface CoordResolver<T>
+public interface DataReader
 {
-    void add( Collection<CoordTrig<T>> coll, int edgeId );
+
+    void readGraph() throws IOException;
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMElement.java b/core/src/main/java/com/graphhopper/reader/OSMElement.java
index 80688dd43c..00de04f07b 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMElement.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMElement.java
@@ -21,35 +21,25 @@
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 
 /**
  * Base class for all OSM objects
  * <p/>
  * @author Nop
+ * @author Peter
  */
 public abstract class OSMElement
 {
     public static final int NODE = 0;
     public static final int WAY = 1;
     public static final int RELATION = 2;
-    protected final int type;
-    protected final long id;
-    protected Map<String, String> tags;
-    protected Map<String, Object> iProperties;
-
-    public OSMElement( long id, int type, XMLStreamReader parser )
-    {
-        this.type = type;
-        this.id = id;
-    }
-
-    public OSMElement( long id, int type, Map<String, String> tags )
-    {
-        this(id, type);
-        this.tags = tags;
-    }
+    private final int type;
+    private final long id;
+    private final Map<String, Object> properties = new HashMap<String, Object>(5);
 
     protected OSMElement( long id, int type )
     {
@@ -62,15 +52,6 @@ public long getId()
         return id;
     }
 
-    public void copyTags( OSMElement input )
-    {
-        if (input.hasTags())
-        {
-            tags = new HashMap<String, String>();
-            tags.putAll(input.getTags());
-        }
-    }
-
     protected void readTags( XMLStreamReader parser ) throws XMLStreamException
     {
         int event = parser.getEventType();
@@ -83,15 +64,7 @@ protected void readTags( XMLStreamReader parser ) throws XMLStreamException
                 String value = parser.getAttributeValue(null, "v");
                 // ignore tags with empty values
                 if (value != null && value.length() > 0)
-                {
-                    // create map only if needed
-                    if (tags == null)
-                    {
-                        tags = new HashMap<String, String>();
-                    }
-
-                    tags.put(key, value);
-                }
+                    setTag(key, value);
             }
 
             event = parser.nextTag();
@@ -100,13 +73,11 @@ protected void readTags( XMLStreamReader parser ) throws XMLStreamException
 
     protected String tagsToString()
     {
-        if (tags == null)
-        {
+        if (properties.isEmpty())
             return "<empty>";
-        }
 
         StringBuilder tagTxt = new StringBuilder();
-        for (Map.Entry<String, String> entry : tags.entrySet())
+        for (Map.Entry<String, Object> entry : properties.entrySet())
         {
             tagTxt.append(entry.getKey());
             tagTxt.append("=");
@@ -116,47 +87,51 @@ protected String tagsToString()
         return tagTxt.toString();
     }
 
-    public Map<String, String> getTags()
+    protected Map<String, Object> getTags()
     {
-        return tags;
+        return properties;
     }
 
-    public void replaceTags( HashMap<String, String> newTags )
+    public void setTags( Map<String, String> newTags )
     {
-        tags = newTags;
+        properties.clear();
+        if (newTags != null)
+            for (Entry<String, String> e : newTags.entrySet())
+            {
+                setTag(e.getKey(), e.getValue());
+            }
     }
 
     public boolean hasTags()
     {
-        return tags != null && !tags.isEmpty();
+        return !properties.isEmpty();
     }
 
     public String getTag( String name )
     {
-        if (tags == null)
-            return null;
-
-        return tags.get(name);
+        return (String) properties.get(name);
     }
 
-    public void setTag( String name, String value )
+    @SuppressWarnings("unchecked")
+    public <T> T getTag( String key, T defaultValue )
     {
-        if (tags == null)
-            tags = new HashMap<String, String>();
+        T val = (T) properties.get(key);
+        if (val == null)
+            return defaultValue;
+        return val;
+    }
 
-        tags.put(name, value);
+    public void setTag( String name, Object value )
+    {
+        properties.put(name, value);
     }
 
     /**
      * Chaeck that the object has a given tag with a given value.
      */
-    public boolean hasTag( String key, String value )
+    public boolean hasTag( String key, Object value )
     {
-        if (tags == null)
-            return false;
-
-        String val = tags.get(key);
-        return value.equals(val);
+        return value.equals(properties.get(key));
     }
 
     /**
@@ -165,10 +140,7 @@ public boolean hasTag( String key, String value )
      */
     public boolean hasTag( String key, String... values )
     {
-        if (tags == null)
-            return false;
-
-        String osmValue = tags.get(key);
+        Object osmValue = properties.get(key);
         if (osmValue == null)
             return false;
 
@@ -189,66 +161,31 @@ public boolean hasTag( String key, String... values )
      */
     public final boolean hasTag( String key, Set<String> values )
     {
-        if (tags == null)
-            return false;
-
-        String osmValue = tags.get(key);
-        return osmValue != null && values.contains(osmValue);
+        return values.contains(properties.get(key));
     }
 
     /**
      * Check a number of tags in the given order for the any of the given values. Used to parse
      * hierarchical access restrictions
      */
-    public boolean hasTag( String[] keyList, Set<String> values )
+    public boolean hasTag( List<String> keyList, Set<String> values )
     {
-        if (tags == null)
-            return false;
-
-        for (int i = 0; i < keyList.length; i++)
+        for (String key : keyList)
         {
-            String osmValue = tags.get(keyList[i]);
-            if (osmValue != null && values.contains(osmValue))
+            if (values.contains(properties.get(key)))
                 return true;
         }
         return false;
     }
 
-    public void setInternalTag( String key, Object value )
-    {
-        if (iProperties == null)
-            iProperties = new HashMap<String, Object>();
-
-        iProperties.put(key, value);
-    }
-
-    public boolean hasInternalTag( String key )
-    {
-        if (iProperties == null)
-            return false;
-        return iProperties.containsKey(key);
-    }
-
-    @SuppressWarnings("unchecked")
-    public <T> T getInternalTag( String key, T defaultValue )
-    {
-        if (iProperties == null)
-            return defaultValue;
-        T val = (T) iProperties.get(key);
-        if (val == null)
-            return defaultValue;
-        return val;
-    }
-
     public void removeTag( String name )
     {
-        if (tags != null)
-            tags.remove(name);
+        properties.remove(name);
     }
 
     public void clearTags()
     {
-        tags = null;
+        properties.clear();
     }
 
     public int getType()
@@ -260,4 +197,10 @@ public boolean isType( int type )
     {
         return this.type == type;
     }
+
+    @Override
+    public String toString()
+    {
+        return properties.toString();
+    }        
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
index a3cb041a35..276227a0e5 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMInputFile.java
@@ -183,27 +183,31 @@ private OSMElement getNextXML() throws XMLStreamException
         {
             if (event == XMLStreamConstants.START_ELEMENT)
             {
-                String name = parser.getLocalName();
-                long id = 0;
-                switch (name.charAt(0))
+                String idStr = parser.getAttributeValue(null, "id");
+                if (idStr != null)
                 {
-                    case 'n':
-                        // note vs. node
-                        if ("node".equals(name))
+                    String name = parser.getLocalName();
+                    long id = 0;
+                    switch (name.charAt(0))
+                    {
+                        case 'n':
+                            // note vs. node
+                            if ("node".equals(name))
+                            {
+                                id = Long.parseLong(idStr);
+                                return OSMNode.create(id, parser);
+                            }
+                            break;
+
+                        case 'w':
                         {
-                            id = Long.parseLong(parser.getAttributeValue(null, "id"));
-                            return new OSMNode(id, parser);
+                            id = Long.parseLong(idStr);
+                            return OSMWay.create(id, parser);
                         }
-                        break;
-
-                    case 'w':
-                    {
-                        id = Long.parseLong(parser.getAttributeValue(null, "id"));
-                        return new OSMWay(id, parser);
+                        case 'r':
+                            id = Long.parseLong(idStr);
+                            return OSMRelation.create(id, parser);
                     }
-                    case 'r':
-                        id = Long.parseLong(parser.getAttributeValue(null, "id"));
-                        return new OSMRelation(id, parser);
                 }
             }
             event = parser.next();
diff --git a/core/src/main/java/com/graphhopper/reader/OSMNode.java b/core/src/main/java/com/graphhopper/reader/OSMNode.java
index f990e7c6e9..d8153cbea4 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMNode.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMNode.java
@@ -17,9 +17,9 @@
  */
 package com.graphhopper.reader;
 
+import com.graphhopper.util.PointAccess;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
-import java.util.Map;
 
 /**
  * Represents an OSM Node
@@ -28,26 +28,28 @@
  */
 public class OSMNode extends OSMElement
 {
-    private double lat;
-    private double lon;
+    private final double lat;
+    private final double lon;
 
-    public OSMNode( long id, XMLStreamReader parser ) throws XMLStreamException
+    public static OSMNode create( long id, XMLStreamReader parser ) throws XMLStreamException
     {
-        super(id, NODE, parser);
-
-        // read location
-        lat = Double.parseDouble(parser.getAttributeValue(null, "lat"));
-        lon = Double.parseDouble(parser.getAttributeValue(null, "lon"));
+        OSMNode node = new OSMNode(id,
+                Double.parseDouble(parser.getAttributeValue(null, "lat")),
+                Double.parseDouble(parser.getAttributeValue(null, "lon")));
 
         parser.nextTag();
-        readTags(parser);
+        node.readTags(parser);
+        return node;
     }
 
-    public OSMNode( long id, Map<String, String> tags, double lat, double lon )
+    public OSMNode( long id, PointAccess pointAccess, int accessId )
     {
-        super(id, NODE, tags);
-        this.lat = lat;
-        this.lon = lon;
+        super(id, NODE);
+
+        this.lat = pointAccess.getLatitude(accessId);
+        this.lon = pointAccess.getLongitude(accessId);
+        if (pointAccess.is3D())
+            setTag("ele", pointAccess.getElevation(accessId));
     }
 
     public OSMNode( long id, double lat, double lon )
@@ -68,27 +70,57 @@ public double getLon()
         return lon;
     }
 
+    public double getEle()
+    {
+        Object ele = getTags().get("ele");
+        if (ele == null)
+            return Double.NaN;
+        return (Double) ele;
+    }
+
     @Override
-    public String toString()
+    public void setTag( String name, Object value )
     {
-        if (tags == null)
+        if ("ele".equals(name))
         {
-            return "Node (" + id + ")";
-        } else
+            if (value == null)
+                value = null;
+            else if (value instanceof String)
+            {
+                String str = (String) value;
+                str = str.trim().replaceAll("\\,", ".");
+                if (str.isEmpty())
+                    value = null;
+                else
+                    try
+                    {
+                        value = Double.parseDouble(str);
+                    } catch (NumberFormatException ex)
+                    {
+                        return;
+                    }
+            } else
+                // force cast
+                value = ((Number) value).doubleValue();
+        }
+        super.setTag(name, value);
+    }
+
+    @Override
+    public String toString()
+    {
+        StringBuilder txt = new StringBuilder();
+        txt.append("Node: ");
+        txt.append(getId());
+        txt.append(" lat=");
+        txt.append(getLat());
+        txt.append(" lon=");
+        txt.append(getLon());
+        if (!getTags().isEmpty())
         {
-//            return "Node (" + id + ", " + tags.size() + " tags)";
-            StringBuilder txt = new StringBuilder();
-            txt.append("Node: ");
-            txt.append(id);
-            txt.append(" lat=");
-            txt.append(lat);
-            txt.append(" lon=");
-            txt.append(lon);
             txt.append("\n");
             txt.append(tagsToString());
-            return txt.toString();
         }
-
-        //return "Node at " + lat + ", " + lon;
+        return txt.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index 00d4ac376f..e12036317e 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -41,21 +41,14 @@
 import com.graphhopper.coll.GHLongIntBTree;
 import com.graphhopper.coll.LongIntMap;
 import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.ExtendedStorage;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.TurnCostStorage;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DouglasPeucker;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import gnu.trove.map.TLongObjectMap;
+import gnu.trove.map.hash.TLongObjectHashMap;
+import java.util.*;
 
 /**
  * This class parses an OSM xml or pbf file and creates a graph from it. It does so in a two phase
@@ -80,7 +73,7 @@
  * <p/>
  * @author Peter Karich
  */
-public class OSMReader
+public class OSMReader implements DataReader
 {
     protected static final int EMPTY = -1;
     // pillar node is >= 3
@@ -91,12 +84,10 @@
     private long locations;
     private long skippedLocations;
     private final GraphStorage graphStorage;
+    private final NodeAccess nodeAccess;
     private EncodingManager encodingManager = null;
     private int workerThreads = -1;
-    private boolean enableInstructions = true;
-    protected final Directory dir;
     protected long zeroCounter = 0;
-    protected final long expectedNodes;
     // Using the correct Map<Long, Integer> is hard. We need a memory efficient and fast solution for big data sets!
     //
     // very slow: new SparseLongLongArray
@@ -109,39 +100,47 @@
     private LongIntMap osmNodeIdToInternalNodeMap;
     private TLongLongHashMap osmNodeIdToNodeFlagsMap;
     private TLongLongHashMap osmWayIdToRouteWeightMap;
-    private TLongHashSet osmIdStoreRequiredSet; //stores osm ids used by relations to identify which edge ids needs to be mapped later
-    private TIntLongMap edgeIdToOsmidMap;
-    private final TLongList barrierNodeIDs = new TLongArrayList();
-    protected DataAccess pillarLats;
-    protected DataAccess pillarLons;
-    private final DistanceCalc distCalc = new DistanceCalcEarth();
+    // stores osm way ids used by relations to identify which edge ids needs to be mapped later
+    private TLongHashSet osmWayIdSet = new TLongHashSet();
+    private TIntLongMap edgeIdToOsmWayIdMap;
+    private final TLongList barrierNodeIds = new TLongArrayList();
+    protected PillarInfo pillarInfo;
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private final DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
+    private boolean doSimplify = true;
     private int nextTowerId = 0;
     private int nextPillarId = 0;
     // negative but increasing to avoid clash with custom created OSM files
-    private long newUniqueOSMId = -Long.MAX_VALUE;
+    private long newUniqueOsmId = -Long.MAX_VALUE;
+    private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private boolean exitOnlyPillarNodeException = true;
+    private File osmFile;
+    private Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
 
-    public OSMReader( GraphStorage storage, long expectedCap )
+    public OSMReader( GraphStorage storage )
     {
         this.graphStorage = storage;
-        this.expectedNodes = expectedCap;
+        this.nodeAccess = graphStorage.getNodeAccess();
 
         osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
         osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
         osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-
-        dir = graphStorage.getDirectory();
-        pillarLats = dir.find("tmpLatitudes");
-        pillarLons = dir.find("tmpLongitudes");
-        pillarLats.create(Math.max(expectedCap, 100));
-        pillarLons.create(Math.max(expectedCap, 100));
+        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
     }
 
-    public void doOSM2Graph( File osmFile ) throws IOException
+    @Override
+    public void readGraph() throws IOException
     {
         if (encodingManager == null)
-            throw new IllegalStateException("Encoding manager not set.");
+            throw new IllegalStateException("Encoding manager was not set.");
+
+        if (osmFile == null)
+            throw new IllegalStateException("No OSM file specified");
+
+        if (!osmFile.exists())
+            throw new IllegalStateException("Your specified OSM file does not exist:" + osmFile.getAbsolutePath());
 
         StopWatch sw1 = new StopWatch().start();
         preProcess(osmFile);
@@ -184,7 +183,7 @@ void preProcess( File osmFile )
                             prepareHighwayNode(wayNodes.get(index));
                         }
 
-                        if (++tmpWayCounter % 500000 == 0)
+                        if (++tmpWayCounter % 5000000 == 0)
                         {
                             logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:" + nf(getNodeMap().getSize()) + " ("
                                     + getNodeMap().getMemoryUsage() + "MB) " + Helper.getMemInfo());
@@ -195,14 +194,10 @@ void preProcess( File osmFile )
                 {
                     final OSMRelation relation = (OSMRelation) item;
                     if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
-                    {
                         prepareWaysWithRelationInfo(relation);
-                    }
 
                     if (relation.hasTag("type", "restriction"))
-                    {
                         prepareRestrictionRelation(relation);
-                    }
 
                     if (++tmpRelationCounter % 50000 == 0)
                     {
@@ -226,25 +221,25 @@ private void prepareRestrictionRelation( OSMRelation relation )
         OSMTurnRelation turnRelation = createTurnRelation(relation);
         if (turnRelation != null)
         {
-            getOsmIdStoreRequiredSet().add(((OSMTurnRelation) turnRelation).getOsmIdFrom());
-            getOsmIdStoreRequiredSet().add(((OSMTurnRelation) turnRelation).getOsmIdTo());
+            getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
+            getOsmWayIdSet().add(turnRelation.getOsmIdTo());
         }
     }
 
-    private TLongSet getOsmIdStoreRequiredSet()
+    /**
+     * @return all required osmWayIds to process e.g. relations.
+     */
+    private TLongSet getOsmWayIdSet()
     {
-        if (osmIdStoreRequiredSet == null)
-            osmIdStoreRequiredSet = new TLongHashSet();
-        
-        return osmIdStoreRequiredSet;
+        return osmWayIdSet;
     }
 
-    private TIntLongMap getEdgeIdToOsmidMap()
+    private TIntLongMap getEdgeIdToOsmWayIdMap()
     {
-        if (edgeIdToOsmidMap == null)
-            edgeIdToOsmidMap = new TIntLongHashMap(getOsmIdStoreRequiredSet().size());
-        
-        return edgeIdToOsmidMap;
+        if (edgeIdToOsmWayIdMap == null)
+            edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
+
+        return edgeIdToOsmWayIdMap;
     }
 
     /**
@@ -286,32 +281,33 @@ private void writeOsm2Graph( File osmFile )
             OSMElement item;
             while ((item = in.getNext()) != null)
             {
-                switch (item.getType()) {
-                case OSMElement.NODE:
-                    if (nodeFilter.get(item.getId()) != -1)
-                    {
-                        processNode((OSMNode) item);
-                    }
-                    break;
+                switch (item.getType())
+                {
+                    case OSMElement.NODE:
+                        if (nodeFilter.get(item.getId()) != -1)
+                        {
+                            processNode((OSMNode) item);
+                        }
+                        break;
 
-                case OSMElement.WAY:
-                    if (wayStart < 0)
-                    {
-                        logger.info(nf(counter) + ", now parsing ways");
-                        wayStart = counter;
-                    }
-                    processWay((OSMWay) item);
-                    break;
-                case OSMElement.RELATION:
-                    if (relationStart < 0)
-                    {
-                        logger.info(nf(counter) + ", now parsing relations");
-                        relationStart = counter;
-                    }
-                    processRelation((OSMRelation) item);
-                    break;
+                    case OSMElement.WAY:
+                        if (wayStart < 0)
+                        {
+                            logger.info(nf(counter) + ", now parsing ways");
+                            wayStart = counter;
+                        }
+                        processWay((OSMWay) item);
+                        break;
+                    case OSMElement.RELATION:
+                        if (relationStart < 0)
+                        {
+                            logger.info(nf(counter) + ", now parsing relations");
+                            relationStart = counter;
+                        }
+                        processRelation((OSMRelation) item);
+                        break;
                 }
-                if (++counter % 5000000 == 0)
+                if (++counter % 100000000 == 0)
                 {
                     logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations + ") " + Helper.getMemInfo());
                 }
@@ -320,7 +316,7 @@ private void writeOsm2Graph( File osmFile )
             // logger.info("storage nodes:" + storage.nodes() + " vs. graph nodes:" + storage.getGraph().nodes());
         } catch (Exception ex)
         {
-            throw new RuntimeException("Couldn't process file " + osmFile, ex);
+            throw new RuntimeException("Couldn't process file " + osmFile + ", error: " + ex.getMessage(), ex);
         } finally
         {
             Helper.close(in);
@@ -351,6 +347,7 @@ void processWay( OSMWay way )
 
         long relationFlags = getRelFlagsMap().get(way.getId());
 
+        // TODO move this after we have created the edge and know the coordinates => encodingManager.applyWayTags
         // estimate length of the track e.g. for ferry speed calculation
         TLongList osmNodeIds = way.getNodes();
         if (osmNodeIds.size() > 1)
@@ -359,11 +356,11 @@ void processWay( OSMWay way )
             int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
             double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
             double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-            if (firstLat != Double.NaN && firstLon != Double.NaN && lastLat != Double.NaN && lastLon != Double.NaN)
+            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon))
             {
                 double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
-                way.setInternalTag("estimated_distance", estimatedDist);
-                way.setInternalTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
+                way.setTag("estimated_distance", estimatedDist);
+                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
             }
         }
 
@@ -414,9 +411,6 @@ void processWay( OSMWay way )
                     // remember barrier for processing the way behind it
                     lastBarrier = i;
                 }
-            } else if (nodeFlags < 0)
-            {
-                wayFlags = encodingManager.applyNodeFlags(wayFlags, -nodeFlags);
             }
         }
 
@@ -434,28 +428,10 @@ void processWay( OSMWay way )
             // no barriers - simply add the whole way
             createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
         }
-        if (enableInstructions)
-        {
-            // String wayInfo = encodingManager.getWayInfo(way);
-            // http://wiki.openstreetmap.org/wiki/Key:name
-            String name = fixWayName(way.getTag("name"));
-            // http://wiki.openstreetmap.org/wiki/Key:ref
-            String refName = fixWayName(way.getTag("ref"));
-            if (!Helper.isEmpty(refName))
-            {
-                if (Helper.isEmpty(name))
-                {
-                    name = refName;
-                } else
-                {
-                    name += ", " + refName;
-                }
-            }
 
-            for (EdgeIteratorState iter : createdEdges)
-            {
-                iter.setName(name);
-            }
+        for (EdgeIteratorState edge : createdEdges)
+        {
+            encodingManager.applyWayTags(way, edge);
         }
     }
 
@@ -466,22 +442,69 @@ public void processRelation( OSMRelation relation ) throws XMLStreamException
             OSMTurnRelation turnRelation = createTurnRelation(relation);
             if (turnRelation != null)
             {
-                ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage).getExtendedStorage();
-                if (extendedStorage instanceof TurnCostStorage)
+                GraphExtension extendedStorage = graphStorage.getExtension();
+                if (extendedStorage instanceof TurnCostExtension)
                 {
-                    Collection<TurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(turnRelation, this);
+                    TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
+                    Collection<TurnCostTableEntry> entries = analyzeTurnRelation(turnRelation);
                     for (TurnCostTableEntry entry : entries)
                     {
-                        ((TurnCostStorage) extendedStorage).setTurnCosts(entry.nodeVia, entry.edgeFrom, entry.edgeTo, (int) entry.flags);
+                        tcs.addTurnInfo(entry.edgeFrom, entry.nodeVia, entry.edgeTo, entry.flags);
                     }
                 }
             }
         }
     }
 
+    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation )
+    {
+        TLongObjectMap<TurnCostTableEntry> entries = new TLongObjectHashMap<OSMTurnRelation.TurnCostTableEntry>();
+
+        for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders())
+        {
+            for (TurnCostTableEntry entry : analyzeTurnRelation(encoder, turnRelation))
+            {
+                TurnCostTableEntry oldEntry = entries.get(entry.getItemId());
+                if (oldEntry != null)
+                {
+                    // merging different encoders
+                    oldEntry.flags |= entry.flags;
+                } else
+                {
+                    entries.put(entry.getItemId(), entry);
+                }
+            }
+        }
+
+        return entries.valueCollection();
+    }
+
+    public Collection<TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder, OSMTurnRelation turnRelation )
+    {
+        if (!encoder.supports(TurnWeighting.class))
+            return Collections.emptyList();
+
+        EdgeExplorer edgeOutExplorer = outExplorerMap.get(encoder);
+        EdgeExplorer edgeInExplorer = inExplorerMap.get(encoder);
+
+        if (edgeOutExplorer == null || edgeInExplorer == null)
+        {
+            edgeOutExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
+            outExplorerMap.put(encoder, edgeOutExplorer);
+
+            edgeInExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false));
+            inExplorerMap.put(encoder, edgeInExplorer);
+        }
+        return turnRelation.getRestrictionAsEntries(encoder, edgeOutExplorer, edgeInExplorer, this);
+    }
+
+    /**
+     * @return OSM way ID from specified edgeId. Only previously stored OSM-way-IDs are returned in
+     * order to reduce memory overhead.
+     */
     public long getOsmIdOfInternalEdge( int edgeId )
     {
-        return getEdgeIdToOsmidMap().get(edgeId);
+        return getEdgeIdToOsmWayIdMap().get(edgeId);
     }
 
     public int getInternalNodeIdOfOsmNode( long nodeOsmId )
@@ -502,12 +525,12 @@ public int getInternalNodeIdOfOsmNode( long nodeOsmId )
         {
             // tower node
             id = -id - 3;
-            return graphStorage.getLatitude(id);
+            return nodeAccess.getLatitude(id);
         } else if (id > -TOWER_NODE)
         {
             // pillar node
             id = id - 3;
-            return pillarLats.getInt(id * 4L);
+            return pillarInfo.getLatitude(id);
         } else
             // e.g. if id is not handled from preparse (e.g. was ignored via isInBounds)
             return Double.NaN;
@@ -521,24 +544,17 @@ public int getInternalNodeIdOfOsmNode( long nodeOsmId )
         {
             // tower node
             id = -id - 3;
-            return graphStorage.getLongitude(id);
+            return nodeAccess.getLongitude(id);
         } else if (id > -TOWER_NODE)
         {
             // pillar node
             id = id - 3;
-            return pillarLons.getInt(id * 4L);
+            return pillarInfo.getLon(id);
         } else
             // e.g. if id is not handled from preparse (e.g. was ignored via isInBounds)
             return Double.NaN;
     }
 
-    static String fixWayName( String str )
-    {
-        if (str == null)
-            return "";
-        return str.replaceAll(";[ ]*", ", ");
-    }
-
     private void processNode( OSMNode node )
     {
         if (isInBounds(node))
@@ -548,7 +564,7 @@ private void processNode( OSMNode node )
             // analyze node tags for barriers
             if (node.hasTags())
             {
-                long nodeFlags = encodingManager.analyzeNodeTags(node);
+                long nodeFlags = encodingManager.handleNodeTags(node);
                 if (nodeFlags != 0)
                     getNodeFlagsMap().put(node.getId(), nodeFlags);
             }
@@ -568,22 +584,24 @@ boolean addNode( OSMNode node )
 
         double lat = node.getLat();
         double lon = node.getLon();
+        double ele = getElevation(node);
         if (nodeType == TOWER_NODE)
         {
-            addTowerNode(node.getId(), lat, lon);
+            addTowerNode(node.getId(), lat, lon, ele);
         } else if (nodeType == PILLAR_NODE)
         {
-            int tmp = nextPillarId * 4;
-            pillarLats.incCapacity(tmp + 4);
-            pillarLats.setInt(tmp, Helper.degreeToInt(lat));
-            pillarLons.incCapacity(tmp + 4);
-            pillarLons.setInt(tmp, Helper.degreeToInt(lon));
+            pillarInfo.setNode(nextPillarId, lat, lon, ele);
             getNodeMap().put(node.getId(), nextPillarId + 3);
             nextPillarId++;
         }
         return true;
     }
 
+    protected double getElevation( OSMNode node )
+    {
+        return eleProvider.getEle(node.getLat(), node.getLon());
+    }
+
     void prepareWaysWithRelationInfo( OSMRelation osmRelation )
     {
         // is there at least one tag interesting for the registed encoders?
@@ -600,7 +618,7 @@ void prepareWaysWithRelationInfo( OSMRelation osmRelation )
             long osmId = member.ref();
             long oldRelationFlags = getRelFlagsMap().get(osmId);
 
-            // Check if our new code is better comparated to the the last occured before            
+            // Check if our new relation data is better comparated to the the last one
             long newRelationFlags = encodingManager.handleRelationTags(osmRelation, oldRelationFlags);
             if (oldRelationFlags != newRelationFlags)
                 getRelFlagsMap().put(osmId, newRelationFlags);
@@ -624,9 +642,13 @@ void prepareHighwayNode( long osmId )
         }
     }
 
-    int addTowerNode( long osmId, double lat, double lon )
+    int addTowerNode( long osmId, double lat, double lon, double ele )
     {
-        graphStorage.setNode(nextTowerId, lat, lon);
+        if (nodeAccess.is3D())
+            nodeAccess.setNode(nextTowerId, lat, lon, ele);
+        else
+            nodeAccess.setNode(nextTowerId, lat, lon);
+
         int id = -(nextTowerId + 3);
         getNodeMap().put(osmId, id);
         nextTowerId++;
@@ -638,7 +660,7 @@ int addTowerNode( long osmId, double lat, double lon )
      */
     Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long flags, long wayOsmId )
     {
-        PointList pointList = new PointList(osmNodeIds.size());
+        PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
         List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
         int firstNode = -1;
         int lastIndex = osmNodeIds.size() - 1;
@@ -672,7 +694,7 @@ int addTowerNode( long osmId, double lat, double lon )
                             // TOWER node
                             newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
                             pointList.clear();
-                            pointList.add(graphStorage.getLatitude(tmpNode), graphStorage.getLongitude(tmpNode));
+                            pointList.add(nodeAccess, tmpNode);
                         }
                         firstNode = tmpNode;
                         lastInBoundsPillarNode = -1;
@@ -699,12 +721,12 @@ int addTowerNode( long osmId, double lat, double lon )
                 {
                     // TOWER node
                     tmpNode = -tmpNode - 3;
-                    pointList.add(graphStorage.getLatitude(tmpNode), graphStorage.getLongitude(tmpNode));
+                    pointList.add(nodeAccess, tmpNode);
                     if (firstNode >= 0)
                     {
                         newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
                         pointList.clear();
-                        pointList.add(graphStorage.getLatitude(tmpNode), graphStorage.getLongitude(tmpNode));
+                        pointList.add(nodeAccess, tmpNode);
                     }
                     firstNode = tmpNode;
                 }
@@ -720,31 +742,45 @@ int addTowerNode( long osmId, double lat, double lon )
 
     EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId )
     {
+        // sanity checks
         if (fromIndex < 0 || toIndex < 0)
             throw new AssertionError("to or from index is invalid for this edge " + fromIndex + "->" + toIndex + ", points:" + pointList);
+        if (pointList.getDimension() != nodeAccess.getDimension())
+            throw new AssertionError("Dimension does not match for pointList vs. nodeAccess " + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
 
         double towerNodeDistance = 0;
         double prevLat = pointList.getLatitude(0);
         double prevLon = pointList.getLongitude(0);
-        double lat;
-        double lon;
-        PointList pillarNodes = new PointList(pointList.getSize() - 2);
+        double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
+        double lat, lon, ele = Double.NaN;
+        PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
         int nodes = pointList.getSize();
         for (int i = 1; i < nodes; i++)
         {
-            // we could save some lines if we would use pointListIncludingTowerNodes.calculateDistance(distCalc);
+            // we could save some lines if we would use pointList.calcDistance(distCalc);
             lat = pointList.getLatitude(i);
             lon = pointList.getLongitude(i);
-            towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
+            if (pointList.is3D())
+            {
+                ele = pointList.getElevation(i);
+                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
+                prevEle = ele;
+            } else
+                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
             prevLat = lat;
             prevLon = lon;
             if (nodes > 2 && i < nodes - 1)
-                pillarNodes.add(lat, lon);
+            {
+                if (pillarNodes.is3D())
+                    pillarNodes.add(lat, lon, ele);
+                else
+                    pillarNodes.add(lat, lon);
+            }
         }
         if (towerNodeDistance == 0)
         {
             // As investigation shows often two paths should have crossed via one identical point 
-            // but end up in two very close points.
+            // but end up in two very release points.
             zeroCounter++;
             towerNodeDistance = 0.0001;
         }
@@ -752,18 +788,23 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
         EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
         if (nodes > 2)
         {
-            simplifyAlgo.simplify(pillarNodes);
+            if (doSimplify)
+                simplifyAlgo.simplify(pillarNodes);
+
             iter.setWayGeometry(pillarNodes);
         }
-        storeOSMWayID(iter.getEdge(), wayOsmId);
+        storeOsmWayID(iter.getEdge(), wayOsmId);
         return iter;
     }
 
-    private void storeOSMWayID( int edgeId, long osmWayID )
+    /**
+     * Stores only osmWayIds which are required for relations
+     */
+    private void storeOsmWayID( int edgeId, long osmWayId )
     {
-        if (getOsmIdStoreRequiredSet().contains(osmWayID))
+        if (getOsmWayIdSet().contains(osmWayId))
         {
-            getEdgeIdToOsmidMap().put(edgeId, osmWayID);
+            getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
         }
     }
 
@@ -773,43 +814,39 @@ private void storeOSMWayID( int edgeId, long osmWayID )
     private int handlePillarNode( int tmpNode, long osmId, PointList pointList, boolean convertToTowerNode )
     {
         tmpNode = tmpNode - 3;
-        int intlat = pillarLats.getInt(tmpNode * 4);
-        int intlon = pillarLons.getInt(tmpNode * 4);
-        if (intlat == Integer.MAX_VALUE || intlon == Integer.MAX_VALUE)
-        {
-            throw new RuntimeException("Conversion pillarNode to towerNode already happended!? " + "osmId:" + osmId + " pillarIndex:"
-                    + tmpNode);
-        }
-
-        double tmpLat = Helper.intToDegree(intlat);
-        double tmpLon = Helper.intToDegree(intlon);
+        double lat = pillarInfo.getLatitude(tmpNode);
+        double lon = pillarInfo.getLongitude(tmpNode);
+        double ele = pillarInfo.getElevation(tmpNode);
+        if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
+            throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
+                    + "osmId:" + osmId + " pillarIndex:" + tmpNode);
 
         if (convertToTowerNode)
         {
             // convert pillarNode type to towerNode, make pillar values invalid
-            pillarLons.setInt(tmpNode * 4, Integer.MAX_VALUE);
-            pillarLats.setInt(tmpNode * 4, Integer.MAX_VALUE);
-            tmpNode = addTowerNode(osmId, tmpLat, tmpLon);
+            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
+            tmpNode = addTowerNode(osmId, lat, lon, ele);
         } else
         {
-            pointList.add(tmpLat, tmpLon);
+            if (pointList.is3D())
+                pointList.add(lat, lon, ele);
+            else
+                pointList.add(lat, lon);
         }
 
-        return tmpNode;
+        return (int) tmpNode;
     }
 
-    void finishedReading()
+    protected void finishedReading()
     {
         printInfo("way");
-        dir.remove(pillarLats);
-        dir.remove(pillarLons);
-        pillarLons = null;
-        pillarLats = null;
+        pillarInfo.clear();
+        eleProvider.release();
         osmNodeIdToInternalNodeMap = null;
         osmNodeIdToNodeFlagsMap = null;
         osmWayIdToRouteWeightMap = null;
-        osmIdStoreRequiredSet = null;
-        edgeIdToOsmidMap = null;
+        osmWayIdSet = null;
+        edgeIdToOsmWayIdMap = null;
     }
 
     /**
@@ -822,15 +859,11 @@ long addBarrierNode( long nodeId )
         if (graphIndex < TOWER_NODE)
         {
             graphIndex = -graphIndex - 3;
-            newNode = new OSMNode(createNewNodeId(), 
-                    graphStorage.getLatitude(graphIndex), 
-                    graphStorage.getLongitude(graphIndex));
+            newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
         } else
         {
             graphIndex = graphIndex - 3;
-            newNode = new OSMNode(createNewNodeId(), 
-                    Helper.intToDegree(pillarLats.getInt(graphIndex * 4)), 
-                    Helper.intToDegree(pillarLons.getInt(graphIndex * 4)));
+            newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
         }
 
         final long id = newNode.getId();
@@ -841,7 +874,7 @@ long addBarrierNode( long nodeId )
 
     private long createNewNodeId()
     {
-        return newUniqueOSMId++;
+        return newUniqueOsmId++;
     }
 
     /**
@@ -852,15 +885,15 @@ private long createNewNodeId()
         // clear barred directions from routing flags
         flags &= ~nodeFlags;
         // add edge
-        barrierNodeIDs.clear();
-        barrierNodeIDs.add(fromId);
-        barrierNodeIDs.add(toId);
-        return addOSMWay(barrierNodeIDs, flags, wayOsmId);
+        barrierNodeIds.clear();
+        barrierNodeIds.add(fromId);
+        barrierNodeIds.add(toId);
+        return addOSMWay(barrierNodeIds, flags, wayOsmId);
     }
 
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
-     * 
+     * <p>
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
     OSMTurnRelation createTurnRelation( OSMRelation relation )
@@ -888,7 +921,7 @@ OSMTurnRelation createTurnRelation( OSMRelation relation )
                     viaNodeID = member.ref();
                 }
             }
-            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
+            if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
             {
                 return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
             }
@@ -907,12 +940,12 @@ boolean isInBounds( OSMNode node )
     /**
      * Maps OSM IDs (long) to internal node IDs (int)
      */
-    LongIntMap getNodeMap()
+    protected LongIntMap getNodeMap()
     {
         return osmNodeIdToInternalNodeMap;
     }
 
-    TLongLongMap getNodeFlagsMap()
+    protected TLongLongMap getNodeFlagsMap()
     {
         return osmNodeIdToNodeFlagsMap;
     }
@@ -925,20 +958,15 @@ TLongLongHashMap getRelFlagsMap()
     /**
      * Specify the type of the path calculation (car, bike, ...).
      */
-    public OSMReader setEncodingManager( EncodingManager acceptWay )
-    {
-        this.encodingManager = acceptWay;
-        return this;
-    }
-
-    public OSMReader setEnableInstructions( boolean enableInstructions )
+    public OSMReader setEncodingManager( EncodingManager em )
     {
-        this.enableInstructions = enableInstructions;
+        this.encodingManager = em;
         return this;
     }
 
     public OSMReader setWayPointMaxDistance( double maxDist )
     {
+        doSimplify = maxDist > 0;
         simplifyAlgo.setMaxDistance(maxDist);
         return this;
     }
@@ -949,12 +977,30 @@ public OSMReader setWorkerThreads( int numOfWorkers )
         return this;
     }
 
+    public OSMReader setElevationProvider( ElevationProvider eleProvider )
+    {
+        if (eleProvider == null)
+            throw new IllegalStateException("Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+
+        if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
+            throw new IllegalStateException("Make sure you graph accepts 3D data");
+
+        this.eleProvider = eleProvider;
+        return this;
+    }
+
+    public OSMReader setOSMFile( File osmFile )
+    {
+        this.osmFile = osmFile;
+        return this;
+    }
+
     private void printInfo( String str )
     {
         LoggerFactory.getLogger(getClass()).info(
                 "finished " + str + " processing." + " nodes: " + graphStorage.getNodes() + ", osmIdMap.size:" + getNodeMap().getSize()
-                        + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB" + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
-                        + ", relFlagsMap.size:" + getRelFlagsMap().size() + " " + Helper.getMemInfo());
+                + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB" + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
+                + ", relFlagsMap.size:" + getRelFlagsMap().size() + " " + Helper.getMemInfo());
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/reader/OSMRelation.java b/core/src/main/java/com/graphhopper/reader/OSMRelation.java
index e417e47851..ff7ca2651f 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMRelation.java
@@ -21,7 +21,6 @@
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 import java.util.ArrayList;
-import java.util.Map;
 
 /**
  * Represents an OSM Relation
@@ -30,23 +29,21 @@
  */
 public class OSMRelation extends OSMElement
 {
-    protected ArrayList<Member> members;
+    protected final ArrayList<Member> members = new ArrayList<Member>(5);
 
-    public OSMRelation( long id, XMLStreamReader parser ) throws XMLStreamException
+    public static OSMRelation create( long id, XMLStreamReader parser ) throws XMLStreamException
     {
-        super(id, RELATION, parser);
-        members = new ArrayList<Member>();
+        OSMRelation rel = new OSMRelation(id);
 
         parser.nextTag();
-        readMembers(parser);
-        readTags(parser);
+        rel.readMembers(parser);
+        rel.readTags(parser);
+        return rel;
     }
 
-    public OSMRelation( long id, Map<String, String> tags )
+    public OSMRelation( long id )
     {
-        super(id, RELATION, tags);
-
-        members = new ArrayList<Member>();
+        super(id, RELATION);
     }
 
     protected void readMembers( XMLStreamReader parser ) throws XMLStreamException
@@ -67,7 +64,7 @@ protected void readMembers( XMLStreamReader parser ) throws XMLStreamException
     @Override
     public String toString()
     {
-        return "Relation (" + id + ", " + members.size() + " members)";
+        return "Relation (" + getId() + ", " + members.size() + " members)";
     }
 
     public ArrayList<Member> getMembers()
@@ -75,15 +72,6 @@ public String toString()
         return members;
     }
 
-    public void copyMembers( OSMRelation input )
-    {
-        members = new ArrayList<Member>();
-        for (int i = 0; i < input.members.size(); i++)
-        {
-            members.add(new Member(input.members.get(i)));
-        }
-    }
-
     public boolean isMetaRelation()
     {
         for (Member member : members)
@@ -144,9 +132,9 @@ public void add( Member member )
         public static final int WAY = 1;
         public static final int RELATION = 2;
         private static final String typeDecode = "nwr";
-        private int type;
-        private long ref;
-        private String role;
+        private final int type;
+        private final long ref;
+        private final String role;
 
         public Member( XMLStreamReader parser )
         {
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
index 234e5040f6..c3e922d7e7 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -2,13 +2,12 @@
 
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Map;
-import java.util.Set;
 
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
+import java.util.*;
 
 /**
  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
@@ -17,12 +16,11 @@
  */
 public class OSMTurnRelation
 {
-
     enum Type
     {
         UNSUPPORTED, NOT, ONLY;
 
-        private static Map<String, Type> tags = new HashMap<String, Type>();
+        private static final Map<String, Type> tags = new HashMap<String, Type>();
 
         static
         {
@@ -46,31 +44,31 @@ public static Type getRestrictionType( String tag )
         }
     }
 
-    private long fromOsm;
-    private long viaOsm;
-    private long toOsm;
-    private Type restriction;
+    private final long fromOsmWayId;
+    private final long viaOsmNodeId;
+    private final long toOsmWayId;
+    private final Type restriction;
 
     OSMTurnRelation( long fromWayID, long viaNodeID, long toWayID, Type restrictionType )
     {
-        this.fromOsm = fromWayID;
-        this.viaOsm = viaNodeID;
-        this.toOsm = toWayID;
+        this.fromOsmWayId = fromWayID;
+        this.viaOsmNodeId = viaNodeID;
+        this.toOsmWayId = toWayID;
         this.restriction = restrictionType;
     }
 
     long getOsmIdFrom()
     {
-        return fromOsm;
+        return fromOsmWayId;
     }
 
     long getOsmIdTo()
     {
-        return toOsm;
+        return toOsmWayId;
     }
 
     /**
-     * transforms this relation into a collection of node cost entries
+     * Transforms this relation into a collection of turn cost entries
      * <p>
      * @param edgeOutExplorer an edge filter which only allows outgoing edges
      * @param edgeInExplorer an edge filter which only allows incoming edges
@@ -79,75 +77,65 @@ long getOsmIdTo()
     public Collection<TurnCostTableEntry> getRestrictionAsEntries( TurnCostEncoder encoder,
             EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, OSMReader osmReader )
     {
-        final Set<TurnCostTableEntry> entries = new HashSet<TurnCostTableEntry>();
-
-        int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsm);
+        int nodeVia = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
 
         try
         {
-            if (viaNodeId == OSMReader.EMPTY)
-            {
-                throw new IllegalArgumentException("Unknown node osm id");
-            }
+            // street with restriction was not included (access or tag limits etc)
+            if (nodeVia == OSMReader.EMPTY)
+                return Collections.emptyList();
 
             int edgeIdFrom = EdgeIterator.NO_EDGE;
 
             // get all incoming edges and receive the edge which is defined by fromOsm
-            EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
+            EdgeIterator iter = edgeInExplorer.setBaseNode(nodeVia);
 
             while (iter.next())
             {
-                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsm)
+                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
                 {
                     edgeIdFrom = iter.getEdge();
                     break;
                 }
             }
 
-            //get all outgoing edges of the via node 
-            iter = edgeOutExplorer.setBaseNode(viaNodeId);
-            if (edgeIdFrom != EdgeIterator.NO_EDGE)
+            if (edgeIdFrom == EdgeIterator.NO_EDGE)
+                return Collections.emptyList();
+
+            final Collection<TurnCostTableEntry> entries = new ArrayList<TurnCostTableEntry>();
+            // get all outgoing edges of the via node 
+            iter = edgeOutExplorer.setBaseNode(nodeVia);
+            // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
+            // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
+            while (iter.next())
             {
-                if (this.restriction == Type.NOT)
+                int edgeId = iter.getEdge();
+                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
+                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId
+                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0)
                 {
-                    // if we have a restriction of TYPE_NO_* we add restriction only to
-                    // the given turn (from, via, to)  
-                    while (iter.next())
-                    {
-                        if (iter.getEdge() != edgeIdFrom && osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.toOsm)
-                        {
-                            final TurnCostTableEntry entry = new TurnCostTableEntry();
-                            entry.nodeVia = viaNodeId;
-                            entry.edgeFrom = edgeIdFrom;
-                            entry.edgeTo = iter.getEdge();
-                            entry.flags = encoder.getTurnFlags(true, 0);
-                            entries.add(entry);
-                        }
-                    }
-
-                } else if (this.restriction == Type.ONLY)
-                {
-                    // if we have a restriction of TYPE_ONLY_* we add restriction to
-                    // any turn possibility (from, via, * ) except the given turn
-                    while (iter.next())
-                    {
-                        if (iter.getEdge() != edgeIdFrom && osmReader.getOsmIdOfInternalEdge(iter.getEdge()) != this.toOsm)
-                        {
-                            final TurnCostTableEntry entry = new TurnCostTableEntry();
-                            entry.nodeVia = viaNodeId;
-                            entry.edgeFrom = edgeIdFrom;
-                            entry.edgeTo = iter.getEdge();
-                            entry.flags = encoder.getTurnFlags(true, 0);
-                            entries.add(entry);
-                        }
-                    }
+                    final TurnCostTableEntry entry = new TurnCostTableEntry();
+                    entry.nodeVia = nodeVia;
+                    entry.edgeFrom = edgeIdFrom;
+                    entry.edgeTo = iter.getEdge();
+                    entry.flags = encoder.getTurnFlags(true, 0);
+                    entries.add(entry);
+
+                    if (this.restriction == Type.NOT)
+                        break;
                 }
             }
+            return entries;
         } catch (Exception e)
         {
-            throw new IllegalStateException("Could not built node costs table for relation of node [osmId:" + this.viaOsm + "].", e);
+            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
         }
-        return entries;
+    }
+
+    @Override
+    public String toString()
+    {
+        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
     }
 
     /**
@@ -156,17 +144,24 @@ long getOsmIdTo()
     public static class TurnCostTableEntry
     {
         public int edgeFrom;
-        public int edgeTo;
         public int nodeVia;
+        public int edgeTo;
         public long flags;
 
         /**
-         * @return an unique id (edgeFrom, edgeTo) to avoid doubled entries during parsing
+         * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
+         * are involved.
          */
         public long getItemId()
         {
             return ((long) edgeFrom) << 32 | ((long) edgeTo);
         }
+
+        @Override
+        public String toString()
+        {
+            return "*-(" + edgeFrom + ")->" + nodeVia + "-(" + edgeTo + ")->*";
+        }
     }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMWay.java b/core/src/main/java/com/graphhopper/reader/OSMWay.java
index 2c3ccee2d4..3f713757b1 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMWay.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMWay.java
@@ -23,7 +23,6 @@
 import javax.xml.stream.XMLStreamConstants;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
-import java.util.Map;
 
 /**
  * Represents an OSM Way
@@ -32,42 +31,23 @@
  */
 public class OSMWay extends OSMElement
 {
-    protected TLongList nodes;
+    protected final TLongList nodes = new TLongArrayList(5);
 
     /**
      * Constructor for XML Parser
-     * <p/>
-     * @param id
-     * @param parser
-     * @throws XMLStreamException
      */
-    public OSMWay( long id, XMLStreamReader parser ) throws XMLStreamException
+    public static OSMWay create( long id, XMLStreamReader parser ) throws XMLStreamException
     {
-        super(id, WAY, parser);
-        nodes = new TLongArrayList();
-
+        OSMWay way = new OSMWay(id);
         parser.nextTag();
-        readNodes(parser);
-        readTags(parser);
-    }
-
-    /**
-     * Constructor for PBF Parser
-     * <p/>
-     * @param id
-     * @param tags
-     */
-    public OSMWay( long id, Map<String, String> tags )
-    {
-        super(id, WAY, tags);
-
-        nodes = new TLongArrayList();
+        way.readNodes(parser);
+        way.readTags(parser);
+        return way;
     }
 
     public OSMWay( long id )
     {
         super(id, WAY);
-        nodes = new TLongArrayList();
     }
 
     protected void readNodes( XMLStreamReader parser ) throws XMLStreamException
@@ -94,6 +74,6 @@ public TLongList getNodes()
     @Override
     public String toString()
     {
-        return "Way (" + id + ", " + nodes.size() + " nodes)";
+        return "Way id:" + getId() + ", nodes:" + nodes.size() + ", tags:" + super.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
new file mode 100644
index 0000000000..0c612d5e7b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -0,0 +1,135 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader;
+
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointAccess;
+
+/**
+ * This class helps to store lat,lon,ele for every node parsed in OSMReader
+ * <p>
+ * @author Peter Karich
+ */
+public class PillarInfo implements PointAccess
+{
+    private final int LAT = 0 * 4, LON = 1 * 4, ELE = 2 * 4;
+    private final boolean enabled3D;
+    private final DataAccess da;
+    private final int rowSizeInBytes;
+    private final Directory dir;
+
+    public PillarInfo( boolean enabled3D, Directory dir )
+    {
+        this.enabled3D = enabled3D;
+        this.dir = dir;
+        this.da = dir.find("tmpPillarInfo").create(100);
+        this.rowSizeInBytes = getDimension() * 4;
+    }
+
+    @Override
+    public boolean is3D()
+    {
+        return enabled3D;
+    }
+
+    @Override
+    public int getDimension()
+    {
+        return enabled3D ? 3 : 2;
+    }
+
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        long tmp = (long) nodeId * rowSizeInBytes;
+        da.ensureCapacity(tmp + rowSizeInBytes);
+    }        
+
+    @Override
+    public void setNode( int nodeId, double lat, double lon )
+    {
+        _setNode(nodeId, lat, lon, Double.NaN);
+    }
+
+    @Override
+    public void setNode( int nodeId, double lat, double lon, double ele )
+    {
+        _setNode(nodeId, lat, lon, ele);
+    }
+
+    private void _setNode( int nodeId, double lat, double lon, double ele )
+    {
+        ensureNode(nodeId);
+        long tmp = (long) nodeId * rowSizeInBytes;
+        da.setInt(tmp + LAT, Helper.degreeToInt(lat));
+        da.setInt(tmp + LON, Helper.degreeToInt(lon));
+
+        if (is3D())
+            da.setInt(tmp + ELE, Helper.eleToInt(ele));
+    }
+
+    @Override
+    public double getLatitude( int id )
+    {
+        int intVal = da.getInt((long) id * rowSizeInBytes + LAT);
+        return Helper.intToDegree(intVal);
+    }
+
+    @Override
+    public double getLat( int id )
+    {
+        return getLatitude(id);
+    }
+
+    @Override
+    public double getLongitude( int id )
+    {
+        int intVal = da.getInt((long) id * rowSizeInBytes + LON);
+        return Helper.intToDegree(intVal);
+    }
+
+    @Override
+    public double getLon( int id )
+    {
+        return getLongitude(id);
+    }
+
+    @Override
+    public double getElevation( int id )
+    {
+        if (!is3D())
+            return Double.NaN;
+
+        int intVal = da.getInt((long) id * rowSizeInBytes + ELE);
+        return Helper.intToEle(intVal);
+    }
+
+    @Override
+    public double getEle( int id )
+    {
+        return getElevation(id);
+    }
+
+    public void clear()
+    {
+        dir.remove(da);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
new file mode 100644
index 0000000000..0de2549665
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -0,0 +1,341 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DAType;
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import java.awt.image.Raster;
+import java.io.*;
+import java.net.SocketTimeoutException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
+import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
+import org.apache.xmlgraphics.image.codec.util.SeekableStream;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Elevation data from CGIAR project http://srtm.csi.cgiar.org/ 'PROCESSED SRTM DATA VERSION 4.1'.
+ * Every file covers a region of 5x5 degree. License granted for all people using GraphHopper:
+ * http://graphhopper.com/public/license/CGIAR.txt
+ * <p>
+ * Every zip contains readme.txt with the necessary information e.g.:
+ * <ol>
+ * <li>
+ * All GeoTiffs with 6000 x 6000 pixels.
+ * </li>
+ * </ol>
+ * <p>
+ * @author NopMap
+ * @author Peter Karich
+ */
+public class CGIARProvider implements ElevationProvider
+{
+    private static final int WIDTH = 6000;
+    private Downloader downloader = new Downloader("GraphHopper CGIARReader").setTimeout(10000);
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
+    private File cacheDir = new File("/tmp/cgiar");
+    // for alternatives see #346
+    private String baseUrl = "http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff";    
+    private Directory dir;
+    private DAType daType = DAType.MMAP;
+    final double precision = 1e7;
+    private final double invPrecision = 1 / precision;
+    private final int degree = 5;
+    private boolean calcMean = false;
+    private boolean autoRemoveTemporary = true;
+
+    @Override
+    public void setCalcMean( boolean eleCalcMean )
+    {
+        calcMean = eleCalcMean;
+    }
+
+    /**
+     * Creating temporary files can take a long time as we need to unpack tiff as well as to fill
+     * our DataAccess object, so this option can be used to disable the default clear mechanism via
+     * specifying 'false'.
+     */
+    public void setAutoRemoveTemporaryFiles( boolean autoRemoveTemporary )
+    {
+        this.autoRemoveTemporary = autoRemoveTemporary;
+    }
+
+    public void setDownloader( Downloader downloader )
+    {
+        this.downloader = downloader;
+    }
+
+    @Override
+    public ElevationProvider setCacheDir( File cacheDir )
+    {
+        if (cacheDir.exists() && !cacheDir.isDirectory())
+            throw new IllegalArgumentException("Cache path has to be a directory");
+        try
+        {
+            this.cacheDir = cacheDir.getCanonicalFile();
+        } catch (IOException ex)
+        {
+            throw new RuntimeException(ex);
+        }
+        return this;
+    }
+
+    @Override
+    public ElevationProvider setBaseURL( String baseUrl )
+    {
+        if (baseUrl == null || baseUrl.isEmpty())
+            throw new IllegalArgumentException("baseUrl cannot be empty");
+
+        this.baseUrl = baseUrl;
+        return this;
+    }
+
+    @Override
+    public ElevationProvider setDAType( DAType daType )
+    {
+        this.daType = daType;
+        return this;
+    }
+
+    @Override
+    public double getEle( double lat, double lon )
+    {
+        // no data we can avoid the trouble
+        if (lat > 60 || lat < -60)
+            return 0;
+
+        lat = (int) (lat * precision) / precision;
+        lon = (int) (lon * precision) / precision;
+        String name = getFileName(lat, lon);
+        HeightTile demProvider = cacheData.get(name);
+        if (demProvider == null)
+        {
+            if (!cacheDir.exists())
+                cacheDir.mkdirs();
+
+            int minLat = down(lat);
+            int minLon = down(lon);
+            // less restrictive against boundary checking
+            demProvider = new HeightTile(minLat, minLon, WIDTH, degree * precision, degree);
+            demProvider.setCalcMean(calcMean);
+
+            cacheData.put(name, demProvider);
+            DataAccess heights = getDirectory().find(name + ".gh");
+            demProvider.setHeights(heights);
+            boolean loadExisting = false;
+            try
+            {
+                loadExisting = heights.loadExisting();
+            } catch (Exception ex)
+            {
+                logger.warn("cannot load " + name + ", error:" + ex.getMessage());
+            }
+
+            if (!loadExisting)
+            {
+                String tifName = name + ".tif";
+                String zippedURL = baseUrl + "/" + name + ".zip";
+                File file = new File(cacheDir, new File(zippedURL).getName());
+
+                // get zip file if not already in cacheDir - unzip later and in-memory only!
+                if (!file.exists())
+                {
+                    try
+                    {
+                        for (int i = 0; i < 3; i++)
+                        {
+                            try
+                            {
+                                downloader.downloadFile(zippedURL, file.getAbsolutePath());
+                                break;
+                            } catch (SocketTimeoutException ex)
+                            {
+                                // just try again after a little nap
+                                Thread.sleep(2000);
+                                continue;
+                            } catch (IOException ex)
+                            {
+                                demProvider.setSeaLevel(true);
+                                // use small size on disc and in-memory
+                                heights.setSegmentSize(100).create(10).
+                                        flush();
+                                return 0;
+                            }
+                        }
+                    } catch (Exception ex)
+                    {
+                        throw new RuntimeException(ex);
+                    }
+                }
+
+                // short == 2 bytes
+                heights.create(2 * WIDTH * WIDTH);
+
+                // logger.info("start decoding");
+                // decode tiff data
+                Raster raster;
+                SeekableStream ss = null;
+                try
+                {
+                    InputStream is = new FileInputStream(file);
+                    ZipInputStream zis = new ZipInputStream(is);
+                    // find tif file in zip
+                    ZipEntry entry = zis.getNextEntry();
+                    while (entry != null && !entry.getName().equals(tifName))
+                    {
+                        entry = zis.getNextEntry();
+                    }
+
+                    ss = SeekableStream.wrapInputStream(zis, true);
+                    TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
+                    raster = imageDecoder.decodeAsRaster();
+                } catch (Exception e)
+                {
+                    throw new RuntimeException("Can't decode " + tifName, e);
+                } finally
+                {
+                    if (ss != null)
+                        Helper.close(ss);
+                }
+
+                // logger.info("start converting to our format");           
+                final int height = raster.getHeight();
+                final int width = raster.getWidth();
+                int x = 0, y = 0;
+                try
+                {
+                    for (y = 0; y < height; y++)
+                    {
+                        for (x = 0; x < width; x++)
+                        {
+                            short val = (short) raster.getPixel(x, y, (int[]) null)[0];
+                            if (val < -1000 || val > 12000)
+                                val = Short.MIN_VALUE;
+
+                            heights.setShort(2 * (y * WIDTH + x), val);
+                        }
+                    }
+                    heights.flush();
+
+                    // TODO remove tifName and zip?
+                } catch (Exception ex)
+                {
+                    throw new RuntimeException("Problem at x:" + x + ", y:" + y, ex);
+                }
+            } // loadExisting
+        }
+
+        if (demProvider.isSeaLevel())
+            return 0;
+
+        return demProvider.getHeight(lat, lon);
+    }
+
+    int down( double val )
+    {
+        // 'rounding' to closest 5
+        int intVal = (int) (val / degree) * degree;
+        if (!(val >= 0 || intVal - val < invPrecision))
+            intVal = intVal - degree;
+
+        return intVal;
+    }
+
+    protected String getFileName( double lat, double lon )
+    {
+        lon = 1 + (180 + lon) / degree;
+        int lonInt = (int) lon;
+        lat = 1 + (60 - lat) / degree;
+        int latInt = (int) lat;
+
+        if (Math.abs(latInt - lat) < invPrecision / degree)
+            latInt--;
+
+        // replace String.format as it seems to be slow
+        // String.format("srtm_%02d_%02d", lonInt, latInt);
+        String str = "srtm_";
+        str += lonInt < 10 ? "0" : "";
+        str += lonInt;
+        str += latInt < 10 ? "_0" : "_";
+        str += latInt;
+
+        return str;
+    }
+
+    @Override
+    public void release()
+    {
+        cacheData.clear();
+
+        // for memory mapped type we create temporary unpacked files which should be removed
+        if (autoRemoveTemporary && dir != null)
+            dir.clear();
+    }
+
+    @Override
+    public String toString()
+    {
+        return "CGIAR";
+    }
+
+    private Directory getDirectory()
+    {
+        if (dir != null)
+            return dir;
+
+        logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
+        return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
+    }
+
+    public static void main( String[] args )
+    {
+        CGIARProvider provider = new CGIARProvider();
+        // 337.0
+        System.out.println(provider.getEle(49.949784, 11.57517));
+        // 453.0
+        System.out.println(provider.getEle(49.968668, 11.575127));
+        // 447.0
+        System.out.println(provider.getEle(49.968682, 11.574842));
+
+        // 3131
+        System.out.println(provider.getEle(-22.532854, -65.110474));
+
+        // 123               
+        System.out.println(provider.getEle(38.065392, -87.099609));
+
+        // 1615
+        System.out.println(provider.getEle(40, -105.2277023));
+        System.out.println(provider.getEle(39.99999999, -105.2277023));
+        System.out.println(provider.getEle(39.9999999, -105.2277023));
+        // 1617
+        System.out.println(provider.getEle(39.999999, -105.2277023));
+
+        // 0
+        System.out.println(provider.getEle(29.840644, -42.890625));
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
new file mode 100644
index 0000000000..aed7740ae7
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
@@ -0,0 +1,98 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DAType;
+import java.io.File;
+
+/**
+ * @author Peter Karich
+ */
+public interface ElevationProvider
+{
+    /**
+     * @return returns the hight in meter or Double.NaN if invalid
+     */
+    double getEle( double lat, double lon );
+
+    /**
+     * Specifies the service URL where to download the elevation data. An empty string should set it
+     * to the default URL. Default is a provider-dependent URL which should work out of the box.
+     */
+    ElevationProvider setBaseURL( String baseURL );
+
+    /**
+     * Specifies the directory where to temporarily store the elevation data after fetched from base
+     * URL. Default is a custom provider-dependent subdirectory in '/tmp'
+     */
+    ElevationProvider setCacheDir( File cacheDir );
+
+    /**
+     * Set to true if you have a small area and need high speed access. Default is DAType.MMAP
+     */
+    ElevationProvider setDAType( DAType daType );
+
+    /**
+     * Configuration option to include surrounding elevation points when fetching the elevation. Has
+     * only an effect if called before the first getEle call. Turned off by default.
+     */
+    void setCalcMean( boolean calcMean );
+
+    /**
+     * Release resources.
+     */
+    void release();
+
+    public final static ElevationProvider NOOP = new ElevationProvider()
+    {
+        @Override
+        public double getEle( double lat, double lon )
+        {
+            return Double.NaN;
+        }
+
+        @Override
+        public ElevationProvider setCacheDir( File cacheDir )
+        {
+            return this;
+        }
+
+        @Override
+        public ElevationProvider setBaseURL( String baseURL )
+        {
+            return this;
+        }
+
+        @Override
+        public ElevationProvider setDAType( DAType daType )
+        {
+            return this;
+        }
+
+        @Override
+        public void release()
+        {
+        }
+
+        @Override
+        public void setCalcMean( boolean eleCalcMean )
+        {
+        }
+    };
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
new file mode 100644
index 0000000000..c0c27c476e
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -0,0 +1,185 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DataAccess;
+import java.awt.Color;
+import java.awt.Graphics;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.imageio.ImageIO;
+
+/**
+ * One rectangle of height data from Shuttle Radar Topography Mission.
+ * <p>
+ * @author Peter Karich
+ */
+public class HeightTile
+{
+    private DataAccess heights;
+    private final int minLat;
+    private final int minLon;
+    private final int width;
+    private final int degree;
+    private final double lowerBound;
+    private final double higherBound;
+    private boolean calcMean;
+
+    public HeightTile( int minLat, int minLon, int width, double precision, int degree )
+    {
+        this.minLat = minLat;
+        this.minLon = minLon;
+        this.width = width;
+
+        this.lowerBound = -1 / precision;
+        this.higherBound = degree + 1 / precision;
+
+        this.degree = degree;
+    }
+
+    public HeightTile setCalcMean( boolean b )
+    {
+        this.calcMean = b;
+        return this;
+    }
+
+    public HeightTile setSeaLevel( boolean b )
+    {
+        heights.setHeader(0, b ? 1 : 0);
+        return this;
+    }
+
+    public boolean isSeaLevel()
+    {
+        return heights.getHeader(0) == 1;
+    }
+
+    void setHeights( DataAccess da )
+    {
+        this.heights = da;
+    }
+
+    public double getHeight( double lat, double lon )
+    {
+        double deltaLat = Math.abs(lat - minLat);
+        double deltaLon = Math.abs(lon - minLon);
+        if (deltaLat > higherBound || deltaLat < lowerBound)
+            throw new IllegalStateException("latitude not in boundary of this file:" + lat + "," + lon + ", this:" + this.toString());
+        if (deltaLon > higherBound || deltaLon < lowerBound)
+            throw new IllegalStateException("longitude not in boundary of this file:" + lat + "," + lon + ", this:" + this.toString());
+
+        // first row in the file is the northernmost one
+        // http://gis.stackexchange.com/a/43756/9006
+        int lonSimilar = (int) (width / degree * deltaLon);
+        // different fallback methods for lat and lon as we have different rounding (lon -> positive, lat -> negative)
+        if (lonSimilar >= width)
+            lonSimilar = width - 1;
+        int latSimilar = width - 1 - (int) (width / degree * deltaLat);
+        if (latSimilar < 0)
+            latSimilar = 0;
+
+        // always keep in mind factor 2 because of short value
+        int daPointer = 2 * (latSimilar * width + lonSimilar);
+        int value = heights.getShort(daPointer);
+        AtomicInteger counter = new AtomicInteger(1);
+        if (value == Short.MIN_VALUE)
+            return Double.NaN;
+
+        if (calcMean)
+        {
+            if (lonSimilar > 0)
+                value += includePoint(daPointer - 2, counter);
+
+            if (lonSimilar < width - 1)
+                value += includePoint(daPointer + 2, counter);
+
+            if (latSimilar > 0)
+                value += includePoint(daPointer - 2 * width, counter);
+
+            if (latSimilar < width - 1)
+                value += includePoint(daPointer + 2 * width, counter);
+        }
+
+        return (double) value / counter.get();
+    }
+
+    private double includePoint( int pointer, AtomicInteger counter )
+    {
+        short value = heights.getShort(pointer);
+        if (value == Short.MIN_VALUE)
+            return 0;
+
+        counter.incrementAndGet();
+        return value;
+    }
+
+    public void toImage( String imageFile ) throws IOException
+    {
+        ImageIO.write(makeARGB(), "PNG", new File(imageFile));
+    }
+
+    protected BufferedImage makeARGB()
+    {
+        int height = width;
+        BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
+        Graphics g = argbImage.getGraphics();
+        long len = heights.getCapacity() / 2;
+        for (int i = 0; i < len; i++)
+        {
+            int lonSimilar = i % width;
+            // no need for width - y as coordinate system for Graphics is already this way
+            int latSimilar = i / width;
+            int green = Math.abs(heights.getShort(i * 2));
+            if (green == 0)
+            {
+                g.setColor(new Color(255, 0, 0, 255));
+            } else
+            {
+                int red = 0;
+                while (green > 255)
+                {
+                    green = green / 10;
+                    red += 50;
+                }
+                if (red > 255)
+                    red = 255;
+                g.setColor(new Color(red, green, 122, 255));
+            }
+            g.drawLine(lonSimilar, latSimilar, lonSimilar, latSimilar);
+        }
+        g.dispose();
+        return argbImage;
+    }
+
+    public BufferedImage getImageFromArray( int[] pixels, int width )
+    {
+        int height = width;
+        BufferedImage tmpImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB_PRE);
+        tmpImage.setRGB(0, 0, width, height, pixels, 0, width);
+        return tmpImage;
+    }
+
+    @Override
+    public String toString()
+    {
+        return minLat + "," + minLon;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
new file mode 100644
index 0000000000..8570012140
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -0,0 +1,334 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.*;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import gnu.trove.map.hash.TIntObjectHashMap;
+import java.io.*;
+import java.net.SocketTimeoutException;
+import java.util.zip.ZipInputStream;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Elevation data from NASA (SRTM). Downloaded from http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/
+ * <p>
+ * Important information about SRTM: the coordinates of the lower-left corner of tile N40W118 are 40
+ * degrees north latitude and 118 degrees west longitude. To be more exact, these coordinates refer
+ * to the geometric center of the lower left sample, which in the case of SRTM3 data will be about
+ * 90 meters in extent.
+ * <p>
+ * @author Peter Karich
+ */
+public class SRTMProvider implements ElevationProvider
+{
+    public static void main( String[] args ) throws IOException
+    {
+        SRTMProvider provider = new SRTMProvider();
+        // 1046
+        System.out.println(provider.getEle(47.468668, 14.575127));
+        // 1113
+        System.out.println(provider.getEle(47.467753, 14.573911));
+
+        // 1946
+        System.out.println(provider.getEle(46.468835, 12.578777));
+
+        // 845
+        System.out.println(provider.getEle(48.469123, 9.576393));
+
+        // 1113 vs new: 
+        provider.setCalcMean(true);
+        System.out.println(provider.getEle(47.467753, 14.573911));
+    }
+
+    private static final BitUtil BIT_UTIL = BitUtil.BIG;
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final int WIDTH = 1201;
+    private Directory dir;
+    private DAType daType = DAType.MMAP;
+    private Downloader downloader = new Downloader("GraphHopper SRTMReader").setTimeout(10000);
+    private File cacheDir = new File("/tmp/srtm");
+    // use a map as an array is not quite useful if we want to hold only parts of the world
+    private final TIntObjectHashMap<HeightTile> cacheData = new TIntObjectHashMap<HeightTile>();
+    private final TIntObjectHashMap<String> areas = new TIntObjectHashMap<String>();
+    private final double precision = 1e7;
+    private final double invPrecision = 1 / precision;
+    // mirror: base = "http://mirror.ufs.ac.za/datasets/SRTM3/"
+    private String baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
+    private boolean calcMean = false;
+
+    public SRTMProvider()
+    {
+        // move to explicit calls?
+        init();
+    }
+
+    @Override
+    public void setCalcMean( boolean calcMean )
+    {
+        this.calcMean = calcMean;
+    }
+
+    /**
+     * The URLs are a bit ugly and so we need to find out which area name a certain lat,lon
+     * coordinate has.
+     */
+    private SRTMProvider init()
+    {
+        try
+        {
+            String strs[] =
+            {
+                "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
+            };
+            for (String str : strs)
+            {
+                InputStream is = getClass().getResourceAsStream(str + "_names.txt.zip");
+                ZipInputStream zis = new ZipInputStream(is);
+                zis.getNextEntry();
+                for (String line : Helper.readFile(new InputStreamReader(zis, Helper.UTF_CS)))
+                {
+                    int lat = Integer.parseInt(line.substring(1, 3));
+                    if (line.substring(0, 1).charAt(0) == 'S')
+                        lat = -lat;
+
+                    int lon = Integer.parseInt(line.substring(4, 7));
+                    if (line.substring(3, 4).charAt(0) == 'W')
+                        lon = -lon;
+
+                    int intKey = calcIntKey(lat, lon);
+                    String key = areas.put(intKey, str);
+                    if (key != null)
+                        throw new IllegalStateException("do not overwrite existing! key " + intKey + " " + key + " vs. " + str);
+                }
+            }
+            return this;
+        } catch (Exception ex)
+        {
+            throw new IllegalStateException("Cannot load area names from classpath", ex);
+        }
+    }
+
+    // use int key instead of string for lower memory usage
+    private int calcIntKey( double lat, double lon )
+    {
+        // we could use LinearKeyAlgo but this is simpler as we only need integer precision:
+        return (down(lat) + 90) * 1000 + down(lon) + 180;
+    }
+
+    public void setDownloader( Downloader downloader )
+    {
+        this.downloader = downloader;
+    }
+
+    @Override
+    public ElevationProvider setCacheDir( File cacheDir )
+    {
+        if (cacheDir.exists() && !cacheDir.isDirectory())
+            throw new IllegalArgumentException("Cache path has to be a directory");
+
+        try
+        {
+            this.cacheDir = cacheDir.getCanonicalFile();
+        } catch (IOException ex)
+        {
+            throw new RuntimeException(ex);
+        }
+        return this;
+    }
+
+    @Override
+    public ElevationProvider setBaseURL( String baseUrl )
+    {
+        if (baseUrl == null || baseUrl.isEmpty())
+            throw new IllegalArgumentException("baseUrl cannot be empty");
+
+        this.baseUrl = baseUrl;
+        return this;
+    }
+
+    @Override
+    public ElevationProvider setDAType( DAType daType )
+    {
+        this.daType = daType;
+        return this;
+    }
+
+    int down( double val )
+    {
+        int intVal = (int) val;
+        if (val >= 0 || intVal - val < invPrecision)
+            return intVal;
+        return intVal - 1;
+    }
+
+    String getFileString( double lat, double lon )
+    {
+        int intKey = calcIntKey(lat, lon);
+        String str = areas.get(intKey);
+        if (str == null)
+            return null;
+
+        int minLat = Math.abs(down(lat));
+        int minLon = Math.abs(down(lon));
+        str += "/";
+        if (lat >= 0)
+            str += "N";
+        else
+            str += "S";
+
+        if (minLat < 10)
+            str += "0";
+        str += minLat;
+
+        if (lon >= 0)
+            str += "E";
+        else
+            str += "W";
+
+        if (minLon < 10)
+            str += "0";
+        if (minLon < 100)
+            str += "0";
+        str += minLon;
+        return str;
+    }
+
+    @Override
+    public double getEle( double lat, double lon )
+    {
+        lat = (int) (lat * precision) / precision;
+        lon = (int) (lon * precision) / precision;
+        int intKey = calcIntKey(lat, lon);
+        HeightTile demProvider = cacheData.get(intKey);
+        if (demProvider == null)
+        {
+            if (!cacheDir.exists())
+                cacheDir.mkdirs();
+
+            String fileDetails = getFileString(lat, lon);
+            if (fileDetails == null)
+                return 0;
+
+            int minLat = down(lat);
+            int minLon = down(lon);
+            demProvider = new HeightTile(minLat, minLon, WIDTH, precision, 1);
+            demProvider.setCalcMean(calcMean);
+            cacheData.put(intKey, demProvider);
+            DataAccess heights = getDirectory().find("dem" + intKey);
+            demProvider.setHeights(heights);
+            boolean loadExisting = false;
+            try
+            {
+                loadExisting = heights.loadExisting();
+            } catch (Exception ex)
+            {
+                logger.warn("cannot load dem" + intKey + ", error:" + ex.getMessage());
+            }
+
+            if (!loadExisting)
+            {
+                byte[] bytes = new byte[2 * WIDTH * WIDTH];
+                heights.create(bytes.length);
+                try
+                {
+                    String zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
+                    File file = new File(cacheDir, new File(zippedURL).getName());
+                    InputStream is;
+                    // get zip file if not already in cacheDir - unzip later and in-memory only!
+                    if (!file.exists())
+                    {
+                        for (int i = 0; i < 3; i++)
+                        {
+                            try
+                            {
+                                downloader.downloadFile(zippedURL, file.getAbsolutePath());
+                                break;
+                            } catch (SocketTimeoutException ex)
+                            {
+                                // just try again after a little nap
+                                Thread.sleep(2000);
+                                continue;
+                            } catch (FileNotFoundException ex)
+                            {
+                                // now try different URL (with point!), necessary if mirror is used
+                                zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
+                                continue;
+                            }
+                        }
+                    }
+
+                    is = new FileInputStream(file);
+                    ZipInputStream zis = new ZipInputStream(is);
+                    zis.getNextEntry();
+                    BufferedInputStream buff = new BufferedInputStream(zis);
+                    int len;
+                    while ((len = buff.read(bytes)) > 0)
+                    {
+                        for (int bytePos = 0; bytePos < len; bytePos += 2)
+                        {
+                            short val = BIT_UTIL.toShort(bytes, bytePos);
+                            if (val < -1000 || val > 12000)
+                                val = Short.MIN_VALUE;
+
+                            heights.setShort(bytePos, val);
+                        }
+                    }
+                    heights.flush();
+
+                    // demProvider.toImage("x" + file.getName() + ".png");
+                    // TODO remove hgt and zip?
+                } catch (Exception ex)
+                {
+                    throw new RuntimeException(ex);
+                }
+            } // loadExisting
+        }
+
+        return demProvider.getHeight(lat, lon);
+    }
+
+    @Override
+    public void release()
+    {
+        cacheData.clear();
+
+        // for memory mapped type we create temporary unpacked files which should be removed
+        if (dir != null)
+            dir.clear();
+    }
+
+    @Override
+    public String toString()
+    {
+        return "SRTM";
+    }
+
+    private Directory getDirectory()
+    {
+        if (dir != null)
+            return dir;
+
+        logger.info(this.toString() + " Elevation Provider, from: " + baseUrl + ", to: " + cacheDir + ", as: " + daType);
+        return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
index 45c3bec911..58ab2d598c 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoder.java
@@ -26,11 +26,11 @@
  */
 public class PbfBlobDecoder implements Runnable
 {
-    private static Logger log = LoggerFactory.getLogger(PbfBlobDecoder.class);
+    private static final Logger log = LoggerFactory.getLogger(PbfBlobDecoder.class);
     private final boolean checkData = false;
-    private String blobType;
-    private byte[] rawBlob;
-    private PbfBlobDecoderListener listener;
+    private final String blobType;
+    private final byte[] rawBlob;
+    private final PbfBlobDecoderListener listener;
     private List<OSMElement> decodedEntities;
 
     /**
@@ -158,8 +158,9 @@ private void processNodes( List<Osmformat.Node> nodes, PbfFieldDecoder fieldDeco
         {
             Map<String, String> tags = buildTags(node.getKeysList(), node.getValsList(), fieldDecoder);
 
-            OSMNode osmNode = new OSMNode(node.getId(), tags, fieldDecoder.decodeLatitude(node
+            OSMNode osmNode = new OSMNode(node.getId(), fieldDecoder.decodeLatitude(node
                     .getLat()), fieldDecoder.decodeLatitude(node.getLon()));
+            osmNode.setTags(tags);
 
             // Add the bound object to the results.
             decodedEntities.add(osmNode);
@@ -258,7 +259,8 @@ private void processNodes( Osmformat.DenseNodes nodes, PbfFieldDecoder fieldDeco
                 tags.put(fieldDecoder.decodeString(keyIndex), fieldDecoder.decodeString(valueIndex));
             }
 
-            OSMNode node = new OSMNode(nodeId, tags, ((double) latitude) / 10000000, ((double) longitude) / 10000000);
+            OSMNode node = new OSMNode(nodeId, ((double) latitude) / 10000000, ((double) longitude) / 10000000);
+            node.setTags(tags);
 
             // Add the bound object to the results.
             decodedEntities.add(node);
@@ -270,8 +272,8 @@ private void processWays( List<Osmformat.Way> ways, PbfFieldDecoder fieldDecoder
         for (Osmformat.Way way : ways)
         {
             Map<String, String> tags = buildTags(way.getKeysList(), way.getValsList(), fieldDecoder);
-
-            OSMWay osmWay = new OSMWay(way.getId(), tags);
+            OSMWay osmWay = new OSMWay(way.getId());
+            osmWay.setTags(tags);
 
             // Build up the list of way nodes for the way. The node ids are
             // delta encoded meaning that each id is stored as a delta against
@@ -346,7 +348,8 @@ private void processRelations( List<Osmformat.Relation> relations, PbfFieldDecod
         {
             Map<String, String> tags = buildTags(relation.getKeysList(), relation.getValsList(), fieldDecoder);
 
-            OSMRelation osmRelation = new OSMRelation(relation.getId(), tags);
+            OSMRelation osmRelation = new OSMRelation(relation.getId());
+            osmRelation.setTags(tags);
 
             buildRelationMembers(osmRelation, relation.getMemidsList(), relation.getRolesSidList(),
                     relation.getTypesList(), fieldDecoder);
@@ -405,7 +408,7 @@ public void run()
 
         } catch (RuntimeException e)
         {
-            listener.error();
+            listener.error(e);
         }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoderListener.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoderListener.java
index d5e0c418cb..cd4c6eca52 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoderListener.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobDecoderListener.java
@@ -22,5 +22,5 @@
     /**
      * Notifies the listener that an error occurred during processing.
      */
-    void error();
+    void error( Exception ex );
 }
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobResult.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobResult.java
index 046de3ea2e..e119944e7e 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobResult.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfBlobResult.java
@@ -15,6 +15,7 @@
     private List<OSMElement> entities;
     private boolean complete;
     private boolean success;
+    private Exception ex;
 
     /**
      * Creates a new instance.
@@ -23,6 +24,7 @@ public PbfBlobResult()
     {
         complete = false;
         success = false;
+        ex = new RuntimeException("no success result stored");
     }
 
     /**
@@ -40,10 +42,11 @@ public void storeSuccessResult( List<OSMElement> decodedEntities )
     /**
      * Stores a failure result for a blob decoding operation.
      */
-    public void storeFailureResult()
+    public void storeFailureResult( Exception ex )
     {
         complete = true;
         success = false;
+        this.ex = ex;
     }
 
     /**
@@ -66,6 +69,11 @@ public boolean isSuccess()
         return success;
     }
 
+    public Exception getException()
+    {
+        return ex;
+    }
+
     /**
      * Gets the entities decoded from the blob. This is only valid after complete becomes true, and
      * if success is true.
diff --git a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
index 050a64d6de..421979704f 100644
--- a/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
+++ b/core/src/main/java/com/graphhopper/reader/pbf/PbfDecoder.java
@@ -20,13 +20,13 @@
  */
 public class PbfDecoder implements Runnable
 {
-    private PbfStreamSplitter streamSplitter;
-    private ExecutorService executorService;
-    private int maxPendingBlobs;
-    private Sink sink;
-    private Lock lock;
-    private Condition dataWaitCondition;
-    private Queue<PbfBlobResult> blobResults;
+    private final PbfStreamSplitter streamSplitter;
+    private final ExecutorService executorService;
+    private final int maxPendingBlobs;
+    private final Sink sink;
+    private final Lock lock;
+    private final Condition dataWaitCondition;
+    private final Queue<PbfBlobResult> blobResults;
 
     /**
      * Creates a new instance.
@@ -92,7 +92,7 @@ private void sendResultsToSink( int targetQueueSize )
 
             if (!blobResult.isSuccess())
             {
-                throw new RuntimeException("A PBF decoding worker thread failed, aborting.");
+                throw new RuntimeException("A PBF decoding worker thread failed, aborting.", blobResult.getException());
             }
 
             // Send the processed entities to the sink. We can release the lock
@@ -130,13 +130,13 @@ private void processBlobs()
             PbfBlobDecoderListener decoderListener = new PbfBlobDecoderListener()
             {
                 @Override
-                public void error()
+                public void error( Exception ex )
                 {
                     lock.lock();
                     try
                     {
-                        System.out.println("ERROR: " + new Date());
-                        blobResult.storeFailureResult();
+                        // System.out.println("ERROR: " + new Date());
+                        blobResult.storeFailureResult(ex);
                         signalUpdate();
 
                     } finally
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 1365968f61..56ba796d60 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -17,14 +17,21 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.util.DistancePlaneProjection;
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.util.PriorityQueue;
+
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.routing.util.BeelineWeightApproximator;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.*;
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-import java.util.PriorityQueue;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
 
 /**
  * This class implements the A* algorithm according to
@@ -36,32 +43,28 @@
  */
 public class AStar extends AbstractRoutingAlgorithm
 {
-    private DistanceCalc dist;
+    private WeightApproximator weightApprox;
     private int visitedCount;
     private TIntObjectMap<AStarEdge> fromMap;
     private PriorityQueue<AStarEdge> prioQueueOpenSet;
     private AStarEdge currEdge;
     private int to1 = -1;
-    private double toLat;
-    private double toLon;
 
-    public AStar( Graph g, FlagEncoder encoder, Weighting weighting )
+    public AStar( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(g, encoder, weighting);
+        super(g, encoder, weighting, tMode);
         initCollections(1000);
-        setApproximation(true);
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     /**
-     * @param approx if true it enables an approximative distance calculation from lat,lon values
+     * @param approx defines how distance to goal Node is approximated
      */
-    public AStar setApproximation( boolean approx )
+    public AStar setApproximation( WeightApproximator approx )
     {
-        if (approx)
-            dist = new DistancePlaneProjection();
-        else
-            dist = new DistanceCalcEarth();
-
+        weightApprox = approx;
         return this;
     }
 
@@ -75,57 +78,66 @@ protected void initCollections( int size )
     public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
-        toLat = graph.getLatitude(to);
-        toLon = graph.getLongitude(to);
         to1 = to;
+        weightApprox.setGoalNode(to);
         currEdge = createEdgeEntry(from, 0);
-        fromMap.put(from, currEdge);
+        if (!traversalMode.isEdgeBased())
+        {
+            fromMap.put(from, currEdge);
+        }
         return runAlgo();
     }
 
     private Path runAlgo()
     {
-        double currWeightToGoal, distEstimation, tmpLat, tmpLon;
+        double currWeightToGoal, distEstimation;
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
-            int currVertex = currEdge.endNode;
+            int currVertex = currEdge.adjNode;
             visitedCount++;
+            if (isWeightLimitReached())
+                return createEmptyPath();
+
             if (finished())
                 break;
 
             EdgeIterator iter = explorer.setBaseNode(currVertex);
             while (iter.next())
             {
-                if (!accept(iter))
-                    continue;
-                if (currEdge.edge == iter.getEdge())
+                if (!accept(iter, currEdge.edge))
                     continue;
 
                 int neighborNode = iter.getAdjNode();
-                double alreadyVisitedWeight = weighting.calcWeight(iter) + currEdge.weightToCompare;
-                AStarEdge nEdge = fromMap.get(neighborNode);
-                if (nEdge == null || nEdge.weightToCompare > alreadyVisitedWeight)
+                int traversalId = traversalMode.createTraversalId(iter, false);
+                // cast to float to avoid rounding errors in comparison to float entry of AStarEdge weight
+                float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, false, currEdge.edge)
+                        + currEdge.weightOfVisitedPath);
+                if (Double.isInfinite(alreadyVisitedWeight))
+                    continue;
+
+                AStarEdge ase = fromMap.get(traversalId);
+                if ((ase == null) || ase.weightOfVisitedPath > alreadyVisitedWeight)
                 {
-                    tmpLat = graph.getLatitude(neighborNode);
-                    tmpLon = graph.getLongitude(neighborNode);
-                    currWeightToGoal = dist.calcDist(toLat, toLon, tmpLat, tmpLon);
-                    currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                    currWeightToGoal = weightApprox.approximate(neighborNode);
                     distEstimation = alreadyVisitedWeight + currWeightToGoal;
-                    if (nEdge == null)
+                    if (ase == null)
                     {
-                        nEdge = new AStarEdge(iter.getEdge(), neighborNode, distEstimation, alreadyVisitedWeight);
-                        fromMap.put(neighborNode, nEdge);
+                        ase = new AStarEdge(iter.getEdge(), neighborNode, distEstimation, alreadyVisitedWeight);
+                        fromMap.put(traversalId, ase);
                     } else
                     {
-                        prioQueueOpenSet.remove(nEdge);
-                        nEdge.edge = iter.getEdge();
-                        nEdge.weight = distEstimation;
-                        nEdge.weightToCompare = alreadyVisitedWeight;
+                        assert (ase.weight > distEstimation) : "Inconsistent distance estimate";
+                        prioQueueOpenSet.remove(ase);
+                        ase.edge = iter.getEdge();
+                        ase.weight = distEstimation;
+                        ase.weightOfVisitedPath = alreadyVisitedWeight;
                     }
-                    nEdge.parent = currEdge;
-                    prioQueueOpenSet.add(nEdge);
-                    updateShortest(nEdge, neighborNode);
+
+                    ase.parent = currEdge;
+                    prioQueueOpenSet.add(ase);
+
+                    updateBestPath(iter, ase, traversalId);
                 }
             }
 
@@ -143,7 +155,7 @@ private Path runAlgo()
     @Override
     protected Path extractPath()
     {
-        return new Path(graph, flagEncoder).setEdgeEntry(currEdge).extract();
+        return new Path(graph, flagEncoder).setWeight(currEdge.weight).setEdgeEntry(currEdge).extract();
     }
 
     @Override
@@ -155,7 +167,7 @@ protected AStarEdge createEdgeEntry( int node, double dist )
     @Override
     protected boolean finished()
     {
-        return currEdge.endNode == to1;
+        return currEdge.adjNode == to1;
     }
 
     @Override
@@ -164,23 +176,27 @@ public int getVisitedNodes()
         return visitedCount;
     }
 
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
+    }
+
     public static class AStarEdge extends EdgeEntry
     {
         // the variable 'weight' is used to let heap select smallest *full* distance.
         // but to compare distance we need it only from start:
-        double weightToCompare;
+        double weightOfVisitedPath;
 
-        public AStarEdge( int edgeId, int node, double weightForHeap, double weightToCompare )
+        public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightOfVisitedPath )
         {
-            super(edgeId, node, weightForHeap);
-            // round makes distance smaller => heuristic should underestimate the distance!
-            this.weightToCompare = (float) weightToCompare;
+            super(edgeId, adjNode, weightForHeap);
+            this.weightOfVisitedPath = (float) weightOfVisitedPath;
         }
     }
 
     @Override
     public String getName()
     {
-        return "astar";
+        return AlgorithmOptions.ASTAR;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index c47b606685..f8a92e1bf3 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -17,35 +17,27 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.AStar.AStarEdge;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.shapes.CoordTrig;
-import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.routing.util.*;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
+
 import java.util.PriorityQueue;
 
+import com.graphhopper.routing.AStar.AStarEdge;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.util.*;
+
 /**
  * This class implements a bidirectional A* algorithm. It is interesting to note that a
  * bidirectional dijkstra is far more efficient than a single direction one. The same does not hold
- * for a bidirectional A* as the finish condition can not be so strict which leads to either
- * suboptimal paths or suboptimal node exploration (too many nodes). Still very good approximations
- * with a rougly twice times faster running time than the normal A* can be reached.
+ * for a bidirectional A* as the heuristic can not be as tight.
  * <p/>
- * Computing the Shortest Path: A∗ Search Meets Graph Theory ->
- * http://research.microsoft.com/apps/pubs/default.aspx?id=64511
+ * See http://research.microsoft.com/apps/pubs/default.aspx?id=64511
  * http://i11www.iti.uni-karlsruhe.de/_media/teaching/sommer2012/routenplanung/vorlesung4.pdf
  * http://research.microsoft.com/pubs/64504/goldberg-sofsem07.pdf
  * http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
  * <p/>
- * better stop condition
+ * and
  * <p/>
  * 1. Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
@@ -58,10 +50,11 @@
  * www.lix.polytechnique.fr/~giacomon/papers/bidirtimedep.pdf
  * <p/>
  * @author Peter Karich
+ * @author jansoe
  */
 public class AStarBidirection extends AbstractBidirAlgo
 {
-    private DistanceCalc dist;
+    private ConsistentWeightApproximator weightApprox;
     private PriorityQueue<AStarEdge> prioQueueOpenSetFrom;
     private TIntObjectMap<AStarEdge> bestWeightMapFrom;
     private PriorityQueue<AStarEdge> prioQueueOpenSetTo;
@@ -69,19 +62,16 @@
     private TIntObjectMap<AStarEdge> bestWeightMapOther;
     protected AStarEdge currFrom;
     protected AStarEdge currTo;
-    protected double approximationFactor;
-    private CoordTrig fromCoord;
-    private CoordTrig toCoord;
     protected PathBidirRef bestPath;
 
-    public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
         int nodes = Math.max(20, graph.getNodes());
         initCollections(nodes);
-
-        // different default value for approximation than AStar
-        setApproximation(false);
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     protected void initCollections( int size )
@@ -96,26 +86,9 @@ protected void initCollections( int size )
     /**
      * @param approx if true it enables approximative distance calculation from lat,lon values
      */
-    public AStarBidirection setApproximation( boolean approx )
-    {
-        if (approx)
-        {
-            dist = new DistancePlaneProjection();
-            approximationFactor = 0.5;
-        } else
-        {
-            dist = new DistanceCalcEarth();
-            approximationFactor = 1.2;
-        }
-        return this;
-    }
-
-    /**
-     * Specify a low value like 0.5 for worse but faster results. Or over 1.1 for more precise.
-     */
-    public AStarBidirection setApproximationFactor( double approxFactor )
+    public AStarBidirection setApproximation( WeightApproximator approx )
     {
-        this.approximationFactor = approxFactor;
+        weightApprox = new ConsistentWeightApproximator(approx);
         return this;
     }
 
@@ -129,13 +102,26 @@ protected AStarEdge createEdgeEntry( int node, double dist )
     public void initFrom( int from, double dist )
     {
         currFrom = createEdgeEntry(from, dist);
-        bestWeightMapFrom.put(from, currFrom);
+        weightApprox.setSourceNode(from);
         prioQueueOpenSetFrom.add(currFrom);
-        fromCoord = new GHPoint(graph.getLatitude(from), graph.getLongitude(from));
-        if (currTo != null)
+        if (!traversalMode.isEdgeBased())
         {
-            bestWeightMapOther = bestWeightMapTo;
-            updateShortest(currTo, from);
+            bestWeightMapFrom.put(from, currFrom);
+            if (currTo != null)
+            {
+                bestWeightMapOther = bestWeightMapTo;
+                updateBestPath(GHUtility.getEdge(graph, from, currTo.adjNode), currTo, from);
+            }
+        } else
+        {
+            if (currTo != null && currTo.adjNode == from)
+            {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
+                finishedFrom = true;
+                finishedTo = true;
+            }
         }
     }
 
@@ -143,25 +129,42 @@ public void initFrom( int from, double dist )
     public void initTo( int to, double dist )
     {
         currTo = createEdgeEntry(to, dist);
-        bestWeightMapTo.put(to, currTo);
+        weightApprox.setGoalNode(to);
         prioQueueOpenSetTo.add(currTo);
-        toCoord = new GHPoint(graph.getLatitude(to), graph.getLongitude(to));
-        if (currFrom != null)
+        if (!traversalMode.isEdgeBased())
+        {
+            bestWeightMapTo.put(to, currTo);
+            if (currFrom != null)
+            {
+                bestWeightMapOther = bestWeightMapFrom;
+                updateBestPath(GHUtility.getEdge(graph, currFrom.adjNode, to), currFrom, to);
+            }
+        } else
         {
-            bestWeightMapOther = bestWeightMapFrom;
-            updateShortest(currFrom, to);
+            if (currFrom != null && currFrom.adjNode == to)
+            {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
+                finishedFrom = true;
+                finishedTo = true;
+            }
         }
     }
 
     @Override
-    protected void initPath()
+    protected Path createAndInitPath()
     {
         bestPath = new PathBidirRef(graph, flagEncoder);
+        return bestPath;
     }
 
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -172,17 +175,19 @@ void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
             throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
     }
 
-    // Problem is the correct finish condition! if the bounds are too wide too many nodes are visited :/   
-    // d_f (v) + (v, w) + d_r (w) < μ + p_r(t)
-    // where pi_r_of_t = p_r(t) = 1/2(pi_r(t) - pi_f(t) + pi_f(s)), and pi_f(t)=0
     @Override
     protected boolean finished()
     {
         if (finishedFrom || finishedTo)
             return true;
 
-        double tmp = bestPath.getWeight() * approximationFactor;
-        return currFrom.weightToCompare + currTo.weightToCompare >= tmp;
+        return currFrom.weight + currTo.weight >= bestPath.getWeight();
+    }
+
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
     }
 
     @Override
@@ -193,8 +198,8 @@ boolean fillEdgesFrom()
 
         currFrom = prioQueueOpenSetFrom.poll();
         bestWeightMapOther = bestWeightMapTo;
-        fillEdges(currFrom, toCoord, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer);
-        visitedFromCount++;
+        fillEdges(currFrom, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
+        visitedCountFrom++;
         return true;
     }
 
@@ -206,77 +211,96 @@ boolean fillEdgesTo()
 
         currTo = prioQueueOpenSetTo.poll();
         bestWeightMapOther = bestWeightMapFrom;
-        fillEdges(currTo, fromCoord, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer);
-        visitedToCount++;
+        fillEdges(currTo, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
+        visitedCountTo++;
         return true;
     }
 
-    private void fillEdges( AStarEdge currEdge, CoordTrig goal,
-            PriorityQueue<AStarEdge> prioQueueOpenSet,
-            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer )
+    private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOpenSet,
+            TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
 
-        int currNode = currEdge.endNode;
+        int currNode = currEdge.adjNode;
         EdgeIterator iter = explorer.setBaseNode(currNode);
         while (iter.next())
         {
-            if (!accept(iter))
-                continue;
-            if (currEdge.edge == iter.getEdge())
+            if (!accept(iter, currEdge.edge))
                 continue;
 
             int neighborNode = iter.getAdjNode();
+            int traversalId = traversalMode.createTraversalId(iter, reverse);
             // TODO performance: check if the node is already existent in the opposite direction
             // then we could avoid the approximation as we already know the exact complete path!
-            double alreadyVisitedWeight = weighting.calcWeight(iter) + currEdge.weightToCompare;
-            AStarEdge de = shortestWeightMap.get(neighborNode);
-            if (de == null || de.weightToCompare > alreadyVisitedWeight)
+            float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, reverse, currEdge.edge)
+                    + currEdge.weightOfVisitedPath);
+            if (Double.isInfinite(alreadyVisitedWeight))
+                continue;
+
+            AStarEdge ase = shortestWeightMap.get(traversalId);
+            if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
             {
-                double tmpLat = graph.getLatitude(neighborNode);
-                double tmpLon = graph.getLongitude(neighborNode);
-                double currWeightToGoal = dist.calcDist(goal.lat, goal.lon, tmpLat, tmpLon);
-                currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                double currWeightToGoal = weightApprox.approximate(neighborNode, reverse);
                 double estimationFullDist = alreadyVisitedWeight + currWeightToGoal;
-                if (de == null)
+                if (ase == null)
                 {
-                    de = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
-                    shortestWeightMap.put(neighborNode, de);
+                    ase = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
+                    shortestWeightMap.put(traversalId, ase);
                 } else
                 {
-                    prioQueueOpenSet.remove(de);
-                    de.edge = iter.getEdge();
-                    de.weight = estimationFullDist;
-                    de.weightToCompare = alreadyVisitedWeight;
+                    assert (ase.weight > estimationFullDist) : "Inconsistent distance estimate";
+                    prioQueueOpenSet.remove(ase);
+                    ase.edge = iter.getEdge();
+                    ase.weight = estimationFullDist;
+                    ase.weightOfVisitedPath = alreadyVisitedWeight;
                 }
 
-                de.parent = currEdge;
-                prioQueueOpenSet.add(de);
-                updateShortest(de, neighborNode);
+                ase.parent = currEdge;
+                prioQueueOpenSet.add(ase);
+                updateBestPath(iter, ase, traversalId);
             }
         }
     }
 
 //    @Override -> TODO use only weight => then a simple EdgeEntry is possible
-    public void updateShortest( AStarEdge shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent, int currLoc )
     {
         AStarEdge entryOther = bestWeightMapOther.get(currLoc);
         if (entryOther == null)
             return;
 
+        boolean reverse = bestWeightMapFrom == bestWeightMapOther;
         // update μ
-        double newShortest = shortestDE.weightToCompare + entryOther.weightToCompare;
-        if (newShortest < bestPath.getWeight())
+        double newWeight = entryCurrent.weightOfVisitedPath + entryOther.weightOfVisitedPath;
+        if (traversalMode.isEdgeBased())
+        {
+            if (entryOther.edge != entryCurrent.edge)
+                throw new IllegalStateException("cannot happen for edge based execution of " + getName());
+
+            // see DijkstraBidirectionRef
+            if (entryOther.adjNode != entryCurrent.adjNode)
+            {
+                entryCurrent = (AStar.AStarEdge) entryCurrent.parent;
+                newWeight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
+            } else
+            {
+                // we detected a u-turn at meeting point, skip if not supported
+                if (!traversalMode.hasUTurnSupport())
+                    return;
+            }
+        }
+
+        if (newWeight < bestPath.getWeight())
         {
-            bestPath.setSwitchToFrom(bestWeightMapFrom == bestWeightMapOther);
-            bestPath.edgeEntry = shortestDE;
+            bestPath.setSwitchToFrom(reverse);
+            bestPath.edgeEntry = entryCurrent;
             bestPath.edgeTo = entryOther;
-            bestPath.setWeight(newShortest);
+            bestPath.setWeight(newWeight);
         }
     }
 
     @Override
     public String getName()
     {
-        return "astarbi";
+        return AlgorithmOptions.ASTAR_BI;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index 3367e3d0df..2a047c7434 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 
@@ -28,16 +29,18 @@
  */
 public abstract class AbstractBidirAlgo extends AbstractRoutingAlgorithm
 {
-    int visitedFromCount;
-    int visitedToCount;
+    int visitedCountFrom;
+    int visitedCountTo;
     protected boolean finishedFrom;
     protected boolean finishedTo;
 
-    public abstract void initFrom( int from, double dist );
+    abstract void initFrom( int from, double dist );
 
-    public abstract void initTo( int to, double dist );
+    abstract void initTo( int to, double dist );
 
-    protected abstract void initPath();
+    protected abstract Path createAndInitPath();
+
+    protected abstract boolean isWeightLimitReached();
 
     abstract void checkState( int fromBase, int fromAdj, int toBase, int toAdj );
 
@@ -45,24 +48,25 @@
 
     abstract boolean fillEdgesTo();
 
-    public AbstractBidirAlgo( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public AbstractBidirAlgo( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
     }
 
     @Override
     public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
-        initPath();
+        createAndInitPath();
         initFrom(from, 0);
         initTo(to, 0);
-        return runAlgo();
+        runAlgo();
+        return extractPath();
     }
 
-    private Path runAlgo()
+    protected void runAlgo()
     {
-        while (!finished())
+        while (!finished() && !isWeightLimitReached())
         {
             if (!finishedFrom)
                 finishedFrom = !fillEdgesFrom();
@@ -70,13 +74,11 @@ private Path runAlgo()
             if (!finishedTo)
                 finishedTo = !fillEdgesTo();
         }
-
-        return extractPath();
     }
 
     @Override
     public int getVisitedNodes()
     {
-        return visitedFromCount + visitedToCount;
+        return visitedCountFrom + visitedCountTo;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 68c9af74c9..62349b3d81 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -17,17 +17,13 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import java.util.ArrayList;
-import java.util.List;
+import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * @author Peter Karich
@@ -35,66 +31,54 @@
 public abstract class AbstractRoutingAlgorithm implements RoutingAlgorithm
 {
     private EdgeFilter additionalEdgeFilter;
-    protected Graph graph;
+    protected final Graph graph;
+    protected NodeAccess nodeAccess;
     protected EdgeExplorer inEdgeExplorer;
     protected EdgeExplorer outEdgeExplorer;
     protected final Weighting weighting;
     protected final FlagEncoder flagEncoder;
+    protected final TraversalMode traversalMode;
+    protected double weightLimit = Double.MAX_VALUE;
     private boolean alreadyRun;
 
     /**
      * @param graph specifies the graph where this algorithm will run on
      * @param encoder sets the used vehicle (bike, car, foot)
      * @param weighting set the used weight calculation (e.g. fastest, shortest).
+     * @param traversalMode how the graph is traversed e.g. if via nodes or edges.
      */
-    public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
     {
         this.weighting = weighting;
         this.flagEncoder = encoder;
-        setGraph(graph);
-    }
-
-    /**
-     * Specify the graph on which this algorithm should operate. API glitch: this method overwrites
-     * graph specified while constructing the algorithm. Only necessary if graph is a QueryGraph.
-     */
-    protected RoutingAlgorithm setGraph( Graph graph )
-    {
+        this.traversalMode = traversalMode;
         this.graph = graph;
+        this.nodeAccess = graph.getNodeAccess();
         outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, false, true));
         inEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, true, false));
-        return this;
-    }
-
-    protected QueryGraph createQueryGraph()
-    {
-        return new QueryGraph(graph);
     }
 
     @Override
-    public Path calcPath( QueryResult fromRes, QueryResult toRes )
+    public void setWeightLimit( double weight )
     {
-        QueryGraph queryGraph = createQueryGraph();
-        List<QueryResult> results = new ArrayList<QueryResult>(2);
-        results.add(fromRes);
-        results.add(toRes);
-        queryGraph.lookup(results);
-        setGraph(queryGraph);
-        return calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
+        this.weightLimit = weight;
     }
-
+       
     public RoutingAlgorithm setEdgeFilter( EdgeFilter additionalEdgeFilter )
     {
         this.additionalEdgeFilter = additionalEdgeFilter;
         return this;
     }
 
-    protected boolean accept( EdgeIterator iter )
+    protected boolean accept( EdgeIterator iter, int prevOrNextEdgeId )
     {
+        if (!traversalMode.hasUTurnSupport() && iter.getEdge() == prevOrNextEdgeId)
+            return false;
+
         return additionalEdgeFilter == null || additionalEdgeFilter.accept(iter);
     }
 
-    protected void updateShortest( EdgeEntry shortestDE, int currLoc )
+    protected void updateBestPath( EdgeIteratorState edgeState, EdgeEntry bestEdgeEntry, int traversalId )
     {
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
new file mode 100644
index 0000000000..6cd1313e15
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
@@ -0,0 +1,194 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.util.PMap;
+
+/**
+ * The algorithm options. Create an immutable object via:
+ * <pre>
+ * AlgorithmOptions algoOpts = AlgorithmOptions.start().
+ *        algorithm(AlgorithmOptions.DIJKSTRA).
+ *        weighting(weighting).
+ *        build();
+ * </pre>
+ * <p>
+ * @author Peter Karich
+ */
+public class AlgorithmOptions
+{
+    /**
+     * Bidirectional Dijkstra
+     */
+    public static final String DIJKSTRA_BI = "dijkstrabi";
+    /**
+     * Unidirectional Dijkstra
+     */
+    public static final String DIJKSTRA = "dijkstra";
+    /**
+     * one to many Dijkstra
+     */
+    public static final String DIJKSTRA_ONE_TO_MANY = "dijkstraOneToMany";
+    /**
+     * Unidirectional A*
+     */
+    public static final String ASTAR = "astar";
+    /**
+     * Bidirectional A*
+     */
+    public static final String ASTAR_BI = "astarbi";
+    private String algorithm = DIJKSTRA_BI;
+    private Weighting weighting;
+    private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private FlagEncoder flagEncoder;
+    private final PMap hints = new PMap(5);
+
+    private AlgorithmOptions()
+    {
+    }
+
+    /**
+     * Default traversal mode NODE_BASED is used.
+     */
+    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting )
+    {
+        this.algorithm = algorithm;
+        this.weighting = weighting;
+        this.flagEncoder = flagEncoder;
+    }
+
+    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting, TraversalMode tMode )
+    {
+        this.algorithm = algorithm;
+        this.weighting = weighting;
+        this.flagEncoder = flagEncoder;
+        this.traversalMode = tMode;
+    }
+
+    /**
+     * @return the traversal mode, where node-based is the default.
+     */
+    public TraversalMode getTraversalMode()
+    {
+        return traversalMode;
+    }
+
+    public Weighting getWeighting()
+    {
+        assertNotNull(weighting, "weighting");
+        return weighting;
+    }
+
+    public String getAlgorithm()
+    {
+        assertNotNull(algorithm, "algorithm");
+        return algorithm;
+    }
+
+    public FlagEncoder getFlagEncoder()
+    {
+        assertNotNull(flagEncoder, "flagEncoder");
+        return flagEncoder;
+    }
+
+    public PMap getHints()
+    {
+        return hints;
+    }
+
+    private void assertNotNull( Object optionValue, String optionName )
+    {
+        if (optionValue == null)
+            throw new NullPointerException("Option '" + optionName + "' must NOT be null");
+    }
+
+    @Override
+    public String toString()
+    {
+        return algorithm + ", " + weighting + ", " + flagEncoder + ", " + traversalMode;
+    }
+
+    /**
+     * This method starts the building process for AlgorithmOptions.
+     */
+    public static Builder start()
+    {
+        return new Builder();
+    }
+
+    /**
+     * This method clones the specified AlgorithmOption object with the possibility for further
+     * changes.
+     */
+    public static Builder start( AlgorithmOptions opts )
+    {
+        Builder b = new Builder();
+        if (opts.algorithm != null)
+            b.algorithm(opts.getAlgorithm());
+        if (opts.flagEncoder != null)
+            b.flagEncoder(opts.getFlagEncoder());
+        if (opts.traversalMode != null)
+            b.traversalMode(opts.getTraversalMode());
+        if (opts.weighting != null)
+            b.weighting(opts.getWeighting());
+        return b;
+    }
+
+    public static class Builder
+    {
+        private final AlgorithmOptions opts = new AlgorithmOptions();
+
+        public Builder traversalMode( TraversalMode traversalMode )
+        {
+            if (traversalMode == null)
+                throw new IllegalArgumentException("null as traversal mode is not allowed");
+
+            this.opts.traversalMode = traversalMode;
+            return this;
+        }
+
+        public Builder weighting( Weighting weighting )
+        {
+            this.opts.weighting = weighting;
+            return this;
+        }
+
+        /**
+         * For possible values see AlgorithmOptions.*
+         */
+        public Builder algorithm( String algorithm )
+        {
+            this.opts.algorithm = algorithm;
+            return this;
+        }
+
+        public Builder flagEncoder( FlagEncoder flagEncoder )
+        {
+            this.opts.flagEncoder = flagEncoder;
+            return this;
+        }
+
+        public AlgorithmOptions build()
+        {
+            return opts;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index 7096fc6218..16d7cd0df6 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -17,15 +17,18 @@
  */
 package com.graphhopper.routing;
 
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.util.PriorityQueue;
+
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-import java.util.PriorityQueue;
 
 /**
  * Implements a single source shortest path algorithm
@@ -35,15 +38,15 @@
  */
 public class Dijkstra extends AbstractRoutingAlgorithm
 {
-    private TIntObjectMap<EdgeEntry> fromMap;
-    private PriorityQueue<EdgeEntry> fromHeap;
+    protected TIntObjectMap<EdgeEntry> fromMap;
+    protected PriorityQueue<EdgeEntry> fromHeap;
+    protected EdgeEntry currEdge;
     private int visitedNodes;
     private int to = -1;
-    private EdgeEntry currEdge;
 
-    public Dijkstra( Graph g, FlagEncoder encoder, Weighting weighting )
+    public Dijkstra( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(g, encoder, weighting);
+        super(g, encoder, weighting, tMode);
         initCollections(1000);
     }
 
@@ -59,38 +62,41 @@ public Path calcPath( int from, int to )
         checkAlreadyRun();
         this.to = to;
         currEdge = createEdgeEntry(from, 0);
-        fromMap.put(from, currEdge);
-        return runAlgo();
+        if (!traversalMode.isEdgeBased())
+        {
+            fromMap.put(from, currEdge);
+        }
+        runAlgo();
+        return extractPath();
     }
 
-    private Path runAlgo()
+    protected void runAlgo()
     {
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
             visitedNodes++;
-            if (finished())
+            if (isWeightLimitReached() || finished())
                 break;
 
-            int neighborNode = currEdge.endNode;
-            EdgeIterator iter = explorer.setBaseNode(neighborNode);
+            int startNode = currEdge.adjNode;
+            EdgeIterator iter = explorer.setBaseNode(startNode);
             while (iter.next())
             {
-                if (!accept(iter))
-                    continue;
-                // minor speed up
-                if (currEdge.edge == iter.getEdge())
+                if (!accept(iter, currEdge.edge))
                     continue;
 
-                int tmpNode = iter.getAdjNode();
-                double tmpWeight = weighting.calcWeight(iter) + currEdge.weight;
+                int traversalId = traversalMode.createTraversalId(iter, false);
+                double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;
+                if (Double.isInfinite(tmpWeight))
+                    continue;
 
-                EdgeEntry nEdge = fromMap.get(tmpNode);
+                EdgeEntry nEdge = fromMap.get(traversalId);
                 if (nEdge == null)
                 {
-                    nEdge = new EdgeEntry(iter.getEdge(), tmpNode, tmpWeight);
+                    nEdge = new EdgeEntry(iter.getEdge(), iter.getAdjNode(), tmpWeight);
                     nEdge.parent = currEdge;
-                    fromMap.put(tmpNode, nEdge);
+                    fromMap.put(traversalId, nEdge);
                     fromHeap.add(nEdge);
                 } else if (nEdge.weight > tmpWeight)
                 {
@@ -99,44 +105,50 @@ private Path runAlgo()
                     nEdge.weight = tmpWeight;
                     nEdge.parent = currEdge;
                     fromHeap.add(nEdge);
-                }
+                } else
+                    continue;
 
-                updateShortest(nEdge, neighborNode);
+                updateBestPath(iter, nEdge, traversalId);
             }
 
             if (fromHeap.isEmpty())
-                return createEmptyPath();
+                break;
 
             currEdge = fromHeap.poll();
             if (currEdge == null)
                 throw new AssertionError("Empty edge cannot happen");
         }
-        return extractPath();
     }
 
     @Override
     protected boolean finished()
     {
-        return currEdge.endNode == to;
+        return currEdge.adjNode == to;
     }
 
     @Override
     protected Path extractPath()
     {
-        if (currEdge == null || !finished())
+        if (currEdge == null || isWeightLimitReached() || !finished())
             return createEmptyPath();
-        return new Path(graph, flagEncoder).setEdgeEntry(currEdge).extract();
+
+        return new Path(graph, flagEncoder).setWeight(currEdge.weight).setEdgeEntry(currEdge).extract();
     }
 
     @Override
-    public String getName()
+    public int getVisitedNodes()
     {
-        return "dijkstra";
+        return visitedNodes;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
     }
 
     @Override
-    public int getVisitedNodes()
+    public String getName()
     {
-        return visitedNodes;
+        return AlgorithmOptions.DIJKSTRA;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java
deleted file mode 100644
index 9b77f99c80..0000000000
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing;
-
-import com.graphhopper.coll.IntDoubleBinHeap;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeWrapper;
-
-/**
- * Calculates shortest path in bidirectional way. Compared to DijkstraBidirectionRef this class is
- * more memory efficient as it does not go the normal Java way via references. In first tests this
- * class saves 30% memory, but as you can see it is more complicated.
- * <p/>
- * Possible improvements
- * <p>
- * 1. use only one EdgeWrapper to save memory. This is not easy if we want it to be as fast as the
- * current solution. But we need to try it out if a forwardSearchBitset.contains(ref) is that
- * expensive
- * <p/>
- * 2. instead of creating references point to the edges itself => we only need an edge+node array
- * and from that can retrieve eg. the distance
- * <p/>
- * @author Peter Karich
- */
-public class DijkstraBidirection extends AbstractBidirAlgo
-{
-    private int currFrom;
-    private double currFromWeight;
-    private int currFromRef;
-    private int currTo;
-    private double currToWeight;
-    private int currToRef;
-    private EdgeWrapper parentRefOther;
-    private IntDoubleBinHeap openSetFrom;
-    private EdgeWrapper parentRefFrom;
-    private IntDoubleBinHeap openSetTo;
-    private EdgeWrapper parentRefTo;
-    private PathBidir nativeBestPath;
-
-    public DijkstraBidirection( Graph graph, FlagEncoder encoder, Weighting weighting )
-    {
-        super(graph, encoder, weighting);
-        initCollections(1000);
-    }
-
-    protected void initCollections( int locs )
-    {
-        openSetFrom = new IntDoubleBinHeap(locs);
-        parentRefFrom = new EdgeWrapper(locs);
-
-        openSetTo = new IntDoubleBinHeap(locs);
-        parentRefTo = new EdgeWrapper(locs);
-    }
-
-    @Override
-    public void initFrom( int from, double dist )
-    {
-        currFrom = from;
-        currFromWeight = dist;
-        currFromRef = parentRefFrom.add(from, dist, EdgeIterator.NO_EDGE);
-        openSetFrom.insert_(currFromWeight, currFromRef);
-        if (currTo >= 0)
-        {
-            parentRefOther = parentRefTo;
-            updateShortest(currFrom, currFromRef, currToWeight);
-        }
-    }
-
-    @Override
-    public void initTo( int to, double dist )
-    {
-        currTo = to;
-        currToWeight = dist;
-        currToRef = parentRefTo.add(to, dist, EdgeIterator.NO_EDGE);
-        openSetTo.insert_(currToWeight, currToRef);
-        if (currFrom >= 0)
-        {
-            parentRefOther = parentRefFrom;
-            updateShortest(currTo, currToRef, currFromWeight);
-        }
-    }
-
-    @Override
-    protected void initPath()
-    {
-        nativeBestPath = new PathBidir(graph, flagEncoder, parentRefFrom, parentRefTo);
-    }
-
-    @Override
-    public Path extractPath()
-    {
-        return nativeBestPath.extract();
-    }
-
-    @Override
-    void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
-    {
-        if (parentRefFrom.isEmpty() || parentRefTo.isEmpty())
-            throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + fromBase + ", to:" + toBase);
-    }
-
-    // http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
-    // a node from overlap may not be on the shortest path!!
-    // => when scanning an arc (v, w) in the forward search and w is scanned in the reverseOrder 
-    //    search, update shortest = μ if df (v) + (v, w) + dr (w) < μ            
-    @Override
-    protected boolean finished()
-    {
-        if (finishedFrom || finishedTo)
-            return true;
-
-        return currFromWeight + currToWeight >= nativeBestPath.getWeight();
-    }
-
-    void fillEdges( int currNode, double currWeight, int currRef,
-            IntDoubleBinHeap openSet, EdgeWrapper wrapper, EdgeExplorer explorer )
-    {
-        EdgeIterator iter = explorer.setBaseNode(currNode);
-        while (iter.next())
-        {
-            if (!accept(iter))
-                continue;
-
-            int neighborNode = iter.getAdjNode();
-            // minor speed up
-            int newRef = wrapper.getRef(neighborNode);
-            if (newRef >= 0 && wrapper.getEdgeId(newRef) == iter.getEdge())
-                continue;
-
-            double tmpWeight = weighting.calcWeight(iter) + currWeight;
-            if (newRef < 0)
-            {
-                newRef = wrapper.add(neighborNode, tmpWeight, iter.getEdge());
-                wrapper.putParent(newRef, currRef);
-                openSet.insert_(tmpWeight, newRef);
-            } else
-            {
-                double weight = wrapper.getWeight(newRef);
-                if (weight > tmpWeight)
-                {
-                    wrapper.putEdgeId(newRef, iter.getEdge());
-                    wrapper.putWeight(newRef, tmpWeight);
-                    wrapper.putParent(newRef, currRef);
-                    openSet.update_(tmpWeight, newRef);
-                }
-            }
-
-            updateShortest(neighborNode, newRef, tmpWeight);
-        }
-    }
-
-    void updateShortest( int nodeId, int ref, double weight )
-    {
-        int otherRef = parentRefOther.getRef(nodeId);
-        if (otherRef < 0)
-            return;
-
-        // update μ
-        double newWeight = weight + parentRefOther.getWeight(otherRef);
-        if (newWeight < nativeBestPath.getWeight())
-        {
-            nativeBestPath.switchWrapper = parentRefFrom == parentRefOther;
-            nativeBestPath.fromRef = ref;
-            nativeBestPath.toRef = otherRef;
-            nativeBestPath.setWeight(newWeight);
-        }
-    }
-
-    @Override
-    boolean fillEdgesFrom()
-    {
-        if (openSetFrom.isEmpty())
-            return false;
-
-        currFromRef = openSetFrom.poll_element();
-        currFrom = parentRefFrom.getNode(currFromRef);
-        currFromWeight = parentRefFrom.getWeight(currFromRef);
-
-        parentRefOther = parentRefTo;
-        fillEdges(currFrom, currFromWeight, currFromRef, openSetFrom, parentRefFrom, outEdgeExplorer);
-        visitedFromCount++;
-        return true;
-    }
-
-    @Override
-    boolean fillEdgesTo()
-    {
-        if (openSetTo.isEmpty())
-            return false;
-        currToRef = openSetTo.poll_element();
-        currTo = parentRefTo.getNode(currToRef);
-        currToWeight = parentRefTo.getWeight(currToRef);
-
-        parentRefOther = parentRefFrom;
-        fillEdges(currTo, currToWeight, currToRef, openSetTo, parentRefTo, inEdgeExplorer);
-        visitedToCount++;
-        return true;
-    }
-
-    @Override
-    public String getName()
-    {
-        return "dijkstraNativebi";
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index b7ace14c60..71bbe643d8 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -17,22 +17,26 @@
  */
 package com.graphhopper.routing;
 
+import gnu.trove.map.TIntObjectMap;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.util.PriorityQueue;
+
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-import java.util.PriorityQueue;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
 
 /**
  * Calculates best path in bidirectional way.
  * <p/>
  * 'Ref' stands for reference implementation and is using the normal Java-'reference'-way.
- * <p/>
- * @see DijkstraBidirection for an array based but more complicated version
+ * <p>
  * @author Peter Karich
  */
 public class DijkstraBidirectionRef extends AbstractBidirAlgo
@@ -45,10 +49,11 @@
     protected EdgeEntry currFrom;
     protected EdgeEntry currTo;
     protected PathBidirRef bestPath;
+    private boolean updateBestPath = true;
 
-    public DijkstraBidirectionRef( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public DijkstraBidirectionRef( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
         initCollections(1000);
     }
 
@@ -65,12 +70,25 @@ protected void initCollections( int nodes )
     public void initFrom( int from, double dist )
     {
         currFrom = createEdgeEntry(from, dist);
-        bestWeightMapFrom.put(from, currFrom);
         openSetFrom.add(currFrom);
-        if (currTo != null)
+        if (!traversalMode.isEdgeBased())
+        {
+            bestWeightMapFrom.put(from, currFrom);
+            if (currTo != null)
+            {
+                bestWeightMapOther = bestWeightMapTo;
+                updateBestPath(GHUtility.getEdge(graph, from, currTo.adjNode), currTo, from);
+            }
+        } else
         {
-            bestWeightMapOther = bestWeightMapTo;
-            updateShortest(currTo, from);
+            if (currTo != null && currTo.adjNode == from)
+            {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
+                finishedFrom = true;
+                finishedTo = true;
+            }
         }
     }
 
@@ -78,24 +96,41 @@ public void initFrom( int from, double dist )
     public void initTo( int to, double dist )
     {
         currTo = createEdgeEntry(to, dist);
-        bestWeightMapTo.put(to, currTo);
         openSetTo.add(currTo);
-        if (currFrom != null)
+        if (!traversalMode.isEdgeBased())
+        {
+            bestWeightMapTo.put(to, currTo);
+            if (currFrom != null)
+            {
+                bestWeightMapOther = bestWeightMapFrom;
+                updateBestPath(GHUtility.getEdge(graph, currFrom.adjNode, to), currFrom, to);
+            }
+        } else
         {
-            bestWeightMapOther = bestWeightMapFrom;
-            updateShortest(currFrom, to);
+            if (currFrom != null && currFrom.adjNode == to)
+            {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
+                finishedFrom = true;
+                finishedTo = true;
+            }
         }
     }
 
     @Override
-    protected void initPath()
+    protected Path createAndInitPath()
     {
         bestPath = new PathBidirRef(graph, flagEncoder);
+        return bestPath;
     }
 
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -107,27 +142,27 @@ void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
     }
 
     @Override
-    protected boolean fillEdgesFrom()
+    public boolean fillEdgesFrom()
     {
         if (openSetFrom.isEmpty())
             return false;
 
         currFrom = openSetFrom.poll();
         bestWeightMapOther = bestWeightMapTo;
-        fillEdges(currFrom, openSetFrom, bestWeightMapFrom, outEdgeExplorer);
-        visitedFromCount++;
+        fillEdges(currFrom, openSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
+        visitedCountFrom++;
         return true;
     }
 
     @Override
-    protected boolean fillEdgesTo()
+    public boolean fillEdgesTo()
     {
         if (openSetTo.isEmpty())
             return false;
         currTo = openSetTo.poll();
         bestWeightMapOther = bestWeightMapFrom;
-        fillEdges(currTo, openSetTo, bestWeightMapTo, inEdgeExplorer);
-        visitedToCount++;
+        fillEdges(currTo, openSetTo, bestWeightMapTo, inEdgeExplorer, true);
+        visitedCountTo++;
         return true;
     }
 
@@ -136,7 +171,7 @@ protected boolean fillEdgesTo()
     // => when scanning an arc (v, w) in the forward search and w is scanned in the reverseOrder 
     //    search, update extractPath = μ if df (v) + (v, w) + dr (w) < μ            
     @Override
-    protected boolean finished()
+    public boolean finished()
     {
         if (finishedFrom || finishedTo)
             return true;
@@ -144,73 +179,135 @@ protected boolean finished()
         return currFrom.weight + currTo.weight >= bestPath.getWeight();
     }
 
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
+    }
+
     void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
-            TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer )
+            TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
-        int currNode = currEdge.endNode;
+        int currNode = currEdge.adjNode;
         EdgeIterator iter = explorer.setBaseNode(currNode);
         while (iter.next())
         {
-            if (!accept(iter))
-                continue;
-            // minor speed up
-            if (currEdge.edge == iter.getEdge())
+            if (!accept(iter, currEdge.edge))
                 continue;
 
-            int neighborNode = iter.getAdjNode();
-            double tmpWeight = weighting.calcWeight(iter) + currEdge.weight;
+            int traversalId = traversalMode.createTraversalId(iter, reverse);
+            double tmpWeight = weighting.calcWeight(iter, reverse, currEdge.edge) + currEdge.weight;
+            if (Double.isInfinite(tmpWeight))
+                continue;
 
-            EdgeEntry de = shortestWeightMap.get(neighborNode);
-            if (de == null)
+            EdgeEntry ee = shortestWeightMap.get(traversalId);
+            if (ee == null)
             {
-                de = new EdgeEntry(iter.getEdge(), neighborNode, tmpWeight);
-                de.parent = currEdge;
-                shortestWeightMap.put(neighborNode, de);
-                prioQueue.add(de);
-            } else if (de.weight > tmpWeight)
+                ee = new EdgeEntry(iter.getEdge(), iter.getAdjNode(), tmpWeight);
+                ee.parent = currEdge;
+                shortestWeightMap.put(traversalId, ee);
+                prioQueue.add(ee);
+            } else if (ee.weight > tmpWeight)
             {
-                prioQueue.remove(de);
-                de.edge = iter.getEdge();
-                de.weight = tmpWeight;
-                de.parent = currEdge;
-                prioQueue.add(de);
-            }
+                prioQueue.remove(ee);
+                ee.edge = iter.getEdge();
+                ee.weight = tmpWeight;
+                ee.parent = currEdge;
+                prioQueue.add(ee);
+            } else
+                continue;
 
-            updateShortest(de, neighborNode);
+            if (updateBestPath)
+                updateBestPath(iter, ee, traversalId);
         }
     }
 
     @Override
-    protected void updateShortest( EdgeEntry shortestEE, int currLoc )
+    protected void updateBestPath( EdgeIteratorState edgeState, EdgeEntry entryCurrent, int traversalId )
     {
-        EdgeEntry entryOther = bestWeightMapOther.get(currLoc);
+        EdgeEntry entryOther = bestWeightMapOther.get(traversalId);
         if (entryOther == null)
             return;
 
+        boolean reverse = bestWeightMapFrom == bestWeightMapOther;
+
         // update μ
-        double newShortest = shortestEE.weight + entryOther.weight;
-        if (newShortest < bestPath.getWeight())
+        double newWeight = entryCurrent.weight + entryOther.weight;
+        if (traversalMode.isEdgeBased())
         {
-            bestPath.setSwitchToFrom(bestWeightMapFrom == bestWeightMapOther);
-            bestPath.setEdgeEntry(shortestEE);
-            bestPath.edgeTo = entryOther;
-            bestPath.setWeight(newShortest);
+            if (entryOther.edge != entryCurrent.edge)
+                throw new IllegalStateException("cannot happen for edge based execution of " + getName());
+
+            if (entryOther.adjNode != entryCurrent.adjNode)
+            {
+                // prevents the path to contain the edge at the meeting point twice and subtract the weight (excluding turn weight => no previous edge)
+                entryCurrent = entryCurrent.parent;
+                newWeight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
+            } else
+            {
+                // we detected a u-turn at meeting point, skip if not supported
+                if (!traversalMode.hasUTurnSupport())
+                    return;
+            }
         }
+
+        if (newWeight < bestPath.getWeight())
+        {
+            bestPath.setSwitchToFrom(reverse);
+            bestPath.setEdgeEntry(entryCurrent);
+            bestPath.setWeight(newWeight);
+            bestPath.setEdgeEntryTo(entryOther);
+        }
+    }
+
+    TIntObjectMap<EdgeEntry> getBestFromMap()
+    {
+        return bestWeightMapFrom;
+    }
+
+    TIntObjectMap<EdgeEntry> getBestToMap()
+    {
+        return bestWeightMapTo;
+    }
+
+    void setBestOtherMap( TIntObjectMap<EdgeEntry> other )
+    {
+        bestWeightMapOther = other;
+    }
+
+    void setFromDataStructures( DijkstraBidirectionRef dijkstra )
+    {
+        openSetFrom = dijkstra.openSetFrom;
+        bestWeightMapFrom = dijkstra.bestWeightMapFrom;
+        finishedFrom = dijkstra.finishedFrom;
+        currFrom = dijkstra.currFrom;
+        visitedCountFrom = dijkstra.visitedCountFrom;
+        // outEdgeExplorer
+    }
+
+    void setToDataStructures( DijkstraBidirectionRef dijkstra )
+    {
+        openSetTo = dijkstra.openSetTo;
+        bestWeightMapTo = dijkstra.bestWeightMapTo;
+        finishedTo = dijkstra.finishedTo;
+        currTo = dijkstra.currTo;
+        visitedCountTo = dijkstra.visitedCountTo;
+        // inEdgeExplorer
     }
 
-    public EdgeEntry shortestWeightFrom( int nodeId )
+    void setUpdateBestPath( boolean b )
     {
-        return bestWeightMapFrom.get(nodeId);
+        updateBestPath = b;
     }
 
-    public EdgeEntry shortestWeightTo( int nodeId )
+    void setBestPath( PathBidirRef bestPath )
     {
-        return bestWeightMapTo.get(nodeId);
+        this.bestPath = bestPath;
     }
 
     @Override
     public String getName()
     {
-        return "dijkstrabi";
+        return AlgorithmOptions.DIJKSTRA_BI;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 7343c116b5..d566173302 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -19,22 +19,24 @@
 
 import com.graphhopper.coll.IntDoubleBinHeap;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.array.TIntArrayList;
 import java.util.Arrays;
 
 /**
- * A simple dijkstra tuned to perform one to many queries more efficient than DijkstraSimple. Old
- * data structures are cache between requests and potentially reused. Useful for CH preparation.
+ * A simple dijkstra tuned to perform one to many queries more efficient than Dijkstra. Old data
+ * structures are cached between requests and potentially reused. Useful for CH preparation.
  * <p/>
  * @author Peter Karich
  */
 public class DijkstraOneToMany extends AbstractRoutingAlgorithm
 {
+    private static final int EMPTY_PARENT = -1;
+    private static final int NOT_FOUND = -1;
     protected double[] weights;
     private final TIntArrayListWithCap changedNodes;
     private int[] parents;
@@ -42,46 +44,34 @@
     private IntDoubleBinHeap heap;
     private int visitedNodes;
     private boolean doClear = true;
-    private double limitWeight = Double.MAX_VALUE;
     private int limitVisitedNodes = Integer.MAX_VALUE;
     private int endNode;
     private int currNode, fromNode, to;
 
-    public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting )
+    public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
 
         parents = new int[graph.getNodes()];
-        Arrays.fill(parents, -1);
+        Arrays.fill(parents, EMPTY_PARENT);
 
         edgeIds = new int[graph.getNodes()];
         Arrays.fill(edgeIds, EdgeIterator.NO_EDGE);
 
         weights = new double[graph.getNodes()];
+
         Arrays.fill(weights, Double.MAX_VALUE);
 
         heap = new IntDoubleBinHeap();
         changedNodes = new TIntArrayListWithCap();
     }
 
-    public DijkstraOneToMany setLimitWeight( double weight )
-    {
-        limitWeight = weight;
-        return this;
-    }
-
     public DijkstraOneToMany setLimitVisitedNodes( int nodes )
     {
         this.limitVisitedNodes = nodes;
         return this;
     }
 
-    @Override
-    public Path calcPath( QueryResult fromRes, QueryResult toRes )
-    {
-        throw new IllegalStateException("not supported yet");
-    }
-
     @Override
     public Path calcPath( int from, int to )
     {
@@ -94,12 +84,18 @@ public Path calcPath( int from, int to )
     public Path extractPath()
     {
         PathNative p = new PathNative(graph, flagEncoder, parents, edgeIds);
+        if (endNode >= 0)
+            p.setWeight(weights[endNode]);
         p.setFromNode(fromNode);
-        if (endNode < 0)
+        if (endNode < 0 || isWeightLimitReached())
             return p;
+
         return p.setEndNode(endNode).extract();
     }
 
+    /**
+     * Call clear if you have a different start node and need to clear the cache.
+     */
     public DijkstraOneToMany clear()
     {
         doClear = true;
@@ -114,7 +110,7 @@ public double getWeight( int endNode )
     public int findEndNode( int from, int to )
     {
         if (weights.length < 2)
-            return -1;
+            return NOT_FOUND;
 
         this.to = to;
         if (doClear)
@@ -125,7 +121,7 @@ public int findEndNode( int from, int to )
             {
                 int n = changedNodes.get(i);
                 weights[n] = Double.MAX_VALUE;
-                parents[n] = -1;
+                parents[n] = EMPTY_PARENT;
                 edgeIds[n] = EdgeIterator.NO_EDGE;
             }
 
@@ -133,15 +129,21 @@ public int findEndNode( int from, int to )
             changedNodes.reset();
 
             currNode = from;
-            weights[currNode] = 0;
-            changedNodes.add(currNode);
+            if (!traversalMode.isEdgeBased())
+            {
+                weights[currNode] = 0;
+                changedNodes.add(currNode);
+            }
         } else
         {
             // Cached! Re-use existing data structures
             int parentNode = parents[to];
-            if (parentNode >= 0 || heap.isEmpty())
+            if (parentNode != EMPTY_PARENT && weights[to] < weights[currNode])
                 return to;
 
+            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
+                return NOT_FOUND;
+
             currNode = heap.poll_element();
         }
 
@@ -155,15 +157,17 @@ public int findEndNode( int from, int to )
             EdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);
             while (iter.next())
             {
-                if (!accept(iter))
-                    continue;
                 int adjNode = iter.getAdjNode();
-                // minor speed up
-                if (edgeIds[adjNode] == iter.getEdge())
+                int prevEdgeId = edgeIds[adjNode];
+                if (!accept(iter, prevEdgeId))
                     continue;
 
-                double tmpWeight = weighting.calcWeight(iter) + weights[currNode];
-                if (weights[adjNode] == Double.MAX_VALUE)
+                double tmpWeight = weighting.calcWeight(iter, false, prevEdgeId) + weights[currNode];
+                if (Double.isInfinite(tmpWeight))
+                    continue;
+
+                double w = weights[adjNode];
+                if (w == Double.MAX_VALUE)
                 {
                     parents[adjNode] = currNode;
                     weights[adjNode] = tmpWeight;
@@ -171,7 +175,7 @@ public int findEndNode( int from, int to )
                     changedNodes.add(adjNode);
                     edgeIds[adjNode] = iter.getEdge();
 
-                } else if (weights[adjNode] > tmpWeight)
+                } else if (w > tmpWeight)
                 {
                     parents[adjNode] = currNode;
                     weights[adjNode] = tmpWeight;
@@ -181,8 +185,8 @@ public int findEndNode( int from, int to )
                 }
             }
 
-            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
-                return -1;
+            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes || isWeightLimitReached())
+                return NOT_FOUND;
 
             // calling just peek and not poll is important if the next query is cached
             currNode = heap.peek_element();
@@ -196,7 +200,12 @@ public int findEndNode( int from, int to )
     @Override
     public boolean finished()
     {
-        return weights[currNode] >= limitWeight || currNode == to;
+        return currNode == to;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return weights[currNode] >= weightLimit;
     }
 
     public void close()
@@ -216,7 +225,7 @@ public int getVisitedNodes()
     @Override
     public String getName()
     {
-        return "dijkstraOneToMany";
+        return AlgorithmOptions.DIJKSTRA_ONE_TO_MANY;
     }
 
     /**
@@ -225,8 +234,8 @@ public String getName()
     public String getMemoryUsageAsString()
     {
         long len = weights.length;
-        return ((8L + 4L + 4L) * len 
-                + changedNodes.getCapacity() * 4L 
+        return ((8L + 4L + 4L) * len
+                + changedNodes.getCapacity() * 4L
                 + heap.getCapacity() * (4L + 4L)) / Helper.MB
                 + "MB";
     }
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index e93e52d0f5..db99ddd34a 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,9 +17,11 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
@@ -33,9 +35,11 @@
  * <p/>
  * @author Peter Karich
  * @author Ottavio Campana
+ * @author jan soe
  */
 public class Path
 {
+    private static final AngleCalc ac = new AngleCalc();
     protected Graph graph;
     private FlagEncoder encoder;
     protected double distance;
@@ -48,14 +52,14 @@
     private int fromNode = -1;
     protected int endNode = -1;
     private TIntList edgeIds;
-    private PointList cachedPoints;
-    private InstructionList cachedWays;
     private double weight;
+    private NodeAccess nodeAccess;
 
     public Path( Graph graph, FlagEncoder encoder )
     {
         this.weight = Double.MAX_VALUE;
         this.graph = graph;
+        this.nodeAccess = graph.getNodeAccess();
         this.encoder = encoder;
         this.edgeIds = new TIntArrayList();
     }
@@ -67,7 +71,7 @@ public Path( Graph graph, FlagEncoder encoder )
     {
         this(p.graph, p.encoder);
         weight = p.weight;
-        edgeIds = new TIntArrayList(edgeIds);
+        edgeIds = new TIntArrayList(p.edgeIds);
         edgeEntry = p.edgeEntry;
     }
 
@@ -102,7 +106,7 @@ protected Path setFromNode( int from )
      */
     private int getFromNode()
     {
-        if (!EdgeIterator.Edge.isValid(fromNode))
+        if (fromNode < 0)
             throw new IllegalStateException("Call extract() before retrieving fromNode");
 
         return fromNode;
@@ -152,9 +156,10 @@ public double getWeight()
         return weight;
     }
 
-    public void setWeight( double w )
+    public Path setWeight( double w )
     {
         this.weight = w;
+        return this;
     }
 
     /**
@@ -162,16 +167,19 @@ public void setWeight( double w )
      */
     public Path extract()
     {
+        if (isFound())
+            throw new IllegalStateException("Extract can only be called once");
+
         extractSW.start();
         EdgeEntry goalEdge = edgeEntry;
-        setEndNode(goalEdge.endNode);
+        setEndNode(goalEdge.adjNode);
         while (EdgeIterator.Edge.isValid(goalEdge.edge))
         {
-            processEdge(goalEdge.edge, goalEdge.endNode);
+            processEdge(goalEdge.edge, goalEdge.adjNode);
             goalEdge = goalEdge.parent;
         }
 
-        setFromNode(goalEdge.endNode);
+        setFromNode(goalEdge.adjNode);
         reverseOrder();
         extractSW.stop();
         return setFound(true);
@@ -193,34 +201,38 @@ public String getDebugInfo()
     /**
      * Calls getDistance and adds the edgeId.
      */
-    protected void processEdge( int edgeId, int endNode )
+    protected void processEdge( int edgeId, int adjNode )
     {
-        EdgeIteratorState iter = graph.getEdgeProps(edgeId, endNode);
-        double dist = calcDistance(iter);
+        EdgeIteratorState iter = graph.getEdgeProps(edgeId, adjNode);
+        double dist = iter.getDistance();
         distance += dist;
-        millis += calcMillis(dist, iter.getFlags());
+        millis += calcMillis(dist, iter.getFlags(), false);
         addEdge(edgeId);
     }
 
-    /**
-     * This method returns the distance in meter for the specified edge.
-     */
-    protected double calcDistance( EdgeIteratorState iter )
-    {
-        return iter.getDistance();
-    }
-
     /**
      * Calculates the time in millis for the specified distance in meter and speed (in km/h) via
      * flags.
      */
-    protected long calcMillis( double distance, long flags )
+    protected long calcMillis( double distance, long flags, boolean revert )
     {
-        return (long) (distance * 3600 / encoder.getSpeed(flags));
+        if (revert && !encoder.isBackward(flags)
+                || !revert && !encoder.isForward(flags))
+            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
+                    + "Reverse:" + revert + ", fwd:" + encoder.isForward(flags) + ", bwd:" + encoder.isBackward(flags));
+
+        double speed = revert ? encoder.getReverseSpeed(flags) : encoder.getSpeed(flags);
+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
+            throw new IllegalStateException("Invalid speed stored in edge! " + speed);
+
+        if (speed == 0)
+            throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
+
+        return (long) (distance * 3600 / speed);
     }
 
     /**
-     * Used in combination with forEveryEdge.
+     * The callback used in forEveryEdge.
      */
     private static interface EdgeVisitor
     {
@@ -228,7 +240,11 @@ protected long calcMillis( double distance, long flags )
     }
 
     /**
-     * Iterates over all edges in this path and calls the visitor for it.
+     * Iterates over all edges in this path sorted from start to end and calls the visitor callback
+     * for every edge.
+     * <p>
+     * @param visitor callback to handle every edge. The edge is decoupled from the iterator and can
+     * be stored.
      */
     private void forEveryEdge( EdgeVisitor visitor )
     {
@@ -238,16 +254,19 @@ private void forEveryEdge( EdgeVisitor visitor )
         {
             EdgeIteratorState edgeBase = graph.getEdgeProps(edgeIds.get(i), tmpNode);
             if (edgeBase == null)
-            {
-                throw new IllegalStateException("Edge " + edgeIds.get(i)
-                        + " was empty when requested with node " + tmpNode
+                throw new IllegalStateException("Edge " + edgeIds.get(i) + " was empty when requested with node " + tmpNode
                         + ", array index:" + i + ", edges:" + edgeIds.size());
-            }
+
             tmpNode = edgeBase.getBaseNode();
+            // more efficient swap, currently not implemented for virtual edges: visitor.next(edgeBase.detach(true), i);
+            edgeBase = graph.getEdgeProps(edgeBase.getEdge(), tmpNode);
             visitor.next(edgeBase, i);
         }
     }
 
+    /**
+     * Returns the list of all edges.
+     */
     public List<EdgeIteratorState> calcEdges()
     {
         final List<EdgeIteratorState> edges = new ArrayList<EdgeIteratorState>(edgeIds.size());
@@ -272,7 +291,13 @@ public TIntList calcNodes()
     {
         final TIntArrayList nodes = new TIntArrayList(edgeIds.size() + 1);
         if (edgeIds.isEmpty())
+        {
+            if (isFound())
+            {
+                nodes.add(endNode);
+            }
             return nodes;
+        }
 
         int tmpNode = getFromNode();
         nodes.add(tmpNode);
@@ -281,53 +306,60 @@ public TIntList calcNodes()
             @Override
             public void next( EdgeIteratorState eb, int i )
             {
-                nodes.add(eb.getBaseNode());
+                nodes.add(eb.getAdjNode());
             }
         });
         return nodes;
     }
 
     /**
-     * @return the cached list of lat,lon for this path
+     * This method calculated a list of points for this path
+     * <p>
+     * @return this path its geometry
      */
     public PointList calcPoints()
     {
-        if (cachedPoints != null)
-            return cachedPoints;
-
-        cachedPoints = new PointList(edgeIds.size() + 1);
+        final PointList points = new PointList(edgeIds.size() + 1, nodeAccess.is3D());
         if (edgeIds.isEmpty())
-            return cachedPoints;
+        {
+            if (isFound())
+            {
+                points.add(graph.getNodeAccess(), endNode);
+            }
+            return points;
+        }
 
         int tmpNode = getFromNode();
-        cachedPoints.add(graph.getLatitude(tmpNode), graph.getLongitude(tmpNode));
+        points.add(nodeAccess, tmpNode);
         forEveryEdge(new EdgeVisitor()
         {
             @Override
-            public void next( EdgeIteratorState eb, int i )
+            public void next( EdgeIteratorState eb, int index )
             {
-                PointList pl = eb.fetchWayGeometry(1);
-                pl.reverse();
+                PointList pl = eb.fetchWayGeometry(2);
                 for (int j = 0; j < pl.getSize(); j++)
                 {
-                    cachedPoints.add(pl.getLatitude(j), pl.getLongitude(j));
+                    points.add(pl, j);
                 }
             }
         });
-        return cachedPoints;
+        return points;
     }
 
     /**
-     * @return the cached list of ways for this path
+     * @return the list of instructions for this path.
      */
-    public InstructionList calcInstructions()
+    public InstructionList calcInstructions( final Translation tr )
     {
-        if (cachedWays != null)
-            return cachedWays;
-
-        cachedWays = new InstructionList(edgeIds.size() / 4);
+        final InstructionList ways = new InstructionList(edgeIds.size() / 4, tr);
         if (edgeIds.isEmpty())
-            return cachedWays;
+        {
+            if (isFound())
+            {
+                ways.add(new FinishInstruction(nodeAccess, endNode));
+            }
+            return ways;
+        }
 
         final int tmpNode = getFromNode();
         forEveryEdge(new EdgeVisitor()
@@ -352,147 +384,229 @@ public InstructionList calcInstructions()
              * considering orientation belonging to the interval
              * [ - pi + previousOrientation , + pi + previousOrientation ]
              */
-            private double prevLat = graph.getLatitude(tmpNode);
-            private double prevLon = graph.getLongitude(tmpNode);
+            private double prevLat = nodeAccess.getLatitude(tmpNode);
+            private double prevLon = nodeAccess.getLongitude(tmpNode);
+            private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
+            private int prevNode = -1;
             private double prevOrientation;
             private Instruction prevInstruction;
-            private PointList points = new PointList();
-            private String name = null;
-            private int pavementCode;
-            private int wayTypeCode;
+            private boolean prevInRoundabout = false;
+            private String name, prevName = null;
+            private InstructionAnnotation annotation, prevAnnotation;
+            private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
             public void next( EdgeIteratorState edge, int index )
             {
-                // Hmmh, a bit ugly: the 'edge' points to the previous node of the path!
-                // Ie. baseNode is the current node and adjNode is the previous.
+                // baseNode is the current node and adjNode is the next
+                int adjNode = edge.getAdjNode();
                 int baseNode = edge.getBaseNode();
-                double baseLat = graph.getLatitude(baseNode);
-                double baseLon = graph.getLongitude(baseNode);
+                long flags = edge.getFlags();
+                double adjLat = nodeAccess.getLatitude(adjNode);
+                double adjLon = nodeAccess.getLongitude(adjNode);
                 double latitude, longitude;
+
                 PointList wayGeo = edge.fetchWayGeometry(3);
+                boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+
                 if (wayGeo.getSize() <= 2)
                 {
-                    latitude = baseLat;
-                    longitude = baseLon;
+                    latitude = adjLat;
+                    longitude = adjLon;
                 } else
                 {
-                    int adjNode = edge.getAdjNode();
-                    prevLat = graph.getLatitude(adjNode);
-                    prevLon = graph.getLongitude(adjNode);
-                    latitude = wayGeo.getLatitude(wayGeo.getSize() - 2);
-                    longitude = wayGeo.getLongitude(wayGeo.getSize() - 2);
+                    latitude = wayGeo.getLatitude(1);
+                    longitude = wayGeo.getLongitude(1);
+                    assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
+                    assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                 }
 
-                double orientation = Math.atan2(latitude - prevLat, longitude - prevLon);
-                if (name == null)
+                name = edge.getName();
+                annotation = encoder.getAnnotation(flags, tr);
+
+                if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                 {
-                    // very first instruction
-                    name = edge.getName();
-                    pavementCode = encoder.getPavementCode(edge.getFlags());
-                    wayTypeCode = encoder.getWayTypeCode(edge.getFlags());
-                    prevInstruction = new Instruction(Instruction.CONTINUE_ON_STREET, name, wayTypeCode, pavementCode, points);
-                    updatePointsAndInstruction(edge, wayGeo);
-                    cachedWays.add(prevInstruction);
+                    int sign = Instruction.CONTINUE_ON_STREET;
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                    ways.add(prevInstruction);
+                    prevName = name;
+                    prevAnnotation = annotation;
+
                 } else
                 {
-                    double tmpOrientation;
-                    if (prevOrientation >= 0)
+                    if (isRoundabout)
+                    // remark: names and annotations within roundabout are ignored
                     {
-                        if (orientation < -Math.PI + prevOrientation)
-                            tmpOrientation = orientation + 2 * Math.PI;
-                        else
-                            tmpOrientation = orientation;
+                        if (!prevInRoundabout) //just entered roundabout
+                        {
+                            int sign = Instruction.USE_ROUNDABOUT;
+                            RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
+                                    annotation, new PointList(10, nodeAccess.is3D()));
+                            if (prevName != null)
+                            {
+                                // check if there is an exit at the same node the roundabout was entered
+                                EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
+                                while (edgeIter.next()) 
+                                {
+                                    if ((edgeIter.getAdjNode() != prevNode) 
+                                         && !encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT))
+                                    {
+                                        roundaboutInstruction.increaseExitNumber();
+                                        break;
+                                    }
+                                }
+
+                                // previous orientation is last orientation before entering roundabout
+                                prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+
+                                // calculate direction of entrance turn to determine direction of rotation
+                                // right turn == counterclockwise and vice versa
+                                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                orientation = ac.alignOrientation(prevOrientation, orientation);
+                                double delta = (orientation - prevOrientation);
+                                roundaboutInstruction.setDirOfRotation(delta);
+
+                            } else // first instructions is roundabout instruction
+                            {
+                                prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                prevName = name;
+                                prevAnnotation = annotation;
+                            }
+                            prevInstruction = roundaboutInstruction;
+                            ways.add(prevInstruction);
+                        }
 
-                    } else
+                        // Add passed exits to instruction. A node is countet if there is at least one outgoing edge
+                        // out of the roundabout
+                        EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
+                        while (edgeIter.next())
+                        {
+                            if (!encoder.isBool(edgeIter.getFlags(), encoder.K_ROUNDABOUT))
+                            {
+                                ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
+                                break;
+                            }
+                        }
+
+                    } else if (prevInRoundabout) //previously in roundabout but not anymore
                     {
-                        if (orientation > +Math.PI + prevOrientation)
-                            tmpOrientation = orientation - 2 * Math.PI;
-                        else
-                            tmpOrientation = orientation;
-                    }
 
-                    String tmpName = edge.getName();
-                    int tmpPavement = encoder.getPavementCode(edge.getFlags());
-                    int tmpWayType = encoder.getWayTypeCode(edge.getFlags());
-                    if ((!name.equals(tmpName))
-                            || (pavementCode != tmpPavement)
-                            || (wayTypeCode != tmpWayType))
+                        prevInstruction.setName(name);
+
+                        // calc angle between roundabout entrance and exit
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double deltaInOut = (orientation - prevOrientation);
+
+                        // calculate direction of exit turn to determine direction of rotation
+                        // right turn == counterclockwise and vice versa
+                        double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(recentOrientation, orientation);
+                        double deltaOut = (orientation - recentOrientation);
+
+                        prevInstruction = ((RoundaboutInstruction) prevInstruction)
+                                .setRadian(deltaInOut)
+                                .setDirOfRotation(deltaOut)
+                                .setExited();
+
+                        prevName = name;
+                        prevAnnotation = annotation;
+
+                    } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation)))
                     {
-                        points = new PointList();                        
-                        name = tmpName;
-                        pavementCode = tmpPavement;
-                        wayTypeCode = tmpWayType;
-                        double delta = Math.abs(tmpOrientation - prevOrientation);
-                        int indication;
-                        if (delta < 0.2)
+                        prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = orientation - prevOrientation;
+                        double absDelta = Math.abs(delta);
+                        int sign;
+
+                        if (absDelta < 0.2)
                         {
                             // 0.2 ~= 11°
-                            indication = Instruction.CONTINUE_ON_STREET;
+                            sign = Instruction.CONTINUE_ON_STREET;
 
-                        } else if (delta < 0.8)
+                        } else if (absDelta < 0.8)
                         {
                             // 0.8 ~= 40°
-                            if (tmpOrientation > prevOrientation)
-                                indication = Instruction.TURN_SLIGHT_LEFT;
+                            if (delta > 0)
+                                sign = Instruction.TURN_SLIGHT_LEFT;
                             else
-                                indication = Instruction.TURN_SLIGHT_RIGHT;
+                                sign = Instruction.TURN_SLIGHT_RIGHT;
 
-                        } else if (delta < 1.8)
+                        } else if (absDelta < 1.8)
                         {
                             // 1.8 ~= 103°
-                            if (tmpOrientation > prevOrientation)
-                                indication = Instruction.TURN_LEFT;
+                            if (delta > 0)
+                                sign = Instruction.TURN_LEFT;
                             else
-                                indication = Instruction.TURN_RIGHT;
+                                sign = Instruction.TURN_RIGHT;
 
                         } else
                         {
-                            if (tmpOrientation > prevOrientation)
-                                indication = Instruction.TURN_SHARP_LEFT;
+                            if (delta > 0)
+                                sign = Instruction.TURN_SHARP_LEFT;
                             else
-                                indication = Instruction.TURN_SHARP_RIGHT;
+                                sign = Instruction.TURN_SHARP_RIGHT;
 
                         }
-
-                        prevInstruction = new Instruction(indication, name, wayTypeCode, pavementCode, points);
-                        cachedWays.add(prevInstruction);
-                    } 
-                    
-                    updatePointsAndInstruction(edge, wayGeo);                    
+                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                        ways.add(prevInstruction);
+                        prevName = name;
+                        prevAnnotation = annotation;
+                    }
                 }
 
-                prevLat = baseLat;
-                prevLon = baseLon;
+                updatePointsAndInstruction(edge, wayGeo);
+
                 if (wayGeo.getSize() <= 2)
-                    prevOrientation = orientation;
-                else
-                    prevOrientation = Math.atan2(baseLat - wayGeo.getLatitude(1), baseLon - wayGeo.getLongitude(1));
+                {
+                    doublePrevLat = prevLat;
+                    doublePrevLong = prevLon;
+                } else
+                {
+                    int beforeLast = wayGeo.getSize() - 2;
+                    doublePrevLat = wayGeo.getLatitude(beforeLast);
+                    doublePrevLong = wayGeo.getLongitude(beforeLast);
+                }
+                
+                prevInRoundabout = isRoundabout;
+                prevNode = baseNode;
+                prevLat = adjLat;
+                prevLon = adjLon;
 
                 boolean lastEdge = index == edgeIds.size() - 1;
                 if (lastEdge)
-                    cachedWays.add(new FinishInstruction(prevLat, prevLon));                
+                {
+                    if (isRoundabout)
+                    {
+                        // calc angle between roundabout entrance and finish
+                        double orientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = (orientation - prevOrientation);
+                        ((RoundaboutInstruction) prevInstruction).setRadian(delta);
+
+                    }
+                    ways.add(new FinishInstruction(nodeAccess, adjNode));
+                }
             }
 
             private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
             {
-                // add points in opposite direction as adj node is previous
-                // skip base point => 'i > 0'
+                // skip adjNode
                 int len = pl.size() - 1;
-                long flags = edge.getFlags();
-                for (int i = len; i > 0; i--)
+                for (int i = 0; i < len; i++)
                 {
-                    double lat = pl.getLatitude(i);
-                    double lon = pl.getLongitude(i);
-                    points.add(lat, lon);
+                    prevInstruction.getPoints().add(pl, i);
                 }
-                double dist = calcDistance(edge);
-                prevInstruction.setDistance(dist + prevInstruction.getDistance());
-                prevInstruction.setMillis(calcMillis(dist, flags) + prevInstruction.getMillis());
+                double newDist = edge.getDistance();
+                prevInstruction.setDistance(newDist + prevInstruction.getDistance());
+                long flags = edge.getFlags();
+                prevInstruction.setTime(calcMillis(newDist, flags, false) + prevInstruction.getTime());
             }
         });
 
-        return cachedWays;
+        return ways;
     }
 
     @Override
@@ -511,6 +625,6 @@ public String toDetailsString()
 
             str += edgeIds.get(i);
         }
-        return toString() + ", " + str;
+        return toString() + ", found:" + isFound() + ", " + str;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidir.java b/core/src/main/java/com/graphhopper/routing/PathBidir.java
index 9c6e42ab6e..39cb980c28 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidir.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidir.java
@@ -84,9 +84,9 @@ public Path extract()
             if (edgeId < 0)
                 break;
 
-            processEdge(edgeId, nodeTo);
             int tmpRef = edgeWTo.getParent(currRef);
             nodeTo = edgeWTo.getNode(tmpRef);
+            processEdge(edgeId, nodeTo);
             currRef = tmpRef;
         }
         setEndNode(nodeTo);
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index c61df2dcff..3ae0152479 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -21,7 +21,6 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.GHUtility;
 
 /**
  * This class creates a DijkstraPath from two Edge's resulting from a BidirectionalDijkstra
@@ -66,10 +65,8 @@ public Path extract()
         if (edgeEntry == null || edgeTo == null)
             return this;
 
-        int from = GHUtility.getToNode(graph, edgeEntry.edge, edgeEntry.endNode);
-        int to = GHUtility.getToNode(graph, edgeTo.edge, edgeTo.endNode);
-        if (from != to)
-            throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge has to be the same." + toString());
+        if (edgeEntry.adjNode != edgeTo.adjNode)
+            throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge has to be the same." + toString() + ", fromEntry:" + edgeEntry + ", toEntry:" + edgeTo);
 
         extractSW.start();
         if (switchWrapper)
@@ -82,20 +79,20 @@ public Path extract()
         EdgeEntry currEdge = edgeEntry;
         while (EdgeIterator.Edge.isValid(currEdge.edge))
         {
-            processEdge(currEdge.edge, currEdge.endNode);
+            processEdge(currEdge.edge, currEdge.adjNode);
             currEdge = currEdge.parent;
         }
-        setFromNode(currEdge.endNode);
+        setFromNode(currEdge.adjNode);
         reverseOrder();
         currEdge = edgeTo;
         int tmpEdge = currEdge.edge;
         while (EdgeIterator.Edge.isValid(tmpEdge))
         {
             currEdge = currEdge.parent;
-            processEdge(tmpEdge, currEdge.endNode);
+            processEdge(tmpEdge, currEdge.adjNode);
             tmpEdge = currEdge.edge;
         }
-        setEndNode(currEdge.endNode);
+        setEndNode(currEdge.adjNode);
         extractSW.stop();
         return setFound(true);
     }
diff --git a/core/src/main/java/com/graphhopper/routing/PathNative.java b/core/src/main/java/com/graphhopper/routing/PathNative.java
index 207ccc8b5a..6089caa68d 100644
--- a/core/src/main/java/com/graphhopper/routing/PathNative.java
+++ b/core/src/main/java/com/graphhopper/routing/PathNative.java
@@ -28,14 +28,14 @@
  */
 public class PathNative extends Path
 {
-    int[] parents;
-    int[] pathEdgeIds;
+    private final int[] parentNodes;
+    private final int[] parentEdges;
 
-    public PathNative( Graph g, FlagEncoder encoder, int[] parents, int[] pathEdgeIds )
+    public PathNative( Graph g, FlagEncoder encoder, int[] parentNodes, int[] parentEdges )
     {
         super(g, encoder);
-        this.parents = parents;
-        this.pathEdgeIds = pathEdgeIds;
+        this.parentNodes = parentNodes;
+        this.parentEdges = parentEdges;
     }
 
     /**
@@ -49,12 +49,12 @@ public Path extract()
 
         while (true)
         {
-            int edgeId = pathEdgeIds[endNode];
+            int edgeId = parentEdges[endNode];
             if (!EdgeIterator.Edge.isValid(edgeId))
                 break;
 
             processEdge(edgeId, endNode);
-            endNode = parents[endNode];
+            endNode = parentNodes[endNode];
         }
         reverseOrder();
         return setFound(true);
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 07f09083f6..ffbb943041 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -19,11 +19,12 @@
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
 
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.map.TIntObjectMap;
@@ -38,23 +39,24 @@
 import java.util.List;
 
 /**
- * A class which is used to query the underlying graph with real GPS points. It
- * does so by introducing virtual nodes and edges. It is lightweight in order to
- * be created every time a new query comes in, which makes the behaviour thread
- * safe.
+ * A class which is used to query the underlying graph with real GPS points. It does so by
+ * introducing virtual nodes and edges. It is lightweight in order to be created every time a new
+ * query comes in, which makes the behaviour thread safe.
  * <p/>
  * @author Peter Karich
  */
-public class QueryGraph implements Graph {
-
+public class QueryGraph implements Graph
+{
     private final Graph mainGraph;
+    private final NodeAccess mainNodeAccess;
     private final int mainNodes;
     private final int mainEdges;
+    private final QueryGraph baseGraph;
+    private final GraphExtension wrappedExtension;
     private List<QueryResult> queryResults;
     /**
-     * Virtual edges are created between existing graph and new virtual tower
-     * nodes. For every virtual node there are 4 edges: base-snap, snap-base,
-     * snap-adj, adj-snap
+     * Virtual edges are created between existing graph and new virtual tower nodes. For every
+     * virtual node there are 4 edges: base-snap, snap-base, snap-adj, adj-snap.
      */
     private List<EdgeIteratorState> virtualEdges;
     private final static int VE_BASE = 0, VE_BASE_REV = 1, VE_ADJ = 2, VE_ADJ_REV = 3;
@@ -63,68 +65,114 @@
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
-    private final DistanceCalc distCalc = new DistancePlaneProjection();
 
-    public QueryGraph(Graph graph) {
+    public QueryGraph( Graph graph )
+    {
         mainGraph = graph;
+        mainNodeAccess = graph.getNodeAccess();
         mainNodes = graph.getNodes();
-        mainEdges = graph.getAllEdges().getMaxId();
+        mainEdges = graph.getAllEdges().getCount();
+
+        if (mainGraph.getExtension() instanceof TurnCostExtension)
+            wrappedExtension = new QueryGraphTurnExt(this);
+        else
+            wrappedExtension = mainGraph.getExtension();
+
+        // create very lightweight QueryGraph which uses variables from this QueryGraph (same virtual edges)
+        baseGraph = new QueryGraph(graph.getBaseGraph(), this);
+    }
+
+    /**
+     * See 'lookup' for further variables that are initialized
+     */
+    private QueryGraph( Graph graph, QueryGraph superQueryGraph )
+    {
+        mainGraph = graph;
+        baseGraph = this;
+        wrappedExtension = superQueryGraph.wrappedExtension;
+        mainNodeAccess = graph.getNodeAccess();
+        mainNodes = superQueryGraph.mainNodes;
+        mainEdges = superQueryGraph.mainEdges;
+    }
+
+    /**
+     * Convenient method to initialize this QueryGraph with the two specified query results.
+     */
+    public QueryGraph lookup( QueryResult fromRes, QueryResult toRes )
+    {
+        List<QueryResult> results = new ArrayList<QueryResult>(2);
+        results.add(fromRes);
+        results.add(toRes);
+        lookup(results);
+        return this;
     }
 
     /**
-     * For all specified query results calculate snapped point and set closest
-     * node and edge to a virtual one if necessary. Additionally the wayIndex
-     * can change if an edge is swapped.
+     * For all specified query results calculate snapped point and set closest node and edge to a
+     * virtual one if necessary. Additionally the wayIndex can change if an edge is swapped.
      */
-    public void lookup(List<QueryResult> resList) {
+    public void lookup( List<QueryResult> resList )
+    {
         if (isInitialized())
             throw new IllegalStateException("Call lookup only once. Otherwise you'll have problems for queries sharing the same edge.");
 
+        // initialize all none-final variables
         virtualEdges = new ArrayList<EdgeIteratorState>(resList.size() * 2);
-        virtualNodes = new PointList(resList.size());
+        virtualNodes = new PointList(resList.size(), mainNodeAccess.is3D());
         queryResults = new ArrayList<QueryResult>(resList.size());
+        baseGraph.virtualEdges = virtualEdges;
+        baseGraph.virtualNodes = virtualNodes;
+        baseGraph.queryResults = queryResults;
 
         TIntObjectMap<List<QueryResult>> edge2res = new TIntObjectHashMap<List<QueryResult>>(resList.size());
 
         // Phase 1
         // calculate snapped point and swap direction of closest edge if necessary
-        for (QueryResult res : resList) {
+        for (QueryResult res : resList)
+        {
             // Do not create virtual node for a query result if it is directly on a tower node or not found
             EdgeIteratorState closestEdge = res.getClosestEdge();
-            if (res.getSnappedPosition() == QueryResult.Position.TOWER || closestEdge == null)
+
+            if (res.getSnappedPosition() == QueryResult.Position.TOWER)
                 continue;
 
+            if (closestEdge == null)
+                throw new IllegalStateException("Do not call QueryGraph.lookup with invalid QueryResult " + res);
+
             int base = closestEdge.getBaseNode();
 
-            // identical direction for all closest edges
-            // important to sort multiple results for the same edge by its wayIndex
-            if (base > closestEdge.getAdjNode()) {
-                EdgeIteratorState reverseEdge = mainGraph.getEdgeProps(closestEdge.getEdge(), base);
-                // #111 reverse edge can be null if real edges are disconnected while CH-prepare
-                if (reverseEdge != null) {
-                    closestEdge = reverseEdge;
-                    PointList fullPL = reverseEdge.fetchWayGeometry(3);
-                    res.setClosestEdge(reverseEdge);
-                    if (res.getSnappedPosition() == QueryResult.Position.PILLAR)
-                        // ON pillar node                
-                        res.setWayIndex(fullPL.getSize() - res.getWayIndex() - 1);
-                    else
-                        // for case "OFF pillar node"
-                        res.setWayIndex(fullPL.getSize() - res.getWayIndex() - 2);
-
-                    if (res.getWayIndex() < 0)
-                        throw new IllegalStateException("Problem with wayIndex while reversing closest edge:" + closestEdge + ", " + res);
-                } else {
-                    List<QueryResult> tmp = edge2res.get(closestEdge.getEdge());
-                    if (tmp != null && tmp.size() > 1)
-                        throw new IllegalStateException("No reverse edge can be created but multiple of them were found!? " + resList);
-                }
+            // Force the identical direction for all closest edges. 
+            // It is important to sort multiple results for the same edge by its wayIndex
+            boolean doReverse = base > closestEdge.getAdjNode();
+            if (base == closestEdge.getAdjNode())
+            {
+                // check for special case #162 where adj == base and force direction via latitude comparison
+                PointList pl = closestEdge.fetchWayGeometry(0);
+                if (pl.size() > 1)
+                    doReverse = pl.getLatitude(0) > pl.getLatitude(pl.size() - 1);
+            }
+
+            if (doReverse)
+            {
+                closestEdge = closestEdge.detach(true);
+                PointList fullPL = closestEdge.fetchWayGeometry(3);
+                res.setClosestEdge(closestEdge);
+                if (res.getSnappedPosition() == QueryResult.Position.PILLAR)
+                    // ON pillar node                
+                    res.setWayIndex(fullPL.getSize() - res.getWayIndex() - 1);
+                else
+                    // for case "OFF pillar node"
+                    res.setWayIndex(fullPL.getSize() - res.getWayIndex() - 2);
+
+                if (res.getWayIndex() < 0)
+                    throw new IllegalStateException("Problem with wayIndex while reversing closest edge:" + closestEdge + ", " + res);
             }
 
             // find multiple results on same edge
             int edgeId = closestEdge.getEdge();
             List<QueryResult> list = edge2res.get(edgeId);
-            if (list == null) {
+            if (list == null)
+            {
                 list = new ArrayList<QueryResult>(5);
                 edge2res.put(edgeId, list);
             }
@@ -134,20 +182,24 @@ public void lookup(List<QueryResult> resList) {
         // Phase 2 - now it is clear which points cut one edge
         // 1. create point lists
         // 2. create virtual edges between virtual nodes and its neighbor (virtual or normal nodes)
-        edge2res.forEachValue(new TObjectProcedure<List<QueryResult>>() {
+        edge2res.forEachValue(new TObjectProcedure<List<QueryResult>>()
+        {
             @Override
-            public boolean execute(List<QueryResult> results) {
+            public boolean execute( List<QueryResult> results )
+            {
                 // we can expect at least one entry in the results
                 EdgeIteratorState closestEdge = results.get(0).getClosestEdge();
                 final PointList fullPL = closestEdge.fetchWayGeometry(3);
                 int baseNode = closestEdge.getBaseNode();
-                final EdgeIteratorState reverseState = mainGraph.getEdgeProps(closestEdge.getEdge(), baseNode);
                 // sort results on the same edge by the wayIndex and if equal by distance to pillar node
-                Collections.sort(results, new Comparator<QueryResult>() {
+                Collections.sort(results, new Comparator<QueryResult>()
+                {
                     @Override
-                    public int compare(QueryResult o1, QueryResult o2) {
+                    public int compare( QueryResult o1, QueryResult o2 )
+                    {
                         int diff = o1.getWayIndex() - o2.getWayIndex();
-                        if (diff == 0) {
+                        if (diff == 0)
+                        {
                             // sort by distance from snappedPoint to fullPL.get(wayIndex) if wayIndex is identical
                             GHPoint p1 = o1.getSnappedPoint();
                             GHPoint p2 = o2.getSnappedPoint();
@@ -156,8 +208,8 @@ public int compare(QueryResult o1, QueryResult o2) {
 
                             double fromLat = fullPL.getLatitude(o1.getWayIndex());
                             double fromLon = fullPL.getLongitude(o1.getWayIndex());
-                            if (distCalc.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
-                                    > distCalc.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
+                            if (Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
+                                    > Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
                                 return 1;
                             return -1;
                         }
@@ -165,125 +217,261 @@ public int compare(QueryResult o1, QueryResult o2) {
                     }
                 });
 
-                GHPoint prevPoint = fullPL.toGHPoint(0);
+                GHPoint3D prevPoint = fullPL.toGHPoint(0);
                 int adjNode = closestEdge.getAdjNode();
-                long reverseFlags = 0;
-                // #111 avoid this
-                if (reverseState != null)
-                    reverseFlags = reverseState.getFlags();
+                long reverseFlags = closestEdge.detach(true).getFlags();
                 int prevWayIndex = 1;
                 int prevNodeId = baseNode;
-                int counter = 0;
                 int virtNodeId = virtualNodes.getSize() + mainNodes;
-                // Create base and adjacent PointLists for all virtual nodes!
+                boolean addedEdges = false;
+
+                // Create base and adjacent PointLists for all none-equal virtual nodes.
                 // We do so via inserting them at the correct position of fullPL and cutting the                
                 // fullPL into the right pieces.
-                for (QueryResult res : results) {
+                for (int counter = 0; counter < results.size(); counter++)
+                {
+                    QueryResult res = results.get(counter);
                     if (res.getClosestEdge().getBaseNode() != baseNode)
                         throw new IllegalStateException("Base nodes have to be identical but were not: " + closestEdge + " vs " + res.getClosestEdge());
 
+                    GHPoint3D currSnapped = res.getSnappedPoint();
+
+                    // no new virtual nodes if exactly the same snapped point
+                    if (prevPoint.equals(currSnapped))
+                    {
+                        res.setClosestNode(prevNodeId);
+                        continue;
+                    }
+
                     queryResults.add(res);
-                    GHPoint currSnapped = res.getSnappedPoint();
-                    boolean onEdge = res.getSnappedPosition() == QueryResult.Position.EDGE;
                     createEdges(prevPoint, prevWayIndex,
                             res.getSnappedPoint(), res.getWayIndex(),
-                            onEdge, fullPL, closestEdge, prevNodeId, virtNodeId, reverseFlags);
-                    virtualNodes.add(currSnapped.lat, currSnapped.lon);
+                            fullPL, closestEdge, prevNodeId, virtNodeId, reverseFlags);
+
+                    virtualNodes.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
                     // add edges again to set adjacent edges for newVirtNodeId
-                    if (counter > 0) {
+                    if (addedEdges)
+                    {
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                     }
 
+                    addedEdges = true;
                     res.setClosestNode(virtNodeId);
                     prevNodeId = virtNodeId;
                     prevWayIndex = res.getWayIndex() + 1;
                     prevPoint = currSnapped;
-                    counter++;
                     virtNodeId++;
                 }
 
-                // two edges between last result and adjacent node are still missing
-                createEdges(prevPoint, prevWayIndex, fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 1,
-                        false, fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
+                // two edges between last result and adjacent node are still missing if not all points skipped
+                if (addedEdges)
+                    createEdges(prevPoint, prevWayIndex, fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
+                            fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
 
                 return true;
             }
         });
     }
 
-    private void createEdges(GHPoint prevSnapped, int prevWayIndex, GHPoint currSnapped, int wayIndex,
-            boolean onEdge, PointList fullPL, EdgeIteratorState closestEdge,
-            int prevNodeId, int nodeId, long swappedFlags) {
-        int max = wayIndex + 1;
-        PointList basePoints = new PointList(max - prevWayIndex + 1);
-        basePoints.add(prevSnapped.lat, prevSnapped.lon);
-        for (int i = prevWayIndex; i < max; i++) {
-            basePoints.add(fullPL.getLatitude(i), fullPL.getLongitude(i));
+    @Override
+    public Graph getBaseGraph()
+    {
+        // Note: if the mainGraph of this QueryGraph is a LevelGraph then ignoring the shortcuts will produce a 
+        // huge gap of edgeIds between base and virtual edge ids. The only solution would be to move virtual edges
+        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
+        return baseGraph;
+    }
+
+    public boolean isVirtualEdge( int edgeId )
+    {
+        return edgeId >= mainEdges;
+    }
+
+    public boolean isVirtualNode( int nodeId )
+    {
+        return nodeId >= mainNodes;
+    }
+
+    class QueryGraphTurnExt extends TurnCostExtension
+    {
+        private final TurnCostExtension mainTurnExtension;
+
+        public QueryGraphTurnExt( QueryGraph qGraph )
+        {
+            this.mainTurnExtension = (TurnCostExtension) mainGraph.getExtension();
         }
 
-        if (onEdge)
-            basePoints.add(currSnapped.lat, currSnapped.lon);
+        @Override
+        public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
+        {
+            if (isVirtualNode(nodeVia))
+            {
+                return 0;
+            } else if (isVirtualEdge(edgeFrom) || isVirtualEdge(edgeTo))
+            {
+                if (isVirtualEdge(edgeFrom))
+                {
+                    edgeFrom = queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                if (isVirtualEdge(edgeTo))
+                {
+                    edgeTo = queryResults.get((edgeTo - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
 
-        PointList baseReversePoints = basePoints.clone(true);
-        double baseDistance = basePoints.calcDistance(distCalc);
+            } else
+            {
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+            }
+        }
+    }
+
+    private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
+            PointList fullPL, EdgeIteratorState closestEdge,
+            int prevNodeId, int nodeId, long reverseFlags )
+    {
+        int max = wayIndex + 1;
+        // basePoints must have at least the size of 2 to make sure fetchWayGeometry(3) returns at least 2
+        PointList basePoints = new PointList(max - prevWayIndex + 1, mainNodeAccess.is3D());
+        basePoints.add(prevSnapped.lat, prevSnapped.lon, prevSnapped.ele);
+        for (int i = prevWayIndex; i < max; i++)
+        {
+            basePoints.add(fullPL, i);
+        }
+        basePoints.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
-        int virtEdgeId = virtualEdges.size() + mainEdges;
+        PointList baseReversePoints = basePoints.clone(true);
+        double baseDistance = basePoints.calcDistance(Helper.DIST_PLANE);
+        int virtEdgeId = mainEdges + virtualEdges.size();
 
         // edges between base and snapped point
-        EdgeIteratorState baseEdge = new VirtualEdgeIState(virtEdgeId + VE_BASE, prevNodeId, nodeId,
+        VirtualEdgeIState baseEdge = new VirtualEdgeIState(virtEdgeId, prevNodeId, nodeId,
                 baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints);
-        updateDistance(baseEdge);
-        EdgeIteratorState baseReverseEdge = new VirtualEdgeIState(virtEdgeId + VE_BASE_REV, nodeId, prevNodeId,
-                baseDistance, swappedFlags, closestEdge.getName(), baseReversePoints);
-        updateDistance(baseReverseEdge);
+        VirtualEdgeIState baseReverseEdge = new VirtualEdgeIState(virtEdgeId, nodeId, prevNodeId,
+                baseDistance, reverseFlags, closestEdge.getName(), baseReversePoints);
 
         virtualEdges.add(baseEdge);
         virtualEdges.add(baseReverseEdge);
     }
 
-    // For workaround in CH algorithms: To set the weight to the distance of the edge
-    protected void updateDistance(EdgeIteratorState edge) {
-    }
-
     @Override
-    public int getNodes() {
+    public int getNodes()
+    {
         return virtualNodes.getSize() + mainNodes;
     }
 
     @Override
-    public double getLatitude(int nodeId) {
-        if (nodeId >= mainNodes)
-            return virtualNodes.getLatitude(nodeId - mainNodes);
-        return mainGraph.getLatitude(nodeId);
+    public NodeAccess getNodeAccess()
+    {
+        return nodeAccess;
     }
 
-    @Override
-    public double getLongitude(int nodeId) {
-        if (nodeId >= mainNodes)
-            return virtualNodes.getLongitude(nodeId - mainNodes);
-        return mainGraph.getLongitude(nodeId);
-    }
+    private final NodeAccess nodeAccess = new NodeAccess()
+    {
+        @Override
+        public void ensureNode( int nodeId )
+        {
+            mainNodeAccess.ensureNode(nodeId);
+        }
 
-    @Override
-    public int getAdditionalNodeField(int nodeId) {
-        return mainGraph.getAdditionalNodeField(nodeId);
-    }
+        @Override
+        public boolean is3D()
+        {
+            return mainNodeAccess.is3D();
+        }
+
+        @Override
+        public int getDimension()
+        {
+            return mainNodeAccess.getDimension();
+        }
+
+        @Override
+        public double getLatitude( int nodeId )
+        {
+            if (isVirtualNode(nodeId))
+                return virtualNodes.getLatitude(nodeId - mainNodes);
+            return mainNodeAccess.getLatitude(nodeId);
+        }
+
+        @Override
+        public double getLongitude( int nodeId )
+        {
+            if (isVirtualNode(nodeId))
+                return virtualNodes.getLongitude(nodeId - mainNodes);
+            return mainNodeAccess.getLongitude(nodeId);
+        }
+
+        @Override
+        public double getElevation( int nodeId )
+        {
+            if (isVirtualNode(nodeId))
+                return virtualNodes.getElevation(nodeId - mainNodes);
+            return mainNodeAccess.getElevation(nodeId);
+        }
+
+        @Override
+        public int getAdditionalNodeField( int nodeId )
+        {
+            if (isVirtualNode(nodeId))
+                return 0;
+            return mainNodeAccess.getAdditionalNodeField(nodeId);
+        }
+
+        @Override
+        public void setNode( int nodeId, double lat, double lon )
+        {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        @Override
+        public void setNode( int nodeId, double lat, double lon, double ele )
+        {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        @Override
+        public void setAdditionalNodeField( int nodeId, int additionalValue )
+        {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        @Override
+        public double getLat( int nodeId )
+        {
+            return getLatitude(nodeId);
+        }
+
+        @Override
+        public double getLon( int nodeId )
+        {
+            return getLongitude(nodeId);
+        }
+
+        @Override
+        public double getEle( int nodeId )
+        {
+            return getElevation(nodeId);
+        }
+    };
 
     @Override
-    public BBox getBounds() {
+    public BBox getBounds()
+    {
         return mainGraph.getBounds();
     }
 
     @Override
-    public EdgeIteratorState getEdgeProps(int origEdgeId, int adjNode) {
-        if (origEdgeId < mainEdges)
+    public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
+    {
+        if (!isVirtualEdge(origEdgeId))
             return mainGraph.getEdgeProps(origEdgeId, adjNode);
 
         int edgeId = origEdgeId - mainEdges;
         EdgeIteratorState eis = virtualEdges.get(edgeId);
-        if (eis.getAdjNode() == adjNode)
+        if (eis.getAdjNode() == adjNode || adjNode == Integer.MIN_VALUE)
             return eis;
 
         // find reverse edge via convention. see virtualEdges comment above
@@ -299,7 +487,8 @@ public EdgeIteratorState getEdgeProps(int origEdgeId, int adjNode) {
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer(final EdgeFilter edgeFilter) {
+    public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
+    {
         if (!isInitialized())
             throw new IllegalStateException("Call lookup before using this graph");
 
@@ -307,14 +496,15 @@ public EdgeExplorer createEdgeExplorer(final EdgeFilter edgeFilter) {
         // so we need to create the mapping on EVERY call!
         // This needs to be a HashMap (and cannot be an array) as we also need to tweak edges for some mainNodes!
         // The more query points we have the more inefficient this map could be. Hmmh.
-        final TIntObjectMap<VirtualEdgeIterator> node2EdgeIter
+        final TIntObjectMap<VirtualEdgeIterator> node2EdgeMap
                 = new TIntObjectHashMap<VirtualEdgeIterator>(queryResults.size() * 3);
 
         final EdgeExplorer mainExplorer = mainGraph.createEdgeExplorer(edgeFilter);
         final TIntHashSet towerNodesToChange = new TIntHashSet(queryResults.size());
 
         // 1. virtualEdges should also get fresh EdgeIterators on every createEdgeExplorer call!        
-        for (int i = 0; i < queryResults.size(); i++) {
+        for (int i = 0; i < queryResults.size(); i++)
+        {
             // create outgoing edges
             VirtualEdgeIterator virtEdgeIter = new VirtualEdgeIterator(2);
             EdgeIteratorState baseRevEdge = virtualEdges.get(i * 4 + VE_BASE_REV);
@@ -325,39 +515,47 @@ public EdgeExplorer createEdgeExplorer(final EdgeFilter edgeFilter) {
                 virtEdgeIter.add(adjEdge);
 
             int virtNode = mainNodes + i;
-            node2EdgeIter.put(virtNode, virtEdgeIter);
+            node2EdgeMap.put(virtNode, virtEdgeIter);
 
-            // replace edge list of neighboring tower nodes: a) add virtual edges only and collect tower nodes where real edges will be added in step 2.
+            // replace edge list of neighboring tower nodes: 
+            // add virtual edges only and collect tower nodes where real edges will be added in step 2.
+            //
             // base node
             int towerNode = baseRevEdge.getAdjNode();
-            if (towerNode < mainNodes) {
+            if (!isVirtualNode(towerNode))
+            {
                 towerNodesToChange.add(towerNode);
-                addVirtualEdges(node2EdgeIter, edgeFilter, true, towerNode, i);
+                addVirtualEdges(node2EdgeMap, edgeFilter, true, towerNode, i);
             }
 
             // adj node
             towerNode = adjEdge.getAdjNode();
-            if (towerNode < mainNodes) {
+            if (!isVirtualNode(towerNode))
+            {
                 towerNodesToChange.add(towerNode);
-                addVirtualEdges(node2EdgeIter, edgeFilter, false, towerNode, i);
+                addVirtualEdges(node2EdgeMap, edgeFilter, false, towerNode, i);
             }
         }
 
         // 2. the connected tower nodes from mainGraph need fresh EdgeIterators with possible fakes
         // where 'fresh' means independent of previous call and respecting the edgeFilter
         // -> setup fake iterators of detected tower nodes (virtual edges are already added)
-        towerNodesToChange.forEach(new TIntProcedure() {
+        towerNodesToChange.forEach(new TIntProcedure()
+        {
             @Override
-            public boolean execute(int value) {
-                fillVirtualEdges(node2EdgeIter, value, mainExplorer);
+            public boolean execute( int value )
+            {
+                fillVirtualEdges(node2EdgeMap, value, mainExplorer);
                 return true;
             }
         });
 
-        return new EdgeExplorer() {
+        return new EdgeExplorer()
+        {
             @Override
-            public EdgeIterator setBaseNode(int baseNode) {
-                VirtualEdgeIterator iter = node2EdgeIter.get(baseNode);
+            public EdgeIterator setBaseNode( int baseNode )
+            {
+                VirtualEdgeIterator iter = node2EdgeMap.get(baseNode);
                 if (iter != null)
                     return iter.reset();
 
@@ -369,12 +567,14 @@ public EdgeIterator setBaseNode(int baseNode) {
     /**
      * Creates a fake edge iterator pointing to multiple edge states.
      */
-    private void addVirtualEdges(TIntObjectMap<VirtualEdgeIterator> node2Edge, EdgeFilter filter, boolean base,
-            int node, int virtNode) {
-        VirtualEdgeIterator existingIter = node2Edge.get(node);
-        if (existingIter == null) {
+    private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, EdgeFilter filter, boolean base,
+            int node, int virtNode )
+    {
+        VirtualEdgeIterator existingIter = node2EdgeMap.get(node);
+        if (existingIter == null)
+        {
             existingIter = new VirtualEdgeIterator(10);
-            node2Edge.put(node, existingIter);
+            node2EdgeMap.put(node, existingIter);
         }
         EdgeIteratorState edge = base
                 ? virtualEdges.get(virtNode * 4 + VE_BASE)
@@ -383,329 +583,75 @@ private void addVirtualEdges(TIntObjectMap<VirtualEdgeIterator> node2Edge, EdgeF
             existingIter.add(edge);
     }
 
-    void fillVirtualEdges(TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl) {
-        if (towerNode >= mainNodes)
-            throw new IllegalStateException("should not happen:" + towerNode + ", " + node2Edge);
+    void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
+    {
+        if (isVirtualNode(towerNode))
+            throw new IllegalStateException("Node should not be virtual:" + towerNode + ", " + node2Edge);
 
         VirtualEdgeIterator vIter = node2Edge.get(towerNode);
-        TIntArrayList ignoreNodes = new TIntArrayList(vIter.count() * 2);
-        while (vIter.next()) {
-            ignoreNodes.add(queryResults.get(vIter.getAdjNode() - mainNodes).getClosestEdge().getAdjNode());
+        TIntArrayList ignoreEdges = new TIntArrayList(vIter.count() * 2);
+        while (vIter.next())
+        {
+            EdgeIteratorState edge = queryResults.get(vIter.getAdjNode() - mainNodes).getClosestEdge();
+            ignoreEdges.add(edge.getEdge());
         }
         vIter.reset();
         EdgeIterator iter = mainExpl.setBaseNode(towerNode);
-        while (iter.next()) {
-            if (!ignoreNodes.contains(iter.getAdjNode()))
-                vIter.add(iter.detach());
+        while (iter.next())
+        {
+            if (!ignoreEdges.contains(iter.getEdge()))
+                vIter.add(iter.detach(false));
         }
     }
 
-    private boolean isInitialized() {
+    private boolean isInitialized()
+    {
         return queryResults != null;
     }
 
     @Override
-    public EdgeExplorer createEdgeExplorer() {
+    public EdgeExplorer createEdgeExplorer()
+    {
         return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     @Override
-    public AllEdgesIterator getAllEdges() {
+    public AllEdgesIterator getAllEdges()
+    {
         throw new UnsupportedOperationException("Not supported yet.");
     }
 
     @Override
-    public void setNode(int node, double lat, double lon) {
+    public EdgeIteratorState edge( int a, int b )
+    {
         throw exc();
     }
 
-    @Override
-    public void setAdditionalNodeField(int nodeId, int additionalValue) {
-        exc();
-    }
-
-    @Override
-    public EdgeIteratorState edge(int a, int b) {
+    public EdgeIteratorState edge( int a, int b, double distance, int flags )
+    {
         throw exc();
     }
 
-    public EdgeIteratorState edge(int a, int b, double distance, int flags) {
+    @Override
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
+    {
         throw exc();
     }
 
     @Override
-    public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
+    public Graph copyTo( Graph g )
+    {
         throw exc();
     }
 
     @Override
-    public Graph copyTo(Graph g) {
-        throw exc();
+    public GraphExtension getExtension()
+    {
+        return wrappedExtension;
     }
 
-    private UnsupportedOperationException exc() {
+    private UnsupportedOperationException exc()
+    {
         return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
-
-    static class VirtualEdgeIterator implements EdgeIterator {
-
-        private final List<EdgeIteratorState> edges;
-        private int current;
-
-        public VirtualEdgeIterator(int edgeCount) {
-            edges = new ArrayList<EdgeIteratorState>(edgeCount);
-            reset();
-        }
-
-        void add(EdgeIteratorState edge) {
-            edges.add(edge);
-        }
-
-        EdgeIterator reset() {
-            current = -1;
-            return this;
-        }
-
-        int count() {
-            return edges.size();
-        }
-
-        @Override
-        public boolean next() {
-            current++;
-            return current < edges.size();
-        }
-
-        @Override
-        public EdgeIteratorState detach() {
-            return edges.get(current);
-        }
-
-        @Override
-        public int getEdge() {
-            return edges.get(current).getEdge();
-        }
-
-        @Override
-        public int getBaseNode() {
-            return edges.get(current).getBaseNode();
-        }
-
-        @Override
-        public int getAdjNode() {
-            return edges.get(current).getAdjNode();
-        }
-
-        @Override
-        public PointList fetchWayGeometry(int mode) {
-            return edges.get(current).fetchWayGeometry(mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry(PointList list) {
-            return edges.get(current).setWayGeometry(list);
-        }
-
-        @Override
-        public double getDistance() {
-            return edges.get(current).getDistance();
-        }
-
-        @Override
-        public EdgeIteratorState setDistance(double dist) {
-            return edges.get(current).setDistance(dist);
-        }
-
-        @Override
-        public long getFlags() {
-            return edges.get(current).getFlags();
-        }
-
-        @Override
-        public EdgeIteratorState setFlags(long flags) {
-            return edges.get(current).setFlags(flags);
-        }
-
-        @Override
-        public String getName() {
-            return edges.get(current).getName();
-        }
-
-        @Override
-        public EdgeIteratorState setName(String name) {
-            return edges.get(current).setName(name);
-        }
-
-        @Override
-        public String toString() {
-            return edges.toString();
-        }
-
-        @Override
-        public int getAdditionalField() {
-            return edges.get(current).getAdditionalField();
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField(int value) {
-            return edges.get(current).setAdditionalField(value);
-        }
-
-        @Override
-        public void copyProperties( EdgeIteratorState edge )
-        {
-            edges.get(current).copyProperties(edge);
-        }
-    }
-
-    /**
-     * Creates an edge state decoupled from a graph where nodes, pointList, etc
-     * are kept in memory.
-     */
-    private static class VirtualEdgeIState implements EdgeIteratorState, /* for isShortcut only: */ EdgeSkipIterator {
-
-        private final PointList pointList;
-        private final int edgeId;
-        private double distance;
-        private long flags;
-        private String name;
-        private final int baseNode;
-        private final int adjNode;
-
-        public VirtualEdgeIState(int edgeId, int baseNode, int adjNode,
-                double distance, long flags, String name, PointList pointList) {
-            this.edgeId = edgeId;
-            this.baseNode = baseNode;
-            this.adjNode = adjNode;
-            this.distance = distance;
-            this.flags = flags;
-            this.name = name;
-            this.pointList = pointList;
-        }
-
-        @Override
-        public int getEdge() {
-            return edgeId;
-        }
-
-        @Override
-        public int getBaseNode() {
-            return baseNode;
-        }
-
-        @Override
-        public int getAdjNode() {
-            return adjNode;
-        }
-
-        @Override
-        public PointList fetchWayGeometry(int mode) {
-            if (pointList.getSize() == 0)
-                return PointList.EMPTY;
-
-            // due to API we need to create a new instance per call!
-            if (mode == 3)
-                return pointList.clone(false);
-            else if (mode == 1)
-                return pointList.copy(0, pointList.getSize() - 1);
-            else if (mode == 2)
-                return pointList.copy(1, pointList.getSize());
-            else if (mode == 0) {
-                if (pointList.getSize() == 1)
-                    return PointList.EMPTY;
-                return pointList.copy(1, pointList.getSize() - 1);
-            }
-
-            throw new UnsupportedOperationException("Illegal mode:" + mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry(PointList list) {
-            throw new UnsupportedOperationException("Not supported for in-memory edge. Set when creating it.");
-        }
-
-        @Override
-        public double getDistance() {
-            return distance;
-        }
-
-        @Override
-        public EdgeIteratorState setDistance(double dist) {
-            this.distance = dist;
-            return this;
-        }
-
-        @Override
-        public long getFlags() {
-            return flags;
-        }
-
-        @Override
-        public EdgeIteratorState setFlags(long flags) {
-            this.flags = flags;
-            return this;
-        }
-
-        @Override
-        public String getName() {
-            return name;
-        }
-
-        @Override
-        public EdgeIteratorState setName(String name) {
-            this.name = name;
-            return this;
-        }
-
-        @Override
-        public String toString() {
-            return baseNode + "->" + adjNode;
-        }
-
-        @Override
-        public boolean isShortcut() {
-            return false;
-        }
-
-        @Override
-        public int getAdditionalField() {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge1() {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge2() {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public void setSkippedEdges(int edge1, int edge2) {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public boolean next() {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState detach() {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField(int value) {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public void copyProperties( EdgeIteratorState edge )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index b1ee8174c5..b7a5abf53c 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.NotThreadSafe;
 
 /**
@@ -36,15 +35,10 @@
     Path calcPath( int from, int to );
 
     /**
-     * Calculates the best path between the specified query results from GPS lookup.
-     * <p/>
-     * Note: The underlying implementation introduces a state of the algorithm and so it is tightly
-     * coupled to the query! Reusing this instance should be done carefully: only from within one
-     * thread and only via this calcPath method.
-     * <p/>
-     * @return the path. Call the method found() to make sure that the path is valid.
+     * Limits the search to avoid full graph exploration in the case of disconnected networks. The
+     * default value is Double.MAX_VALUE. See #104
      */
-    Path calcPath( QueryResult from, QueryResult to );
+    void setWeightLimit( double weight );
 
     /**
      * @return name of this algorithm
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
index 512c772f46..58d0f17a3a 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
@@ -17,48 +17,12 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 
 /**
  * @author Peter Karich
  */
-public class RoutingAlgorithmFactory
+public interface RoutingAlgorithmFactory
 {
-    private String algoStr;
-    private boolean approx;
-
-    /**
-     * @param algo possible values are astar (A* algorithm), astarbi (bidirectional A*) dijkstra
-     * (Dijkstra), dijkstrabi and dijkstraNative (a bit faster bidirectional Dijkstra).
-     */
-    public RoutingAlgorithmFactory( String algo, boolean approx )
-    {
-        this.algoStr = algo;
-        this.approx = approx;
-    }
-
-    public RoutingAlgorithm createAlgo( Graph g, FlagEncoder encoder, Weighting weighting )
-    {
-        if ("dijkstrabi".equalsIgnoreCase(algoStr))
-        {
-            return new DijkstraBidirectionRef(g, encoder, weighting);
-        } else if ("dijkstraNative".equalsIgnoreCase(algoStr))
-        {
-            return new DijkstraBidirection(g, encoder, weighting);
-        } else if ("dijkstra".equalsIgnoreCase(algoStr))
-        {
-            return new Dijkstra(g, encoder, weighting);
-        } else if ("astarbi".equalsIgnoreCase(algoStr))
-        {
-            return new AStarBidirection(g, encoder, weighting).setApproximation(approx);
-        } else if ("dijkstraOneToMany".equalsIgnoreCase(algoStr))
-        {
-            return new DijkstraOneToMany(g, encoder, weighting);
-        } else
-        {
-            return new AStar(g, encoder, weighting);
-        }
-    }
+    RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts );   
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
new file mode 100644
index 0000000000..ae6609148f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -0,0 +1,84 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.BeelineWeightApproximator;
+import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.Helper;
+
+/**
+ * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
+ * <p>
+ * @author Peter Karich
+ */
+public class RoutingAlgorithmFactorySimple implements RoutingAlgorithmFactory
+{
+    @Override
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {        
+        AbstractRoutingAlgorithm algo;
+        String algoStr = opts.getAlgorithm();
+        if (AlgorithmOptions.DIJKSTRA_BI.equalsIgnoreCase(algoStr))
+        {
+            return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.DIJKSTRA.equalsIgnoreCase(algoStr))
+        {
+            return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.ASTAR_BI.equalsIgnoreCase(algoStr))
+        {
+            AStarBidirection aStarBi = new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(),
+                    opts.getTraversalMode());
+            aStarBi.setApproximation(getApproximation(AlgorithmOptions.ASTAR_BI, opts, g.getNodeAccess()));
+            return aStarBi;
+        } else if (AlgorithmOptions.DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr))
+        {
+            return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.ASTAR.equalsIgnoreCase(algoStr))
+        {
+            AStar aStar = new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+            aStar.setApproximation(getApproximation(AlgorithmOptions.ASTAR, opts, g.getNodeAccess()));
+            return aStar;
+        } else
+        {
+            throw new IllegalArgumentException("Algorithm " + algoStr + " not found in " + getClass().getName());
+        }
+
+    }
+
+    private WeightApproximator getApproximation( String prop, AlgorithmOptions opts, NodeAccess na )
+    {
+        String approxAsStr = opts.getHints().get(prop + ".approximation", "BeelineSimplification");
+        if ("BeelineSimplification".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_PLANE);
+            return approx;
+
+        } else if ("BeelineAccurate".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_EARTH);
+            return approx;
+        } else
+        {
+            throw new IllegalArgumentException("Approximation " + approxAsStr + " not found in " + getClass().getName());
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
new file mode 100644
index 0000000000..9552052d02
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.PointList;
+
+/**
+ * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
+ */
+class VirtualEdgeIState implements EdgeIteratorState, EdgeSkipIterState {
+    private final PointList pointList;
+    private final int edgeId;
+    private double distance;
+    private long flags;
+    private String name;
+    private final int baseNode;
+    private final int adjNode;
+
+    public VirtualEdgeIState( int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
+    {
+        this.edgeId = edgeId;
+        this.baseNode = baseNode;
+        this.adjNode = adjNode;
+        this.distance = distance;
+        this.flags = flags;
+        this.name = name;
+        this.pointList = pointList;
+    }
+
+    @Override
+    public int getEdge()
+    {
+        return edgeId;
+    }
+
+    @Override
+    public int getBaseNode()
+    {
+        return baseNode;
+    }
+
+    @Override
+    public int getAdjNode()
+    {
+        return adjNode;
+    }
+
+    @Override
+    public PointList fetchWayGeometry( int mode )
+    {
+        if (pointList.getSize() == 0)
+            return PointList.EMPTY;
+        // due to API we need to create a new instance per call!
+        if (mode == 3)
+            return pointList.clone(false);
+        else if (mode == 1)
+            return pointList.copy(0, pointList.getSize() - 1);
+        else if (mode == 2)
+            return pointList.copy(1, pointList.getSize());
+        else if (mode == 0)
+        {
+            if (pointList.getSize() == 1)
+                return PointList.EMPTY;
+            return pointList.copy(1, pointList.getSize() - 1);
+        }
+        throw new UnsupportedOperationException("Illegal mode:" + mode);
+    }
+
+    @Override
+    public EdgeIteratorState setWayGeometry( PointList list )
+    {
+        throw new UnsupportedOperationException("Not supported for virtual edge. Set when creating it.");
+    }
+
+    @Override
+    public double getDistance()
+    {
+        return distance;
+    }
+
+    @Override
+    public EdgeIteratorState setDistance( double dist )
+    {
+        this.distance = dist;
+        return this;
+    }
+
+    @Override
+    public long getFlags()
+    {
+        return flags;
+    }
+
+    @Override
+    public EdgeIteratorState setFlags( long flags )
+    {
+        this.flags = flags;
+        return this;
+    }
+
+    @Override
+    public String getName()
+    {
+        return name;
+    }
+
+    @Override
+    public EdgeIteratorState setName( String name )
+    {
+        this.name = name;
+        return this;
+    }
+
+    @Override
+    public String toString()
+    {
+        return baseNode + "->" + adjNode;
+    }
+
+    @Override
+    public boolean isShortcut()
+    {
+        return false;
+    }
+
+    @Override
+    public int getAdditionalField()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge1()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge2()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setSkippedEdges( int edge1, int edge2 )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState detach( boolean reverse )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField( int value )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeSkipIterState setWeight( double weight )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public double getWeight()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+    
+}
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
new file mode 100644
index 0000000000..22abb0004f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.PointList;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ *
+ * @author Peter Karich
+ */
+class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState {
+    private final List<EdgeIteratorState> edges;
+    private int current;
+
+    public VirtualEdgeIterator( int edgeCount )
+    {
+        edges = new ArrayList<EdgeIteratorState>(edgeCount);
+        reset();
+    }
+
+    void add( EdgeIteratorState edge )
+    {
+        edges.add(edge);
+    }
+
+    EdgeIterator reset()
+    {
+        current = -1;
+        return this;
+    }
+
+    int count()
+    {
+        return edges.size();
+    }
+
+    @Override
+    public boolean next()
+    {
+        current++;
+        return current < edges.size();
+    }
+
+    @Override
+    public EdgeIteratorState detach( boolean reverse )
+    {
+        if (reverse)
+            throw new IllegalStateException("Not yet supported");
+        return edges.get(current);
+    }
+
+    @Override
+    public int getEdge()
+    {
+        return edges.get(current).getEdge();
+    }
+
+    @Override
+    public int getBaseNode()
+    {
+        return edges.get(current).getBaseNode();
+    }
+
+    @Override
+    public int getAdjNode()
+    {
+        return edges.get(current).getAdjNode();
+    }
+
+    @Override
+    public PointList fetchWayGeometry( int mode )
+    {
+        return edges.get(current).fetchWayGeometry(mode);
+    }
+
+    @Override
+    public EdgeIteratorState setWayGeometry( PointList list )
+    {
+        return edges.get(current).setWayGeometry(list);
+    }
+
+    @Override
+    public double getDistance()
+    {
+        return edges.get(current).getDistance();
+    }
+
+    @Override
+    public EdgeIteratorState setDistance( double dist )
+    {
+        return edges.get(current).setDistance(dist);
+    }
+
+    @Override
+    public long getFlags()
+    {
+        return edges.get(current).getFlags();
+    }
+
+    @Override
+    public EdgeIteratorState setFlags( long flags )
+    {
+        return edges.get(current).setFlags(flags);
+    }
+
+    @Override
+    public String getName()
+    {
+        return edges.get(current).getName();
+    }
+
+    @Override
+    public EdgeIteratorState setName( String name )
+    {
+        return edges.get(current).setName(name);
+    }
+
+    @Override
+    public String toString()
+    {
+        return edges.toString();
+    }
+
+    @Override
+    public int getAdditionalField()
+    {
+        return edges.get(current).getAdditionalField();
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField( int value )
+    {
+        return edges.get(current).setAdditionalField(value);
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+    {
+        return edges.get(current).copyPropertiesTo(edge);
+    }
+
+    @Override
+    public boolean isShortcut()
+    {
+        EdgeIteratorState edge = edges.get(current);
+        return edge instanceof EdgeSkipIterState && ((EdgeSkipIterState) edge).isShortcut();
+    }
+
+    @Override
+    public double getWeight()
+    {
+        // will be called only from PreparationWeighting and if isShortcut is true
+        return ((EdgeSkipIterState) edges.get(current)).getWeight();
+    }
+
+    @Override
+    public EdgeSkipIterState setWeight( double weight )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge1()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge2()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setSkippedEdges( int edge1, int edge2 )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+    
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index ea3ea48a8d..fe8163b088 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -19,9 +19,7 @@
 
 import com.graphhopper.routing.PathBidirRef;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.EdgeSkipIterState;
 
 /**
@@ -32,36 +30,30 @@
  */
 public class Path4CH extends PathBidirRef
 {
-    private final Weighting calc;
+    private final Graph routingGraph;
 
-    public Path4CH( Graph g, FlagEncoder encoder, Weighting calc )
+    public Path4CH( Graph routingGraph, Graph baseGraph, FlagEncoder encoder )
     {
-        super(g, encoder);
-        this.calc = calc;
+        super(baseGraph, encoder);
+        this.routingGraph = routingGraph;
     }
 
     @Override
-    protected void processEdge( int tmpEdge, int endNode )
+    protected final void processEdge( int tmpEdge, int endNode )
     {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((EdgeSkipIterState) graph.getEdgeProps(tmpEdge, endNode), false);
+        expandEdge((EdgeSkipIterState) routingGraph.getEdgeProps(tmpEdge, endNode), false);
     }
 
-    @Override
-    public double calcDistance( EdgeIteratorState mainIter )
-    {
-        return calc.revertWeight(mainIter, mainIter.getDistance());
-    }
-
-    private void expandEdge( EdgeSkipIterState mainEdgeState, boolean revert )
+    private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
     {
         if (!mainEdgeState.isShortcut())
         {
-            double dist = calcDistance(mainEdgeState);
+            double dist = mainEdgeState.getDistance();
             distance += dist;
             long flags = mainEdgeState.getFlags();
-            millis += calcMillis(dist, flags);
+            millis += calcMillis(dist, flags, reverse);
             addEdge(mainEdgeState.getEdge());
             return;
         }
@@ -69,7 +61,9 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean revert )
         int skippedEdge1 = mainEdgeState.getSkippedEdge1();
         int skippedEdge2 = mainEdgeState.getSkippedEdge2();
         int from = mainEdgeState.getBaseNode(), to = mainEdgeState.getAdjNode();
-        if (revert)
+
+        // get properties like speed of the edge in the correct direction
+        if (reverse)
         {
             int tmp = from;
             from = to;
@@ -79,32 +73,32 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean revert )
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
         if (reverseOrder)
         {
-            EdgeSkipIterState edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+            EdgeSkipIterState edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             boolean empty = edgeState == null;
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(edgeState, false);
 
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             else
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(edgeState, true);
         } else
         {
-            EdgeSkipIterState iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+            EdgeSkipIterState iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             boolean empty = iter == null;
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(iter, true);
 
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             else
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(iter, false);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
new file mode 100644
index 0000000000..9fa3bf8ed4
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -0,0 +1,63 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+
+/**
+ * Used in CH preparation and therefor assumed that all edges are of type EdgeSkipIterState
+ * <p>
+ * @author Peter Karich
+ */
+public class PreparationWeighting implements Weighting
+{
+    private final Weighting userWeighting;
+
+    public PreparationWeighting( Weighting userWeighting )
+    {
+        this.userWeighting = userWeighting;
+    }
+
+    @Override
+    public final double getMinWeight( double distance )
+    {
+        return userWeighting.getMinWeight(distance);
+    }
+
+    @Override
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+    {
+        if (edgeState instanceof EdgeSkipIterState)
+        {
+            EdgeSkipIterState tmp = (EdgeSkipIterState) edgeState;
+            if (tmp.isShortcut())
+                // if a shortcut is in both directions the weight is identical => no need for 'reverse'
+                return tmp.getWeight();
+        }
+        return userWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+    }
+
+    @Override
+    public String toString()
+    {
+        return "PREPARE+" + userWeighting.toString();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 1d441c236f..4f34c750ae 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -23,12 +23,7 @@
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.LevelEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.ShortestWeighting;
 import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.routing.AStarBidirection;
-import com.graphhopper.routing.DijkstraBidirectionRef;
-import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.RoutingAlgorithm;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.DAType;
@@ -36,6 +31,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.LevelGraphStorage;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import java.util.*;
 import org.slf4j.Logger;
@@ -53,68 +49,57 @@
  * <p/>
  * @author Peter Karich
  */
-public class PrepareContractionHierarchies extends AbstractAlgoPreparation<PrepareContractionHierarchies>
+public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    // preparation dijkstra uses always shortest path as edges are rewritten - see doWork
-    private final Weighting shortestWeighting = new ShortestWeighting();
-    private final Weighting prepareWeighting;
-    private final FlagEncoder prepareEncoder;
+    private final PreparationWeighting prepareWeighting;
+    private final FlagEncoder prepareFlagEncoder;
+    private final TraversalMode traversalMode;
     private EdgeSkipExplorer vehicleInExplorer;
     private EdgeSkipExplorer vehicleOutExplorer;
     private EdgeSkipExplorer vehicleAllExplorer;
     private EdgeSkipExplorer vehicleAllTmpExplorer;
     private EdgeSkipExplorer calcPrioAllExplorer;
-    private LevelGraph g;
+    private final LevelEdgeFilter levelFilter;
+    private int maxLevel;
+    private final LevelGraph prepareGraph;
+
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
-    private int oldPriorities[];    
+    private int oldPriorities[];
     private final DataAccess originalEdges;
-    // shortcut is one direction, speed is only involved while recalculating the endNode weights - see prepareEdges
-    private final long scOneDir;
-    private final long scBothDir;
     private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
-    private IgnoreNodeFilter levelEdgeFilter;
-    private DijkstraOneToMany algo;
-    private boolean removesHigher2LowerEdges = true;
+    private IgnoreNodeFilter ignoreNodeFilter;
+    private DijkstraOneToMany prepareAlgo;
     private long counter;
     private int newShortcuts;
     private long dijkstraCount;
     private double meanDegree;
     private final Random rand = new Random(123);
     private StopWatch dijkstraSW = new StopWatch();
+    private final StopWatch allSW = new StopWatch();
     private int periodicUpdatesPercentage = 20;
     private int lastNodesLazyUpdatePercentage = 10;
-    private final StopWatch allSW = new StopWatch();
-    private int neighborUpdatePercentage = 10;
-    private int initialCollectionSize = 10000;
+    private int neighborUpdatePercentage = 20;
+    private int initialCollectionSize = 5000;
+    private double nodesContractedPercentage = 100;
     private double logMessagesPercentage = 20;
 
-    public PrepareContractionHierarchies( FlagEncoder encoder, Weighting weighting )
+    public PrepareContractionHierarchies( LevelGraph g, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
     {
-        prepareEncoder = encoder;
-        scOneDir = encoder.setAccess(0, true, false);
-        scBothDir = encoder.setAccess(0, true, true);
-        prepareWeighting = weighting;
-        originalEdges = new GHDirectory("", DAType.RAM_INT).find("originalEdges");
-        originalEdges.create(1000);
-    }
-
-    @Override
-    public PrepareContractionHierarchies setGraph( Graph g )
-    {
-        this.g = (LevelGraph) g;
-        return this;
-    }
+        this.prepareGraph = g;
+        this.traversalMode = traversalMode;
+        this.prepareFlagEncoder = encoder;
+        long scFwdDir = encoder.setAccess(0, true, false);
+        levelFilter = new LevelEdgeFilter(prepareGraph);
 
-    long getScBothDir()
-    {
-        return scBothDir;
-    }
+        // shortcuts store weight in flags where we assume bit 1 and 2 are used for access restriction
+        if ((scFwdDir & PrepareEncoder.getScFwdDir()) == 0)
+            throw new IllegalArgumentException("Enabling the speed-up mode is currently only supported for the first vehicle.");
 
-    long getScOneDir()
-    {
-        return scOneDir;
+        prepareWeighting = new PreparationWeighting(weighting);
+        originalEdges = new GHDirectory("", DAType.RAM_INT).find("original_edges");
+        originalEdges.create(1000);
     }
 
     /**
@@ -127,7 +112,9 @@ long getScOneDir()
     public PrepareContractionHierarchies setPeriodicUpdates( int periodicUpdates )
     {
         if (periodicUpdates < 0)
-            throw new IllegalArgumentException("periodicUpdates has to be in [0, 100]. To disable it use 0");
+            return this;
+        if (periodicUpdates > 100)
+            throw new IllegalArgumentException("periodicUpdates has to be in [0, 100], to disable it use 0");
 
         this.periodicUpdatesPercentage = periodicUpdates;
         return this;
@@ -139,7 +126,10 @@ public PrepareContractionHierarchies setPeriodicUpdates( int periodicUpdates )
      */
     public PrepareContractionHierarchies setLazyUpdates( int lazyUpdates )
     {
-        if (lazyUpdates < 0 || lazyUpdates > 100)
+        if (lazyUpdates < 0)
+            return this;
+
+        if (lazyUpdates > 100)
             throw new IllegalArgumentException("lazyUpdates has to be in [0, 100], to disable it use 0");
 
         this.lastNodesLazyUpdatePercentage = lazyUpdates;
@@ -151,7 +141,10 @@ public PrepareContractionHierarchies setLazyUpdates( int lazyUpdates )
      */
     public PrepareContractionHierarchies setNeighborUpdates( int neighborUpdates )
     {
-        if (neighborUpdates < 0 || neighborUpdates > 100)
+        if (neighborUpdates < 0)
+            return this;
+
+        if (neighborUpdates > 100)
             throw new IllegalArgumentException("neighborUpdates has to be in [0, 100], to disable it use 0");
 
         this.neighborUpdatePercentage = neighborUpdates;
@@ -164,20 +157,21 @@ public PrepareContractionHierarchies setNeighborUpdates( int neighborUpdates )
      */
     public PrepareContractionHierarchies setLogMessages( double logMessages )
     {
-        this.logMessagesPercentage = logMessages;
+        if (logMessages >= 0)
+            this.logMessagesPercentage = logMessages;
         return this;
     }
 
     /**
-     * Disconnect is very important to improve query time and preparation if enabled. It will remove
-     * the edge going from the higher level node to the currently contracted one. But the original
-     * graph is no longer available, so it is only useful for bidirectional CH algorithms. Default
-     * is true.
+     * Define how many nodes (percentage) should be contracted. Less nodes means slower query but
+     * faster contraction duration. Not yet ready for prime time.
      */
-    public PrepareContractionHierarchies setRemoveHigher2LowerEdges( boolean removeHigher2LowerEdges )
+    void setNodesContracted( double nodesContracted )
     {
-        this.removesHigher2LowerEdges = removeHigher2LowerEdges;
-        return this;
+        if (nodesContracted > 100)
+            throw new IllegalArgumentException("setNodesContracted can be 100% maximum");
+
+        this.nodesContractedPercentage = nodesContracted;
     }
 
     /**
@@ -191,10 +185,9 @@ public void setInitialCollectionSize( int initialCollectionSize )
     }
 
     @Override
-    public PrepareContractionHierarchies doWork()
+    public void doWork()
     {
-        checkGraph();
-        if (prepareEncoder == null)
+        if (prepareFlagEncoder == null)
             throw new IllegalStateException("No vehicle encoder set.");
 
         if (prepareWeighting == null)
@@ -205,40 +198,35 @@ public PrepareContractionHierarchies doWork()
 
         initFromGraph();
         if (!prepareEdges())
-            return this;
+            return;
 
         if (!prepareNodes())
-            return this;
+            return;
 
         contractNodes();
-        return this;
     }
 
     boolean prepareEdges()
     {
-        // In CH the setProperties (speed) are ignored as calculating the new setProperties for a shortcut is often not possible.
-        // Also several shortcuts would be necessary with the different modes (e.g. fastest and shortest)
-        // So calculate the weight and store this as weight, then use only weight instead of calcWeight
-        EdgeIterator iter = g.getAllEdges();
+        EdgeIterator iter = prepareGraph.getAllEdges();
         int c = 0;
         while (iter.next())
         {
             c++;
-            iter.setDistance(prepareWeighting.calcWeight(iter));
             setOrigEdgeCount(iter.getEdge(), 1);
         }
         return c > 0;
     }
 
-    // TODO we can avoid node level if we store this into a temporary array and 
-    // disconnect all edges which goes from higher to lower level
-    // uninitialized nodes have a level of 0
-    // TODO we could avoid the second storage for skippedEdge as we could store that info into linkB or A if it is disconnected
     boolean prepareNodes()
     {
-        int len = g.getNodes();
-        
-        for (int node = 0; node < len; node++)
+        int nodes = prepareGraph.getNodes();
+        for (int node = 0; node < nodes; node++)
+        {
+            prepareGraph.setLevel(node, maxLevel);
+        }
+
+        for (int node = 0; node < nodes; node++)
         {
             int priority = oldPriorities[node] = calculatePriority(node);
             sortedNodes.insert(node, priority);
@@ -252,11 +240,11 @@ boolean prepareNodes()
 
     void contractNodes()
     {
-        meanDegree = g.getAllEdges().getMaxId() / g.getNodes();
+        meanDegree = prepareGraph.getAllEdges().getCount() / prepareGraph.getNodes();
         int level = 1;
         counter = 0;
         int initSize = sortedNodes.getSize();
-        int logSize = (int) Math.round(Math.max(10, sortedNodes.getSize() / 100 * logMessagesPercentage));
+        long logSize = Math.round(Math.max(10, sortedNodes.getSize() / 100 * logMessagesPercentage));
         if (logMessagesPercentage == 0)
             logSize = Integer.MAX_VALUE;
 
@@ -265,14 +253,18 @@ void contractNodes()
         boolean periodicUpdate = true;
         StopWatch periodSW = new StopWatch();
         int updateCounter = 0;
-        int periodicUpdatesCount = Math.max(10, sortedNodes.getSize() / 100 * periodicUpdatesPercentage);
+        long periodicUpdatesCount = Math.round(Math.max(10, sortedNodes.getSize() / 100d * periodicUpdatesPercentage));
         if (periodicUpdatesPercentage == 0)
             periodicUpdate = false;
 
         // disable as preparation is slower and query time does not benefit
-        int lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
-                ? 0
-                : sortedNodes.getSize() / 100 * lastNodesLazyUpdatePercentage;
+        long lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
+                ? 0L
+                : Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
+
+        // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
+        // we don't need to wait for all nodes to be contracted
+        long nodesToAvoidContract = Math.round((100 - nodesContractedPercentage) / 100 * sortedNodes.getSize());
         StopWatch lazySW = new StopWatch();
 
         // Recompute priority of uncontracted neighbors.
@@ -283,7 +275,7 @@ void contractNodes()
             neighborUpdate = false;
 
         StopWatch neighborSW = new StopWatch();
-        LevelGraphStorage lg = ((LevelGraphStorage) g);
+        LevelGraphStorage levelGraphCast = ((LevelGraphStorage) prepareGraph);
         while (!sortedNodes.isEmpty())
         {
             // periodically update priorities of ALL nodes            
@@ -291,10 +283,10 @@ void contractNodes()
             {
                 periodSW.start();
                 sortedNodes.clear();
-                int len = g.getNodes();
+                int len = prepareGraph.getNodes();
                 for (int node = 0; node < len; node++)
                 {
-                    if (g.getLevel(node) != 0)
+                    if (prepareGraph.getLevel(node) != maxLevel)
                         continue;
 
                     int priority = oldPriorities[node] = calculatePriority(node);
@@ -302,13 +294,13 @@ void contractNodes()
                 }
                 periodSW.stop();
                 updateCounter++;
+                if (sortedNodes.isEmpty())
+                    throw new IllegalStateException("Cannot prepare as no unprepared nodes where found. Called preparation twice?");
             }
 
             if (counter % logSize == 0)
             {
-                // TODO necessary?
-                System.gc();
-                logger.info(Helper.nf(counter) + ", updates:" + updateCounter 
+                logger.info(Helper.nf(counter) + ", updates:" + updateCounter
                         + ", nodes: " + Helper.nf(sortedNodes.getSize())
                         + ", shortcuts:" + Helper.nf(newShortcuts)
                         + ", dijkstras:" + Helper.nf(dijkstraCount)
@@ -317,7 +309,7 @@ void contractNodes()
                         + ", t(lazy):" + (int) lazySW.getSeconds()
                         + ", t(neighbor):" + (int) neighborSW.getSeconds()
                         + ", meanDegree:" + (long) meanDegree
-                        + ", algo:" + algo.getMemoryUsageAsString()
+                        + ", algo:" + prepareAlgo.getMemoryUsageAsString()
                         + ", " + Helper.getMemInfo());
                 dijkstraSW = new StopWatch();
                 periodSW = new StopWatch();
@@ -326,7 +318,7 @@ void contractNodes()
             }
 
             counter++;
-            int polledNode = sortedNodes.pollKey();            
+            int polledNode = sortedNodes.pollKey();
             if (sortedNodes.getSize() < lastNodesLazyUpdates)
             {
                 lazySW.start();
@@ -343,15 +335,18 @@ void contractNodes()
 
             // contract!            
             newShortcuts += addShortcuts(polledNode);
-            g.setLevel(polledNode, level);
+            prepareGraph.setLevel(polledNode, level);
             level++;
 
+            if (sortedNodes.getSize() < nodesToAvoidContract)
+                // skipped nodes are already set to maxLevel
+                break;
+
             EdgeSkipIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next())
             {
                 int nn = iter.getAdjNode();
-                if (g.getLevel(nn) != 0)
-                    // already contracted no update necessary
+                if (prepareGraph.getLevel(nn) != maxLevel)
                     continue;
 
                 if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage)
@@ -365,8 +360,7 @@ void contractNodes()
                     neighborSW.stop();
                 }
 
-                if (removesHigher2LowerEdges)
-                    lg.disconnect(vehicleAllTmpExplorer, iter);
+                levelGraphCast.disconnect(vehicleAllTmpExplorer, iter);
             }
         }
 
@@ -374,25 +368,25 @@ void contractNodes()
         // The preparation object itself has to be intact to create the algorithm.
         close();
         logger.info("took:" + (int) allSW.stop().getSeconds()
-                + ", new shortcuts: " + newShortcuts 
+                + ", new shortcuts: " + newShortcuts
                 + ", " + prepareWeighting
-                + ", " + prepareEncoder
-                + ", removeHigher2LowerEdges:" + removesHigher2LowerEdges
+                + ", " + prepareFlagEncoder
                 + ", dijkstras:" + dijkstraCount
                 + ", t(dijk):" + (int) dijkstraSW.getSeconds()
                 + ", t(period):" + (int) periodSW.getSeconds()
                 + ", t(lazy):" + (int) lazySW.getSeconds()
-                + ", t(neighbor):" + (int) neighborSW.getSeconds()                
+                + ", t(neighbor):" + (int) neighborSW.getSeconds()
                 + ", meanDegree:" + (long) meanDegree
                 + ", initSize:" + initSize
                 + ", periodic:" + periodicUpdatesPercentage
                 + ", lazy:" + lastNodesLazyUpdatePercentage
-                + ", neighbor:" + neighborUpdatePercentage);
+                + ", neighbor:" + neighborUpdatePercentage
+                + ", " + Helper.getMemInfo());
     }
 
     public void close()
     {
-        algo.close();
+        prepareAlgo.close();
         originalEdges.close();
         sortedNodes = null;
         oldPriorities = null;
@@ -403,7 +397,8 @@ public void close()
     interface ShortcutHandler
     {
         void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, EdgeIterator outgoingEdges,
+                double existingDirectWeight, double distance,
+                EdgeIterator outgoingEdges,
                 int skippedEdge1, int incomingEdgeOrigCount );
 
         int getNode();
@@ -431,7 +426,8 @@ public int getNode()
 
         @Override
         public void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, EdgeIterator outgoingEdges,
+                double existingDirectWeight, double distance,
+                EdgeIterator outgoingEdges,
                 int skippedEdge1, int incomingEdgeOrigCount )
         {
             shortcuts++;
@@ -462,7 +458,8 @@ public AddShortcutHandler setNode( int n )
 
         @Override
         public void foundShortcut( int u_fromNode, int w_toNode,
-                double existingDirectWeight, EdgeIterator outgoingEdges,
+                double existingDirectWeight, double existingDistSum,
+                EdgeIterator outgoingEdges,
                 int skippedEdge1, int incomingEdgeOrigCount )
         {
             // FOUND shortcut 
@@ -470,19 +467,18 @@ public void foundShortcut( int u_fromNode, int w_toNode,
             // and also in the graph for u->w. If existing AND identical weight => update setProperties.
             // Hint: shortcuts are always one-way due to distinct level of every node but we don't
             // know yet the levels so we need to determine the correct direction or if both directions
-            // minor improvement: if (shortcuts.containsKey(sc) 
-            // then two shortcuts with the same nodes (u<->n.endNode) exists => check current shortcut against both
-            Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight);
+            Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
             if (shortcuts.containsKey(sc))
-            {
                 return;
-            } else
+
+            Shortcut tmpSc = new Shortcut(w_toNode, u_fromNode, existingDirectWeight, existingDistSum);
+            Shortcut tmpRetSc = shortcuts.get(tmpSc);
+            if (tmpRetSc != null)
             {
-                Shortcut tmpSc = new Shortcut(w_toNode, u_fromNode, existingDirectWeight);
-                Shortcut tmpRetSc = shortcuts.get(tmpSc);
-                if (tmpRetSc != null)
+                // overwrite flags only if skipped edges are identical
+                if (tmpRetSc.skippedEdge2 == skippedEdge1 && tmpRetSc.skippedEdge1 == outgoingEdges.getEdge())
                 {
-                    tmpRetSc.flags = scBothDir;
+                    tmpRetSc.flags = PrepareEncoder.getScDirMask();
                     return;
                 }
             }
@@ -501,20 +497,20 @@ public void foundShortcut( int u_fromNode, int w_toNode,
     }
 
     /**
-     * Calculates the priority of endNode v without changing the graph. Warning: the calculated
+     * Calculates the priority of adjNode v without changing the graph. Warning: the calculated
      * priority must NOT depend on priority(v) and therefor findShortcuts should also not depend on
      * the priority(v). Otherwise updating the priority before contracting in contractNodes() could
      * lead to a slowishor even endless loop.
      */
     int calculatePriority( int v )
     {
-        // set of shortcuts that would be added if endNode v would be contracted next.
+        // set of shortcuts that would be added if adjNode v would be contracted next.
         findShortcuts(calcScHandler.setNode(v));
 
 //        System.out.println(v + "\t " + tmpShortcuts);
         // # huge influence: the bigger the less shortcuts gets created and the faster is the preparation
         //
-        // every endNode has an 'original edge' number associated. initially it is r=1
+        // every adjNode has an 'original edge' number associated. initially it is r=1
         // when a new shortcut is introduced then r of the associated edges is summed up:
         // r(u,w)=r(u,v)+r(v,w) now we can define
         // originalEdgesCount = σ(v) := sum_{ (u,w) ∈ shortcuts(v) } of r(u, w)
@@ -541,7 +537,7 @@ int calculatePriority( int v )
         // # low influence: with it the shortcut creation is slightly faster
         //
         // |shortcuts(v)| − |{(u, v) | v uncontracted}| − |{(v, w) | v uncontracted}|        
-        // meanDegree is used instead of outDegree+inDegree as if one endNode is in both directions
+        // meanDegree is used instead of outDegree+inDegree as if one adjNode is in both directions
         // only one bucket memory is used. Additionally one shortcut could also stand for two directions.
         int edgeDifference = calcScHandler.shortcuts - degree;
 
@@ -562,46 +558,56 @@ void findShortcuts( ShortcutHandler sch )
         {
             int u_fromNode = incomingEdges.getAdjNode();
             // accept only uncontracted nodes
-            if (g.getLevel(u_fromNode) != 0)
+            if (prepareGraph.getLevel(u_fromNode) != maxLevel)
                 continue;
 
-            double v_u_weight = incomingEdges.getDistance();
+            double v_u_dist = incomingEdges.getDistance();
+            double v_u_weight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
             int skippedEdge1 = incomingEdges.getEdge();
             int incomingEdgeOrigCount = getOrigEdgeCount(skippedEdge1);
             // collect outgoing nodes (goal-nodes) only once
             EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
             // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
-            algo.clear();
+            prepareAlgo.clear();
             tmpDegreeCounter++;
             while (outgoingEdges.next())
             {
                 int w_toNode = outgoingEdges.getAdjNode();
                 // add only uncontracted nodes
-                if (g.getLevel(w_toNode) != 0 || u_fromNode == w_toNode)
-                {
+                if (prepareGraph.getLevel(w_toNode) != maxLevel || u_fromNode == w_toNode)
                     continue;
-                }
 
                 // Limit weight as ferries or forbidden edges can increase local search too much.
                 // If we decrease the correct weight we only explore less and introduce more shortcuts.
                 // I.e. no change to accuracy is made.
-                double existingDirectWeight = v_u_weight + outgoingEdges.getDistance();
-                algo.setLimitWeight(existingDirectWeight)
-                        .setLimitVisitedNodes((int) meanDegree * 100)
-                        .setEdgeFilter(levelEdgeFilter.setAvoidNode(sch.getNode()));
+                double existingDirectWeight = v_u_weight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
+                if (Double.isNaN(existingDirectWeight))
+                    throw new IllegalStateException("Weighting should never return NaN values"
+                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
+                            + ", dist:" + outgoingEdges.getDistance() + ", speed:" + prepareFlagEncoder.getSpeed(outgoingEdges.getFlags()));
+
+                if (Double.isInfinite(existingDirectWeight))
+                    continue;
+
+                double existingDistSum = v_u_dist + outgoingEdges.getDistance();
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setLimitVisitedNodes((int) meanDegree * 100)
+                        .setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
 
                 dijkstraSW.start();
                 dijkstraCount++;
-                int endNode = algo.findEndNode(u_fromNode, w_toNode);
+                int endNode = prepareAlgo.findEndNode(u_fromNode, w_toNode);
                 dijkstraSW.stop();
 
                 // compare end node as the limit could force dijkstra to finish earlier
-                if (endNode == w_toNode && algo.getWeight(endNode) <= existingDirectWeight)
+                if (endNode == w_toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
                     // FOUND witness path, so do not add shortcut                
                     continue;
 
-                sch.foundShortcut(u_fromNode, w_toNode, existingDirectWeight,
-                        outgoingEdges, skippedEdge1, incomingEdgeOrigCount);
+                sch.foundShortcut(u_fromNode, w_toNode,
+                        existingDirectWeight, existingDistSum,
+                        outgoingEdges,
+                        skippedEdge1, incomingEdgeOrigCount);
             }
         }
         if (sch instanceof AddShortcutHandler)
@@ -613,13 +619,14 @@ void findShortcuts( ShortcutHandler sch )
     }
 
     /**
-     * Introduces the necessary shortcuts for endNode v in the graph.
+     * Introduces the necessary shortcuts for adjNode v in the graph.
      */
     int addShortcuts( int v )
     {
         shortcuts.clear();
         findShortcuts(addScHandler.setNode(v));
         int tmpNewShortcuts = 0;
+        NEXT_SC:
         for (Shortcut sc : shortcuts.keySet())
         {
             boolean updatedInGraph = false;
@@ -628,12 +635,27 @@ int addShortcuts( int v )
             while (iter.next())
             {
                 if (iter.isShortcut() && iter.getAdjNode() == sc.to
-                        && prepareEncoder.canBeOverwritten(iter.getFlags(), sc.flags)
-                        && iter.getDistance() > sc.weight)
+                        && PrepareEncoder.canBeOverwritten(iter.getFlags(), sc.flags))
                 {
+                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE))
+                        continue NEXT_SC;
+
+                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2)
+                    {
+                        throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
+                                + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
+                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
+                                + ", sc:" + sc
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge2, sc.to), prepareGraph)
+                                + ", neighbors:" + GHUtility.getNeighbors(iter));
+                    }
+
+                    // note: flags overwrite weight => call first
                     iter.setFlags(sc.flags);
+                    iter.setWeight(sc.weight);
+                    iter.setDistance(sc.dist);
                     iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                    iter.setDistance(sc.weight);
                     setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
                     updatedInGraph = true;
                     break;
@@ -642,8 +664,11 @@ int addShortcuts( int v )
 
             if (!updatedInGraph)
             {
-                EdgeSkipIterState edgeState = g.shortcut(sc.from, sc.to);
-                edgeState.setDistance(sc.weight).setFlags(sc.flags);
+                EdgeSkipIterState edgeState = prepareGraph.shortcut(sc.from, sc.to);
+                // note: flags overwrite weight => call first
+                edgeState.setFlags(sc.flags);
+                edgeState.setWeight(sc.weight);
+                edgeState.setDistance(sc.dist);
                 edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
                 setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
                 tmpNewShortcuts++;
@@ -652,22 +677,48 @@ int addShortcuts( int v )
         return tmpNewShortcuts;
     }
 
+    String getCoords( EdgeIteratorState e, Graph g )
+    {
+        NodeAccess na = g.getNodeAccess();
+        int base = e.getBaseNode();
+        int adj = e.getAdjNode();
+        return base + "->" + adj + " (" + e.getEdge() + "); "
+                + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
+    }
+
     PrepareContractionHierarchies initFromGraph()
     {
-        checkGraph();
-        vehicleInExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareEncoder, true, false));
-        vehicleOutExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareEncoder, false, true));
-        vehicleAllExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareEncoder, true, true));
-        vehicleAllTmpExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareEncoder, true, true));
-        calcPrioAllExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareEncoder, true, true));
-        levelEdgeFilter = new IgnoreNodeFilter(g);
+        vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
+        vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
+        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
+
+        // filter by vehicle and level number
+        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph)
+        {
+            @Override
+            public final boolean accept( EdgeIteratorState edgeState )
+            {
+                if (!super.accept(edgeState))
+                    return false;
+
+                return allFilter.accept(edgeState);
+            }
+        };
+
+        maxLevel = prepareGraph.getNodes() + 1;
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
+        vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
+
         // Use an alternative to PriorityQueue as it has some advantages: 
-        //   1. Gets automatically smaller if less entries are stored => less total RAM used (as Graph is increasing until the end)
+        //   1. Gets automatically smaller if less entries are stored => less total RAM used. 
+        //      Important because Graph is increasing until the end.
         //   2. is slightly faster
-        //   but we need additional priorities array to keep old value which is necessary for update method
+        //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
-        oldPriorities = new int[g.getNodes()];
-        algo = new DijkstraOneToMany(g, prepareEncoder, shortestWeighting);
+        oldPriorities = new int[prepareGraph.getNodes()];
+        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareFlagEncoder, prepareWeighting, traversalMode);
         return this;
     }
 
@@ -679,11 +730,13 @@ public int getShortcuts()
     static class IgnoreNodeFilter implements EdgeFilter
     {
         int avoidNode;
+        int maxLevel;
         LevelGraph graph;
 
-        public IgnoreNodeFilter( LevelGraph g )
+        public IgnoreNodeFilter( LevelGraph g, int maxLevel )
         {
             this.graph = g;
+            this.maxLevel = maxLevel;
         }
 
         public IgnoreNodeFilter setAvoidNode( int node )
@@ -695,16 +748,16 @@ public IgnoreNodeFilter setAvoidNode( int node )
         @Override
         public final boolean accept( EdgeIteratorState iter )
         {
-            // ignore if it is skipNode or a endNode already contracted
+            // ignore if it is skipNode or adjNode is already contracted
             int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == 0;
+            return avoidNode != node && graph.getLevel(node) == maxLevel;
         }
     }
 
     private void setOrigEdgeCount( int index, int value )
     {
         long tmp = (long) index * 4;
-        originalEdges.incCapacity(tmp + 4);
+        originalEdges.ensureCapacity(tmp + 4);
         originalEdges.setInt(tmp, value);
     }
 
@@ -712,175 +765,112 @@ private int getOrigEdgeCount( int index )
     {
         // TODO possible memory usage improvement: avoid storing the value 1 for normal edges (does not change)!
         long tmp = (long) index * 4;
-        originalEdges.incCapacity(tmp + 4);
+        originalEdges.ensureCapacity(tmp + 4);
         return originalEdges.getInt(tmp);
     }
 
     @Override
-    public RoutingAlgorithm createAlgo()
+    public RoutingAlgorithm createAlgo( Graph graph, AlgorithmOptions opts )
     {
-        checkGraph();
-        // do not change weight within DijkstraBidirectionRef => so use ShortestWeighting
-        DijkstraBidirectionRef dijkstrabi = new DijkstraBidirectionRef(g, prepareEncoder, shortestWeighting)
+        AbstractBidirAlgo algo;
+        if (AlgorithmOptions.ASTAR_BI.equals(opts.getAlgorithm()))
         {
-            @Override
-            protected void initCollections( int nodes )
+            AStarBidirection astarBi = new AStarBidirection(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
             {
-                // algorithm with CH does not need that much memory pre allocated
-                super.initCollections(Math.min(initialCollectionSize, nodes));
-            }
-
-            @Override
-            protected QueryGraph createQueryGraph()
-            {
-                return new QueryGraph(graph)
+                @Override
+                protected void initCollections( int nodes )
                 {
-                    @Override
-                    protected void updateDistance( EdgeIteratorState edge )
-                    {
-                        edge.setDistance(prepareWeighting.calcWeight(edge));
-                    }
-                };
-            }
+                    // algorithm with CH does not need that much memory pre allocated
+                    super.initCollections(Math.min(initialCollectionSize, nodes));
+                }
 
-            @Override
-            public boolean finished()
-            {
-                // we need to finish BOTH searches for CH!
-                if (finishedFrom && finishedTo)
-                    return true;
+                @Override
+                protected boolean finished()
+                {
+                    // we need to finish BOTH searches for CH!
+                    if (finishedFrom && finishedTo)
+                        return true;
 
-                // changed also the final finish condition for CH                
-                return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
-            }
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
 
-            @Override
-            public void initPath()
-            {
-                // CH changes the weight in prepareEdges to the weight
-                // now we need to transform it back to the real weight
-                Weighting w = createWeighting();
-                bestPath = new Path4CH(graph, flagEncoder, w);
-            }
+                    // changed finish condition for CH
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+                }
 
-            @Override
-            public String getName()
-            {
-                return "dijkstrabiCH";
-            }
+                @Override
 
-            @Override
-            public String toString()
-            {
-                return getName() + "|" + prepareWeighting;
-            }
-        };
+                protected Path createAndInitPath()
+                {
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
+                    return bestPath;
+                }
 
-        if (!removesHigher2LowerEdges)
-            dijkstrabi.setEdgeFilter(new LevelEdgeFilter(g));
+                @Override
+                public String getName()
+                {
+                    return "astarbiCH";
+                }
 
-        return dijkstrabi;
-    }
+                @Override
 
-    public AStarBidirection createAStar()
-    {
-        checkGraph();
-        AStarBidirection astar = new AStarBidirection(g, prepareEncoder, shortestWeighting)
+                public String toString()
+                {
+                    return getName() + "|" + prepareWeighting;
+                }
+            };
+            algo = astarBi;
+        } else if (AlgorithmOptions.DIJKSTRA_BI.equals(opts.getAlgorithm()))
         {
-            @Override
-            protected void initCollections( int nodes )
-            {
-                // algorithm with CH does not need that much memory pre allocated
-                super.initCollections(Math.min(initialCollectionSize, nodes));
-            }
-
-            @Override
-            protected QueryGraph createQueryGraph()
+            algo = new DijkstraBidirectionRef(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
             {
-                return new QueryGraph(graph)
+                @Override
+                protected void initCollections( int nodes )
                 {
-                    @Override
-                    protected void updateDistance( EdgeIteratorState edge )
-                    {
-                        edge.setDistance(prepareWeighting.calcWeight(edge));
-                    }
-                };
-            }
-
-            @Override
-            protected boolean finished()
-            {
-                // we need to finish BOTH searches for CH!
-                if (finishedFrom && finishedTo)
-                    return true;
-
-                // changed finish condition for CH
-                double tmpWeight = bestPath.getWeight() * approximationFactor;
-                return currFrom.weight >= tmpWeight && currTo.weight >= tmpWeight;
-            }
+                    // algorithm with CH does not need that much memory pre allocated
+                    super.initCollections(Math.min(initialCollectionSize, nodes));
+                }
 
-            @Override
-            protected void initPath()
-            {
-                // CH changes the weight in prepareEdges to the weight
-                // now we need to transform it back to the real weight
-                Weighting wc = createWeighting();
-                bestPath = new Path4CH(graph, flagEncoder, wc);
-            }
+                @Override
+                public boolean finished()
+                {
+                    // we need to finish BOTH searches for CH!
+                    if (finishedFrom && finishedTo)
+                        return true;
 
-            @Override
-            public String getName()
-            {
-                return "astarbiCH";
-            }
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
 
-            @Override
-            public String toString()
-            {
-                return getName() + "|" + prepareWeighting;
-            }
-        };
+                    // changed also the final finish condition for CH                
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+                }
 
-        if (!removesHigher2LowerEdges)
-            astar.setEdgeFilter(new LevelEdgeFilter(g));
+                @Override
+                protected Path createAndInitPath()
+                {
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
+                    return bestPath;
+                }
 
-        return astar;
-    }
+                @Override
+                public String getName()
+                {
+                    return "dijkstrabiCH";
+                }
 
-    Weighting createWeighting()
-    {
-        return new Weighting()
+                @Override
+                public String toString()
+                {
+                    return getName() + "|" + prepareWeighting;
+                }
+            };
+        } else
         {
-            @Override
-            public String toString()
-            {
-                return "CH_DIST_ONLY";
-            }
-
-            @Override
-            public double getMinWeight( double distance )
-            {
-                throw new IllegalStateException("getMinWeight not supported yet");
-            }
-
-            @Override
-            public double calcWeight( EdgeIteratorState edge )
-            {
-                return edge.getDistance();
-            }
-
-            @Override
-            public double revertWeight( EdgeIteratorState iter, double weight )
-            {
-                return prepareWeighting.revertWeight(iter, weight);
-            }
-        };
-    }
+            throw new UnsupportedOperationException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies");
+        }
 
-    private void checkGraph()
-    {
-        if (g == null)
-            throw new NullPointerException("setGraph before usage");
+        algo.setEdgeFilter(levelFilter);
+        return algo;
     }
 
     private static class PriorityNode implements Comparable<PriorityNode>
@@ -913,15 +903,17 @@ public int compareTo( PriorityNode o )
         int to;
         int skippedEdge1;
         int skippedEdge2;
+        double dist;
         double weight;
         int originalEdges;
-        long flags = scOneDir;
+        long flags = PrepareEncoder.getScFwdDir();
 
-        public Shortcut( int from, int to, double dist )
+        public Shortcut( int from, int to, double weight, double dist )
         {
             this.from = from;
             this.to = to;
-            this.weight = dist;
+            this.weight = weight;
+            this.dist = dist;
         }
 
         @Override
@@ -950,7 +942,19 @@ public boolean equals( Object obj )
         @Override
         public String toString()
         {
-            return from + "->" + to + ", dist:" + weight;
+            String str;
+            if (flags == PrepareEncoder.getScDirMask())
+                str = from + "<->";
+            else
+                str = from + "->";
+
+            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
         }
     }
+
+    @Override
+    public String toString()
+    {
+        return "PREPARE|CH|dijkstrabi";
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
new file mode 100644
index 0000000000..6aee636cba
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
@@ -0,0 +1,61 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+/**
+ * The flags are stored differently for shortcuts: just a weight and the direction flags. Currently
+ * it is not allowed to store multiple vehicles.
+ * <p>
+ * @author Peter Karich
+ */
+public class PrepareEncoder
+{
+    // shortcut is one direction, speed is only involved while recalculating the adjNode weights
+    // see PrepareContractionHierarchies.prepareEdges
+    private static final long scFwdDir = 0x1;
+    private static final long scDirMask = 0x3;
+
+    public static final long getScDirMask()
+    {
+        return scDirMask;
+    }
+
+    public static final long getScFwdDir()
+    {
+        return scFwdDir;
+    }
+
+    /**
+     * Returns true if flags1 can be overwritten in the edge by flags2 without restricting or
+     * changing the directions of flags1.
+     * <p>
+     * @return true if flags2 is enabled in both directions or if both flags are pointing into the
+     * same direction.
+     */
+    //        \  flags2:
+    // flags1  \ -> | <- | <->
+    // ->         t | f  | t
+    // <-         f | t  | t
+    // <->        f | f  | t
+    public static final boolean canBeOverwritten( long flags1, long flags2 )
+    {
+        return (flags2 & scDirMask) == scDirMask
+                || (flags1 & scDirMask) == (flags2 & scDirMask);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
index c98da4c65a..3de7c2c89a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
@@ -17,36 +17,21 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.Graph;
-
 /**
  * @author Peter Karich
  */
-public abstract class AbstractAlgoPreparation<T extends AlgorithmPreparation> implements AlgorithmPreparation
+public abstract class AbstractAlgoPreparation
 {
-    protected Graph _graph;
     private boolean prepared = false;
 
-    @Override
-    public AlgorithmPreparation setGraph( Graph g )
-    {
-        _graph = g;
-        return this;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public T doWork()
+    public void doWork()
     {
         if (prepared)
             throw new IllegalStateException("Call doWork only once!");
 
         prepared = true;
-        // no operation        
-        return (T) this;
     }
 
-    @Override
     public boolean isPrepared()
     {
         return prepared;
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index dcf9dfa84b..409bc6a307 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -17,28 +17,21 @@
  */
 package com.graphhopper.routing.util;
 
-import java.util.Collection;
 import java.util.HashSet;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMReader;
-import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
-import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.Helper;
-import java.util.Collections;
+import com.graphhopper.util.*;
+import java.util.*;
 
 /**
  * Abstract class which handles flag decoding and encoding. Every encoder should be registered to a
- * EncodingManager to be usable. Although the flag is of type long only the int-portition is
- * currently stored.
+ * EncodingManager to be usable. If you want the full long to be stored you need to enable this in
+ * the GraphHopperStorage.
  * <p/>
  * @author Peter Karich
  * @author Nop
@@ -47,44 +40,53 @@
 public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder
 {
     private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
-
+    private final static int K_FORWARD = 0, K_BACKWARD = 1;
     /* Edge Flag Encoder fields */
     private long nodeBitMask;
     private long wayBitMask;
     private long relBitMask;
-    protected long forwardBit = 0;
-    protected long backwardBit = 0;
-    protected long directionBitMask = 0;
-    protected EncodedValue speedEncoder;
+    protected long forwardBit;
+    protected long backwardBit;
+    protected long directionBitMask;
+    protected long roundaboutBit;
+    protected EncodedDoubleValue speedEncoder;
     // bit to signal that way is accepted
-    protected long acceptBit = 0;
-    protected long ferryBit = 0;
-
-    /* Turn Cost Flag Encoder fields */
-    protected int maxCostsBits;
-    protected long costsMask;
+    protected long acceptBit;
+    protected long ferryBit;
 
-    protected long restrictionBit;
-    protected long costShift;
+    private EncodedValue turnCostEncoder;
+    private long turnRestrictionBit;
+    private final int maxTurnCosts;
 
     /* processing properties (to be initialized lazy when needed) */
     protected EdgeExplorer edgeOutExplorer;
     protected EdgeExplorer edgeInExplorer;
 
-    /* restriction definitions */
-    protected String[] restrictions;
-    protected HashSet<String> intended = new HashSet<String>();
-    protected HashSet<String> restrictedValues = new HashSet<String>(5);
-    protected HashSet<String> ferries = new HashSet<String>(5);
-    protected HashSet<String> oneways = new HashSet<String>(5);
-    protected HashSet<String> acceptedRailways = new HashSet<String>(5);
-    protected HashSet<String> absoluteBarriers = new HashSet<String>(5);
-    protected HashSet<String> potentialBarriers = new HashSet<String>(5);
-    protected int speedBits;
-    protected int speedFactor;
+    /* restriction definitions where order is important */
+    protected final List<String> restrictions = new ArrayList<String>(5);
+    protected final HashSet<String> intendedValues = new HashSet<String>(5);
+    protected final HashSet<String> restrictedValues = new HashSet<String>(5);
+    protected final HashSet<String> ferries = new HashSet<String>(5);
+    protected final HashSet<String> oneways = new HashSet<String>(5);
+    protected final HashSet<String> acceptedRailways = new HashSet<String>(5);
+    // http://wiki.openstreetmap.org/wiki/Mapfeatures#Barrier
+    protected final HashSet<String> absoluteBarriers = new HashSet<String>(5);
+    protected final HashSet<String> potentialBarriers = new HashSet<String>(5);
+    private boolean blockByDefault = true;
+    private boolean blockFords = true;
+    protected final int speedBits;
+    protected final double speedFactor;
 
-    public AbstractFlagEncoder( int speedBits, int speedFactor )
+    /**
+     * @param speedBits specify the number of bits used for speed
+     * @param speedFactor specify the factor to multiple the stored value (can be used to increase
+     * or decrease accuracy of speed value)
+     * @param maxTurnCosts specify the maximum value used for turn costs, if this value is reached a
+     * turn is forbidden and results in costs of positive infinity.
+     */
+    protected AbstractFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     {
+        this.maxTurnCosts = maxTurnCosts <= 0 ? 0 : maxTurnCosts;
         this.speedBits = speedBits;
         this.speedFactor = speedFactor;
         oneways.add("yes");
@@ -96,8 +98,34 @@ public AbstractFlagEncoder( int speedBits, int speedFactor )
         ferries.add("ferry");
 
         acceptedRailways.add("tram");
+        acceptedRailways.add("abandoned");
+        acceptedRailways.add("disused");
+
+        // http://wiki.openstreetmap.org/wiki/Demolished_Railway
+        acceptedRailways.add("dismantled");
+        acceptedRailways.add("razed");
+        acceptedRailways.add("historic");
+        acceptedRailways.add("obliterated");
     }
-    
+
+    /**
+     * Should potential barriers block when no access limits are given?
+     */
+    public void setBlockByDefault( boolean blockByDefault )
+    {
+        this.blockByDefault = blockByDefault;
+    }
+
+    public void setBlockFords( boolean blockFords )
+    {
+        this.blockFords = blockFords;
+    }
+
+    public boolean isBlockFords()
+    {
+        return blockFords;
+    }
+
     /**
      * Defines the bits for the node flags, which are currently used for barriers only.
      * <p>
@@ -117,18 +145,23 @@ public int defineNodeBits( int index, int shift )
      */
     public int defineWayBits( int index, int shift )
     {
+        if (forwardBit != 0)
+            throw new IllegalStateException("You must not register a FlagEncoder (" + toString() + ") twice!");
+
         // define the first 2 speedBits in flags for routing
-        forwardBit = 1 << shift;
-        backwardBit = 2 << shift;
-        directionBitMask = 3 << shift;
+        forwardBit = 1L << shift;
+        backwardBit = 2L << shift;
+        directionBitMask = 3L << shift;
+        shift += 2;
+        roundaboutBit = 1L << shift;
+        shift++;
 
         // define internal flags for parsing
         index *= 2;
-        acceptBit = 1 << index;
-        ferryBit = 2 << index;
+        acceptBit = 1L << index;
+        ferryBit = 2L << index;
 
-        // forward and backward bit:
-        return shift + 2;
+        return shift;
     }
 
     /**
@@ -142,158 +175,161 @@ public int defineRelationBits( int index, int shift )
     }
 
     /**
-     * Defines the bits reserved for storing turn restriction and turn cost
-     * <p>
-     * @param shift bit offset for the first bit used by this encoder
-     * @param numberCostsBits number of bits reserved for storing costs (range of values: [0,
-     * 2^numberCostBits - 1] seconds )
-     * @return incremented shift value pointing behind the last used bit
-     */
-    public int defineTurnBits( int index, int shift, int numberCostsBits )
-    {
-        this.maxCostsBits = numberCostsBits;
-
-        int mask = 0;
-        for (int i = 0; i < this.maxCostsBits; i++)
-        {
-            mask |= (1 << i);
-        }
-        this.costsMask = mask;
-
-        restrictionBit = 1 << shift;
-        costShift = shift + 1;
-        return shift + maxCostsBits + 1;
-    }
-
-    /**
-     * Analyze the properties of a relation and create the routing flags for the second read step
+     * Analyze the properties of a relation and create the routing flags for the second read step.
+     * In the pre-parsing step this method will be called to determine the useful relation tags.
      * <p/>
      */
     public abstract long handleRelationTags( OSMRelation relation, long oldRelationFlags );
 
     /**
-     * Decide whether a way is routable for a given mode of travel
+     * Decide whether a way is routable for a given mode of travel. This skips some ways before
+     * handleWayTags is called.
      * <p/>
      * @return the encoded value to indicate if this encoder allows travel or not.
      */
     public abstract long acceptWay( OSMWay way );
 
     /**
-     * Analyze properties of a way and create the routing flags          
+     * Analyze properties of a way and create the routing flags. This method is called in the second
+     * parsing step.
      */
     public abstract long handleWayTags( OSMWay way, long allowed, long relationFlags );
 
     /**
      * Parse tags on nodes. Node tags can add to speed (like traffic_signals) where the value is
-     * strict negative or blocks access (like a barrier), then the value is strict positive.
+     * strict negative or blocks access (like a barrier), then the value is strict positive.This
+     * method is called in the second parsing step.
      */
-    public long analyzeNodeTags( OSMNode node )
+    public long handleNodeTags( OSMNode node )
     {
-        // movable barriers block if they are not marked as passable
-        if (node.hasTag("barrier", potentialBarriers) 
-                && !node.hasTag(restrictions, intended) 
-                && !node.hasTag("locked", "no"))
+        // absolute barriers always block
+        if (node.hasTag("barrier", absoluteBarriers))
             return directionBitMask;
 
-        if ((node.hasTag("highway", "ford") 
-                || node.hasTag("ford")) && !node.hasTag(restrictions, intended))
+        // movable barriers block if they are not marked as passable
+        if (node.hasTag("barrier", potentialBarriers))
+        {
+            boolean locked = false;
+            if (node.hasTag("locked", "yes"))
+                locked = true;
+
+            for (String res : restrictions)
+            {
+                if (!locked && node.hasTag(res, intendedValues))
+                    return 0;
+
+                if (node.hasTag(res, restrictedValues))
+                    return directionBitMask;
+            }
+
+            if (blockByDefault)
+                return directionBitMask;
+        }
+
+        if (blockFords
+                && (node.hasTag("highway", "ford") || node.hasTag("ford"))
+                && !node.hasTag(restrictions, intendedValues))
             return directionBitMask;
 
         return 0;
     }
 
-    public long applyNodeFlags( long wayFlags, long nodeFlags )
-    {
-        return nodeFlags | wayFlags;
-    }
-
     @Override
-    public boolean isForward( long flags )
+    public InstructionAnnotation getAnnotation( long flags, Translation tr )
     {
-        return (flags & forwardBit) != 0;
+        return InstructionAnnotation.EMPTY;
     }
 
-    @Override
-    public boolean isBackward( long flags )
+    /**
+     * Swapping directions means swapping bits which are dependent on the direction of an edge like
+     * the access bits. But also direction dependent speed values should be swapped too. Keep in
+     * mind that this method is performance critical!
+     */
+    public long reverseFlags( long flags )
     {
-        return (flags & backwardBit) != 0;
-    }
+        long dir = flags & directionBitMask;
+        if (dir == directionBitMask || dir == 0)
+            return flags;
 
-    public boolean isBoth( long flags )
-    {
-        return (flags & directionBitMask) == directionBitMask;
+        return flags ^ directionBitMask;
     }
 
-    @Override
-    public boolean canBeOverwritten( long flags1, long flags2 )
+    /**
+     * Sets default flags with specified access.
+     */
+    public long flagsDefault( boolean forward, boolean backward )
     {
-        return isBoth(flags2) || (flags1 & directionBitMask) == (flags2 & directionBitMask);
+        long flags = speedEncoder.setDefaultValue(0);
+        return setAccess(flags, forward, backward);
     }
 
     @Override
-    public int getPavementCode( long flags )
+    public long setAccess( long flags, boolean forward, boolean backward )
     {
-        return -1;
+        return setBool(setBool(flags, K_BACKWARD, backward), K_FORWARD, forward);
     }
 
     @Override
-    public int getWayTypeCode( long flags )
+    public long setSpeed( long flags, double speed )
     {
-        return -1;
-    }
-
-    public long swapDirection( long flags )
-    {
-        long dir = flags & directionBitMask;
-        if (dir == directionBitMask || dir == 0)
-            return flags;
+        if (speed < 0)
+            throw new IllegalArgumentException("Speed cannot be negative: " + speed
+                    + ", flags:" + BitUtil.LITTLE.toBitString(flags));
 
-        return flags ^ directionBitMask;
+        if (speed > getMaxSpeed())
+            speed = getMaxSpeed();
+        return speedEncoder.setDoubleValue(flags, speed);
     }
 
     @Override
-    public int getSpeed( long flags )
+    public double getSpeed( long flags )
     {
-        int speedVal = (int) speedEncoder.getValue(flags);
+        double speedVal = speedEncoder.getDoubleValue(flags);
         if (speedVal < 0)
             throw new IllegalStateException("Speed was negative!? " + speedVal);
 
         return speedVal;
     }
 
-    /**
-     * Sets default flags with specified access.
-     */
-    public long flagsDefault( boolean forward, boolean backward )
+    @Override
+    public long setReverseSpeed( long flags, double speed )
     {
-        long flags = speedEncoder.setDefaultValue(0);
-        return setAccess(flags, forward, backward);
+        return setSpeed(flags, speed);
     }
 
     @Override
-    public long setAccess( long flags, boolean forward, boolean backward )
+    public double getReverseSpeed( long flags )
     {
-        return flags | (forward ? forwardBit : 0) | (backward ? backwardBit : 0);
+        return getSpeed(flags);
     }
 
     @Override
-    public long setSpeed( long flags, int speed )
+    public long setProperties( double speed, boolean forward, boolean backward )
     {
-        if (speed < 0)
-            throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
-        return speedEncoder.setValue(flags, speed);
+        return setAccess(setSpeed(0, speed), forward, backward);
     }
 
     @Override
-    public long setProperties( int speed, boolean forward, boolean backward )
+    public double getMaxSpeed()
     {
-        return setAccess(setSpeed(0, speed), forward, backward);
+        return speedEncoder.getMaxValue();
     }
 
-    @Override
-    public int getMaxSpeed()
+    /**
+     * @return -1 if no maxspeed found
+     */
+    protected double getMaxSpeed( OSMWay way )
     {
-        return (int) speedEncoder.getMaxValue();
+        double maxSpeed = parseSpeed(way.getTag("maxspeed"));
+        double fwdSpeed = parseSpeed(way.getTag("maxspeed:forward"));
+        if (fwdSpeed >= 0 && (maxSpeed < 0 || fwdSpeed < maxSpeed))
+            maxSpeed = fwdSpeed;
+
+        double backSpeed = parseSpeed(way.getTag("maxspeed:backward"));
+        if (backSpeed >= 0 && (maxSpeed < 0 || backSpeed < maxSpeed))
+            maxSpeed = backSpeed;
+
+        return maxSpeed;
     }
 
     @Override
@@ -321,20 +357,13 @@ public boolean equals( Object obj )
         return this.toString().equals(other.toString());
     }
 
-    public String getWayInfo( OSMWay way )
-    {
-        return "";
-    }
-
     /**
      * @return the speed in km/h
      */
-    static int parseSpeed( String str )
+    protected static double parseSpeed( String str )
     {
         if (Helper.isEmpty(str))
-        {
             return -1;
-        }
 
         try
         {
@@ -345,7 +374,7 @@ static int parseSpeed( String str )
             {
                 str = str.substring(0, mpInteger).trim();
                 val = Integer.parseInt(str);
-                return (int) Math.round(val * DistanceCalcEarth.KM_MILE);
+                return val * DistanceCalcEarth.KM_MILE;
             }
 
             int knotInteger = str.indexOf("knots");
@@ -353,7 +382,7 @@ static int parseSpeed( String str )
             {
                 str = str.substring(0, knotInteger).trim();
                 val = Integer.parseInt(str);
-                return (int) Math.round(val * 1.852);
+                return val * 1.852;
             }
 
             int kmInteger = str.indexOf("km");
@@ -386,15 +415,15 @@ protected static int parseDuration( String str )
     {
         if (str == null)
             return 0;
-        
+
         try
         {
             // for now ignore this special duration notation
             // because P1M != PT1M but there are wrong edits in OSM! e.g. http://www.openstreetmap.org/way/24791405
             // http://wiki.openstreetmap.org/wiki/Key:duration
-            if(str.startsWith("P"))
+            if (str.startsWith("P"))
                 return 0;
-            
+
             int index = str.indexOf(":");
             if (index > 0)
             {
@@ -420,29 +449,37 @@ protected static int parseDuration( String str )
             }
         } catch (Exception ex)
         {
-            logger.error("Cannot parse " + str + " using 0 minutes");
+            logger.warn("Cannot parse " + str + " using 0 minutes");
         }
         return 0;
     }
 
+    /**
+     * Second parsing step. Invoked after splitting the edges. Currently used to offer a hook to
+     * calculate precise speed values based on elevation data stored in the specified edge.
+     */
+    public void applyWayTags( OSMWay way, EdgeIteratorState edge )
+    {
+    }
+
     /**
      * Special handling for ferry ways.
      */
-    protected long handleFerry( OSMWay way, int unknownSpeed, int shortTripsSpeed, int longTripsSpeed )
+    protected long handleFerryTags( OSMWay way, double unknownSpeed, double shortTripsSpeed, double longTripsSpeed )
     {
         // to hours
         double durationInHours = parseDuration(way.getTag("duration")) / 60d;
         if (durationInHours > 0)
             try
             {
-                Number estimatedLength = way.getInternalTag("estimated_distance", null);
+                Number estimatedLength = way.getTag("estimated_distance", null);
                 if (estimatedLength != null)
                 {
                     // to km
                     double val = estimatedLength.doubleValue() / 1000;
                     // If duration AND distance is available we can calculate the speed more precisely
                     // and set both speed to the same value. Factor 1.4 slower because of waiting time!
-                    shortTripsSpeed = (int) Math.round(val / durationInHours / 1.4);
+                    shortTripsSpeed = Math.round(val / durationInHours / 1.4);
                     if (shortTripsSpeed > getMaxSpeed())
                         shortTripsSpeed = getMaxSpeed();
                     longTripsSpeed = shortTripsSpeed;
@@ -454,14 +491,14 @@ protected long handleFerry( OSMWay way, int unknownSpeed, int shortTripsSpeed, i
         if (durationInHours == 0)
         {
             // unknown speed -> put penalty on ferry transport
-            return speedEncoder.setValue(0, unknownSpeed);
+            return setSpeed(0, unknownSpeed);
         } else if (durationInHours > 1)
         {
             // lengthy ferries should be faster than short trip ferry
-            return speedEncoder.setValue(0, longTripsSpeed);
+            return setSpeed(0, longTripsSpeed);
         } else
         {
-            return speedEncoder.setValue(0, shortTripsSpeed);
+            return setSpeed(0, shortTripsSpeed);
         }
     }
 
@@ -498,37 +535,246 @@ long getNodeBitMask()
         return nodeBitMask;
     }
 
+    /**
+     * Defines the bits reserved for storing turn restriction and turn cost
+     * <p>
+     * @param shift bit offset for the first bit used by this encoder
+     * @return incremented shift value pointing behind the last used bit
+     */
+    public int defineTurnBits( int index, int shift )
+    {
+        if (maxTurnCosts == 0)
+            return shift;
+
+        // optimization for turn restrictions only 
+        else if (maxTurnCosts == 1)
+        {
+            turnRestrictionBit = 1L << shift;
+            return shift + 1;
+        }
+
+        int turnBits = Helper.countBitValue(maxTurnCosts);
+        turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0, maxTurnCosts)
+        {
+            // override to avoid expensive Math.round
+            @Override
+            public final long getValue( long flags )
+            {
+                // find value
+                flags &= mask;
+                flags >>= shift;
+                return flags;
+            }
+        };
+        return shift + turnBits;
+    }
+
     @Override
-    public boolean isTurnRestricted( long flag )
+    public boolean isTurnRestricted( long flags )
     {
-        return (flag & restrictionBit) != 0;
+        if (maxTurnCosts == 0)
+            return false;
+
+        else if (maxTurnCosts == 1)
+            return (flags & turnRestrictionBit) != 0;
+
+        return turnCostEncoder.getValue(flags) == maxTurnCosts;
     }
 
     @Override
-    public int getTurnCosts( long flag )
+    public double getTurnCost( long flags )
     {
-        long result = (flag >> costShift) & costsMask;
-        if (result >= Math.pow(2, maxCostsBits) || result < 0)
+        if (maxTurnCosts == 0)
+            return 0;
+
+        else if (maxTurnCosts == 1)
+            return ((flags & turnRestrictionBit) == 0) ? 0 : Double.POSITIVE_INFINITY;
+
+        long cost = turnCostEncoder.getValue(flags);
+        if (cost == maxTurnCosts)
+            return Double.POSITIVE_INFINITY;
+
+        return cost;
+    }
+
+    @Override
+    public long getTurnFlags( boolean restricted, double costs )
+    {
+        if (maxTurnCosts == 0)
+            return 0;
+
+        else if (maxTurnCosts == 1)
         {
-            throw new IllegalStateException("Wrong encoding of turn costs");
+            if (costs != 0)
+                throw new IllegalArgumentException("Only restrictions are supported");
+
+            return restricted ? turnRestrictionBit : 0;
         }
-        return Long.valueOf(result).intValue();
+
+        if (restricted)
+        {
+            if (costs != 0 || Double.isInfinite(costs))
+                throw new IllegalArgumentException("Restricted turn can only have infinite costs (or use 0)");
+        } else
+        {
+            if (costs >= maxTurnCosts)
+                throw new IllegalArgumentException("Cost is too high. Or specifiy restricted == true");
+        }
+
+        if (costs < 0)
+            throw new IllegalArgumentException("Turn costs cannot be negative");
+
+        if (costs >= maxTurnCosts || restricted)
+            costs = maxTurnCosts;
+        return turnCostEncoder.setValue(0L, (int) costs);
+    }
+
+    protected boolean isFerry( long internalFlags )
+    {
+        return (internalFlags & ferryBit) != 0;
+    }
+
+    protected boolean isAccept( long internalFlags )
+    {
+        return (internalFlags & acceptBit) != 0;
     }
 
     @Override
-    public long getTurnFlags( boolean restricted, int costs )
+    public boolean isBackward( long flags )
     {
-        costs = Math.min(costs, (int) (Math.pow(2, maxCostsBits) - 1));
-        long encode = costs << costShift;
-        if (restricted)
+        return (flags & backwardBit) != 0;
+    }
+
+    @Override
+    public boolean isForward( long flags )
+    {
+        return (flags & forwardBit) != 0;
+    }
+
+    @Override
+    public long setBool( long flags, int key, boolean value )
+    {
+        switch (key)
+        {
+            case K_FORWARD:
+                return value ? flags | forwardBit : flags & ~forwardBit;
+            case K_BACKWARD:
+                return value ? flags | backwardBit : flags & ~backwardBit;
+            case K_ROUNDABOUT:
+                return value ? flags | roundaboutBit : flags & ~roundaboutBit;
+            default:
+                throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
+        }
+    }
+
+    @Override
+    public boolean isBool( long flags, int key )
+    {
+        switch (key)
+        {
+            case K_FORWARD:
+                return isForward(flags);
+            case K_BACKWARD:
+                return isBackward(flags);
+            case K_ROUNDABOUT:
+                return (flags & roundaboutBit) != 0;
+            default:
+                throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
+        }
+    }
+
+    @Override
+    public long setLong( long flags, int key, long value )
+    {
+        throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
+    }
+
+    @Override
+    public long getLong( long flags, int key )
+    {
+        throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
+    }
+
+    @Override
+    public long setDouble( long flags, int key, double value )
+    {
+        throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
+    }
+
+    @Override
+    public double getDouble( long flags, int key )
+    {
+        throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
+    }
+
+    protected static double parseDouble( String str, String key, double defaultD )
+    {
+        String val = getStr(str, key);
+        if (val.isEmpty())
+            return defaultD;
+        return Double.parseDouble(val);
+    }
+
+    protected static long parseLong( String str, String key, long defaultL )
+    {
+        String val = getStr(str, key);
+        if (val.isEmpty())
+            return defaultL;
+        return Long.parseLong(val);
+    }
+
+    protected static boolean parseBoolean( String str, String key, boolean defaultB )
+    {
+        String val = getStr(str, key);
+        if (val.isEmpty())
+            return defaultB;
+        return Boolean.parseBoolean(val);
+    }
+
+    protected static String getStr( String str, String key )
+    {
+        key = key.toLowerCase();
+        for (String s : str.split("\\|"))
         {
-            encode |= restrictionBit;
+            s = s.trim().toLowerCase();
+            int index = s.indexOf("=");
+            if (index < 0)
+                continue;
+
+            String field = s.substring(0, index);
+            String valueStr = s.substring(index + 1);
+            if (key.equals(field))
+                return valueStr;
         }
-        return encode;
+        return "";
     }
 
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
+    /**
+     * @param force should be false if speed should be changed only if it is bigger than maxspeed.
+     */
+    protected double applyMaxSpeed( OSMWay way, double speed, boolean force )
     {
-        return Collections.emptyList();
+        double maxSpeed = getMaxSpeed(way);
+        // apply only if smaller maxSpeed
+        if (maxSpeed >= 0)
+        {
+            if (force || maxSpeed < speed)
+                return maxSpeed * 0.9;
+        }
+        return speed;
+    }
+
+    protected String getPropertiesString()
+    {
+        return "speedFactor=" + speedFactor + "|speedBits=" + speedBits + "|turnCosts=" + (maxTurnCosts > 0);
+    }
+
+    @Override
+    public boolean supports( Class<?> feature )
+    {
+        if (TurnWeighting.class.isAssignableFrom(feature))
+            return maxTurnCosts > 0;
+
+        return false;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java b/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java
deleted file mode 100644
index 2eb5a9e664..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.storage.Graph;
-
-/**
- * Holds an algorithm which can be prepared and created.
- * <p/>
- * @author Peter Karich
- */
-public interface AlgorithmPreparation
-{
-    /**
-     * Prepares the underlying graph to be used by a specialized algorithm.
-     */
-    AlgorithmPreparation doWork();
-
-    /**
-     * @return true if doWork was already called.
-     */
-    boolean isPrepared();
-
-    AlgorithmPreparation setGraph( Graph g );
-
-    RoutingAlgorithm createAlgo();
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
index 3f256b5280..3a88c83a7b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
@@ -24,5 +24,8 @@
  */
 public interface AllEdgesIterator extends EdgeIterator
 {
-    int getMaxId();
+    /**
+     * @return the number of edges
+     */
+    int getCount();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
new file mode 100644
index 0000000000..5df84cfe62
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
@@ -0,0 +1,52 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.DistancePlaneProjection;
+
+/**
+ * Approximates the distance to the goalNode by weighting the beeline distance according to the distance weighting
+ * @author jansoe
+ */
+public class BeelineWeightApproximator implements WeightApproximator {
+
+    private NodeAccess nodeAccess;
+    private Weighting weighting;
+    private DistanceCalc distanceCalc;
+    double toLat, toLon;
+
+    public BeelineWeightApproximator(NodeAccess nodeAccess, Weighting weighting) {
+        this.nodeAccess = nodeAccess;
+        this.weighting = weighting;
+        setDistanceCalc(new DistanceCalcEarth());
+    }
+
+    public void setGoalNode(int toNode){
+        toLat = nodeAccess.getLatitude(toNode);
+        toLon = nodeAccess.getLongitude(toNode);
+    }
+
+    @Override
+    public WeightApproximator duplicate() {
+        return new BeelineWeightApproximator(nodeAccess, weighting).setDistanceCalc(distanceCalc);
+    }
+
+
+    @Override
+    public double approximate(int fromNode) {
+
+        double fromLat, fromLon, dist2goal, weight2goal;
+        fromLat  = nodeAccess.getLatitude(fromNode);
+        fromLon = nodeAccess.getLongitude(fromNode);
+        dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
+        weight2goal = weighting.getMinWeight(dist2goal);
+
+        return weight2goal;
+    }
+
+    public BeelineWeightApproximator setDistanceCalc(DistanceCalc distanceCalc) {
+        this.distanceCalc = distanceCalc;
+        return this;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
new file mode 100644
index 0000000000..886c62c6a0
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -0,0 +1,233 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import static com.graphhopper.util.Helper.*;
+
+/**
+ * Stores two speed values into an edge to support avoiding too much incline
+ * <p>
+ * @author Peter Karich
+ */
+public class Bike2WeightFlagEncoder extends BikeFlagEncoder
+{
+    private EncodedDoubleValue reverseSpeed;
+
+    public Bike2WeightFlagEncoder()
+    {
+        super();
+    }
+
+    public Bike2WeightFlagEncoder( String propertiesStr )
+    {
+        super(propertiesStr);
+    }
+
+    public Bike2WeightFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+    }
+
+    @Override
+    public int defineWayBits( int index, int shift )
+    {
+        shift = super.defineWayBits(index, shift);
+        reverseSpeed = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, getHighwaySpeed("cycleway"), 30);
+        shift += reverseSpeed.getBits();
+        return shift;
+    }
+
+    @Override
+    public double getReverseSpeed( long flags )
+    {
+        return reverseSpeed.getDoubleValue(flags);
+    }
+
+    @Override
+    public long setReverseSpeed( long flags, double speed )
+    {
+        if (speed < 0)
+            throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
+
+        if (speed > getMaxSpeed())
+            speed = getMaxSpeed();
+
+        return reverseSpeed.setDoubleValue(flags, speed);
+    }
+
+    @Override
+    public long handleSpeed( OSMWay way, double speed, long encoded )
+    {
+        // handle oneways
+        if ((way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
+                && !way.hasTag("oneway:bicycle", "no")
+                && !way.hasTag("cycleway", oppositeLanes))
+        {
+
+            if (way.hasTag("oneway", "-1"))
+            {
+                encoded |= backwardBit;
+                encoded = setReverseSpeed(encoded, speed);
+            } else
+            {
+                encoded |= forwardBit;
+                encoded = setSpeed(encoded, speed);
+            }
+        } else
+        {
+            encoded |= directionBitMask;
+            encoded = setSpeed(encoded, speed);
+            encoded = setReverseSpeed(encoded, speed);
+        }
+        return encoded;
+    }
+
+    @Override
+    public long flagsDefault( boolean forward, boolean backward )
+    {
+        long flags = super.flagsDefault(forward, backward);
+        if (backward)
+            return reverseSpeed.setDefaultValue(flags);
+
+        return flags;
+    }
+
+    @Override
+    public long setProperties( double speed, boolean forward, boolean backward )
+    {
+        long flags = super.setProperties(speed, forward, backward);
+        if (backward)
+            return setReverseSpeed(flags, speed);
+
+        return flags;
+    }
+
+    @Override
+    public long reverseFlags( long flags )
+    {
+        // swap access
+        flags = super.reverseFlags(flags);
+
+        // swap speeds 
+        double otherValue = reverseSpeed.getDoubleValue(flags);
+        flags = setReverseSpeed(flags, speedEncoder.getDoubleValue(flags));
+        return setSpeed(flags, otherValue);
+    }
+
+    @Override
+    public void applyWayTags( OSMWay way, EdgeIteratorState edge )
+    {
+        PointList pl = edge.fetchWayGeometry(3);
+        if (!pl.is3D())
+            throw new IllegalStateException("To support speed calculation based on elevation data it is necessary to enable import of it.");
+
+        long flags = edge.getFlags();
+
+        if (way.hasTag("tunnel", "yes") || way.hasTag("bridge", "yes") || way.hasTag("highway", "steps"))
+        {
+            // do not change speed
+            // note: although tunnel can have a difference in elevation it is very unlikely that the elevation data is correct for a tunnel
+        } else
+        {
+            // Decrease the speed for ele increase (incline), and decrease the speed for ele decrease (decline). The speed-decrease 
+            // has to be bigger (compared to the speed-increase) for the same elevation difference to simulate loosing energy and avoiding hills.
+            // For the reverse speed this has to be the opposite but again keeping in mind that up+down difference.
+            double incEleSum = 0, incDist2DSum = 0;
+            double decEleSum = 0, decDist2DSum = 0;
+            // double prevLat = pl.getLatitude(0), prevLon = pl.getLongitude(0);
+            double prevEle = pl.getElevation(0);
+            double fullDist2D = 0;
+
+            fullDist2D = edge.getDistance();
+            double eleDelta = pl.getElevation(pl.size() - 1) - prevEle;
+            if (eleDelta > 0.1)
+            {
+                incEleSum = eleDelta;
+                incDist2DSum = fullDist2D;
+            } else if (eleDelta < -0.1)
+            {
+                decEleSum = -eleDelta;
+                decDist2DSum = fullDist2D;
+            }
+
+//            // get a more detailed elevation information, but due to bad SRTM data this does not make sense now.
+//            for (int i = 1; i < pl.size(); i++)
+//            {
+//                double lat = pl.getLatitude(i);
+//                double lon = pl.getLongitude(i);
+//                double ele = pl.getElevation(i);
+//                double eleDelta = ele - prevEle;
+//                double dist2D = distCalc.calcDist(prevLat, prevLon, lat, lon);
+//                if (eleDelta > 0.1)
+//                {
+//                    incEleSum += eleDelta;
+//                    incDist2DSum += dist2D;
+//                } else if (eleDelta < -0.1)
+//                {
+//                    decEleSum += -eleDelta;
+//                    decDist2DSum += dist2D;
+//                }
+//                fullDist2D += dist2D;
+//                prevLat = lat;
+//                prevLon = lon;
+//                prevEle = ele;
+//            }
+            // Calculate slop via tan(asin(height/distance)) but for rather smallish angles where we can assume tan a=a and sin a=a.
+            // Then calculate a factor which decreases or increases the speed.
+            // Do this via a simple quadratic equation where y(0)=1 and y(0.3)=1/4 for incline and y(0.3)=2 for decline        
+            double fwdIncline = incDist2DSum > 1 ? incEleSum / incDist2DSum : 0;
+            double fwdDecline = decDist2DSum > 1 ? decEleSum / decDist2DSum : 0;
+            double restDist2D = fullDist2D - incDist2DSum - decDist2DSum;
+            double maxSpeed = getHighwaySpeed("cycleway");
+            if (isForward(flags))
+            {
+                // use weighted mean so that longer incline infuences speed more than shorter
+                double speed = getSpeed(flags);
+                double fwdFaster = 1 + 2 * keepIn(fwdDecline, 0, 0.2);
+                fwdFaster = fwdFaster * fwdFaster;
+                double fwdSlower = 1 - 5 * keepIn(fwdIncline, 0, 0.2);
+                fwdSlower = fwdSlower * fwdSlower;
+                speed = speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum + 1 * restDist2D) / fullDist2D;
+                flags = this.setSpeed(flags, keepIn(speed, PUSHING_SECTION_SPEED / 2, maxSpeed));
+            }
+
+            if (isBackward(flags))
+            {
+                double speedReverse = getReverseSpeed(flags);
+                double bwFaster = 1 + 2 * keepIn(fwdIncline, 0, 0.2);
+                bwFaster = bwFaster * bwFaster;
+                double bwSlower = 1 - 5 * keepIn(fwdDecline, 0, 0.2);
+                bwSlower = bwSlower * bwSlower;
+                speedReverse = speedReverse * (bwFaster * incDist2DSum + bwSlower * decDist2DSum + 1 * restDist2D) / fullDist2D;
+                flags = this.setReverseSpeed(flags, keepIn(speedReverse, PUSHING_SECTION_SPEED / 2, maxSpeed));
+            }
+        }
+        edge.setFlags(flags);
+    }
+
+    @Override
+    public String toString()
+    {
+        return "bike2";
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
new file mode 100644
index 0000000000..fcf8179ec5
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -0,0 +1,680 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.OSMWay;
+import com.graphhopper.reader.OSMRelation;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionAnnotation;
+import com.graphhopper.util.Translation;
+
+import java.util.*;
+
+/**
+ * Defines bit layout of bicycles (not motorcycles) for speed, access and relations (network).
+ * <p/>
+ * @author Peter Karich
+ * @author Nop
+ * @author ratrun
+ */
+public class BikeCommonFlagEncoder extends AbstractFlagEncoder
+{
+    /**
+     * Reports wether this edge is unpaved.
+     */
+    public static final int K_UNPAVED = 100;
+    protected static final int PUSHING_SECTION_SPEED = 4;
+    private long unpavedBit = 0;
+    // Pushing section heighways are parts where you need to get off your bike and push it (German: Schiebestrecke)
+    protected final HashSet<String> pushingSections = new HashSet<String>();
+    protected final HashSet<String> oppositeLanes = new HashSet<String>();
+    protected final Set<String> preferHighwayTags = new HashSet<String>();
+    protected final Set<String> avoidHighwayTags = new HashSet<String>();
+    protected final Set<String> unpavedSurfaceTags = new HashSet<String>();
+    private final Map<String, Integer> trackTypeSpeed = new HashMap<String, Integer>();
+    private final Map<String, Integer> surfaceSpeed = new HashMap<String, Integer>();
+    private final Set<String> roadValues = new HashSet<String>();
+    private final Map<String, Integer> highwaySpeed = new HashMap<String, Integer>();
+    // convert network tag of bicycle routes into a way route code
+    private final Map<String, Integer> bikeNetworkToCode = new HashMap<String, Integer>();
+    protected EncodedValue relationCodeEncoder;
+    private EncodedValue wayTypeEncoder;
+    private EncodedValue preferWayEncoder;
+
+    protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        // strict set, usually vehicle and agricultural/forestry are ignored by cyclists
+        restrictions.addAll(Arrays.asList("bicycle", "access"));
+        restrictedValues.add("private");
+        restrictedValues.add("no");
+        restrictedValues.add("restricted");
+        restrictedValues.add("military");
+
+        intendedValues.add("yes");
+        intendedValues.add("designated");
+        intendedValues.add("official");
+        intendedValues.add("permissive");
+
+        oppositeLanes.add("opposite");
+        oppositeLanes.add("opposite_lane");
+        oppositeLanes.add("opposite_track");
+
+        setBlockByDefault(false);
+        potentialBarriers.add("gate");
+        // potentialBarriers.add("lift_gate");
+        potentialBarriers.add("swing_gate");
+
+        absoluteBarriers.add("kissing_gate");
+        absoluteBarriers.add("stile");
+        absoluteBarriers.add("turnstile");
+
+        unpavedSurfaceTags.add("unpaved");
+        unpavedSurfaceTags.add("gravel");
+        unpavedSurfaceTags.add("ground");
+        unpavedSurfaceTags.add("dirt");
+        unpavedSurfaceTags.add("grass");
+        unpavedSurfaceTags.add("compacted");
+        unpavedSurfaceTags.add("earth");
+        unpavedSurfaceTags.add("fine_gravel");
+        unpavedSurfaceTags.add("grass_paver");
+        unpavedSurfaceTags.add("ice");
+        unpavedSurfaceTags.add("mud");
+        unpavedSurfaceTags.add("salt");
+        unpavedSurfaceTags.add("sand");
+        unpavedSurfaceTags.add("wood");
+
+        roadValues.add("living_street");
+        roadValues.add("road");
+        roadValues.add("service");
+        roadValues.add("unclassified");
+        roadValues.add("residential");
+        roadValues.add("trunk");
+        roadValues.add("trunk_link");
+        roadValues.add("primary");
+        roadValues.add("primary_link");
+        roadValues.add("secondary");
+        roadValues.add("secondary_link");
+        roadValues.add("tertiary");
+        roadValues.add("tertiary_link");
+
+        setTrackTypeSpeed("grade1", 18); // paved
+        setTrackTypeSpeed("grade2", 12); // now unpaved ...
+        setTrackTypeSpeed("grade3", 8);
+        setTrackTypeSpeed("grade4", 6);
+        setTrackTypeSpeed("grade5", 4); // like sand/grass     
+
+        setSurfaceSpeed("paved", 18);
+        setSurfaceSpeed("asphalt", 18);
+        setSurfaceSpeed("cobblestone", 8);
+        setSurfaceSpeed("cobblestone:flattened", 10);
+        setSurfaceSpeed("sett", 10);
+        setSurfaceSpeed("concrete", 18);
+        setSurfaceSpeed("concrete:lanes", 16);
+        setSurfaceSpeed("concrete:plates", 16);
+        setSurfaceSpeed("paving_stones", 12);
+        setSurfaceSpeed("paving_stones:30", 12);
+        setSurfaceSpeed("unpaved", 14);
+        setSurfaceSpeed("compacted", 16);
+        setSurfaceSpeed("dirt", 10);
+        setSurfaceSpeed("earth", 12);
+        setSurfaceSpeed("fine_gravel", 18);
+        setSurfaceSpeed("grass", 8);
+        setSurfaceSpeed("grass_paver", 8);
+        setSurfaceSpeed("gravel", 12);
+        setSurfaceSpeed("ground", 12);
+        setSurfaceSpeed("ice", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("metal", 10);
+        setSurfaceSpeed("mud", 10);
+        setSurfaceSpeed("pebblestone", 16);
+        setSurfaceSpeed("salt", 6);
+        setSurfaceSpeed("sand", 6);
+        setSurfaceSpeed("wood", 6);
+
+        setHighwaySpeed("living_street", 6);
+        setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
+
+        setHighwaySpeed("cycleway", 18);
+        setHighwaySpeed("path", 18);
+        setHighwaySpeed("footway", 6);
+        setHighwaySpeed("pedestrian", 6);
+        setHighwaySpeed("track", 12);
+        setHighwaySpeed("service", 14);
+        setHighwaySpeed("residential", 18);
+        // no other highway applies:
+        setHighwaySpeed("unclassified", 16);
+        // unknown road:
+        setHighwaySpeed("road", 12);
+
+        setHighwaySpeed("trunk", 18);
+        setHighwaySpeed("trunk_link", 18);
+        setHighwaySpeed("primary", 18);
+        setHighwaySpeed("primary_link", 18);
+        setHighwaySpeed("secondary", 18);
+        setHighwaySpeed("secondary_link", 18);
+        setHighwaySpeed("tertiary", 18);
+        setHighwaySpeed("tertiary_link", 18);
+
+        // special case see tests and #191
+        setHighwaySpeed("motorway", 18);
+        setHighwaySpeed("motorway_link", 18);
+        avoidHighwayTags.add("motorway");
+        avoidHighwayTags.add("motorway_link");
+
+        setCyclingNetworkPreference("icn", PriorityCode.BEST.getValue());
+        setCyclingNetworkPreference("ncn", PriorityCode.BEST.getValue());
+        setCyclingNetworkPreference("rcn", PriorityCode.VERY_NICE.getValue());
+        setCyclingNetworkPreference("lcn", PriorityCode.PREFER.getValue());
+        setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
+
+        setCyclingNetworkPreference("deprecated", PriorityCode.AVOID_AT_ALL_COSTS.getValue());
+    }
+
+    @Override
+    public int defineWayBits( int index, int shift )
+    {
+        // first two bits are reserved for route handling in superclass
+        shift = super.defineWayBits(index, shift);
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeed.get("cycleway"), 30);
+        shift += speedEncoder.getBits();
+
+        unpavedBit = 1L << shift++;
+        // 2 bits
+        wayTypeEncoder = new EncodedValue("WayType", shift, 2, 1, 0, 3, true);
+        shift += wayTypeEncoder.getBits();
+
+        preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
+        shift += preferWayEncoder.getBits();
+
+        return shift;
+    }
+
+    @Override
+    public int defineRelationBits( int index, int shift )
+    {
+        relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
+        return shift + relationCodeEncoder.getBits();
+    }
+
+    @Override
+    public long acceptWay( OSMWay way )
+    {
+        String highwayValue = way.getTag("highway");
+        if (highwayValue == null)
+        {
+            if (way.hasTag("route", ferries))
+            {
+                // if bike is NOT explictly tagged allow bike but only if foot is not specified
+                String bikeTag = way.getTag("bicycle");
+                if (bikeTag == null && !way.hasTag("foot") || "yes".equals(bikeTag))
+                    return acceptBit | ferryBit;
+            }
+            return 0;
+        }
+
+        if (!highwaySpeed.containsKey(highwayValue))
+            return 0;
+
+        // use the way if it is tagged for bikes
+        if (way.hasTag("bicycle", intendedValues))
+            return acceptBit;
+
+        // accept only if explicitely tagged for bike usage
+        if ("motorway".equals(highwayValue) || "motorway_link".equals(highwayValue))
+            return 0;
+
+        if (way.hasTag("motorroad", "yes"))
+            return 0;
+
+        // do not use fords with normal bikes, flagged fords are in included above
+        if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
+            return 0;
+
+        // check access restrictions
+        if (way.hasTag(restrictions, restrictedValues))
+            return 0;
+
+        // do not accept railways (sometimes incorrectly mapped!)
+        if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
+            return 0;
+
+        String sacScale = way.getTag("sac_scale");
+        if (sacScale != null)
+        {
+            if ((way.hasTag("highway", "cycleway"))
+                    && (way.hasTag("sac_scale", "hiking")))
+                return acceptBit;
+            if (!allowedSacScale(sacScale))
+                return 0;
+        }
+        return acceptBit;
+    }
+
+    boolean allowedSacScale( String sacScale )
+    {
+        // other scales are nearly impossible by an ordinary bike, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
+        return "hiking".equals(sacScale);
+    }
+
+    @Override
+    public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
+    {
+        int code = 0;
+        if (relation.hasTag("route", "bicycle"))
+        {
+            Integer val = bikeNetworkToCode.get(relation.getTag("network"));
+            if (val != null)
+                code = val;
+        } else if (relation.hasTag("route", "ferry"))
+        {
+            code = PriorityCode.AVOID_IF_POSSIBLE.getValue();
+        }
+
+        int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
+        if (oldCode < code)
+            return relationCodeEncoder.setValue(0, code);
+        return oldRelationFlags;
+    }
+
+    @Override
+    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
+    {
+        if (!isAccept(allowed))
+            return 0;
+
+        long encoded = 0;
+        if (!isFerry(allowed))
+        {
+            double speed = getSpeed(way);
+            int priorityFromRelation = 0;
+            if (relationFlags != 0)
+                priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
+
+            encoded = setLong(encoded, PriorityWeighting.KEY, handlePriority(way, priorityFromRelation));
+
+            // bike maxspeed handling is different from car as we don't increase speed
+            speed = applyMaxSpeed(way, speed, false);
+            encoded = handleSpeed(way, speed, encoded);
+            encoded = handleBikeRelated(way, encoded, relationFlags > UNCHANGED.getValue());
+
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+            {
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
+            }
+
+        } else
+        {
+            encoded = handleFerryTags(way,
+                    highwaySpeed.get("living_street"),
+                    highwaySpeed.get("track"),
+                    highwaySpeed.get("primary"));
+            encoded |= directionBitMask;
+        }
+        return encoded;
+    }
+
+    int getSpeed( OSMWay way )
+    {
+        int speed = PUSHING_SECTION_SPEED;
+        String s = way.getTag("surface");
+        if (!Helper.isEmpty(s))
+        {
+            Integer sInt = surfaceSpeed.get(s);
+            if (sInt != null)
+                speed = sInt;
+        } else
+        {
+            String tt = way.getTag("tracktype");
+            if (!Helper.isEmpty(tt))
+            {
+                Integer tInt = trackTypeSpeed.get(tt);
+                if (tInt != null)
+                    speed = tInt;
+            } else
+            {
+                String highway = way.getTag("highway");
+                if (!Helper.isEmpty(highway))
+                {
+                    Integer hwInt = highwaySpeed.get(highway);
+                    if (hwInt != null)
+                    {
+                        if (way.getTag("service") == null)
+                            speed = hwInt;
+                        else
+                            speed = highwaySpeed.get("living_street");
+                    }
+                }
+            }
+        }
+
+        // Until now we assumed that the way is no pusing section
+        // Now we check, but only in case that our speed is bigger compared to the PUSHING_SECTION_SPEED
+        if ((speed > PUSHING_SECTION_SPEED)
+                && (!way.hasTag("bicycle", intendedValues) && way.hasTag("highway", pushingSections)))
+        {
+            if (way.hasTag("highway", "steps"))
+                speed = PUSHING_SECTION_SPEED / 2;
+            else
+                speed = PUSHING_SECTION_SPEED;
+        }
+
+        return speed;
+    }
+
+    @Override
+    public InstructionAnnotation getAnnotation( long flags, Translation tr )
+    {
+        int paveType = 0; // paved
+        if (isBool(flags, K_UNPAVED))
+            paveType = 1; // unpaved        
+
+        int wayType = (int) wayTypeEncoder.getValue(flags);
+        String wayName = getWayName(paveType, wayType, tr);
+        return new InstructionAnnotation(0, wayName);
+    }
+
+    String getWayName( int pavementType, int wayType, Translation tr )
+    {
+        String pavementName = "";
+        if (pavementType == 1)
+            pavementName = tr.tr("unpaved");
+
+        String wayTypeName = "";
+        switch (wayType)
+        {
+            case 0:
+                wayTypeName = tr.tr("road");
+                break;
+            case 1:
+                wayTypeName = tr.tr("off_bike");
+                break;
+            case 2:
+                wayTypeName = tr.tr("cycleway");
+                break;
+            case 3:
+                wayTypeName = tr.tr("way");
+                break;
+        }
+
+        if (pavementName.isEmpty())
+        {
+            if (wayType == 0 || wayType == 3)
+                return "";
+            return wayTypeName;
+        } else
+        {
+            if (wayTypeName.isEmpty())
+                return pavementName;
+            else
+                return wayTypeName + ", " + pavementName;
+        }
+    }
+
+    /**
+     * In this method we prefer cycleways or roads with designated bike access and avoid big roads
+     * or roads with trams or pedestrian.
+     * <p>
+     * @return new priority based on priorityFromRelation and on the tags in OSMWay.
+     */
+    protected int handlePriority( OSMWay way, int priorityFromRelation )
+    {
+        TreeMap<Double, Integer> weightToPrioMap = new TreeMap<Double, Integer>();
+        if (priorityFromRelation == 0)
+            weightToPrioMap.put(0d, UNCHANGED.getValue());
+        else
+            weightToPrioMap.put(110d, priorityFromRelation);
+
+        collect(way, weightToPrioMap);
+
+        // pick priority with biggest order value
+        return weightToPrioMap.lastEntry().getValue();
+    }
+
+    /**
+     * @param weightToPrioMap associate a weight with every priority. This sorted map allows
+     * subclasses to 'insert' more important priorities as well as overwrite determined priorities.
+     */
+    void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
+    {
+        String service = way.getTag("service");
+        String highway = way.getTag("highway");
+        if (way.hasTag("bicycle", "designated"))
+            weightToPrioMap.put(100d, PREFER.getValue());
+        if ("cycleway".equals(highway))
+            weightToPrioMap.put(100d, VERY_NICE.getValue());
+
+        double maxSpeed = getMaxSpeed(way);
+        if (preferHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 30)
+        {
+            weightToPrioMap.put(40d, PREFER.getValue());
+            if (way.hasTag("tunnel", intendedValues))
+                weightToPrioMap.put(40d, UNCHANGED.getValue());
+        }
+
+        if (pushingSections.contains(highway)
+                || way.hasTag("bicycle", "use_sidepath")
+                || "parking_aisle".equals(service))
+        {
+            weightToPrioMap.put(50d, AVOID_IF_POSSIBLE.getValue());
+        }
+
+        if (avoidHighwayTags.contains(highway) || maxSpeed > 80)
+        {
+            weightToPrioMap.put(50d, REACH_DEST.getValue());
+            if (way.hasTag("tunnel", intendedValues))
+                weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+        }
+
+        if (way.hasTag("railway", "tram"))
+            weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+    }
+
+    /**
+     * Handle surface and wayType encoding
+     */
+    long handleBikeRelated( OSMWay way, long encoded, boolean partOfCycleRelation )
+    {
+        String surfaceTag = way.getTag("surface");
+        String highway = way.getTag("highway");
+        String trackType = way.getTag("tracktype");
+
+        // Populate bits at wayTypeMask with wayType            
+        WayType wayType = WayType.OTHER_SMALL_WAY;
+        boolean isPusingSection = isPushingSection(way);
+        if (isPusingSection && !partOfCycleRelation || "steps".equals(highway))
+            wayType = WayType.PUSHING_SECTION;
+
+        if ("track".equals(highway) && (trackType == null || !"grade1".equals(trackType))
+                || "path".equals(highway) && surfaceTag == null
+                || unpavedSurfaceTags.contains(surfaceTag))
+        {
+            encoded = setBool(encoded, K_UNPAVED, true);
+        }
+
+        if (way.hasTag("bicycle", intendedValues))
+        {
+            if (isPusingSection && !way.hasTag("bicycle", "designated"))
+                wayType = WayType.OTHER_SMALL_WAY;
+            else
+                wayType = WayType.CYCLEWAY;
+        } else if ("cycleway".equals(highway))
+            wayType = WayType.CYCLEWAY;
+        else if (roadValues.contains(highway))
+            wayType = WayType.ROAD;
+
+        return wayTypeEncoder.setValue(encoded, wayType.getValue());
+    }
+
+    @Override
+    public long setBool( long flags, int key, boolean value )
+    {
+        switch (key)
+        {
+            case K_UNPAVED:
+                return value ? flags | unpavedBit : flags & ~unpavedBit;
+            default:
+                return super.setBool(flags, key, value);
+        }
+    }
+
+    @Override
+    public boolean isBool( long flags, int key )
+    {
+        switch (key)
+        {
+            case K_UNPAVED:
+                return (flags & unpavedBit) != 0;
+            default:
+                return super.isBool(flags, key);
+        }
+    }
+
+    @Override
+    public double getDouble( long flags, int key )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                double prio = preferWayEncoder.getValue(flags);
+                if (prio == 0)
+                    return (double) UNCHANGED.getValue() / BEST.getValue();
+
+                return prio / BEST.getValue();
+            default:
+                return super.getDouble(flags, key);
+        }
+    }
+
+    @Override
+    public long getLong( long flags, int key )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.getValue(flags);
+            default:
+                return super.getLong(flags, key);
+        }
+    }
+
+    @Override
+    public long setLong( long flags, int key, long value )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.setValue(flags, value);
+            default:
+                return super.setLong(flags, key, value);
+        }
+    }
+
+    boolean isPushingSection( OSMWay way )
+    {
+        return way.hasTag("highway", pushingSections);
+    }
+
+    protected long handleSpeed( OSMWay way, double speed, long encoded )
+    {
+        encoded = setSpeed(encoded, speed);
+
+        // handle oneways        
+        boolean isOneway = way.hasTag("oneway", oneways)
+                || way.hasTag("vehicle:backward")
+                || way.hasTag("vehicle:forward");
+
+        if ((isOneway || way.hasTag("junction", "roundabout"))
+                && !way.hasTag("oneway:bicycle", "no")
+                && !way.hasTag("bicycle:backward")
+                && !way.hasTag("cycleway", oppositeLanes))
+        {
+            boolean isBackward = way.hasTag("oneway", "-1")
+                    || way.hasTag("vehicle:forward", "no");
+            if (isBackward)
+                encoded |= backwardBit;
+            else
+                encoded |= forwardBit;
+
+        } else
+        {
+            encoded |= directionBitMask;
+        }
+        return encoded;
+    }
+
+    private enum WayType
+    {
+        ROAD(0),
+        PUSHING_SECTION(1),
+        CYCLEWAY(2),
+        OTHER_SMALL_WAY(3);
+
+        private final int value;
+
+        private WayType( int value )
+        {
+            this.value = value;
+        }
+
+        public int getValue()
+        {
+            return value;
+        }
+    };
+
+    protected void setHighwaySpeed( String highway, int speed )
+    {
+        highwaySpeed.put(highway, speed);
+    }
+
+    protected int getHighwaySpeed( String key )
+    {
+        return highwaySpeed.get(key);
+    }
+
+    void setTrackTypeSpeed( String tracktype, int speed )
+    {
+        trackTypeSpeed.put(tracktype, speed);
+    }
+
+    void setSurfaceSpeed( String surface, int speed )
+    {
+        surfaceSpeed.put(surface, speed);
+    }
+
+    void setCyclingNetworkPreference( String network, int code )
+    {
+        bikeNetworkToCode.put(network, code);
+    }
+
+    void addPushingSection( String highway )
+    {
+        pushingSections.add(highway);
+    }
+
+    @Override
+    public boolean supports( Class<?> feature )
+    {
+        if (super.supports(feature))
+            return true;
+
+        return PriorityWeighting.class.isAssignableFrom(feature);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagCommonEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagCommonEncoder.java
deleted file mode 100644
index ed17563953..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagCommonEncoder.java
+++ /dev/null
@@ -1,458 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMWay;
-import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.util.Helper;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Defines bit layout of bicycles (not motorbikes) for speed, access and relations (network).
- * <p/>
- * @author Peter Karich
- * @author Nop
- * @author ratrun
- */
-public class BikeFlagCommonEncoder extends AbstractFlagEncoder
-{
-    protected static final int DEFAULT_REL_CODE = 4;
-    protected static final int PUSHING_SECTION_SPEED = 4;
-    // private int safeWayBit = 0;
-    private int unpavedBit = 0;
-    // Pushing section heighways are parts where you need to get off your bike and push it (German: Schiebestrecke)
-    private final HashSet<String> pushingSections = new HashSet<String>();
-    private final HashSet<String> oppositeLanes = new HashSet<String>();
-    private final Set<String> unpavedSurfaceTags = new HashSet<String>();
-    private final Map<String, Integer> trackTypeSpeed = new HashMap<String, Integer>();
-    private final Map<String, Integer> surfaceSpeed = new HashMap<String, Integer>();
-    private final Set<String> roadValues = new HashSet<String>();
-    private final Map<String, Integer> highwaySpeed = new HashMap<String, Integer>();
-    //Convert network tag of bicycle routes into a way route code stored in the wayMAP
-    private final Map<String, Integer> bikeNetworkToCode = new HashMap<String, Integer>();
-    protected EncodedValue relationCodeEncoder;
-    private EncodedValue wayTypeEncoder;
-
-    /**
-     * Should be only instantied via EncodingManager
-     */
-    protected BikeFlagCommonEncoder()
-    {
-        super(4, 2);
-        // strict set, usually vehicle and agricultural/forestry are ignored by cyclists
-        restrictions = new String[]
-        {
-            "bicycle", "access"
-        };
-        restrictedValues.add("private");
-        restrictedValues.add("no");
-        restrictedValues.add("restricted");
-
-        intended.add("yes");
-        intended.add("designated");
-        intended.add("official");
-        intended.add("permissive");
-
-        oppositeLanes.add("opposite");
-        oppositeLanes.add("opposite_lane");
-        oppositeLanes.add("opposite_track");
-
-        // With a bike one usually can pass all those barriers:
-        // potentialBarriers.add("gate");
-        // potentialBarriers.add("lift_gate");
-        // potentialBarriers.add("swing_gate");
-        // potentialBarriers.add("cycle_barrier");
-        // potentialBarriers.add("block");
-        absoluteBarriers.add("kissing_gate");
-        absoluteBarriers.add("stile");
-        absoluteBarriers.add("turnstile");
-        // very dangerous
-        // acceptedRailways.remove("tram");
-
-        unpavedSurfaceTags.add("unpaved");
-        unpavedSurfaceTags.add("gravel");
-        unpavedSurfaceTags.add("ground");
-        unpavedSurfaceTags.add("dirt");
-        unpavedSurfaceTags.add("paving_stones");
-        unpavedSurfaceTags.add("grass");
-        unpavedSurfaceTags.add("cobblestone");
-
-        roadValues.add("living_street");
-        roadValues.add("road");
-        roadValues.add("service");
-        roadValues.add("unclassified");
-        roadValues.add("residential");
-        roadValues.add("trunk");
-        roadValues.add("trunk_link");
-        roadValues.add("primary");
-        roadValues.add("primary_link");
-        roadValues.add("secondary");
-        roadValues.add("secondary_link");
-        roadValues.add("tertiary");
-        roadValues.add("tertiary_link");
-
-        setCyclingNetworkPreference("deprecated", RelationMapCode.AVOID_AT_ALL_COSTS.getValue());
-    }
-
-    @Override
-    public int defineWayBits( int index, int shift )
-    {
-        // first two bits are reserved for route handling in superclass
-        shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedValue("Speed", shift, speedBits, speedFactor, highwaySpeed.get("cycleway"), 30);
-        shift += speedBits;
-
-        //safeWayBit = 1 << shift++;
-        unpavedBit = 1 << shift++;
-        // 2 bits
-        wayTypeEncoder = new EncodedValue("WayType", shift, 2, 1, 0, 3);
-        return shift + 2;
-    }
-
-    @Override
-    public int defineRelationBits( int index, int shift )
-    {
-        relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
-        return shift + 3;
-    }
-
-    @Override
-    public long acceptWay( OSMWay way )
-    {
-        String highwayValue = way.getTag("highway");
-        if (highwayValue == null)
-        {
-            if (way.hasTag("route", ferries))
-            {
-                // if bike is NOT explictly tagged allow bike but only if foot is not specified
-                String bikeTag = way.getTag("bicycle");
-                if (bikeTag == null && !way.hasTag("foot") || "yes".equals(bikeTag))
-                    return acceptBit | ferryBit;
-            }
-            return 0;
-        }
-
-        if (!highwaySpeed.containsKey(highwayValue))
-            return 0;
-
-        // use the way if it is tagged for bikes
-        if (way.hasTag("bicycle", intended))
-            return acceptBit;
-
-        if (way.hasTag("motorroad", "yes"))
-            return 0;
-
-        // do not use fords with normal bikes, flagged fords are in included above
-        if (way.hasTag("highway", "ford") || way.hasTag("ford"))
-            return 0;
-
-        // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues))
-            return 0;
-
-        // do not accept railways (sometimes incorrectly mapped!)
-        if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
-            return 0;
-
-        return acceptBit;
-    }
-
-    @Override
-    public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
-    {
-        int code = RelationMapCode.UNCHANGED.getValue();
-        if (relation.hasTag("route", "bicycle"))
-        {
-            Integer val = bikeNetworkToCode.get(relation.getTag("network"));
-            if (val != null)
-                code = val;
-        }
-        int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
-        if (oldCode < code)
-            return relationCodeEncoder.setValue(0, code);
-        return oldRelationFlags;
-    }
-
-    // In case that the way belongs to a relation for which we do have a relation triggered weight change.    
-    // FIXME: Re-write in case that there is a more generic way to influence the weighting (issue #124).
-    // Here we boost or reduce the speed according to the relationWeightCode:
-    int relationWeightCodeToSpeed( int highwaySpeed, int relationCode )
-    {
-        int speed;
-        if (highwaySpeed < 15)
-            // We know that our way belongs to a cycle route, so we are optimistic and assume 15km/h minimum,
-            // irrespective of the tracktype and surface
-            speed = 15;
-        else
-            speed = highwaySpeed;
-        // Add or remove 4km/h per every relation weight boost point
-        return speed + 4 * (relationCode - DEFAULT_REL_CODE);
-    }
-
-    @Override
-    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
-    {
-        if ((allowed & acceptBit) == 0)
-            return 0;
-
-        long encoded;
-        if ((allowed & ferryBit) == 0)
-        {
-            // set speed
-            // FIXME Rewrite necessary after decision #124 for other weighting than speed!
-            // Currently there is only speed, so we increase it.
-            int speed;
-            if (relationFlags == 0)
-            {
-                // In case that the way does not belong to a relation
-                speed = getSpeed(way);
-            } else
-            {
-                speed = relationWeightCodeToSpeed(getSpeed(way), (int) relationCodeEncoder.getValue(relationFlags));
-            }
-
-            // Make sure that we do not exceed the limits:
-            if (speed > speedEncoder.getMaxValue())
-                speed = (int) speedEncoder.getMaxValue();
-            else if (speed < 0)
-                speed = 0;
-            encoded = speedEncoder.setValue(0, speed);
-
-            // handle oneways
-            if ((way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
-                    && !way.hasTag("oneway:bicycle", "no")
-                    && !way.hasTag("cycleway", oppositeLanes))
-            {
-
-                if (way.hasTag("oneway", "-1"))
-                {
-                    encoded |= backwardBit;
-                } else
-                {
-                    encoded |= forwardBit;
-                }
-            } else
-            {
-                encoded |= directionBitMask;
-            }
-
-            String highway = way.getTag("highway");
-
-            /*            
-             // mark safe ways or ways with cycle lanes
-             if (SAFE_HIGHWAY_TAGS.contains(highway) || way.hasTag("cycleway"))
-             {
-             encoded |= safeWayBit;
-             }
-             */
-            // mark unpaved bit
-            String surfaceTag = way.getTag("surface");
-            String trackType = way.getTag("tracktype");
-            if ("track".equals(highway) && trackType == null
-                    || ("track".equals(highway) && !"grade1".equals(trackType))
-                    || (surfaceTag == null && way.hasTag("highway", "path"))
-                    || unpavedSurfaceTags.contains(surfaceTag))
-            {
-                encoded |= unpavedBit;
-            }
-
-            // Populate bits at wayTypeMask with wayType            
-            WayType ourWayType = WayType.OTHER_SMALL_WAY;
-            if (way.hasTag("highway", pushingSections))
-                ourWayType = WayType.PUSHING_SECTION;
-            if ((way.hasTag("bicycle", intended) && way.hasTag("highway", pushingSections))
-                    || ("cycleway".equals(way.getTag("highway"))))
-                ourWayType = WayType.CYCLEWAY;
-            if (way.hasTag("highway", roadValues))
-                ourWayType = WayType.ROAD;
-
-            encoded = wayTypeEncoder.setValue(encoded, ourWayType.getValue());
-
-        } else
-        {
-            encoded = handleFerry(way,
-                    highwaySpeed.get("living_street"),
-                    highwaySpeed.get("track"),
-                    highwaySpeed.get("primary"));
-            encoded |= directionBitMask;
-        }
-        return encoded;
-    }
-
-    @Override
-    public long analyzeNodeTags( OSMNode node )
-    {
-        // absolute barriers always block
-        if (node.hasTag("barrier", absoluteBarriers))
-            return directionBitMask;
-
-        return super.analyzeNodeTags(node);
-    }
-
-    int getSpeed( OSMWay way )
-    {
-        int speed = 0;
-
-        String s = way.getTag("surface");
-        if (!Helper.isEmpty(s))
-        {
-            Integer sInt = surfaceSpeed.get(s);
-            if (sInt != null)
-                speed = sInt;
-        } else
-        {
-            String tt = way.getTag("tracktype");
-            if (!Helper.isEmpty(tt))
-            {
-                Integer tInt = trackTypeSpeed.get(tt);
-                if (tInt != null)
-                    speed = tInt;
-            } else
-            {
-                String highway = way.getTag("highway");
-                if (!Helper.isEmpty(highway))
-                {
-                    Integer hwInt = highwaySpeed.get(highway);
-                    if (hwInt != null)
-                    {
-                        if (way.getTag("service") == null)
-                            speed = hwInt;
-                        else
-                            speed = highwaySpeed.get("living_street");
-                    }
-                }
-            }
-        }
-
-        // Until now we assumed that the way is no pusing section
-        // Now we check, but only in case that our speed is bigger compared to the PUSHING_SECTION_SPEED
-        if ((speed > PUSHING_SECTION_SPEED)
-                && (!way.hasTag("bicycle", intended) && way.hasTag("highway", pushingSections)))
-        {
-            if (way.hasTag("highway", "steps"))
-                speed = PUSHING_SECTION_SPEED / 2;
-            else
-                speed = PUSHING_SECTION_SPEED;
-        }
-
-        return speed;
-    }
-
-    @Override
-    public int getPavementCode( long flags )
-    {
-        if ((flags & unpavedBit) != 0)
-            return 1; // unpaved
-        else
-            return 0; // paved
-    }
-
-    @Override
-    public int getWayTypeCode( long flags )
-    {
-        return (int) wayTypeEncoder.getValue(flags);
-    }
-
-    public enum RelationMapCode
-    {
-        /* Inspired by http://wiki.openstreetmap.org/wiki/Class:bicycle
-         "-3" = Avoid at all cost. 
-         "-2" = Only use to reach your destination, not well suited. 
-         "-1" = Better take another way 
-         "0" = as well as other ways around. 
-         Try to to avoid using 0 but decide on -1 or +1. 
-         class:bicycle shall only be used as an additional key. 
-         "1" = Prefer 
-         "2" = Very Nice way to cycle 
-         "3" = This way is so nice, it pays out to make a detour also if this means taking 
-         many unsuitable ways to get here. Outstanding for its intended usage class.
-         */
-        //We can't store negative numbers into our map, therefore we add 
-        //unspecifiedRelationWeight=4 to the schema from above
-        AVOID_AT_ALL_COSTS(1),
-        REACH_DEST(2),
-        AVOID_IF_POSSIBLE(3),
-        UNCHANGED(DEFAULT_REL_CODE),
-        PREFER(5),
-        VERY_NICE(6),
-        OUTSTANDING_NICE(7);
-
-        private final int value;
-
-        private RelationMapCode( int value )
-        {
-            this.value = value;
-        }
-
-        public int getValue()
-        {
-            return value;
-        }
-    };
-
-    private enum WayType
-    {
-        ROAD(0),
-        PUSHING_SECTION(1),
-        CYCLEWAY(2),
-        OTHER_SMALL_WAY(3);
-
-        private final int value;
-
-        private WayType( int value )
-        {
-            this.value = value;
-        }
-
-        public int getValue()
-        {
-            return value;
-        }
-
-    };
-
-    public void setTrackTypeSpeed( String tracktype, int speed )
-    {
-        trackTypeSpeed.put(tracktype, speed);
-    }
-
-    public void setSurfaceSpeed( String surface, int speed )
-    {
-        surfaceSpeed.put(surface, speed);
-    }
-
-    public void setHighwaySpeed( String highway, int speed )
-    {
-        highwaySpeed.put(highway, speed);
-    }
-
-    public void setCyclingNetworkPreference( String network, int code )
-    {
-        bikeNetworkToCode.put(network, code);
-    }
-
-    public void setPushingSection( String highway )
-    {
-        pushingSections.add(highway);
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index 2d6c3a9015..32dc4a7a49 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -17,65 +17,58 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMWay;
+
 /**
  * Specifies the settings for cycletouring/trekking
  * <p/>
  * @author ratrun
+ * @author Peter Karich
  */
-public class BikeFlagEncoder extends BikeFlagCommonEncoder
+public class BikeFlagEncoder extends BikeCommonFlagEncoder
 {
-    BikeFlagEncoder()
+    public BikeFlagEncoder()
     {
-        setTrackTypeSpeed("grade1", 20); // paved
-        setTrackTypeSpeed("grade2", 12); // now unpaved ...
-        setTrackTypeSpeed("grade3", 12);
-        setTrackTypeSpeed("grade4", 10);
-        setTrackTypeSpeed("grade5", 8); // like sand/grass     
-
-        setSurfaceSpeed("asphalt", 20);
-        setSurfaceSpeed("concrete", 20);
-        setSurfaceSpeed("paved", 20);
-        setSurfaceSpeed("unpaved", 16);
-        setSurfaceSpeed("gravel", 12);
-        setSurfaceSpeed("ground", 12);
-        setSurfaceSpeed("dirt", 10);
-        setSurfaceSpeed("paving_stones", 8);
-        setSurfaceSpeed("grass", 8);
-        setSurfaceSpeed("cobblestone", 6);
+        this(4, 2, 0);
+    }
 
-        setHighwaySpeed("living_street", 15);
-        setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
+    public BikeFlagEncoder( String propertiesStr )
+    {
+        this((int) parseLong(propertiesStr, "speedBits", 4),
+                parseDouble(propertiesStr, "speedFactor", 2),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+    }
 
-        setHighwaySpeed("cycleway", 18);
-        setHighwaySpeed("path", 18);
-        setHighwaySpeed("footway", 18);
-        setHighwaySpeed("pedestrian", 16);
-        setHighwaySpeed("road", 10);
-        setHighwaySpeed("track", 20);
-        setHighwaySpeed("service", 20);
-        setHighwaySpeed("unclassified", 20);
-        setHighwaySpeed("residential", 20);
+    public BikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        addPushingSection("path");
+        addPushingSection("footway");
+        addPushingSection("pedestrian");
+        addPushingSection("steps");
 
-        setHighwaySpeed("trunk", 18);
-        setHighwaySpeed("trunk_link", 18);
-        setHighwaySpeed("primary", 18);
-        setHighwaySpeed("primary_link", 15);
-        setHighwaySpeed("secondary", 16);
-        setHighwaySpeed("secondary_link", 16);
-        setHighwaySpeed("tertiary", 18);
-        setHighwaySpeed("tertiary_link", 18);
+        avoidHighwayTags.add("trunk");
+        avoidHighwayTags.add("trunk_link");
+        avoidHighwayTags.add("primary");
+        avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("secondary");
+        avoidHighwayTags.add("secondary_link");
 
-        setPushingSection("path");
-        setPushingSection("track");
-        setPushingSection("footway");
-        setPushingSection("pedestrian");
-        setPushingSection("steps");
+        // preferHighwayTags.add("road");
+        preferHighwayTags.add("service");
+        preferHighwayTags.add("tertiary");
+        preferHighwayTags.add("tertiary_link");
+        preferHighwayTags.add("residential");
+        preferHighwayTags.add("unclassified");
+    }
 
-        setCyclingNetworkPreference("icn", RelationMapCode.OUTSTANDING_NICE.getValue());
-        setCyclingNetworkPreference("ncn", RelationMapCode.OUTSTANDING_NICE.getValue());
-        setCyclingNetworkPreference("rcn", RelationMapCode.VERY_NICE.getValue());
-        setCyclingNetworkPreference("lcn", RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("mtb", RelationMapCode.UNCHANGED.getValue());
+    @Override
+    boolean isPushingSection( OSMWay way )
+    {
+        String highway = way.getTag("highway");
+        String trackType = way.getTag("tracktype");
+        return way.hasTag("highway", pushingSections)
+                || "track".equals(highway) && trackType != null && !"grade1".equals(trackType);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 3f077217fb..6bf97ce87a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -17,19 +17,15 @@
  */
 package com.graphhopper.routing.util;
 
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
-import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.Helper;
+import java.util.*;
 
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
@@ -39,26 +35,44 @@
  */
 public class CarFlagEncoder extends AbstractFlagEncoder
 {
+    protected final Map<String, Integer> trackTypeSpeedMap = new HashMap<String, Integer>();
+    protected final Set<String> badSurfaceSpeedMap = new HashSet<String>();
+    /**
+     * A map which associates string to speed. Get some impression:
+     * http://www.itoworld.com/map/124#fullscreen
+     * http://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed
+     */
+    protected final Map<String, Integer> defaultSpeedMap = new HashMap<String, Integer>();
+
     /**
      * Should be only instantied via EncodingManager
      */
-    protected CarFlagEncoder()
+    public CarFlagEncoder()
+    {
+        this(5, 5, 0);
+    }
+
+    public CarFlagEncoder( String propertiesStr )
     {
-        this(5, 5);
+        this((int) parseLong(propertiesStr, "speedBits", 5),
+                parseDouble(propertiesStr, "speedFactor", 5),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
     }
 
-    protected CarFlagEncoder( int speedBits, int speedFactor )
+    public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
     {
-        super(speedBits, speedFactor);
-        restrictions = new String[] { "motorcar", "motor_vehicle", "vehicle", "access" };
+        super(speedBits, speedFactor, maxTurnCosts);
+        restrictions.addAll(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
         restrictedValues.add("private");
         restrictedValues.add("agricultural");
         restrictedValues.add("forestry");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("delivery");
+        restrictedValues.add("military");
 
-        intended.add("yes");
-        intended.add("permissive");
+        intendedValues.add("yes");
+        intendedValues.add("permissive");
 
         potentialBarriers.add("gate");
         potentialBarriers.add("lift_gate");
@@ -69,36 +83,76 @@ protected CarFlagEncoder( int speedBits, int speedFactor )
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
         absoluteBarriers.add("cycle_barrier");
+        absoluteBarriers.add("motorcycle_barrier");
         absoluteBarriers.add("block");
+
+        trackTypeSpeedMap.put("grade1", 20); // paved
+        trackTypeSpeedMap.put("grade2", 15); // now unpaved - gravel mixed with ...
+        trackTypeSpeedMap.put("grade3", 10); // ... hard and soft materials
+        trackTypeSpeedMap.put("grade4", 5); // ... some hard or compressed materials
+        trackTypeSpeedMap.put("grade5", 5); // ... no hard materials. soil/sand/grass
+
+        badSurfaceSpeedMap.add("cobblestone");
+        badSurfaceSpeedMap.add("grass_paver");
+        badSurfaceSpeedMap.add("gravel");
+        badSurfaceSpeedMap.add("sand");
+        badSurfaceSpeedMap.add("paving_stones");
+        badSurfaceSpeedMap.add("dirt");
+        badSurfaceSpeedMap.add("ground");
+        badSurfaceSpeedMap.add("grass");
+
+        // autobahn
+        defaultSpeedMap.put("motorway", 100);
+        defaultSpeedMap.put("motorway_link", 70);
+        defaultSpeedMap.put("motorroad", 90);
+        // bundesstraße
+        defaultSpeedMap.put("trunk", 70);
+        defaultSpeedMap.put("trunk_link", 65);
+        // linking bigger town
+        defaultSpeedMap.put("primary", 65);
+        defaultSpeedMap.put("primary_link", 60);
+        // linking towns + villages
+        defaultSpeedMap.put("secondary", 60);
+        defaultSpeedMap.put("secondary_link", 50);
+        // streets without middle line separation
+        defaultSpeedMap.put("tertiary", 50);
+        defaultSpeedMap.put("tertiary_link", 40);
+        defaultSpeedMap.put("unclassified", 30);
+        defaultSpeedMap.put("residential", 30);
+        // spielstraße
+        defaultSpeedMap.put("living_street", 5);
+        defaultSpeedMap.put("service", 20);
+        // unknown road
+        defaultSpeedMap.put("road", 20);
+        // forestry stuff
+        defaultSpeedMap.put("track", 15);
     }
 
     /**
-     * Define the place of speedBits in the flags variable for car.
+     * Define the place of the speedBits in the edge flags for car.
      */
     @Override
     public int defineWayBits( int index, int shift )
     {
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedValue("Speed", shift, speedBits, speedFactor, SPEED.get("secondary"), SPEED.get("motorway"));
-
-        // speed used 5 bits
-        return shift + speedBits;
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), defaultSpeedMap.get("motorway"));
+        return shift + speedEncoder.getBits();
     }
 
-    protected int getSpeed( OSMWay way )
+    protected double getSpeed( OSMWay way )
     {
         String highwayValue = way.getTag("highway");
-        Integer speed = SPEED.get(highwayValue);
+        Integer speed = defaultSpeedMap.get(highwayValue);
         if (speed == null)
-            throw new IllegalStateException("car, no speed found for:" + highwayValue);
+            throw new IllegalStateException(toString() + ", no speed found for: " + highwayValue + ", tags: " + way);
 
         if (highwayValue.equals("track"))
         {
             String tt = way.getTag("tracktype");
             if (!Helper.isEmpty(tt))
             {
-                Integer tInt = TRACKTYPE_SPEED.get(tt);
+                Integer tInt = trackTypeSpeedMap.get(tt);
                 if (tInt != null)
                     speed = tInt;
             }
@@ -125,18 +179,26 @@ public long acceptWay( OSMWay way )
             return 0;
         }
 
-        if (!SPEED.containsKey(highwayValue))
+        if ("track".equals(highwayValue))
+        {
+            String tt = way.getTag("tracktype");
+            if (tt != null && !tt.equals("grade1") && !tt.equals("grade2") && !tt.equals("grade3"))
+                return 0;
+        }
+
+        if (!defaultSpeedMap.containsKey(highwayValue))
             return 0;
 
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
             return 0;
 
         // do not drive street cars into fords
-        if ((way.hasTag("highway", "ford") || way.hasTag("ford")) && !way.hasTag(restrictions, intended))
+        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
             return 0;
 
         // check access restrictions
-        if (way.hasTag(restrictions, restrictedValues))
+        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
             return 0;
 
         // do not drive cars over railways (sometimes incorrectly mapped!)
@@ -153,34 +215,40 @@ public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
     }
 
     @Override
-    public long handleWayTags( OSMWay way, long allowed, long relationCode )
+    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
     {
-        if ((allowed & acceptBit) == 0)
+        if (!isAccept(allowed))
             return 0;
 
         long encoded;
-        if ((allowed & ferryBit) == 0)
+        if (!isFerry(allowed))
         {
             // get assumed speed from highway type
-            Integer speed = getSpeed(way);
-            int maxspeed = parseSpeed(way.getTag("maxspeed"));
-            // apply speed limit no matter of the road type
-            if (maxspeed >= 0)
-                // reduce speed limit to reflect average speed
-                speed = Math.round(maxspeed * 0.9f);
+            double speed = getSpeed(way);
+            speed = applyMaxSpeed(way, speed, true);
 
             // limit speed to max 30 km/h if bad surface
-            if (speed > 30 && way.hasTag("surface", BAD_SURFACE))
+            if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
                 speed = 30;
 
-            if (speed > getMaxSpeed())
-                speed = getMaxSpeed();
+            encoded = setSpeed(0, speed);
 
-            encoded = speedEncoder.setValue(0, speed);
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
 
-            if (way.hasTag("oneway", oneways) || way.hasTag("junction", "roundabout"))
+            boolean isOneway = way.hasTag("oneway", oneways)
+                    || way.hasTag("vehicle:backward")
+                    || way.hasTag("vehicle:forward")
+                    || way.hasTag("motor_vehicle:backward")
+                    || way.hasTag("motor_vehicle:forward");
+
+            if (isOneway || isRoundabout)
             {
-                if (way.hasTag("oneway", "-1"))
+                boolean isBackward = way.hasTag("oneway", "-1")
+                        || way.hasTag("vehicle:forward", "no")
+                        || way.hasTag("motor_vehicle:forward", "no");
+                if (isBackward)
                     encoded |= backwardBit;
                 else
                     encoded |= forwardBit;
@@ -189,24 +257,13 @@ public long handleWayTags( OSMWay way, long allowed, long relationCode )
 
         } else
         {
-            encoded = handleFerry(way, SPEED.get("living_street"), SPEED.get("service"), SPEED.get("residential"));
+            encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
             encoded |= directionBitMask;
         }
 
         return encoded;
     }
 
-    @Override
-    public long analyzeNodeTags( OSMNode node )
-    {
-        // absolute barriers always block
-        if (node.hasTag("barrier", absoluteBarriers))
-            return directionBitMask;
-
-        return super.analyzeNodeTags(node);
-    }
-
-    @Override
     public String getWayInfo( OSMWay way )
     {
         String str = "";
@@ -240,84 +297,9 @@ public String getWayInfo( OSMWay way )
             return "destination: " + str;
     }
 
-    @Override
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-    {
-        if(edgeOutExplorer == null || edgeInExplorer == null) {
-            edgeOutExplorer = osmReader.getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(this, false, true));
-            edgeInExplorer = osmReader.getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(this, true, false));
-        }
-        return turnRelation.getRestrictionAsEntries(this, edgeOutExplorer, edgeInExplorer, osmReader);
-    }
-
-    @Override
-    public int getPavementCode( long flags )
-    {
-        return 0;
-    }
-
-    @Override
-    public int getWayTypeCode( long flags )
-    {
-        return 0;
-    }
-
     @Override
     public String toString()
     {
         return "car";
     }
-
-    private static final Map<String, Integer> TRACKTYPE_SPEED = new HashMap<String, Integer>();
-    private static final Set<String> BAD_SURFACE = new HashSet<String>();
-    /**
-     * A map which associates string to speed. Get some impression:
-     * http://www.itoworld.com/map/124#fullscreen
-     * http://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed
-     */
-    private static final Map<String, Integer> SPEED = new HashMap<String, Integer>();
-
-    static
-    {
-
-        TRACKTYPE_SPEED.put("grade1", 20); // paved
-        TRACKTYPE_SPEED.put("grade2", 15); // now unpaved - gravel mixed with ...
-        TRACKTYPE_SPEED.put("grade3", 10); // ... hard and soft materials
-        TRACKTYPE_SPEED.put("grade4", 5); // ... some hard or compressed materials
-        TRACKTYPE_SPEED.put("grade5", 5); // ... no hard materials. soil/sand/grass
-
-        BAD_SURFACE.add("cobblestone");
-        BAD_SURFACE.add("grass_paver");
-        BAD_SURFACE.add("gravel");
-        BAD_SURFACE.add("sand");
-        BAD_SURFACE.add("paving_stones");
-        BAD_SURFACE.add("dirt");
-        BAD_SURFACE.add("ground");
-        BAD_SURFACE.add("grass");
-
-        // autobahn
-        SPEED.put("motorway", 100);
-        SPEED.put("motorway_link", 70);
-        // bundesstraße
-        SPEED.put("trunk", 70);
-        SPEED.put("trunk_link", 65);
-        // linking bigger town
-        SPEED.put("primary", 65);
-        SPEED.put("primary_link", 60);
-        // linking towns + villages
-        SPEED.put("secondary", 60);
-        SPEED.put("secondary_link", 50);
-        // streets without middle line separation
-        SPEED.put("tertiary", 50);
-        SPEED.put("tertiary_link", 40);
-        SPEED.put("unclassified", 30);
-        SPEED.put("residential", 30);
-        // spielstraße
-        SPEED.put("living_street", 5);
-        SPEED.put("service", 20);
-        // unknown road
-        SPEED.put("road", 20);
-        // forestry stuff
-        SPEED.put("track", 15);
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
new file mode 100644
index 0000000000..c7b67e7c68
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
@@ -0,0 +1,43 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.NodeAccess;
+
+/**
+ * Turns an unidirectional weight Approximation into a bidirectional consistent one.
+ * <p/>
+ * Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
+ * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
+ * pages 291–296.
+ * <p/>
+ *
+ * @author jansoe
+ */
+public class ConsistentWeightApproximator {
+
+    private NodeAccess nodeAccess;
+    private Weighting weighting;
+    private WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
+
+    public ConsistentWeightApproximator(WeightApproximator weightApprox){
+        uniDirApproximatorForward = weightApprox;
+        uniDirApproximatorReverse = weightApprox.duplicate();
+    }
+
+    public void setSourceNode(int sourceNode){
+        uniDirApproximatorReverse.setGoalNode(sourceNode);
+    }
+
+    public void setGoalNode(int goalNode){
+        uniDirApproximatorForward.setGoalNode(goalNode);
+    }
+
+    public double approximate(int fromNode, boolean reverse)    {
+        double weightApproximation = 0.5*(uniDirApproximatorForward.approximate(fromNode)
+                                          - uniDirApproximatorReverse.approximate(fromNode));
+        if (reverse) {
+            weightApproximation *= -1;
+        }
+
+        return weightApproximation;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index f03e602c6c..e86ca2c43d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
 /**
@@ -45,7 +44,7 @@ public DefaultEdgeFilter( FlagEncoder encoder, boolean in, boolean out )
     }
 
     @Override
-    public boolean accept( EdgeIteratorState iter )
+    public final boolean accept( EdgeIteratorState iter )
     {
         long flags = iter.getFlags();
         return out && encoder.isForward(flags) || in && encoder.isBackward(flags);
diff --git a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
index 4911250276..a108e4826c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
 /**
@@ -30,12 +29,12 @@
     /**
      * @return true if the current edge should be processed and false otherwise.
      */
-    boolean accept( EdgeIteratorState edgeIterState );
-    
+    boolean accept( EdgeIteratorState edgeState );
+
     static final EdgeFilter ALL_EDGES = new EdgeFilter()
     {
         @Override
-        public final boolean accept( EdgeIteratorState edgeIterState )
+        public final boolean accept( EdgeIteratorState edgeState )
         {
             return true;
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
new file mode 100644
index 0000000000..f00dc17928
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
@@ -0,0 +1,89 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+/**
+ * Encapsulates a bit-encoded value.
+ * <p/>
+ * @author Nop
+ */
+public class EncodedDoubleValue extends EncodedValue
+{
+
+    public EncodedDoubleValue( String name, int shift, int bits, double factor, long defaultValue, int maxValue )
+    {
+        this(name, shift, bits, factor, defaultValue, maxValue, true);
+    }
+
+    public EncodedDoubleValue( String name, int shift, int bits, double factor, long defaultValue, int maxValue, boolean allowZero )
+    {
+        super(name, shift, bits, factor, defaultValue, maxValue, allowZero);
+    }
+
+    @Override
+    public long setValue( long flags, long value )
+    {
+        throw new IllegalStateException("Use setDoubleValue instead");
+    }
+
+    @Override
+    public long getValue( long flags )
+    {
+        throw new IllegalStateException("Use setDoubleValue instead");
+    }
+
+    @Override
+    public long setDefaultValue( long flags )
+    {
+        return setDoubleValue(flags, defaultValue);
+    }
+
+    public long setDoubleValue( long flags, double value )
+    {
+        // scale value        
+        long tmpValue = Math.round(value / factor);
+        checkValue(Math.round(tmpValue * factor));
+        tmpValue <<= shift;
+
+        // clear value bits
+        flags &= ~mask;
+
+        // set value
+        return flags | tmpValue;
+    }
+
+    public double getDoubleValue( long flags )
+    {
+        // find value
+        flags &= mask;
+        flags >>= shift;
+        return flags * factor;
+    }
+
+    /**
+     * Swap the contents controlled by this value encoder with the given value.
+     * <p>
+     * @return the new flags
+     */
+    public long swap( long flags, EncodedDoubleValue otherEncoder )
+    {
+        double otherValue = otherEncoder.getDoubleValue(flags);
+        flags = otherEncoder.setDoubleValue(flags, getDoubleValue(flags));
+        return setDoubleValue(flags, otherValue);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
index 05498aa55f..d2c961bf15 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
@@ -25,12 +25,11 @@
 public class EncodedValue
 {
     private final String name;
-    private final long shift;
-    private final long mask;
-    private final long factor;
+    protected final long shift;
+    protected final long mask;
+    protected final double factor;
+    protected final long defaultValue;
     private final long maxValue;
-    private final long defaultValue;
-    private final boolean allowNegative;
     private final boolean allowZero;
     private final int bits;
 
@@ -44,13 +43,12 @@
      * @param defaultValue default value
      * @param maxValue default maximum value
      */
-    public EncodedValue( String name, int shift, int bits, int factor, int defaultValue, int maxValue )
+    public EncodedValue( String name, int shift, int bits, double factor, long defaultValue, int maxValue )
     {
-        this(name, shift, bits, factor, defaultValue, maxValue, false, true);
+        this(name, shift, bits, factor, defaultValue, maxValue, true);
     }
 
-    public EncodedValue( String name, int shift, int bits, int factor, int defaultValue, int maxValue,
-            boolean allowNegative, boolean allowZero )
+    public EncodedValue( String name, int shift, int bits, double factor, long defaultValue, int maxValue, boolean allowZero )
     {
         this.name = name;
         this.shift = shift;
@@ -58,27 +56,28 @@ public EncodedValue( String name, int shift, int bits, int factor, int defaultVa
         this.defaultValue = defaultValue;
         this.bits = bits;
         long tmpMask = (1L << bits) - 1;
-        long tmpMaxValue = tmpMask * factor;
-        if (maxValue > tmpMaxValue)
+        this.maxValue = Math.min(maxValue, Math.round(tmpMask * factor));
+        if (maxValue > this.maxValue)
             throw new IllegalStateException(name + " -> maxValue " + maxValue + " is too large for " + bits + " bits");
 
-        this.maxValue = maxValue;
         mask = tmpMask << shift;
-
-        this.allowNegative = allowNegative;
         this.allowZero = allowZero;
     }
 
-    public long setValue( long flags, long value )
+    protected void checkValue( long value )
     {
         if (value > maxValue)
             throw new IllegalArgumentException(name + " value too large for encoding: " + value + ", maxValue:" + maxValue);
-        if (!allowNegative && value < 0)
+        if (value < 0)
             throw new IllegalArgumentException("negative " + name + " value not allowed! " + value);
         if (!allowZero && value == 0)
             throw new IllegalArgumentException("zero " + name + " value not allowed! " + value);
+    }
 
-        // scale down value
+    public long setValue( long flags, long value )
+    {
+        checkValue(value);
+        // scale value
         value /= factor;
         value <<= shift;
 
@@ -94,7 +93,7 @@ public long getValue( long flags )
         // find value
         flags &= mask;
         flags >>= shift;
-        return flags * factor;
+        return Math.round(flags * factor);
     }
 
     public int getBits()
@@ -111,4 +110,16 @@ public long getMaxValue()
     {
         return maxValue;
     }
+
+    /**
+     * Swap the contents controlled by this value encoder with the given value.
+     * <p>
+     * @return the new flags
+     */
+    public long swap( long flags, EncodedValue otherEncoder )
+    {
+        long otherValue = otherEncoder.getValue(flags);
+        flags = otherEncoder.setValue(flags, getValue(flags));
+        return setValue(flags, otherValue);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 7b66b8f6f6..4b2aa8a183 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -17,22 +17,19 @@
  */
 package com.graphhopper.routing.util;
 
-import gnu.trove.map.TLongObjectMap;
-import gnu.trove.map.hash.TLongObjectHashMap;
-
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 
 import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.StorableProperties;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+import java.util.*;
 
 /**
  * Manager class to register encoder, assign their flag values and check objects with all encoders
@@ -45,124 +42,160 @@
 {
     public static final String CAR = "car";
     public static final String BIKE = "bike";
+    public static final String BIKE2 = "bike2";
     public static final String RACINGBIKE = "racingbike";
     public static final String MOUNTAINBIKE = "mtb";
     public static final String FOOT = "foot";
-    private static final Map<String, String> defaultEdgeFlagEncoders = new HashMap<String, String>();
-    private static final Map<String, String> defaultTurnFlagEncoders = new HashMap<String, String>();
-
-    static
-    {
-        defaultEdgeFlagEncoders.put(CAR, CarFlagEncoder.class.getName());
-        defaultEdgeFlagEncoders.put(BIKE, BikeFlagEncoder.class.getName());
-        defaultEdgeFlagEncoders.put(RACINGBIKE, RacingBikeFlagEncoder.class.getName());
-        defaultEdgeFlagEncoders.put(MOUNTAINBIKE, MountainBikeFlagEncoder.class.getName());
-        defaultEdgeFlagEncoders.put(FOOT, FootFlagEncoder.class.getName());        
-    }
-
-    public static final int MAX_BITS = 32;
-    public static final int MAX_BITS_TURN_FLAGS = 32;
+    public static final String MOTORCYCLE = "motorcycle";
 
     private final List<AbstractFlagEncoder> edgeEncoders = new ArrayList<AbstractFlagEncoder>();
-    private int edgeEncoderNextBit = 0;
 
     private int nextWayBit = 0;
     private int nextNodeBit = 0;
     private int nextRelBit = 0;
     private int nextTurnBit = 0;
-    protected int maxTurnCost;
-
-    public EncodingManager()
-    {
-        maxTurnCost = 0; //we don't need turn costs yet, but only restrictions
-    }
+    private final int bitsForEdgeFlags;
+    private final int bitsForTurnFlags = 8 * 4;
+    private boolean enableInstructions = true;
 
     /**
      * Instantiate manager with the given list of encoders. The manager knows the default encoders:
      * CAR, FOOT and BIKE (ignoring the case). Custom encoders can be specified by giving a full
      * class name e.g. "car:com.graphhopper.myproject.MyCarEncoder"
      * <p/>
-     * @param encoderList comma delimited list of encoders. The order does not matter.
+     * @param flagEncodersStr comma delimited list of encoders. The order does not matter.
      */
-    public EncodingManager( String encoderList )
+    public EncodingManager( String flagEncodersStr )
+    {
+        this(flagEncodersStr, 4);
+    }
+
+    public EncodingManager( String flagEncodersStr, int bytesForFlags )
+    {
+        this(parseEncoderString(flagEncodersStr), bytesForFlags);
+    }
+
+    /**
+     * Instantiate manager with the given list of encoders.
+     * <p/>
+     * @param flagEncoders comma delimited list of encoders. The order does not matter.
+     */
+    public EncodingManager( FlagEncoder... flagEncoders )
+    {
+        this(Arrays.asList(flagEncoders));
+    }
+
+    /**
+     * Instantiate manager with the given list of encoders.
+     * <p/>
+     * @param flagEncoders comma delimited list of encoders. The order does not matter.
+     */
+    public EncodingManager( List<? extends FlagEncoder> flagEncoders )
+    {
+        this(flagEncoders, 4);
+    }
+
+    public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags )
     {
-        this();
+        if (bytesForEdgeFlags != 4 && bytesForEdgeFlags != 8)
+            throw new IllegalStateException("For 'edge flags' currently only 4 or 8 bytes supported");
 
-        for (AbstractFlagEncoder flagEncoder : readFromEncoderString(defaultEdgeFlagEncoders, encoderList, AbstractFlagEncoder.class))
+        this.bitsForEdgeFlags = bytesForEdgeFlags * 8;
+        for (FlagEncoder flagEncoder : flagEncoders)
         {
-            registerEncoder(flagEncoder);
+            registerEncoder((AbstractFlagEncoder) flagEncoder);
         }
+
+        if (edgeEncoders.isEmpty())
+            throw new IllegalStateException("No vehicles found");
     }
 
-    private <T> List<T> readFromEncoderString( Map<String, String> defaultEncoders, String encoderList, Class<T> encoderClass )
+    public int getBytesForFlags()
     {
-        String[] entries = encoderList.split(",");
-        Arrays.sort(entries);
+        return bitsForEdgeFlags / 8;
+    }
 
-        List<T> resultEncoders = new ArrayList<T>();
+    static List<FlagEncoder> parseEncoderString( String encoderList )
+    {
+        if (encoderList.contains(":"))
+            throw new IllegalArgumentException("EncodingManager does no longer use reflection instantiate encoders directly.");
+
+        String[] entries = encoderList.split(",");
+        List<FlagEncoder> resultEncoders = new ArrayList<FlagEncoder>();
 
         for (String entry : entries)
         {
-            entry = entry.trim();
+            entry = entry.trim().toLowerCase();
             if (entry.isEmpty())
                 continue;
 
-            String className = null;
-            int pos = entry.indexOf(":");
-            if (pos > 0)
+            String entryVal = "";
+            if (entry.contains("|"))
             {
-                className = entry.substring(pos + 1);
-            } else
-            {
-                className = defaultEncoders.get(entry.toLowerCase());
-                if (className == null)
-                    throw new IllegalArgumentException("Unknown encoder name " + entry);
+                entryVal = entry;
+                entry = entry.split("\\|")[0];
             }
 
-            try
-            {
-                @SuppressWarnings("unchecked")
-                Class<T> cls = (Class<T>) Class.forName(className);
-                resultEncoders.add((T) cls.getDeclaredConstructor().newInstance());
-            } catch (Exception e)
-            {
-                throw new IllegalArgumentException("Cannot instantiate class " + className, e);
-            }
+            AbstractFlagEncoder fe;
+            if (entry.equals(CAR))
+                fe = new CarFlagEncoder(entryVal);
+
+            else if (entry.equals(BIKE))
+                fe = new BikeFlagEncoder(entryVal);
+
+            else if (entry.equals(BIKE2))
+                fe = new Bike2WeightFlagEncoder(entryVal);
+
+            else if (entry.equals(RACINGBIKE))
+                fe = new RacingBikeFlagEncoder(entryVal);
+
+            else if (entry.equals(MOUNTAINBIKE))
+                fe = new MountainBikeFlagEncoder(entryVal);
+
+            else if (entry.equals(FOOT))
+                fe = new FootFlagEncoder(entryVal);
+
+            else if (entry.equals(MOTORCYCLE))
+                fe = new MotorcycleFlagEncoder(entryVal);
+
+            else
+                throw new IllegalArgumentException("entry in encoder list not supported " + entry);
+
+            resultEncoders.add(fe);
         }
         return resultEncoders;
     }
 
-    public void registerEncoder( AbstractFlagEncoder encoder )
+    private static final String ERR = "Encoders are requesting more than %s bits of %s flags. ";
+    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long.";
+
+    private void registerEncoder( AbstractFlagEncoder encoder )
     {
         int encoderCount = edgeEncoders.size();
-
-        int usedBits = encoder.defineNodeBits(encoderCount, edgeEncoderNextBit);
-        if (usedBits >= MAX_BITS)
-            throw new IllegalArgumentException("Encoders are requesting more than " + MAX_BITS + " bits of node flags");
+        int usedBits = encoder.defineNodeBits(encoderCount, nextNodeBit);
+        if (usedBits > bitsForEdgeFlags)
+            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "node"));
         encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
         nextNodeBit = usedBits;
 
         usedBits = encoder.defineWayBits(encoderCount, nextWayBit);
-        if (usedBits >= MAX_BITS)
-            throw new IllegalArgumentException("Encoders are requesting more than " + MAX_BITS + " bits of way flags");
+        if (usedBits > bitsForEdgeFlags)
+            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "way") + WAY_ERR);
         encoder.setWayBitMask(usedBits - nextWayBit, nextWayBit);
         nextWayBit = usedBits;
 
         usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
-        if (usedBits >= MAX_BITS)
-            throw new IllegalArgumentException("Encoders are requesting more than " + MAX_BITS + " bits of relation flags");
+        if (usedBits > bitsForEdgeFlags)
+            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "relation"));
         encoder.setRelBitMask(usedBits - nextRelBit, nextRelBit);
         nextRelBit = usedBits;
 
-        edgeEncoderNextBit = usedBits;
-
-        //turn flag bits are independent from edge encoder bits
-        usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit, determineRequiredBits(maxTurnCost));
-        if (usedBits >= MAX_BITS_TURN_FLAGS)
-            throw new IllegalArgumentException("Encoders are requesting more than " + MAX_BITS + " bits of turn flags");
+        // turn flag bits are independent from edge encoder bits
+        usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit);
+        if (usedBits > bitsForTurnFlags)
+            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "turn"));
         nextTurnBit = usedBits;
 
-        //everything okay, add encoder
         edgeEncoders.add(encoder);
     }
 
@@ -181,14 +214,13 @@ public FlagEncoder getEncoder( String name )
 
     private FlagEncoder getEncoder( String name, boolean throwExc )
     {
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            if (name.equalsIgnoreCase(edgeEncoders.get(i).toString()))
-                return edgeEncoders.get(i);
+            if (name.equalsIgnoreCase(encoder.toString()))
+                return encoder;
         }
         if (throwExc)
-            throw new IllegalArgumentException("Encoder for " + name + " not found.");
+            throw new IllegalArgumentException("Encoder for " + name + " not found. Existing: " + toDetailsString());
         return null;
     }
 
@@ -198,10 +230,9 @@ private FlagEncoder getEncoder( String name, boolean throwExc )
     public long acceptWay( OSMWay way )
     {
         long includeWay = 0;
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            includeWay |= edgeEncoders.get(i).acceptWay(way);
+            includeWay |= encoder.acceptWay(way);
         }
 
         return includeWay;
@@ -210,10 +241,9 @@ public long acceptWay( OSMWay way )
     public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
     {
         long flags = 0;
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            flags |= edgeEncoders.get(i).handleRelationTags(relation, oldRelationFlags);
+            flags |= encoder.handleRelationTags(relation, oldRelationFlags);
         }
 
         return flags;
@@ -229,90 +259,65 @@ public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
     public long handleWayTags( OSMWay way, long includeWay, long relationFlags )
     {
         long flags = 0;
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            AbstractFlagEncoder encoder = edgeEncoders.get(i);
             flags |= encoder.handleWayTags(way, includeWay, relationFlags & encoder.getRelBitMask());
         }
 
         return flags;
     }
 
-    public int getVehicleCount()
-    {
-        return edgeEncoders.size();
-    }
-
     @Override
     public String toString()
     {
         StringBuilder str = new StringBuilder();
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        for (AbstractFlagEncoder encoder : edgeEncoders)
         {
             if (str.length() > 0)
                 str.append(",");
 
-            str.append(edgeEncoders.get(i).toString());
+            str.append(encoder.toString());
         }
 
         return str.toString();
     }
 
-    public String getEncoderList()
+    public String toDetailsString()
     {
         StringBuilder str = new StringBuilder();
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        for (AbstractFlagEncoder encoder : edgeEncoders)
         {
             if (str.length() > 0)
                 str.append(",");
 
-            str.append(edgeEncoders.get(i).toString());
-            str.append(":");
-            str.append(edgeEncoders.get(i).getClass().getName());
+            str.append(encoder.toString());
+            str.append("|");
+            str.append(encoder.getPropertiesString());
         }
 
         return str.toString();
     }
 
-    public FlagEncoder getSingle()
-    {
-        if (getVehicleCount() > 1)
-            throw new IllegalStateException("multiple encoders are active. cannot return one:" + toString());
-
-        return getFirst();
-    }
-
-    private FlagEncoder getFirst()
-    {
-        if (getVehicleCount() == 0)
-            throw new IllegalStateException("no encoder is active!");
-
-        return edgeEncoders.get(0);
-    }
-
     public long flagsDefault( boolean forward, boolean backward )
     {
         long flags = 0;
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            flags |= edgeEncoders.get(i).flagsDefault(forward, backward);
+            flags |= encoder.flagsDefault(forward, backward);
         }
         return flags;
     }
 
     /**
-     * Swap direction for all encoders
+     * Reverse flags, to do so all encoders are called.
      */
-    public long swapDirection( long flags )
+    public long reverseFlags( long flags )
     {
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        // performance critical
+        int len = edgeEncoders.size();
+        for (int i = 0; i < len; i++)
         {
-            flags = edgeEncoders.get(i).swapDirection(flags);
+            flags = edgeEncoders.get(i).reverseFlags(flags);
         }
         return flags;
     }
@@ -329,13 +334,11 @@ public int hashCode()
     public boolean equals( Object obj )
     {
         if (obj == null)
-        {
             return false;
-        }
+
         if (getClass() != obj.getClass())
-        {
             return false;
-        }
+
         final EncodingManager other = (EncodingManager) obj;
         if (this.edgeEncoders != other.edgeEncoders && (this.edgeEncoders == null || !this.edgeEncoders.equals(other.edgeEncoders)))
         {
@@ -347,83 +350,100 @@ public boolean equals( Object obj )
     /**
      * Analyze tags on osm node. Store node tags (barriers etc) for later usage while parsing way.
      */
-    public long analyzeNodeTags( OSMNode node )
+    public long handleNodeTags( OSMNode node )
     {
         long flags = 0;
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            flags |= edgeEncoders.get(i).analyzeNodeTags(node);
+            flags |= encoder.handleNodeTags(node);
         }
 
         return flags;
     }
 
-    public String getWayInfo( OSMWay way )
+    public EncodingManager setEnableInstructions( boolean enableInstructions )
     {
-        String str = "";
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
-        {
-            String tmpWayInfo = edgeEncoders.get(i).getWayInfo(way);
-            if (tmpWayInfo.isEmpty())
-                continue;
-            if (!str.isEmpty())
-                str += ", ";
-            str += tmpWayInfo;
-        }
-        return str;
+        this.enableInstructions = enableInstructions;
+        return this;
     }
 
-    /**
-     * When parsing the ways we have the node flags as long variable encoded in analyzeNode.
-     */
-    public long applyNodeFlags( long wayFlags, long nodeFlags )
+    public void applyWayTags( OSMWay way, EdgeIteratorState edge )
     {
-        long flags = 0;
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+        // storing the road name does not yet depend on the flagEncoder so manage it directly
+        if (enableInstructions)
         {
-            AbstractFlagEncoder encoder = edgeEncoders.get(i);
-            flags |= encoder.applyNodeFlags(wayFlags & encoder.getWayBitMask(), nodeFlags);
+            // String wayInfo = carFlagEncoder.getWayInfo(way);
+            // http://wiki.openstreetmap.org/wiki/Key:name
+            String name = fixWayName(way.getTag("name"));
+            // http://wiki.openstreetmap.org/wiki/Key:ref
+            String refName = fixWayName(way.getTag("ref"));
+            if (!Helper.isEmpty(refName))
+            {
+                if (Helper.isEmpty(name))
+                    name = refName;
+                else
+                    name += ", " + refName;
+            }
+
+            edge.setName(name);
         }
 
-        return flags;
+        for (AbstractFlagEncoder encoder : edgeEncoders)
+        {
+            encoder.applyWayTags(way, edge);
+        }
     }
 
-    private static int determineRequiredBits( int value )
+    /**
+     * The returned list is never empty.
+     */
+    public List<FlagEncoder> fetchEdgeEncoders()
     {
-        int numberOfBits = 0;
-        while (value > 0)
-        {
-            value = value >> 1;
-            numberOfBits++;
-        }
-        return numberOfBits;
+        List<FlagEncoder> list = new ArrayList<FlagEncoder>();
+        list.addAll(edgeEncoders);
+        return list;
     }
 
-    public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
+    static String fixWayName( String str )
     {
-        TLongObjectMap<TurnCostTableEntry> entries = new TLongObjectHashMap<OSMTurnRelation.TurnCostTableEntry>();
+        if (str == null)
+            return "";
+        return str.replaceAll(";[ ]*", ", ");
+    }
 
-        int encoderCount = edgeEncoders.size();
-        for (int i = 0; i < encoderCount; i++)
+    public boolean needsTurnCostsSupport()
+    {
+        for (FlagEncoder encoder : edgeEncoders)
         {
-            AbstractFlagEncoder encoder = edgeEncoders.get(i);
-            for (TurnCostTableEntry entry : encoder.analyzeTurnRelation(turnRelation, osmReader))
-            {
-                TurnCostTableEntry oldEntry = entries.get(entry.getItemId());
-                if (oldEntry != null)
-                {
-                    // merging different encoders
-                    oldEntry.flags |= entry.flags;
-                } else
-                {
-                    entries.put(entry.getItemId(), entry);
-                }
-            }
+            if (encoder.supports(TurnWeighting.class))
+                return true;
         }
+        return false;
+    }
 
-        return entries.valueCollection();
+    /**
+     * Create the EncodingManager from the provided GraphHopper location. Throws an
+     * IllegalStateException if it fails.
+     */
+    public static EncodingManager create( String ghLoc )
+    {
+        Directory dir = new RAMDirectory(ghLoc, true);
+        StorableProperties properties = new StorableProperties(dir);
+        if (!properties.loadExisting())
+            throw new IllegalStateException("Cannot load properties to fetch EncodingManager configuration at: "
+                    + dir.getLocation());
+
+        // check encoding for compatiblity
+        properties.checkVersions(false);
+        String acceptStr = properties.get("graph.flagEncoders");
+
+        if (acceptStr.isEmpty())
+            throw new IllegalStateException("EncodingManager was not configured. And no one was found in the graph: "
+                    + dir.getLocation());
+
+        int bytesForFlags = 4;
+        if ("8".equals(properties.get("graph.bytesForFlags")))
+            bytesForFlags = 8;
+        return new EncodingManager(acceptStr, bytesForFlags);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index 3b54ed2de7..3a5a7f1632 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -20,19 +20,25 @@
 import com.graphhopper.util.EdgeIteratorState;
 
 /**
- * Calculates the fastest route with the specified vehicle (VehicleEncoder).
+ * Calculates the fastest route with the specified vehicle (VehicleEncoder). Calculates the weight
+ * in seconds.
  * <p/>
  * @author Peter Karich
  */
 public class FastestWeighting implements Weighting
 {
-    private final FlagEncoder encoder;
+    /**
+     * Converting to seconds is not necessary but makes adding other penalities easier (e.g. turn
+     * costs or traffic light costs etc)
+     */
+    protected final static double SPEED_CONV = 3.6;
+    protected final FlagEncoder encoder;
     private final double maxSpeed;
 
     public FastestWeighting( FlagEncoder encoder )
     {
         this.encoder = encoder;
-        maxSpeed = encoder.getMaxSpeed();
+        maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
 
     @Override
@@ -42,15 +48,12 @@ public double getMinWeight( double distance )
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edge )
-    {
-        return edge.getDistance() / encoder.getSpeed(edge.getFlags());
-    }
-
-    @Override
-    public double revertWeight( EdgeIteratorState edge, double weight )
-    {
-        return weight * encoder.getSpeed(edge.getFlags());
+    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
+    {        
+        double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
+        if (speed == 0)
+            return Double.POSITIVE_INFINITY;
+        return edge.getDistance() / speed * SPEED_CONV;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 2a9711807b..96b6a599d3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -17,25 +17,43 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.util.InstructionAnnotation;
+import com.graphhopper.util.Translation;
+
 /**
  * This class provides methods to define how a value (like speed or direction) converts to a flag
  * (currently an integer value), which is stored in an edge .
  * <p/>
  * @author Peter Karich
  */
-public interface FlagEncoder
+public interface FlagEncoder extends TurnCostEncoder
 {
     /**
-     * @return the speed in km/h
+     * @return the maximum speed in km/h
+     */
+    double getMaxSpeed();
+
+    /**
+     * @return the speed in km/h for this direction, for backward direction use getReverseSpeed
      */
-    int getSpeed( long flags );
+    double getSpeed( long flags );
 
     /**
      * Sets the speed in km/h.
      * <p>
      * @return modified setProperties
      */
-    long setSpeed( long flags, int speed );
+    long setSpeed( long flags, double speed );
+
+    /**
+     * @return the speed of the reverse direction in km/h
+     */
+    double getReverseSpeed( long flags );
+
+    /**
+     * Sets the reverse speed in the flags.
+     */
+    long setReverseSpeed( long flags, double speed );
 
     /**
      * Sets the access of the edge.
@@ -49,29 +67,58 @@
      * <p>
      * @return created flags
      */
-    long setProperties( int speed, boolean forward, boolean backward );
+    long setProperties( double speed, boolean forward, boolean backward );
 
+    /**
+     * Reports wether the edge is available in forward direction for a certain vehicle
+     */
     boolean isForward( long flags );
 
+    /**
+     * Reports wether the edge is available in backward direction for a certain vehicle
+     */
     boolean isBackward( long flags );
 
+    /*
+     * Simple rules for every subclass which introduces a new key. It has to use the prefix K_ and
+     * uses a minimum value which is two magnitudes higher than in the super class. 
+     * Currently this means starting from 100, and subclasses of this class start from 10000 and so on.
+     */
     /**
-     * @return the maximum speed in km/h
+     * Reports wether this edge is part of a roundabout.
+     */
+    static final int K_ROUNDABOUT = 2;
+
+    /**
+     * Returns arbitrary boolean value identified by the specified key.
      */
-    int getMaxSpeed();
+    boolean isBool( long flags, int key );
+
+    long setBool( long flags, int key, boolean value );
 
     /**
-     * Returns true if flags1 can be overwritten by flags2 without restricting or changing the
-     * directions of flags1.
+     * Returns arbitrary long value identified by the specified key. E.g. can be used to return the
+     * way or surface type of an edge
      */
-    //        \  flags2:
-    // flags1  \ -> | <- | <->
-    // ->         t | f  | t
-    // <-         f | t  | t
-    // <->        f | f  | t
-    boolean canBeOverwritten( long flags1, long flags2 );
+    long getLong( long flags, int key );
 
-    int getPavementCode( long flags );
+    long setLong( long flags, int key, long value );
 
-    int getWayTypeCode( long flags );
+    /**
+     * Returns arbitrary long value identified by the specified key. E.g. can be used to return the
+     * maximum width or height allowed for an edge.
+     */
+    double getDouble( long flags, int key );
+
+    long setDouble( long flags, int key, double value );
+
+    /**
+     * Returns true if the feature class is supported like TurnWeighting or PriorityWeighting.
+     */
+    public boolean supports( Class<?> feature );
+
+    /**
+     * @return additional cost or warning information for an instruction like ferry or road charges.
+     */
+    InstructionAnnotation getAnnotation( long flags, Translation tr );
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index a3f791034e..b11e3182a6 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -22,6 +22,8 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import java.util.*;
 
 /**
  * Defines bit layout for pedestrians (speed, access, surface, ...).
@@ -32,41 +34,53 @@
  */
 public class FootFlagEncoder extends AbstractFlagEncoder
 {
-    static final int SLOW = 2;
-    static final int MEAN = 5;
-    static final int FERRY = 10;
-    private int safeWayBit = 0;
+    static final int SLOW_SPEED = 2;
+    static final int MEAN_SPEED = 5;
+    static final int FERRY_SPEED = 10;
+    private EncodedValue preferWayEncoder;
+    private EncodedValue relationCodeEncoder;
     protected HashSet<String> sidewalks = new HashSet<String>();
     private final Set<String> safeHighwayTags = new HashSet<String>();
     private final Set<String> allowedHighwayTags = new HashSet<String>();
+    private final Set<String> avoidHighwayTags = new HashSet<String>();
+    // convert network tag of hiking routes into a way route code
+    private final Map<String, Integer> hikingNetworkToCode = new HashMap<String, Integer>();
 
     /**
-     * Should be only instantied via EncodingManager
+     * Should be only instantiated via EncodingManager
      */
-    protected FootFlagEncoder()
+    public FootFlagEncoder()
     {
-        super(4, 1);
-        restrictions = new String[]
-        {
-            "foot", "access"
-        };
+        this(4, 1);
+    }
+
+    public FootFlagEncoder( String propertiesStr )
+    {
+        this((int) parseLong(propertiesStr, "speedBits", 4),
+                parseDouble(propertiesStr, "speedFactor", 1));
+    }
+
+    public FootFlagEncoder( int speedBits, double speedFactor )
+    {
+        super(speedBits, speedFactor, 0);
+        restrictions.addAll(Arrays.asList("foot", "access"));
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("military");
 
-        intended.add("yes");
-        intended.add("designated");
-        intended.add("official");
-        intended.add("permissive");
+        intendedValues.add("yes");
+        intendedValues.add("designated");
+        intendedValues.add("official");
+        intendedValues.add("permissive");
 
         sidewalks.add("yes");
         sidewalks.add("both");
         sidewalks.add("left");
         sidewalks.add("right");
 
+        setBlockByDefault(false);
         potentialBarriers.add("gate");
-        //potentialBarriers.add( "lift_gate" );   you can always pass them on foot
-        potentialBarriers.add("swing_gate");
 
         acceptedRailways.add("station");
         acceptedRailways.add("platform");
@@ -80,19 +94,29 @@ protected FootFlagEncoder()
         safeHighwayTags.add("residential");
         safeHighwayTags.add("service");
 
+        avoidHighwayTags.add("trunk");
+        avoidHighwayTags.add("trunk_link");
+        avoidHighwayTags.add("primary");
+        avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("tertiary");
+        avoidHighwayTags.add("tertiary_link");
+        // for now no explicit avoiding #257
+        //avoidHighwayTags.add("cycleway"); 
+
         allowedHighwayTags.addAll(safeHighwayTags);
-        allowedHighwayTags.add("trunk");
-        allowedHighwayTags.add("trunk_link");
-        allowedHighwayTags.add("primary");
-        allowedHighwayTags.add("primary_link");
+        allowedHighwayTags.addAll(avoidHighwayTags);
+        allowedHighwayTags.add("cycleway");
         allowedHighwayTags.add("secondary");
         allowedHighwayTags.add("secondary_link");
-        allowedHighwayTags.add("tertiary");
-        allowedHighwayTags.add("tertiary_link");
         allowedHighwayTags.add("unclassified");
         allowedHighwayTags.add("road");
         // disallowed in some countries
         //allowedHighwayTags.add("bridleway");
+
+        hikingNetworkToCode.put("iwn", BEST.getValue());
+        hikingNetworkToCode.put("nwn", BEST.getValue());
+        hikingNetworkToCode.put("rwn", VERY_NICE.getValue());
+        hikingNetworkToCode.put("lwn", VERY_NICE.getValue());
     }
 
     @Override
@@ -101,25 +125,33 @@ public int defineWayBits( int index, int shift )
         // first two bits are reserved for route handling in superclass
         shift = super.defineWayBits(index, shift);
         // larger value required - ferries are faster than pedestrians
-        speedEncoder = new EncodedValue("Speed", shift, speedBits, speedFactor, MEAN, FERRY);
-        shift += speedBits;
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, MEAN_SPEED, FERRY_SPEED);
+        shift += speedEncoder.getBits();
 
-        safeWayBit = 1 << shift++;
+        preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
+        shift += preferWayEncoder.getBits();
         return shift;
     }
-    
+
+    @Override
+    public int defineRelationBits( int index, int shift )
+    {
+        relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
+        return shift + relationCodeEncoder.getBits();
+    }
+
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
      */
     @Override
-    public int defineTurnBits( int index, int shift, int numberCostsBits )
+    public int defineTurnBits( int index, int shift )
     {
         return shift;
     }
-    
+
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * 
+     * <p>
      * @return <code>false</code>
      */
     @Override
@@ -127,23 +159,22 @@ public boolean isTurnRestricted( long flag )
     {
         return false;
     }
-    
+
     /**
      * Foot flag encoder does not provide any turn cost / restrictions
-     * 
+     * <p>
      * @return 0
-     */    
+     */
     @Override
-    public int getTurnCosts( long flag )
+    public double getTurnCost( long flag )
     {
         return 0;
     }
-    
 
     @Override
-    public String toString()
+    public long getTurnFlags( boolean restricted, double costs )
     {
-        return "foot";
+        return 0;
     }
 
     /**
@@ -169,7 +200,8 @@ public long acceptWay( OSMWay way )
         String sacScale = way.getTag("sac_scale");
         if (sacScale != null)
         {
-            if (!"hiking".equals(sacScale) && !"mountain_hiking".equals(sacScale))
+            if (!"hiking".equals(sacScale) && !"mountain_hiking".equals(sacScale)
+                    && !"demanding_mountain_hiking".equals(sacScale) && !"alpine_hiking".equals(sacScale))
                 // other scales are too dangerous, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
                 return 0;
         }
@@ -178,7 +210,7 @@ public long acceptWay( OSMWay way )
             return acceptBit;
 
         // no need to evaluate ferries or fords - already included here
-        if (way.hasTag("foot", intended))
+        if (way.hasTag("foot", intendedValues))
             return acceptBit;
 
         if (!allowedHighwayTags.contains(highwayValue))
@@ -188,10 +220,7 @@ public long acceptWay( OSMWay way )
             return 0;
 
         // do not get our feet wet, "yes" is already included above
-        if (way.hasTag("highway", "ford") || way.hasTag("ford"))
-            return 0;
-
-        if (way.hasTag("bicycle", "official"))
+        if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
             return 0;
 
         // check access restrictions
@@ -208,41 +237,60 @@ public long acceptWay( OSMWay way )
     @Override
     public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
     {
+        int code = 0;
+        if (relation.hasTag("route", "hiking") || relation.hasTag("route", "foot"))
+        {
+            Integer val = hikingNetworkToCode.get(relation.getTag("network"));
+            if (val != null)
+                code = val;
+        } else if (relation.hasTag("route", "ferry"))
+        {
+            code = PriorityCode.AVOID_IF_POSSIBLE.getValue();
+        }
+
+        int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
+        if (oldCode < code)
+            return relationCodeEncoder.setValue(0, code);
         return oldRelationFlags;
     }
 
     @Override
-    public long handleWayTags( OSMWay way, long allowed, long relationCode )
+    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
     {
-        if ((allowed & acceptBit) == 0)
+        if (!isAccept(allowed))
             return 0;
 
         long encoded;
-        if ((allowed & ferryBit) == 0)
-        {
+        if (!isFerry(allowed))
+        {           
             String sacScale = way.getTag("sac_scale");
             if (sacScale != null)
             {
                 if ("hiking".equals(sacScale))
-                    encoded = speedEncoder.setValue(0, MEAN);
+                    encoded = speedEncoder.setDoubleValue(0, MEAN_SPEED);
                 else
-                    encoded = speedEncoder.setValue(0, SLOW);
+                    encoded = speedEncoder.setDoubleValue(0, SLOW_SPEED);
             } else
             {
-                encoded = speedEncoder.setValue(0, MEAN);
+                encoded = speedEncoder.setDoubleValue(0, MEAN_SPEED);
             }
             encoded |= directionBitMask;
 
-            // mark safe ways or ways with cycle lanes
-            if (safeHighwayTags.contains(way.getTag("highway"))
-                    || way.hasTag("sidewalk", sidewalks))
+            int priorityFromRelation = 0;
+            if (relationFlags != 0)
+                priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
+
+            encoded = setLong(encoded, PriorityWeighting.KEY, handlePriority(way, priorityFromRelation));
+
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
             {
-                encoded |= safeWayBit;
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
             }
 
         } else
         {
-            encoded = handleFerry(way, SLOW, MEAN, FERRY);
+            encoded = handleFerryTags(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
             encoded |= directionBitMask;
         }
 
@@ -250,14 +298,108 @@ public long handleWayTags( OSMWay way, long allowed, long relationCode )
     }
 
     @Override
-    public int getPavementCode( long flags )
+    public double getDouble( long flags, int key )
     {
-        return 0;
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                double prio = preferWayEncoder.getValue(flags);
+                if (prio == 0)
+                    return (double) UNCHANGED.getValue() / BEST.getValue();
+
+                return prio / BEST.getValue();
+            default:
+                return super.getDouble(flags, key);
+        }
     }
 
     @Override
-    public int getWayTypeCode( long flags )
+    public long getLong( long flags, int key )
     {
-        return 0;
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.getValue(flags);
+            default:
+                return super.getLong(flags, key);
+        }
+    }
+
+    @Override
+    public long setLong( long flags, int key, long value )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.setValue(flags, value);
+            default:
+                return super.setLong(flags, key, value);
+        }
+    }
+
+    protected int handlePriority( OSMWay way, int priorityFromRelation )
+    {
+        TreeMap<Double, Integer> weightToPrioMap = new TreeMap<Double, Integer>();
+        if (priorityFromRelation == 0)
+            weightToPrioMap.put(0d, UNCHANGED.getValue());
+        else
+            weightToPrioMap.put(110d, priorityFromRelation);
+
+        collect(way, weightToPrioMap);
+
+        // pick priority with biggest order value
+        return weightToPrioMap.lastEntry().getValue();
+    }
+
+    /**
+     * @param weightToPrioMap associate a weight with every priority. This sorted map allows
+     * subclasses to 'insert' more important priorities as well as overwrite determined priorities.
+     */
+    void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
+    {
+        String highway = way.getTag("highway");
+        if (way.hasTag("foot", "designated"))
+            weightToPrioMap.put(100d, PREFER.getValue());
+
+        double maxSpeed = getMaxSpeed(way);
+        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20)
+        {
+            weightToPrioMap.put(40d, PREFER.getValue());
+            if (way.hasTag("tunnel", intendedValues))
+                weightToPrioMap.put(40d, UNCHANGED.getValue());
+        }
+
+        if (way.hasTag("bicycle", "official") || way.hasTag("bicycle", "designated"))
+        {
+            weightToPrioMap.put(44d, AVOID_IF_POSSIBLE.getValue());
+        }
+
+        if (way.hasTag("sidewalk", sidewalks))
+        {
+            weightToPrioMap.put(45d, PREFER.getValue());
+        }
+
+        if (avoidHighwayTags.contains(highway) || maxSpeed > 50)
+        {
+            weightToPrioMap.put(50d, REACH_DEST.getValue());
+
+            if (way.hasTag("tunnel", intendedValues))
+                weightToPrioMap.put(50d, AVOID_AT_ALL_COSTS.getValue());
+        }
+    }
+
+    @Override
+    public boolean supports( Class<?> feature )
+    {
+        if (super.supports(feature))
+            return true;
+
+        return PriorityWeighting.class.isAssignableFrom(feature);
+    }
+
+    @Override
+    public String toString()
+    {
+        return "foot";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
index 1db6312e76..985a4477d5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.EdgeSkipIterator;
 
 /**
  * Only certain nodes are accepted and therefor the others are ignored.
@@ -27,16 +29,28 @@
  */
 public class LevelEdgeFilter implements EdgeFilter
 {
-    protected LevelGraph graph;
+    private final LevelGraph graph;
+    private final int maxNodes;
 
     public LevelEdgeFilter( LevelGraph g )
     {
         graph = g;
+        maxNodes = g.getNodes();
     }
 
     @Override
-    public boolean accept( EdgeIteratorState edgeIter )
+    public boolean accept( EdgeIteratorState edgeIterState )
     {
-        return graph.getLevel(edgeIter.getBaseNode()) <= graph.getLevel(edgeIter.getAdjNode());
+        int base = edgeIterState.getBaseNode();
+        int adj = edgeIterState.getAdjNode();
+        // always accept virtual edges, see #288
+        if (base >= maxNodes || adj >= maxNodes)
+            return true;
+
+        // minor performance improvement: shortcuts in wrong direction are disconnected, so no need to exclude them
+        if (((EdgeSkipIterState) edgeIterState).isShortcut())
+            return true;
+
+        return graph.getLevel(base) <= graph.getLevel(adj);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
new file mode 100644
index 0000000000..ce5f0aef68
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -0,0 +1,328 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.OSMWay;
+import com.graphhopper.util.BitUtil;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import java.util.HashSet;
+
+/**
+ * Defines bit layout for motorbikes
+ * <p>
+ * @author Peter Karich
+ */
+public class MotorcycleFlagEncoder extends CarFlagEncoder
+{
+    private EncodedDoubleValue reverseSpeedEncoder;
+    private EncodedValue preferWayEncoder;
+    private final HashSet<String> avoidSet = new HashSet<String>();
+    private final HashSet<String> preferSet = new HashSet<String>();
+
+    public MotorcycleFlagEncoder( String propertiesStr )
+    {
+        this((int) parseLong(propertiesStr, "speedBits", 5),
+                parseDouble(propertiesStr, "speedFactor", 5),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+    }
+
+    public MotorcycleFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        restrictions.remove("motorcar");
+        //  moped, mofa
+        restrictions.add("motorcycle");
+
+        trackTypeSpeedMap.clear();
+        defaultSpeedMap.clear();
+
+        trackTypeSpeedMap.put("grade1", 20); // paved
+        trackTypeSpeedMap.put("grade2", 15); // now unpaved - gravel mixed with ...
+        trackTypeSpeedMap.put("grade3", 10); // ... hard and soft materials
+        trackTypeSpeedMap.put("grade4", 5); // ... some hard or compressed materials
+        trackTypeSpeedMap.put("grade5", 5); // ... no hard materials. soil/sand/grass
+
+        avoidSet.add("motorway");
+        avoidSet.add("trunk");
+        avoidSet.add("motorroad");
+        preferSet.add("primary");
+        preferSet.add("secondary");
+
+        // autobahn
+        defaultSpeedMap.put("motorway", 100);
+        defaultSpeedMap.put("motorway_link", 70);
+        defaultSpeedMap.put("motorroad", 90);
+        // bundesstraße
+        defaultSpeedMap.put("trunk", 80);
+        defaultSpeedMap.put("trunk_link", 75);
+        // linking bigger town
+        defaultSpeedMap.put("primary", 65);
+        defaultSpeedMap.put("primary_link", 60);
+        // linking towns + villages
+        defaultSpeedMap.put("secondary", 60);
+        defaultSpeedMap.put("secondary_link", 50);
+        // streets without middle line separation
+        defaultSpeedMap.put("tertiary", 50);
+        defaultSpeedMap.put("tertiary_link", 40);
+        defaultSpeedMap.put("unclassified", 30);
+        defaultSpeedMap.put("residential", 30);
+        // spielstraße
+        defaultSpeedMap.put("living_street", 5);
+        defaultSpeedMap.put("service", 20);
+        // unknown road
+        defaultSpeedMap.put("road", 20);
+        // forestry stuff
+        defaultSpeedMap.put("track", 15);
+    }
+
+    /**
+     * Define the place of the speedBits in the edge flags for car.
+     */
+    @Override
+    public int defineWayBits( int index, int shift )
+    {
+        // first two bits are reserved for route handling in superclass
+        shift = super.defineWayBits(index, shift);
+        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), defaultSpeedMap.get("motorway"));
+        shift += reverseSpeedEncoder.getBits();
+
+        preferWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 3, 7);
+        shift += reverseSpeedEncoder.getBits();
+
+        return shift;
+    }
+
+    @Override
+    public long acceptWay( OSMWay way )
+    {
+        String highwayValue = way.getTag("highway");
+        if (highwayValue == null)
+        {
+            if (way.hasTag("route", ferries))
+            {
+                String motorcycleTag = way.getTag("motorcycle");
+                if (motorcycleTag == null)
+                    motorcycleTag = way.getTag("motor_vehicle");
+
+                if (motorcycleTag == null && !way.hasTag("foot") && !way.hasTag("bicycle") || "yes".equals(motorcycleTag))
+                    return acceptBit | ferryBit;
+            }
+            return 0;
+        }
+
+        if ("track".equals(highwayValue))
+        {
+            String tt = way.getTag("tracktype");
+            if (tt != null && !tt.equals("grade1"))
+                return 0;
+        }
+
+        if (!defaultSpeedMap.containsKey(highwayValue))
+            return 0;
+
+        if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
+            return 0;
+
+        // do not drive street cars into fords
+        boolean carsAllowed = way.hasTag(restrictions, intendedValues);
+        if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")) && !carsAllowed)
+            return 0;
+
+        // check access restrictions
+        if (way.hasTag(restrictions, restrictedValues) && !carsAllowed)
+            return 0;
+
+        // do not drive cars over railways (sometimes incorrectly mapped!)
+        if (way.hasTag("railway") && !way.hasTag("railway", acceptedRailways))
+            return 0;
+
+        return acceptBit;
+    }
+
+    @Override
+    public long handleWayTags( OSMWay way, long allowed, long relationFlags )
+    {
+        if (!isAccept(allowed))
+            return 0;
+
+        long encoded = 0;
+        if (!isFerry(allowed))
+        {
+            encoded = setLong(encoded, PriorityWeighting.KEY, calcPriority(way, relationFlags));
+
+            // get assumed speed from highway type
+            double speed = getSpeed(way);
+            speed = applyMaxSpeed(way, speed, true);
+
+            double maxMCSpeed = parseSpeed(way.getTag("maxspeed:motorcycle"));
+            if (maxMCSpeed > 0 && maxMCSpeed < speed)
+                speed = maxMCSpeed * 0.9;
+
+            // limit speed to max 30 km/h if bad surface
+            if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
+                speed = 30;
+
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+                encoded = setBool(0, K_ROUNDABOUT, true);
+
+            if (way.hasTag("oneway", oneways) || isRoundabout)
+            {
+                if (way.hasTag("oneway", "-1"))
+                {
+                    encoded = setReverseSpeed(encoded, speed);
+                    encoded |= backwardBit;
+                } else
+                {
+                    encoded = setSpeed(encoded, speed);
+                    encoded |= forwardBit;
+                }
+            } else
+            {
+                encoded = setSpeed(encoded, speed);
+                encoded = setReverseSpeed(encoded, speed);
+                encoded |= directionBitMask;
+            }
+
+        } else
+        {
+            encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
+            encoded |= directionBitMask;
+        }
+
+        return encoded;
+    }
+
+    @Override
+    public double getReverseSpeed( long flags )
+    {
+        return reverseSpeedEncoder.getDoubleValue(flags);
+    }
+
+    @Override
+    public long setReverseSpeed( long flags, double speed )
+    {
+        if (speed < 0)
+            throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
+
+        if (speed > getMaxSpeed())
+            speed = getMaxSpeed();
+
+        return reverseSpeedEncoder.setDoubleValue(flags, speed);
+    }
+
+    @Override
+    public long flagsDefault( boolean forward, boolean backward )
+    {
+        long flags = super.flagsDefault(forward, backward);
+        if (backward)
+            return reverseSpeedEncoder.setDefaultValue(flags);
+
+        return flags;
+    }
+
+    @Override
+    public long setProperties( double speed, boolean forward, boolean backward )
+    {
+        long flags = super.setProperties(speed, forward, backward);
+        if (backward)
+            return setReverseSpeed(flags, speed);
+
+        return flags;
+    }
+
+    @Override
+    public long reverseFlags( long flags )
+    {
+        // swap access
+        flags = super.reverseFlags(flags);
+
+        // swap speeds 
+        double otherValue = reverseSpeedEncoder.getDoubleValue(flags);
+        flags = setReverseSpeed(flags, speedEncoder.getDoubleValue(flags));
+        return setSpeed(flags, otherValue);
+    }
+
+    @Override
+    public double getDouble( long flags, int key )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                double prio = preferWayEncoder.getValue(flags);
+                if (prio == 0)
+                    return (double) UNCHANGED.getValue() / BEST.getValue();
+
+                return prio / BEST.getValue();
+            default:
+                return super.getDouble(flags, key);
+        }
+    }
+
+    @Override
+    public long getLong( long flags, int key )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.getValue(flags);
+            default:
+                return super.getLong(flags, key);
+        }
+    }
+
+    @Override
+    public long setLong( long flags, int key, long value )
+    {
+        switch (key)
+        {
+            case PriorityWeighting.KEY:
+                return preferWayEncoder.setValue(flags, value);
+            default:
+                return super.setLong(flags, key, value);
+        }
+    }
+
+    private int calcPriority( OSMWay way, long relationFlags )
+    {
+        String highway = way.getTag("highway", "");
+        if (avoidSet.contains(highway))
+        {
+            return PriorityCode.AVOID_AT_ALL_COSTS.getValue();
+        } else if (preferSet.contains(highway))
+        {
+            return PriorityCode.VERY_NICE.getValue();
+        }
+        return PriorityCode.UNCHANGED.getValue();
+    }
+
+    @Override
+    public boolean supports( Class<?> feature )
+    {
+        if (super.supports(feature))
+            return true;
+
+        return PriorityWeighting.class.isAssignableFrom(feature);
+    }
+
+    @Override
+    public String toString()
+    {
+        return "motorcycle";
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
index f77aa953cd..26da91bb32 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
@@ -17,71 +17,162 @@
  */
 package com.graphhopper.routing.util;
 
-import static com.graphhopper.routing.util.BikeFlagCommonEncoder.PUSHING_SECTION_SPEED;
+import com.graphhopper.reader.OSMRelation;
+import com.graphhopper.reader.OSMWay;
+import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import java.util.TreeMap;
 
 /**
  * Specifies the settings for mountain biking
  * <p/>
  * @author ratrun
+ * @author Peter Karich
  */
-public class MountainBikeFlagEncoder extends BikeFlagCommonEncoder
+public class MountainBikeFlagEncoder extends BikeCommonFlagEncoder
 {
-    MountainBikeFlagEncoder()
+    public MountainBikeFlagEncoder()
     {
-        setTrackTypeSpeed("grade1", 12); // paved
-        setTrackTypeSpeed("grade2", 20); // now unpaved ...
-        setTrackTypeSpeed("grade3", 20);
-        setTrackTypeSpeed("grade4", 20);
-        setTrackTypeSpeed("grade5", 20); // like sand/grass     
-
-        setSurfaceSpeed("asphalt", 12);
-        setSurfaceSpeed("concrete", 12);
-        setSurfaceSpeed("paved", 12);
-        setSurfaceSpeed("unpaved", 20);
-        setSurfaceSpeed("gravel", 20);
-        setSurfaceSpeed("ground", 20);
-        setSurfaceSpeed("dirt", 20);
-        setSurfaceSpeed("paving_stones", 20);
-        setSurfaceSpeed("grass", 20);
-        setSurfaceSpeed("cobblestone", 20);
-
-        setHighwaySpeed("living_street", 15);
-        setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
-
-        setHighwaySpeed("cycleway", 12);
-        setHighwaySpeed("path", 24);
-        setHighwaySpeed("footway", 15);
-        setHighwaySpeed("pedestrian", 15);
-        setHighwaySpeed("road", 10);
-        setHighwaySpeed("track", 24);
-        setHighwaySpeed("service", 15);
-        setHighwaySpeed("unclassified", 15);
-        setHighwaySpeed("residential", 15);
-
-        setHighwaySpeed("trunk", 12);
-        setHighwaySpeed("trunk_link", 12);
-        setHighwaySpeed("primary", 10);
-        setHighwaySpeed("primary_link", 10);
-        setHighwaySpeed("secondary", 12);
-        setHighwaySpeed("secondary_link", 12);
-        setHighwaySpeed("tertiary", 14);
-        setHighwaySpeed("tertiary_link", 14);
-
-        setPushingSection("footway");
-        setPushingSection("pedestrian");
-        setPushingSection("steps");
-
-        setCyclingNetworkPreference("icn", BikeFlagCommonEncoder.RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("ncn", BikeFlagCommonEncoder.RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("rcn", BikeFlagCommonEncoder.RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("lcn", BikeFlagCommonEncoder.RelationMapCode.PREFER.getValue());
-        setCyclingNetworkPreference("mtb", BikeFlagCommonEncoder.RelationMapCode.OUTSTANDING_NICE.getValue());
+        this(4, 2, 0);
+    }
 
+    public MountainBikeFlagEncoder( String propertiesStr )
+    {
+        this((int) parseLong(propertiesStr, "speedBits", 4),
+                parseDouble(propertiesStr, "speedFactor", 2),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+    }
+
+    public MountainBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        setTrackTypeSpeed("grade1", 18); // paved
+        setTrackTypeSpeed("grade2", 16); // now unpaved ...
+        setTrackTypeSpeed("grade3", 12);
+        setTrackTypeSpeed("grade4", 8);
+        setTrackTypeSpeed("grade5", 6); // like sand/grass     
+
+        setSurfaceSpeed("paved", 18);
+        setSurfaceSpeed("asphalt", 18);
+        setSurfaceSpeed("cobblestone", 10);
+        setSurfaceSpeed("cobblestone:flattened", 10);
+        setSurfaceSpeed("sett", 10);
+        setSurfaceSpeed("concrete", 14);
+        setSurfaceSpeed("concrete:lanes", 16);
+        setSurfaceSpeed("concrete:plates", 16);
+        setSurfaceSpeed("paving_stones", 16);
+        setSurfaceSpeed("paving_stones:30", 16);
+        setSurfaceSpeed("unpaved", 14);
+        setSurfaceSpeed("compacted", 14);
+        setSurfaceSpeed("dirt", 14);
+        setSurfaceSpeed("earth", 14);
+        setSurfaceSpeed("fine_gravel", 18);
+        setSurfaceSpeed("grass", 14);
+        setSurfaceSpeed("grass_paver", 14);
+        setSurfaceSpeed("gravel", 16);
+        setSurfaceSpeed("ground", 16);
+        setSurfaceSpeed("ice", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("metal", 10);
+        setSurfaceSpeed("mud", 12);
+        setSurfaceSpeed("pebblestone", 12);
+        setSurfaceSpeed("salt", 12);
+        setSurfaceSpeed("sand", 10);
+        setSurfaceSpeed("wood", 10);
+
+        setHighwaySpeed("living_street", 6);
+        setHighwaySpeed("steps", PUSHING_SECTION_SPEED);
+
+        setHighwaySpeed("cycleway", 18);
+        setHighwaySpeed("path", 18);
+        setHighwaySpeed("footway", 6);
+        setHighwaySpeed("pedestrian", 6);
+        setHighwaySpeed("road", 12);
+        setHighwaySpeed("track", 18);
+        setHighwaySpeed("service", 14);
+        setHighwaySpeed("unclassified", 16);
+        setHighwaySpeed("residential", 16);
+
+        setHighwaySpeed("trunk", 18);
+        setHighwaySpeed("trunk_link", 18);
+        setHighwaySpeed("primary", 18);
+        setHighwaySpeed("primary_link", 18);
+        setHighwaySpeed("secondary", 18);
+        setHighwaySpeed("secondary_link", 18);
+        setHighwaySpeed("tertiary", 18);
+        setHighwaySpeed("tertiary_link", 18);
+
+        addPushingSection("footway");
+        addPushingSection("pedestrian");
+        addPushingSection("steps");
+
+        setCyclingNetworkPreference("icn", PREFER.getValue());
+        setCyclingNetworkPreference("ncn", PREFER.getValue());
+        setCyclingNetworkPreference("rcn", PREFER.getValue());
+        setCyclingNetworkPreference("lcn", PREFER.getValue());
+        setCyclingNetworkPreference("mtb", BEST.getValue());
+
+        addPushingSection("footway");
+        addPushingSection("pedestrian");
+        addPushingSection("steps");
+
+        avoidHighwayTags.add("primary");
+        avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("secondary");
+        avoidHighwayTags.add("secondary_link");
+
+        preferHighwayTags.add("road");
+        preferHighwayTags.add("track");
+        preferHighwayTags.add("path");
+        preferHighwayTags.add("service");
+        preferHighwayTags.add("tertiary");
+        preferHighwayTags.add("tertiary_link");
+        preferHighwayTags.add("residential");
+        preferHighwayTags.add("unclassified");
     }
 
     @Override
-    public String toString()
+    void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
     {
+        super.collect(way, weightToPrioMap);
+
+        String highway = way.getTag("highway");
+        if ("track".equals(highway))
+        {
+            String trackType = way.getTag("tracktype");
+            if ("grade1".equals(trackType))
+                weightToPrioMap.put(50d, UNCHANGED.getValue());
+            else if (trackType == null)
+                weightToPrioMap.put(90d, PREFER.getValue());
+            else if (trackType.startsWith("grade"))
+                weightToPrioMap.put(100d, VERY_NICE.getValue());
+        }
+    }
+
+    @Override
+    public long handleRelationTags( OSMRelation relation, long oldRelationFlags )
+    {
+        oldRelationFlags = super.handleRelationTags(relation, oldRelationFlags);
+        int code = 0;
+        if (relation.hasTag("route", "mtb"))
+            code = PREFER.getValue();
+
+        int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
+        if (oldCode < code)
+            return relationCodeEncoder.setValue(0, code);
+        return oldRelationFlags;
+    }
+
+    @Override
+    boolean allowedSacScale( String sacScale )
+    {
+        // other scales are too dangerous even for MTB, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
+        return "hiking".equals(sacScale) || "mountain_hiking".equals(sacScale)
+                || "demanding_mountain_hiking".equals(sacScale) || "alpine_hiking".equals(sacScale);
+    }
+
+    @Override
+    public String toString()
+    {        
         return "mtb";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java b/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java
deleted file mode 100644
index 26dbacbf60..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.RoutingAlgorithmFactory;
-import com.graphhopper.storage.Graph;
-
-/**
- * @author Peter Karich
- */
-public abstract class NoOpAlgorithmPreparation extends AbstractAlgoPreparation<NoOpAlgorithmPreparation>
-{
-    public NoOpAlgorithmPreparation()
-    {
-    }
-
-    /**
-     * Creates a preparation wrapper for the specified algorithm. Possible values for algorithmStr:
-     * astar (A* algorithm), astarbi (bidirectional A*) dijkstra (Dijkstra), dijkstrabi and
-     * dijkstraNative (a bit faster bidirectional Dijkstra).
-     */
-    public static AlgorithmPreparation createAlgoPrepare( Graph g, final String algorithmStr,
-            FlagEncoder encoder, Weighting weighting )
-    {
-        return p(new RoutingAlgorithmFactory(algorithmStr, false), encoder, weighting).setGraph(g);
-    }
-
-    private static AlgorithmPreparation p( final RoutingAlgorithmFactory factory,
-            final FlagEncoder encoder, final Weighting weighting )
-    {
-        return new NoOpAlgorithmPreparation()
-        {
-            @Override
-            public RoutingAlgorithm createAlgo()
-            {
-                try
-                {
-                    return factory.createAlgo(_graph, encoder, weighting);
-                } catch (Exception ex)
-                {
-                    throw new RuntimeException(ex);
-                }
-            }
-
-            @Override
-            public String toString()
-            {
-                return createAlgo().getName() + ", " + encoder + ", " + weighting;
-            }
-        };
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index 009db0927c..a02bf36a83 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -20,16 +20,16 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.XFirstSearch;
+import com.graphhopper.util.*;
 import java.util.*;
 import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicInteger;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import gnu.trove.list.array.TIntArrayList;
+
 /**
  * Removes nodes which are not part of the largest network. Ie. mostly nodes with no edges at all
  * but also small subnetworks which are nearly always bugs in OSM data or indicate otherwise
@@ -43,18 +43,19 @@
     private final GraphStorage g;
     private final EdgeFilter edgeFilter;
     private int minNetworkSize = 200;
+    private int minOneWayNetworkSize = 0;
     private int subNetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
+    private FlagEncoder singleEncoder;
 
     public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
     {
         this.g = g;
-        if (em.getVehicleCount() == 0)
-            throw new IllegalStateException("No vehicles found");
-        else if (em.getVehicleCount() > 1)
+        List<FlagEncoder> encoders = em.fetchEdgeEncoders();
+        if (encoders.size() > 1)
             edgeFilter = EdgeFilter.ALL_EDGES;
         else
-            edgeFilter = new DefaultEdgeFilter(em.getSingle());
+            edgeFilter = new DefaultEdgeFilter(singleEncoder = encoders.get(0));
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
@@ -63,12 +64,24 @@ public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
         return this;
     }
 
+    public PrepareRoutingSubnetworks setMinOneWayNetworkSize( int minOnewayNetworkSize )
+    {
+        this.minOneWayNetworkSize = minOnewayNetworkSize;
+        return this;
+    }
+
     public void doWork()
     {
         int del = removeZeroDegreeNodes();
         Map<Integer, Integer> map = findSubnetworks();
         keepLargeNetworks(map);
+
+        int unvisitedDeadEnds = -1;
+        if ((this.minOneWayNetworkSize > 0) && singleEncoder != null)
+            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
+
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
+                + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
                 + "maxEdges/node (" + maxEdgesPerNode.get() + ")");
         g.optimize();
         subNetworks = map.size();
@@ -80,18 +93,22 @@ public int getSubNetworks()
     }
 
     public Map<Integer, Integer> findSubnetworks()
+    {
+        return findSubnetworks(g.createEdgeExplorer(edgeFilter));
+    }
+
+    private Map<Integer, Integer> findSubnetworks( final EdgeExplorer explorer )
     {
         final Map<Integer, Integer> map = new HashMap<Integer, Integer>();
         final AtomicInteger integ = new AtomicInteger(0);
         int locs = g.getNodes();
         final GHBitSet bs = new GHBitSetImpl(locs);
-        EdgeExplorer explorer = g.createEdgeExplorer(edgeFilter);
         for (int start = 0; start < locs; start++)
         {
             if (g.isNodeRemoved(start) || bs.contains(start))
                 continue;
 
-            new XFirstSearch()
+            new BreadthFirstSearch()
             {
                 int tmpCounter = 0;
 
@@ -119,7 +136,7 @@ protected final boolean checkAdjacent( EdgeIteratorState iter )
                     return true;
                 }
 
-            }.start(explorer, start, false);
+            }.start(explorer, start);
             map.put(start, integ.get());
             integ.set(0);
         }
@@ -127,7 +144,7 @@ protected final boolean checkAdjacent( EdgeIteratorState iter )
     }
 
     /**
-     * Deletes all but the larges subnetworks.
+     * Deletes all but the largest subnetworks.
      */
     void keepLargeNetworks( Map<Integer, Integer> map )
     {
@@ -171,7 +188,7 @@ void removeNetwork( int start, int entries, final GHBitSet bs )
             return;
         }
         EdgeExplorer explorer = g.createEdgeExplorer(edgeFilter);
-        new XFirstSearch()
+        new DepthFirstSearch()
         {
             @Override
             protected GHBitSet createBitSet()
@@ -185,7 +202,7 @@ protected boolean goFurther( int nodeId )
                 g.markNodeRemoved(nodeId);
                 return super.goFurther(nodeId);
             }
-        }.start(explorer, start, true);
+        }.start(explorer, start);
     }
 
     /**
@@ -209,4 +226,34 @@ int removeZeroDegreeNodes()
         }
         return removed;
     }
+
+    /**
+     * Clean small networks that will be never be visited by this explorer See #86 For example,
+     * small areas like parking lots are sometimes connected to the whole network through a one-way
+     * road. This is clearly an error - but is causes the routing to fail when point get connected
+     * to this small area. This routines removed all these points from the graph.
+     * <p/>
+     * @return number of removed nodes;
+     */
+    public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
+    {
+        // Partition g into strongly connected components using Tarjan's Algorithm.
+        final EdgeFilter filter = new DefaultEdgeFilter(encoder, false, true);
+        List<TIntArrayList> components = new TarjansStronglyConnectedComponentsAlgorithm(g, filter).findComponents();
+
+        // remove components less than minimum size
+        int removed = 0;
+        for (TIntArrayList component : components)
+        {
+            if (component.size() < minOneWayNetworkSize)
+            {
+                for (int i = 0; i < component.size(); i++)
+                {
+                    g.markNodeRemoved(component.get(i));
+                    removed++;
+                }
+            }
+        }
+        return removed;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/IntRef.java b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
similarity index 64%
rename from core/src/main/java/com/graphhopper/util/IntRef.java
rename to core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
index e349ca4b5f..e21eab1310 100644
--- a/core/src/main/java/com/graphhopper/util/IntRef.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
@@ -15,17 +15,34 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.routing.util;
 
 /**
+ * Used to store a priority value in the way flags of an edge. Used in combination with
+ * PriorityWeighting
+ * <p>
  * @author Peter Karich
  */
-public class IntRef
+public enum PriorityCode
 {
-    public int val;
+    WORST(0),
+    AVOID_AT_ALL_COSTS(1),
+    REACH_DEST(2),
+    AVOID_IF_POSSIBLE(3),
+    UNCHANGED(4),
+    PREFER(5),
+    VERY_NICE(6),
+    BEST(7);
+    private final int value;
 
-    public IntRef( int val )
+    private PriorityCode( int value )
     {
-        this.val = val;
+        this.value = value;
     }
+
+    public int getValue()
+    {
+        return value;
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
new file mode 100644
index 0000000000..1b20c872a4
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWeighting.java
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * Special weighting for (motor)bike
+ * <p>
+ * @author Peter Karich
+ */
+public class PriorityWeighting extends FastestWeighting
+{
+    /**
+     * For now used only in BikeCommonFlagEncoder and MotorcycleFlagEncoder
+     */
+    public static final int KEY = 101;
+
+    public PriorityWeighting( FlagEncoder encoder )
+    {
+        super(encoder);
+    }
+
+    @Override
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+    {
+        double weight = super.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+        if (Double.isInfinite(weight))
+            return Double.POSITIVE_INFINITY;
+        return weight / (0.5 + encoder.getDouble(edgeState.getFlags(), KEY));
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index bd4bcb9e76..9ccb9e1855 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -17,86 +17,138 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMWay;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import java.util.TreeMap;
+
 /**
  * Specifies the settings for racebikeing
  * <p/>
  * @author ratrun
+ * @author Peter Karich
  */
-public class RacingBikeFlagEncoder extends BikeFlagCommonEncoder
+public class RacingBikeFlagEncoder extends BikeCommonFlagEncoder
 {
-    RacingBikeFlagEncoder()
+    public RacingBikeFlagEncoder()
+    {
+        this(4, 2, 0);
+    }
+
+    public RacingBikeFlagEncoder( String propertiesStr )
     {
+        this((int) parseLong(propertiesStr, "speedBits", 4),
+                parseDouble(propertiesStr, "speedFactor", 2),
+                parseBoolean(propertiesStr, "turnCosts", false) ? 3 : 0);
+    }
+
+    public RacingBikeFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+    {
+        super(speedBits, speedFactor, maxTurnCosts);
+        preferHighwayTags.add("road");
+        preferHighwayTags.add("secondary");
+        preferHighwayTags.add("secondary_link");
+        preferHighwayTags.add("tertiary");
+        preferHighwayTags.add("tertiary_link");
+        preferHighwayTags.add("residential");
+
         setTrackTypeSpeed("grade1", 20); // paved
-        setTrackTypeSpeed("grade2", PUSHING_SECTION_SPEED); // now unpaved ...
-        setTrackTypeSpeed("grade3", PUSHING_SECTION_SPEED / 2);
-        setTrackTypeSpeed("grade4", PUSHING_SECTION_SPEED / 2);
-        setTrackTypeSpeed("grade5", PUSHING_SECTION_SPEED / 2); // like sand/grass     
+        setTrackTypeSpeed("grade2", 10); // now unpaved ...
+        setTrackTypeSpeed("grade3", PUSHING_SECTION_SPEED);
+        setTrackTypeSpeed("grade4", PUSHING_SECTION_SPEED);
+        setTrackTypeSpeed("grade5", PUSHING_SECTION_SPEED);
 
+        setSurfaceSpeed("paved", 20);
         setSurfaceSpeed("asphalt", 20);
+        setSurfaceSpeed("cobblestone", 10);
+        setSurfaceSpeed("cobblestone:flattened", 10);
+        setSurfaceSpeed("sett", 10);
         setSurfaceSpeed("concrete", 20);
-        setSurfaceSpeed("paved", 20);
+        setSurfaceSpeed("concrete:lanes", 16);
+        setSurfaceSpeed("concrete:plates", 16);
+        setSurfaceSpeed("paving_stones", 10);
+        setSurfaceSpeed("paving_stones:30", 10);
         setSurfaceSpeed("unpaved", PUSHING_SECTION_SPEED / 2);
-        setSurfaceSpeed("gravel", PUSHING_SECTION_SPEED / 2);
-        setSurfaceSpeed("ground", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("compacted", PUSHING_SECTION_SPEED / 2);
         setSurfaceSpeed("dirt", PUSHING_SECTION_SPEED / 2);
-        setSurfaceSpeed("paving_stones", PUSHING_SECTION_SPEED);
+        setSurfaceSpeed("earth", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("fine_gravel", PUSHING_SECTION_SPEED);
         setSurfaceSpeed("grass", PUSHING_SECTION_SPEED / 2);
-        setSurfaceSpeed("cobblestone", PUSHING_SECTION_SPEED / 2);
-
-        setHighwaySpeed("living_street", 15);
-        setHighwaySpeed("steps", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("grass_paver", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("gravel", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("ground", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("ice", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("metal", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("mud", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("pebblestone", PUSHING_SECTION_SPEED);
+        setSurfaceSpeed("salt", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("sand", PUSHING_SECTION_SPEED / 2);
+        setSurfaceSpeed("wood", PUSHING_SECTION_SPEED / 2);
 
         setHighwaySpeed("cycleway", 18);
-        setHighwaySpeed("path", 15);
-        setHighwaySpeed("footway", 15);
-        setHighwaySpeed("pedestrian", 15);
-        setHighwaySpeed("road", 10);
+        setHighwaySpeed("path", 8);
+        setHighwaySpeed("footway", 6);
+        setHighwaySpeed("pedestrian", 6);
+        setHighwaySpeed("road", 12);
         setHighwaySpeed("track", PUSHING_SECTION_SPEED / 2); // assume unpaved
-        setHighwaySpeed("service", 20);
-        setHighwaySpeed("unclassified", 20);
-        setHighwaySpeed("residential", 20);
+        setHighwaySpeed("service", 12);
+        setHighwaySpeed("unclassified", 16);
+        setHighwaySpeed("residential", 16);
 
         setHighwaySpeed("trunk", 20);
         setHighwaySpeed("trunk_link", 20);
         setHighwaySpeed("primary", 20);
         setHighwaySpeed("primary_link", 20);
-        setHighwaySpeed("secondary", 24);
-        setHighwaySpeed("secondary_link", 24);
-        setHighwaySpeed("tertiary", 24);
-        setHighwaySpeed("tertiary_link", 24);
+        setHighwaySpeed("secondary", 20);
+        setHighwaySpeed("secondary_link", 20);
+        setHighwaySpeed("tertiary", 20);
+        setHighwaySpeed("tertiary_link", 20);
 
-        setPushingSection("path");
-        setPushingSection("track");
-        setPushingSection("footway");
-        setPushingSection("pedestrian");
-        setPushingSection("steps");
+        addPushingSection("path");
+        addPushingSection("track");
+        addPushingSection("footway");
+        addPushingSection("pedestrian");
+        addPushingSection("steps");
 
-        setCyclingNetworkPreference("icn", RelationMapCode.OUTSTANDING_NICE.getValue());
-        setCyclingNetworkPreference("ncn", RelationMapCode.OUTSTANDING_NICE.getValue());
-        setCyclingNetworkPreference("rcn", RelationMapCode.VERY_NICE.getValue());
-        setCyclingNetworkPreference("lcn", RelationMapCode.UNCHANGED.getValue());
-        setCyclingNetworkPreference("mtb", RelationMapCode.UNCHANGED.getValue());
+        setCyclingNetworkPreference("icn", PriorityCode.BEST.getValue());
+        setCyclingNetworkPreference("ncn", PriorityCode.BEST.getValue());
+        setCyclingNetworkPreference("rcn", PriorityCode.VERY_NICE.getValue());
+        setCyclingNetworkPreference("lcn", PriorityCode.UNCHANGED.getValue());
+        setCyclingNetworkPreference("mtb", PriorityCode.UNCHANGED.getValue());
+    }
 
+    @Override
+    void collect( OSMWay way, TreeMap<Double, Integer> weightToPrioMap )
+    {
+        super.collect(way, weightToPrioMap);
+
+        String highway = way.getTag("highway");
+        if ("service".equals(highway))
+        {
+            weightToPrioMap.put(40d, UNCHANGED.getValue());
+        } else if ("track".equals(highway))
+        {
+            String trackType = way.getTag("tracktype");
+            if ("grade1".equals(trackType))
+                weightToPrioMap.put(110d, PREFER.getValue());
+            else if (trackType == null || trackType.startsWith("grade"))
+                weightToPrioMap.put(110d, AVOID_AT_ALL_COSTS.getValue());
+        }
     }
 
-    // In case that the way belongs to a relation for which we do have a relation triggered weight change.    
-    // FIXME: Re-write in case that there is a more generic way to influence the weighting (issue #124).
-    // Here we boost or reduce the speed according to the relationWeightCode:
     @Override
-    int relationWeightCodeToSpeed( int highwaySpeed, int relationCode )
+    boolean isPushingSection( OSMWay way )
     {
-        int speed;
-        if ((highwaySpeed > PUSHING_SECTION_SPEED) && (highwaySpeed < 15))
-            // We know that our way belongs to a cycle route, so we assume 15km/h minimum
-            speed = 15;
-        else
-            speed = highwaySpeed;
+        String highway = way.getTag("highway");
+        String trackType = way.getTag("tracktype");
+        return way.hasTag("highway", pushingSections)
+                || "track".equals(highway) && trackType != null && !"grade1".equals(trackType);
+    }
 
-        if (speed > PUSHING_SECTION_SPEED)
-            // Add or remove 4km/h per every relation weight boost point
-            return speed + 4 * (relationCode - DEFAULT_REL_CODE);
-        else
-            return speed;   // We are not pushing unpaved parts
+    @Override
+    boolean allowedSacScale( String sacScale )
+    {
+        // for racing bike it is only allowed if empty
+        return false;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java b/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
deleted file mode 100644
index a749b00b16..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.GraphHopper;
-import com.graphhopper.coll.MapEntry;
-import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.util.StopWatch;
-import static com.graphhopper.routing.util.NoOpAlgorithmPreparation.*;
-import com.graphhopper.storage.*;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map.Entry;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Integration tests for one bigger area - at the moment Unterfranken (Germany). Execute via
- * ./graphhopper.sh test unterfranken.osm
- * <p/>
- * @author Peter Karich
- */
-public class RoutingAlgorithmSpecialAreaTests
-{
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final Graph unterfrankenGraph;
-    private final LocationIndex idx;
-
-    public RoutingAlgorithmSpecialAreaTests( GraphHopper graphhopper )
-    {
-        this.unterfrankenGraph = graphhopper.getGraph();
-        StopWatch sw = new StopWatch().start();
-        idx = graphhopper.getLocationIndex();
-        logger.info(idx.getClass().getSimpleName() + " index. Size:"
-                + (float) idx.getCapacity() / (1 << 20) + " MB, took:" + sw.stop().getSeconds());
-    }
-
-    public void start()
-    {
-        testIndex();
-        testAlgos();
-    }
-
-    void testAlgos()
-    {
-        if (unterfrankenGraph instanceof LevelGraph)
-        {
-            throw new IllegalStateException("run testAlgos only with a none-LevelGraph. Use prepare.chShortcuts=false "
-                    + "Or use prepare.chShortcuts=shortest and avoid the preparation");
-        }
-
-        TestAlgoCollector testCollector = new TestAlgoCollector("testAlgos");
-        final EncodingManager encodingManager = new EncodingManager("CAR");
-        CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-        boolean ch = true;
-        Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = createAlgos(unterfrankenGraph, idx,
-                carEncoder, ch, new ShortestWeighting(), encodingManager);
-        EdgeFilter ef = new DefaultEdgeFilter(carEncoder);
-
-        for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
-        {
-            AlgorithmPreparation prepare = entry.getKey();
-            LocationIndex currIdx = entry.getValue();
-            int failed = testCollector.errors.size();
-
-            testCollector.assertDistance(prepare.createAlgo(),
-                    currIdx.findClosest(50.0314, 10.5105, ef), currIdx.findClosest(50.0303, 10.5070, ef), 570, 22);
-            testCollector.assertDistance(prepare.createAlgo(),
-                    currIdx.findClosest(49.51451, 9.967346, ef), currIdx.findClosest(50.2920, 10.4650, ef), 107545, 1712);
-            testCollector.assertDistance(prepare.createAlgo(),
-                    currIdx.findClosest(50.0780, 9.1570, ef), currIdx.findClosest(49.5860, 9.9750, ef), 91715, 1299);
-            testCollector.assertDistance(prepare.createAlgo(),
-                    currIdx.findClosest(50.2800, 9.7190, ef), currIdx.findClosest(49.8960, 10.3890, ef), 76411, 1406);
-            testCollector.assertDistance(prepare.createAlgo(),
-                    currIdx.findClosest(49.8020, 9.2470, ef), currIdx.findClosest(50.4940, 10.1970, ef), 125633, 2253);
-            testCollector.assertDistance(prepare.createAlgo(),
-                    currIdx.findClosest(49.72449, 9.23482, ef), currIdx.findClosest(50.4140, 10.2750, ef), 137260.8, 2401);
-            testCollector.assertDistance(prepare.createAlgo(),
-                    currIdx.findClosest(50.1100, 10.7530, ef), currIdx.findClosest(49.6500, 10.3410, ef), 73530, 1462);
-
-            System.out.println("unterfranken " + prepare.createAlgo() + ": " + (testCollector.errors.size() - failed) + " failed");
-        }
-
-        testCollector.printSummary();
-    }
-
-    private static class ME extends MapEntry<AlgorithmPreparation, LocationIndex>
-    {
-        public ME( AlgorithmPreparation ap, LocationIndex idx )
-        {
-            super(ap, idx);
-        }
-    }
-
-    public static Collection<Entry<AlgorithmPreparation, LocationIndex>> createAlgos( Graph g,
-            LocationIndex idx, FlagEncoder encoder, boolean withCh, Weighting weighting, EncodingManager manager )
-    {
-        // List<Entry<AlgorithmPreparation, LocationIndex>> prepare = new ArrayList<Entry<AlgorithmPreparation, LocationIndex>>();
-        List<Entry<AlgorithmPreparation, LocationIndex>> prepare = new ArrayList<Entry<AlgorithmPreparation, LocationIndex>>();
-        prepare.add(new ME(createAlgoPrepare(g, "astar", encoder, weighting), idx));
-        // prepare.add(new ME(createAlgoPrepare(g, "dijkstraOneToMany", encoder, weighting), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "astarbi", encoder, weighting), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstraNative", encoder, weighting), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstrabi", encoder, weighting), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstra", encoder, weighting), idx));
-
-        if (withCh)
-        {
-            LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).levelGraphCreate());
-            PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(encoder, weighting).
-                    setGraph(graphCH);
-            prepareCH.doWork();
-            LocationIndex idxCH = new LocationIndexTreeSC(graphCH, new RAMDirectory()).prepareIndex();
-            prepare.add(new ME(prepareCH, idxCH));
-
-            // still one failing test regardless of the approx factor
-//            PrepareContractionHierarchies prepareCHAStar = new PrepareContractionHierarchies(encoder, weighting) {
-//
-//                @Override
-//                public RoutingAlgorithm createAlgo()
-//                {
-//                    return createAStar().setApproximation(true).setApproximationFactor(0.9);
-//                }
-//            }.setGraph(graphCH);            
-//            prepare.add(new ME(prepareCHAStar, idxCH));
-        }
-        return prepare;
-    }
-
-    void testIndex()
-    {
-        TestAlgoCollector testCollector = new TestAlgoCollector("testIndex");
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.080539, 10.125854, 63.35);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.081146, 10.124496, 0.0);
-        testCollector.queryIndex(unterfrankenGraph, idx, 49.68243, 9.933271, 436.29);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.066495, 10.191836, 14.63);
-
-        testCollector.printSummary();
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
index e100a9b9ce..418caed170 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
@@ -27,10 +27,6 @@
  */
 public class ShortestWeighting implements Weighting
 {
-    public ShortestWeighting()
-    {
-    }
-
     @Override
     public double getMinWeight( double currDistToGoal )
     {
@@ -38,15 +34,9 @@ public double getMinWeight( double currDistToGoal )
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edge )
-    {
-        return edge.getDistance();
-    }
-
-    @Override
-    public double revertWeight( EdgeIteratorState edge, double weight )
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
     {
-        return weight;
+        return edgeState.getDistance();
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
new file mode 100644
index 0000000000..1eff527304
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/TarjansStronglyConnectedComponentsAlgorithm.java
@@ -0,0 +1,144 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.util.EdgeIterator;
+import gnu.trove.list.array.TIntArrayList;
+import gnu.trove.stack.array.TIntArrayStack;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Stack;
+
+/**
+ * Implementation of Tarjan's algorithm using an explicit stack.
+ * (The traditional recursive approach runs into stack overflow pretty quickly.)
+ *
+ * Used for finding strongly connected components to detect dead-ends.
+ *
+ * http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm
+ */
+public class TarjansStronglyConnectedComponentsAlgorithm {
+
+    private final GraphStorage g;
+    private final TIntArrayStack nodeStack;
+    private final GHBitSetImpl onStack;
+    private final int[] nodeIndex;
+    private final int[] nodeLowLink;
+    private final ArrayList<TIntArrayList> components = new ArrayList<TIntArrayList>();
+
+    private int index = 1;
+    private final EdgeFilter edgeFilter;
+
+    public TarjansStronglyConnectedComponentsAlgorithm(final GraphStorage g, final EdgeFilter edgeFilter) {
+        this.g = g;
+        this.nodeStack = new TIntArrayStack();
+        this.onStack = new GHBitSetImpl(g.getNodes());
+        this.nodeIndex = new int[g.getNodes()];
+        this.nodeLowLink = new int[g.getNodes()];
+        this.edgeFilter = edgeFilter;
+    }
+
+    /**
+     * Find and return list of all strongly connected components in g.
+     */
+    public List<TIntArrayList> findComponents() {
+
+        int nodes = g.getNodes();
+        for (int start = 0; start < nodes; start++) {
+            if (nodeIndex[start] == 0 && !g.isNodeRemoved(start)) {
+                strongConnect(start);
+            }
+        }
+
+        return components;
+    }
+
+    // Find all components reachable from firstNode, add them to 'components'
+    private void strongConnect(int firstNode) {
+        final Stack<TarjanState> stateStack = new Stack<TarjanState>();
+        stateStack.push(TarjanState.startState(firstNode));
+
+        // nextState label is equivalent to the function entry point in the recursive Tarjan's algorithm.
+        nextState:
+
+        while (!stateStack.empty()) {
+            TarjanState state = stateStack.pop();
+            final int start = state.start;
+            final EdgeIterator iter;
+
+            if (state.isStart()) {
+                // We're traversing a new node 'start'.  Set the depth index for this node to the smallest unused index.
+                nodeIndex[start] = index;
+                nodeLowLink[start] = index;
+                index ++;
+                nodeStack.push(start);
+                onStack.set(start);
+
+                iter = g.createEdgeExplorer(edgeFilter).setBaseNode(start);
+
+            } else { // if (state.isResume()) {
+
+                // We're resuming iteration over the next child of 'start', set lowLink as appropriate.
+                iter = state.iter;
+
+                int prevConnectedId = iter.getAdjNode();
+                nodeLowLink[start] = Math.min(nodeLowLink[start], nodeLowLink[prevConnectedId]);
+            }
+
+            // Each element (excluding the first) in the current component should be able to find
+            // a successor with a lower nodeLowLink.
+            while (iter.next())
+            {
+                int connectedId = iter.getAdjNode();
+                if (nodeIndex[connectedId] == 0) {
+                    // Push resume and start states onto state stack to continue our DFS through the graph after the jump.
+                    // Ideally we'd just call strongConnectIterative(connectedId);
+                    stateStack.push(TarjanState.resumeState(start, iter));
+                    stateStack.push(TarjanState.startState(connectedId));
+                    continue nextState;
+                } else if (onStack.contains(connectedId)) {
+                    nodeLowLink[start] = Math.min(nodeLowLink[start], nodeIndex[connectedId]);
+                }
+            }
+
+            // If nodeLowLink == nodeIndex, then we are the first element in a component.
+            // Add all nodes higher up on nodeStack to this component.
+            if (nodeIndex[start] == nodeLowLink[start]) {
+                TIntArrayList component = new TIntArrayList();
+                int node;
+                while ((node = nodeStack.pop()) != start) {
+                    component.add(node);
+                    onStack.clear(node);
+                }
+                component.add(start);
+                onStack.clear(start);
+
+                components.add(component);
+            }
+        }
+    }
+
+    // Internal stack state of algorithm, used to avoid recursive function calls and hitting stack overflow exceptions.
+    // State is either 'start' for new nodes or 'resume' for partially traversed nodes.
+    private static class TarjanState {
+        final int start;
+        final EdgeIterator iter;
+
+        // Iterator only present in 'resume' state.
+        boolean isStart() { return iter == null; }
+
+        private TarjanState(final int start, final EdgeIterator iter) {
+            this.start = start;
+            this.iter = iter;
+        }
+
+        public static TarjanState startState(int start) {
+            return new TarjanState(start, null);
+        }
+
+        public static TarjanState resumeState(int start, EdgeIterator iter) {
+            return new TarjanState(start, iter);
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index cf29bc9a1c..66d437d1ac 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -17,17 +17,17 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.GHResponse;
+import com.graphhopper.routing.*;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Locale;
 
 /**
  * @author Peter Karich
@@ -35,47 +35,70 @@
 public class TestAlgoCollector
 {
     private final String name;
-    private final DistanceCalc distCalc = new DistanceCalcEarth();
-    public List<String> errors = new ArrayList<String>();
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private final TranslationMap trMap = new TranslationMap().doImport();
+    public final List<String> errors = new ArrayList<String>();
 
     public TestAlgoCollector( String name )
     {
         this.name = name;
     }
 
-    public TestAlgoCollector assertDistance( RoutingAlgorithm algo,
-            QueryResult from, QueryResult to, double distance, int pointCount )
+    public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryResult> queryList,
+            OneRun oneRun )
     {
-        Path path = algo.calcPath(from, to);
-        if (!path.isFound())
+        List<Path> viaPaths = new ArrayList<Path>();
+        QueryGraph queryGraph = new QueryGraph(algoEntry.getQueryGraph());
+        queryGraph.lookup(queryList);
+        AlgorithmOptions opts = algoEntry.opts;
+        FlagEncoder encoder = opts.getFlagEncoder();
+        if (encoder.supports(TurnWeighting.class))
+            algoEntry.setAlgorithmOptions(AlgorithmOptions.start(opts).weighting(new TurnWeighting(opts.getWeighting(), opts.getFlagEncoder(), (TurnCostExtension) queryGraph.getExtension())).build());
+
+        for (int i = 0; i < queryList.size() - 1; i++)
+        {
+            Path path = algoEntry.createAlgo(queryGraph).
+                    calcPath(queryList.get(i).getClosestNode(), queryList.get(i + 1).getClosestNode());
+            // System.out.println(path.calcInstructions().createGPX("temp", 0, "GMT"));
+            viaPaths.add(path);
+        }
+
+        PathMerger pathMerger = new PathMerger().
+                setCalcPoints(true).
+                setSimplifyResponse(false).
+                setEnableInstructions(true);
+        GHResponse rsp = new GHResponse();
+        pathMerger.doWork(rsp, viaPaths, trMap.getWithFallBack(Locale.US));
+
+        if (rsp.hasErrors())
         {
-            errors.add(algo + " returns no path! expected distance: " + distance
-                    + ", expected locations: " + pointCount + ". from:" + from + ", to:" + to);
+            errors.add(algoEntry + " response contains errors. Expected distance: " + rsp.getDistance()
+                    + ", expected points: " + oneRun + ". " + queryList + ", errors:" + rsp.getErrors());
             return this;
         }
 
-        PointList pointList = path.calcPoints();
+        PointList pointList = rsp.getPoints();
         double tmpDist = pointList.calcDistance(distCalc);
-        if (Math.abs(path.getDistance() - tmpDist) > 5)
+        if (Math.abs(rsp.getDistance() - tmpDist) > 2)
         {
-            errors.add(algo + " path.getDistance was  " + path.getDistance()
-                    + "\t pointList.calcDistance was " + tmpDist + "\t (expected points " + pointCount
-                    + ", expected distance " + distance + ") from:" + from + ", to:" + to);
+            errors.add(algoEntry + " path.getDistance was  " + rsp.getDistance()
+                    + "\t pointList.calcDistance was " + tmpDist + "\t (expected points " + oneRun.getLocs()
+                    + ", expected distance " + oneRun.getDistance() + ") " + queryList);
         }
 
-        if (Math.abs(path.getDistance() - distance) > 4)
+        if (Math.abs(rsp.getDistance() - oneRun.getDistance()) > 2)
         {
-            errors.add(algo + " returns path not matching the expected distance of " + distance
-                    + "\t Returned was " + path.getDistance() + "\t (expected points " + pointCount
-                    + ", was " + pointList.getSize() + ") from:" + from + ", to:" + to);
+            errors.add(algoEntry + " returns path not matching the expected distance of " + oneRun.getDistance()
+                    + "\t Returned was " + rsp.getDistance() + "\t (expected points " + oneRun.getLocs()
+                    + ", was " + pointList.getSize() + ") " + queryList);
         }
 
         // There are real world instances where A-B-C is identical to A-C (in meter precision).
-        if (Math.abs(pointList.getSize() - pointCount) > 4)
+        if (Math.abs(pointList.getSize() - oneRun.getLocs()) > 1)
         {
-            errors.add(algo + " returns path not matching the expected points of " + pointCount
-                    + "\t Returned was " + pointList.getSize() + "\t (expected distance " + distance
-                    + ", was " + path.getDistance() + ") from:" + from + ", to:" + to);
+            errors.add(algoEntry + " returns path not matching the expected points of " + oneRun.getLocs()
+                    + "\t Returned was " + pointList.getSize() + "\t (expected distance " + oneRun.getDistance()
+                    + ", was " + rsp.getDistance() + ") " + queryList);
         }
         return this;
     }
@@ -122,4 +145,137 @@ void printSummary()
             System.out.println("SUCCESS for " + name + "!");
         }
     }
+
+    public static class AlgoHelperEntry
+    {
+        private Graph queryGraph;
+        private final LocationIndex idx;
+        private AlgorithmOptions opts;
+
+        public AlgoHelperEntry( Graph g, AlgorithmOptions opts, LocationIndex idx )
+        {
+            this.queryGraph = g;
+            this.opts = opts;
+            this.idx = idx;
+        }
+
+        public Graph getQueryGraph()
+        {
+            return queryGraph;
+        }
+
+        public void setQueryGraph( Graph queryGraph )
+        {
+            this.queryGraph = queryGraph;
+        }
+
+        public void setAlgorithmOptions( AlgorithmOptions opts )
+        {
+            this.opts = opts;
+        }
+
+        public LocationIndex getIdx()
+        {
+            return idx;
+        }
+
+        public RoutingAlgorithm createAlgo( Graph qGraph )
+        {
+            return new RoutingAlgorithmFactorySimple().createAlgo(qGraph, opts);
+        }
+
+        @Override
+        public String toString()
+        {
+            return opts.getAlgorithm();
+        }
+    }
+
+    public static class OneRun
+    {
+        private final List<AssumptionPerPath> assumptions = new ArrayList<AssumptionPerPath>();
+
+        public OneRun()
+        {
+        }
+
+        public OneRun( double fromLat, double fromLon, double toLat, double toLon, double dist, int locs )
+        {
+            add(fromLat, fromLon, 0, 0);
+            add(toLat, toLon, dist, locs);
+        }
+
+        public OneRun add( double lat, double lon, double dist, int locs )
+        {
+            assumptions.add(new AssumptionPerPath(lat, lon, dist, locs));
+            return this;
+        }
+
+        public int getLocs()
+        {
+            int sum = 0;
+            for (AssumptionPerPath as : assumptions)
+            {
+                sum += as.locs;
+            }
+            return sum;
+        }
+
+        public void setLocs( int index, int locs )
+        {
+            assumptions.get(index).locs = locs;
+        }
+
+        public double getDistance()
+        {
+            double sum = 0;
+            for (AssumptionPerPath as : assumptions)
+            {
+                sum += as.distance;
+            }
+            return sum;
+        }
+
+        public void setDistance( int index, double dist )
+        {
+            assumptions.get(index).distance = dist;
+        }
+
+        public List<QueryResult> getList( LocationIndex idx, EdgeFilter edgeFilter )
+        {
+            List<QueryResult> qr = new ArrayList<QueryResult>();
+            for (AssumptionPerPath p : assumptions)
+            {
+                qr.add(idx.findClosest(p.lat, p.lon, edgeFilter));
+            }
+            return qr;
+        }
+
+        @Override
+        public String toString()
+        {
+            return assumptions.toString();
+        }
+    }
+
+    static class AssumptionPerPath
+    {
+        double lat, lon;
+        int locs;
+        double distance;
+
+        public AssumptionPerPath( double lat, double lon, double distance, int locs )
+        {
+            this.lat = lat;
+            this.lon = lon;
+            this.locs = locs;
+            this.distance = distance;
+        }
+
+        @Override
+        public String toString()
+        {
+            return lat + ", " + lon + ", locs:" + locs + ", dist:" + distance;
+        }
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
new file mode 100644
index 0000000000..20738fd6a9
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -0,0 +1,121 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import java.util.Arrays;
+
+/**
+ * Defines how the graph can be traversed while Dijkstra or similar RoutingAlgorithm is in progress.
+ * Different options define how precise turn restrictions and costs are taken into account, but
+ * still all are without via-way support. BTW: this would not be done at runtime, this would be a
+ * pre-processing step to avoid performance penalities.
+ * <p>
+ * @author Peter Karich
+ */
+public enum TraversalMode
+{
+    /**
+     * The simplest traversal mode but without turn restrictions or cost support.
+     */
+    NODE_BASED(false, 1, false),
+    /**
+     * Strictly not recommended as it could lead to 'route not found' for bidirectional algorithms.
+     * An edged-based traversal mode with basic turn restriction and cost support, including the
+     * most scenarios. But without certain turn restrictions and without u-turns. As fast as node
+     * based.
+     */
+    EDGE_BASED_1DIR(true, 1, false),
+    /**
+     * The bidirectional edged-based traversal mode with turn restriction and cost support. Without
+     * u-turn support. 2 times slower than node based.
+     */
+    EDGE_BASED_2DIR(true, 2, false),
+    /**
+     * Not recommended as it leads to strange routes that outsmart the turn costs. The most feature
+     * rich edged-based traversal mode with turn restriction and cost support, including u-turns. 4
+     * times slower than node based.
+     */
+    EDGE_BASED_2DIR_UTURN(true, 2, true);
+
+    private final boolean edgeBased;
+    private final int noOfStates;
+    private final boolean uTurnSupport;
+
+    TraversalMode( boolean edgeBased, int noOfStates, boolean uTurnSupport )
+    {
+        this.edgeBased = edgeBased;
+        this.noOfStates = noOfStates;
+        this.uTurnSupport = uTurnSupport;
+
+        if (noOfStates != 1 && noOfStates != 2)
+            throw new IllegalArgumentException("Currently only 1 or 2 states allowed");
+    }
+
+    /**
+     * Returns the identifier to access the map of the shortest path tree according to the traversal
+     * mode. E.g. returning the adjacent node id in node-based behavior whilst returning the edge id
+     * in edge-based behavior
+     * <p>
+     * @param iterState the current {@link EdgeIteratorState}
+     * @param reverse <code>true</code>, if traversal in backward direction. Will be true only for
+     * backward searches in bidirectional algorithms.
+     * @return the identifier to access the shortest path tree
+     */
+    public final int createTraversalId( EdgeIteratorState iterState, boolean reverse )
+    {
+        if (edgeBased)
+        {
+            if (noOfStates == 1)
+                return iterState.getEdge();
+
+            return GHUtility.createEdgeKey(iterState.getAdjNode(), iterState.getBaseNode(), iterState.getEdge(), reverse);
+        }
+
+        return iterState.getAdjNode();
+    }
+
+    public int getNoOfStates()
+    {
+        return noOfStates;
+    }
+
+    public boolean isEdgeBased()
+    {
+        return edgeBased;
+    }
+
+    public final boolean hasUTurnSupport()
+    {
+        return uTurnSupport;
+    }
+
+    public static TraversalMode fromString( String name )
+    {
+        try
+        {
+            return valueOf(name.toUpperCase());
+        } catch (Exception ex)
+        {
+            throw new IllegalArgumentException("TraversalMode " + name + " not supported. "
+                    + "Supported are: " + Arrays.asList(TraversalMode.values()));
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
index 8edb992b7a..ca8ce6cb7c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
@@ -17,54 +17,56 @@
  */
 package com.graphhopper.routing.util;
 
-
 /**
  * Encodes and decodes a turn restriction and turn costs within a integer flag
  * <p>
- * @author karl.huebner
+ * @author Karl Hübner
  */
 public interface TurnCostEncoder
 {
     /**
-     * @return true, if, and only if it is encoded in flag 
+     * @return true, if the turn restriction is encoded in the specified flags
+     */
+    boolean isTurnRestricted( long flags );
+
+    /**
+     * @return the costs encoded in the specified flag, if restricted it will be
+     * Double.POSITIVE_INFINITY
      */
-    boolean isTurnRestricted( long flag );
+    double getTurnCost( long flags );
 
     /**
-     * @return the costs in seconds encoded in flag 
+     * @param restricted true if restricted turn, equivalent to specifying of costs
+     * Double.POSITIVE_INFINITY
+     * @param costs the turn costs, specify 0 or Double.POSITIVE_INFINITY if restricted == true.
+     * Only used if restricted == false.
+     * @return the encoded flags
      */
-    int getTurnCosts( long flag );
-    
-    long getTurnFlags( boolean restriction, int costs );
+    long getTurnFlags( boolean restricted, double costs );
 
     /**
-     * whether turn costs nor turn restrictions will be encoded by this
-     * encoder, should be used for pedestrians  
+     * whether turn costs nor turn restrictions will be encoded by this encoder, should be used for
+     * pedestrians
      */
     static class NoTurnCostsEncoder implements TurnCostEncoder
     {
 
         @Override
-        public boolean isTurnRestricted( long flag )
+        public boolean isTurnRestricted( long flags )
         {
             return false;
         }
 
         @Override
-        public int getTurnCosts( long flag )
+        public double getTurnCost( long flags )
         {
             return 0;
         }
 
         @Override
-        public long getTurnFlags( boolean restriction, int costs )
+        public long getTurnFlags( boolean restriction, double costs )
         {
             return 0;
         }
-
     }
-
-    
-
-
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
new file mode 100644
index 0000000000..bde1c79da6
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
@@ -0,0 +1,104 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * Provides methods to retrieve turn costs for a specific turn.
+ * <p>
+ * @author Karl Hübner
+ * @author Peter Karich
+ */
+public class TurnWeighting implements Weighting
+{
+    /**
+     * Encoder, which decodes the turn flags
+     */
+    private final TurnCostEncoder turnCostEncoder;
+    private final TurnCostExtension turnCostExt;
+    private final Weighting superWeighting;
+    private double defaultUTurnCost = 40;
+
+    /**
+     * @param turnCostExt the turn cost storage to be used
+     */
+    public TurnWeighting( Weighting superWeighting, TurnCostEncoder encoder, TurnCostExtension turnCostExt )
+    {
+        this.turnCostEncoder = encoder;
+        this.superWeighting = superWeighting;
+        this.turnCostExt = turnCostExt;
+        if (encoder == null)
+            throw new IllegalArgumentException("No encoder set to calculate turn weight");
+        if (turnCostExt == null)
+            throw new RuntimeException("No storage set to calculate turn weight");
+    }
+
+    /**
+     * Set the default cost for an u-turn in seconds. Default is 40s. Should be that high to avoid
+     * 'tricking' other turn costs or restrictions.
+     */
+    public TurnWeighting setDefaultUTurnCost( double costInSeconds )
+    {
+        this.defaultUTurnCost = costInSeconds;
+        return this;
+    }
+
+    @Override
+    public double getMinWeight( double distance )
+    {
+        return superWeighting.getMinWeight(distance);
+    }
+
+    @Override
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+    {
+        double weight = superWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+        if (prevOrNextEdgeId == EdgeIterator.NO_EDGE)
+            return weight;
+
+        int edgeId = edgeState.getEdge();
+        double turnCosts;
+        if (reverse)
+            turnCosts = calcTurnWeight(edgeId, edgeState.getBaseNode(), prevOrNextEdgeId);
+        else
+            turnCosts = calcTurnWeight(prevOrNextEdgeId, edgeState.getBaseNode(), edgeId);
+
+        if (turnCosts == 0 && edgeId == prevOrNextEdgeId)
+            return weight + defaultUTurnCost;
+
+        return weight + turnCosts;
+    }
+
+    public double calcTurnWeight( int edgeFrom, int nodeVia, int edgeTo )
+    {
+        long turnFlags = turnCostExt.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+        if (turnCostEncoder.isTurnRestricted(turnFlags))
+            return Double.POSITIVE_INFINITY;
+
+        return turnCostEncoder.getTurnCost(turnFlags);
+    }
+
+    @Override
+    public String toString()
+    {
+        return "TURN|" + superWeighting.toString();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
new file mode 100644
index 0000000000..f471be0d07
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
@@ -0,0 +1,22 @@
+package com.graphhopper.routing.util;
+
+/**
+ * Specifies a weight approximation between an node and the goalNode according to the specified weighting.
+ * <p/>
+ * @author jansoe
+ */
+public interface WeightApproximator
+{
+
+    /**
+     * @return minimal weight fromNode to the goalNode
+     */
+    double approximate(int fromNode);
+
+    void setGoalNode(int to);
+
+    /**
+     * makes a deep copy of itself
+     */
+    WeightApproximator duplicate();
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/Weighting.java b/core/src/main/java/com/graphhopper/routing/util/Weighting.java
index 1dae8cbe6b..412666bf54 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Weighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Weighting.java
@@ -34,12 +34,13 @@
     double getMinWeight( double distance );
 
     /**
-     * @return the calculated weight with the specified velocity
+     * @param edgeState the edge for which the weight should be calculated
+     * @param reverse if the specified edge is specified in reverse direction e.g. from the reverse
+     * case of a bidirectional search.
+     * @param prevOrNextEdgeId if reverse is false this has to be the previous edgeId, if true it
+     * has to be the next edgeId in the direction from start to end.
+     * @return the calculated weight with the specified velocity has to be in the range of 0 and
+     * +Infinity. Make sure your method does not return NaN which can e.g. occur for 0/0.
      */
-    double calcWeight( EdgeIteratorState edge );
-
-    /**
-     * @return distance from specified weight
-     */
-    double revertWeight( EdgeIteratorState edge, double weight );
+    double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId );
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigLongEntry.java b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
similarity index 58%
rename from core/src/main/java/com/graphhopper/util/shapes/CoordTrigLongEntry.java
rename to core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
index f3cf56d9bf..b69f61d8f7 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigLongEntry.java
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightingMap.java
@@ -15,41 +15,47 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util.shapes;
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.PMap;
 
 /**
  *
  * @author Peter Karich
  */
-public class CoordTrigLongEntry extends CoordTrig<Long>
+public class WeightingMap extends PMap
 {
-    private long v;
-
-    public CoordTrigLongEntry()
+    public WeightingMap()
     {
     }
 
-    public CoordTrigLongEntry( long o, double lat, double lon )
+    /**
+     * Convenient constructor if only one parameter is provided
+     * <p>
+     * @param weighting
+     */
+    public WeightingMap( String weighting )
     {
-        super(lat, lon);
-        this.v = o;
+        super(5);
+        setWeighting(weighting);
     }
 
     @Override
-    public void setValue( Long t )
+    public WeightingMap put( String key, Object str )
     {
-        v = t;
+        super.put(key, str);
+        return this;
     }
 
-    @Override
-    public Long getValue()
+    public WeightingMap setWeighting( String w )
     {
-        return v;
+        if (w != null)
+            super.put("weighting", w);
+        return this;
     }
 
-    @Override
-    public String toString()
+    public String getWeighting()
     {
-        return super.toString() + " value:" + v;
+        return super.get("weighting", "");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/search/Geocoding.java b/core/src/main/java/com/graphhopper/search/Geocoding.java
index e2a52f4335..06239cf252 100644
--- a/core/src/main/java/com/graphhopper/search/Geocoding.java
+++ b/core/src/main/java/com/graphhopper/search/Geocoding.java
@@ -30,5 +30,5 @@
     /**
      * Returns a list of matching points for the specified place query string.
      */
-    List<GHPlace> name2point( GHPlace... place );
+    List<GHPlace> names2places( GHPlace... place );
 }
diff --git a/core/src/main/java/com/graphhopper/search/NameIndex.java b/core/src/main/java/com/graphhopper/search/NameIndex.java
index f2888423af..71c10990cc 100644
--- a/core/src/main/java/com/graphhopper/search/NameIndex.java
+++ b/core/src/main/java/com/graphhopper/search/NameIndex.java
@@ -20,7 +20,8 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Storable;
-import java.io.UnsupportedEncodingException;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.Helper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -30,13 +31,13 @@
  */
 public class NameIndex implements Storable<NameIndex>
 {
-    private static Logger logger = LoggerFactory.getLogger(NameIndex.class);
-    private static final int START_POINTER = 1;
-    private int bytePointer = START_POINTER;
-    private DataAccess names;
+    private static final Logger logger = LoggerFactory.getLogger(NameIndex.class);
+    private static final long START_POINTER = 1;
+    private final DataAccess names;
+    private long bytePointer = START_POINTER;
     // minor optimization for the previous stored name
     private String lastName;
-    private int lastIndex;
+    private long lastIndex;
 
     public NameIndex( Directory dir )
     {
@@ -55,7 +56,7 @@ public boolean loadExisting()
     {
         if (names.loadExisting())
         {
-            bytePointer = names.getHeader(0);
+            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(1));
             return true;
         }
 
@@ -63,9 +64,9 @@ public boolean loadExisting()
     }
 
     /**
-     * @return the integer reference
+     * @return the byte pointer to the name
      */
-    public int put( String name )
+    public long put( String name )
     {
         if (name == null || name.isEmpty())
         {
@@ -76,8 +77,8 @@ public int put( String name )
             return lastIndex;
         }
         byte[] bytes = getBytes(name);
-        int oldPointer = bytePointer;
-        names.incCapacity(bytePointer + 1 + bytes.length);
+        long oldPointer = bytePointer;
+        names.ensureCapacity(bytePointer + 1 + bytes.length);
         byte[] sizeBytes = new byte[]
         {
             (byte) bytes.length
@@ -100,22 +101,16 @@ public int put( String name )
         byte[] bytes = null;
         for (int i = 0; i < 2; i++)
         {
-            try
+            bytes = name.getBytes(Helper.UTF_CS);
+            // we have to store the size of the array into *one* byte
+            if (bytes.length > 255)
             {
-                bytes = name.getBytes("UTF-8");
-                // we have to store the size of the array into *one* byte
-                if (bytes.length > 255)
-                {
-                    String newName = name.substring(0, 256 / 4);
-                    logger.info("Way name is too long: " + name + " truncated to " + newName);
-                    name = newName;
-                    continue;
-                }
-                break;
-            } catch (UnsupportedEncodingException ex)
-            {
-                throw new RuntimeException("Encoding not supported", ex);
+                String newName = name.substring(0, 256 / 4);
+                logger.info("Way name is too long: " + name + " truncated to " + newName);
+                name = newName;
+                continue;
             }
+            break;
         }
         if (bytes.length > 255)
         {
@@ -125,7 +120,7 @@ public int put( String name )
         return bytes;
     }
 
-    public String get( int pointer )
+    public String get( long pointer )
     {
         if (pointer < 0)
         {
@@ -140,19 +135,14 @@ public String get( int pointer )
         int size = sizeBytes[0] & 0xFF;
         byte[] bytes = new byte[size];
         names.getBytes(pointer + sizeBytes.length, bytes, size);
-        try
-        {
-            return new String(bytes, "UTF-8");
-        } catch (UnsupportedEncodingException ex)
-        {
-            throw new RuntimeException("Encoding not supported", ex);
-        }
+        return new String(bytes, Helper.UTF_CS);
     }
 
     @Override
     public void flush()
     {
-        names.setHeader(0, bytePointer);
+        names.setHeader(0, BitUtil.LITTLE.getIntLow(bytePointer));
+        names.setHeader(4, BitUtil.LITTLE.getIntHigh(bytePointer));
         names.flush();
     }
 
@@ -162,6 +152,12 @@ public void close()
         names.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return names.isClosed();
+    }
+
     public void setSegmentSize( int segments )
     {
         names.setSegmentSize(segments);
diff --git a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
index 4efd504c53..164da777d0 100644
--- a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
+++ b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
@@ -30,5 +30,5 @@
     /**
      * Tries to retrieve a locational string from the specified points (list of lat,lon).
      */
-    List<GHPlace> point2name( GHPlace... points );
+    List<GHPlace> places2names( GHPlace... points );
 }
diff --git a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
index 7f427b01cb..1839ce1f43 100644
--- a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
@@ -42,6 +42,7 @@
     protected transient int indexDivisor;
     protected final ByteOrder byteOrder;
     protected final BitUtil bitUtil;
+    protected transient boolean closed = false;
 
     public AbstractDataAccess( String name, String location, ByteOrder order )
     {
@@ -68,8 +69,15 @@ protected String getFullName()
     @Override
     public void close()
     {
+        closed = true;
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return closed;
+    }        
+
     @Override
     public void setHeader( int bytePos, int value )
     {
@@ -118,14 +126,19 @@ protected long readHeader( RandomAccessFile raFile ) throws IOException
         return bytes;
     }
 
-    @Override
-    public DataAccess copyTo( DataAccess da )
+    protected void copyHeader( DataAccess da )
     {
         for (int h = 0; h < header.length * 4; h += 4)
         {
             da.setHeader(h, getHeader(h));
         }
-        da.incCapacity(getCapacity());
+    }
+
+    @Override
+    public DataAccess copyTo( DataAccess da )
+    {
+        copyHeader(da);
+        da.ensureCapacity(getCapacity());
         long cap = getCapacity();
         // currently get/setBytes does not support copying more bytes then segmentSize
         int segSize = Math.min(da.getSegmentSize(), getSegmentSize());
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
similarity index 55%
rename from core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
rename to core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 6fba4e4b57..21fbf67926 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -1,87 +1,99 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.storage.index;
+package com.graphhopper.storage;
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.util.*;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterator;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
 
 /**
- * The LevelGraph has some edges disconnected (to be more efficient), but this happens before the
- * index is created! So we need to take care of this and also ignore the introduced shortcuts e.g.
- * for calculating closest edges.
- * <p/>
- * TODO avoid some of the tricks if we move a disconnected edge to the end of the edge-list (instead
- * of just disconnecting them). And then while accessing them break iteration if we encounter the
- * first of those disconnected edges (this should have the same speed). Therefor we also need to
- * change the EdgeFilter interface and add a stop(EdgeIterator) method or similar.
- * <p/>
  * @author Peter Karich
  */
-public class LocationIndexTreeSC extends LocationIndexTree
+class BaseGraph implements Graph
 {
-    private final static EdgeFilter NO_SHORTCUT = new EdgeFilter()
+    private final LevelGraph lg;
+
+    BaseGraph( LevelGraph lg )
     {
-        @Override
-        public boolean accept( EdgeIteratorState edgeIterState )
-        {
-            return !((EdgeSkipIterator) edgeIterState).isShortcut();
-        }
-    };
-    private LevelGraph lg;
+        this.lg = lg;
+    }
 
-    public LocationIndexTreeSC( LevelGraph g, Directory dir )
+    @Override
+    public Graph getBaseGraph()
     {
-        super(g, dir);
-        lg = g;
+        return this;
     }
 
     @Override
-    protected int pickBestNode( int nodeA, int nodeB )
+    public int getNodes()
     {
-        // return lower level nodes as those nodes are always connected to higher ones
-        // (high level nodes are potentially disconnected from lower ones in order to improve performance on Android)
-        if (lg.getLevel(nodeA) < lg.getLevel(nodeB))
-        {
-            return nodeA;
-        }
-        return nodeB;
+        return lg.getNodes();
+    }
+
+    @Override
+    public NodeAccess getNodeAccess()
+    {
+        return lg.getNodeAccess();
+    }
+
+    @Override
+    public BBox getBounds()
+    {
+        return lg.getBounds();
     }
 
     @Override
-    protected AllEdgesIterator getAllEdges()
+    public EdgeIteratorState edge( int a, int b )
+    {
+        return lg.edge(a, b);
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
+    {
+        return lg.edge(a, b, distance, bothDirections);
+    }
+
+    @Override
+    public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
+    {
+        if (lg.isShortcut(edgeId))
+            throw new IllegalStateException("Do not fetch shortcuts from BaseGraph use the LevelGraph instead");
+
+        return lg.getEdgeProps(edgeId, adjNode);
+    }
+
+    @Override
+    public AllEdgesIterator getAllEdges()
     {
         final AllEdgesSkipIterator tmpIter = lg.getAllEdges();
         return new AllEdgesIterator()
         {
             @Override
-            public EdgeIteratorState detach()
+            public int getCount()
             {
-                return tmpIter.detach();
-            }
-
-            @Override
-            public int getMaxId()
-            {
-                return tmpIter.getMaxId();
+                return tmpIter.getCount();
             }
 
             @Override
@@ -176,16 +188,62 @@ public EdgeIteratorState setAdditionalField( int value )
             }
 
             @Override
-            public void copyProperties( EdgeIteratorState edge )
+            public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
             {
-                tmpIter.copyProperties(edge);
-            }            
+                return tmpIter.copyPropertiesTo(edge);
+            }
+
+            @Override
+            public EdgeIteratorState detach( boolean reverse )
+            {
+                return tmpIter.detach(reverse);
+            }
         };
     }
 
     @Override
-    protected EdgeFilter getEdgeFilter()
+    public EdgeExplorer createEdgeExplorer( final EdgeFilter filter )
+    {
+        if (filter == EdgeFilter.ALL_EDGES)
+            return createEdgeExplorer();
+
+        return lg.createEdgeExplorer(new EdgeFilter()
+        {
+            @Override
+            public boolean accept( EdgeIteratorState edgeIterState )
+            {
+                if (((EdgeSkipIterator) edgeIterState).isShortcut())
+                    return false;
+
+                return filter.accept(edgeIterState);
+            }
+        });
+    }
+
+    private final static EdgeFilter NO_SHORTCUTS = new EdgeFilter()
+    {
+        @Override
+        public boolean accept( EdgeIteratorState edgeIterState )
+        {
+            return !((EdgeSkipIterator) edgeIterState).isShortcut();
+        }
+    };
+
+    @Override
+    public EdgeExplorer createEdgeExplorer()
+    {
+        return lg.createEdgeExplorer(NO_SHORTCUTS);
+    }
+
+    @Override
+    public Graph copyTo( Graph g )
+    {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    @Override
+    public GraphExtension getExtension()
     {
-        return NO_SHORTCUT;
+        return lg.getExtension();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index e42340bce9..a1d337c3d8 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -27,29 +27,35 @@
     /**
      * The DA object is hold entirely in-memory. Loading and flushing is a no-op. See RAMDataAccess.
      */
-    public static final DAType RAM = new DAType(MemRef.HEAP, false, false);
+    public static final DAType RAM = new DAType(MemRef.HEAP, false, false, true, false);
     /**
      * Optimized RAM DA type for integer access. The set and getBytes methods cannot be used.
      */
-    public static final DAType RAM_INT = new DAType(MemRef.HEAP, false, true);
+    public static final DAType RAM_INT = new DAType(MemRef.HEAP, false, true, true, false);
     /**
      * The DA object is hold entirely in-memory. It will read load disc and flush to it if they
      * equivalent methods are called. See RAMDataAccess.
      */
-    public static final DAType RAM_STORE = new DAType(MemRef.HEAP, true, false);
+    public static final DAType RAM_STORE = new DAType(MemRef.HEAP, true, false, true, false);
     /**
      * Optimized RAM_STORE DA type for integer access. The set and getBytes methods cannot be used.
      */
-    public static final DAType RAM_INT_STORE = new DAType(MemRef.HEAP, true, true);
+    public static final DAType RAM_INT_STORE = new DAType(MemRef.HEAP, true, true, true, false);
     /**
      * Memory mapped DA object. See MMapDataAccess. To make it read and write thread-safe you need
      * to use 'new DAType(MMAP, true)'
      */
-    public static final DAType MMAP = new DAType(MemRef.MMAP, true, false);
+    public static final DAType MMAP = new DAType(MemRef.MMAP, true, false, true, false);
+
+    /**
+     * Read-only memory mapped DA object. To avoid write access useful for reading on mobile or
+     * embedded data stores.
+     */
+    public static final DAType MMAP_RO = new DAType(MemRef.MMAP, true, false, false, false);
     /**
      * Experimental API. Do not use yet.
      */
-    public static final DAType UNSAFE_STORE = new DAType(MemRef.UNSAFE, true, false);
+    public static final DAType UNSAFE_STORE = new DAType(MemRef.UNSAFE, true, false, true, false);
 
     public enum MemRef
     {
@@ -60,29 +66,26 @@
     private final boolean storing;
     private final boolean integ;
     private final boolean synched;
+    private final boolean allowWrites;
 
     public DAType( DAType type, boolean synched )
     {
-        this(type.getMemRef(), type.isStoring(), type.isInteg(), synched);
+        this(type.getMemRef(), type.isStoring(), type.isInteg(), type.isAllowWrites(), synched);
         if (!synched)
             throw new IllegalStateException("constructor can only be used with synched=true");
         if (type.isSynched())
             throw new IllegalStateException("something went wrong as DataAccess object is already synched!?");
     }
 
-    public DAType( MemRef memRef, boolean storing, boolean integ, boolean synched )
+    public DAType( MemRef memRef, boolean storing, boolean integ, boolean allowWrites, boolean synched )
     {
         this.memRef = memRef;
         this.storing = storing;
         this.integ = integ;
+        this.allowWrites = allowWrites;
         this.synched = synched;
     }
 
-    public DAType( MemRef memRef, boolean store, boolean integ )
-    {
-        this(memRef, store, integ, false);
-    }
-
     /**
      * Memory mapped or purely in memory? default is HEAP
      */
@@ -91,6 +94,14 @@ MemRef getMemRef()
         return memRef;
     }
 
+    public boolean isAllowWrites()
+    {
+        return allowWrites;
+    }
+
+    /**
+     * @return true if data resides in the JVM heap.
+     */
     public boolean isInMemory()
     {
         return memRef == MemRef.HEAP;
@@ -147,6 +158,27 @@ else if (getMemRef() == MemRef.HEAP)
         return str;
     }
 
+    public static DAType fromString( String dataAccess )
+    {
+        dataAccess = dataAccess.toUpperCase();
+        DAType type;
+        if (dataAccess.contains("MMAP"))
+            type = DAType.MMAP;
+        else if (dataAccess.contains("UNSAFE"))
+            type = DAType.UNSAFE_STORE;
+        else
+        {
+            if (dataAccess.contains("RAM_STORE"))
+                type = DAType.RAM_STORE;
+            else
+                type = DAType.RAM;
+        }
+
+        if (dataAccess.contains("SYNC"))
+            type = new DAType(type, true);
+        return type;
+    }
+
     @Override
     public int hashCode()
     {
diff --git a/core/src/main/java/com/graphhopper/storage/DataAccess.java b/core/src/main/java/com/graphhopper/storage/DataAccess.java
index a24516e5c6..b22c593851 100644
--- a/core/src/main/java/com/graphhopper/storage/DataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/DataAccess.java
@@ -23,7 +23,7 @@
  * Directory.create. Current implementations are RAM and memory mapped access.
  * <p/>
  * Life cycle: (1) object creation, (2) configuration (e.g. segment size), (3) create or
- * loadExisting, (4) usage, (5) close
+ * loadExisting, (4) usage and calling ensureCapacity if necessary, (5) close
  * <p/>
  * @author Peter Karich
  */
@@ -43,15 +43,25 @@
     void rename( String newName );
 
     /**
-     * Set 4 bytes at position 'index' to the specified value
+     * Set 4 bytes at position 'bytePos' to the specified value
      */
     void setInt( long bytePos, int value );
 
     /**
-     * Get 4 bytes from position 'index'
+     * Get 4 bytes from position 'bytePos'
      */
     int getInt( long bytePos );
 
+    /**
+     * Set 2 bytes at position 'index' to the specified value
+     */
+    void setShort( long bytePos, short value );
+
+    /**
+     * Get 2 bytes from position 'index'
+     */
+    short getShort( long bytePos );
+
     /**
      * Set bytes from position 'index' to the specified values
      */
@@ -76,7 +86,7 @@
 
     /**
      * The first time you use a DataAccess object after configuring it you need to call this. After
-     * that first call you have to use incCapacity to ensure that enough space is reserved.
+     * that first call you have to use ensureCapacity to ensure that enough space is reserved.
      */
     @Override
     DataAccess create( long bytes );
@@ -88,7 +98,7 @@
      * @see #create(long)
      * @return true if size was increased
      */
-    boolean incCapacity( long bytes );
+    boolean ensureCapacity(long bytes);
 
     /**
      * Reduces the allocate space to the specified bytes. Warning: it'll free the space even if it
@@ -117,5 +127,8 @@
      */
     int getSegments();
 
+    /**
+     * @return the data access type of this object.
+     */
     DAType getType();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/Directory.java b/core/src/main/java/com/graphhopper/storage/Directory.java
index 0443030a00..53cf760bd7 100644
--- a/core/src/main/java/com/graphhopper/storage/Directory.java
+++ b/core/src/main/java/com/graphhopper/storage/Directory.java
@@ -28,7 +28,6 @@
  */
 public interface Directory
 {
-
     /**
      * @return an id or location in the local filesystem.
      */
@@ -50,8 +49,7 @@
     /**
      * Renames the specified DataAccess object into one.
      */
-    DataAccess rename( DataAccess da, String newName );
-
+    // DataAccess rename( DataAccess da, String newName );
     /**
      * Removes the specified object from the directory.
      */
@@ -61,4 +59,9 @@
      * @return the default type of a newly created DataAccess object
      */
     DAType getDefaultType();
+
+    /**
+     * Removes all contained objects from the directory and releases its resources.
+     */
+    void clear();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/Edge.java b/core/src/main/java/com/graphhopper/storage/Edge.java
deleted file mode 100644
index a3abb12c69..0000000000
--- a/core/src/main/java/com/graphhopper/storage/Edge.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-/**
- * 'Edges' do not exist as separate objects in GraphHopper for the storage as this would be too
- * memory intensive. Look into EdgeIterator and Graph.getEdges(index) instead. But it is used as
- * base class in all algorithms except the native BidirectionalDijkstra.
- * <p/>
- * @see EdgeEntry
- * @author Peter Karich
- */
-public class Edge implements Comparable<Edge>
-{
-    public int edge;
-    public int endNode;
-    public double weight;
-
-    public Edge( int edgeId, int endNode, double distance )
-    {
-        this.edge = edgeId;
-        this.endNode = endNode;
-        this.weight = distance;
-    }
-
-    @Override
-    public int compareTo( Edge o )
-    {
-        return Double.compare(weight, o.weight);
-    }
-
-    @Override
-    public String toString()
-    {
-        return endNode + " (" + edge + ") distance is " + weight;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
index 8353c6f425..184a4ba9fe 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
@@ -22,19 +22,24 @@
  * <p/>
  * @author Peter Karich
  */
-public class EdgeEntry extends Edge implements Cloneable
+public class EdgeEntry implements Cloneable, Comparable<EdgeEntry>
 {
+    public int edge;
+    public int adjNode;
+    public double weight;
     public EdgeEntry parent;
 
-    public EdgeEntry( int edgeId, int endNode, double distance )
+    public EdgeEntry( int edgeId, int adjNode, double weight )
     {
-        super(edgeId, endNode, distance);
+        this.edge = edgeId;
+        this.adjNode = adjNode;
+        this.weight = weight;
     }
 
     @Override
     public EdgeEntry clone()
     {
-        return new EdgeEntry(edge, endNode, weight);
+        return new EdgeEntry(edge, adjNode, weight);
     }
 
     public EdgeEntry cloneFull()
@@ -50,4 +55,16 @@ public EdgeEntry cloneFull()
         }
         return de;
     }
+
+    @Override
+    public int compareTo( EdgeEntry o )
+    {
+        return Double.compare(weight, o.weight);
+    }
+
+    @Override
+    public String toString()
+    {
+        return adjNode + " (" + edge + ") weight: " + weight;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index be018d605f..68f12c3f56 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -52,7 +52,7 @@ public GHDirectory( String _location, DAType defaultType )
             throw new RuntimeException("file '" + dir + "' exists but is not a directory");
 
         // set default access to integer based
-        // improves performance on server side, 10% faster for queries, 20% faster for preparation
+        // improves performance on server side, 10% faster for queries and preparation
         if (this.defaultType.isInMemory())
         {
             if (isStoring())
@@ -120,8 +120,8 @@ public DataAccess find( String name, DAType type )
                     da = new RAMDataAccess(name, location, false, byteOrder);
             }
         } else if (type.isMMap())
-        {
-            da = new MMapDataAccess(name, location, byteOrder);
+        {            
+            da = new MMapDataAccess(name, location, byteOrder, type.isAllowWrites());
         } else
         {
             da = new UnsafeDataAccess(name, location, byteOrder);
@@ -135,28 +135,48 @@ public DataAccess find( String name, DAType type )
     }
 
     @Override
-    public DataAccess rename( DataAccess da, String newName )
+    public void clear()
     {
-        String oldName = da.getName();
-        da.rename(newName);
-        removeByName(oldName);
-        map.put(newName, da);
-        return da;
+        // If there is at least one MMap DA then do not apply the cleanHack 
+        // for every single mmap DA as this is very slow if lots of DataAccess objects were collected 
+        // => forceClean == false
+
+        MMapDataAccess mmapDA = null;
+        for (DataAccess da : map.values())
+        {
+            if (da instanceof MMapDataAccess)
+                mmapDA = (MMapDataAccess) da;
+
+            removeDA(da, da.getName(), false);
+        }
+        if (mmapDA != null)
+            Helper.cleanHack();
+        map.clear();
     }
 
     @Override
     public void remove( DataAccess da )
     {
-        removeByName(da.getName());
+        removeFromMap(da.getName());
+        removeDA(da, da.getName(), true);
     }
 
-    void removeByName( String name )
+    void removeDA( DataAccess da, String name, boolean forceClean )
+    {
+        if (da instanceof MMapDataAccess)
+            ((MMapDataAccess) da).close(forceClean);
+        else
+            da.close();
+
+        if (da.getType().isStoring())
+            Helper.removeDir(new File(location + name));
+    }
+
+    void removeFromMap( String name )
     {
         DataAccess da = map.remove(name);
         if (da == null)
             throw new IllegalStateException("Couldn't remove dataAccess object:" + name);
-        da.close();
-        Helper.removeDir(new File(location + name));
     }
 
     @Override
@@ -173,9 +193,7 @@ public boolean isStoring()
     protected void mkdirs()
     {
         if (isStoring())
-        {
             new File(location).mkdirs();
-        }
     }
 
     Collection<DataAccess> getAll()
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
new file mode 100644
index 0000000000..b075f3864f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -0,0 +1,150 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.util.Helper;
+
+/**
+ * A helper class for GraphHopperStorage for its node access.
+ * <p>
+ * @author Peter Karich
+ */
+class GHNodeAccess implements NodeAccess
+{
+    private final GraphHopperStorage that;
+    private final boolean elevation;
+
+    public GHNodeAccess( GraphHopperStorage that, boolean withElevation )
+    {
+        this.that = that;
+        this.elevation = withElevation;
+    }
+
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        that.ensureNodeIndex(nodeId);
+    }
+
+    @Override
+    public final void setNode( int nodeId, double lat, double lon )
+    {
+        setNode(nodeId, lat, lon, Double.NaN);
+    }
+
+    @Override
+    public final void setNode( int nodeId, double lat, double lon, double ele )
+    {
+        that.ensureNodeIndex(nodeId);
+        long tmp = (long) nodeId * that.nodeEntryBytes;
+        that.nodes.setInt(tmp + that.N_LAT, Helper.degreeToInt(lat));
+        that.nodes.setInt(tmp + that.N_LON, Helper.degreeToInt(lon));
+
+        if (is3D())
+        {
+            // meter precision is sufficient for now
+            that.nodes.setInt(tmp + that.N_ELE, Helper.eleToInt(ele));
+            that.bounds.update(lat, lon, ele);
+
+        } else
+        {
+            that.bounds.update(lat, lon);
+        }
+
+        // set the default value for the additional field of this node
+        if (that.extStorage.isRequireNodeField())
+            that.nodes.setInt(tmp + that.N_ADDITIONAL, that.extStorage.getDefaultNodeFieldValue());
+    }
+
+    @Override
+    public final double getLatitude( int nodeId )
+    {
+        return Helper.intToDegree(that.nodes.getInt((long) nodeId * that.nodeEntryBytes + that.N_LAT));
+    }
+
+    @Override
+    public final double getLongitude( int nodeId )
+    {
+        return Helper.intToDegree(that.nodes.getInt((long) nodeId * that.nodeEntryBytes + that.N_LON));
+    }
+
+    @Override
+    public final double getElevation( int nodeId )
+    {
+        if (!elevation)
+            throw new IllegalStateException("Cannot access elevation - 3D is not enabled");
+
+        return Helper.intToEle(that.nodes.getInt((long) nodeId * that.nodeEntryBytes + that.N_ELE));
+    }
+
+    @Override
+    public final double getEle( int nodeId )
+    {
+        return getElevation(nodeId);
+    }
+
+    @Override
+    public final double getLat( int nodeId )
+    {
+        return getLatitude(nodeId);
+    }
+
+    @Override
+    public final double getLon( int nodeId )
+    {
+        return getLongitude(nodeId);
+    }
+
+    @Override
+    public final void setAdditionalNodeField( int index, int additionalValue )
+    {
+        if (that.extStorage.isRequireNodeField() && that.N_ADDITIONAL >= 0)
+        {
+            that.ensureNodeIndex(index);
+            long tmp = (long) index * that.nodeEntryBytes;
+            that.nodes.setInt(tmp + that.N_ADDITIONAL, additionalValue);
+        } else
+        {
+            throw new AssertionError("This graph does not provide an additional node field");
+        }
+    }
+
+    @Override
+    public final int getAdditionalNodeField( int index )
+    {
+        if (that.extStorage.isRequireNodeField() && that.N_ADDITIONAL >= 0)
+            return that.nodes.getInt((long) index * that.nodeEntryBytes + that.N_ADDITIONAL);
+        else
+            throw new AssertionError("This graph does not provide an additional node field");
+    }
+
+    @Override
+    public final boolean is3D()
+    {
+        return elevation;
+    }
+
+    @Override
+    public int getDimension()
+    {
+        if (elevation)
+            return 3;
+        return 2;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index fa02f7a505..65e9c63b26 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -32,40 +32,20 @@
 public interface Graph
 {
     /**
-     * @return the number of created locations - via setNode() or edge()
-     */
-    int getNodes();
-
-    /**
-     * This method ensures that the node with the specified index exists and sets the lat+lon to the
-     * specified values. The index goes from 0 (inclusive) to nodes() (exclusive)
+     * @return a graph which behaves like an unprepared graph and e.g. the normal unidirectional
+     * Dijkstra or any graph traversal algorithm can be executed.
      */
-    void setNode( int node, double lat, double lon );
+    Graph getBaseGraph();
 
     /**
-     * @return the latitude at the specified node index
-     */
-    double getLatitude( int nodeId );
-
-    /**
-     * @return the longitude at the specified node index
-     */
-    double getLongitude( int nodeId );
-
-    /**
-     * @return the additional value at the specified node index
-     * @throws AssertionError if, and only if, the extendedStorage does not require an additional
-     * node field
+     * @return the number of created locations - via setNode() or edge()
      */
-    int getAdditionalNodeField( int nodeId );
+    int getNodes();
 
     /**
-     * Sets the additional value at the specified node index
-     * <p>
-     * @throws AssertionError if, and only if, the extendedStorage does not require an additional
-     * node field
+     * Creates a node explorer to access node properties.
      */
-    void setAdditionalNodeField( int nodeId, int additionalValue );
+    NodeAccess getNodeAccess();
 
     /**
      * Returns the implicit bounds of this graph calculated from the lat,lon input of setNode
@@ -93,7 +73,7 @@
      * @param adjNode is the node that will be returned via adjNode(). If adjNode is
      * Integer.MIN_VALUE then the edge with undefined values for adjNode and baseNode will be
      * returned.
-     * @return an edge iterator over one element where the method next() will always return false.
+     * @return an edge iterator state
      * @throws IllegalStateException if edgeId is not valid
      */
     EdgeIteratorState getEdgeProps( int edgeId, int adjNode );
@@ -126,4 +106,9 @@
      * @return the specified GraphStorage g
      */
     Graph copyTo( Graph g );
+
+    /**
+     * @return the graph extension like a TurnCostExtension
+     */
+    GraphExtension getExtension();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index e525c975a8..cfcbc63c83 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -31,6 +31,7 @@
     private boolean mmap;
     private boolean store;
     private boolean level;
+    private boolean elevation;
     private long byteCapacity = 100;
 
     public GraphBuilder( EncodingManager encodingManager )
@@ -43,7 +44,7 @@ public GraphBuilder( EncodingManager encodingManager )
      * <p/>
      * @see LevelGraph
      */
-    GraphBuilder setLevelGraph( boolean level )
+    public GraphBuilder setLevelGraph( boolean level )
     {
         this.level = level;
         return this;
@@ -73,6 +74,17 @@ public GraphBuilder setExpectedSize( byte cap )
         return this;
     }
 
+    public GraphBuilder set3D( boolean withElevation )
+    {
+        this.elevation = withElevation;
+        return this;
+    }
+
+    public boolean hasElevation()
+    {
+        return elevation;
+    }
+
     public LevelGraphStorage levelGraphBuild()
     {
         return (LevelGraphStorage) setLevelGraph(true).build();
@@ -91,24 +103,25 @@ public LevelGraphStorage levelGraphCreate()
      * Afterwards you'll need to call GraphStorage.create to have a useable object. Better use
      * create.
      */
-    GraphStorage build()
+    public GraphStorage build()
     {
         Directory dir;
         if (mmap)
-        {
             dir = new MMapDirectory(location);
-        } else
-        {
+        else
             dir = new RAMDirectory(location, store);
-        }
+
         GraphStorage graph;
         if (level)
+            graph = new LevelGraphStorage(dir, encodingManager, elevation);
+        else
         {
-            graph = new LevelGraphStorage(dir, encodingManager);
-        } else
-        {
-            graph = new GraphHopperStorage(dir, encodingManager);
+            if (encodingManager.needsTurnCostsSupport())
+                graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostExtension());
+            else
+                graph = new GraphHopperStorage(dir, encodingManager, elevation);
         }
+
         return graph;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/ExtendedStorage.java b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
similarity index 82%
rename from core/src/main/java/com/graphhopper/storage/ExtendedStorage.java
rename to core/src/main/java/com/graphhopper/storage/GraphExtension.java
index f3b9b6e818..380bf4ec82 100644
--- a/core/src/main/java/com/graphhopper/storage/ExtendedStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
@@ -21,9 +21,8 @@
  * If you need custom storages, like turn cost tables, or osmid tables for your graph you implement
  * this interface and put it in any graph storage you want.
  */
-public interface ExtendedStorage
+public interface GraphExtension extends Storable<GraphExtension>
 {
-
     /**
      * @return true, if and only if, if an additional field at the graphs node storage is required
      */
@@ -49,46 +48,21 @@
      */
     void init( GraphStorage graph );
 
-    /**
-     * creates all additional data storages
-     */
-    void create( long initSize );
-
-    /**
-     * loads from existing data storages
-     */
-    boolean loadExisting();
-
     /**
      * sets the segment size in all additional data storages
      */
     void setSegmentSize( int bytes );
 
-    /**
-     * flushes all additional data storages
-     */
-    void flush();
-
-    /**
-     * closes all additional data storages
-     */
-    void close();
-
-    /**
-     * returns the sum of all additional data storages capacity
-     */
-    long getCapacity();
-
     /**
      * creates a copy of this extended storage
      */
-    ExtendedStorage copyTo( ExtendedStorage extStorage );
+    GraphExtension copyTo( GraphExtension extStorage );
 
     /**
      * default implementation defines no additional fields or any logic. there's like nothing , like
      * the default behavior.
      */
-    public class NoExtendedStorage implements ExtendedStorage
+    public class NoExtendedStorage implements GraphExtension
     {
 
         @Override
@@ -122,9 +96,10 @@ public void init( GraphStorage grap )
         }
 
         @Override
-        public void create( long initSize )
+        public GraphExtension create( long byteCount )
         {
             // noop
+            return this;
         }
 
         @Override
@@ -159,11 +134,22 @@ public long getCapacity()
         }
 
         @Override
-        public ExtendedStorage copyTo( ExtendedStorage extStorage )
+        public GraphExtension copyTo( GraphExtension extStorage )
         {
             // noop
             return extStorage;
         }
 
+        @Override
+        public String toString()
+        {
+            return "NoExt";
+        }
+
+        @Override
+        public boolean isClosed()
+        {
+            return false;
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index cc95d55efc..b3f749525f 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -24,10 +24,18 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.search.NameIndex;
-import com.graphhopper.util.*;
-import static com.graphhopper.util.Helper.nf;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
 
+import static com.graphhopper.util.Helper.nf;
+import java.io.UnsupportedEncodingException;
+
 /**
  * The main implementation which handles nodes and edges file format. It can be used with different
  * Directory implementations like RAMDirectory for fast access or via MMapDirectory for
@@ -50,56 +58,61 @@
     // Road networks typically do not have nodes with plenty of edges!
     private static final int MAX_EDGES = 1000;
     // distance of around +-1000 000 meter are ok
-    private static final double INT_DIST_FACTOR = 1000f;
+    private static final double INT_DIST_FACTOR = 1000d;
     private final Directory dir;
-    // edge memory layout: nodeA,nodeB,linkA,linkB,dist,flags,geometryRef,streetNameRef
-    protected final int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS, E_GEO, E_NAME, E_ADDITIONAL;
+    // edge memory layout:
+    protected int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS, E_GEO, E_NAME, E_ADDITIONAL;
+    /**
+     * Specifies how many entries (integers) are used per edge.
+     */
     protected int edgeEntryBytes;
-    protected DataAccess edges;
+    protected final DataAccess edges;
     /**
-     * Specified how many entries (integers) are used per edge. interval [0,n)
+     * interval [0,n)
      */
-    protected int edgeCount = 0;
-    // node memory layout: edgeRef,lat,lon
-    protected final int N_EDGE_REF, N_LAT, N_LON, N_ADDITIONAL;
+    protected int edgeCount;
+    // node memory layout:
+    protected int N_EDGE_REF, N_LAT, N_LON, N_ELE, N_ADDITIONAL;
     /**
-     * specified how many entries (integers) are used per node
+     * Specifies how many entries (integers) are used per node
      */
     protected int nodeEntryBytes;
-    protected DataAccess nodes;
+    protected final DataAccess nodes;
     /**
      * interval [0,n)
      */
     private int nodeCount;
-    private BBox bounds;
+    final BBox bounds;
     // remove markers are not yet persistent!
     private GHBitSet removedNodes;
-    private int edgeEntryIndex = -4, nodeEntryIndex = -4;
+    private int edgeEntryIndex, nodeEntryIndex;
     // length | nodeA | nextNode | ... | nodeB
-    // as we use integer index in 'egdes' area => 'geometry' area is limited to 2GB
+    // as we use integer index in 'egdes' area => 'geometry' area is limited to 2GB (currently ~311M for world wide)
     private final DataAccess wayGeometry;
-    // 0 stands for no separate geoRef
-    private int maxGeoRef = 4;
+    private int maxGeoRef;
     private boolean initialized = false;
     private EncodingManager encodingManager;
     private final NameIndex nameIndex;
-    protected final EdgeFilter allEdgesFilter;
     private final StorableProperties properties;
     private final BitUtil bitUtil;
-    private ExtendedStorage extStorage;
+    private boolean flagsSizeIsLong;
+    final GraphExtension extStorage;
+    private final NodeAccess nodeAccess;
 
-    public GraphHopperStorage( Directory dir, EncodingManager encodingManager )
+    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation )
     {
-        this(dir, encodingManager, new ExtendedStorage.NoExtendedStorage());
+        this(dir, encodingManager, withElevation, new GraphExtension.NoExtendedStorage());
     }
 
-    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, ExtendedStorage extendedStorage )
+    public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation,
+            GraphExtension extendedStorage )
     {
-        // here encoding manager can be null e.g. if we want to load existing
-        // graph
+        if (encodingManager == null)
+            throw new IllegalArgumentException("EncodingManager cannot be null in GraphHopperStorage since 0.4. "
+                    + "If you need to parse EncodingManager configuration from existing graph use EncodingManager.create");
+
         this.encodingManager = encodingManager;
         this.extStorage = extendedStorage;
-        allEdgesFilter = EdgeFilter.ALL_EDGES;
         this.dir = dir;
         this.bitUtil = BitUtil.get(dir.getByteOrder());
         this.nodes = dir.find("nodes");
@@ -107,62 +120,42 @@ public GraphHopperStorage( Directory dir, EncodingManager encodingManager, Exten
         this.wayGeometry = dir.find("geometry");
         this.nameIndex = new NameIndex(dir);
         this.properties = new StorableProperties(dir);
-        this.bounds = BBox.INVERSE.clone();
-        E_NODEA = nextEdgeEntryIndex();
-        E_NODEB = nextEdgeEntryIndex();
-        E_LINKA = nextEdgeEntryIndex();
-        E_LINKB = nextEdgeEntryIndex();
-        E_DIST = nextEdgeEntryIndex();
-        E_FLAGS = nextEdgeEntryIndex();
-        E_GEO = nextEdgeEntryIndex();
-        E_NAME = nextEdgeEntryIndex();
-        if (extStorage.isRequireEdgeField())
-        {
-            E_ADDITIONAL = nextEdgeEntryIndex();
-        } else
-        {
-            E_ADDITIONAL = -1;
-        }
-
-        N_EDGE_REF = nextNodeEntryIndex();
-        N_LAT = nextNodeEntryIndex();
-        N_LON = nextNodeEntryIndex();
-        if (extStorage.isRequireNodeField())
-        {
-            N_ADDITIONAL = nextNodeEntryIndex();
-        } else
-        {
-            N_ADDITIONAL = -1;
-        }
-        initNodeAndEdgeEntrySize();
+        this.bounds = BBox.createInverse(withElevation);
+        this.nodeAccess = new GHNodeAccess(this, withElevation);
         extendedStorage.init(this);
     }
 
+    @Override
+    public Graph getBaseGraph()
+    {
+        return this;
+    }
+
     void checkInit()
     {
         if (initialized)
-        {
             throw new IllegalStateException("You cannot configure this GraphStorage "
                     + "after calling create or loadExisting. Calling one of the methods twice is also not allowed.");
-        }
     }
 
-    protected final int nextEdgeEntryIndex()
+    protected final int nextEdgeEntryIndex( int sizeInBytes )
     {
-        edgeEntryIndex += 4;
-        return edgeEntryIndex;
+        int tmp = edgeEntryIndex;
+        edgeEntryIndex += sizeInBytes;
+        return tmp;
     }
 
-    protected final int nextNodeEntryIndex()
+    protected final int nextNodeEntryIndex( int sizeInBytes )
     {
-        nodeEntryIndex += 4;
-        return nodeEntryIndex;
+        int tmp = nodeEntryIndex;
+        nodeEntryIndex += sizeInBytes;
+        return tmp;
     }
 
     protected final void initNodeAndEdgeEntrySize()
     {
-        nodeEntryBytes = nodeEntryIndex + 4;
-        edgeEntryBytes = edgeEntryIndex + 4;
+        nodeEntryBytes = nodeEntryIndex;
+        edgeEntryBytes = edgeEntryIndex;
     }
 
     /**
@@ -197,16 +190,23 @@ public GraphStorage create( long byteCount )
 
         long initSize = Math.max(byteCount, 100);
         nodes.create(initSize);
-        initNodeRefs(0, nodes.getCapacity());
-
         edges.create(initSize);
         wayGeometry.create(initSize);
         nameIndex.create(1000);
         properties.create(100);
-        properties.put("osmreader.acceptWay", encodingManager.getEncoderList());
-        properties.putCurrentVersions();
         extStorage.create(initSize);
-        initialized = true;
+
+        properties.put("graph.bytesForFlags", encodingManager.getBytesForFlags());
+        properties.put("graph.flagEncoders", encodingManager.toDetailsString());
+
+        properties.put("graph.byteOrder", dir.getByteOrder());
+        properties.put("graph.dimension", nodeAccess.getDimension());
+        properties.putCurrentVersions();
+        initStorage();
+        // 0 stands for no separate geoRef
+        maxGeoRef = 4;
+
+        initNodeRefs(0, nodes.getCapacity());
         return this;
     }
 
@@ -217,27 +217,9 @@ public int getNodes()
     }
 
     @Override
-    public double getLatitude( int index )
-    {
-        return Helper.intToDegree(nodes.getInt((long) index * nodeEntryBytes + N_LAT));
-    }
-
-    @Override
-    public double getLongitude( int index )
-    {
-        return Helper.intToDegree(nodes.getInt((long) index * nodeEntryBytes + N_LON));
-    }
-
-    @Override
-    public int getAdditionalNodeField( int index )
+    public NodeAccess getNodeAccess()
     {
-        if (extStorage.isRequireNodeField() && N_ADDITIONAL >= 0)
-        {
-            return nodes.getInt((long) index * nodeEntryBytes + N_ADDITIONAL);
-        } else
-        {
-            throw new AssertionError("This graph does not provide an additional node field");
-        }
+        return nodeAccess;
     }
 
     /**
@@ -277,70 +259,29 @@ public BBox getBounds()
         return bounds;
     }
 
-    @Override
-    public void setNode( int index, double lat, double lon )
-    {
-        ensureNodeIndex(index);
-        long tmp = (long) index * nodeEntryBytes;
-        nodes.setInt(tmp + N_LAT, Helper.degreeToInt(lat));
-        nodes.setInt(tmp + N_LON, Helper.degreeToInt(lon));
-        if (lat > bounds.maxLat)
-        {
-            bounds.maxLat = lat;
-        }
-        if (lat < bounds.minLat)
-        {
-            bounds.minLat = lat;
-        }
-        if (lon > bounds.maxLon)
-        {
-            bounds.maxLon = lon;
-        }
-        if (lon < bounds.minLon)
-        {
-            bounds.minLon = lon;
-        }
-
-        //set the default value for the additional field of this node
-        if (extStorage.isRequireNodeField())
-        {
-            nodes.setInt(tmp + N_ADDITIONAL, extStorage.getDefaultNodeFieldValue());
-        }
-    }
-
-    @Override
-    public void setAdditionalNodeField( int index, int additionalValue )
-    {
-        if (extStorage.isRequireNodeField() && N_ADDITIONAL >= 0)
-        {
-            ensureNodeIndex(index);
-            long tmp = (long) index * nodeEntryBytes;
-            nodes.setInt(tmp + N_ADDITIONAL, additionalValue);
-        } else
-        {
-            throw new AssertionError("This graph does not provide an additional node field");
-        }
-    }
-
+    /**
+     * Check if byte capacity of DataAcess nodes object is sufficient to include node index, else
+     * extend byte capacity
+     */
     final void ensureNodeIndex( int nodeIndex )
     {
         if (!initialized)
-        {
             throw new AssertionError("The graph has not yet been initialized.");
-        }
 
         if (nodeIndex < nodeCount)
             return;
 
         long oldNodes = nodeCount;
         nodeCount = nodeIndex + 1;
-        if (!nodes.incCapacity((long) nodeCount * nodeEntryBytes))
-            return;
+        boolean capacityIncreased = nodes.ensureCapacity((long) nodeCount * nodeEntryBytes);
+        if (capacityIncreased)
+        {
+            long newBytesCapacity = nodes.getCapacity();
+            initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);
+            if (removedNodes != null)
+                getRemovedNodes().ensureCapacity((int) (newBytesCapacity / nodeEntryBytes));
+        }
 
-        long newBytesCapacity = nodes.getCapacity();
-        initNodeRefs(oldNodes * nodeEntryBytes, newBytesCapacity);
-        if (removedNodes != null)
-            getRemovedNodes().ensureCapacity((int) (newBytesCapacity / nodeEntryBytes));
     }
 
     /**
@@ -363,12 +304,12 @@ private void initNodeRefs( long oldCapacity, long newCapacity )
 
     private void ensureEdgeIndex( int edgeIndex )
     {
-        edges.incCapacity(((long) edgeIndex + 1) * edgeEntryBytes);
+        edges.ensureCapacity(((long) edgeIndex + 1) * edgeEntryBytes);
     }
 
     private void ensureGeometry( long bytePos, int byteLength )
     {
-        wayGeometry.incCapacity(bytePos + byteLength);
+        wayGeometry.ensureCapacity(bytePos + byteLength);
     }
 
     @Override
@@ -377,6 +318,11 @@ public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirect
         return edge(a, b).setDistance(distance).setFlags(encodingManager.flagsDefault(true, bothDirection));
     }
 
+    /**
+     * Create edge between nodes a and b
+     * <p>
+     * @return EdgeIteratorState of newly created edge
+     */
     @Override
     public EdgeIteratorState edge( int a, int b )
     {
@@ -402,17 +348,17 @@ private int nextGeoRef( int arrayLength )
     }
 
     /**
-     * @return edgeIdPointer which is edgeId * edgeEntrySize
+     * Write new edge between nodes fromNodeId, and toNodeId both to nodes index and edges index
      */
     int internalEdgeAdd( int fromNodeId, int toNodeId )
     {
-        int newOrExistingEdge = nextEdge();
-        writeEdge(newOrExistingEdge, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        connectNewEdge(fromNodeId, newOrExistingEdge);
+        int newEdgeId = nextEdge();
+        writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
+        connectNewEdge(fromNodeId, newEdgeId);
         if (fromNodeId != toNodeId)
-            connectNewEdge(toNodeId, newOrExistingEdge);
+            connectNewEdge(toNodeId, newEdgeId);
 
-        return newOrExistingEdge;
+        return newEdgeId;
     }
 
     // for test only
@@ -421,6 +367,11 @@ void setEdgeCount( int cnt )
         edgeCount = cnt;
     }
 
+    /**
+     * Determine next free edgeId and ensure byte capacity to store edge
+     * <p>
+     * @return next free edgeId
+     */
     private int nextEdge()
     {
         int nextEdge = edgeCount;
@@ -556,13 +507,15 @@ public StorableProperties getProperties()
         protected long edgePointer = -edgeEntryBytes;
         private final long maxEdges = (long) edgeCount * edgeEntryBytes;
         private int nodeA;
+        private int nodeB;
+        private boolean reverse = false;
 
         public AllEdgeIterator()
         {
         }
 
         @Override
-        public int getMaxId()
+        public int getCount()
         {
             return edgeCount;
         }
@@ -574,6 +527,8 @@ public boolean next()
             {
                 edgePointer += edgeEntryBytes;
                 nodeA = edges.getInt(edgePointer + E_NODEA);
+                nodeB = edges.getInt(edgePointer + E_NODEB);
+                reverse = getBaseNode() > getAdjNode();
                 // some edges are deleted and have a negative node
             } while (nodeA == NO_NODE && edgePointer < maxEdges);
             return edgePointer < maxEdges;
@@ -588,7 +543,7 @@ public int getBaseNode()
         @Override
         public int getAdjNode()
         {
-            return edges.getInt(edgePointer + E_NODEB);
+            return nodeB;
         }
 
         @Override
@@ -607,7 +562,7 @@ public EdgeIteratorState setDistance( double dist )
         @Override
         public long getFlags()
         {
-            return edges.getInt(edgePointer + E_FLAGS);
+            return GraphHopperStorage.this.getFlags(edgePointer, reverse);
         }
 
         @Override
@@ -626,13 +581,14 @@ public EdgeIteratorState setAdditionalField( int value )
         @Override
         public EdgeIteratorState setFlags( long flags )
         {
-            throw new UnsupportedOperationException("Not supported yet.");
+            GraphHopperStorage.this.setFlags(edgePointer, reverse, flags);
+            return this;
         }
 
         @Override
-        public void copyProperties( EdgeIteratorState edge )
+        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
         {
-            throw new UnsupportedOperationException("Not supported yet.");
+            return GraphHopperStorage.this.copyProperties(this, edge);
         }
 
         @Override
@@ -644,14 +600,15 @@ public int getEdge()
         @Override
         public EdgeIteratorState setWayGeometry( PointList pillarNodes )
         {
-            GraphHopperStorage.this.setWayGeometry(pillarNodes, edgePointer, getBaseNode() > getAdjNode());
+            GraphHopperStorage.this.setWayGeometry(pillarNodes, edgePointer, reverse);
             return this;
         }
 
         @Override
         public PointList fetchWayGeometry( int type )
         {
-            return GraphHopperStorage.this.fetchWayGeometry(edgePointer, getBaseNode() > getAdjNode(), type, getBaseNode(), getAdjNode());
+            return GraphHopperStorage.this.fetchWayGeometry(edgePointer, reverse,
+                    type, getBaseNode(), getAdjNode());
         }
 
         @Override
@@ -664,19 +621,29 @@ public String getName()
         @Override
         public EdgeIteratorState setName( String name )
         {
-            int nameIndexRef = nameIndex.put(name);
-            edges.setInt(edgePointer + E_NAME, nameIndexRef);
+            long nameIndexRef = nameIndex.put(name);
+            if (nameIndexRef < 0)
+                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
             return this;
         }
 
         @Override
-        public EdgeIteratorState detach()
+        public EdgeIteratorState detach( boolean reverseArg )
         {
             if (edgePointer < 0)
                 throw new IllegalStateException("call next before detaching");
             AllEdgeIterator iter = new AllEdgeIterator();
-            iter.edgePointer = edgePointer;
             iter.nodeA = nodeA;
+            iter.nodeB = nodeB;
+            iter.edgePointer = edgePointer;
+            if (reverseArg)
+            {
+                iter.reverse = !this.reverse;
+                iter.nodeA = nodeB;
+                iter.nodeB = nodeA;
+            }
             return iter;
         }
 
@@ -706,13 +673,14 @@ public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
         if (adjNode == nodeB || adjNode == Integer.MIN_VALUE)
         {
             edge = createSingleEdge(edgeId, nodeA);
-            edge.node = nodeB;
+            edge.reverse = false;
+            edge.adjNode = nodeB;
             return edge;
         } else if (adjNode == nodeA)
         {
             edge = createSingleEdge(edgeId, nodeB);
-            edge.node = nodeA;
-            edge.switchFlags = true;
+            edge.adjNode = nodeA;
+            edge.reverse = true;
             return edge;
         }
         // if edgeId exists but adjacent nodes do not match
@@ -724,10 +692,38 @@ protected SingleEdge createSingleEdge( int edgeId, int nodeId )
         return new SingleEdge(edgeId, nodeId);
     }
 
-    protected class SingleEdge extends EdgeIterable
+    private long getFlags( long edgePointer, boolean reverse )
     {
-        protected boolean switchFlags;
+        int low = edges.getInt(edgePointer + E_FLAGS);
+        long res = low;
+        if (flagsSizeIsLong)
+        {
+            int high = edges.getInt(edgePointer + E_FLAGS + 4);
+            res = bitUtil.combineIntsToLong(low, high);
+        }
+        if (reverse)
+            return reverseFlags(edgePointer, res);
+        return res;
+    }
+
+    long reverseFlags( long edgePointer, long flags )
+    {
+        return encodingManager.reverseFlags(flags);
+    }
+
+    private void setFlags( long edgePointer, boolean reverse, long flags )
+    {
+        if (reverse)
+            flags = reverseFlags(edgePointer, flags);
+
+        edges.setInt(edgePointer + E_FLAGS, bitUtil.getIntLow(flags));
+
+        if (flagsSizeIsLong)
+            edges.setInt(edgePointer + E_FLAGS + 4, bitUtil.getIntHigh(flags));
+    }
 
+    protected class SingleEdge extends EdgeIterable
+    {
         public SingleEdge( int edgeId, int nodeId )
         {
             super(EdgeFilter.ALL_EDGES);
@@ -735,16 +731,6 @@ public SingleEdge( int edgeId, int nodeId )
             setEdgeId(edgeId);
             nextEdge = EdgeIterable.NO_EDGE;
         }
-
-        @Override
-        public long getFlags()
-        {
-            int flags = edges.getInt(edgePointer + E_FLAGS);
-            if (switchFlags)
-                return encodingManager.swapDirection(flags);
-
-            return flags;
-        }
     }
 
     @Override
@@ -756,20 +742,19 @@ public EdgeExplorer createEdgeExplorer( EdgeFilter filter )
     @Override
     public EdgeExplorer createEdgeExplorer()
     {
-        return createEdgeExplorer(allEdgesFilter);
+        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     protected class EdgeIterable implements EdgeExplorer, EdgeIterator
     {
         final EdgeFilter filter;
         int baseNode;
-        // edge properties
-        int node;
+        int adjNode;
         int edgeId;
         long edgePointer;
         int nextEdge;
+        boolean reverse;
 
-        // used for SingleEdge and as return value of edge()        
         public EdgeIterable( EdgeFilter filter )
         {
             if (filter == null)
@@ -793,6 +778,18 @@ public EdgeIterator setBaseNode( int baseNode )
             return this;
         }
 
+        @Override
+        public final int getBaseNode()
+        {
+            return baseNode;
+        }
+
+        @Override
+        public final int getAdjNode()
+        {
+            return adjNode;
+        }
+
         @Override
         public final boolean next()
         {
@@ -805,23 +802,16 @@ public final boolean next()
 
                 edgePointer = (long) nextEdge * edgeEntryBytes;
                 edgeId = nextEdge;
-                node = getOtherNode(baseNode, edgePointer);
+                adjNode = getOtherNode(baseNode, edgePointer);
+                reverse = baseNode > adjNode;
 
-                // position to next edge
-                nextEdge = edges.getInt(getLinkPosInEdgeArea(baseNode, node, edgePointer));
+                // position to next edge                
+                nextEdge = edges.getInt(getLinkPosInEdgeArea(baseNode, adjNode, edgePointer));
                 if (nextEdge == edgeId)
-                    throw new AssertionError("endless loop detected for " + baseNode + ", " + node
+                    throw new AssertionError("endless loop detected for " + baseNode + ", " + adjNode
                             + ", " + edgePointer + ", " + edgeId);
 
-                foundNext = filter == null || filter.accept(this);
-//
-//                if(foundNext && nextEdge != EdgeIterator.NO_EDGE && extStorage instanceof TurnCostStorage){
-//                    int turncosts = ((TurnCostStorage) extStorage).getTurnCosts(baseNode, edgeId, nextEdge);
-//                    if(turncosts == Integer.MAX_VALUE){
-//                        foundNext = false;
-//                    }
-//                }
-
+                foundNext = filter.accept(this);
                 if (foundNext)
                     break;
             }
@@ -837,12 +827,6 @@ private long getEdgePointer()
             return edgePointer;
         }
 
-        @Override
-        public final int getAdjNode()
-        {
-            return node;
-        }
-
         @Override
         public final double getDistance()
         {
@@ -859,22 +843,13 @@ public final EdgeIteratorState setDistance( double dist )
         @Override
         public long getFlags()
         {
-            long flags = edges.getInt(edgePointer + E_FLAGS);
-
-            // switch direction flags if necessary
-            if (baseNode > node)
-                flags = encodingManager.swapDirection(flags);
-
-            return flags;
+            return GraphHopperStorage.this.getFlags(edgePointer, reverse);
         }
 
         @Override
         public final EdgeIteratorState setFlags( long fl )
         {
-            int nep = edges.getInt(getLinkPosInEdgeArea(baseNode, node, edgePointer));
-            int neop = edges.getInt(getLinkPosInEdgeArea(node, baseNode, edgePointer));
-            writeEdge(getEdge(), baseNode, node, nep, neop);
-            GraphHopperStorage.this.setFlags(edgePointer, baseNode, node, fl);
+            GraphHopperStorage.this.setFlags(edgePointer, reverse, fl);
             return this;
         }
 
@@ -892,22 +867,16 @@ public EdgeIteratorState setAdditionalField( int value )
         }
 
         @Override
-        public final int getBaseNode()
-        {
-            return baseNode;
-        }
-
-        @Override
-        public final EdgeIteratorState setWayGeometry( PointList pillarNodes )
+        public EdgeIteratorState setWayGeometry( PointList pillarNodes )
         {
-            GraphHopperStorage.this.setWayGeometry(pillarNodes, edgePointer, baseNode > node);
+            GraphHopperStorage.this.setWayGeometry(pillarNodes, edgePointer, reverse);
             return this;
         }
 
         @Override
-        public final PointList fetchWayGeometry( int mode )
+        public PointList fetchWayGeometry( int mode )
         {
-            return GraphHopperStorage.this.fetchWayGeometry(edgePointer, baseNode > node, mode, getBaseNode(), getAdjNode());
+            return GraphHopperStorage.this.fetchWayGeometry(edgePointer, reverse, mode, getBaseNode(), getAdjNode());
         }
 
         @Override
@@ -926,13 +895,16 @@ public String getName()
         @Override
         public EdgeIteratorState setName( String name )
         {
-            int nameIndexRef = nameIndex.put(name);
-            edges.setInt(edgePointer + E_NAME, nameIndexRef);
+            long nameIndexRef = nameIndex.put(name);
+            if (nameIndexRef < 0)
+                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
             return this;
         }
 
         @Override
-        public EdgeIterator detach()
+        public EdgeIteratorState detach( boolean reverseArg )
         {
             if (edgeId == nextEdge)
                 throw new IllegalStateException("call next before detaching");
@@ -941,6 +913,12 @@ public EdgeIterator detach()
             iter.setBaseNode(baseNode);
             iter.setEdgeId(edgeId);
             iter.next();
+            if (reverseArg)
+            {
+                iter.reverse = !this.reverse;
+                iter.adjNode = baseNode;
+                iter.baseNode = adjNode;
+            }
             return iter;
         }
 
@@ -951,51 +929,69 @@ public final String toString()
         }
 
         @Override
-        public void copyProperties( EdgeIteratorState edge )
+        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
         {
-            setDistance(edge.getDistance()).setFlags(edge.getFlags()).setWayGeometry(edge.fetchWayGeometry(0));
+            return GraphHopperStorage.this.copyProperties(this, edge);
         }
     }
 
-    private void setFlags( long edgePointer, int nodeA, int nodeB, long flags )
+    /**
+     * @return to
+     */
+    EdgeIteratorState copyProperties( EdgeIteratorState from, EdgeIteratorState to )
     {
-        if (nodeA > nodeB)
-            flags = encodingManager.swapDirection(flags);
-        edges.setInt(edgePointer + E_FLAGS, (int) flags);
+        to.setDistance(from.getDistance()).
+                setName(from.getName()).
+                setFlags(from.getFlags()).
+                setWayGeometry(from.fetchWayGeometry(0));
+
+        if (E_ADDITIONAL >= 0)
+            to.setAdditionalField(from.getAdditionalField());
+        return to;
     }
 
     public void setAdditionalEdgeField( long edgePointer, int value )
     {
         if (extStorage.isRequireEdgeField() && E_ADDITIONAL >= 0)
-        {
-            nodes.setInt(edgePointer + E_ADDITIONAL, value);
-        } else
-        {
+            edges.setInt(edgePointer + E_ADDITIONAL, value);
+        else
             throw new AssertionError("This graph does not support an additional edge field.");
-        }
     }
 
     private void setWayGeometry( PointList pillarNodes, long edgePointer, boolean reverse )
     {
         if (pillarNodes != null && !pillarNodes.isEmpty())
         {
+            if (pillarNodes.getDimension() != nodeAccess.getDimension())
+                throw new IllegalArgumentException("Cannot use pointlist which is " + pillarNodes.getDimension()
+                        + "D for graph which is " + nodeAccess.getDimension() + "D");
+
             int len = pillarNodes.getSize();
-            int tmpRef = nextGeoRef(len * 2);
+            int dim = nodeAccess.getDimension();
+            int tmpRef = nextGeoRef(len * dim);
             edges.setInt(edgePointer + E_GEO, tmpRef);
             long geoRef = (long) tmpRef * 4;
-            ensureGeometry(geoRef, len * 8 + 4);
-            byte[] bytes = new byte[len * 2 * 4 + 4];
+            byte[] bytes = new byte[len * dim * 4 + 4];
+            ensureGeometry(geoRef, bytes.length);
             bitUtil.fromInt(bytes, len, 0);
             if (reverse)
                 pillarNodes.reverse();
 
             int tmpOffset = 4;
+            boolean is3D = nodeAccess.is3D();
             for (int i = 0; i < len; i++)
             {
-                bitUtil.fromInt(bytes, Helper.degreeToInt(pillarNodes.getLatitude(i)), tmpOffset);
+                double lat = pillarNodes.getLatitude(i);
+                bitUtil.fromInt(bytes, Helper.degreeToInt(lat), tmpOffset);
                 tmpOffset += 4;
                 bitUtil.fromInt(bytes, Helper.degreeToInt(pillarNodes.getLongitude(i)), tmpOffset);
                 tmpOffset += 4;
+
+                if (is3D)
+                {
+                    bitUtil.fromInt(bytes, Helper.eleToInt(pillarNodes.getElevation(i)), tmpOffset);
+                    tmpOffset += 4;
+                }
             }
 
             wayGeometry.setBytes(geoRef, bytes, bytes.length);
@@ -1014,23 +1010,22 @@ private PointList fetchWayGeometry( long edgePointer, boolean reverse, int mode,
         {
             geoRef *= 4;
             count = wayGeometry.getInt(geoRef);
-            wayGeometry.getInt(geoRef);
 
             geoRef += 4;
-            bytes = new byte[count * 2 * 4];
+            bytes = new byte[count * nodeAccess.getDimension() * 4];
             wayGeometry.getBytes(geoRef, bytes, bytes.length);
         } else if (mode == 0)
             return PointList.EMPTY;
 
-        PointList pillarNodes = new PointList(count + mode);
+        PointList pillarNodes = new PointList(count + mode, nodeAccess.is3D());
         if (reverse)
         {
             if ((mode & 2) != 0)
-                pillarNodes.add(getLatitude(adjNode), getLongitude(adjNode));
+                pillarNodes.add(nodeAccess, adjNode);
         } else
         {
             if ((mode & 1) != 0)
-                pillarNodes.add(getLatitude(baseNode), getLongitude(baseNode));
+                pillarNodes.add(nodeAccess, baseNode);
         }
 
         int index = 0;
@@ -1040,18 +1035,25 @@ private PointList fetchWayGeometry( long edgePointer, boolean reverse, int mode,
             index += 4;
             double lon = Helper.intToDegree(bitUtil.toInt(bytes, index));
             index += 4;
-            pillarNodes.add(lat, lon);
+            if (nodeAccess.is3D())
+            {
+                pillarNodes.add(lat, lon, Helper.intToEle(bitUtil.toInt(bytes, index)));
+                index += 4;
+            } else
+            {
+                pillarNodes.add(lat, lon);
+            }
         }
 
         if (reverse)
         {
             if ((mode & 1) != 0)
-                pillarNodes.add(getLatitude(baseNode), getLongitude(baseNode));
+                pillarNodes.add(nodeAccess, baseNode);
             pillarNodes.reverse();
         } else
         {
             if ((mode & 2) != 0)
-                pillarNodes.add(getLatitude(adjNode), getLongitude(adjNode));
+                pillarNodes.add(nodeAccess, adjNode);
         }
 
         return pillarNodes;
@@ -1072,30 +1074,34 @@ public Graph copyTo( Graph g )
     Graph _copyTo( GraphHopperStorage clonedG )
     {
         if (clonedG.edgeEntryBytes != edgeEntryBytes)
-        {
-            throw new IllegalStateException("edgeEntrySize cannot be different for cloned graph");
-        }
+            throw new IllegalStateException("edgeEntryBytes cannot be different for cloned graph. "
+                    + "Cloned: " + clonedG.edgeEntryBytes + " vs " + edgeEntryBytes);
 
         if (clonedG.nodeEntryBytes != nodeEntryBytes)
-        {
-            throw new IllegalStateException("nodeEntrySize cannot be different for cloned graph");
-        }
+            throw new IllegalStateException("nodeEntryBytes cannot be different for cloned graph. "
+                    + "Cloned: " + clonedG.nodeEntryBytes + " vs " + nodeEntryBytes);
+
+        if (clonedG.nodeAccess.getDimension() != nodeAccess.getDimension())
+            throw new IllegalStateException("dimension cannot be different for cloned graph. "
+                    + "Cloned: " + clonedG.nodeAccess.getDimension() + " vs " + nodeAccess.getDimension());
 
         // nodes
+        setNodesHeader();
         nodes.copyTo(clonedG.nodes);
-        clonedG.nodeCount = nodeCount;
-        clonedG.bounds = bounds.clone();
+        clonedG.loadNodesHeader();
 
         // edges
+        setEdgesHeader();
         edges.copyTo(clonedG.edges);
-        clonedG.edgeCount = edgeCount;
+        clonedG.loadEdgesHeader();
 
         // name
         nameIndex.copyTo(clonedG.nameIndex);
 
         // geometry
+        setWayGeometryHeader();
         wayGeometry.copyTo(clonedG.wayGeometry);
-        clonedG.maxGeoRef = maxGeoRef;
+        clonedG.loadWayGeometryHeader();
 
         // extStorage
         extStorage.copyTo(clonedG.extStorage);
@@ -1139,7 +1145,7 @@ public void optimize()
         if (delNodes <= 0)
             return;
 
-        // Deletes only nodes. 
+        // Deletes only nodes.
         // It reduces the fragmentation of the node space but introduces new unused edges.
         inPlaceNodeRemove(delNodes);
 
@@ -1202,7 +1208,7 @@ private void inPlaceNodeRemove( int removeNodeCount )
         GHBitSet toRemoveSet = new GHBitSetImpl(removeNodeCount);
         removedNodes.copyTo(toRemoveSet);
 
-        EdgeExplorer delExplorer = createEdgeExplorer(allEdgesFilter);
+        EdgeExplorer delExplorer = createEdgeExplorer(EdgeFilter.ALL_EDGES);
         // create map of old node ids pointing to new ids        
         for (int removeNode = removedNodes.next(0);
                 removeNode >= 0;
@@ -1289,7 +1295,7 @@ private void inPlaceNodeRemove( int removeNodeCount )
         }
 
         // *rewrites* all edges connected to moved nodes
-        // go through all edges and pick the necessary <- this is easier to implement then
+        // go through all edges and pick the necessary <- this is easier to implement than
         // a more efficient (?) breadth-first search
         EdgeIterator iter = getAllEdges();
         while (iter.next())
@@ -1313,9 +1319,9 @@ private void inPlaceNodeRemove( int removeNodeCount )
             long edgePointer = (long) edge * edgeEntryBytes;
             int linkA = edges.getInt(getLinkPosInEdgeArea(nodeA, nodeB, edgePointer));
             int linkB = edges.getInt(getLinkPosInEdgeArea(nodeB, nodeA, edgePointer));
-            int flags = edges.getInt(edgePointer + E_FLAGS);
+            long flags = getFlags(edgePointer, false);
             writeEdge(edge, updatedA, updatedB, linkA, linkB);
-            setFlags(edgePointer, updatedA, updatedB, flags);
+            setFlags(edgePointer, updatedA > updatedB, flags);
             if (updatedA < updatedB != nodeA < nodeB)
                 setWayGeometry(fetchWayGeometry(edgePointer, true, 0, -1, -1), edgePointer, false);
         }
@@ -1376,28 +1382,15 @@ private static boolean isTestingEnabled()
     public boolean loadExisting()
     {
         checkInit();
-        if (edges.loadExisting())
+        if (nodes.loadExisting())
         {
-            if (!nodes.loadExisting())
-                throw new IllegalStateException("cannot load nodes. corrupt file or directory? " + dir);
-
-            if (!wayGeometry.loadExisting())
-                throw new IllegalStateException("cannot load geometry. corrupt file or directory? " + dir);
-
-            if (!nameIndex.loadExisting())
-                throw new IllegalStateException("cannot load name index. corrupt file or directory? " + dir);
-
-            if (!extStorage.loadExisting())
-            {
-                throw new IllegalStateException("cannot load extended storage. corrupt file or directory? " + dir);
-            }
-
             String acceptStr = "";
             if (properties.loadExisting())
             {
                 properties.checkVersions(false);
                 // check encoding for compatiblity
-                acceptStr = properties.get("osmreader.acceptWay");
+                acceptStr = properties.get("graph.flagEncoders");
+
             } else
                 throw new IllegalStateException("cannot load properties. corrupt file or directory? " + dir);
 
@@ -1407,58 +1400,158 @@ public boolean loadExisting()
                     throw new IllegalStateException("No EncodingManager was configured. And no one was found in the graph: "
                             + dir.getLocation());
 
-                encodingManager = new EncodingManager(acceptStr);
-            } else if (!acceptStr.isEmpty() && !encodingManager.getEncoderList().equalsIgnoreCase(acceptStr))
+                int bytesForFlags = 4;
+                if ("8".equals(properties.get("graph.bytesForFlags")))
+                    bytesForFlags = 8;
+                encodingManager = new EncodingManager(acceptStr, bytesForFlags);
+            } else if (!acceptStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(acceptStr))
             {
-                throw new IllegalStateException("Encoding does not match:\nGraphhopper config: " + encodingManager.getEncoderList() + "\nGraph: " + acceptStr);
+                throw new IllegalStateException("Encoding does not match:\nGraphhopper config: " + encodingManager.toDetailsString()
+                        + "\nGraph: " + acceptStr + ", dir:" + dir.getLocation());
             }
 
-            // nodes
-            int hash = nodes.getHeader(0);
-            if (hash != getClass().getName().hashCode())
-            {
-                throw new IllegalStateException("Cannot load the graph - use instance "
-                        + getClass().getName() + " to load it! " + dir);
-            }
-            nodeEntryBytes = nodes.getHeader(1 * 4);
-            nodeCount = nodes.getHeader(2 * 4);
-            bounds.minLon = Helper.intToDegree(nodes.getHeader(3 * 4));
-            bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
-            bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
-            bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
-
-            // edges
-            edgeEntryBytes = edges.getHeader(0);
-            edgeCount = edges.getHeader(1 * 4);
-
-            // geometry
-            maxGeoRef = wayGeometry.getHeader(0);
-            initialized = true;
+            String dim = properties.get("graph.dimension");
+            if (!dim.equalsIgnoreCase("" + nodeAccess.getDimension()))
+                throw new IllegalStateException("Configured dimension (" + dim + ") is not equal to dimension of loaded graph (" + nodeAccess.getDimension() + ")");
+
+            String byteOrder = properties.get("graph.byteOrder");
+            if (!byteOrder.equalsIgnoreCase("" + dir.getByteOrder()))
+                throw new IllegalStateException("Configured byteOrder (" + dim + ") is not equal to byteOrder of loaded graph (" + dir.getByteOrder() + ")");
+
+            if (!edges.loadExisting())
+                throw new IllegalStateException("Cannot load nodes. corrupt file or directory? " + dir);
+
+            if (!wayGeometry.loadExisting())
+                throw new IllegalStateException("Cannot load geometry. corrupt file or directory? " + dir);
+
+            if (!nameIndex.loadExisting())
+                throw new IllegalStateException("Cannot load name index. corrupt file or directory? " + dir);
+
+            if (!extStorage.loadExisting())
+                throw new IllegalStateException("Cannot load extended storage. corrupt file or directory? " + dir);
+
+            // first define header indices of this storage
+            initStorage();
+
+            // now load some properties from stored data
+            loadNodesHeader();
+            loadEdgesHeader();
+            loadWayGeometryHeader();
             return true;
         }
         return false;
     }
 
-    @Override
-    public void flush()
+    protected void initStorage()
     {
-        // nodes
-        nodes.setHeader(0, getClass().getName().hashCode());
+        edgeEntryIndex = 0;
+        nodeEntryIndex = 0;
+        E_NODEA = nextEdgeEntryIndex(4);
+        E_NODEB = nextEdgeEntryIndex(4);
+        E_LINKA = nextEdgeEntryIndex(4);
+        E_LINKB = nextEdgeEntryIndex(4);
+        E_DIST = nextEdgeEntryIndex(4);
+        this.flagsSizeIsLong = encodingManager.getBytesForFlags() == 8;
+        E_FLAGS = nextEdgeEntryIndex(encodingManager.getBytesForFlags());
+        E_GEO = nextEdgeEntryIndex(4);
+        E_NAME = nextEdgeEntryIndex(4);
+        if (extStorage.isRequireEdgeField())
+            E_ADDITIONAL = nextEdgeEntryIndex(4);
+        else
+            E_ADDITIONAL = -1;
+
+        N_EDGE_REF = nextNodeEntryIndex(4);
+        N_LAT = nextNodeEntryIndex(4);
+        N_LON = nextNodeEntryIndex(4);
+        if (nodeAccess.is3D())
+            N_ELE = nextNodeEntryIndex(4);
+        else
+            N_ELE = -1;
+
+        if (extStorage.isRequireNodeField())
+            N_ADDITIONAL = nextNodeEntryIndex(4);
+        else
+            N_ADDITIONAL = -1;
+
+        initNodeAndEdgeEntrySize();
+        initialized = true;
+    }
+
+    protected int loadNodesHeader()
+    {
+        int hash = nodes.getHeader(0);
+        if (hash != stringHashCode(getClass().getName()))
+            throw new IllegalStateException("Cannot load the graph when using instance of "
+                    + getClass().getName() + " and location: " + dir);
+
+        nodeEntryBytes = nodes.getHeader(1 * 4);
+        nodeCount = nodes.getHeader(2 * 4);
+        bounds.minLon = Helper.intToDegree(nodes.getHeader(3 * 4));
+        bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
+        bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
+        bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
+
+        if (bounds.hasElevation())
+        {
+            bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
+            bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
+        }        
+
+        return 7;
+    }
+
+    protected int setNodesHeader()
+    {
+        nodes.setHeader(0, stringHashCode(getClass().getName()));
         nodes.setHeader(1 * 4, nodeEntryBytes);
         nodes.setHeader(2 * 4, nodeCount);
         nodes.setHeader(3 * 4, Helper.degreeToInt(bounds.minLon));
         nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
         nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
         nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
+        if (bounds.hasElevation())
+        {
+            nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
+            nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
+        }
 
-        // edges
+        return 7;
+    }
+
+    protected int loadEdgesHeader()
+    {
+        edgeEntryBytes = edges.getHeader(0 * 4);
+        edgeCount = edges.getHeader(1 * 4);
+        return 4;
+    }
+
+    protected int setEdgesHeader()
+    {
         edges.setHeader(0, edgeEntryBytes);
         edges.setHeader(1 * 4, edgeCount);
         edges.setHeader(2 * 4, encodingManager.hashCode());
         edges.setHeader(3 * 4, extStorage.hashCode());
+        return 4;
+    }
 
-        // geometry
+    protected int loadWayGeometryHeader()
+    {
+        maxGeoRef = wayGeometry.getHeader(0);
+        return 1;
+    }
+
+    protected int setWayGeometryHeader()
+    {
         wayGeometry.setHeader(0, maxGeoRef);
+        return 1;
+    }
+
+    @Override
+    public void flush()
+    {
+        setNodesHeader();
+        setEdgesHeader();
+        setWayGeometryHeader();
 
         properties.flush();
         wayGeometry.flush();
@@ -1479,33 +1572,55 @@ public void close()
         extStorage.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return nodes.isClosed();
+    }
+
+    @Override
+    public GraphExtension getExtension()    
+    {
+        return extStorage;
+    }
+
     @Override
     public long getCapacity()
     {
-        return edges.getCapacity() + nodes.getCapacity() + nameIndex.getCapacity() + wayGeometry.getCapacity() + properties.getCapacity()
-                + extStorage.getCapacity();
+        return edges.getCapacity() + nodes.getCapacity() + nameIndex.getCapacity() + wayGeometry.getCapacity()
+                + properties.getCapacity() + extStorage.getCapacity();
     }
 
+    @Override
     public String toDetailsString()
     {
         return "edges:" + nf(edgeCount) + "(" + edges.getCapacity() / Helper.MB + "), "
                 + "nodes:" + nf(nodeCount) + "(" + nodes.getCapacity() / Helper.MB + "), "
-                + "name: - (" + nameIndex.getCapacity() / Helper.MB + "), "
+                + "name: /(" + nameIndex.getCapacity() / Helper.MB + "), "
                 + "geo:" + nf(maxGeoRef) + "(" + wayGeometry.getCapacity() / Helper.MB + "), "
                 + "bounds:" + bounds;
     }
 
+    // workaround for graphhopper-ios https://github.com/google/j2objc/issues/423
+    private int stringHashCode( String str )
+    {
+        try
+        {
+            return java.util.Arrays.hashCode(str.getBytes("UTF-8"));
+        } catch (UnsupportedEncodingException ex)
+        {
+            throw new UnsupportedOperationException(ex);
+        }
+    }
+
     @Override
     public String toString()
     {
         return getClass().getSimpleName()
                 + "|" + encodingManager
                 + "|" + getDirectory().getDefaultType()
+                + "|" + nodeAccess.getDimension() + "D"
+                + ((extStorage == null) ? "" : "|" + extStorage)
                 + "|" + getProperties().versionsToString();
     }
-
-    public ExtendedStorage getExtendedStorage()
-    {
-        return extStorage;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphStorage3D.java b/core/src/main/java/com/graphhopper/storage/GraphStorage3D.java
deleted file mode 100644
index f174b1f443..0000000000
--- a/core/src/main/java/com/graphhopper/storage/GraphStorage3D.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.util.Helper;
-
-/**
- * @author Peter Karich
- */
-public class GraphStorage3D extends GraphHopperStorage implements Graph3D
-{
-    private final int N_HEIGHT;
-
-    public GraphStorage3D( Directory dir, EncodingManager encodingManager )
-    {
-        super(dir, encodingManager);
-        N_HEIGHT = nextNodeEntryIndex();
-        initNodeAndEdgeEntrySize();
-    }
-
-    @Override
-    public GraphStorage3D create( long nodeCount )
-    {
-        return (GraphStorage3D) super.create(nodeCount);
-    }
-
-    @Override
-    public void setNode( int index, double lat, double lon, double height )
-    {
-        setNode(index, lat, lon);
-
-        // Improvements:
-        // 1 bounds for index
-        // 2 location to id index
-        // we need to avoid rewriting every algorithm like A*
-        // 3 currWeightToGoal = dist.calcDistKm(toLat, toLon, tmpLat, tmpLon);
-        nodes.setInt((long) index * nodeEntryBytes + N_HEIGHT, Helper.doubleToInt(height));
-    }
-
-    @Override
-    public double getHeight( int index )
-    {
-        ensureNodeIndex(index);
-        return Helper.intToDouble(nodes.getInt((long) index * nodeEntryBytes + N_HEIGHT));
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraph.java b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
index 8bca2098a9..d7917c32ef 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
@@ -23,16 +23,29 @@
 import com.graphhopper.util.EdgeSkipIterState;
 
 /**
- * Extended graph interface which supports storing and retrieving the level for a node.
+ * Extended graph interface which supports storing and retrieving the level for a node and creating
+ * shortcuts, which are additional 'artificial' edges to speedup traversal in certain cases.
  * <p/>
  * @author Peter Karich
  */
 public interface LevelGraph extends Graph
 {
-    void setLevel( int index, int level );
-
-    int getLevel( int index );
-
+    /**
+     * This methods sets the level of the specified node.
+     */
+    void setLevel( int nodeId, int level );
+
+    /**
+     * @return the level of the specified node.
+     */
+    int getLevel( int nodeId );
+
+    boolean isShortcut( int edgeId );
+
+    /**
+     * This method creates a shortcut between a to b which is nearly identical to creating an edge
+     * except that it can be excluded or included for certain traversals or algorithms.
+     */
     EdgeSkipIterState shortcut( int a, int b );
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index afe7e63b6b..d16a114944 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -17,14 +17,11 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.ch.PrepareEncoder;
 import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeSkipExplorer;
-import com.graphhopper.util.EdgeSkipIterator;
-import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.*;
 
 /**
  * A Graph necessary for shortcut algorithms like Contraction Hierarchies. This class enables the
@@ -35,41 +32,76 @@
  */
 public class LevelGraphStorage extends GraphHopperStorage implements LevelGraph
 {
-    private final int I_SKIP_EDGE1;
-    private final int I_SKIP_EDGE2;
-    private final int I_LEVEL;
+    private static final double WEIGHT_FACTOR = 1000f;
+    // 2 bits for access, for now only 32bit => not Long.MAX
+    private static final long MAX_WEIGHT_LONG = (Integer.MAX_VALUE >> 2) << 2;
+    private static final double MAX_WEIGHT = (Integer.MAX_VALUE >> 2) / WEIGHT_FACTOR;
+    private int I_SKIP_EDGE1;
+    private int I_SKIP_EDGE2;
+    private int I_LEVEL;
+    // after the last edge only shortcuts are stored
+    private int lastEdgeIndex = -1;
+    private final long scDirMask = PrepareEncoder.getScDirMask();
+    private final Graph baseGraph;
+
+    public LevelGraphStorage( Directory dir, EncodingManager encodingManager, boolean enabled3D )
+    {
+        super(dir, encodingManager, enabled3D);
+        baseGraph = new BaseGraph(this);
+    }
+
+    @Override
+    public boolean isShortcut( int edgeId )
+    {
+        return edgeId > lastEdgeIndex;
+    }
 
-    public LevelGraphStorage( Directory dir, EncodingManager encodingManager )
+    @Override
+    protected void initStorage()
     {
-        super(dir, encodingManager);
-        I_SKIP_EDGE1 = nextEdgeEntryIndex();
-        I_SKIP_EDGE2 = nextEdgeEntryIndex();
-        I_LEVEL = nextNodeEntryIndex();
+        super.initStorage();
+        I_SKIP_EDGE1 = nextEdgeEntryIndex(4);
+        I_SKIP_EDGE2 = nextEdgeEntryIndex(4);
+        I_LEVEL = nextNodeEntryIndex(4);
         initNodeAndEdgeEntrySize();
     }
 
     @Override
-    public final void setLevel( int index, int level )
+    public final void setLevel( int nodeIndex, int level )
     {
-        ensureNodeIndex(index);
-        nodes.setInt((long) index * nodeEntryBytes + I_LEVEL, level);
+        if (nodeIndex >= getNodes())
+            return;
+
+        nodes.setInt((long) nodeIndex * nodeEntryBytes + I_LEVEL, level);
     }
 
     @Override
-    public final int getLevel( int index )
+    public final int getLevel( int nodeIndex )
     {
-        ensureNodeIndex(index);
-        return nodes.getInt((long) index * nodeEntryBytes + I_LEVEL);
+        // automatically allocate new nodes only via creating edges or setting node properties
+        if (nodeIndex >= getNodes())
+            throw new IllegalStateException("node " + nodeIndex + " is invalid. Not in [0," + getNodes() + ")");
+
+        return nodes.getInt((long) nodeIndex * nodeEntryBytes + I_LEVEL);
     }
 
     @Override
     public EdgeSkipIterState shortcut( int a, int b )
     {
-        return edge(a, b);
+        return createEdge(a, b);
     }
 
     @Override
     public EdgeSkipIterState edge( int a, int b )
+    {
+        if (lastEdgeIndex + 1 < edgeCount)
+            throw new IllegalStateException("Cannot create after shortcut was created");
+
+        lastEdgeIndex = edgeCount;
+        return createEdge(a, b);
+    }
+
+    private EdgeSkipIterState createEdge( int a, int b )
     {
         ensureNodeIndex(Math.max(a, b));
         int edgeId = internalEdgeAdd(a, b);
@@ -84,7 +116,7 @@ public EdgeSkipIterState edge( int a, int b )
     @Override
     public EdgeSkipExplorer createEdgeExplorer()
     {
-        return createEdgeExplorer(allEdgesFilter);
+        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     @Override
@@ -114,7 +146,7 @@ public EdgeSkipIteratorImpl( EdgeFilter filter )
         }
 
         @Override
-        public EdgeSkipIterator setBaseNode( int baseNode )
+        public final EdgeSkipIterator setBaseNode( int baseNode )
         {
             super.setBaseNode(baseNode);
             return this;
@@ -147,11 +179,24 @@ public final int getSkippedEdge2()
         @Override
         public final boolean isShortcut()
         {
-            return EdgeIterator.Edge.isValid(getSkippedEdge1());
+            return edgeId > lastEdgeIndex;
+        }
+
+        @Override
+        public final EdgeSkipIterState setWeight( double weight )
+        {
+            LevelGraphStorage.this.setWeight(this, weight);
+            return this;
+        }
+
+        @Override
+        public final double getWeight()
+        {
+            return LevelGraphStorage.this.getWeight(this);
         }
 
         @Override
-        public EdgeIterator detach()
+        public final EdgeIteratorState detach( boolean reverseArg )
         {
             if (edgeId == nextEdge)
                 throw new IllegalStateException("call next before detaching");
@@ -159,16 +204,72 @@ public EdgeIterator detach()
             iter.setBaseNode(baseNode);
             iter.setEdgeId(edgeId);
             iter.next();
+            if (reverseArg)
+            {
+                iter.reverse = !this.reverse;
+                iter.adjNode = baseNode;
+                iter.baseNode = adjNode;
+            }
             return iter;
         }
 
         @Override
-        public void copyProperties( EdgeIteratorState edge )
+        public final EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
         {
-            super.copyProperties(edge);
-            EdgeSkipIterator eSkip = (EdgeSkipIterator) edge;
+            super.copyPropertiesTo(edge);
+
+//            EdgeSkipIterator eSkip = (EdgeSkipIterator) edge;
 //            setSkippedEdges(eSkip.getSkippedEdge1(), eSkip.getSkippedEdge2());
+            return edge;
+        }
+
+        @Override
+        public String getName()
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call getName on shortcut " + getEdge());
+            return super.getName();
+        }
+
+        @Override
+        public EdgeIteratorState setName( String name )
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call setName on shortcut " + getEdge());
+            return super.setName(name);
         }
+
+        @Override
+        public PointList fetchWayGeometry( int mode )
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call fetchWayGeometry on shortcut " + getEdge());
+            return super.fetchWayGeometry(mode);
+        }
+
+        @Override
+        public EdgeIteratorState setWayGeometry( PointList list )
+        {
+            if (isShortcut())
+                throw new IllegalStateException("Cannot call setWayGeometry on shortcut " + getEdge());
+            return super.setWayGeometry(list);
+        }
+    }
+
+    @Override
+    long reverseFlags( long edgePointer, long flags )
+    {
+        boolean isShortcut = edgePointer > (long) lastEdgeIndex * edgeEntryBytes;
+        if (!isShortcut)
+            return super.reverseFlags(edgePointer, flags);
+
+        // we need a special swapping for level graph if it is a shortcut as we only store the weight and access flags then
+        long dir = flags & scDirMask;
+        if (dir == scDirMask || dir == 0)
+            return flags;
+
+        // swap the last bits with this mask
+        return flags ^ scDirMask;
     }
 
     /**
@@ -179,25 +280,20 @@ public void copyProperties( EdgeIteratorState edge )
      */
     public void disconnect( EdgeSkipExplorer explorer, EdgeIteratorState edgeState )
     {
-        // search edge with opposite direction        
+        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
         // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
         EdgeSkipIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
         int tmpPrevEdge = EdgeIterator.NO_EDGE;
-        boolean found = false;
         while (tmpIter.next())
         {
-            // If we disconnect shortcuts only we could run normal algos on the graph too
-            // BUT CH queries will be 10-20% slower and preparation will be 10% slower
-            if (/*tmpIter.isShortcut() &&*/tmpIter.getEdge() == edgeState.getEdge())
+            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
             {
-                found = true;
+                internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
                 break;
             }
 
             tmpPrevEdge = tmpIter.getEdge();
         }
-        if (found)
-            internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
     }
 
     @Override
@@ -209,28 +305,41 @@ public AllEdgesSkipIterator getAllEdges()
     class AllEdgeSkipIterator extends AllEdgeIterator implements AllEdgesSkipIterator
     {
         @Override
-        public void setSkippedEdges( int edge1, int edge2 )
+        public final void setSkippedEdges( int edge1, int edge2 )
         {
             edges.setInt(edgePointer + I_SKIP_EDGE1, edge1);
             edges.setInt(edgePointer + I_SKIP_EDGE2, edge2);
         }
 
         @Override
-        public int getSkippedEdge1()
+        public final int getSkippedEdge1()
         {
             return edges.getInt(edgePointer + I_SKIP_EDGE1);
         }
 
         @Override
-        public int getSkippedEdge2()
+        public final int getSkippedEdge2()
         {
             return edges.getInt(edgePointer + I_SKIP_EDGE2);
         }
 
         @Override
-        public boolean isShortcut()
+        public final boolean isShortcut()
+        {
+            return edgePointer / edgeEntryBytes > lastEdgeIndex;
+        }
+
+        @Override
+        public final EdgeSkipIterState setWeight( double weight )
         {
-            return EdgeIterator.Edge.isValid(getSkippedEdge1());
+            LevelGraphStorage.this.setWeight(this, weight);
+            return this;
+        }
+
+        @Override
+        public final double getWeight()
+        {
+            return LevelGraphStorage.this.getWeight(this);
         }
     }
 
@@ -248,28 +357,92 @@ public SingleLevelEdge( int edge, int nodeId )
         }
 
         @Override
-        public void setSkippedEdges( int edge1, int edge2 )
+        public final void setSkippedEdges( int edge1, int edge2 )
         {
             edges.setInt(edgePointer + I_SKIP_EDGE1, edge1);
             edges.setInt(edgePointer + I_SKIP_EDGE2, edge2);
         }
 
         @Override
-        public int getSkippedEdge1()
+        public final int getSkippedEdge1()
         {
             return edges.getInt(edgePointer + I_SKIP_EDGE1);
         }
 
         @Override
-        public int getSkippedEdge2()
+        public final int getSkippedEdge2()
         {
             return edges.getInt(edgePointer + I_SKIP_EDGE2);
         }
 
         @Override
-        public boolean isShortcut()
+        public final boolean isShortcut()
+        {
+            return edgeId > lastEdgeIndex;
+        }
+
+        @Override
+        public final EdgeSkipIterState setWeight( double weight )
+        {
+            LevelGraphStorage.this.setWeight(this, weight);
+            return this;
+        }
+
+        @Override
+        public final double getWeight()
         {
-            return EdgeIterator.Edge.isValid(getSkippedEdge1());
+            return LevelGraphStorage.this.getWeight(this);
         }
     }
+
+    final void setWeight( EdgeSkipIterState edge, double weight )
+    {
+        if (!edge.isShortcut())
+            throw new IllegalStateException("setWeight is only available for shortcuts");
+        if (weight < 0)
+            throw new IllegalArgumentException("weight cannot be negative! but was " + weight);
+
+        long weightLong;
+        if (weight > MAX_WEIGHT)
+            weightLong = MAX_WEIGHT_LONG;
+        else
+            weightLong = ((long) (weight * WEIGHT_FACTOR)) << 2;
+
+        long accessFlags = edge.getFlags() & PrepareEncoder.getScDirMask();
+        edge.setFlags(weightLong | accessFlags);
+    }
+
+    final double getWeight( EdgeSkipIterState edge )
+    {
+        if (!edge.isShortcut())
+            throw new IllegalStateException("getWeight is only available for shortcuts");
+
+        double weight = (edge.getFlags() >> 2) / WEIGHT_FACTOR;
+        if (weight >= MAX_WEIGHT)
+            return Double.POSITIVE_INFINITY;
+
+        return weight;
+    }
+
+    @Override
+    protected int loadEdgesHeader()
+    {
+        int next = super.loadEdgesHeader();
+        lastEdgeIndex = edges.getHeader(next * 4);
+        return next + 1;
+    }
+
+    @Override
+    protected int setEdgesHeader()
+    {
+        int next = super.setEdgesHeader();
+        edges.setHeader(next * 4, lastEdgeIndex);
+        return next + 1;
+    }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return baseGraph;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/trees/LeafWorker.java b/core/src/main/java/com/graphhopper/storage/Lock.java
similarity index 50%
rename from core/src/main/java/com/graphhopper/trees/LeafWorker.java
rename to core/src/main/java/com/graphhopper/storage/Lock.java
index 629717fd3d..ca9c118e67 100644
--- a/core/src/main/java/com/graphhopper/trees/LeafWorker.java
+++ b/core/src/main/java/com/graphhopper/storage/Lock.java
@@ -1,31 +1,37 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.trees;
+package com.graphhopper.storage;
 
 /**
- * specify work on the leaf nodes of a quadtree
- * <p/>
+ * A write lock. Influenced by Lucene code
+ * <p>
  * @author Peter Karich
  */
-interface LeafWorker<T>
+public interface Lock
 {
-    /**
-     * @return true if no further search necessary
-     */
-    void doWork( QTDataNode<T> entry, int index );
+    String getName();
+
+    boolean tryLock();
+
+    boolean isLocked();
+
+    void release();
+    
+    Exception getObtainFailedReason();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/LockFactory.java b/core/src/main/java/com/graphhopper/storage/LockFactory.java
new file mode 100644
index 0000000000..a4b276c0eb
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/LockFactory.java
@@ -0,0 +1,42 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import java.io.File;
+
+/**
+ * @author Peter Karich
+ */
+public interface LockFactory
+{
+    void setLockDir( File lockDir );
+
+    /**
+     * This creates a file for write or read locks depending on the specified writeAccess property.
+     * Important note: even for read locks we need write access to the underlying filesystem in
+     * order to avoid writes from other processes.
+     */
+    Lock create( String fileName, boolean writeAccess );
+
+    /**
+     * Removes the specified lock. Note: on windows we cannot forcefully remove an unreleased native
+     * lock
+     */
+    void forceRemove( String fileName, boolean writeAccess );
+}
diff --git a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
index dd16654526..324168122c 100644
--- a/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/MMapDataAccess.java
@@ -42,11 +42,12 @@
     private RandomAccessFile raFile;
     private List<ByteBuffer> segments = new ArrayList<ByteBuffer>();
     private boolean cleanAndRemap = false;
-    private transient boolean closed = false;
+    private final boolean allowWrites;
 
-    MMapDataAccess( String name, String location, ByteOrder order )
+    MMapDataAccess( String name, String location, ByteOrder order, boolean allowWrites )
     {
         super(name, location, order);
+        this.allowWrites = allowWrites;
     }
 
     MMapDataAccess cleanAndRemap( boolean cleanAndRemap )
@@ -65,7 +66,7 @@ private void initRandomAccessFile()
         try
         {
             // raFile necessary for loadExisting and create
-            raFile = new RandomAccessFile(getFullName(), "rw");
+            raFile = new RandomAccessFile(getFullName(), allowWrites ? "rw" : "r");
         } catch (IOException ex)
         {
             throw new RuntimeException(ex);
@@ -82,7 +83,7 @@ public MMapDataAccess create( long bytes )
         initRandomAccessFile();
         bytes = Math.max(10 * 4, bytes);
         setSegmentSize(segmentSizeInBytes);
-        incCapacity(bytes);
+        ensureCapacity(bytes);
         return this;
     }
 
@@ -98,7 +99,7 @@ public DataAccess copyTo( DataAccess da )
     }
 
     @Override
-    public boolean incCapacity( long bytes )
+    public boolean ensureCapacity( long bytes )
     {
         return mapIt(HEADER_OFFSET, bytes, true);
     }
@@ -134,6 +135,7 @@ protected boolean mapIt( long offset, long byteCount, boolean clearNew )
             {
                 newSegments = segmentsToMap;
                 clean(0, segments.size());
+                Helper.cleanHack();
                 segments.clear();
             } else
             {
@@ -173,13 +175,15 @@ private ByteBuffer newByteBuffer( long offset, long byteCount ) throws IOExcepti
         {
             try
             {
-                buf = raFile.getChannel().map(FileChannel.MapMode.READ_WRITE, offset, byteCount);
+                buf = raFile.getChannel().map(
+                        allowWrites ? FileChannel.MapMode.READ_WRITE : FileChannel.MapMode.READ_ONLY,
+                        offset, byteCount);
                 break;
             } catch (IOException tmpex)
             {
                 ioex = tmpex;
                 trial++;
-                cleanHack();
+                Helper.cleanHack();
                 try
                 {
                     // mini sleep to let JVM do unmapping
@@ -223,8 +227,8 @@ public boolean loadExisting()
         if (segments.size() > 0)
             throw new IllegalStateException("already initialized");
 
-        if (closed)
-            return false;
+        if (isClosed())
+            throw new IllegalStateException("already closed");
 
         File file = new File(getFullName());
         if (!file.exists() || file.length() == 0)
@@ -248,10 +252,9 @@ public boolean loadExisting()
     @Override
     public void flush()
     {
-        if (closed)
-        {
+        if (isClosed())
             throw new IllegalStateException("already closed");
-        }
+
         try
         {
             if (!segments.isEmpty() && segments.get(0) instanceof MappedByteBuffer)
@@ -276,16 +279,21 @@ public void flush()
     @Override
     public void close()
     {
-        clean(0, segments.size());
-        segments.clear();
-        Helper.close(raFile);
-        closed = true;
+        super.close();
+        close(true);
     }
 
-    private void cleanHack()
+    /**
+     * @param forceClean if true the clean hack (system.gc) will be executed and forces the system
+     * to cleanup the mmap resources. Set false if you need to close many MMapDataAccess objects.
+     */
+    void close( boolean forceClean )
     {
-        // trying to force the release of the mapped ByteBuffer
-        System.gc();
+        clean(0, segments.size());
+        segments.clear();
+        Helper.close(raFile);
+        if (forceClean)
+            Helper.cleanHack();
     }
 
     @Override
@@ -304,6 +312,22 @@ public final int getInt( long bytePos )
         return segments.get(bufferIndex).getInt(index);
     }
 
+    @Override
+    public final void setShort( long bytePos, short value )
+    {
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        segments.get(bufferIndex).putShort(index, value);
+    }
+
+    @Override
+    public final short getShort( long bytePos )
+    {
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        return segments.get(bufferIndex).getShort(index);
+    }
+
     @Override
     public void setBytes( long bytePos, byte[] values, int length )
     {
@@ -381,7 +405,6 @@ private void clean( int from, int to )
             Helper.cleanMappedByteBuffer(bb);
             segments.set(i, null);
         }
-        cleanHack();
     }
 
     @Override
@@ -398,6 +421,7 @@ public void trimTo( long capacity )
         }
 
         clean(remainingSegNo, segments.size());
+        Helper.cleanHack();
         segments = new ArrayList<ByteBuffer>(segments.subList(0, remainingSegNo));
 
         try
@@ -424,7 +448,7 @@ boolean releaseSegment( int segNumber )
 
         Helper.cleanMappedByteBuffer(segment);
         segments.set(segNumber, null);
-        cleanHack();
+        Helper.cleanHack();
         return true;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
new file mode 100644
index 0000000000..11f6615ac2
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
@@ -0,0 +1,253 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.util.Helper;
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.nio.channels.FileChannel;
+import java.nio.channels.FileLock;
+
+/**
+ * Creates a write lock file. Influenced by Lucene code
+ * <p>
+ * @author Peter Karich
+ */
+public class NativeFSLockFactory implements LockFactory
+{
+    private File lockDir;
+
+    public NativeFSLockFactory()
+    {
+    }
+
+    public NativeFSLockFactory( File dir )
+    {
+        this.lockDir = dir;
+    }
+
+    @Override
+    public void setLockDir( File lockDir )
+    {
+        this.lockDir = lockDir;
+    }
+
+    @Override
+    public synchronized Lock create( String fileName, boolean writeAccess )
+    {
+        if (lockDir == null)
+            throw new RuntimeException("Set lockDir before creating " + (writeAccess ? "write" : "read") + " locks");
+
+        return new NativeLock(lockDir, fileName, writeAccess);
+    }
+
+    @Override
+    public synchronized void forceRemove( String fileName, boolean writeAccess )
+    {
+        if (lockDir.exists())
+        {
+            create(fileName, writeAccess).release();
+            File lockFile = new File(lockDir, fileName);
+            if (lockFile.exists() && !lockFile.delete())
+                throw new RuntimeException("Cannot delete " + lockFile);
+        }
+    }
+
+    static class NativeLock implements Lock
+    {
+        private RandomAccessFile tmpRaFile;
+        private FileChannel tmpChannel;
+        private FileLock tmpLock;
+
+        private final String name;
+        private final File lockDir;
+        private final File lockFile;
+        private final boolean writeLock;
+
+        private Exception failedReason;
+
+        public NativeLock( File lockDir, String fileName, boolean writeLock )
+        {
+            this.name = fileName;
+            this.lockDir = lockDir;
+            this.lockFile = new File(lockDir, fileName);
+            this.writeLock = writeLock;
+        }
+
+        @Override
+        public synchronized boolean tryLock()
+        {
+            // already locked
+            if (lockExists())
+                return false;
+
+            // on-the-fly: make sure directory exists
+            if (!lockDir.exists())
+            {
+                if (!lockDir.mkdirs())
+                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
+            }
+
+            if (!lockDir.isDirectory())
+                throw new IllegalArgumentException("lockDir has to be a directory: " + lockDir);
+
+            try
+            {
+                failedReason = null;
+                // we need write access even for read locks - in order to create the lock file!
+                tmpRaFile = new RandomAccessFile(lockFile, "rw");
+            } catch (IOException ex)
+            {
+                failedReason = ex;
+                return false;
+            }
+
+            try
+            {
+                tmpChannel = tmpRaFile.getChannel();
+                try
+                {
+                    tmpLock = tmpChannel.tryLock(0, Long.MAX_VALUE, !writeLock);
+                    // OverlappingFileLockException is not an IOException!
+                } catch (Exception ex)
+                {
+                    failedReason = ex;
+                } finally
+                {
+                    if (tmpLock == null)
+                    {
+                        Helper.close(tmpChannel);
+                        tmpChannel = null;
+                    }
+                }
+            } finally
+            {
+                if (tmpChannel == null)
+                {
+                    Helper.close(tmpRaFile);
+                    tmpRaFile = null;
+                }
+            }
+            return lockExists();
+        }
+
+        private synchronized boolean lockExists()
+        {
+            return tmpLock != null;
+        }
+
+        @Override
+        public synchronized boolean isLocked()
+        {
+            if (!lockFile.exists())
+                return false;
+
+            if (lockExists())
+                return true;
+
+            try
+            {
+                boolean obtained = tryLock();
+                if (obtained)
+                    release();
+                return !obtained;
+            } catch (Exception ex)
+            {
+                return false;
+            }
+        }
+
+        @Override
+        public synchronized void release()
+        {
+            if (lockExists())
+            {
+                try
+                {
+                    failedReason = null;
+                    tmpLock.release();
+                } catch (Exception ex)
+                {
+                    throw new RuntimeException(ex);
+                } finally
+                {
+                    tmpLock = null;
+                    try
+                    {
+                        tmpChannel.close();
+                    } catch (Exception ex)
+                    {
+                        throw new RuntimeException(ex);
+                    } finally
+                    {
+                        tmpChannel = null;
+                        try
+                        {
+                            tmpRaFile.close();
+                        } catch (Exception ex)
+                        {
+                            throw new RuntimeException(ex);
+                        } finally
+                        {
+                            tmpRaFile = null;
+                        }
+                    }
+                }
+                lockFile.delete();
+            }
+        }
+
+        @Override
+        public String getName()
+        {
+            return name;
+        }
+
+        @Override
+        public Exception getObtainFailedReason()
+        {
+            return failedReason;
+        }
+
+        @Override
+        public String toString()
+        {
+            return lockFile.toString();
+        }
+    }
+
+    public static void main( String[] args ) throws IOException
+    {
+        // trying FileLock mechanics in different processes
+        File file = new File("tmp.lock");
+
+        file.createNewFile();
+        FileChannel channel = new RandomAccessFile(file, "r").getChannel();
+        
+        boolean shared = true;
+        FileLock lock1 = channel.tryLock(0, Long.MAX_VALUE, shared);
+
+        System.out.println("locked " + lock1);
+        System.in.read();
+
+        System.out.println("release " + lock1);
+        lock1.release();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/NodeAccess.java b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
new file mode 100644
index 0000000000..5221b1fb6b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/NodeAccess.java
@@ -0,0 +1,46 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.util.PointAccess;
+
+/**
+ * This interface specifies how to access properties of the nodes in the graph. Similar to
+ * EdgeExplorer as it needs multiple instances for different threads or loops but without the need
+ * for an additional iterator.
+ * <p>
+ * @author Peter Karich
+ */
+public interface NodeAccess extends PointAccess
+{
+    /**
+     * @return the additional value at the specified node index
+     * @throws AssertionError if, and only if, the extendedStorage does not require an additional
+     * node field
+     */
+    int getAdditionalNodeField( int nodeId );
+
+    /**
+     * Sets the additional value at the specified node index
+     * <p>
+     * @throws AssertionError if, and only if, the extendedStorage does not require an additional
+     * node field
+     */
+    void setAdditionalNodeField( int nodeId, int additionalValue );
+}
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index 73305ae5d8..3fe15fffc0 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -32,9 +32,7 @@
  */
 public class RAMDataAccess extends AbstractDataAccess
 {
-
     private byte[][] segments = new byte[0][];
-    private boolean closed = false;
     private boolean store;
 
     RAMDataAccess( String name, String location, boolean store, ByteOrder order )
@@ -63,6 +61,7 @@ public DataAccess copyTo( DataAccess da )
     {
         if (da instanceof RAMDataAccess)
         {
+            copyHeader(da);
             RAMDataAccess rda = (RAMDataAccess) da;
             // TODO PERFORMANCE we could reuse rda segments!
             rda.segments = new byte[segments.length][];
@@ -88,12 +87,12 @@ public RAMDataAccess create( long bytes )
 
         // initialize transient values
         setSegmentSize(segmentSizeInBytes);
-        incCapacity(Math.max(10 * 4, bytes));
+        ensureCapacity(Math.max(10 * 4, bytes));
         return this;
     }
 
     @Override
-    public boolean incCapacity( long bytes )
+    public boolean ensureCapacity(long bytes)
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
@@ -130,7 +129,10 @@ public boolean loadExisting()
         if (segments.length > 0)
             throw new IllegalStateException("already initialized");
 
-        if (!store || closed)
+        if (isClosed())
+            throw new IllegalStateException("already closed");
+
+        if (!store)
             return false;
 
         File file = new File(getFullName());
@@ -232,6 +234,26 @@ public final int getInt( long bytePos )
         return bitUtil.toInt(segments[bufferIndex], index);
     }
 
+    @Override
+    public final void setShort( long bytePos, short value )
+    {
+        assert segmentSizePower > 0 : "call create or loadExisting before usage!";
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        assert index + 2 <= segmentSizeInBytes : "integer cannot be distributed over two segments";
+        bitUtil.fromShort(segments[bufferIndex], value, index);
+    }
+
+    @Override
+    public final short getShort( long bytePos )
+    {
+        assert segmentSizePower > 0 : "call create or loadExisting before usage!";
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        assert index + 2 <= segmentSizeInBytes : "integer cannot be distributed over two segments";
+        return bitUtil.toShort(segments[bufferIndex], index);
+    }
+
     @Override
     public void setBytes( long bytePos, byte[] values, int length )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
index 8b8a7d99b8..7d8f66631c 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
@@ -62,6 +62,7 @@ public DataAccess copyTo( DataAccess da )
     {
         if (da instanceof RAMIntDataAccess)
         {
+            copyHeader(da);
             RAMIntDataAccess rda = (RAMIntDataAccess) da;
             // TODO PERFORMANCE we could reuse rda segments!
             rda.segments = new int[segments.length][];
@@ -89,12 +90,12 @@ public RAMIntDataAccess create( long bytes )
 
         // initialize transient values
         setSegmentSize(segmentSizeInBytes);
-        incCapacity(Math.max(10 * 4, bytes));
+        ensureCapacity(Math.max(10 * 4, bytes));
         return this;
     }
 
     @Override
-    public boolean incCapacity( long bytes )
+    public boolean ensureCapacity(long bytes)
     {
         if (bytes < 0)
             throw new IllegalArgumentException("new capacity has to be strictly positive");
@@ -129,13 +130,14 @@ public boolean incCapacity( long bytes )
     public boolean loadExisting()
     {
         if (segments.length > 0)
-        {
             throw new IllegalStateException("already initialized");
-        }
-        if (!store || closed)
-        {
+
+        if (isClosed())
+            throw new IllegalStateException("already closed");
+
+        if (!store)
             return false;
-        }
+
         File file = new File(getFullName());
         if (!file.exists() || file.length() == 0)
         {
@@ -222,25 +224,57 @@ public void flush()
     }
 
     @Override
-    public final void setInt( long longIndex, int value )
+    public final void setInt( long bytePos, int value )
     {
         assert segmentSizeIntsPower > 0 : "call create or loadExisting before usage!";
-        longIndex >>>= 2;
-        int bufferIndex = (int) (longIndex >>> segmentSizeIntsPower);
-        int index = (int) (longIndex & indexDivisor);
+        bytePos >>>= 2;
+        int bufferIndex = (int) (bytePos >>> segmentSizeIntsPower);
+        int index = (int) (bytePos & indexDivisor);
         segments[bufferIndex][index] = value;
     }
 
     @Override
-    public final int getInt( long longIndex )
+    public final int getInt( long bytePos )
     {
         assert segmentSizeIntsPower > 0 : "call create or loadExisting before usage!";
-        longIndex >>>= 2;
-        int bufferIndex = (int) (longIndex >>> segmentSizeIntsPower);
-        int index = (int) (longIndex & indexDivisor);
+        bytePos >>>= 2;
+        int bufferIndex = (int) (bytePos >>> segmentSizeIntsPower);
+        int index = (int) (bytePos & indexDivisor);
         return segments[bufferIndex][index];
     }
 
+    @Override
+    public final void setShort( long bytePos, short value )
+    {
+        assert segmentSizeIntsPower > 0 : "call create or loadExisting before usage!";
+        if (bytePos % 4 != 0 && bytePos % 4 != 2)
+            throw new IllegalMonitorStateException("bytePos of wrong multiple for RAMInt " + bytePos);
+
+        long tmpIndex = bytePos >>> 1;
+        int bufferIndex = (int) (tmpIndex >>> segmentSizeIntsPower);
+        int index = (int) (tmpIndex & indexDivisor);
+        if (tmpIndex * 2 == bytePos)
+            segments[bufferIndex][index] = value;
+        else
+            segments[bufferIndex][index] = value << 16;
+    }
+
+    @Override
+    public final short getShort( long bytePos )
+    {
+        assert segmentSizeIntsPower > 0 : "call create or loadExisting before usage!";
+        if (bytePos % 4 != 0 && bytePos % 4 != 2)
+            throw new IllegalMonitorStateException("bytePos of wrong multiple for RAMInt " + bytePos);
+
+        long tmpIndex = bytePos >>> 1;
+        int bufferIndex = (int) (tmpIndex >>> segmentSizeIntsPower);
+        int index = (int) (tmpIndex & indexDivisor);
+        if (tmpIndex * 2 == bytePos)
+            return (short) segments[bufferIndex][index];
+        else
+            return (short) (segments[bufferIndex][index] >> 16);
+    }
+
     @Override
     public void getBytes( long bytePos, byte[] values, int length )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
new file mode 100644
index 0000000000..54182e6f99
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
@@ -0,0 +1,138 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Creates a write lock file. Influenced by Lucene code
+ * <p>
+ * @author Peter Karich
+ */
+public class SimpleFSLockFactory implements LockFactory
+{
+    private File lockDir;
+
+    public SimpleFSLockFactory()
+    {
+    }
+
+    public SimpleFSLockFactory( File dir )
+    {
+        this.lockDir = dir;
+    }
+
+    @Override
+    public void setLockDir( File lockDir )
+    {
+        this.lockDir = lockDir;
+    }
+
+    @Override
+    public synchronized Lock create( String fileName, boolean writeAccess )
+    {
+        // TODO no read access-only support
+        if (lockDir == null)
+            throw new RuntimeException("Set lockDir before creating locks");
+
+        return new SimpleLock(lockDir, fileName);
+    }
+
+    @Override
+    public synchronized void forceRemove( String fileName, boolean writeAccess )
+    {
+        if (lockDir.exists())
+        {
+            File lockFile = new File(lockDir, fileName);
+            if (lockFile.exists() && !lockFile.delete())
+                throw new RuntimeException("Cannot delete " + lockFile);
+        }
+    }
+
+    static class SimpleLock implements Lock
+    {
+        private final File lockDir;
+        private final File lockFile;
+        private final String name;
+        private IOException failedReason;
+
+        public SimpleLock( File lockDir, String fileName )
+        {
+            this.name = fileName;
+            this.lockDir = lockDir;
+            this.lockFile = new File(lockDir, fileName);
+        }
+
+        @Override
+        public synchronized boolean tryLock()
+        {
+            // make sure directory exists, do it on-the-fly (not possible when setLockDir is called)
+            if (!lockDir.exists())
+            {
+                if (!lockDir.mkdirs())
+                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
+            }
+
+            // this test can only be performed after the dir has created!
+            if (!lockDir.isDirectory())
+                throw new IllegalArgumentException("lockDir has to be a directory: " + lockDir);
+
+            try
+            {
+                return lockFile.createNewFile();
+            } catch (IOException ex)
+            {
+                failedReason = ex;
+                return false;
+            }
+        }
+
+        @Override
+        public synchronized boolean isLocked()
+        {
+            return lockFile.exists();
+        }
+
+        @Override
+        public synchronized void release()
+        {
+            if (isLocked() && lockFile.exists() && !lockFile.delete())
+                throw new RuntimeException("Cannot release lock file: " + lockFile);
+        }
+
+        @Override
+        public String getName()
+        {
+            return name;
+        }
+
+        @Override
+        public synchronized Exception getObtainFailedReason()
+        {
+            return failedReason;
+        }
+
+        @Override
+        public String toString()
+        {
+            return lockFile.toString();
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/Storable.java b/core/src/main/java/com/graphhopper/storage/Storable.java
index ffbcf5b6a9..8acef8afc8 100644
--- a/core/src/main/java/com/graphhopper/storage/Storable.java
+++ b/core/src/main/java/com/graphhopper/storage/Storable.java
@@ -23,10 +23,16 @@
  * Interface for a storage abstraction. Currently is serves just the purpose to ensure the same
  * methods and names through all kind of 'storable' things in graphhopper.
  * <p/>
- * Then the lifecycle is identical for all such objects: <ol> <li>object creation via new</li>
- * <li>optional configuration via additional setters and getters</li>
- * <li>if(!storable.loadExisting()) storable.create()</li> <li>usage and flush() calls
- * in-between</li> <li>close which does no flush()</li> <ol>
+ * Then the lifecycle is identical for all such objects:
+ * <ol>
+ * <li>object creation via new</li>
+ * <li>optional configuration via additional setters and getters which are not in this
+ * interface</li>
+ * <li>if(!storable.loadExisting()) storable.create()</li>
+ * <li>usage storable and optional flush() calls in-between. Keep in mind that some data structure
+ * could require a call to increase memory while usage. E.g. DataAccess.ensureCapacity()</li>
+ * <li>Finally do close() which does no flush()</li>
+ * </ol>
  * <p/>
  * @author Peter Karich
  */
@@ -56,6 +62,8 @@
     @Override
     void close();
 
+    boolean isClosed();
+
     /**
      * @return the allocated storage size in bytes
      */
diff --git a/core/src/main/java/com/graphhopper/storage/StorableProperties.java b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
index 6efea99a49..7c8dec0694 100644
--- a/core/src/main/java/com/graphhopper/storage/StorableProperties.java
+++ b/core/src/main/java/com/graphhopper/storage/StorableProperties.java
@@ -53,7 +53,7 @@ public boolean loadExisting()
         da.getBytes(0, bytes, len);
         try
         {
-            Helper.loadProperties(map, new StringReader(new String(bytes, "UTF-8")));
+            Helper.loadProperties(map, new StringReader(new String(bytes, Helper.UTF_CS)));
             return true;
         } catch (IOException ex)
         {
@@ -69,7 +69,7 @@ public void flush()
             StringWriter sw = new StringWriter();
             Helper.saveProperties(map, sw);
             // TODO at the moment the size is limited to da.segmentSize() !
-            byte[] bytes = sw.toString().getBytes("UTF-8");
+            byte[] bytes = sw.toString().getBytes(Helper.UTF_CS);
             da.setBytes(0, bytes, bytes.length);
             da.flush();
         } catch (IOException ex)
@@ -109,6 +109,12 @@ public void close()
         da.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return da.isClosed();
+    }        
+
     @Override
     public StorableProperties create( long size )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
index 8772e3ab49..841974263f 100644
--- a/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
+++ b/core/src/main/java/com/graphhopper/storage/SynchedDAWrapper.java
@@ -57,6 +57,18 @@ public synchronized int getInt( long bytePos )
         return inner.getInt(bytePos);
     }
 
+    @Override
+    public synchronized void setShort( long bytePos, short value )
+    {
+        inner.setShort(bytePos, value);
+    }
+
+    @Override
+    public synchronized short getShort( long bytePos )
+    {
+        return inner.getShort(bytePos);
+    }
+
     @Override
     public synchronized void setBytes( long bytePos, byte[] values, int length )
     {
@@ -88,9 +100,9 @@ public synchronized DataAccess create( long bytes )
     }
 
     @Override
-    public synchronized boolean incCapacity( long bytes )
+    public synchronized boolean ensureCapacity(long bytes)
     {
-        return inner.incCapacity(bytes);
+        return inner.ensureCapacity(bytes);
     }
 
     @Override
@@ -141,6 +153,12 @@ public synchronized void close()
         inner.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return inner.isClosed();
+    }
+
     @Override
     public synchronized long getCapacity()
     {
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
new file mode 100644
index 0000000000..84f77a6513
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -0,0 +1,264 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.util.EdgeIterator;
+
+/**
+ * Holds turn cost tables for each node. The additional field of a node will be used to point
+ * towards the first entry within a node cost table to identify turn restrictions, or later, turn
+ * getCosts.
+ * <p>
+ * @author Karl Hübner
+ * @author Peter Karich
+ */
+public class TurnCostExtension implements GraphExtension
+{
+    /* pointer for no cost entry */
+    private final int NO_TURN_ENTRY = -1;
+    private final long EMPTY_FLAGS = 0L;
+
+    /*
+     * items in turn cost tables: edge from, edge to, getCosts, pointer to next
+     * cost entry of same node
+     */
+    private final int TC_FROM, TC_TO, TC_FLAGS, TC_NEXT;
+
+    private DataAccess turnCosts;
+    private int turnCostsEntryIndex = -4;
+    private int turnCostsEntryBytes;
+    private int turnCostsCount;
+
+    private GraphStorage graph;
+    private NodeAccess nodeAccess;
+
+    public TurnCostExtension()
+    {
+        TC_FROM = nextTurnCostEntryIndex();
+        TC_TO = nextTurnCostEntryIndex();
+        TC_FLAGS = nextTurnCostEntryIndex();
+        TC_NEXT = nextTurnCostEntryIndex();
+        turnCostsEntryBytes = turnCostsEntryIndex + 4;
+        turnCostsCount = 0;
+    }
+
+    @Override
+    public void init( GraphStorage graph )
+    {
+        if (turnCostsCount > 0)
+            throw new AssertionError("The turn cost storage must be initialized only once.");
+
+        this.graph = graph;
+        this.nodeAccess = graph.getNodeAccess();
+        this.turnCosts = this.graph.getDirectory().find("turn_costs");
+    }
+
+    private int nextTurnCostEntryIndex()
+    {
+        turnCostsEntryIndex += 4;
+        return turnCostsEntryIndex;
+    }
+
+    @Override
+    public void setSegmentSize( int bytes )
+    {
+        turnCosts.setSegmentSize(bytes);
+    }
+
+    @Override
+    public TurnCostExtension create( long initBytes )
+    {
+        turnCosts.create((long) initBytes * turnCostsEntryBytes);
+        return this;
+    }
+
+    @Override
+    public void flush()
+    {
+        turnCosts.setHeader(0, turnCostsEntryBytes);
+        turnCosts.setHeader(1 * 4, turnCostsCount);
+        turnCosts.flush();
+    }
+
+    @Override
+    public void close()
+    {
+        turnCosts.close();
+    }
+
+    @Override
+    public long getCapacity()
+    {
+        return turnCosts.getCapacity();
+    }
+
+    @Override
+    public boolean loadExisting()
+    {
+        if (!turnCosts.loadExisting())
+            return false;
+
+        turnCostsEntryBytes = turnCosts.getHeader(0);
+        turnCostsCount = turnCosts.getHeader(4);
+        return true;
+    }
+
+    /**
+     * This method adds a new entry which is a turn restriction or cost information via the
+     * turnFlags.
+     */
+    public void addTurnInfo( int from, int viaNode, int to, long turnFlags )
+    {
+        // no need to store turn information
+        if (turnFlags == EMPTY_FLAGS)
+            return;
+
+        // append
+        int newEntryIndex = turnCostsCount;
+        turnCostsCount++;
+        ensureTurnCostIndex(newEntryIndex);
+
+        // determine if we already have an cost entry for this node
+        int previousEntryIndex = nodeAccess.getAdditionalNodeField(viaNode);
+        if (previousEntryIndex == NO_TURN_ENTRY)
+        {
+            // set cost-pointer to this new cost entry
+            nodeAccess.setAdditionalNodeField(viaNode, newEntryIndex);
+        } else
+        {
+            int i = 0;
+            int tmp = previousEntryIndex;
+            while ((tmp = turnCosts.getInt((long) tmp * turnCostsEntryBytes + TC_NEXT)) != NO_TURN_ENTRY)
+            {
+                previousEntryIndex = tmp;
+                // search for the last added cost entry
+                if (i++ > 1000)
+                {
+                    throw new IllegalStateException("Something unexpected happened. A node probably will not have 1000+ relations.");
+                }
+            }
+            // set next-pointer to this new cost entry
+            turnCosts.setInt((long) previousEntryIndex * turnCostsEntryBytes + TC_NEXT, newEntryIndex);
+        }
+        // add entry
+        long costsBase = (long) newEntryIndex * turnCostsEntryBytes;
+        turnCosts.setInt(costsBase + TC_FROM, from);
+        turnCosts.setInt(costsBase + TC_TO, to);
+        turnCosts.setInt(costsBase + TC_FLAGS, (int) turnFlags);
+        // next-pointer is NO_TURN_ENTRY
+        turnCosts.setInt(costsBase + TC_NEXT, NO_TURN_ENTRY);
+    }
+
+    /**
+     * @return turn flags of the specified node and edge properties.
+     */
+    public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
+    {
+        if (edgeFrom == EdgeIterator.NO_EDGE || edgeTo == EdgeIterator.NO_EDGE)
+            throw new IllegalArgumentException("from and to edge cannot be NO_EDGE");
+        if (nodeVia < 0)
+            throw new IllegalArgumentException("via node cannot be negative");
+
+        return nextCostFlags(edgeFrom, nodeVia, edgeTo);
+    }
+
+    private long nextCostFlags( int edgeFrom, int nodeVia, int edgeTo )
+    {
+        int turnCostIndex = nodeAccess.getAdditionalNodeField(nodeVia);
+        int i = 0;
+        for (; i < 1000; i++)
+        {
+            if (turnCostIndex == NO_TURN_ENTRY)
+                break;
+            long turnCostPtr = (long) turnCostIndex * turnCostsEntryBytes;
+            if (edgeFrom == turnCosts.getInt(turnCostPtr + TC_FROM))
+            {
+                if (edgeTo == turnCosts.getInt(turnCostPtr + TC_TO))
+                    return turnCosts.getInt(turnCostPtr + TC_FLAGS);
+            }
+
+            int nextTurnCostIndex = turnCosts.getInt(turnCostPtr + TC_NEXT);
+            if (nextTurnCostIndex == turnCostIndex)
+                throw new IllegalStateException("something went wrong: next entry would be the same");
+
+            turnCostIndex = nextTurnCostIndex;
+        }
+        // so many turn restrictions on one node? here is something wrong
+        if (i > 1000)
+            throw new IllegalStateException("something went wrong: there seems to be no end of the turn cost-list!?");
+        return EMPTY_FLAGS;
+    }
+
+    private void ensureTurnCostIndex( int nodeIndex )
+    {
+        turnCosts.ensureCapacity(((long) nodeIndex + 4) * turnCostsEntryBytes);
+    }
+
+    @Override
+    public boolean isRequireNodeField()
+    {
+        //we require the additional field in the graph to point to the first entry in the node table
+        return true;
+    }
+
+    @Override
+    public boolean isRequireEdgeField()
+    {
+        return false;
+    }
+
+    @Override
+    public int getDefaultNodeFieldValue()
+    {
+        return NO_TURN_ENTRY;
+    }
+
+    @Override
+    public int getDefaultEdgeFieldValue()
+    {
+        throw new UnsupportedOperationException("Not supported by this storage");
+    }
+
+    @Override
+    public GraphExtension copyTo( GraphExtension clonedStorage )
+    {
+        if (!(clonedStorage instanceof TurnCostExtension))
+        {
+            throw new IllegalStateException("the extended storage to clone must be the same");
+        }
+
+        TurnCostExtension clonedTC = (TurnCostExtension) clonedStorage;
+
+        turnCosts.copyTo(clonedTC.turnCosts);
+        clonedTC.turnCostsCount = turnCostsCount;
+
+        return clonedStorage;
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return turnCosts.isClosed();
+    }
+
+    @Override
+    public String toString()
+    {
+        return "turnCost";
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java b/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java
deleted file mode 100644
index 19c54b29e4..0000000000
--- a/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.TurnCostIterator;
-
-/**
- * Holds turn cost tables for each node. The additional field of a node will be used to point
- * towards the first entry within a node cost table to identify turn restrictions, or later, turn
- * costs.
- * <p>
- * @author karl.huebner
- */
-public class TurnCostStorage implements ExtendedStorage
-{
-
-    /* pointer for no cost entry */
-    protected final int NO_COST_ENTRY = -1;
-
-    /*
-     * items in turn cost tables: edge from, edge to, costs, pointer to next
-     * cost entry of same node
-     */
-    protected final int TC_FROM, TC_TO, TC_COSTS, TC_NEXT;
-
-    protected DataAccess turnCosts;
-    protected int turnCostsEntryIndex = -4;
-    protected int turnCostsEntryBytes;
-    protected int turnCostsCount;
-
-    private GraphStorage graph;
-
-    public TurnCostStorage()
-    {
-        TC_FROM = nextTurnCostsEntryIndex();
-        TC_TO = nextTurnCostsEntryIndex();
-        TC_COSTS = nextTurnCostsEntryIndex();
-        TC_NEXT = nextTurnCostsEntryIndex();
-        turnCostsEntryBytes = turnCostsEntryIndex + 4;
-        turnCostsCount = 0;
-    }
-
-    @Override
-    public void init( GraphStorage graph )
-    {
-
-        if (turnCostsCount > 0)
-        {
-            throw new AssertionError("The turn cost storage must be initialized only once.");
-        }
-
-        this.graph = graph;
-
-        Directory dir = this.graph.getDirectory();
-
-        this.turnCosts = dir.find("turnCosts");
-    }
-
-    protected final int nextTurnCostsEntryIndex()
-    {
-        turnCostsEntryIndex += 4;
-        return turnCostsEntryIndex;
-    }
-
-    @Override
-    public void setSegmentSize( int bytes )
-    {
-        turnCosts.setSegmentSize(bytes);
-    }
-
-    @Override
-    public void create( long initBytes )
-    {
-        turnCosts.create((long) initBytes * turnCostsEntryBytes);
-    }
-
-    @Override
-    public void flush()
-    {
-        turnCosts.setHeader(0, turnCostsEntryBytes);
-        turnCosts.setHeader(1 * 4, turnCostsCount);
-        turnCosts.flush();
-    }
-
-    @Override
-    public void close()
-    {
-        turnCosts.close();
-    }
-
-    @Override
-    public long getCapacity()
-    {
-        return turnCosts.getCapacity();
-    }
-
-    public int entries()
-    {
-        return turnCostsCount;
-    }
-
-    @Override
-    public boolean loadExisting()
-    {
-        if (!turnCosts.loadExisting())
-            throw new IllegalStateException("cannot load node costs. corrupt file or directory? " + graph.getDirectory());
-
-        turnCostsEntryBytes = turnCosts.getHeader(0);
-        turnCostsCount = turnCosts.getHeader(4);
-        return true;
-    }
-
-    private int getCostTableAdress( int index )
-    {
-        if (index >= graph.getNodes() || index < 0)
-        {
-            return NO_COST_ENTRY;
-        }
-        return graph.getAdditionalNodeField(index);
-    }
-
-    public void setTurnCosts( int nodeIndex, int from, int to, int flags )
-    {
-        if(flags == 0) {
-            //no need to store turn costs
-            return;
-        }
-        
-        // append
-        int newEntryIndex = turnCostsCount;
-        turnCostsCount++;
-        ensureTurnCostsIndex(newEntryIndex);
-
-        // determine if we already have an cost entry for this node
-        int previousEntryIndex = getCostTableAdress(nodeIndex);
-        if (previousEntryIndex == NO_COST_ENTRY)
-        {
-            // set cost-pointer to this new cost entry
-            graph.setAdditionalNodeField(nodeIndex, newEntryIndex);
-        } else
-        {
-            int i = 0;
-            int tmp = previousEntryIndex;
-            while ((tmp = turnCosts.getInt((long) tmp * turnCostsEntryBytes + TC_NEXT)) != NO_COST_ENTRY)
-            {
-                previousEntryIndex = tmp;
-                // search for the last added cost entry
-                if (i++ > 1000)
-                {
-                    throw new IllegalStateException("Something unexpected happened. A node probably will not have 1000+ relations.");
-                }
-            }
-            // set next-pointer to this new cost entry
-            turnCosts.setInt((long) previousEntryIndex * turnCostsEntryBytes + TC_NEXT, newEntryIndex);
-        }
-        // add entry
-        long costsBase = (long) newEntryIndex * turnCostsEntryBytes;
-        turnCosts.setInt(costsBase + TC_FROM, from);
-        turnCosts.setInt(costsBase + TC_TO, to);
-        turnCosts.setInt(costsBase + TC_COSTS, flags);
-        // next-pointer is NO_COST_ENTRY
-        turnCosts.setInt(costsBase + TC_NEXT, NO_COST_ENTRY);
-    }
-
-    public int getTurnCosts( int node, int edgeFrom, int edgeTo )
-    {
-        if (edgeFrom != EdgeIterator.NO_EDGE && edgeTo != EdgeIterator.NO_EDGE)
-        {
-            TurnCostIterator tc = createTurnCostIterable(node, edgeFrom, edgeTo);
-            if (tc.next())
-            {
-                return tc.costs();
-            }
-        }
-        return 0;
-    }
-
-    public TurnCostIterator createTurnCostIterable( int node, int edgeFrom, int edgeTo )
-    {
-        return new TurnCostIteratable(node, edgeFrom, edgeTo);
-    }
-
-    void ensureTurnCostsIndex( int nodeIndex )
-    {
-        long deltaCap = ((long) nodeIndex + 4) * turnCostsEntryBytes - turnCosts.getCapacity();
-        if (deltaCap <= 0)
-        {
-            return;
-        }
-        turnCosts.incCapacity(deltaCap);
-    }
-
-    @Override
-    public boolean isRequireNodeField()
-    {
-        //we require the additional field in the graph to point to the first entry in the node table
-        return true;
-    }
-
-    @Override
-    public boolean isRequireEdgeField()
-    {
-        return false;
-    }
-
-    @Override
-    public int getDefaultNodeFieldValue()
-    {
-        return NO_COST_ENTRY;
-    }
-
-    @Override
-    public int getDefaultEdgeFieldValue()
-    {
-        throw new UnsupportedOperationException("Not supported by this storage");
-    }
-
-    @Override
-    public ExtendedStorage copyTo( ExtendedStorage clonedStorage )
-    {
-
-        if (!(clonedStorage instanceof TurnCostStorage))
-        {
-            throw new IllegalStateException("the extended storage to clone must be the same");
-        }
-
-        TurnCostStorage clonedTC = (TurnCostStorage) clonedStorage;
-
-        turnCosts.copyTo(clonedTC.turnCosts);
-        clonedTC.turnCostsCount = turnCostsCount;
-
-        return clonedStorage;
-    }
-
-    public class TurnCostIteratable implements TurnCostIterator
-    {
-
-        int nodeVia;
-        int edgeFrom;
-        int edgeTo;
-        int iteratorEdgeFrom;
-        int iteratorEdgeTo;
-        int turnCostIndex;
-        long turnCostPtr;
-
-        public TurnCostIteratable( int node, int edgeFrom, int edgeTo )
-        {
-            this.nodeVia = node;
-            this.iteratorEdgeFrom = edgeFrom;
-            this.iteratorEdgeTo = edgeTo;
-            this.edgeFrom = EdgeIterator.NO_EDGE;
-            this.edgeTo = EdgeIterator.NO_EDGE;
-            this.turnCostIndex = getCostTableAdress(nodeVia);
-            this.turnCostPtr = -1L;
-        }
-
-        @Override
-        public boolean next()
-        {
-            int i = 0;
-            boolean found = false;
-            for (; i < 1000; i++)
-            {
-                if (turnCostIndex == NO_COST_ENTRY)
-                    break;
-                turnCostPtr = (long) turnCostIndex * turnCostsEntryBytes;
-                edgeFrom = turnCosts.getInt(turnCostPtr + TC_FROM);
-                edgeTo = turnCosts.getInt(turnCostPtr + TC_TO);
-
-                int nextTurnCostIndex = turnCosts.getInt(turnCostPtr + TC_NEXT);
-                if (nextTurnCostIndex == turnCostIndex)
-                {
-                    throw new IllegalStateException("something went wrong: next entry would be the same");
-                }
-                turnCostIndex = nextTurnCostIndex;
-
-                if (edgeFrom != EdgeIterator.NO_EDGE && edgeTo != EdgeIterator.NO_EDGE && //
-                        (iteratorEdgeFrom == TurnCostIterator.ANY_EDGE || edgeFrom == iteratorEdgeFrom) && //
-                        (iteratorEdgeTo == TurnCostIterator.ANY_EDGE || edgeTo == iteratorEdgeTo))
-                {
-                    found = true;
-                    break;
-                }
-            }
-            // so many turn restrictions on one node? here is something wrong
-            if (i > 1000)
-                throw new IllegalStateException("something went wrong: no end of turn cost-list found");
-            return found;
-        }
-
-        public int edgeFrom()
-        {
-            return edgeFrom;
-        }
-
-        public int edgeTo()
-        {
-            return edgeTo;
-        }
-
-        public int costs()
-        {
-            return turnCosts.getInt(turnCostPtr + TC_COSTS);
-        }
-    }
-
-}
diff --git a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
index 9e14874c65..20d112c42b 100644
--- a/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/UnsafeDataAccess.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.storage;
 
-import static com.graphhopper.storage.AbstractDataAccess.HEADER_OFFSET;
 import com.graphhopper.util.NotThreadSafe;
 import java.io.File;
 import java.io.IOException;
@@ -32,9 +31,9 @@
  * <p>
  * 1. Highly experimental. Still some bugs and access through file/MMAP should work at some point
  * <p>
- * 2. Compared to MMAP no syncDAWrapper is need to make it safe from multiple threads
+ * 2. Compared to MMAP no syncDAWrapper is need to make it read and write safe from multiple threads
  * <p>
- * 3. Cannot be used on Android I think
+ * 3. Cannot be used on Android as no memory allocation methods are available there
  * <p/>
  * @author Peter Karich
  */
@@ -47,7 +46,7 @@
     static
     {
         try
-        {                           
+        {
             // On Android getting Unsafe fails as the field is named THE_ONE but Android has no memory allocation methods so it won't work nevertheless.
             // On Android we need JNI+malloc https://github.com/libgdx/libgdx/blob/5945211a88570ced7eafce95c68f6f1f7124cd23/gdx/src/com/badlogic/gdx/utils/BufferUtils.java#L287
             @SuppressWarnings("all")
@@ -61,8 +60,7 @@
     }
 
     private long address;
-    private long capacity;
-    private transient boolean closed = false;
+    private long capacity;    
 
     UnsafeDataAccess( String name, String location, ByteOrder order )
     {
@@ -75,12 +73,12 @@ public UnsafeDataAccess create( long bytes )
         // TODO use unsafe.pageSize() instead segmentSizeInBytes?
         // e.g. on my system pageSize is only 4096
         setSegmentSize(segmentSizeInBytes);
-        incCapacity(bytes);
+        ensureCapacity(bytes);
         return this;
     }
 
     @Override
-    public final boolean incCapacity( long bytes )
+    public final boolean ensureCapacity(long bytes)
     {
         return ensureCapacity(bytes, true);
     }
@@ -127,8 +125,8 @@ public DataAccess copyTo( DataAccess da )
     @Override
     public boolean loadExisting()
     {
-        if (closed)
-            return false;
+        if (isClosed())
+            throw new IllegalStateException("already closed");
 
         File file = new File(getFullName());
         if (!file.exists() || file.length() == 0)
@@ -173,7 +171,7 @@ public boolean loadExisting()
     @Override
     public void flush()
     {
-        if (closed)
+        if (isClosed())
             throw new IllegalStateException("already closed");
 
         try
@@ -204,7 +202,7 @@ public void flush()
     @Override
     public void close()
     {
-        closed = true;
+        super.close();
         UNSAFE.freeMemory(address);
     }
 
@@ -220,6 +218,18 @@ public final int getInt( long bytePos )
         return UNSAFE.getInt(address + bytePos);
     }
 
+    @Override
+    public short getShort( long bytePos )
+    {
+        return UNSAFE.getShort(address + bytePos);
+    }
+
+    @Override
+    public void setShort( long bytePos, short value )
+    {
+        UNSAFE.putShort(address + bytePos, value);
+    }
+
     @Override
     public final void setBytes( long bytePos, byte[] values, int length )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/VLongStorage.java b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
index 87096def80..c609eca201 100644
--- a/core/src/main/java/com/graphhopper/storage/VLongStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
@@ -77,7 +77,7 @@ void writeByte( byte b )
      * Writes an long in a variable-length format. Writes between one and nine bytes. Smaller values
      * take fewer bytes. Negative numbers are not supported.
      * <p>
-     * The format is described further in {@link DataOutput#writeVInt(int)}.
+     * The format is described further in Lucene its DataOutput#writeVInt(int)
      * <p/>
      * See DataInput readVLong of Lucene
      */
diff --git a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
index 87f0d0c147..ec3a4b9011 100644
--- a/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
+++ b/core/src/main/java/com/graphhopper/storage/index/BresenhamLine.java
@@ -18,36 +18,124 @@
 package com.graphhopper.storage.index;
 
 /**
- * http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm or even better:
- * http://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm
+ * We need the supercover line. The best algorithm is a 'voxel grid traversal algorithm' and
+ * described in "A Fast Voxel Traversal Algorithm for Ray Tracing" by John Amanatides and Andrew Woo
+ * (1987): http://www.cse.yorku.ca/~amana/research/grid.pdf
+ * <p>
+ * Other methods we used are Bresenham (only integer start and end values) and Xiaolin Wu (anti
+ * aliasing). See some discussion here: http://stackoverflow.com/a/3234074/194609 and here
+ * http://stackoverflow.com/q/24679963/194609
  * <p/>
  * @author Peter Karich
  */
 public class BresenhamLine
 {
-    // http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm#Simplification
     public static void calcPoints( int y1, int x1, int y2, int x2,
             PointEmitter emitter )
+    {
+        bresenham(y1, x1, y2, x2, emitter);
+    }
+
+    public static void voxelTraversal( double y1, double x1, double y2, double x2,
+            PointEmitter emitter )
+    {
+        // edge case
+        x1 = fix(x1);
+        y1 = fix(y1);
+        x2 = fix(x2);
+        y2 = fix(y2);
+
+        int x = (int) x1, y = (int) y1;
+        int endX = (int) x2, endY = (int) y2;
+
+        // deltaX and Y is how far we have to move in ray direction until we find a new cell in x or y direction
+        // y = u + t * v, where u=(x1,x2) and v=(stepX,stepY) is the direction vector
+        final double gridCellWidth = 1, gridCellHeight = 1;
+
+        double deltaX = gridCellWidth / Math.abs(x2 - x1);
+        int stepX = (int) Math.signum(x2 - x1);
+        double tmp = frac(x1 / gridCellWidth);
+        double maxX = deltaX * (1.0 - tmp);
+
+        double deltaY = gridCellHeight / Math.abs(y2 - y1);
+        int stepY = (int) Math.signum(y2 - y1);
+        tmp = frac(y1 / gridCellHeight);
+        double maxY = deltaY * (1.0 - tmp);
+
+        boolean reachedY = false, reachedX = false;
+
+        emitter.set(y, x);
+        // trace primary ray
+        while (!(reachedX && reachedY))
+        {
+            if (maxX < maxY)
+            {
+                maxX += deltaX;
+                x += stepX;
+            } else
+            {
+                maxY += deltaY;
+                y += stepY;
+            }
+
+            emitter.set(y, x);
+
+            if (stepX > 0.0)
+            {
+                if (x >= endX)
+                    reachedX = true;
+
+            } else if (x <= endX)
+            {
+                reachedX = true;
+            }
+
+            if (stepY > 0.0)
+            {
+                if (y >= endY)
+                    reachedY = true;
+
+            } else if (y <= endY)
+            {
+                reachedY = true;
+            }
+        }
+    }
+
+    static final double fix( double val )
+    {
+        if (frac(val) == 0)
+            return val + 0.1;
+        return val;
+    }
+
+    static final double frac( double val )
+    {
+        return val - (int) val;
+    }
+
+    public static void bresenham( int y1, int x1, int y2, int x2,
+            PointEmitter emitter )
     {
         boolean latIncreasing = y1 < y2;
         boolean lonIncreasing = x1 < x2;
         int dLat = Math.abs(y2 - y1), sLat = latIncreasing ? 1 : -1;
         int dLon = Math.abs(x2 - x1), sLon = lonIncreasing ? 1 : -1;
-        int err = 2 * (dLon - dLat);
+        int err = dLon - dLat;
 
         while (true)
         {
             emitter.set(y1, x1);
             if (y1 == y2 && x1 == x2)
-            {
                 break;
-            }
-            int tmpErr = err;
+
+            int tmpErr = 2 * err;
             if (tmpErr > -dLat)
             {
                 err -= dLat;
                 x1 += sLon;
             }
+
             if (tmpErr < dLon)
             {
                 err += dLon;
@@ -56,42 +144,122 @@ public static void calcPoints( int y1, int x1, int y2, int x2,
         }
     }
 
-    public static void calcPoints( double lat1, double lon1,
-            double lat2, double lon2, final PointEmitter emitter,
-            final double offsetLat, final double offsetLon,
-            final double deltaLat, final double deltaLon )
+    public static void xiaolinWu( double y1, double x1, double y2, double x2,
+            PointEmitter emitter )
     {
-        // round to make results of bresenham closer to correct solution
-        int y1 = (int) Math.round((lat1 - offsetLat) / deltaLat);
-        int x1 = (int) Math.round((lon1 - offsetLon) / deltaLon);
-        int y2 = (int) Math.round((lat2 - offsetLat) / deltaLat);
-        int x2 = (int) Math.round((lon2 - offsetLon) / deltaLon);
-        calcPoints(y1, x1, y2, x2, new PointEmitter()
+        double dx = x2 - x1;
+        double dy = y2 - y1;
+
+        if (Math.abs(dx) > Math.abs(dy))
         {
-            @Override
-            public void set( double lat, double lon )
+            if (x2 < x1)
             {
-                emitter.set(((lat) * deltaLat + offsetLat),
-                        ((lon) * deltaLon + offsetLon));
+                // algo only handles rightwards so swap
+                double tmp = x1;
+                x1 = x2;
+                x2 = tmp;
+                tmp = y1;
+                y1 = y2;
+                y2 = tmp;
             }
-        });
+
+            double gradient = dy / dx;
+            // orig: round
+            int xend = (int) (x1);
+            double yend = y1 + gradient * (xend - x1);
+            int xpxl1 = xend;
+            int ypxl1 = (int) yend;
+
+            // first endpoint
+            emitter.set(ypxl1, xpxl1);
+            emitter.set(ypxl1 + 1, xpxl1);
+            double intery = yend + gradient;
+
+            // orig: round
+            xend = (int) (x2);
+            yend = y2 + gradient * (xend - x2);
+            int xpxl2 = xend;
+            int ypxl2 = (int) yend;
+
+            // second endpoint
+            emitter.set(ypxl2, xpxl2);
+            emitter.set(ypxl2 + 1, xpxl2);
+
+            // all the points between the endpoints
+            for (int x = xpxl1 + 1; x <= xpxl2 - 1; ++x)
+            {
+                emitter.set((int) intery, x);
+                emitter.set((int) intery + 1, x);
+                intery += gradient;
+            }
+        } else
+        {
+            if (y2 < y1)
+            {
+                // algo only handles topwards so swap
+                double tmp = x1;
+                x1 = x2;
+                x2 = tmp;
+                tmp = y1;
+                y1 = y2;
+                y2 = tmp;
+            }
+
+            double gradient = dx / dy;
+            // orig: round
+            int yend = (int) (y1);
+            double xend = x1 + gradient * (yend - y1);
+            int ypxl1 = yend;
+            int xpxl1 = (int) xend;
+
+            // first endpoint
+            emitter.set(ypxl1, xpxl1);
+            emitter.set(ypxl1 + 1, xpxl1);
+            double interx = xend + gradient;
+
+            // orig: round
+            yend = (int) (y2);
+            xend = x2 + gradient * (yend - y2);
+            int ypxl2 = yend;
+            int xpxl2 = (int) xend;
+
+            // second endpoint
+            emitter.set(ypxl2, xpxl2);
+            emitter.set(ypxl2 + 1, xpxl2);
+
+            // all the points between the endpoints
+            for (int y = ypxl1 + 1; y <= ypxl2 - 1; ++y)
+            {
+                emitter.set(y, (int) interx);
+                emitter.set(y, (int) interx + 1);
+                interx += gradient;
+            }
+        }
     }
 
-    public static void calcPointsOffset( double lat1, double lon1,
-            double lat2, double lon2, final PointEmitter emitter,
+    public static void calcPoints( final double lat1, final double lon1,
+            final double lat2, final double lon2,
+            final PointEmitter emitter,
             final double offsetLat, final double offsetLon,
             final double deltaLat, final double deltaLon )
     {
+//        double y1 = (lat1 - offsetLat) / deltaLat;
+//        double x1 = (lon1 - offsetLon) / deltaLon;
+//        double y2 = (lat2 - offsetLat) / deltaLat;
+//        double x2 = (lon2 - offsetLon) / deltaLon;
+        // for xiaolinWu or calcPoints
+
+        // round to make results of bresenham closer to correct solution
         int y1 = (int) ((lat1 - offsetLat) / deltaLat);
         int x1 = (int) ((lon1 - offsetLon) / deltaLon);
         int y2 = (int) ((lat2 - offsetLat) / deltaLat);
         int x2 = (int) ((lon2 - offsetLon) / deltaLon);
-        calcPoints(y1, x1, y2, x2, new PointEmitter()
+        bresenham(y1, x1, y2, x2, new PointEmitter()
         {
             @Override
             public void set( double lat, double lon )
             {
-                // +0.5 to move into the center of the tile
+                // +.1 to move more near the center of the tile
                 emitter.set((lat + .1) * deltaLat + offsetLat, (lon + .1) * deltaLon + offsetLon);
             }
         });
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
index 2a10fdddac..8a0a88955f 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
@@ -20,9 +20,9 @@
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.Circle;
 
 /**
@@ -32,12 +32,15 @@
  */
 public class Location2IDFullIndex implements LocationIndex
 {
-    private DistanceCalc calc = new DistancePlaneProjection();
+    private DistanceCalc calc = Helper.DIST_PLANE;
     private final Graph graph;
+    private final NodeAccess nodeAccess;
+    private boolean closed = false;
 
     public Location2IDFullIndex( Graph g )
     {
         this.graph = g;
+        this.nodeAccess = g.getNodeAccess();
     }
 
     @Override
@@ -50,12 +53,10 @@ public boolean loadExisting()
     public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
-        {
-            calc = new DistancePlaneProjection();
-        } else
-        {
-            calc = new DistanceCalcEarth();
-        }
+            calc = Helper.DIST_PLANE;
+        else
+            calc = Helper.DIST_EARTH;
+
         return this;
     }
 
@@ -74,6 +75,9 @@ public LocationIndex prepareIndex()
     @Override
     public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter edgeFilter )
     {
+        if (isClosed())
+            throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
+
         QueryResult res = new QueryResult(queryLat, queryLon);
         Circle circle = null;
         AllEdgesIterator iter = graph.getAllEdges();
@@ -91,12 +95,12 @@ public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter edg
                 {
                     node = iter.getAdjNode();
                 }
-                double tmpLat = graph.getLatitude(node);
-                double tmpLon = graph.getLongitude(node);
+                double tmpLat = nodeAccess.getLatitude(node);
+                double tmpLon = nodeAccess.getLongitude(node);
                 double dist = calc.calcDist(tmpLat, tmpLon, queryLat, queryLon);
                 if (circle == null || dist < calc.calcDist(circle.getLat(), circle.getLon(), queryLat, queryLon))
                 {
-                    res.setClosestEdge(iter.detach());
+                    res.setClosestEdge(iter.detach(false));
                     res.setClosestNode(node);
                     res.setQueryDistance(dist);
                     if (dist <= 0)
@@ -129,6 +133,13 @@ public void flush()
     @Override
     public void close()
     {
+        closed = true;
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return closed;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
index 72104be8fc..a189adffd4 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
@@ -20,9 +20,11 @@
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistancePlaneProjection;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
 
 /**
  * Same as full index but calculates distance to all edges too
@@ -31,12 +33,15 @@
  */
 public class Location2IDFullWithEdgesIndex implements LocationIndex
 {
-    private DistanceCalc calc = new DistanceCalcEarth();
-    private Graph graph;
+    private DistanceCalc calc = Helper.DIST_EARTH;
+    private final Graph graph;
+    private final NodeAccess nodeAccess;
+    private boolean closed = false;
 
     public Location2IDFullWithEdgesIndex( Graph g )
     {
         this.graph = g;
+        this.nodeAccess = g.getNodeAccess();
     }
 
     @Override
@@ -56,10 +61,10 @@ public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
         {
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         } else
         {
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
         }
         return this;
     }
@@ -79,6 +84,9 @@ public int findID( double lat, double lon )
     @Override
     public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter filter )
     {
+        if (isClosed())
+            throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
+
         QueryResult res = new QueryResult(queryLat, queryLon);
         double foundDist = Double.MAX_VALUE;
         AllEdgesIterator iter = graph.getAllEdges();
@@ -98,8 +106,8 @@ public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter fil
                     node = iter.getAdjNode();
                 }
 
-                double fromLat = graph.getLatitude(node);
-                double fromLon = graph.getLongitude(node);
+                double fromLat = nodeAccess.getLatitude(node);
+                double fromLon = nodeAccess.getLongitude(node);
                 double fromDist = calc.calcDist(fromLat, fromLon, queryLat, queryLon);
                 if (fromDist < 0)
                     continue;
@@ -107,7 +115,7 @@ public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter fil
                 if (fromDist < foundDist)
                 {
                     res.setQueryDistance(fromDist);
-                    res.setClosestEdge(iter.detach());
+                    res.setClosestEdge(iter.detach(false));
                     res.setClosestNode(node);
                     foundDist = fromDist;
                 }
@@ -117,8 +125,8 @@ public QueryResult findClosest( double queryLat, double queryLon, EdgeFilter fil
                     continue;
 
                 int toNode = iter.getAdjNode();
-                double toLat = graph.getLatitude(toNode);
-                double toLon = graph.getLongitude(toNode);
+                double toLat = nodeAccess.getLatitude(toNode);
+                double toLon = nodeAccess.getLongitude(toNode);
 
                 if (calc.validEdgeDistance(queryLat, queryLon,
                         fromLat, fromLon, toLat, toLon))
@@ -155,6 +163,13 @@ public void flush()
     @Override
     public void close()
     {
+        closed = true;
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return closed;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 369d880cd3..513e17fa7d 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -23,15 +23,8 @@
 import com.graphhopper.geohash.KeyAlgo;
 import com.graphhopper.geohash.LinearKeyAlgo;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.XFirstSearch;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import java.util.Arrays;
@@ -48,20 +41,22 @@
  * <p/>
  * @author Peter Karich
  */
-public class Location2IDQuadtree implements LocationIndex
+class Location2IDQuadtree implements LocationIndex
 {
     private final static int MAGIC_INT = Integer.MAX_VALUE / 12306;
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private KeyAlgo keyAlgo;
-    protected DistanceCalc distCalc = new DistancePlaneProjection();
+    protected DistanceCalc distCalc = Helper.DIST_PLANE;
     private final DataAccess index;
     private double maxRasterWidth2InMeterNormed;
     private final Graph graph;
+    private final NodeAccess nodeAccess;
     private int lonSize, latSize;
 
     public Location2IDQuadtree( Graph g, Directory dir )
     {
         this.graph = g;
+        this.nodeAccess = g.getNodeAccess();
         index = dir.find("loc2idIndex");
         setResolution(100 * 100);
     }
@@ -70,9 +65,9 @@ public Location2IDQuadtree( Graph g, Directory dir )
     public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
-            distCalc = new DistancePlaneProjection();
+            distCalc = Helper.DIST_PLANE;
         else
-            distCalc = new DistanceCalcEarth();
+            distCalc = Helper.DIST_EARTH;
 
         return this;
     }
@@ -191,8 +186,8 @@ private GHBitSet fillQuadtree( int size )
         GHPoint coord = new GHPoint();
         for (int nodeId = 0; nodeId < locs; nodeId++)
         {
-            double lat = graph.getLatitude(nodeId);
-            double lon = graph.getLongitude(nodeId);
+            double lat = nodeAccess.getLatitude(nodeId);
+            double lon = nodeAccess.getLongitude(nodeId);
             int key = (int) keyAlgo.encode(lat, lon);
             long bytePos = (long) key * 4;
             if (filledIndices.contains(key))
@@ -201,8 +196,8 @@ private GHBitSet fillQuadtree( int size )
                 keyAlgo.decode(key, coord);
                 // decide which one is closer to 'key'
                 double distNew = distCalc.calcNormalizedDist(coord.lat, coord.lon, lat, lon);
-                double oldLat = graph.getLatitude(oldNodeId);
-                double oldLon = graph.getLongitude(oldNodeId);
+                double oldLat = nodeAccess.getLatitude(oldNodeId);
+                double oldLon = nodeAccess.getLongitude(oldNodeId);
                 double distOld = distCalc.calcNormalizedDist(coord.lat, coord.lon, oldLat, oldLon);
                 // new point is closer to quad tree point (key) so overwrite old
                 if (distNew < distOld)
@@ -323,6 +318,9 @@ public int findID( final double lat, final double lon )
     public QueryResult findClosest( final double queryLat, final double queryLon,
             final EdgeFilter edgeFilter )
     {
+        if (isClosed())
+            throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
+
         if (edgeFilter != EdgeFilter.ALL_EDGES)
             throw new UnsupportedOperationException("edge filters are not yet implemented for " + Location2IDQuadtree.class.getSimpleName());
 
@@ -342,13 +340,13 @@ public QueryResult findClosest( final double queryLat, final double queryLon,
          */
         long key = keyAlgo.encode(queryLat, queryLon);
         final int id = index.getInt(key * 4);
-        double mainLat = graph.getLatitude(id);
-        double mainLon = graph.getLongitude(id);
+        double mainLat = nodeAccess.getLatitude(id);
+        double mainLon = nodeAccess.getLongitude(id);
         final QueryResult res = new QueryResult(queryLat, queryLon);
         res.setClosestNode(id);
         res.setQueryDistance(distCalc.calcNormalizedDist(queryLat, queryLon, mainLat, mainLon));
         goFurtherHook(id);
-        new XFirstSearch()
+        new BreadthFirstSearch()
         {
             @Override
             protected GHBitSet createBitSet()
@@ -363,8 +361,8 @@ protected boolean goFurther( int baseNode )
                     return true;
 
                 goFurtherHook(baseNode);
-                double currLat = graph.getLatitude(baseNode);
-                double currLon = graph.getLongitude(baseNode);
+                double currLat = nodeAccess.getLatitude(baseNode);
+                double currLon = nodeAccess.getLongitude(baseNode);
                 double currNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, currLat, currLon);
                 if (currNormedDist < res.getQueryDistance())
                 {
@@ -375,7 +373,7 @@ protected boolean goFurther( int baseNode )
 
                 return currNormedDist < maxRasterWidth2InMeterNormed;
             }
-        }.start(graph.createEdgeExplorer(), id, false);
+        }.start(graph.createEdgeExplorer(), id);
 
         // denormalize distance
         res.setQueryDistance(distCalc.calcDenormalizedDist(res.getQueryDistance()));
@@ -402,6 +400,12 @@ public void close()
         index.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return index.isClosed();
+    }
+
     @Override
     public void setSegmentSize( int bytes )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 6a8ea9028c..73a559903a 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -20,27 +20,25 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.geohash.SpatialKeyAlgo;
-import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
+import gnu.trove.iterator.TIntIterator;
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.procedure.TIntProcedure;
 import gnu.trove.set.hash.TIntHashSet;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
+import java.util.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * This implementation implements an n-tree to get node ids from GPS location. This replaces
- * Location2IDQuadtree except for cases when you only need rough precision or when you need better
- * support for out-of-bounds queries.
+ * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
  * <p/>
  * All leafs are at the same depth, otherwise it is quite complicated to calculate the bresenham
  * line for different resolutions, especially if a leaf node could be split into a tree-node and
@@ -52,34 +50,43 @@
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final int MAGIC_INT;
-    protected static DistanceCalc distCalc = new DistancePlaneProjection();
-    private DistanceCalc preciseDistCalc = new DistanceCalcEarth();
+    protected DistanceCalc distCalc = Helper.DIST_PLANE;
+    private DistanceCalc preciseDistCalc = Helper.DIST_EARTH;
     protected final Graph graph;
+    private final NodeAccess nodeAccess;
     final DataAccess dataAccess;
     private int[] entries;
     private byte[] shifts;
     // convert spatial key to index for subentry of current depth
     private long[] bitmasks;
-    SpatialKeyAlgo keyAlgo;
-    private int minResolutionInMeter = 500;
+    protected SpatialKeyAlgo keyAlgo;
+    private int minResolutionInMeter = 300;
     private double deltaLat;
     private double deltaLon;
     private int initSizeLeafEntries = 4;
     private boolean initialized = false;
     // do not start with 0 as a positive value means leaf and a negative means "entry with subentries"
     static final int START_POINTER = 1;
-    private boolean regionSearch = true;
+    int maxRegionSearch = 4;
     /**
      * If normed distance is smaller than this value the node or edge is 'identical' and the
      * algorithm can stop search.
      */
     private double equalNormedDelta;
 
+    /**
+     * @param g the graph for which this index should do the lookup based on latitude,longitude.
+     * @param dir
+     */
     public LocationIndexTree( Graph g, Directory dir )
     {
+        if (g instanceof LevelGraph)
+            throw new IllegalArgumentException("Call LevelGraph.getBaseGraph() instead of using the LevelGraph itself");
+
         MAGIC_INT = Integer.MAX_VALUE / 22316;
         this.graph = g;
-        dataAccess = dir.find("locationIndex");
+        this.nodeAccess = g.getNodeAccess();
+        dataAccess = dir.find("location_index");
     }
 
     public int getMinResolutionInMeter()
@@ -98,11 +105,20 @@ public LocationIndexTree setMinResolutionInMeter( int minResolutionInMeter )
     }
 
     /**
-     * Searches also neighbouring quadtree entries to increase map matching precision.
+     * Searches also neighbouring tiles until the maximum distance from the query point is reached
+     * (minResolutionInMeter*regionAround). Set to 1 for to force avoiding a fall back, good if you
+     * have strict performance and lookup-quality requirements. Default is 4.
      */
-    public LocationIndexTree setSearchRegion( boolean regionAround )
+    public LocationIndexTree setMaxRegionSearch( int numTiles )
     {
-        this.regionSearch = regionAround;
+        if (numTiles < 1)
+            throw new IllegalArgumentException("Region of location index must be at least 1 but was " + numTiles);
+
+        // see #232
+        if (numTiles % 2 == 1)
+            numTiles++;
+
+        this.maxRegionSearch = numTiles;
         return this;
     }
 
@@ -115,8 +131,11 @@ void prepareAlgo()
         // if we assume a minimum resolution like 0.5km for a leaf-tile                
         // n^(depth/2) = toMeter(dLon) / minResolution
         BBox bounds = graph.getBounds();
-        if (graph.getNodes() == 0 || !bounds.check())
-            throw new IllegalStateException("Bounds of graph are invalid: " + bounds);
+        if (graph.getNodes() == 0)
+            throw new IllegalStateException("Cannot create location index of empty graph!");
+
+        if (!bounds.isValid())
+            throw new IllegalStateException("Cannot create location index when graph has invalid bounds: " + bounds);
 
         double lat = Math.min(Math.abs(bounds.maxLat), Math.abs(bounds.minLat));
         double maxDistInMeter = Math.max(
@@ -201,7 +220,7 @@ private byte getShift( int entries )
 
     private long getBitmask( int shift )
     {
-        long bm = (1 << shift) - 1;
+        long bm = (1L << shift) - 1;
         if (bm <= 0)
         {
             throw new IllegalStateException("invalid bitmask:" + bm);
@@ -261,9 +280,9 @@ public LocationIndex setResolution( int minResolutionInMeter )
     public LocationIndex setApproximation( boolean approx )
     {
         if (approx)
-            distCalc = new DistancePlaneProjection();
+            distCalc = Helper.DIST_PLANE;
         else
-            distCalc = new DistanceCalcEarth();
+            distCalc = Helper.DIST_EARTH;
         return this;
     }
 
@@ -297,8 +316,14 @@ public LocationIndex prepareIndex()
 
         // compact & store to dataAccess
         dataAccess.create(64 * 1024);
-        int lastPointer = inMem.store(inMem.root, START_POINTER);
-        flush();
+        try
+        {
+            inMem.store(inMem.root, START_POINTER);
+            flush();
+        } catch (Exception ex)
+        {
+            throw new IllegalStateException("Problem while storing location index. " + Helper.getMemInfo(), ex);
+        }
         float entriesPerLeaf = (float) inMem.size / inMem.leafs;
         initialized = true;
         logger.info("location index created in " + sw.stop().getSeconds()
@@ -325,6 +350,12 @@ public void close()
         dataAccess.close();
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return dataAccess.isClosed();
+    }
+
     @Override
     public long getCapacity()
     {
@@ -350,15 +381,15 @@ public InMemConstructionIndex( int noOfSubEntries )
 
         void prepare()
         {
-            final EdgeIterator allIter = getAllEdges();
+            final EdgeIterator allIter = graph.getAllEdges();
             try
             {
                 while (allIter.next())
                 {
                     int nodeA = allIter.getBaseNode();
                     int nodeB = allIter.getAdjNode();
-                    double lat1 = graph.getLatitude(nodeA);
-                    double lon1 = graph.getLongitude(nodeA);
+                    double lat1 = nodeAccess.getLatitude(nodeA);
+                    double lon1 = nodeAccess.getLongitude(nodeA);
                     double lat2;
                     double lon2;
                     PointList points = allIter.fetchWayGeometry(0);
@@ -371,13 +402,12 @@ void prepare()
                         lat1 = lat2;
                         lon1 = lon2;
                     }
-                    lat2 = graph.getLatitude(nodeB);
-                    lon2 = graph.getLongitude(nodeB);
+                    lat2 = nodeAccess.getLatitude(nodeB);
+                    lon2 = nodeAccess.getLongitude(nodeB);
                     addNode(nodeA, nodeB, lat1, lon1, lat2, lon2);
                 }
             } catch (Exception ex)
             {
-//                logger.error("Problem!", ex);
                 logger.error("Problem! base:" + allIter.getBaseNode() + ", adj:" + allIter.getAdjNode()
                         + ", edge:" + allIter.getEdge(), ex);
             }
@@ -395,7 +425,7 @@ public void set( double lat, double lon )
                     long key = keyAlgo.encode(lat, lon);
                     long keyPart = createReverseKey(key);
                     // no need to feed both nodes as we search neighbors in fillIDs
-                    addNode(root, pickBestNode(nodeA, nodeB), 0, keyPart, key);
+                    addNode(root, nodeA, 0, keyPart, key);
                 }
             };
             BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
@@ -505,7 +535,7 @@ int store( InMemEntry entry, int intIndex )
                 size += len;
                 intIndex++;
                 leafs++;
-                dataAccess.incCapacity((long) (intIndex + len + 1) * 4);
+                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
                 if (len == 1)
                 {
                     // less disc space for single entries
@@ -530,7 +560,7 @@ int store( InMemEntry entry, int intIndex )
                     {
                         continue;
                     }
-                    dataAccess.incCapacity((long) (intIndex + 1) * 4);
+                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
                     int beforeIntIndex = intIndex;
                     intIndex = store(subEntry, beforeIntIndex);
                     if (intIndex == beforeIntIndex)
@@ -551,8 +581,8 @@ TIntArrayList getEntries()
         return new TIntArrayList(entries);
     }
 
-    // fillIDs according to how they are stored    
-    void fillIDs( long keyPart, int intIndex, TIntHashSet set, int depth )
+    // fillIDs according to how they are stored
+    final void fillIDs( long keyPart, int intIndex, TIntHashSet set, int depth )
     {
         long pointer = (long) intIndex << 2;
         if (depth == entries.length)
@@ -593,36 +623,170 @@ final long createReverseKey( long key )
         return BitUtil.BIG.reverse(key, keyAlgo.getBits());
     }
 
-    protected TIntHashSet findNetworkEntries( double queryLat, double queryLon )
+    /**
+     * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
+     * context of a spatial key tile.
+     * <p>
+     */
+    final double calculateRMin( double lat, double lon )
+    {
+        return calculateRMin(lat, lon, 0);
+    }
+
+    /**
+     * Calculates the distance to the nearest tile border, where the tile border is the rectangular
+     * region with dimension 2*paddingTiles + 1 and where the center tile contains the given lat/lon
+     * coordinate
+     */
+    final double calculateRMin( double lat, double lon, int paddingTiles )
     {
-        TIntHashSet storedNetworkEntryIds = new TIntHashSet();
-        if (regionSearch)
+        GHPoint query = new GHPoint(lat, lon);
+        long key = keyAlgo.encode(query);
+        GHPoint center = new GHPoint();
+        keyAlgo.decode(key, center);
+
+        // deltaLat and deltaLon comes from the LocationIndex:
+        double minLat = center.lat - (0.5 + paddingTiles) * deltaLat;
+        double maxLat = center.lat + (0.5 + paddingTiles) * deltaLat;
+        double minLon = center.lon - (0.5 + paddingTiles) * deltaLon;
+        double maxLon = center.lon + (0.5 + paddingTiles) * deltaLon;
+
+        double dSouthernLat = query.lat - minLat;
+        double dNorthernLat = maxLat - query.lat;
+        double dWesternLon = query.lon - minLon;
+        double dEasternLon = maxLon - query.lon;
+
+        // convert degree deltas into a radius in meter
+        double dMinLat, dMinLon;
+        if (dSouthernLat < dNorthernLat)
         {
-            // search all rasters around minResolutionInMeter as we did not fill empty entries
-            double maxLat = queryLat + deltaLat;
-            double maxLon = queryLon + deltaLon;
-            for (double tmpLat = queryLat - deltaLat; tmpLat <= maxLat; tmpLat += deltaLat)
+            dMinLat = distCalc.calcDist(query.lat, query.lon, minLat, query.lon);
+        } else
+        {
+            dMinLat = distCalc.calcDist(query.lat, query.lon, maxLat, query.lon);
+        }
+
+        if (dWesternLon < dEasternLon)
+        {
+            dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, minLon);
+        } else
+        {
+            dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, maxLon);
+        }
+
+        double rMin = Math.min(dMinLat, dMinLon);
+        return rMin;
+    }
+
+    /**
+     * Provide info about tilesize for testing / visualization
+     */
+    double getDeltaLat()
+    {
+        return deltaLat;
+    }
+
+    double getDeltaLon()
+    {
+        return deltaLon;
+    }
+
+    GHPoint getCenter( double lat, double lon )
+    {
+        GHPoint query = new GHPoint(lat, lon);
+        long key = keyAlgo.encode(query);
+        GHPoint center = new GHPoint();
+        keyAlgo.decode(key, center);
+        return center;
+    }
+
+    /**
+     * This method collects the node indices from the quad tree data structure in a certain order
+     * which makes sure not too many nodes are collected as well as no nodes will be missing. See
+     * discussion at issue #221.
+     */
+    public final TIntHashSet findNetworkEntries( double queryLat, double queryLon, int maxIteration )
+    {
+        TIntHashSet foundEntries = new TIntHashSet();
+
+        for (int iteration = 0; iteration < maxIteration; iteration++)
+        {
+            // find entries in border of searchbox
+            for (int yreg = -iteration; yreg <= iteration; yreg++)
             {
-                for (double tmpLon = queryLon - deltaLon; tmpLon <= maxLon; tmpLon += deltaLon)
+                double subqueryLat = queryLat + yreg * deltaLat;
+                double subqueryLonA = queryLon - iteration * deltaLon;
+                double subqueryLonB = queryLon + iteration * deltaLon;
+                findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonA);
+
+                // minor optimization for iteration == 0
+                if (iteration > 0)
                 {
-                    long keyPart = createReverseKey(tmpLat, tmpLon);
-                    // System.out.println(BitUtilLittle.toBitString(key, keyAlgo.bits()));
-                    fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
+                    findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonB);
                 }
             }
-        } else
+
+            for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++)
+            {
+                double subqueryLon = queryLon + xreg * deltaLon;
+                double subqueryLatA = queryLat - iteration * deltaLat;
+                double subqueryLatB = queryLat + iteration * deltaLat;
+                findNetworkEntriesSingleRegion(foundEntries, subqueryLatA, subqueryLon);
+                findNetworkEntriesSingleRegion(foundEntries, subqueryLatB, subqueryLon);
+            }
+
+            // see #232
+            if (iteration % 2 == 1)
+            {
+                // Check if something was found already...
+                if (foundEntries.size() > 0)
+                {
+                    double rMin = calculateRMin(queryLat, queryLon, iteration);
+                    double minDistance = calcMinDistance(queryLat, queryLon, foundEntries);
+
+                    if (minDistance < rMin)
+                    {   // resultEntries contains a nearest node for sure
+                        break;
+                    } // else: continue an undetected nearer node may sit in a neighbouring tile.
+                    // Now calculate how far we have to look outside to find any hidden nearest nodes
+                    // and repeat whole process with wider search area until this distance is covered.
+                }
+            }
+        }
+        return foundEntries;
+    }
+
+    final double calcMinDistance( double queryLat, double queryLon, TIntHashSet pointset )
+    {
+        double min = Double.MAX_VALUE;
+        TIntIterator itr = pointset.iterator();
+        while (itr.hasNext())
         {
-            long keyPart = createReverseKey(queryLat, queryLon);
-            fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
+            int node = itr.next();
+            double lat = nodeAccess.getLat(node);
+            double lon = nodeAccess.getLon(node);
+            double dist = distCalc.calcDist(queryLat, queryLon, lat, lon);
+            if (dist < min)
+            {
+                min = dist;
+            }
         }
-        return storedNetworkEntryIds;
+        return min;
+    }
+
+    final void findNetworkEntriesSingleRegion( TIntHashSet storedNetworkEntryIds, double queryLat, double queryLon )
+    {
+        long keyPart = createReverseKey(queryLat, queryLon);
+        fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
     }
 
     @Override
-    public QueryResult findClosest( final double queryLat, final double queryLon,
-            final EdgeFilter edgeFilter )
+    public QueryResult findClosest( final double queryLat, final double queryLon, final EdgeFilter edgeFilter )
     {
-        final TIntHashSet storedNetworkEntryIds = findNetworkEntries(queryLat, queryLon);
+        if (isClosed())
+            throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
+
+        final TIntHashSet storedNetworkEntryIds = findNetworkEntries(queryLat, queryLon, maxRegionSearch);
         final QueryResult closestMatch = new QueryResult(queryLat, queryLon);
         if (storedNetworkEntryIds.isEmpty())
             return closestMatch;
@@ -630,11 +794,11 @@ public QueryResult findClosest( final double queryLat, final double queryLon,
         // clone storedIds to avoid interference with forEach
         final GHBitSet checkBitset = new GHTBitSet(new TIntHashSet(storedNetworkEntryIds));
         // find nodes from the network entries which are close to 'point'
-        final EdgeExplorer explorer = graph.createEdgeExplorer(getEdgeFilter());
+        final EdgeExplorer explorer = graph.createEdgeExplorer();
         storedNetworkEntryIds.forEach(new TIntProcedure()
         {
             @Override
-            public boolean execute( final int networkEntryNodeId )
+            public boolean execute( int networkEntryNodeId )
             {
                 new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter)
                 {
@@ -651,14 +815,14 @@ protected boolean check( int node, double normedDist, int wayIndex, EdgeIterator
                         {
                             closestMatch.setQueryDistance(normedDist);
                             closestMatch.setClosestNode(node);
-                            closestMatch.setClosestEdge(edge.detach());
+                            closestMatch.setClosestEdge(edge.detach(false));
                             closestMatch.setWayIndex(wayIndex);
                             closestMatch.setSnappedPosition(pos);
                             return true;
                         }
                         return false;
                     }
-                }.start(explorer, networkEntryNodeId, false);
+                }.start(explorer, networkEntryNodeId);
                 return true;
             }
         });
@@ -676,7 +840,7 @@ protected boolean check( int node, double normedDist, int wayIndex, EdgeIterator
     /**
      * Make it possible to collect nearby location also for other purposes.
      */
-    protected abstract class XFirstSearchCheck extends XFirstSearch
+    protected abstract class XFirstSearchCheck extends BreadthFirstSearch
     {
         boolean goFurther = true;
         double currNormedDist;
@@ -706,8 +870,8 @@ protected GHBitSet createBitSet()
         protected boolean goFurther( int baseNode )
         {
             currNode = baseNode;
-            currLat = graph.getLatitude(baseNode);
-            currLon = graph.getLongitude(baseNode);
+            currLat = nodeAccess.getLatitude(baseNode);
+            currLon = nodeAccess.getLongitude(baseNode);
             currNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, currLat, currLon);
             return goFurther;
         }
@@ -731,8 +895,8 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
             }
 
             int adjNode = currEdge.getAdjNode();
-            double adjLat = graph.getLatitude(adjNode);
-            double adjLon = graph.getLongitude(adjNode);
+            double adjLat = nodeAccess.getLatitude(adjNode);
+            double adjLon = nodeAccess.getLongitude(adjNode);
             double adjDist = distCalc.calcNormalizedDist(adjLat, adjLon, queryLat, queryLon);
             // if there are wayPoints this is only an approximation
             if (adjDist < currNormedDist)
@@ -753,16 +917,19 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
                     tmpNormedDist = distCalc.calcNormalizedEdgeDistance(queryLat, queryLon,
                             tmpLat, tmpLon, wayLat, wayLon);
                     check(tmpClosestNode, tmpNormedDist, pointIndex, currEdge, pos);
-                } else if (pointIndex + 1 == len)
-                {
-                    tmpNormedDist = adjDist;
-                    pos = QueryResult.Position.TOWER;
                 } else
                 {
-                    tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
-                    pos = QueryResult.Position.PILLAR;
+                    if (pointIndex + 1 == len)
+                    {
+                        tmpNormedDist = adjDist;
+                        pos = QueryResult.Position.TOWER;
+                    } else
+                    {
+                        tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
+                        pos = QueryResult.Position.PILLAR;
+                    }
+                    check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
                 }
-                check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
 
                 if (tmpNormedDist <= equalNormedDelta)
                     return false;
@@ -778,23 +945,6 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
         protected abstract boolean check( int node, double normedDist, int wayIndex, EdgeIteratorState iter, QueryResult.Position pos );
     }
 
-    protected int pickBestNode( int nodeA, int nodeB )
-    {
-        // For normal graph the node does not matter because if nodeA is conntected to nodeB
-        // then nodeB is also connect to nodeA, but for a LevelGraph this does not apply.
-        return nodeA;
-    }
-
-    protected EdgeFilter getEdgeFilter()
-    {
-        return EdgeFilter.ALL_EDGES;
-    }
-
-    protected AllEdgesIterator getAllEdges()
-    {
-        return graph.getAllEdges();
-    }
-
     // make entries static as otherwise we get an additional reference to this class (memory waste)
     static interface InMemEntry
     {
@@ -803,12 +953,12 @@ protected AllEdgesIterator getAllEdges()
 
     static class InMemLeafEntry extends SortedIntSet implements InMemEntry
     {
-        private long key;
+        // private long key;
 
         public InMemLeafEntry( int count, long key )
         {
             super(count);
-            this.key = key;
+            // this.key = key;
         }
 
         public boolean addNode( int nodeId )
@@ -825,7 +975,7 @@ public final boolean isLeaf()
         @Override
         public String toString()
         {
-            return "LEAF " + key + " " + super.toString();
+            return "LEAF " + /*key +*/ " " + super.toString();
         }
 
         TIntArrayList getResults()
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index 94ef64574a..c371733f82 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -20,22 +20,18 @@
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.CoordTrig;
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
 
 /**
  * Result of LocationIndex lookup.
- * <p/>
- * <
- * pre> X=query coordinates S=snapped coordinates: "snapping" real coords to road N=tower or pillar
+ * <pre> X=query coordinates S=snapped coordinates: "snapping" real coords to road N=tower or pillar
  * node T=closest tower node XS=distance
- * <p/>
  * X
  * |
  * T--S----N
- * <p/>
  * </pre>
- * <p/>
+ * <p>
  * @author Peter Karich
  */
 public class QueryResult
@@ -45,9 +41,17 @@
     private int closestNode = -1;
     private EdgeIteratorState closestEdge;
     private final GHPoint queryPoint;
-    private GHPoint snappedPoint;
+    private GHPoint3D snappedPoint;
     private Position snappedPosition;
 
+    /**
+     * Due to precision differences it is hard to define when something is exactly 90° or "on-node"
+     * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
+     * "on-edge" even if it could be 90°. To prefer "on-node" you could use e.g. GHPoint.equals with
+     * a default precision of 1e-6.
+     * <p>
+     * @see DistanceCalc#validEdgeDistance
+     */
     public static enum Position
     {
         EDGE, TOWER, PILLAR
@@ -119,7 +123,6 @@ public Position getSnappedPosition()
      */
     public boolean isValid()
     {
-        // Location2IDQuadtree does not support edges
         return closestNode >= 0;
     }
 
@@ -136,7 +139,7 @@ public EdgeIteratorState getClosestEdge()
         return closestEdge;
     }
 
-    public CoordTrig getQueryPoint()
+    public GHPoint getQueryPoint()
     {
         return queryPoint;
     }
@@ -145,7 +148,7 @@ public CoordTrig getQueryPoint()
      * Calculates the position of the query point 'snapped' to a close road segment or node. Call
      * calcSnappedPoint before, if not, an IllegalStateException is thrown.
      */
-    public GHPoint getSnappedPoint()
+    public GHPoint3D getSnappedPoint()
     {
         if (snappedPoint == null)
             throw new IllegalStateException("Calculate snapped point before!");
@@ -165,19 +168,23 @@ public void calcSnappedPoint( DistanceCalc distCalc )
         PointList fullPL = getClosestEdge().fetchWayGeometry(3);
         double tmpLat = fullPL.getLatitude(wayIndex);
         double tmpLon = fullPL.getLongitude(wayIndex);
+        double tmpEle = fullPL.getElevation(wayIndex);
         if (snappedPosition != Position.EDGE)
         {
-            snappedPoint = new GHPoint(tmpLat, tmpLon);
+            snappedPoint = new GHPoint3D(tmpLat, tmpLon, tmpEle);
             return;
         }
 
         double queryLat = getQueryPoint().lat, queryLon = getQueryPoint().lon;
         double adjLat = fullPL.getLatitude(wayIndex + 1), adjLon = fullPL.getLongitude(wayIndex + 1);
         if (distCalc.validEdgeDistance(queryLat, queryLon, tmpLat, tmpLon, adjLat, adjLon))
-            snappedPoint = distCalc.calcCrossingPointToEdge(queryLat, queryLon, tmpLat, tmpLon, adjLat, adjLon);
-        else
+        {
+            GHPoint tmpPoint = distCalc.calcCrossingPointToEdge(queryLat, queryLon, tmpLat, tmpLon, adjLat, adjLon);
+            double adjEle = fullPL.getElevation(wayIndex + 1);
+            snappedPoint = new GHPoint3D(tmpPoint.lat, tmpPoint.lon, (tmpEle + adjEle) / 2);
+        } else
             // outside of edge boundaries
-            snappedPoint = new GHPoint(tmpLat, tmpLon);
+            snappedPoint = new GHPoint3D(tmpLat, tmpLon, tmpEle);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/index/WeightedNode.java b/core/src/main/java/com/graphhopper/storage/index/WeightedNode.java
deleted file mode 100644
index 13b5a04f42..0000000000
--- a/core/src/main/java/com/graphhopper/storage/index/WeightedNode.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage.index;
-
-/**
- * Helper class used in some Location2IDIndex implementations for findID
- * <p/>
- * @author Peter Karich
- */
-class WeightedNode implements Comparable<WeightedNode>
-{
-    public int node;
-    public double weight;
-
-    WeightedNode( int node, double distance )
-    {
-        this.node = node;
-        this.weight = distance;
-    }
-
-    @Override
-    public int compareTo( WeightedNode o )
-    {
-        return Double.compare(weight, o.weight);
-    }
-
-    @Override
-    public String toString()
-    {
-        return node + " weight is " + weight;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/trees/QTBranchNode.java b/core/src/main/java/com/graphhopper/trees/QTBranchNode.java
deleted file mode 100644
index 7f9ba39696..0000000000
--- a/core/src/main/java/com/graphhopper/trees/QTBranchNode.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.trees;
-
-import com.graphhopper.util.Helper;
-
-/**
- * @author Peter Karich
- */
-class QTBranchNode<V> implements QTNode<V>
-{
-    QTNode<V> node0;
-    QTNode<V> node1;
-    QTNode<V> node2;
-    QTNode<V> node3;
-
-    public QTBranchNode()
-    {
-    }
-
-    @Override
-    public final QTNode<V> get( int num )
-    {
-        switch (num)
-        {
-            case 0:
-                return node0;
-            case 1:
-                return node1;
-            case 2:
-                return node2;
-            default:
-                return node3;
-        }
-    }
-
-    @Override
-    public void set( int num, QTNode<V> n )
-    {
-        switch (num)
-        {
-            case 0:
-                node0 = n;
-                return;
-            case 1:
-                node1 = n;
-                return;
-            case 2:
-                node2 = n;
-                return;
-            default:
-                node3 = n;
-                return;
-        }
-    }
-
-    @Override
-    public final boolean hasData()
-    {
-        return false;
-    }
-
-    @Override
-    public String toString()
-    {
-        return "B 0:" + node0.hasData() + " 1:" + node1.hasData() + " 2:" + node2.hasData() + " 3:" + node3.hasData();
-    }
-
-    @Override
-    public long getMemoryUsageInBytes( int factor )
-    {
-        // recursivly fetch the results
-        long all = 4 * Helper.getSizeOfObjectRef(factor);
-        if (node0 != null)
-        {
-            all += node0.getMemoryUsageInBytes(factor);
-        }
-        if (node1 != null)
-        {
-            all += node1.getMemoryUsageInBytes(factor);
-        }
-        if (node2 != null)
-        {
-            all += node2.getMemoryUsageInBytes(factor);
-        }
-        if (node3 != null)
-        {
-            all += node3.getMemoryUsageInBytes(factor);
-        }
-        return all;
-    }
-
-    @Override
-    public int count()
-    {
-        int all = 0;
-        if (node0 != null)
-        {
-            all += node0.count();
-        }
-        if (node1 != null)
-        {
-            all += node1.count();
-        }
-        if (node2 != null)
-        {
-            all += node2.count();
-        }
-        if (node3 != null)
-        {
-            all += node3.count();
-        }
-        return all;
-    }
-
-    @Override
-    public long getEmptyEntries( boolean onlyBranches )
-    {
-        int all = 0;
-        if (node0 == null)
-        {
-            all++;
-        } else
-        {
-            all += node0.getEmptyEntries(onlyBranches);
-        }
-
-        if (node1 == null)
-        {
-            all++;
-        } else
-        {
-            all += node1.getEmptyEntries(onlyBranches);
-        }
-
-        if (node2 == null)
-        {
-            all++;
-        } else
-        {
-            all += node2.getEmptyEntries(onlyBranches);
-        }
-
-        if (node3 == null)
-        {
-            all++;
-        } else
-        {
-            all += node3.getEmptyEntries(onlyBranches);
-        }
-        return all;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/trees/QTDataNode.java b/core/src/main/java/com/graphhopper/trees/QTDataNode.java
deleted file mode 100644
index 90d12625e2..0000000000
--- a/core/src/main/java/com/graphhopper/trees/QTDataNode.java
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.trees;
-
-import com.graphhopper.geohash.SpatialKeyAlgo;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.shapes.GHPoint;
-
-/**
- * @author Peter Karich
- */
-class QTDataNode<V> implements QTNode<V>
-{
-    long[] keys;
-    /**
-     * Use 'null' to mark the end of the array and to avoid an additional capacity int
-     */
-    V[] values;
-
-    @SuppressWarnings("unchecked")
-    public QTDataNode( int entries )
-    {
-        keys = new long[entries];
-        values = (V[]) new Object[entries];
-    }
-
-    @Override
-    public final boolean hasData()
-    {
-        return true;
-    }
-
-    public boolean isEmpty()
-    {
-        return values[0] == null;
-    }
-
-    public boolean isFull()
-    {
-        return count() == values.length;
-    }
-
-    public int remove( long key )
-    {
-        int removed = 0;
-        for (int i = 0; i < values.length;)
-        {
-            if (values[i] == null)
-            {
-                break;
-            }
-            if (keys[i] == key)
-            {
-                // is array copy more efficient?
-                int max = values.length - 1;
-                int j = i;
-                for (; j < max; j++)
-                {
-                    keys[j] = keys[j + 1];
-                    values[j] = values[j + 1];
-                }
-                // new end
-                values[j] = null;
-                removed++;
-            } else
-            {
-                i++;
-            }
-        }
-        return removed;
-    }
-
-    /**
-     * @return true if overflow necessary
-     */
-    public boolean add( long key, V value )
-    {
-        for (int i = 0; i < values.length; i++)
-        {
-            if (values[i] == null)
-            {
-                keys[i] = key;
-                values[i] = value;
-                i++;
-                if (i < values.length)
-                {
-                    values[i] = null;
-                }
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * @return true if data is full
-     */
-    public boolean overwriteFrom( int num, long bitPosition, QTDataNode<V> dn, long key, V value )
-    {
-        int counter = 0;
-        long nextBitPos = bitPosition >>> 1;
-        int tmp = (key & bitPosition) == 0 ? 0 : 2;
-        if ((key & nextBitPos) != 0)
-        {
-            tmp++;
-        }
-
-        if (tmp == num)
-        {
-            keys[counter] = key;
-            values[counter] = value;
-            counter++;
-        }
-        for (int i = 0; i < dn.values.length; i++)
-        {
-            if (dn.values[i] == null)
-            {
-                break;
-            }
-            tmp = (dn.keys[i] & bitPosition) == 0 ? 0 : 2;
-            if ((dn.keys[i] & nextBitPos) != 0)
-            {
-                tmp++;
-            }
-
-            if (tmp == num)
-            {
-                if (counter >= values.length)
-                {
-                    return true;
-                }
-                keys[counter] = dn.keys[i];
-                values[counter] = dn.values[i];
-                counter++;
-            }
-        }
-        // set last entry to null
-        if (counter < values.length)
-        {
-            values[counter] = null;
-        }
-        return false;
-    }
-
-    V getValue( long key )
-    {
-        for (int i = 0; i < values.length; i++)
-        {
-            if (values[i] == null)
-            {
-                return null;
-            }
-            if (keys[i] == key)
-            {
-                return (V) values[i];
-            }
-        }
-        return null;
-    }
-
-    @Override
-    public QTNode<V> get( int num )
-    {
-        throw new UnsupportedOperationException("no branch node.");
-    }
-
-    @Override
-    public void set( int num, QTNode<V> n )
-    {
-        throw new UnsupportedOperationException("no branch node.");
-    }
-
-    @Override
-    public String toString()
-    {
-        StringBuilder sb = new StringBuilder("dn:").append(count()).append(" ");
-        for (int i = 0; i < keys.length; i++)
-        {
-            if (values[i] == null)
-            {
-                break;
-            }
-
-            sb.append(values[i]).append(" ");
-        }
-        return sb.toString();
-    }
-
-    public String toString( SpatialKeyAlgo algo )
-    {
-        StringBuilder sb = new StringBuilder("dn:").append(count()).append(" ");
-        GHPoint obj = new GHPoint();
-        for (int i = 0; i < values.length; i++)
-        {
-            if (values[i] == null)
-            {
-                break;
-            }
-            algo.decode(keys[i], obj);
-            sb.append(values[i]).append(":").append(obj).append(" ");
-        }
-        return sb.toString();
-    }
-
-    @Override
-    public long getMemoryUsageInBytes( int factor )
-    {
-        return Helper.getSizeOfLongArray(keys.length, factor) + Helper.getSizeOfLongArray(values.length, factor);
-    }
-
-    @Override
-    public long getEmptyEntries( boolean onlyBranches )
-    {
-        if (onlyBranches)
-        {
-            return 0;
-        }
-
-        return values.length - count();
-    }
-
-    @Override
-    public int count()
-    {
-        int i = 0;
-        for (; i < values.length; i++)
-        {
-            if (values[i] == null)
-            {
-                return i;
-            }
-        }
-        return i;
-    }
-
-    @SuppressWarnings("unchecked")
-    void ensure( int newSize )
-    {
-        long[] tmpKeys = new long[newSize];
-        Object[] tmpValues = new Object[newSize];
-        System.arraycopy(keys, 0, tmpKeys, 0, keys.length);
-        System.arraycopy(values, 0, tmpValues, 0, values.length);
-        keys = tmpKeys;
-        values = (V[]) tmpValues;
-    }
-
-    int count( long spatialKey )
-    {
-        int counter = 0;
-        for (int i = 0; i < values.length; i++)
-        {
-            if (spatialKey == keys[i])
-            {
-                counter++;
-            }
-            if (values[i] == null)
-            {
-                break;
-            }
-        }
-        return counter;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/trees/QTNode.java b/core/src/main/java/com/graphhopper/trees/QTNode.java
deleted file mode 100644
index 933e02fa79..0000000000
--- a/core/src/main/java/com/graphhopper/trees/QTNode.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.trees;
-
-/**
- * Avoid ugly casting and use the same interface for data and branch nodes. although not really any
- * method in common
- * <p/>
- * @author Peter Karich
- */
-interface QTNode<V>
-{
-    QTNode<V> get( int num );
-
-    void set( int num, QTNode<V> n );
-
-    boolean hasData();
-
-    /**
-     * This methods returns the memory usage for PerfTest without the memory of the values. I.e. you
-     * need to add sizeOf(V)*noOfNodes
-     * <p/>
-     * @param factor is 1 for 32 bit and 2 for 64 bit systems
-     */
-    long getMemoryUsageInBytes( int factor );
-
-    int count();
-
-    long getEmptyEntries( boolean onlyBranches );
-}
diff --git a/core/src/main/java/com/graphhopper/trees/QuadTree.java b/core/src/main/java/com/graphhopper/trees/QuadTree.java
deleted file mode 100644
index 735a29874a..0000000000
--- a/core/src/main/java/com/graphhopper/trees/QuadTree.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.trees;
-
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.shapes.CoordTrig;
-import com.graphhopper.util.shapes.Shape;
-import java.util.Collection;
-
-/**
- * A quad tree interface - think Map<latitude+longitude, V> with the possibility to get neighbouring
- * entries fast.
- * <p/>
- * @author Peter Karich
- */
-public interface QuadTree<V>
-{
-    /**
-     * The quadtree could be configured with implementation specific values. After this it needs to
-     * be configured.
-     * <p/>
-     * @throws RuntimeException could be thrown
-     */
-    QuadTree init( long maxItemsHint );
-
-    long getSize();
-
-    boolean isEmpty();
-
-    void add( double lat, double lon, V value );
-
-    int remove( double lat, double lon );
-
-    /**
-     * @return The nodes matching the specified latitude and longitude. If value is null all values
-     * will be returned
-     */
-    Collection<CoordTrig<V>> getNodesFromValue( double lat, double lon, V value );
-
-    /**
-     * @return points near the specified latitude/longitude
-     */
-    Collection<CoordTrig<V>> getNodes( double lat, double lon, double distanceInKm );
-
-    Collection<CoordTrig<V>> getNodes( Shape boundingBox );
-
-    void clear();
-
-    /**
-     * For debugging purposes
-     */
-    String toDetailString();
-
-    long getMemoryUsageInBytes( int factor );
-
-    /**
-     * Good for memory estimation
-     */
-    long getEmptyEntries( boolean onlyBranches );
-
-    class Util
-    {
-        public static void fill( QuadTree<Long> quadTree, Graph graph )
-        {
-            int locs = graph.getNodes();
-            for (int i = 0; i < locs; i++)
-            {
-                double lat = graph.getLatitude(i);
-                double lon = graph.getLongitude(i);
-                quadTree.add(lat, lon, 1L);
-            }
-        }
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/trees/QuadTreeSimple.java b/core/src/main/java/com/graphhopper/trees/QuadTreeSimple.java
deleted file mode 100644
index 6db4012fa2..0000000000
--- a/core/src/main/java/com/graphhopper/trees/QuadTreeSimple.java
+++ /dev/null
@@ -1,498 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.trees;
-
-import com.graphhopper.geohash.SpatialKeyAlgo;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.Circle;
-import com.graphhopper.util.shapes.CoordTrig;
-import com.graphhopper.util.shapes.CoordTrigObjEntry;
-import com.graphhopper.util.shapes.Shape;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * A simple implementation of a spatial index via a spatial key trie - the normal java way (a bit
- * memory intensive with all those object references).
- * <p/>
- * TODO depth is too large!
- * <p/>
- * The latitude and longitude is encoded via our spatial key - see SpatialKeyAlgo for more details.
- * <p/>
- * If the branch node would have only 2 children then it would be a binary tree - we would need to
- * shift only once. If the branch node would have 8 children then it would be an oct tree - shifting
- * 3 times.
- * <p/>
- * Warning: cannot store null values - an exception will be thrown.
- * <p/>
- * Duplicates allowed.
- * <p/>
- * @author Peter Karich
- */
-public class QuadTreeSimple<T> implements QuadTree<T>
-{
-    private static class Acceptor<T> implements LeafWorker<T>
-    {
-        public final List<CoordTrig<T>> result = new ArrayList<CoordTrig<T>>();
-        SpatialKeyAlgo algo;
-
-        public Acceptor( SpatialKeyAlgo algo )
-        {
-            this.algo = algo;
-        }
-
-        @Override
-        public void doWork( QTDataNode<T> dataNode, int i )
-        {
-            CoordTrigObjEntry<T> entry = new CoordTrigObjEntry<T>();
-            algo.decode(dataNode.keys[i], entry);
-            if (accept(entry))
-            {
-                entry.setValue(dataNode.values[i]);
-                result.add(entry);
-            }
-        }
-
-        public boolean accept( CoordTrig<T> entry )
-        {
-            return true;
-        }
-    }
-    private final int mbits;
-    private final long globalMaxBit;
-    private final SpatialKeyAlgo algo;
-    private final int entriesPerLeaf;
-    private DistanceCalc calc = new DistanceCalcEarth();
-    private int size;
-    private QTNode<T> root;
-
-    public QuadTreeSimple()
-    {
-        this(1, 64);
-    }
-
-    public QuadTreeSimple( int entriesPerLeafNode )
-    {
-        this(entriesPerLeafNode, 64);
-    }
-
-    public QuadTreeSimple( int entriesPerLeafNode, int bitsForLatLon )
-    {
-        mbits = bitsForLatLon;
-        entriesPerLeaf = entriesPerLeafNode;
-        globalMaxBit = 1L << (bitsForLatLon - 1);
-        algo = new SpatialKeyAlgo(bitsForLatLon);
-    }
-
-    public QuadTreeSimple setCalcDistance( DistanceCalc dist )
-    {
-        this.calc = dist;
-        return this;
-    }
-
-    @Override
-    public long getSize()
-    {
-        return size;
-    }
-
-    @Override
-    public QuadTreeSimple init( long maxItemsHint )
-    {
-        return this;
-    }
-
-    @Override
-    public void add( double lat, double lon, T value )
-    {
-        if (value == null)
-        {
-            throw new IllegalArgumentException("This quad tree does not support null values");
-        }
-
-        long spatialKey = algo.encode(lat, lon);
-        long maxBit = globalMaxBit;
-        if (root == null)
-        {
-            size++;
-            QTDataNode<T> d = new QTDataNode<T>(entriesPerLeaf);
-            d.add(spatialKey, value);
-            root = d;
-            return;
-        }
-        QTBranchNode<T> previousBranch = null;
-        int previousNum = -1;
-        QTNode<T> current = root;
-        while (maxBit != 0)
-        {
-            if (current.hasData())
-            {
-                addData(spatialKey, value, current, previousBranch, previousNum, maxBit);
-                return;
-            }
-
-            previousBranch = (QTBranchNode<T>) current;
-            // latitude
-            previousNum = (spatialKey & maxBit) == 0 ? 0 : 2;
-            maxBit >>>= 1;
-            // longitude
-            if ((spatialKey & maxBit) == 0)
-            {
-                current = previousNum == 0 ? previousBranch.node0 : previousBranch.node2;
-            } else
-            {
-                current = previousNum == 0 ? previousBranch.node1 : previousBranch.node3;
-                previousNum++;
-            }
-            maxBit >>>= 1;
-            if (current == null)
-            {
-                current = new QTDataNode<T>(entriesPerLeaf);
-                previousBranch.set(previousNum, current);
-            }
-        }
-
-        throw new UnsupportedOperationException("Cannot put element? Too many entries per area? Try increasing entries per leaf! "
-                + lat + "," + lon + " spatial key:" + spatialKey + " value:" + value + " size:" + size);
-    }
-
-    private void addData( long spatialKey, T value, QTNode<T> current, QTNode<T> previousBranch,
-            int previousNum, long maxBit )
-    {
-        size++;
-
-        QTDataNode<T> dataNode = (QTDataNode<T>) current;
-        boolean overflow = dataNode.add(spatialKey, value);
-        if (!overflow)
-        {
-            return;
-        }
-
-        QTBranchNode<T> n = new QTBranchNode<T>();
-        if (previousBranch != null)
-        {
-            previousBranch.set(previousNum, n);
-        } else
-        {
-            root = n;
-        }
-
-        int num;
-        MAIN:
-        for (; maxBit != 0; maxBit >>>= 2)
-        {
-            for (num = 0; num < 4; num++)
-            {
-                QTDataNode<T> dn = new QTDataNode<T>(entriesPerLeaf);
-                overflow = dn.overwriteFrom(num, maxBit, dataNode, spatialKey, value);
-                if (overflow)
-                {
-                    if ((maxBit & 0x3) != 0)
-                    {
-                        // if the dataNode contains duplicates or if too many nodes have a very similar position
-                        // it couldn't be splitted, so we need to increase size
-                        dn.ensure(dn.keys.length + 1);
-                        dn.add(spatialKey, value);
-                        n.set(num, dn);
-                        continue;
-                    } else
-                    {
-                        // current node would be full so divide it again
-                        QTBranchNode<T> tmp = new QTBranchNode<T>();
-                        n.set(num, tmp);
-                        n = tmp;
-                        continue MAIN;
-                    }
-                } else if (!dn.isEmpty())
-                {
-                    n.set(num, dn);
-                    continue;
-                }
-            }
-
-            return;
-        }
-
-        throw new AssertionError("Cannot happen? datanode:" + dataNode + " new entry:" + spatialKey + "->" + value);
-    }
-
-    @Override
-    public int remove( double lat, double lon )
-    {
-        if (root == null)
-        {
-            return 0;
-        }
-
-        final long spatialKey = algo.encode(lat, lon);
-        final AtomicInteger removedWrapper = new AtomicInteger(0);
-        LeafWorker<T> worker = new LeafWorker<T>()
-        {
-            @Override
-            public void doWork( QTDataNode<T> entry, int i )
-            {
-                int removed = entry.remove(spatialKey);
-                if (removed > 0)
-                {
-                    removedWrapper.addAndGet(removed);
-                    size -= removed;
-                }
-            }
-        };
-        double err = 1.0 / Math.pow(10, algo.getExactPrecision());
-        getNeighbours(BBox.createEarthMax(), new BBox(lon - err, lon + err, lat - err, lat + err), root, worker);
-        return removedWrapper.get();
-    }
-
-    @Override
-    public boolean isEmpty()
-    {
-        return size == 0;
-    }
-
-    @Override
-    public Collection<CoordTrig<T>> getNodesFromValue( final double lat, final double lon, final T value )
-    {
-        if (root == null)
-        {
-            return Collections.emptyList();
-        }
-
-        final long spatialKey = algo.encode(lat, lon);
-        final List<CoordTrig<T>> nodes = new ArrayList<CoordTrig<T>>(1);
-        LeafWorker<T> worker = new LeafWorker<T>()
-        {
-            @Override
-            public void doWork( QTDataNode<T> dataNode, int i )
-            {
-                if (value != null && !value.equals(dataNode.values[i]))
-                {
-                    return;
-                }
-
-                if (dataNode.keys[i] == spatialKey)
-                {
-                    CoordTrig<T> ret = new CoordTrigObjEntry<T>();
-                    algo.decode(dataNode.keys[i], ret);
-                    ret.setValue(dataNode.values[i]);
-                    nodes.add(ret);
-                }
-            }
-        };
-        double err = 1.0 / Math.pow(10, algo.getExactPrecision());
-        getNeighbours(BBox.createEarthMax(), new BBox(lon - err, lon + err, lat - err, lat + err), root, worker);
-        return nodes;
-    }
-
-    @Override
-    public Collection<CoordTrig<T>> getNodes( double lat, double lon, double distanceInMeter )
-    {
-        return getNodes(new Circle(lat, lon, distanceInMeter, calc));
-    }
-
-    @Override
-    public Collection<CoordTrig<T>> getNodes( final Shape boundingBox )
-    {
-        if (root == null)
-        {
-            return Collections.emptyList();
-        }
-
-        Acceptor<T> worker = new Acceptor<T>(algo)
-        {
-            @Override
-            public boolean accept( CoordTrig<T> entry )
-            {
-                return boundingBox.contains(entry.lat, entry.lon);
-            }
-        };
-        getNeighbours(BBox.createEarthMax(), boundingBox, root, worker);
-        return worker.result;
-    }
-
-    @SuppressWarnings("unchecked")
-    private void getNeighbours( BBox nodeBB, Shape searchRect, QTNode<T> current, LeafWorker<T> worker )
-    {
-        if (current.hasData())
-        {
-            QTDataNode<T> dataNode = (QTDataNode<T>) current;
-            for (int i = 0; i < dataNode.values.length; i++)
-            {
-                if (dataNode.values[i] == null)
-                {
-                    break;
-                }
-
-                worker.doWork(dataNode, i);
-            }
-            return;
-        }
-
-        double lat12 = (nodeBB.maxLat + nodeBB.minLat) / 2;
-        double lon12 = (nodeBB.minLon + nodeBB.maxLon) / 2;
-
-        // top-left - see SpatialKeyAlgo that latitude goes from bottom to top and is 1 if on top
-        // 10 11
-        // 00 01
-        QTNode<T> node10 = current.get(2);
-        if (node10 != null)
-        {
-            BBox nodeRect10 = new BBox(nodeBB.minLon, lon12, lat12, nodeBB.maxLat);
-            if (searchRect.intersect(nodeRect10))
-            {
-                getNeighbours(nodeRect10, searchRect, node10, worker);
-            }
-        }
-
-        // top-right
-        QTNode<T> node11 = current.get(3);
-        if (node11 != null)
-        {
-            BBox nodeRect11 = new BBox(lon12, nodeBB.maxLon, lat12, nodeBB.maxLat);
-            if (searchRect.intersect(nodeRect11))
-            {
-                getNeighbours(nodeRect11, searchRect, node11, worker);
-            }
-        }
-
-        // bottom-left
-        QTNode<T> node00 = current.get(0);
-        if (node00 != null)
-        {
-            BBox nodeRect00 = new BBox(nodeBB.minLon, lon12, nodeBB.minLat, lat12);
-            if (searchRect.intersect(nodeRect00))
-            {
-                getNeighbours(nodeRect00, searchRect, node00, worker);
-            }
-        }
-
-        // bottom-right
-        QTNode<T> node01 = current.get(1);
-        if (node01 != null)
-        {
-            BBox nodeRect01 = new BBox(lon12, nodeBB.maxLon, nodeBB.minLat, lat12);
-            if (searchRect.intersect(nodeRect01))
-            {
-                getNeighbours(nodeRect01, searchRect, node01, worker);
-            }
-        }
-    }
-
-    @Override
-    public void clear()
-    {
-        root = null;
-        size = 0;
-    }
-
-    @Override
-    public String toDetailString()
-    {
-        StringBuilder sb = new StringBuilder();
-        List<QTNode<T>> newList = new ArrayList<QTNode<T>>();
-        List<QTNode<T>> list = new ArrayList<QTNode<T>>();
-        list.add(root);
-        int counter = 0;
-        int level = 0;
-        while (true)
-        {
-            if (counter >= list.size())
-            {
-                if (newList.isEmpty())
-                {
-                    break;
-                }
-
-                level++;
-                sb.append(level).append("\n");
-                list.clear();
-                List<QTNode<T>> tmp = list;
-                list = newList;
-                newList = tmp;
-                counter = 0;
-            }
-
-            toDetailString(list.get(counter), sb, newList);
-            counter++;
-        }
-        sb.append("\n");
-        return sb.toString();
-    }
-
-    private void toDetailString( QTNode<T> current, StringBuilder sb, List<QTNode<T>> list )
-    {
-        if (current == null)
-        {
-            sb.append("dn:null\t");
-            return;
-        }
-
-        if (current.hasData())
-        {
-            sb.append(((QTDataNode) current).toString(algo)).append("\t");
-        } else
-        {
-            sb.append("B\t");
-            list.add(current.get(2));
-            list.add(current.get(3));
-            list.add(current.get(0));
-            list.add(current.get(1));
-        }
-    }
-
-    @Override
-    public long getMemoryUsageInBytes( int factor )
-    {
-        QTNode node = root;
-
-        // + some bytes for the deep objects
-        long offset = 3 * 4 + 8 + 3 * Helper.getSizeOfObjectRef(factor);
-        if (root != null)
-        {
-            return node.getMemoryUsageInBytes(factor) + offset;
-        }
-
-        return offset;
-    }
-
-    @Override
-    public long getEmptyEntries( boolean onlyBranches )
-    {
-        if (root != null)
-        {
-            return root.getEmptyEntries(onlyBranches);
-        }
-
-        return 0;
-    }
-
-    public int count()
-    {
-        if (root != null)
-        {
-            return root.count();
-        }
-        return 0;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
new file mode 100644
index 0000000000..5e98e3ca80
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -0,0 +1,139 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+/**
+ * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
+ * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
+ * <p>
+ * @author Johannes Pelzer
+ * @author Peter Karich
+ */
+public class AngleCalc
+{
+    private final static double PI_4 = Math.PI / 4.0;
+    private final static double PI3_4 = 3.0 * Math.PI / 4.0;
+
+    static final double atan2( double y, double x )
+    {
+        // kludge to prevent 0/0 condition
+        double absY = Math.abs(y) + 1e-10;
+        double r, angle;
+        if (x < 0.0)
+        {
+            r = (x + absY) / (absY - x);
+            angle = PI3_4;
+        } else
+        {
+            r = (x - absY) / (x + absY);
+            angle = PI_4;
+        }
+
+        angle += (0.1963 * r * r - 0.9817) * r;
+        if (y < 0.0)
+            // negate if in quad III or IV
+            return -angle;
+        return angle;
+    }
+
+    /**
+     * Return orientation of line relative to east.
+     * <p>
+     * @return Orientation in interval -pi to +pi where 0 is east
+     */
+    public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
+    {
+        return atan2((lat2 - lat1), (lon2 - lon1));
+    }
+
+    /**
+     * Change the representation of an orientation, so the difference to the given baseOrientation
+     * will be smaller or equal to PI (180 degree). This is achieved by adding or substracting a
+     * 2*PI, so the direction of the orientation will not be changed
+     */
+    public double alignOrientation( double baseOrientation, double orientation )
+    {
+        double resultOrientation;
+        if (baseOrientation >= 0)
+        {
+            if (orientation < -Math.PI + baseOrientation)
+                resultOrientation = orientation + 2 * Math.PI;
+            else
+                resultOrientation = orientation;
+
+        } else
+        {
+            if (orientation > +Math.PI + baseOrientation)
+                resultOrientation = orientation - 2 * Math.PI;
+            else
+                resultOrientation = orientation;
+        }
+        return resultOrientation;
+    }
+
+    /**
+     * Calculate the azimuth in degree for a line given by two coordinates. Direction in 'degree'
+     * where 0 is north, 90 is east, 180 is south and 270 is west.
+     */
+    double calcAzimuth( double lat1, double lon1, double lat2, double lon2 )
+    {
+        double orientation = -calcOrientation(lat1, lon1, lat2, lon2);
+        orientation = Helper.round4(orientation + Math.PI / 2);
+        if (orientation < 0)
+            orientation += 2 * Math.PI;
+
+        return Math.toDegrees(orientation);
+    }
+
+    String azimuth2compassPoint( double azimuth )
+    {
+
+        String cp;
+        double slice = 360.0 / 16;
+        if (azimuth < slice)
+        {
+            cp = "N";
+        } else if (azimuth < slice * 3)
+        {
+            cp = "NE";
+        } else if (azimuth < slice * 5)
+        {
+            cp = "E";
+        } else if (azimuth < slice * 7)
+        {
+            cp = "SE";
+        } else if (azimuth < slice * 9)
+        {
+            cp = "S";
+        } else if (azimuth < slice * 11)
+        {
+            cp = "SW";
+        } else if (azimuth < slice * 13)
+        {
+            cp = "W";
+        } else if (azimuth < slice * 15)
+        {
+            cp = "NW";
+        } else
+        {
+            cp = "N";
+        }
+        return cp;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index d427f2468d..11957181dd 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -107,6 +107,13 @@ public final void fromFloat( byte[] bytes, float value, int offset )
         fromInt(bytes, Float.floatToRawIntBits(value), offset);
     }
 
+    public final short toShort( byte[] b )
+    {
+        return toShort(b, 0);
+    }
+
+    public abstract short toShort( byte[] b, int offset );
+
     public final int toInt( byte[] b )
     {
         return toInt(b, 0);
@@ -126,6 +133,20 @@ public final void fromInt( byte[] bytes, int value )
         fromInt(bytes, value, 0);
     }
 
+    public final byte[] fromShort( short value )
+    {
+        byte[] bytes = new byte[4];
+        fromShort(bytes, value, 0);
+        return bytes;
+    }
+
+    public final void fromShort( byte[] bytes, short value )
+    {
+        fromShort(bytes, value, 0);
+    }
+
+    public abstract void fromShort( byte[] bytes, short value, int offset );
+
     public abstract void fromInt( byte[] bytes, int value, int offset );
 
     public final long toLong( byte[] b )
@@ -174,6 +195,9 @@ public final long fromBitString2Long( String str )
 
     public abstract byte[] fromBitString( String str );
 
+    /**
+     * Similar to Long.toBinaryString
+     */
     public final String toBitString( long value )
     {
         return toBitString(value, 64);
@@ -244,6 +268,21 @@ public final long reverse( long value, int maxBits )
         return res;
     }
 
+    public final int getIntLow( long longValue )
+    {
+        return (int) (longValue & 0xFFFFFFFFL);
+    }
+
+    public final int getIntHigh( long longValue )
+    {
+        return (int) (longValue >> 32);
+    }
+
+    public final long combineIntsToLong( int intLow, int intHigh )
+    {
+        return ((long) intHigh << 32) | (intLow & 0xFFFFFFFFL);
+    }
+
     public final long reverseLeft( long value, int maxBits )
     {
         long res = 0;
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilBig.java b/core/src/main/java/com/graphhopper/util/BitUtilBig.java
index 1c57166d31..ee3dfcd59e 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtilBig.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilBig.java
@@ -28,11 +28,24 @@
     {
     }
 
+    @Override
+    public final short toShort( byte[] b, int offset )
+    {
+        return (short) ((b[offset] & 0xFF) << 8 | (b[offset + 1] & 0xFF));
+    }
+
     @Override
     public final int toInt( byte[] b, int offset )
     {
-        return (b[offset] & 0xFF) << 24 | (b[++offset] & 0xFF) << 16 | (b[++offset] & 0xFF) << 8
-                | (b[++offset] & 0xFF);
+        return (b[offset] & 0xFF) << 24 | (b[++offset] & 0xFF) << 16
+                | (b[++offset] & 0xFF) << 8 | (b[++offset] & 0xFF);
+    }
+
+    @Override
+    public void fromShort( byte[] bytes, short value, int offset )
+    {
+        bytes[offset] = (byte) (value >> 8);
+        bytes[offset + 1] = (byte) (value);
     }
 
     @Override
@@ -121,7 +134,13 @@ public String toBitString( byte[] bytes )
      */
     final long reversePart( long v, int maxBits )
     {
-        long rest = v & (~((1 << maxBits) - 1));
+        long rest = v & (~((1L << maxBits) - 1));
         return rest | reverse(v, maxBits);
     }
+
+    @Override
+    public String toString()
+    {
+        return "big";
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
index 5d7f65cbd6..e4ac8415d9 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtilLittle.java
@@ -28,11 +28,24 @@
     {
     }
 
+    @Override
+    public final short toShort( byte[] b, int offset )
+    {
+        return (short) ((b[offset + 1] & 0xFF) << 8 | (b[offset] & 0xFF));
+    }
+
     @Override
     public final int toInt( byte[] b, int offset )
     {
-        return (b[offset + 3] & 0xFF) << 24 | (b[offset + 2] & 0xFF) << 16 | (b[offset + 1] & 0xFF) << 8
-                | (b[offset] & 0xFF);
+        return (b[offset + 3] & 0xFF) << 24 | (b[offset + 2] & 0xFF) << 16
+                | (b[offset + 1] & 0xFF) << 8 | (b[offset] & 0xFF);
+    }
+
+    @Override
+    public void fromShort( byte[] bytes, short value, int offset )
+    {
+        bytes[offset + 1] = (byte) (value >> 8);
+        bytes[offset] = (byte) (value);
     }
 
     @Override
@@ -116,4 +129,10 @@ public String toBitString( byte[] bytes )
         }
         return sb.toString();
     }
+
+    @Override
+    public String toString()
+    {
+        return "little";
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
new file mode 100644
index 0000000000..05d3a3d009
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
@@ -0,0 +1,55 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import com.graphhopper.coll.GHBitSet;
+
+/**
+ * Implementattion of breadth first search (BFS)
+ * <p/>
+ * @author Peter Karich
+ */
+public class BreadthFirstSearch extends XFirstSearch
+{
+    @Override
+    public void start( EdgeExplorer explorer, int startNode )
+    {
+        SimpleIntDeque fifo = new SimpleIntDeque();
+        GHBitSet visited = createBitSet();
+        visited.add(startNode);
+        fifo.push(startNode);
+        int current;
+        while (!fifo.isEmpty())
+        {
+            current = fifo.pop();
+            if (!goFurther(current))
+                continue;
+
+            EdgeIterator iter = explorer.setBaseNode(current);
+            while (iter.next())
+            {
+                int connectedId = iter.getAdjNode();
+                if (checkAdjacent(iter) && !visited.contains(connectedId))
+                {
+                    visited.add(connectedId);
+                    fifo.push(connectedId);
+                }
+            }
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index 70d4cef0bf..6c4801f816 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -31,110 +31,25 @@
  * <p/>
  * @author Peter Karich
  */
-public class CmdArgs
+public class CmdArgs extends PMap
 {
-    private final Map<String, String> map;
 
     public CmdArgs()
     {
-        this(new LinkedHashMap<String, String>(5));
     }
 
     public CmdArgs( Map<String, String> map )
     {
-        this.map = map;
+        super(map);
     }
 
-    public CmdArgs put( String key, String str )
+    @Override
+    public CmdArgs put( String key, Object str )
     {
-        map.put(key.toLowerCase(), str);
+        super.put(key, str);
         return this;
     }
 
-    public long getLong( String key, long _default )
-    {
-        String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
-                return Long.parseLong(str);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return _default;
-    }
-
-    public int getInt( String key, int _default )
-    {
-        String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
-                return Integer.parseInt(str);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return _default;
-    }
-
-    public boolean getBool( String key, boolean _default )
-    {
-        String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
-                return Boolean.parseBoolean(str);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return _default;
-    }
-
-    public double getDouble( String key, double _default )
-    {
-        String str = get(key);
-        if (!Helper.isEmpty(str))
-        {
-            try
-            {
-                return Double.parseDouble(str);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return _default;
-    }
-
-    public String get( String key, String _default )
-    {
-        String str = get(key);
-        if (Helper.isEmpty(str))
-        {
-            return _default;
-        }
-        return str;
-    }
-
-    String get( String key )
-    {
-        if (Helper.isEmpty(key))
-        {
-            return "";
-        }
-        String val = map.get(key.toLowerCase());
-        if (val == null)
-        {
-            return "";
-        }
-        return val;
-    }
-
     /**
      * @param fileStr the file name of config.properties
      * @param systemProperty the property name of the configuration. E.g. -Dgraphhopper.config
@@ -150,7 +65,7 @@ public static CmdArgs readFromConfig( String fileStr, String systemProperty ) th
 
         Map<String, String> map = new LinkedHashMap<String, String>();
         Helper.loadProperties(map, new InputStreamReader(new FileInputStream(
-                new File(configLocation).getAbsoluteFile()), "UTF-8"));
+                new File(configLocation).getAbsoluteFile()), Helper.UTF_CS));
         CmdArgs args = new CmdArgs();
         args.merge(map);
 
@@ -198,32 +113,26 @@ public static CmdArgs read( String[] args )
         return new CmdArgs(map);
     }
 
-    public CmdArgs merge( CmdArgs read )
-    {
-        return merge(read.map);
-    }
-
-    CmdArgs merge( Map<String, String> map )
+    /**
+     * Command line configuration overwrites the ones in the config file.
+     * <p>
+     * @return a new CmdArgs object if necessary.
+     */
+    public static CmdArgs readFromConfigAndMerge( CmdArgs args, String configKey, String configSysAttr )
     {
-        for (Entry<String, String> e : map.entrySet())
+        String configVal = args.get(configKey, "");
+        if (!Helper.isEmpty(configVal))
         {
-            if (Helper.isEmpty(e.getKey()))
+            try
             {
-                continue;
+                CmdArgs tmp = CmdArgs.readFromConfig(configVal, configSysAttr);
+                tmp.merge(args);
+                return tmp;
+            } catch (Exception ex)
+            {
+                throw new RuntimeException(ex);
             }
-            this.map.put(e.getKey().toLowerCase(), e.getValue());
         }
-        return this;
-    }
-
-    public boolean has( String key )
-    {
-        return map.containsKey(key);
-    }
-
-    @Override
-    public String toString()
-    {
-        return map.toString();
+        return args;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 25914100a9..2da8f5e766 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -50,9 +50,9 @@
     public static final String OS_ARCH = System.getProperty("os.arch");
     public static final String OS_VERSION = System.getProperty("os.version");
     public static final String JAVA_VENDOR = System.getProperty("java.vendor");
-    public static final int VERSION_NODE = 2;
-    public static final int VERSION_EDGE = 3;
-    public static final int VERSION_GEOMETRY = 2;
+    public static final int VERSION_NODE = 4;
+    public static final int VERSION_EDGE = 12;
+    public static final int VERSION_GEOMETRY = 3;
     public static final int VERSION_LOCATION_IDX = 2;
     public static final int VERSION_NAME_IDX = 2;
     /**
@@ -73,7 +73,7 @@ public static String getVersions()
         String version = "0.0";
         try
         {
-            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/version"), "UTF-8"));
+            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/version"), Helper.UTF_CS));
             version = v.get(0);
         } catch (Exception ex)
         {
@@ -103,7 +103,7 @@ public static String getVersions()
         String buildDate = "";
         try
         {
-            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/builddate"), "UTF-8"));
+            List<String> v = readFile(new InputStreamReader(Helper.class.getResourceAsStream("/builddate"), Helper.UTF_CS));
             buildDate = v.get(0);
         } catch (Exception ex)
         {
diff --git a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
new file mode 100644
index 0000000000..987657798a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
@@ -0,0 +1,62 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import com.graphhopper.coll.GHBitSet;
+import gnu.trove.stack.array.TIntArrayStack;
+
+/**
+ * Implementation of depth first search (DFS) by LIFO queue
+ * <p/>
+ * @author Peter Karich
+ * @author Jan Sölter
+ */
+public class DepthFirstSearch extends XFirstSearch
+{
+    /**
+     * beginning with startNode add all following nodes to LIFO queue. If node has been already
+     * explored before, skip reexploration.
+     */
+    @Override
+    public void start( EdgeExplorer explorer, int startNode )
+    {
+        TIntArrayStack stack = new TIntArrayStack();
+
+        GHBitSet explored = createBitSet();
+        stack.push(startNode);
+        int current;
+        while (stack.size() > 0)
+        {
+            current = stack.pop();
+            if (!explored.contains(current) && goFurther(current))
+            {
+                EdgeIterator iter = explorer.setBaseNode(current);
+                while (iter.next())
+                {
+                    int connectedId = iter.getAdjNode();
+                    if (checkAdjacent(iter))
+                    {
+                        stack.push(connectedId);
+                    }
+                }
+                explored.add(current);
+            }
+        }
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
index 0a58b949f5..d0ea52f8a4 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
@@ -55,20 +55,23 @@
     double calcNormalizedDist( double fromLat, double fromLon, double toLat, double toLon );
 
     /**
-     * This method decides case 1: if we should use distance(r to edge) where r=(lat,lon) or case 2:
-     * min(distance(r to a), distance(r to b)) where edge=(a to b)
-     * <p/>
-     * @return true for case 1
+     * This method decides for case 1: if we should use distance(r to edge) where r=(lat,lon) or
+     * case 2: min(distance(r to a), distance(r to b)) where edge=(a to b). Note that due to
+     * rounding errors it cannot properly detect if it is case 1 or 90°.
+     * <pre>
+     * case 1 (including ):
+     *   r
+     *  .
+     * a-------b
+     *
+     * case 2:
+     * r
+     *  .
+     *    a-------b
+     * </pre>
+     * <p>
+     * @return true for case 1 which is "on edge" or the special case of 90° to the edge
      */
-    // case 1:
-    //   r
-    //  . 
-    // a-------b
-    //    
-    // case 2:
-    // r
-    //  .
-    //    a-------b
     boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg );
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 1870deea66..7e21bb6055 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -103,9 +103,7 @@ public boolean isDateLineCrossOver( double lon1, double lon2 )
     public BBox createBBox( double lat, double lon, double radiusInMeter )
     {
         if (radiusInMeter <= 0)
-        {
             throw new IllegalArgumentException("Distance must not be zero or negative! " + radiusInMeter + " lat,lon:" + lat + "," + lon);
-        }
 
         // length of a circle at specified lat / dist
         double dLon = (360 / (calcCircumference(lat) / radiusInMeter));
@@ -216,21 +214,6 @@ else if (factor < 0)
         return new GHPoint(c_lat, c_lon / shrink_factor);
     }
 
-    /**
-     * This method decides case 1: if we should use distance(r to edge) where r=(lat,lon) or case 2:
-     * min(distance(r to a), distance(r to b)) where edge=(a to b)
-     * <p/>
-     * @return true for case 1
-     */
-    // case 1:
-    //   r
-    //  . 
-    // a-------b
-    //    
-    // case 2:
-    // r
-    //  .
-    //    a-------b
     @Override
     public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
@@ -268,10 +251,4 @@ public String toString()
     {
         return "EXACT";
     }
-
-    public static double round( double someDouble, int i )
-    {
-        double factor = Math.pow(10, i);
-        return Math.round(someDouble * factor) / factor;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
index 0804b7b26e..db35c29f03 100644
--- a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
+++ b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
@@ -18,7 +18,7 @@
 package com.graphhopper.util;
 
 /**
- * Simplyfies a list of points which are not too far away.
+ * Simplyfies a list of 2D points which are not too far away.
  * http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm
  * <p/>
  * Calling simplify is thread safe.
@@ -42,9 +42,9 @@ public void setApproximation( boolean a )
     {
         approx = a;
         if (approx)
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         else
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
     }
 
     /**
@@ -85,27 +85,6 @@ public int simplify( PointList points )
         return removed;
     }
 
-    /**
-     * compress list: move points into EMPTY slots
-     */
-    void compress( PointList list )
-    {
-        PointList pl = new PointList(list.getSize());
-        for (int i = 0; i < list.getSize(); i++)
-        {
-            if (Double.isNaN(list.getLatitude(i)))
-            {
-                continue;
-            }
-            pl.add(list.getLatitude(i), list.getLongitude(i));
-        }
-        list.clear();
-        for (int i = 0; i < pl.getSize(); i++)
-        {
-            list.add(pl.getLatitude(i), pl.getLongitude(i));
-        }
-    }
-
     /**
      * compress list: move points into EMPTY slots
      */
@@ -117,17 +96,16 @@ void compressNew( PointList points, int removed )
             if (Double.isNaN(points.getLatitude(currentIndex)))
             {
                 if (freeIndex < 0)
-                {
                     freeIndex = currentIndex;
-                }
+
                 continue;
             } else if (freeIndex < 0)
             {
                 continue;
             }
 
-            points.set(freeIndex, points.getLatitude(currentIndex), points.getLongitude(currentIndex));
-            points.set(currentIndex, Double.NaN, Double.NaN);
+            points.set(freeIndex, points.getLatitude(currentIndex), points.getLongitude(currentIndex), points.getElevation(currentIndex));
+            points.set(currentIndex, Double.NaN, Double.NaN, Double.NaN);
             // find next free index
             int max = currentIndex;
             int searchIndex = freeIndex + 1;
@@ -183,7 +161,7 @@ int simplify( PointList points, int fromIndex, int lastIndex )
         {
             for (int i = fromIndex + 1; i < lastIndex; i++)
             {
-                points.set(i, Double.NaN, Double.NaN);
+                points.set(i, Double.NaN, Double.NaN, Double.NaN);
                 counter++;
             }
         } else
@@ -193,4 +171,6 @@ int simplify( PointList points, int fromIndex, int lastIndex )
         }
         return counter;
     }
+
+    
 }
diff --git a/core/src/main/java/com/graphhopper/util/Downloader.java b/core/src/main/java/com/graphhopper/util/Downloader.java
index 12ef79d5e0..297a917ccb 100644
--- a/core/src/main/java/com/graphhopper/util/Downloader.java
+++ b/core/src/main/java/com/graphhopper/util/Downloader.java
@@ -27,13 +27,16 @@
 /**
  * @author Peter Karich
  */
-public class Downloader {
-
-    public static void main(String[] args) throws IOException {
+public class Downloader
+{
+    public static void main( String[] args ) throws IOException
+    {
         new Downloader("GraphHopper Downloader").downloadAndUnzip("http://graphhopper.com/public/maps/0.1/europe_germany_berlin.ghz", "somefolder",
-                new ProgressListener() {
+                new ProgressListener()
+                {
                     @Override
-                    public void update(long val) {
+                    public void update( long val )
+                    {
                         System.out.println("progress:" + val);
                     }
                 });
@@ -42,23 +45,26 @@ public void update(long val) {
     private final String userAgent;
     private String acceptEncoding = "gzip, deflate";
     private int timeout = 4000;
-    private int size = 1024 * 8;
 
-    public Downloader(String userAgent) {
+    public Downloader( String userAgent )
+    {
         this.userAgent = userAgent;
     }
 
-    public Downloader setTimeout(int timeout) {
+    public Downloader setTimeout( int timeout )
+    {
         this.timeout = timeout;
         return this;
     }
 
-    public Downloader setReferrer(String referrer) {
+    public Downloader setReferrer( String referrer )
+    {
         this.referrer = referrer;
         return this;
     }
 
-    public InputStream fetch(HttpURLConnection conn) throws IOException {
+    public InputStream fetch( HttpURLConnection conn ) throws IOException
+    {
         // create connection but before reading get the correct inputstream based on the compression
         conn.connect();
         String encoding = conn.getContentEncoding();
@@ -73,13 +79,16 @@ else if (encoding != null && encoding.equalsIgnoreCase("deflate"))
         return is;
     }
 
-    public InputStream fetch(String url) throws IOException {
+    public InputStream fetch( String url ) throws IOException
+    {
         return fetch((HttpURLConnection) createConnection(url));
     }
 
-    public HttpURLConnection createConnection(String urlStr) throws IOException {
+    public HttpURLConnection createConnection( String urlStr ) throws IOException
+    {
         URL url = new URL(urlStr);
         HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+        // conn.setDoInput(true); // Will yield in a POST request
         conn.setDoOutput(true);
         conn.setUseCaches(true);
         conn.setRequestProperty("Referrer", referrer);
@@ -92,36 +101,46 @@ public HttpURLConnection createConnection(String urlStr) throws IOException {
         return conn;
     }
 
-    public void downloadAndUnzip(String url, String to, final ProgressListener progressListener) throws IOException {
+    public void downloadFile( String url, String toFile ) throws IOException
+    {
+        HttpURLConnection conn = createConnection(url);
+        InputStream iStream = fetch(conn);
+        int size = 8 * 1024;
+        BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(toFile), size);
+        InputStream in = new BufferedInputStream(iStream, size);
+        try
+        {
+            byte[] buffer = new byte[size];
+            int numRead;
+            while ((numRead = in.read(buffer)) != -1)
+            {
+                writer.write(buffer, 0, numRead);
+            }
+        } finally
+        {
+            writer.close();
+            in.close();
+        }
+    }
+
+    public void downloadAndUnzip( String url, String toFolder, final ProgressListener progressListener ) throws IOException
+    {
         HttpURLConnection conn = createConnection(url);
         final int length = conn.getContentLength();
         InputStream iStream = fetch(conn);
 
-        new Unzipper().setSize(size).unzip(iStream, new File(to), new ProgressListener() {
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
+        {
             @Override
-            public void update(long sumBytes) {
+            public void update( long sumBytes )
+            {
                 progressListener.update((int) (100 * sumBytes / length));
             }
         });
     }
 
-    public String downloadAsString(String url) throws IOException {
-        return readString(fetch(url));
-    }
-
-    private String readString(InputStream inputStream) throws IOException {
-        String encoding = "UTF-8";
-        InputStream in = new BufferedInputStream(inputStream, size);
-        try {
-            byte[] buffer = new byte[size];
-            ByteArrayOutputStream output = new ByteArrayOutputStream();
-            int numRead;
-            while ((numRead = in.read(buffer)) != -1) {
-                output.write(buffer, 0, numRead);
-            }
-            return output.toString(encoding);
-        } finally {
-            in.close();
-        }
+    public String downloadAsString( String url ) throws IOException
+    {
+        return Helper.isToString(fetch(url));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index 8ee69b3a9a..a3f2107628 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -42,6 +42,8 @@
 {
     /**
      * To be called to go to the next edge state.
+     * <p>
+     * @return true if an edge state is available
      */
     boolean next();
 
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
index e6fd5f6257..e790ec8afb 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
@@ -94,11 +94,17 @@
 
     /**
      * Clones this EdgeIteratorState.
+     * <p>
+     * @param reverse if true a detached edgeState with reversed properties is created where base
+     * and adjacent nodes, flags and wayGeometry are in reversed order. See #162 for more details
+     * about why we need the new reverse parameter.
      */
-    EdgeIteratorState detach();
-    
+    EdgeIteratorState detach( boolean reverse );
+
     /**
-     * Copies the specified edge into the current one.
+     * Copies the properties of this edge into the specified edge. Does not change nodes!
+     * <p>
+     * @return the specified edge e
      */
-    void copyProperties(EdgeIteratorState edge);
+    EdgeIteratorState copyPropertiesTo( EdgeIteratorState e );
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java b/core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java
index dc139b41a3..2ccdd75207 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeSkipIterState.java
@@ -30,4 +30,8 @@
     void setSkippedEdges( int edge1, int edge2 );
 
     boolean isShortcut();
+
+    EdgeSkipIterState setWeight( double weight );
+
+    double getWeight();
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
index 85ddb34c18..dbe2737226 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.routing.DijkstraBidirection;
+import com.graphhopper.routing.PathBidir;
 import gnu.trove.map.hash.TIntIntHashMap;
 import java.util.Arrays;
 
@@ -25,7 +25,7 @@
  * This class acts as a HashMap (nodes to weights) and is used to implement references from one edge
  * to its parent.
  * <p/>
- * @see DijkstraBidirection
+ * @see PathBidir
  * @author Peter Karich
  */
 @NotThreadSafe
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index d1e1cc6cf9..b59f453b7b 100644
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -17,19 +17,39 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.storage.NodeAccess;
+
 /**
  * @author Peter Karich
  */
 public class FinishInstruction extends Instruction
 {
-    public FinishInstruction( final double lat, final double lon )
+    private int count = -1;
+
+    public FinishInstruction( final double lat, final double lon, final double ele )
     {
-        super(FINISH, "", 0, 0, new PointList()
+        super(FINISH, "", InstructionAnnotation.EMPTY, new PointList(2, true)
         {
-            
             {
-                add(lat, lon);
+                add(lat, lon, ele);
             }
         });
     }
+
+    public FinishInstruction( NodeAccess nodeAccess, int node )
+    {
+        this(nodeAccess.getLatitude(node), nodeAccess.getLongitude(node),
+                nodeAccess.is3D() ? nodeAccess.getElevation(node) : 0);
+    }
+
+    void setVia( int i )
+    {
+        sign = REACHED_VIA;
+        count = i;
+    }
+
+    public int getViaPosition()
+    {
+        return count;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index 73aade749d..a3623be0a3 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -19,12 +19,16 @@
 
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
 import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * A helper class to avoid cluttering the Graph interface with all the common methods. Most of the
@@ -42,16 +46,17 @@
         List<String> problems = new ArrayList<String>();
         int nodes = g.getNodes();
         int nodeIndex = 0;
+        NodeAccess na = g.getNodeAccess();
         try
         {
             EdgeExplorer explorer = g.createEdgeExplorer();
             for (; nodeIndex < nodes; nodeIndex++)
             {
-                double lat = g.getLatitude(nodeIndex);
+                double lat = na.getLatitude(nodeIndex);
                 if (lat > 90 || lat < -90)
                     problems.add("latitude is not within its bounds " + lat);
 
-                double lon = g.getLongitude(nodeIndex);
+                double lon = na.getLongitude(nodeIndex);
                 if (lon > 180 || lon < -180)
                     problems.add("longitude is not within its bounds " + lon);
 
@@ -74,7 +79,7 @@
         }
 
 //        for (int i = 0; i < nodes; i++) {
-//            new XFirstSearch().start(g, i, false);
+//            new BreadthFirstSearch().start(g, i);
 //        }
         return problems;
     }
@@ -112,9 +117,37 @@ public static int count( EdgeIterator iter )
         return list;
     }
 
+    public static List<Integer> getEdgeIds( EdgeIterator iter )
+    {
+        List<Integer> list = new ArrayList<Integer>();
+        while (iter.next())
+        {
+            list.add(iter.getEdge());
+        }
+        return list;
+    }
+
+    public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
+    {
+        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getCount() + " ---");
+        AllEdgesIterator iter = g.getAllEdges();
+        while (iter.next())
+        {
+            String sc = "";
+            if (iter instanceof AllEdgesSkipIterator)
+            {
+                AllEdgesSkipIterator aeSkip = (AllEdgesSkipIterator) iter;
+                sc = aeSkip.isShortcut() ? "sc" : "  ";
+            }
+            String fwdStr = encoder.isForward(iter.getFlags()) ? "fwd" : "   ";
+            String bckStr = encoder.isBackward(iter.getFlags()) ? "bckwd" : "";
+            System.out.println(sc + " " + iter + " " + fwdStr + " " + bckStr);
+        }
+    }
+
     public static void printInfo( final Graph g, int startNode, final int counts, final EdgeFilter filter )
     {
-        new XFirstSearch()
+        new BreadthFirstSearch()
         {
             int counter = 0;
 
@@ -128,14 +161,15 @@ protected boolean goFurther( int nodeId )
                 }
                 return true;
             }
-        }.start(g.createEdgeExplorer(), startNode, false);
+        }.start(g.createEdgeExplorer(), startNode);
     }
 
     public static String getNodeInfo( LevelGraph g, int nodeId, EdgeFilter filter )
     {
         EdgeSkipExplorer ex = g.createEdgeExplorer(filter);
         EdgeSkipIterator iter = ex.setBaseNode(nodeId);
-        String str = nodeId + ":" + g.getLatitude(nodeId) + "," + g.getLongitude(nodeId) + "\n";
+        NodeAccess na = g.getNodeAccess();
+        String str = nodeId + ":" + na.getLatitude(nodeId) + "," + na.getLongitude(nodeId) + "\n";
         while (iter.next())
         {
             str += "  ->" + iter.getAdjNode() + "(" + iter.getSkippedEdge1() + "," + iter.getSkippedEdge2() + ") "
@@ -147,7 +181,8 @@ public static String getNodeInfo( LevelGraph g, int nodeId, EdgeFilter filter )
     public static String getNodeInfo( Graph g, int nodeId, EdgeFilter filter )
     {
         EdgeIterator iter = g.createEdgeExplorer(filter).setBaseNode(nodeId);
-        String str = nodeId + ":" + g.getLatitude(nodeId) + "," + g.getLongitude(nodeId) + "\n";
+        NodeAccess na = g.getNodeAccess();
+        String str = nodeId + ":" + na.getLatitude(nodeId) + "," + na.getLongitude(nodeId) + "\n";
         while (iter.next())
         {
             str += "  ->" + iter.getAdjNode() + " (" + iter.getDistance() + ") pillars:"
@@ -180,12 +215,12 @@ public static Graph sortDFS( Graph g, Graph sortedGraph )
         int nodes = g.getNodes();
         list.fill(0, nodes, -1);
         final GHBitSetImpl bitset = new GHBitSetImpl(nodes);
-        final IntRef ref = new IntRef(0);
+        final AtomicInteger ref = new AtomicInteger(-1);
         EdgeExplorer explorer = g.createEdgeExplorer();
         for (int startNode = 0; startNode >= 0 && startNode < nodes;
                 startNode = bitset.nextClear(startNode + 1))
         {
-            new XFirstSearch()
+            new DepthFirstSearch()
             {
                 @Override
                 protected GHBitSet createBitSet()
@@ -196,44 +231,70 @@ protected GHBitSet createBitSet()
                 @Override
                 protected boolean goFurther( int nodeId )
                 {
-                    list.set(nodeId, ref.val);
-                    ref.val++;
+                    list.set(nodeId, ref.incrementAndGet());
                     return super.goFurther(nodeId);
                 }
-            }.start(explorer, startNode, false);
+            }.start(explorer, startNode);
         }
         return createSortedGraph(g, sortedGraph, list);
     }
 
-    static Graph createSortedGraph( Graph g, Graph sortedGraph, final TIntList oldToNewNodeList )
+    static Graph createSortedGraph( Graph fromGraph, Graph toSortedGraph, final TIntList oldToNewNodeList )
     {
-        int len = oldToNewNodeList.size();
-        // important to avoid creating two edges for edges with both directions
-        GHBitSet bitset = new GHBitSetImpl(len);
-        EdgeExplorer explorer = g.createEdgeExplorer();
-        for (int old = 0; old < len; old++)
+        AllEdgesIterator eIter = fromGraph.getAllEdges();
+        while (eIter.next())
         {
-            int newIndex = oldToNewNodeList.get(old);
+            int base = eIter.getBaseNode();
+            int newBaseIndex = oldToNewNodeList.get(base);
+            int adj = eIter.getAdjNode();
+            int newAdjIndex = oldToNewNodeList.get(adj);
+
             // ignore empty entries
-            if (newIndex < 0)
+            if (newBaseIndex < 0 || newAdjIndex < 0)
                 continue;
-            
-            bitset.add(newIndex);
-            sortedGraph.setNode(newIndex, g.getLatitude(old), g.getLongitude(old));
-            EdgeIterator eIter = explorer.setBaseNode(old);
-            while (eIter.next())
-            {
-                int newNodeIndex = oldToNewNodeList.get(eIter.getAdjNode());
-                if (newNodeIndex < 0)
-                    throw new IllegalStateException("empty entries should be connected to the others");
 
-                if (bitset.contains(newNodeIndex))
-                    continue;
+            eIter.copyPropertiesTo(toSortedGraph.edge(newBaseIndex, newAdjIndex));
+        }
 
-                sortedGraph.edge(newIndex, newNodeIndex).copyProperties(eIter);
-            }
+        int nodes = fromGraph.getNodes();
+        NodeAccess na = fromGraph.getNodeAccess();
+        NodeAccess sna = toSortedGraph.getNodeAccess();
+        for (int old = 0; old < nodes; old++)
+        {
+            int newIndex = oldToNewNodeList.get(old);
+            if (sna.is3D())
+                sna.setNode(newIndex, na.getLatitude(old), na.getLongitude(old), na.getElevation(old));
+            else
+                sna.setNode(newIndex, na.getLatitude(old), na.getLongitude(old));
         }
-        return sortedGraph;
+        return toSortedGraph;
+    }
+
+    /**
+     * @return the specified toGraph which is now filled with data from fromGraph
+     */
+    // TODO very similar to createSortedGraph -> use a 'int map(int)' interface
+    public static Graph copyTo( Graph fromGraph, Graph toGraph )
+    {
+        AllEdgesIterator eIter = fromGraph.getAllEdges();
+        while (eIter.next())
+        {
+            int base = eIter.getBaseNode();
+            int adj = eIter.getAdjNode();
+            eIter.copyPropertiesTo(toGraph.edge(base, adj));
+        }
+
+        NodeAccess fna = fromGraph.getNodeAccess();
+        NodeAccess tna = toGraph.getNodeAccess();
+        int nodes = fromGraph.getNodes();
+        for (int node = 0; node < nodes; node++)
+        {
+            if (tna.is3D())
+                tna.setNode(node, fna.getLatitude(node), fna.getLongitude(node), fna.getElevation(node));
+            else
+                tna.setNode(node, fna.getLatitude(node), fna.getLongitude(node));
+        }
+        return toGraph;
     }
 
     static Directory guessDirectory( GraphStorage store )
@@ -254,13 +315,12 @@ static Directory guessDirectory( GraphStorage store )
     static GraphStorage guessStorage( Graph g, Directory outdir, EncodingManager encodingManager )
     {
         GraphStorage store;
+        boolean is3D = g.getNodeAccess().is3D();
         if (g instanceof LevelGraphStorage)
-        {
-            store = new LevelGraphStorage(outdir, encodingManager);
-        } else
-        {
-            store = new GraphHopperStorage(outdir, encodingManager);
-        }
+            store = new LevelGraphStorage(outdir, encodingManager, is3D);
+        else
+            store = new GraphHopperStorage(outdir, encodingManager, is3D);
+
         return store;
     }
 
@@ -280,50 +340,22 @@ public static Graph clone( Graph g, GraphStorage outGraph )
         return g.copyTo(outGraph.create(g.getNodes()));
     }
 
-    /**
-     * @return the graph 'to'
-     */
-    // TODO very similar to createSortedGraph -> use a 'int map(int)' interface
-    public static Graph copyTo( Graph from, Graph to )
-    {
-        int len = from.getNodes();
-        // important to avoid creating two edges for edges with both directions        
-        GHBitSet bitset = new GHBitSetImpl(len);
-        EdgeExplorer explorer = from.createEdgeExplorer();
-        for (int oldNode = 0; oldNode < len; oldNode++)
-        {
-            bitset.add(oldNode);
-            to.setNode(oldNode, from.getLatitude(oldNode), from.getLongitude(oldNode));
-            EdgeIterator eIter = explorer.setBaseNode(oldNode);
-            while (eIter.next())
-            {
-                int adjacentNodeIndex = eIter.getAdjNode();
-                if (bitset.contains(adjacentNodeIndex))
-                    continue;
-
-                to.edge(oldNode, adjacentNodeIndex).setDistance(eIter.getDistance()).setFlags(eIter.getFlags()).
-                        setWayGeometry(eIter.fetchWayGeometry(0));
-            }
-        }
-        return to;
-    }
-
-    public static int getToNode( Graph g, int edge, int endNode )
+    public static int getAdjNode( Graph g, int edge, int adjNode )
     {
         if (EdgeIterator.Edge.isValid(edge))
         {
-            EdgeIteratorState iterTo = g.getEdgeProps(edge, endNode);
+            EdgeIteratorState iterTo = g.getEdgeProps(edge, adjNode);
             return iterTo.getAdjNode();
         }
-        return endNode;
+        return adjNode;
     }
 
     public static class DisabledEdgeIterator implements EdgeSkipIterator
     {
         @Override
-        public EdgeIterator detach()
+        public EdgeIterator detach( boolean reverse )
         {
-            return this;
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
@@ -435,7 +467,19 @@ public EdgeIteratorState setAdditionalField( int value )
         }
 
         @Override
-        public void copyProperties( EdgeIteratorState edge )
+        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+        {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public double getWeight()
+        {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public EdgeSkipIterState setWeight( double weight )
         {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
@@ -455,4 +499,25 @@ public static EdgeIteratorState getEdge( Graph graph, int base, int adj )
         }
         return null;
     }
+
+    /**
+     * Creates unique positive number for specified edgeId taking into account the direction defined
+     * by nodeA, nodeB and reverse.
+     */
+    public static int createEdgeKey( int nodeA, int nodeB, int edgeId, boolean reverse )
+    {
+        edgeId = edgeId << 1;
+        if (reverse)
+            return (nodeA > nodeB) ? edgeId : edgeId + 1;
+        return (nodeA > nodeB) ? edgeId + 1 : edgeId;
+    }
+
+    /**
+     * Returns if the specified edgeKeys (created by createEdgeKey) are identical regardless of the
+     * direction.
+     */
+    public static boolean isSameEdgeKeys( int edgeKey1, int edgeKey2 )
+    {
+        return edgeKey1 / 2 == edgeKey2 / 2;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/GPXEntry.java b/core/src/main/java/com/graphhopper/util/GPXEntry.java
index a118cbcf86..d9279ca1c3 100644
--- a/core/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/core/src/main/java/com/graphhopper/util/GPXEntry.java
@@ -18,23 +18,35 @@
 package com.graphhopper.util;
 
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
 
 /**
  * @author Peter Karich
  */
-public class GPXEntry extends GHPoint
+public class GPXEntry extends GHPoint3D
 {
     private long time;
 
+    public GPXEntry( GHPoint p, long millis )
+    {
+        this(p.lat, p.lon, millis);
+    }
+
     public GPXEntry( double lat, double lon, long millis )
     {
-        super(lat, lon);
+        super(lat, lon, Double.NaN);
         this.time = millis;
     }
-    
-    public GPXEntry( GHPoint p, long millis )
+
+    public GPXEntry( double lat, double lon, double ele, long millis )
     {
-        this(p.lat, p.lon, millis);
+        super(lat, lon, ele);
+        this.time = millis;
+    }
+
+    boolean is3D()
+    {
+        return !Double.isNaN(ele);
     }
 
     /**
@@ -50,6 +62,16 @@ public void setMillis( long time )
         this.time = time;
     }
 
+    @Override
+    public boolean equals( Object obj )
+    {
+        if (obj == null)
+            return false;
+
+        final GPXEntry other = (GPXEntry) obj;
+        return time == other.time && super.equals(obj);
+    }
+
     @Override
     public String toString()
     {
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 64cd8cd35f..5e56078c64 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -24,6 +24,7 @@
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.nio.MappedByteBuffer;
+import java.nio.charset.Charset;
 import java.security.AccessController;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
@@ -41,8 +42,11 @@
  */
 public class Helper
 {
-    private static final DistanceCalc dce = new DistanceCalcEarth();
+    public static final DistanceCalc DIST_EARTH = new DistanceCalcEarth();
+    public static final DistanceCalc3D DIST_3D = new DistanceCalc3D();
+    public static final DistancePlaneProjection DIST_PLANE = new DistancePlaneProjection();
     private static final Logger logger = LoggerFactory.getLogger(Helper.class);
+    public static Charset UTF_CS = Charset.forName("UTF-8");
     public static final long MB = 1L << 20;
 
     public static ArrayList<Integer> tIntListToArrayList( TIntList from )
@@ -72,6 +76,15 @@ static String packageToPath( Package pkg )
         return pkg.getName().replaceAll("\\.", File.separator);
     }
 
+    public static int countBitValue( int maxTurnCosts )
+    {
+        double val = Math.log(maxTurnCosts) / Math.log(2);
+        int intVal = (int) val;
+        if (val == intVal)
+            return intVal;
+        return intVal + 1;
+    }
+
     private Helper()
     {
     }
@@ -131,7 +144,7 @@ public static void saveProperties( Map<String, String> map, Writer tmpWriter ) t
 
     public static List<String> readFile( String file ) throws IOException
     {
-        return readFile(new InputStreamReader(new FileInputStream(file), "UTF-8"));
+        return readFile(new InputStreamReader(new FileInputStream(file), UTF_CS));
     }
 
     public static List<String> readFile( Reader simpleReader ) throws IOException
@@ -152,6 +165,27 @@ public static void saveProperties( Map<String, String> map, Writer tmpWriter ) t
         }
     }
 
+    public static String isToString( InputStream inputStream ) throws IOException
+    {
+        int size = 1024 * 8;
+        String encoding = "UTF-8";
+        InputStream in = new BufferedInputStream(inputStream, size);
+        try
+        {
+            byte[] buffer = new byte[size];
+            ByteArrayOutputStream output = new ByteArrayOutputStream();
+            int numRead;
+            while ((numRead = in.read(buffer)) != -1)
+            {
+                output.write(buffer, 0, numRead);
+            }
+            return output.toString(encoding);
+        } finally
+        {
+            in.close();
+        }
+    }
+
     public static int idealIntArraySize( int need )
     {
         return idealByteArraySize(need * 4) / 4;
@@ -260,7 +294,7 @@ public static int calcIndexSize( BBox graphBounds )
         if (!graphBounds.isValid())
             throw new IllegalArgumentException("Bounding box is not valid to calculate index size: " + graphBounds);
 
-        double dist = dce.calcDist(graphBounds.maxLat, graphBounds.minLon,
+        double dist = DIST_EARTH.calcDist(graphBounds.maxLat, graphBounds.minLon,
                 graphBounds.minLat, graphBounds.maxLon);
         // convert to km and maximum is 50000km => 1GB
         dist = Math.min(dist / 1000, 50000);
@@ -271,9 +305,7 @@ public static String pruneFileEnd( String file )
     {
         int index = file.lastIndexOf(".");
         if (index < 0)
-        {
             return file;
-        }
         return file.substring(0, index);
     }
 
@@ -290,34 +322,29 @@ public static TIntList createTList( int... list )
     public static PointList createPointList( double... list )
     {
         if (list.length % 2 != 0)
-        {
             throw new IllegalArgumentException("list should consist of lat,lon pairs!");
-        }
-        PointList res = new PointList(list.length);
+
         int max = list.length / 2;
+        PointList res = new PointList(max, false);
         for (int i = 0; i < max; i++)
         {
-            res.add(list[2 * i], list[2 * i + 1]);
+            res.add(list[2 * i], list[2 * i + 1], Double.NaN);
         }
         return res;
     }
 
-    /**
-     * Converts a double (maximum value 10000) into an integer.
-     * <p/>
-     * @return the integer to be stored
-     */
-    public static int doubleToInt( double deg )
+    public static PointList createPointList3D( double... list )
     {
-        return (int) (deg * INT_FACTOR);
-    }
+        if (list.length % 3 != 0)
+            throw new IllegalArgumentException("list should consist of lat,lon,ele tuples!");
 
-    /**
-     * Converts back the once transformed storedInt from doubleToInt
-     */
-    public static double intToDouble( int storedInt )
-    {
-        return (double) storedInt / INT_FACTOR;
+        int max = list.length / 3;
+        PointList res = new PointList(max, true);
+        for (int i = 0; i < max; i++)
+        {
+            res.add(list[3 * i], list[3 * i + 1], list[3 * i + 2]);
+        }
+        return res;
     }
 
     /**
@@ -327,8 +354,12 @@ public static double intToDouble( int storedInt )
      * <p/>
      * @return the integer of the specified degree
      */
-    public static int degreeToInt( double deg )
+    public static final int degreeToInt( double deg )
     {
+        if (deg >= Double.MAX_VALUE)
+            return Integer.MAX_VALUE;
+        if (deg <= -Double.MAX_VALUE)
+            return -Integer.MAX_VALUE;
         return (int) (deg * DEGREE_FACTOR);
     }
 
@@ -337,14 +368,40 @@ public static int degreeToInt( double deg )
      * <p/>
      * @return the degree value of the specified integer
      */
-    public static double intToDegree( int storedInt )
+    public static final double intToDegree( int storedInt )
     {
-        // Double.longBitsToDouble();
+        if (storedInt == Integer.MAX_VALUE)
+            return Double.MAX_VALUE;
+        if (storedInt == -Integer.MAX_VALUE)
+            return -Double.MAX_VALUE;
         return (double) storedInt / DEGREE_FACTOR;
     }
+
+    /**
+     * Converts elevation value (in meters) into integer for storage.
+     */
+    public static final int eleToInt( double ele )
+    {
+        if (ele >= Integer.MAX_VALUE)
+            return Integer.MAX_VALUE;
+        return (int) (ele * ELE_FACTOR);
+    }
+
+    /**
+     * Converts the integer value retrieved from storage into elevation (in meters). Do not expect
+     * more precision than meters although it currently is!
+     */
+    public static final double intToEle( int integEle )
+    {
+        if (integEle == Integer.MAX_VALUE)
+            return Double.MAX_VALUE;
+        return integEle / ELE_FACTOR;
+    }
+
     // +- 180 and +-90 => let use use 400
     private static final float DEGREE_FACTOR = Integer.MAX_VALUE / 400f;
-    private static final float INT_FACTOR = Integer.MAX_VALUE / 10000f;
+    // milli meter is a bit extreme but we have integers
+    private static final float ELE_FACTOR = 1000f;
 
     public static void cleanMappedByteBuffer( final ByteBuffer buffer )
     {
@@ -355,12 +412,16 @@ public static void cleanMappedByteBuffer( final ByteBuffer buffer )
                 @Override
                 public Object run() throws Exception
                 {
-                    final Method getCleanerMethod = buffer.getClass().getMethod("cleaner");
-                    getCleanerMethod.setAccessible(true);
-                    final Object cleaner = getCleanerMethod.invoke(buffer);
-                    if (cleaner != null)
+                    try
+                    {
+                        final Method getCleanerMethod = buffer.getClass().getMethod("cleaner");
+                        getCleanerMethod.setAccessible(true);
+                        final Object cleaner = getCleanerMethod.invoke(buffer);
+                        if (cleaner != null)
+                            cleaner.getClass().getMethod("clean").invoke(cleaner);
+                    } catch (NoSuchMethodException ex)
                     {
-                        cleaner.getClass().getMethod("clean").invoke(cleaner);
+                        // ignore if method cleaner or clean is not available, like on Android
                     }
                     return null;
                 }
@@ -371,6 +432,15 @@ public Object run() throws Exception
         }
     }
 
+    /**
+     * Trying to force the release of the mapped ByteBuffer. See
+     * http://stackoverflow.com/q/2972986/194609 and use only if you know what you are doing.
+     */
+    public static void cleanHack()
+    {
+        System.gc();
+    }
+
     public static String nf( long no )
     {
         // I like french localization the most: 123654 will be 123 654 instead
@@ -388,4 +458,36 @@ public static String firstBig( String sayText )
 
         return Character.toUpperCase(sayText.charAt(0)) + sayText.substring(1);
     }
+
+    /**
+     * This methods returns the value or min if too small or max if too big.
+     */
+    public static final double keepIn( double value, double min, double max )
+    {
+        return Math.max(min, Math.min(value, max));
+    }
+
+    /**
+     * Round the value to the specified exponent
+     */
+    public static double round( double value, int exponent )
+    {
+        double factor = Math.pow(10, exponent);
+        return Math.round(value * factor) / factor;
+    }
+
+    public static final double round6( double value )
+    {
+        return Math.round(value * 1e6) / 1e6;
+    }
+
+    public static final double round4( double value )
+    {
+        return Math.round(value * 1e4) / 1e4;
+    }
+
+    public static final double round2( double value )
+    {
+        return Math.round(value * 100) / 100;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Helper7.java b/core/src/main/java/com/graphhopper/util/Helper7.java
index ab8491e114..36a22f065b 100644
--- a/core/src/main/java/com/graphhopper/util/Helper7.java
+++ b/core/src/main/java/com/graphhopper/util/Helper7.java
@@ -21,32 +21,37 @@
 import javax.xml.stream.XMLStreamReader;
 
 /**
- * Put the usage of proprietary "sun" classes and after jdk6 classes into this
- * class. To use Helper class under Android as well.
+ * Put the usage of proprietary "sun" classes and after jdk6 classes into this class. To use Helper
+ * class under Android as well.
  * <p/>
  * @author Peter Karich
  */
-public class Helper7 {
+public class Helper7
+{
 
     /**
      * <code>true</code>, if this platform supports unmapping mmapped files.
      */
     public static final boolean UNMAP_SUPPORTED;
 
-    static {
+    static
+    {
         boolean v;
-        try {
+        try
+        {
             Class.forName("sun.misc.Cleaner");
             Class.forName("java.nio.DirectByteBuffer")
                     .getMethod("cleaner");
             v = true;
-        } catch (Exception e) {
+        } catch (Exception e)
+        {
             v = false;
         }
         UNMAP_SUPPORTED = v;
     }
 
-    public static String getBeanMemInfo() {
+    public static String getBeanMemInfo()
+    {
         java.lang.management.OperatingSystemMXBean mxbean = java.lang.management.ManagementFactory.getOperatingSystemMXBean();
         com.sun.management.OperatingSystemMXBean sunmxbean = (com.sun.management.OperatingSystemMXBean) mxbean;
         long freeMemory = sunmxbean.getFreePhysicalMemorySize();
@@ -55,12 +60,16 @@ public static String getBeanMemInfo() {
                 + ", rfree:" + Runtime.getRuntime().freeMemory() / Helper.MB;
     }
 
-    public static void close(XMLStreamReader r) {
-        try {
-            if (r != null) {
+    public static void close( XMLStreamReader r )
+    {
+        try
+        {
+            if (r != null)
+            {
                 r.close();
             }
-        } catch (XMLStreamException ex) {
+        } catch (XMLStreamException ex)
+        {
             throw new RuntimeException("Couldn't close xml reader", ex);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index d9f449a781..ab9bb92d6d 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,11 +17,16 @@
  */
 package com.graphhopper.util;
 
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 public class Instruction
 {
-    private static final DistanceCalc distanceCalc = new DistanceCalcEarth();
+    private static final AngleCalc ac = new AngleCalc();
+
+    public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
     public static final int TURN_SLIGHT_LEFT = -1;
@@ -30,49 +35,59 @@
     public static final int TURN_RIGHT = 2;
     public static final int TURN_SHARP_RIGHT = 3;
     public static final int FINISH = 4;
-    private final int indication;
-    private final String name;
-    private double distance;
-    private long millis;
-    private final PointList points;
-    private final int pavementType;
-    private final int waytype;
+    public static final int REACHED_VIA = 5;
+    public static final int USE_ROUNDABOUT = 6;
+
+    protected int sign;
+    protected String name;
+    protected double distance;
+    protected long time;
+    protected final PointList points;
+    protected final InstructionAnnotation annotation;
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
-     * instruction is not duplicated here and should be in the next one. The first distance and time
-     * entries are measured between the first point and the second one etc.
+     * instruction is not duplicated here and should be in the next one.
      */
-    public Instruction( int indication, String name, int waytype, int pavementType, PointList pl )
+    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl)
     {
-        this.indication = indication;
+        this.sign = sign;
         this.name = name;
         this.points = pl;
-        this.waytype = waytype;
-        this.pavementType = pavementType;
+        this.annotation = ia;
     }
 
-    public int getPavement()
+    public InstructionAnnotation getAnnotation()
     {
-        return pavementType;
+        return annotation;
     }
 
-    public int getWayType()
+    /**
+     * The instruction for the person/driver to execute.
+     */
+    public int getSign()
     {
-        return waytype;
+        return sign;
     }
 
-    public int getIndication()
+    public String getName()
     {
-        return indication;
+        return name;
     }
 
-    /**
-     * The instruction for the person/driver to execute.
-     */
-    public String getName()
+    public void setName(String name)
     {
-        return name;
+        this.name = name;
+    }
+
+    public Map<String,Object> getExtraInfoJSON()
+    {
+        return Collections.<String, Object>emptyMap();
+    }
+
+    public void setExtraInfo(String key, Object value)
+    {
+        throw new IllegalArgumentException("Key" + key + " is not a valid option");
     }
 
     public Instruction setDistance( double distance )
@@ -89,18 +104,18 @@ public double getDistance()
         return distance;
     }
 
-    public Instruction setMillis( long millis )
+    public Instruction setTime( long time )
     {
-        this.millis = millis;
+        this.time = time;
         return this;
     }
-    
+
     /**
-     * Time in millis until no new instruction
+     * Time in time until no new instruction
      */
-    public long getMillis()
+    public long getTime()
     {
-        return millis;
+        return time;
     }
 
     /**
@@ -119,43 +134,53 @@ public long getMillis()
         return points.getLongitude(0);
     }
 
-    double getLastLat()
+    double getFirstEle()
     {
-        return points.getLatitude(points.size() - 1);
+        return points.getElevation(0);
     }
 
-    double getLastLon()
+    public PointList getPoints()
     {
-        return points.getLongitude(points.size() - 1);
+        return points;
     }
 
     /**
-     * This method returns a list of gpx entries where the time (in millis) is relative to the first
+     * This method returns a list of gpx entries where the time (in time) is relative to the first
      * which is 0. It does NOT contain the last point which is the first of the next instruction.
      * <p>
      * @return the time offset to add for the next instruction
      */
-    public long fillGPXList( List<GPXEntry> list, long time, double prevFactor, double prevLat, double prevLon )
+    long fillGPXList( List<GPXEntry> list, long time,
+            Instruction prevInstr, Instruction nextInstr, boolean firstInstr )
     {
+        checkOne();
         int len = points.size();
+        long prevTime = time;
+        double lat = points.getLatitude(0);
+        double lon = points.getLongitude(0);
+        double ele = Double.NaN;
+        boolean is3D = points.is3D();
+        if (is3D)
+            ele = points.getElevation(0);
+
         for (int i = 0; i < len; i++)
         {
-            double lat = points.getLatitude(i);
-            double lon = points.getLongitude(i);
-            if (!Double.isNaN(prevLat))
-            {
-                // Here we assume that the same speed is used until the next instruction.
-                // If we would calculate all the distances (and times) up front there
-                // would be a problem where the air-line distance is not the distance returned from the edge
-                // e.g. in the case if we include elevation data                
-                time += distanceCalc.calcDist(prevLat, prevLon, lat, lon) / prevFactor;
-            }
-            list.add(new GPXEntry(lat, lon, time));
-            prevFactor = distance / millis;
-            prevLat = lat;
-            prevLon = lon;
+            list.add(new GPXEntry(lat, lon, ele, prevTime));
+
+            boolean last = i + 1 == len;
+            double nextLat = last ? nextInstr.getFirstLat() : points.getLatitude(i + 1);
+            double nextLon = last ? nextInstr.getFirstLon() : points.getLongitude(i + 1);
+            double nextEle = is3D ? (last ? nextInstr.getFirstEle() : points.getElevation(i + 1)) : Double.NaN;
+            if (is3D)
+                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, nextEle, lat, lon, ele) / distance);
+            else
+                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, lat, lon) / distance);
+
+            lat = nextLat;
+            lon = nextLon;
+            ele = nextEle;
         }
-        return time;
+        return time + this.time;
     }
 
     @Override
@@ -163,14 +188,103 @@ public String toString()
     {
         StringBuilder sb = new StringBuilder();
         sb.append('(');
-        sb.append(indication);
-        sb.append(',');
-        sb.append(name);
-        sb.append(',');
-        sb.append(distance);
-        sb.append(',');
-        sb.append(millis);
+        sb.append(sign).append(',');
+        sb.append(name).append(',');
+        sb.append(distance).append(',');
+        sb.append(time);
         sb.append(')');
         return sb.toString();
     }
+
+    /**
+     * Return the direction like 'NE' based on the first tracksegment of the instruction. If
+     * Instruction does not contain enough coordinate points, an empty string will be returned.
+     */
+    String calcDirection( Instruction nextI )
+    {
+        double azimuth = calcAzimuth(nextI);
+        if (Double.isNaN(azimuth))
+            return "";
+
+        return ac.azimuth2compassPoint(azimuth);
+    }
+
+    /**
+     * Return the azimuth in degree based on the first tracksegment of the instruction. If
+     * Instruction does not contain enough coordinate points, an empty string will be returned.
+     */
+    public double calcAzimuth( Instruction nextI )
+    {
+        double nextLat;
+        double nextLon;
+
+        if (points.getSize() >= 2)
+        {
+            nextLat = points.getLatitude(1);
+            nextLon = points.getLongitude(1);
+        } else if (nextI != null && points.getSize() == 1)
+        {
+            nextLat = nextI.points.getLatitude(0);
+            nextLon = nextI.points.getLongitude(0);
+        } else
+        {
+            return Double.NaN;
+        }
+
+        double lat = points.getLatitude(0);
+        double lon = points.getLongitude(0);
+        return ac.calcAzimuth(lat, lon, nextLat, nextLon);
+    }
+
+    void checkOne()
+    {
+        if (points.size() < 1)
+            throw new IllegalStateException("Instruction must contain at least one point " + toString());
+    }
+
+    public String getTurnDescription( Translation tr )
+    {
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.FINISH)
+        {
+            str = tr.tr("finish");
+        } else if (indi == Instruction.REACHED_VIA)
+        {
+            str = tr.tr("stopover", ((FinishInstruction) this).getViaPosition());
+        } else if (indi == Instruction.CONTINUE_ON_STREET)
+        {
+            str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
+        } else
+        {
+            String dir = null;
+            switch (indi)
+            {
+                case Instruction.TURN_SHARP_LEFT:
+                    dir = tr.tr("turn_sharp_left");
+                    break;
+                case Instruction.TURN_LEFT:
+                    dir = tr.tr("turn_left");
+                    break;
+                case Instruction.TURN_SLIGHT_LEFT:
+                    dir = tr.tr("turn_slight_left");
+                    break;
+                case Instruction.TURN_SLIGHT_RIGHT:
+                    dir = tr.tr("turn_slight_right");
+                    break;
+                case Instruction.TURN_RIGHT:
+                    dir = tr.tr("turn_right");
+                    break;
+                case Instruction.TURN_SHARP_RIGHT:
+                    dir = tr.tr("turn_sharp_right");
+                    break;
+            }
+            if (dir == null)
+                throw new IllegalStateException("Turn indication not found " + indi);
+
+            str = Helper.isEmpty(streetName) ? dir : tr.tr("turn_onto", dir, streetName);
+        }
+        return str;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java b/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java
new file mode 100644
index 0000000000..c1a02c2d42
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/InstructionAnnotation.java
@@ -0,0 +1,100 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+/**
+ * @author Peter Karich
+ */
+public class InstructionAnnotation
+{
+    public final static InstructionAnnotation EMPTY = new InstructionAnnotation();
+    private boolean empty;
+    private int importance;
+    private String message;
+
+    private InstructionAnnotation()
+    {
+        setEmpty();
+    }
+
+    public InstructionAnnotation( int importance, String message )
+    {
+        if (message.isEmpty() && importance == 0)
+        {
+            setEmpty();
+        } else
+        {
+            this.empty = false;
+            this.importance = importance;
+            this.message = message;
+        }
+    }
+
+    private void setEmpty()
+    {
+        this.empty = true;
+        this.importance = 0;
+        this.message = "";
+    }
+
+    public boolean isEmpty()
+    {
+        return empty;
+    }
+
+    public int getImportance()
+    {
+        return importance;
+    }
+
+    public String getMessage()
+    {
+        return message;
+    }
+
+    @Override
+    public String toString()
+    {
+        return importance + ": " + getMessage();
+    }
+
+    @Override
+    public int hashCode()
+    {
+        int hash = 3;
+        hash = 83 * hash + this.importance;
+        hash = 83 * hash + (this.message != null ? this.message.hashCode() : 0);
+        return hash;
+    }
+
+    @Override
+    public boolean equals( Object obj )
+    {
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        final InstructionAnnotation other = (InstructionAnnotation) obj;
+        if (this.importance != other.importance)
+            return false;
+        if ((this.message == null) ? (other.message != null) : !this.message.equals(other.message))
+            return false;
+        return true;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 3285ad645c..5d36783569 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -19,27 +19,31 @@
 
 import java.text.SimpleDateFormat;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.TimeZone;
+import java.util.*;
 
 /**
  * List of instructions.
  */
 public class InstructionList implements Iterable<Instruction>
 {
+    public static final InstructionList EMPTY = new InstructionList();
     private final List<Instruction> instructions;
+    private final Translation tr;
 
-    public InstructionList()
+    private InstructionList()
     {
-        this(10);
+        this(0, null);
     }
 
-    public InstructionList( int cap )
+    public InstructionList( Translation tr )
+    {
+        this(10, tr);
+    }
+
+    public InstructionList( int cap, Translation tr )
     {
         instructions = new ArrayList<Instruction>(cap);
+        this.tr = tr;
     }
 
     public void add( Instruction instr )
@@ -57,150 +61,43 @@ public int size()
         return instructions.size();
     }
 
-    /**
-     * @return list of indications useful to create images
-     */
-    public List<Integer> createIndications()
-    {
-        List<Integer> res = new ArrayList<Integer>(instructions.size());
-        for (Instruction instruction : instructions)
-        {
-            res.add(instruction.getIndication());
-        }
-        return res;
-    }
-
-    public List<Double> createDistances()
+    public List<Map<String, Object>> createJson()
     {
-        List<Double> res = new ArrayList<Double>(instructions.size());
+        List<Map<String, Object>> instrList = new ArrayList<Map<String, Object>>(instructions.size());
+        int pointsIndex = 0;
+        int counter = 0;
         for (Instruction instruction : instructions)
         {
-            res.add(instruction.getDistance());
-        }
-        return res;
-    }
+            Map<String, Object> instrJson = new HashMap<String, Object>();
+            instrList.add(instrJson);
 
-    public List<String> createDistances( TranslationMap.Translation tr, boolean mile )
-    {
-        List<Double> distances = createDistances();
-        List<String> labels = new ArrayList<String>(distances.size());
-        for (int i = 0; i < distances.size(); i++)
-        {
-            double distInMeter = distances.get(i);
-            if (mile)
-            {
-                // calculate miles
-                double distInMiles = distInMeter / 1000 / DistanceCalcEarth.KM_MILE;
-                if (distInMiles < 0.9)
-                {
-                    labels.add((int) DistanceCalcEarth.round(distInMiles * 5280, 1) + " " + tr.tr("ftAbbr"));
-                } else
-                {
-                    if (distInMiles < 100)
-                        labels.add(DistanceCalcEarth.round(distInMiles, 2) + " " + tr.tr("miAbbr"));
-                    else
-                        labels.add((int) DistanceCalcEarth.round(distInMiles, 1) + " " + tr.tr("miAbbr"));
-                }
-            } else
+            InstructionAnnotation ia = instruction.getAnnotation();
+            String str = instruction.getTurnDescription(tr);
+            if (Helper.isEmpty(str))
+                str = ia.getMessage();
+            instrJson.put("text", Helper.firstBig(str));
+            if (!ia.isEmpty())
             {
-                if (distInMeter < 950)
-                {
-                    labels.add((int) DistanceCalcEarth.round(distInMeter, 1) + " " + tr.tr("mAbbr"));
-                } else
-                {
-                    distInMeter /= 1000;
-                    if (distInMeter < 100)
-                        labels.add(DistanceCalcEarth.round(distInMeter, 2) + " " + tr.tr("kmAbbr"));
-                    else
-                        labels.add((int) DistanceCalcEarth.round(distInMeter, 1) + " " + tr.tr("kmAbbr"));
-                }
+                instrJson.put("annotationText", ia.getMessage());
+                instrJson.put("annotationImportance", ia.getImportance());
             }
-        }
-        return labels;
-    }
 
-    /**
-     * @return string representations of the times until no new instruction.
-     */
-    public List<Long> createMillis()
-    {
-        List<Long> res = new ArrayList<Long>(instructions.size());
-        for (Instruction instruction : instructions)
-        {
-            res.add(instruction.getMillis());
-        }
-        return res;
-    }
+            instrJson.put("time", instruction.getTime());
+            instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
+            instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
 
-    /**
-     * @return the lat,lon positions at which the instructions have to be presented.
-     */
-    public List<List<Double>> createLatLngs()
-    {
-        List<List<Double>> res = new ArrayList<List<Double>>();
-        for (Instruction instruction : instructions)
-        {
-            List<Double> latLng = new ArrayList<Double>(2);
-            latLng.add(instruction.getFirstLat());
-            latLng.add(instruction.getFirstLon());
-            res.add(latLng);
-        }
-        return res;
-    }
+            int tmpIndex = pointsIndex + instruction.getPoints().size();
+            // the last instruction should not point to the next instruction
+            if (counter + 1 == instructions.size())
+                tmpIndex--;
 
-    public List<String> createDescription( TranslationMap.Translation tr )
-    {
-        String shLeftTr = tr.tr("sharp_left");
-        String shRightTr = tr.tr("sharp_right");
-        String slLeftTr = tr.tr("slight_left");
-        String slRightTr = tr.tr("slight_right");
-        String leftTr = tr.tr("left");
-        String rightTr = tr.tr("right");
-        String continueTr = tr.tr("continue");
-        List<String> res = new ArrayList<String>(instructions.size());
-        for (Instruction instruction : instructions)
-        {
-            String str;
-            String n = getWayName(instruction.getName(), instruction.getPavement(), instruction.getWayType(), tr);
-            int indi = instruction.getIndication();
-            if (indi == Instruction.FINISH)
-            {
-                str = tr.tr("finish");
-            } else if (indi == Instruction.CONTINUE_ON_STREET)
-            {
-                str = Helper.isEmpty(n) ? continueTr : tr.tr("continue_onto", n);
-            } else
-            {
-                String dir = null;
-                switch (indi)
-                {
-                    case Instruction.TURN_SHARP_LEFT:
-                        dir = shLeftTr;
-                        break;
-                    case Instruction.TURN_LEFT:
-                        dir = leftTr;
-                        break;
-                    case Instruction.TURN_SLIGHT_LEFT:
-                        dir = slLeftTr;
-                        break;
-                    case Instruction.TURN_SLIGHT_RIGHT:
-                        dir = slRightTr;
-                        break;
-                    case Instruction.TURN_RIGHT:
-                        dir = rightTr;
-                        break;
-                    case Instruction.TURN_SHARP_RIGHT:
-                        dir = shRightTr;
-                        break;
-                }
-                if (dir == null)
-                    throw new IllegalStateException("Indication not found " + indi);
+            instrJson.put("interval", Arrays.asList(pointsIndex, tmpIndex));
+            pointsIndex = tmpIndex;
 
-                str = Helper.isEmpty(n) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, n);
-            }
-            res.add(Helper.firstBig(str));
+            counter++;
         }
-        return res;
+        return instrList;
     }
 
     public boolean isEmpty()
@@ -226,8 +123,9 @@ public String toString()
     }
 
     /**
-     * This method returns a list of gpx entries where the time (in millis) is relative to the first
-     * which is 0.
+     * @return This method returns a list of gpx entries where the time (in millis) is relative to
+     * the first which is 0.
+     * <p>
      */
     public List<GPXEntry> createGPXList()
     {
@@ -236,24 +134,42 @@ public String toString()
 
         List<GPXEntry> gpxList = new ArrayList<GPXEntry>();
         long timeOffset = 0;
-        double prevLat = Double.NaN, prevLon = Double.NaN;
-        double prevFactor = 0;
-        for (Instruction i : this)
+        for (int i = 0; i < size() - 1; i++)
         {
-            timeOffset = i.fillGPXList(gpxList, timeOffset, prevFactor, prevLat, prevLon);
-            prevFactor = i.getDistance() / i.getMillis();
-            prevLat = i.getLastLat();
-            prevLon = i.getLastLon();
+            Instruction prevInstr = (i > 0) ? get(i - 1) : null;
+            boolean instrIsFirst = prevInstr == null;
+            Instruction nextInstr = get(i + 1);
+            nextInstr.checkOne();
+            // current instruction does not contain last point which is equals to first point of next instruction:
+            timeOffset = get(i).fillGPXList(gpxList, timeOffset, prevInstr, nextInstr, instrIsFirst);
         }
+        Instruction lastI = get(size() - 1);
+        if (lastI.points.size() != 1)
+            throw new IllegalStateException("Last instruction must have exactly one point but was " + lastI.points.size());
+        double lastLat = lastI.getFirstLat(), lastLon = lastI.getFirstLon(),
+                lastEle = lastI.getPoints().is3D() ? lastI.getFirstEle() : Double.NaN;
+        gpxList.add(new GPXEntry(lastLat, lastLon, lastEle, timeOffset));
         return gpxList;
     }
 
     /**
-     * Creates the GPX Format out of the points.
+     * Creates the standard GPX string out of the points according to the schema found here:
+     * https://graphhopper.com/public/schema/gpx-1.1.xsd
      * <p/>
      * @return string to be stored as gpx file
      */
+    public String createGPX()
+    {
+        return createGPX("GraphHopper", 0, "GMT");
+    }
+
     public String createGPX( String trackName, long startTimeMillis, String timeZoneId )
+    {
+        boolean includeElevation = getSize() > 0 ? get(0).getPoints().is3D() : false;
+        return createGPX(trackName, startTimeMillis, timeZoneId, includeElevation);
+    }
+
+    public String createGPX( String trackName, long startTimeMillis, String timeZoneId, boolean includeElevation )
     {
         SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
         TimeZone tz = TimeZone.getDefault();
@@ -262,24 +178,51 @@ public String createGPX( String trackName, long startTimeMillis, String timeZone
 
         formatter.setTimeZone(tz);
         String header = "<?xml version='1.0' encoding='UTF-8' standalone='no' ?>"
-                + "<gpx xmlns='http://www.topografix.com/GPX/1/1' creator='Graphhopper' version='1.1' >"
-                + "<metadata>"
+                + "<gpx xmlns='http://www.topografix.com/GPX/1/1' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'"
+                + " creator='Graphhopper' version='1.1'"
+                // This xmlns:gh acts only as ID, no valid URL necessary.
+                // Use a separate namespace for custom extensions to make basecamp happy.
+                + " xmlns:gh='https://graphhopper.com/public/schema/gpx/1.1'>"
+                + "\n<metadata>"
+                + "<copyright author=\"OpenStreetMap contributors\"/>"
                 + "<link href='http://graphhopper.com'>"
                 + "<text>GraphHopper GPX</text>"
                 + "</link>"
                 + "<time>" + tzHack(formatter.format(startTimeMillis)) + "</time>"
                 + "</metadata>";
         StringBuilder track = new StringBuilder(header);
-        track.append("<trk><name>").append(trackName).append("</name>");
+        if (!isEmpty())
+        {
+            track.append("\n<rte>");
+            Instruction nextInstr = null;
+            for (Instruction currInstr : instructions)
+            {
+                if (null != nextInstr)
+                    createRteptBlock(track, nextInstr, currInstr);
+
+                nextInstr = currInstr;
+            }
+            createRteptBlock(track, nextInstr, null);
+            track.append("</rte>");
+        }
+
+        track.append("\n<trk><name>").append(trackName).append("</name>");
+
         track.append("<trkseg>");
         for (GPXEntry entry : createGPXList())
         {
-            track.append("<trkpt lat='").append(entry.getLat()).append("' lon='").append(entry.getLon()).append("'>");
+            track.append("\n<trkpt lat='").append(Helper.round6(entry.getLat()));
+            track.append("' lon='").append(Helper.round6(entry.getLon())).append("'>");
+            if (includeElevation)
+                track.append("<ele>").append(Helper.round2(entry.getEle())).append("</ele>");
             track.append("<time>").append(tzHack(formatter.format(startTimeMillis + entry.getMillis()))).append("</time>");
             track.append("</trkpt>");
         }
         track.append("</trkseg>");
-        track.append("</trk></gpx>");
+        track.append("</trk>");
+
+        // we could now use 'wpt' for via points
+        track.append("</gpx>");
         return track.toString().replaceAll("\\'", "\"");
     }
 
@@ -291,41 +234,112 @@ private static String tzHack( String str )
         return str.substring(0, str.length() - 2) + ":" + str.substring(str.length() - 2);
     }
 
-    public static String getWayName( String name, int pavetype, int waytype, TranslationMap.Translation tr )
+    private void createRteptBlock( StringBuilder output, Instruction instruction, Instruction nextI )
+    {
+        output.append("\n<rtept lat=\"").append(Helper.round6(instruction.getFirstLat())).
+                append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
+
+        if (!instruction.getName().isEmpty())
+            output.append("<desc>").append(instruction.getTurnDescription(tr)).append("</desc>");
+
+        output.append("<extensions>");
+        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
+        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
+
+        String direction = instruction.calcDirection(nextI);
+        if (!direction.isEmpty())
+            output.append("<gh:direction>").append(direction).append("</gh:direction>");
+
+        double azimuth = instruction.calcAzimuth(nextI);
+        if (!Double.isNaN(azimuth))
+            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
+
+        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
+        output.append("</extensions>");
+        output.append("</rtept>");
+    }
+
+    /**
+     * @return list of lat lon
+     */
+    List<List<Double>> createStartPoints()
+    {
+        List<List<Double>> res = new ArrayList<List<Double>>(instructions.size());
+        for (Instruction instruction : instructions)
+        {
+            res.add(Arrays.asList(instruction.getFirstLat(), instruction.getFirstLon()));
+        }
+        return res;
+    }
+
+    /**
+     * This method is useful for navigation devices to find the next instruction for the specified
+     * coordinate (e.g. the current position).
+     * <p>
+     * @param maxDistance the maximum acceptable distance to the instruction (in meter)
+     * @return the next Instruction or null if too far away.
+     */
+    public Instruction find( double lat, double lon, double maxDistance )
     {
-        String pavementName = "";
-        if (pavetype == 1)
-            pavementName = tr.tr("unpaved");
+        // handle special cases
+        if (getSize() == 0)
+        {
+            return null;
+        }
+        PointList points = get(0).getPoints();
+        double prevLat = points.getLatitude(0);
+        double prevLon = points.getLongitude(0);
+        DistanceCalc distCalc = Helper.DIST_EARTH;
+        double foundMinDistance = distCalc.calcNormalizedDist(lat, lon, prevLat, prevLon);
+        int foundInstruction = 0;
 
-        String wayClass = "";
-        switch (waytype)
+        // Search the closest edge to the query point
+        if (getSize() > 1)
         {
-            case 0:
-                wayClass = tr.tr("road");
-                break;
-            case 1:
-                wayClass = tr.tr("pushing_section");
-                break;
-            case 2:
-                wayClass = tr.tr("cycleway");
-                break;
-            case 3:
-                wayClass = tr.tr("way");
-                break;
+            for (int instructionIndex = 0; instructionIndex < getSize(); instructionIndex++)
+            {
+                points = get(instructionIndex).getPoints();
+                for (int pointIndex = 0; pointIndex < points.size(); pointIndex++)
+                {
+                    double currLat = points.getLatitude(pointIndex);
+                    double currLon = points.getLongitude(pointIndex);
+
+                    if (!(instructionIndex == 0 && pointIndex == 0))
+                    {
+                        // calculate the distance from the point to the edge
+                        double distance;
+                        int index = instructionIndex;
+                        if (distCalc.validEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon))
+                        {
+                            distance = distCalc.calcNormalizedEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon);
+                            if (pointIndex > 0)
+                                index++;
+                        } else
+                        {
+                            distance = distCalc.calcNormalizedDist(lat, lon, currLat, currLon);
+                        }
+
+                        if (distance < foundMinDistance)
+                        {
+                            foundMinDistance = distance;
+                            foundInstruction = index;
+                        }
+                    }
+
+                    prevLat = currLat;
+                    prevLon = currLon;
+                }
+            }
         }
 
-        if (name.isEmpty())
-            if (pavementName.isEmpty())
-                return wayClass;
-            else
-                return wayClass + ", " + pavementName;
-        else if (pavementName.isEmpty())
-            if (waytype == 0)
-                return name;
-            else
-                return name + ", " + wayClass;
-        else
-            return name + ", " + pavementName;
+        if (distCalc.calcDenormalizedDist(foundMinDistance) > maxDistance)
+            return null;
+
+        // special case finish condition
+        if (foundInstruction == getSize())
+            foundInstruction--;
+
+        return get(foundInstruction);
     }
 
 }
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 24cb8cd371..590c89b2fa 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -63,25 +63,33 @@ public MiniPerfTest setIterations( int counts )
         return this;
     }
 
-    // in ms
+    /**
+     * @return minimum time of every call, in ms
+     */
     public double getMin()
     {
         return min / 1e6;
     }
 
-    // in ms
+    /**
+     * @return maximum time of every calls, in ms
+     */
     public double getMax()
     {
         return max / 1e6;
     }
 
-    // in ms
+    /**
+     * @return time for all calls accumulated, in ms
+     */
     public double getSum()
     {
         return fullTime / 1e6;
     }
 
-    // in ms
+    /**
+     * @return mean time per call, in ms
+     */
     public double getMean()
     {
         return getSum() / counts;
diff --git a/core/src/main/java/com/graphhopper/util/PMap.java b/core/src/main/java/com/graphhopper/util/PMap.java
new file mode 100644
index 0000000000..4e3e493706
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/PMap.java
@@ -0,0 +1,179 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A properties map with convenient accessors
+ * <p>
+ * @author Peter Karich
+ */
+public class PMap
+{
+    private final Map<String, String> map;
+
+    public PMap()
+    {
+        this(5);
+    }
+
+    public PMap( int capacity )
+    {
+        this(new HashMap<String, String>(capacity));
+    }
+
+    public PMap( Map<String, String> map )
+    {
+        this.map = map;
+    }
+
+    public PMap put( String key, Object str )
+    {
+        if (str == null)
+            throw new NullPointerException("Value cannot be null. Use remove instead.");
+
+        map.put(key.toLowerCase(), str.toString());
+        return this;
+    }
+
+    public PMap remove( String key )
+    {
+        map.remove(key);
+        return this;
+    }
+
+    public long getLong( String key, long _default )
+    {
+        String str = get(key);
+        if (!Helper.isEmpty(str))
+        {
+            try
+            {
+                return Long.parseLong(str);
+            } catch (Exception ex)
+            {
+            }
+        }
+        return _default;
+    }
+
+    public int getInt( String key, int _default )
+    {
+        String str = get(key);
+        if (!Helper.isEmpty(str))
+        {
+            try
+            {
+                return Integer.parseInt(str);
+            } catch (Exception ex)
+            {
+            }
+        }
+        return _default;
+    }
+
+    public boolean getBool( String key, boolean _default )
+    {
+        String str = get(key);
+        if (!Helper.isEmpty(str))
+        {
+            try
+            {
+                return Boolean.parseBoolean(str);
+            } catch (Exception ex)
+            {
+            }
+        }
+        return _default;
+    }
+
+    public double getDouble( String key, double _default )
+    {
+        String str = get(key);
+        if (!Helper.isEmpty(str))
+        {
+            try
+            {
+                return Double.parseDouble(str);
+            } catch (Exception ex)
+            {
+            }
+        }
+        return _default;
+    }
+
+    public String get( String key, String _default )
+    {
+        String str = get(key);
+        if (Helper.isEmpty(str))
+        {
+            return _default;
+        }
+        return str;
+    }
+
+    String get( String key )
+    {
+        if (Helper.isEmpty(key))
+        {
+            return "";
+        }
+        String val = map.get(key.toLowerCase());
+        if (val == null)
+        {
+            return "";
+        }
+        return val;
+    }
+
+    private Map<String, String> getMap()
+    {
+        return map;
+    }
+
+    public PMap merge( PMap read )
+    {
+        return merge(read.getMap());
+    }
+
+    PMap merge( Map<String, String> map )
+    {
+        for (Map.Entry<String, String> e : map.entrySet())
+        {
+            if (Helper.isEmpty(e.getKey()))
+            {
+                continue;
+            }
+            this.getMap().put(e.getKey().toLowerCase(), e.getValue());
+        }
+        return this;
+    }
+
+    public boolean has( String key )
+    {
+        return this.getMap().containsKey(key);
+    }
+
+    @Override
+    public String toString()
+    {
+        return this.getMap().toString();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
new file mode 100644
index 0000000000..a8c8288634
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -0,0 +1,151 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import com.graphhopper.GHResponse;
+import com.graphhopper.routing.Path;
+import java.util.List;
+
+/**
+ * This class merges a list of points into one point recognizing the specified places.
+ * <p>
+ * @author Peter Karich
+ * @author ratrun
+ */
+public class PathMerger
+{
+    private boolean enableInstructions = true;
+    private boolean simplifyResponse = true;
+    private DouglasPeucker douglasPeucker;
+    private boolean calcPoints = true;
+
+    public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
+    {
+        int origPoints = 0;
+        StopWatch sw;
+        long fullMillis = 0;
+        double fullWeight = 0;
+        double fullDistance = 0;
+        boolean allFound = true;
+
+        InstructionList fullInstructions = new InstructionList(tr);
+        PointList fullPoints = PointList.EMPTY;
+        for (int pathIndex = 0; pathIndex < paths.size(); pathIndex++)
+        {
+            Path path = paths.get(pathIndex);
+            fullMillis += path.getMillis();
+            fullDistance += path.getDistance();
+            fullWeight += path.getWeight();
+            if (enableInstructions)
+            {
+                InstructionList il = path.calcInstructions(tr);
+                sw = new StopWatch().start();
+
+                if (!il.isEmpty())
+                {
+                    if (fullPoints.isEmpty())
+                    {
+                        PointList pl = il.get(0).getPoints();
+                        // do a wild guess about the total number of points to avoid reallocation a bit
+                        fullPoints = new PointList(il.size() * Math.min(10, pl.size()), pl.is3D());
+                    }
+
+                    for (Instruction i : il)
+                    {
+                        if (simplifyResponse)
+                        {
+                            origPoints += i.getPoints().size();
+                            douglasPeucker.simplify(i.getPoints());
+                        }
+                        fullInstructions.add(i);
+                        fullPoints.add(i.getPoints());
+                    }
+                    sw.stop();
+
+                    // if not yet reached finish replace with 'reached via'
+                    if (pathIndex + 1 < paths.size())
+                    {
+                        FinishInstruction fi = (FinishInstruction) fullInstructions.get(fullInstructions.size() - 1);
+                        fi.setVia(pathIndex + 1);
+                    }
+                }
+
+            } else if (calcPoints)
+            {
+                PointList tmpPoints = path.calcPoints();
+                if (fullPoints.isEmpty())
+                    fullPoints = new PointList(tmpPoints.size(), tmpPoints.is3D());
+
+                if (simplifyResponse)
+                {
+                    origPoints = tmpPoints.getSize();
+                    sw = new StopWatch().start();
+                    douglasPeucker.simplify(tmpPoints);
+                    sw.stop();
+                }
+                fullPoints.add(tmpPoints);
+            }
+
+            allFound = allFound && path.isFound();
+        }
+
+        if (!fullPoints.isEmpty())
+        {
+            String debug = rsp.getDebugInfo() + ", simplify (" + origPoints + "->" + fullPoints.getSize() + ")";
+            rsp.setDebugInfo(debug);
+        }
+
+        if (enableInstructions)
+            rsp.setInstructions(fullInstructions);
+
+        if (!allFound)
+        {
+            rsp.addError(new RuntimeException("Not found"));
+        }
+
+        rsp.setPoints(fullPoints).
+                setRouteWeight(fullWeight).
+                setDistance(fullDistance).
+                setMillis(fullMillis);
+    }
+
+    public PathMerger setCalcPoints( boolean calcPoints )
+    {
+        this.calcPoints = calcPoints;
+        return this;
+    }
+
+    public PathMerger setDouglasPeucker( DouglasPeucker douglasPeucker )
+    {
+        this.douglasPeucker = douglasPeucker;
+        return this;
+    }
+
+    public PathMerger setSimplifyResponse( boolean simplifyRes )
+    {
+        this.simplifyResponse = simplifyRes;
+        return this;
+    }
+
+    public PathMerger setEnableInstructions( boolean enableInstructions )
+    {
+        this.enableInstructions = enableInstructions;
+        return this;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/core/src/main/java/com/graphhopper/util/PointAccess.java
new file mode 100644
index 0000000000..5d3068a599
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/PointAccess.java
@@ -0,0 +1,78 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+/**
+ * @author Peter Karich
+ */
+public interface PointAccess
+{
+    /**
+     * @return true if elevation data is stored and can be retrieved
+     */
+    boolean is3D();
+
+    /**
+     * @return 3 if elevation enabled. 2 otherwise
+     */
+    int getDimension();
+
+    /**
+     * This method ensures that the node with the specified index exists i.e. allocates space for
+     * it.
+     */
+    void ensureNode( int nodeId );
+
+    /**
+     * This method ensures that the node with the specified index exists and prepares access to it.
+     * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
+     * <p>
+     * This methods sets the latitude, longitude and elevation to the specified value.
+     */
+    void setNode( int nodeId, double lat, double lon );
+
+    /**
+     * This method ensures that the node with the specified index exists and prepares access to it.
+     * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
+     * <p>
+     * This methods sets the latitude, longitude and elevation to the specified value.
+     */
+    void setNode( int nodeId, double lat, double lon, double ele );
+
+    /**
+     * @return the latitude at the specified node index
+     */
+    double getLatitude( int nodeId );
+
+    double getLat( int nodeId );
+
+    /**
+     * @return the longitude at the specified node index
+     */
+    double getLongitude( int nodeId );
+
+    double getLon( int nodeId );
+
+    /**
+     * Returns the elevation of the specified nodeId.
+     */
+    double getElevation( int nodeId );
+
+    double getEle( int nodeId );
+}
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index 7164f1486a..cb29f7fb96 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -19,6 +19,7 @@
 package com.graphhopper.util;
 
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -28,46 +29,137 @@
  * <p/>
  * @author Peter Karich
  */
-public class PointList
+public class PointList implements PointAccess
 {
+    private final static DistanceCalc3D distCalc3D = Helper.DIST_3D;
+    private static String ERR_MSG = "Tried to access PointList with too big index!";
     private double[] latitudes;
     private double[] longitudes;
-    private int size = 0;
+    private double[] elevations;
+    protected int size = 0;
+    protected boolean is3D;
 
     public PointList()
     {
-        this(10);
+        this(10, false);
     }
 
-    public PointList( int cap )
+    public PointList( int cap, boolean is3D )
     {
         latitudes = new double[cap];
         longitudes = new double[cap];
+        this.is3D = is3D;
+        if (is3D)
+            elevations = new double[cap];
     }
 
-    public void set( int index, double lat, double lon )
+    @Override
+    public boolean is3D()
+    {
+        return is3D;
+    }
+
+    @Override
+    public int getDimension()
+    {
+        if (is3D)
+            return 3;
+        return 2;
+    }
+
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        incCap(nodeId + 1);
+    }
+
+    @Override
+    public void setNode( int nodeId, double lat, double lon )
+    {
+        set(nodeId, lat, lon, Double.NaN);
+    }
+
+    @Override
+    public void setNode( int nodeId, double lat, double lon, double ele )
+    {
+        set(nodeId, lat, lon, ele);
+    }
+
+    public void set( int index, double lat, double lon, double ele )
     {
         if (index >= size)
             throw new ArrayIndexOutOfBoundsException("index has to be smaller than size " + size);
 
         latitudes[index] = lat;
         longitudes[index] = lon;
+        if (is3D)
+            elevations[index] = ele;
+        else if (!Double.isNaN(ele))
+            throw new IllegalStateException("This is a 2D list we cannot store elevation: " + ele);
+    }
+
+    private void incCap( int newSize )
+    {
+        if (newSize <= latitudes.length)
+            return;
+
+        int cap = newSize * 2;
+        if (cap < 15)
+            cap = 15;
+        latitudes = Arrays.copyOf(latitudes, cap);
+        longitudes = Arrays.copyOf(longitudes, cap);
+        if (is3D)
+            elevations = Arrays.copyOf(elevations, cap);
     }
 
     public void add( double lat, double lon )
     {
-        int newSize = size + 1;
-        if (newSize >= latitudes.length)
-        {
-            int cap = (int) (newSize * 1.7);
-            if (cap < 8)
-                cap = 8;
-            latitudes = Arrays.copyOf(latitudes, cap);
-            longitudes = Arrays.copyOf(longitudes, cap);
-        }
+        if (is3D)
+            throw new IllegalStateException("Cannot add point without elevation data in 3D mode");
+        add(lat, lon, Double.NaN);
+    }
 
+    public void add( double lat, double lon, double ele )
+    {
+        int newSize = size + 1;
+        incCap(newSize);
         latitudes[size] = lat;
         longitudes[size] = lon;
+        if (is3D)
+            elevations[size] = ele;
+        else if (!Double.isNaN(ele))
+            throw new IllegalStateException("This is a 2D list we cannot store elevation: " + ele);
+        size = newSize;
+    }
+
+    public void add( PointAccess nodeAccess, int index )
+    {
+        if (is3D)
+            add(nodeAccess.getLatitude(index), nodeAccess.getLongitude(index), nodeAccess.getElevation(index));
+        else
+            add(nodeAccess.getLatitude(index), nodeAccess.getLongitude(index));
+    }
+
+    public void add( GHPoint point )
+    {
+        if (is3D)
+            add(point.lat, point.lon, ((GHPoint3D) point).ele);
+        else
+            add(point.lat, point.lon);
+    }
+
+    public void add( PointList points )
+    {
+        int newSize = size + points.getSize();
+        incCap(newSize);
+        for (int i = 0; i < points.getSize(); i++)
+        {
+            int tmp = size + i;
+            latitudes[tmp] = points.getLatitude(i);
+            longitudes[tmp] = points.getLongitude(i);
+            if (is3D)
+                elevations[tmp] = points.getElevation(i);
+        }
         size = newSize;
     }
 
@@ -86,27 +178,56 @@ public boolean isEmpty()
         return size == 0;
     }
 
+    @Override
+    public double getLat( int index )
+    {
+        return getLatitude(index);
+    }
+
+    @Override
     public double getLatitude( int index )
     {
         if (index >= size)
-        {
-            throw new ArrayIndexOutOfBoundsException("Tried to access PointList with too big index! "
-                    + "index:" + index + ", size:" + size);
-        }
+            throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + size);
+
         return latitudes[index];
     }
 
+    @Override
+    public double getLon( int index )
+    {
+        return getLongitude(index);
+    }
+
+    @Override
     public double getLongitude( int index )
     {
         if (index >= size)
-            throw new ArrayIndexOutOfBoundsException("Tried to access PointList with too big index! "
-                    + "index:" + index + ", size:" + size);
+            throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + size);
 
         return longitudes[index];
     }
 
+    @Override
+    public double getElevation( int index )
+    {
+        if (index >= size)
+            throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + size);
+        if (!is3D)
+            return Double.NaN;
+
+        return elevations[index];
+    }
+
+    @Override
+    public double getEle( int index )
+    {
+        return getElevation(index);
+    }
+
     public void reverse()
     {
+        // in-place reverse
         int max = size / 2;
         for (int i = 0; i < max; i++)
         {
@@ -119,6 +240,13 @@ public void reverse()
             tmp = longitudes[i];
             longitudes[i] = longitudes[swapIndex];
             longitudes[swapIndex] = tmp;
+
+            if (is3D)
+            {
+                tmp = elevations[i];
+                elevations[i] = elevations[swapIndex];
+                elevations[swapIndex] = tmp;
+            }
         }
     }
 
@@ -148,23 +276,40 @@ public String toString()
             sb.append(latitudes[i]);
             sb.append(',');
             sb.append(longitudes[i]);
+            if (is3D)
+            {
+                sb.append(',');
+                sb.append(elevations[i]);
+            }
             sb.append(')');
         }
         return sb.toString();
     }
 
     /**
-     * Attention: geoJson is LON,LAT
+     * Attention: geoJson is LON,LAT or LON,LAT,ELE
      */
     public List<Double[]> toGeoJson()
     {
+        return toGeoJson(is3D);
+    }
+
+    public List<Double[]> toGeoJson( boolean includeElevation )
+    {
+
         ArrayList<Double[]> points = new ArrayList<Double[]>(size);
         for (int i = 0; i < size; i++)
         {
-            points.add(new Double[]
-            {
-                getLongitude(i), getLatitude(i)
-            });
+            if (includeElevation)
+                points.add(new Double[]
+                {
+                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)), Helper.round2(getElevation(i))
+                });
+            else
+                points.add(new Double[]
+                {
+                    Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i))
+                });
         }
         return points;
     }
@@ -175,8 +320,11 @@ public boolean equals( Object obj )
         if (obj == null)
             return false;
 
-        final PointList other = (PointList) obj;
-        if (this.size != other.size)
+        PointList other = (PointList) obj;
+        if (other.isEmpty() && other.isEmpty())
+            return true;
+
+        if (this.getSize() != other.getSize() || this.is3D() != other.is3D())
             return false;
 
         for (int i = 0; i < size; i++)
@@ -186,17 +334,26 @@ public boolean equals( Object obj )
 
             if (!NumHelper.equalsEps(longitudes[i], other.longitudes[i]))
                 return false;
+
+            if (is3D && !NumHelper.equalsEps(elevations[i], other.elevations[i]))
+                return false;
         }
         return true;
     }
 
     public PointList clone( boolean reverse )
     {
-        PointList clonePL = new PointList(size);
-        for (int i = 0; i < size; i++)
-        {
-            clonePL.add(latitudes[i], longitudes[i]);
-        }
+        PointList clonePL = new PointList(size, is3D);
+        if (is3D)
+            for (int i = 0; i < size; i++)
+            {
+                clonePL.add(latitudes[i], longitudes[i], elevations[i]);
+            }
+        else
+            for (int i = 0; i < size; i++)
+            {
+                clonePL.add(latitudes[i], longitudes[i]);
+            }
         if (reverse)
             clonePL.reverse();
         return clonePL;
@@ -209,11 +366,18 @@ public PointList copy( int from, int end )
         if (from < 0 || end > size)
             throw new IllegalArgumentException("Illegal interval: " + from + ", " + end + ", size:" + size);
 
-        PointList copyPL = new PointList(size);
-        for (int i = from; i < end; i++)
-        {
-            copyPL.add(latitudes[i], longitudes[i]);
-        }
+        PointList copyPL = new PointList(size, is3D);
+        if (is3D)
+            for (int i = from; i < end; i++)
+            {
+                copyPL.add(latitudes[i], longitudes[i], elevations[i]);
+            }
+        else
+            for (int i = from; i < end; i++)
+            {
+                copyPL.add(latitudes[i], longitudes[i], Double.NaN);
+            }
+
         return copyPL;
     }
 
@@ -232,16 +396,24 @@ public int hashCode()
 
     public double calcDistance( DistanceCalc calc )
     {
-        double lat = -1;
-        double lon = -1;
+        double prevLat = Double.NaN;
+        double prevLon = Double.NaN;
+        double prevEle = Double.NaN;
         double dist = 0;
         for (int i = 0; i < size; i++)
         {
             if (i > 0)
-                dist += calc.calcDist(lat, lon, latitudes[i], longitudes[i]);
-
-            lat = latitudes[i];
-            lon = longitudes[i];
+            {
+                if (is3D)
+                    dist += distCalc3D.calcDist(prevLat, prevLon, prevEle, latitudes[i], longitudes[i], elevations[i]);
+                else
+                    dist += calc.calcDist(prevLat, prevLon, latitudes[i], longitudes[i]);
+            }
+
+            prevLat = latitudes[i];
+            prevLon = longitudes[i];
+            if (is3D)
+                prevEle = elevations[i];
         }
         return dist;
     }
@@ -250,7 +422,7 @@ public double calcDistance( DistanceCalc calc )
      * Takes the string from a json array ala [lon1,lat1], [lon2,lat2], ... and fills the list from
      * it.
      */
-    public void parseJSON( String str )
+    public void parse2DJSON( String str )
     {
         for (String latlon : str.split("\\["))
         {
@@ -259,19 +431,25 @@ public void parseJSON( String str )
 
             String ll[] = latlon.split(",");
             String lat = ll[1].replace("]", "").trim();
-            add(Double.parseDouble(lat), Double.parseDouble(ll[0].trim()));
+            add(Double.parseDouble(lat), Double.parseDouble(ll[0].trim()), Double.NaN);
         }
     }
-    public static final PointList EMPTY = new PointList(0)
+
+    public GHPoint3D toGHPoint( int index )
+    {
+        return new GHPoint3D(getLatitude(index), getLongitude(index), getElevation(index));
+    }
+
+    public static PointList EMPTY = new PointList(0, true)
     {
         @Override
-        public void set( int index, double lat, double lon )
+        public void set( int index, double lat, double lon, double ele )
         {
             throw new RuntimeException("cannot change EMPTY PointList");
         }
 
         @Override
-        public void add( double lat, double lon )
+        public void add( double lat, double lon, double ele )
         {
             throw new RuntimeException("cannot change EMPTY PointList");
         }
@@ -288,6 +466,12 @@ public double getLongitude( int index )
             throw new RuntimeException("cannot access EMPTY PointList");
         }
 
+        @Override
+        public boolean isEmpty()
+        {
+            return true;
+        }
+
         @Override
         public void clear()
         {
@@ -301,7 +485,7 @@ public void trimToSize( int newSize )
         }
 
         @Override
-        public void parseJSON( String str )
+        public void parse2DJSON( String str )
         {
             throw new RuntimeException("cannot change EMPTY PointList");
         }
@@ -309,7 +493,7 @@ public void parseJSON( String str )
         @Override
         public double calcDistance( DistanceCalc calc )
         {
-            return 0;
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
         }
 
         @Override
@@ -321,12 +505,72 @@ public PointList copy( int from, int end )
         @Override
         public PointList clone( boolean reverse )
         {
-            return this;
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public double getElevation( int index )
+        {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public double getLat( int index )
+        {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public double getLon( int index )
+        {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public double getEle( int index )
+        {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public List<Double[]> toGeoJson()
+        {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public void reverse()
+        {
+            throw new UnsupportedOperationException("cannot change EMPTY PointList");
+        }
+
+        @Override
+        public int getSize()
+        {
+            return 0;
+        }
+
+        @Override
+        public int size()
+        {
+            return 0;
+        }
+
+        @Override
+        public GHPoint3D toGHPoint( int index )
+        {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
+        }
+
+        @Override
+        public boolean is3D()
+        {
+            throw new UnsupportedOperationException("cannot access EMPTY PointList");
         }
     };
 
-    public GHPoint toGHPoint( int index )
+    int getCapacity()
     {
-        return new GHPoint(getLatitude(index), getLongitude(index));
+        return latitudes.length;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
new file mode 100644
index 0000000000..c7786a3cc8
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -0,0 +1,129 @@
+package com.graphhopper.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @author jansoe
+ */
+public class RoundaboutInstruction extends Instruction
+{
+    private int exitNumber = 0;
+    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private boolean exited = false;
+    private double radian = Double.NaN;
+
+    public RoundaboutInstruction( int sign, String name, InstructionAnnotation ia, PointList pl )
+    {
+        super(sign, name, ia, pl);
+    }
+
+    public RoundaboutInstruction increaseExitNumber()
+    {
+        this.exitNumber += 1;
+        return this;
+    }
+
+    public RoundaboutInstruction setExitNumber( int exitNumber )
+    {
+        this.exitNumber = exitNumber;
+        return this;
+    }
+
+    public RoundaboutInstruction setDirOfRotation( double deltaIn )
+    {
+        if (clockwise == 0)
+        {
+            clockwise = deltaIn > 0 ? 1 : -1;
+        } else
+        {
+            int clockwise2 = deltaIn > 0 ? 1 : -1;
+            if (clockwise != clockwise2)
+            {
+                clockwise = 2;
+            }
+        }
+        return this;
+    }
+
+    public RoundaboutInstruction setExited()
+    {
+        exited = true;
+        return this;
+    }
+
+    public boolean isExited()
+    {
+        return exited;
+    }
+
+    public int getExitNumber()
+    {
+        if (exited && exitNumber == 0)
+        {
+            throw new IllegalStateException("RoundaboutInstruction must contain exitNumber>0");
+        }
+        return exitNumber;
+    }
+
+    /**
+     * @return radian of angle -2PI < x < 2PI between roundabout entrance and exit
+     *         values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     */
+    public double getRadian()
+    {
+        if (Math.abs(clockwise) != 1)
+        {
+            return Double.NaN;
+        } else
+        {
+            double tmpRadian = Math.PI - clockwise * radian;
+            tmpRadian *= clockwise;
+            return tmpRadian;
+        }
+    }
+
+    public RoundaboutInstruction setRadian( double radian )
+    {
+        this.radian = radian;
+        return this;
+    }
+
+    @Override
+    public Map<String, Object> getExtraInfoJSON()
+    {
+        Map<String, Object> tmpMap = new HashMap<String, Object>(2);
+        tmpMap.put("exit_number", getExitNumber());
+        double radian = getRadian();
+        if (!Double.isNaN(radian))
+        {
+            tmpMap.put("turn_angle", Helper.round(radian, 2));
+        }
+
+        return tmpMap;
+
+    }
+
+    @Override
+    public String getTurnDescription( Translation tr )
+    {
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.USE_ROUNDABOUT)
+        {
+            if (!exited)
+            {
+                str = tr.tr("roundaboutEnter");
+            } else
+            {
+                str = Helper.isEmpty(streetName) ? tr.tr("roundaboutExit", getExitNumber())
+                        : tr.tr("roundaboutExitOnto", getExitNumber(), streetName);
+            }
+        } else
+        {
+            throw new IllegalStateException(indi + "no Roundabout indication");
+        }
+        return str;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/StopWatch.java b/core/src/main/java/com/graphhopper/util/StopWatch.java
index 9a64df4379..dbe55ede43 100644
--- a/core/src/main/java/com/graphhopper/util/StopWatch.java
+++ b/core/src/main/java/com/graphhopper/util/StopWatch.java
@@ -24,6 +24,7 @@
  */
 public class StopWatch
 {
+
     private long lastTime;
     private long nanoTime;
     private String name = "";
diff --git a/core/src/main/java/com/graphhopper/util/Translation.java b/core/src/main/java/com/graphhopper/util/Translation.java
new file mode 100644
index 0000000000..a99296c402
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/Translation.java
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * @author Peter Karich
+ */
+public interface Translation
+{
+
+    String tr( String key, Object... params );
+
+    Map<String, String> asMap();
+
+    Locale getLocale();
+
+    String getLanguage();
+}
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index f6fe7fa51e..4d161efd39 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -25,16 +25,17 @@
  * A class which manages the translations in-memory. Translations are managed here:
  * https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0
  * <p/>
- * and can be easily converted to a language file via: ./core/files/update_translations.sh
- * GraphHopper.csv
- * <p/>
+ * See here for more information: ./docs/core/translations.md
+ * <p>
  * @author Peter Karich
  */
 public class TranslationMap
 {
-    // use 'en' as reference
-    private static final List<String> LOCALES = Arrays.asList("bg", "de_DE", "en_US", "es", "fr", "ja", "pt_PT", "ro", "ru", "si", "tr");
-    private Map<String, Translation> translations = new HashMap<String, Translation>();
+    // ISO codes (639-1), use 'en_US' as reference
+    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es", "fil",
+            "fi", "fr", "gl", "he", "it", "ja", "ne", "nl", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk",
+            "vi_VI", "zh_CN");
+    private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
      * This loads the translation files from the specified folder.
@@ -49,7 +50,7 @@ public TranslationMap doImport( File folder )
                 trMap.doImport(new FileInputStream(new File(folder, locale + ".txt")));
                 add(trMap);
             }
-            checkTranslations();
+            postImportHook();
             return this;
         } catch (Exception ex)
         {
@@ -70,7 +71,7 @@ public TranslationMap doImport()
                 trMap.doImport(TranslationMap.class.getResourceAsStream(locale + ".txt"));
                 add(trMap);
             }
-            checkTranslations();
+            postImportHook();
             return this;
         } catch (Exception ex)
         {
@@ -82,8 +83,17 @@ public void add( Translation tr )
     {
         Locale locale = tr.getLocale();
         translations.put(locale.toString(), tr);
-        if (!locale.getCountry().isEmpty())
+        if (!locale.getCountry().isEmpty() && !translations.containsKey(tr.getLanguage()))
             translations.put(tr.getLanguage(), tr);
+
+        // Map old Java 'standard' to latest, Java is a bit ugly here: http://stackoverflow.com/q/13974169/194609
+        // Hebrew
+        if ("iw".equals(locale.getLanguage()))
+            translations.put("he", tr);
+
+        // Indonesia
+        if ("in".equals(locale.getLanguage()))
+            translations.put("id", tr);
     }
 
     /**
@@ -103,7 +113,7 @@ public Translation getWithFallBack( Locale locale )
     }
 
     /**
-     * Returns the Translation object for the specified locale.
+     * Returns the Translation object for the specified locale and returns null if not found.
      */
     public Translation get( String locale )
     {
@@ -122,46 +132,45 @@ public static int countOccurence( String phrase, String splitter )
         return phrase.trim().split(splitter).length;
     }
 
-    private void checkTranslations()
+    /**
+     * This method does some checks and fills missing translation from en
+     */
+    private void postImportHook()
     {
         Map<String, String> enMap = get("en").asMap();
-        // check against english!
         StringBuilder sb = new StringBuilder();
         for (Translation tr : translations.values())
         {
             Map<String, String> trMap = tr.asMap();
-            for (Entry<String, String> e : enMap.entrySet())
+            for (Entry<String, String> enEntry : enMap.entrySet())
             {
-                String value = trMap.get(e.getKey());
+                String value = trMap.get(enEntry.getKey());
                 if (Helper.isEmpty(value))
+                {
+                    trMap.put(enEntry.getKey(), enEntry.getValue());
                     continue;
-                int expectedCount = countOccurence(e.getValue(), "\\%");
+                }
+
+                int expectedCount = countOccurence(enEntry.getValue(), "\\%");
                 if (expectedCount != countOccurence(value, "\\%"))
                 {
-                    sb.append(tr.getLocale()).append(" - error in ").append(e.getKey()).append("->").
+                    sb.append(tr.getLocale()).append(" - error in ").append(enEntry.getKey()).append("->").
                             append(value).append("\n");
                 }
             }
         }
+
         if (sb.length() > 0)
+        {
+            System.out.println(sb);
             throw new IllegalStateException(sb.toString());
-    }
-
-    public static interface Translation
-    {
-        String tr( String key, Object... params );
-
-        Map<String, String> asMap();
-
-        Locale getLocale();
-
-        String getLanguage();
+        }
     }
 
     public static class TranslationHashMap implements Translation
     {
         private final Map<String, String> map = new HashMap<String, String>();
-        private final Locale locale;
+        final Locale locale;
 
         public TranslationHashMap( Locale locale )
         {
@@ -221,7 +230,7 @@ public TranslationHashMap doImport( InputStream is )
                 throw new IllegalStateException("No input stream found in class path!?");
             try
             {
-                for (String line : Helper.readFile(new InputStreamReader(is, "UTF-8")))
+                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
                 {
                     if (line.isEmpty() || line.startsWith("//") || line.startsWith("#"))
                         continue;
@@ -234,9 +243,6 @@ public TranslationHashMap doImport( InputStream is )
                         throw new IllegalStateException("No key provided:" + line);
 
                     String value = line.substring(index + 1);
-                    if (value.isEmpty() && !key.contains("web"))
-                        throw new IllegalStateException("A key for the core cannot be empty: " + key);
-
                     if (!value.isEmpty())
                         put(key, value);
 
diff --git a/core/src/main/java/com/graphhopper/util/TurnCostIterator.java b/core/src/main/java/com/graphhopper/util/TurnCostIterator.java
deleted file mode 100644
index 84a5661716..0000000000
--- a/core/src/main/java/com/graphhopper/util/TurnCostIterator.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.graphhopper.util;
-
-/**
- * @author Karl Hübner
- */
-public interface TurnCostIterator
-{
-
-    public static int ANY_EDGE = -2;
-
-    public boolean next();
-
-    public int edgeFrom();
-
-    public int edgeTo();
-
-    public int costs();
-
-}
diff --git a/core/src/main/java/com/graphhopper/util/Unzipper.java b/core/src/main/java/com/graphhopper/util/Unzipper.java
index bcb4fee96e..5a68816e8d 100644
--- a/core/src/main/java/com/graphhopper/util/Unzipper.java
+++ b/core/src/main/java/com/graphhopper/util/Unzipper.java
@@ -26,14 +26,6 @@
  */
 public class Unzipper
 {
-    private int size = 1024 * 8;
-
-    public Unzipper setSize( int size )
-    {
-        this.size = size;
-        return this;
-    }
-
     public void unzip( String from, boolean remove ) throws IOException
     {
         String to = Helper.pruneFileEnd(from);
@@ -66,7 +58,7 @@ public void unzip( InputStream fromIs, File toFolder, ProgressListener progressL
         try
         {
             ZipEntry ze = zis.getNextEntry();
-            byte[] buffer = new byte[size];
+            byte[] buffer = new byte[8 * 1024];
             while (ze != null)
             {
                 if (ze.isDirectory())
diff --git a/core/src/main/java/com/graphhopper/util/XFirstSearch.java b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
index fd677f9812..31b56569a7 100644
--- a/core/src/main/java/com/graphhopper/util/XFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
@@ -19,65 +19,20 @@
 
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
-import gnu.trove.stack.array.TIntArrayStack;
 
 /**
- * This class can be used for breadth first search (BFS) or depth first search (DFS)
+ * This abstract class defines commonalities for BFS and DFS
  * <p/>
- * @author Peter Karich
+ * @author Jan Sölter
  */
-public class XFirstSearch
+public abstract class XFirstSearch
 {
-    /**
-     * interface to use a queue (FIFO) OR a stack (LIFO)
-     */
-    interface HelperColl
-    {
-        boolean isEmpty();
-
-        int pop();
-
-        void push( int v );
-    }
-
     protected GHBitSet createBitSet()
     {
         return new GHBitSetImpl();
     }
 
-    public void start( EdgeExplorer explorer, int startNode, boolean depthFirst )
-    {
-        HelperColl coll;
-        if (depthFirst)
-        {
-            coll = new MyIntStack();
-        } else
-        {
-            coll = new MyHelperIntQueue();
-        }
-
-        GHBitSet visited = createBitSet();
-        visited.add(startNode);
-        coll.push(startNode);
-        int current;
-        while (!coll.isEmpty())
-        {
-            current = coll.pop();
-            if (goFurther(current))
-            {
-                EdgeIterator iter = explorer.setBaseNode(current);
-                while (iter.next())
-                {
-                    int connectedId = iter.getAdjNode();
-                    if (checkAdjacent(iter) && !visited.contains(connectedId))
-                    {
-                        visited.add(connectedId);
-                        coll.push(connectedId);
-                    }
-                }
-            }
-        }
-    }
+    public abstract void start( EdgeExplorer explorer, int startNode );
 
     protected boolean goFurther( int nodeId )
     {
@@ -88,17 +43,4 @@ protected boolean checkAdjacent( EdgeIteratorState edge )
     {
         return true;
     }
-
-    static class MyIntStack extends TIntArrayStack implements HelperColl
-    {
-        @Override
-        public boolean isEmpty()
-        {
-            return super.size() == 0;
-        }
-    }
-
-    static class MyHelperIntQueue extends SimpleIntDeque implements HelperColl
-    {
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index 4d89ddc155..d0eb1ebb46 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.util.shapes;
 
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
 import java.util.ArrayList;
 import java.util.List;
@@ -33,62 +34,104 @@
  */
 public class BBox implements Shape, Cloneable
 {
-    /**
-     * A bounding box which prefills the values with minimum values so that it can increase.
-     */
-    public static final BBox INVERSE = new BBox();
 
-    static
-    {
-        INVERSE.minLon = Double.MAX_VALUE;
-        INVERSE.maxLon = -Double.MAX_VALUE;
-        INVERSE.minLat = Double.MAX_VALUE;
-        INVERSE.maxLat = -Double.MAX_VALUE;
-    }
-    // longitude (theta) = x, latitude (phi) = y
+    // longitude (theta) = x, latitude (phi) = y, elevation = z
     public double minLon;
     public double maxLon;
     public double minLat;
     public double maxLat;
+    public double minEle;
+    public double maxEle;
+    private final boolean elevation;
 
-    private BBox()
+    public BBox( double minLon, double maxLon, double minLat, double maxLat )
     {
+        this(minLon, maxLon, minLat, maxLat, Double.NaN, Double.NaN, false);
     }
 
-    public BBox( double minLon, double maxLon, double minLat, double maxLat )
+    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle )
     {
+        this(minLon, maxLon, minLat, maxLat, minEle, maxEle, true);
+    }
+
+    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean elevation )
+    {
+        this.elevation = elevation;
         this.maxLat = maxLat;
         this.minLon = minLon;
         this.minLat = minLat;
         this.maxLon = maxLon;
+        this.minEle = minEle;
+        this.maxEle = maxEle;
     }
 
-    public boolean check()
+    public boolean hasElevation()
     {
-        // "second longitude should be bigger than the first";
-        if (minLon >= maxLon)
+        return elevation;
+    }
+
+    /**
+     * Prefills BBox with minimum values so that it can increase.
+     */
+    public static BBox createInverse( boolean elevation )
+    {
+        if (elevation)
         {
-            return false;
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.MAX_VALUE, -Double.MAX_VALUE, true);
+        } else
+        {
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.NaN, Double.NaN, false);
         }
+    }
 
-        //"second latitude should be smaller than the first";
-        if (minLat >= maxLat)
+    public void update( double lat, double lon )
+    {
+        if (lat > maxLat)
         {
-            return false;
+            maxLat = lat;
         }
-        return true;
 
+        if (lat < minLat)
+        {
+            minLat = lat;
+        }
+
+        if (lon > maxLon)
+        {
+            maxLon = lon;
+        }
+        if (lon < minLon)
+        {
+            minLon = lon;
+        }
     }
 
-    public static BBox createEarthMax()
+    public void update( double lat, double lon, double elev )
     {
-        return new BBox(-180.0, 180.0, -90.0, 90.0);
+        if (elevation)
+        {
+            if (elev > maxEle)
+            {
+                maxEle = elev;
+            }
+            if (elev < minEle)
+            {
+                minEle = elev;
+            }
+        } else
+        {
+            throw new IllegalStateException("No BBox with elevation to update");
+        }
+        update(lat, lon);
+
     }
 
     @Override
     public BBox clone()
     {
-        return new BBox(minLon, maxLon, minLat, maxLat);
+        return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, elevation);
     }
 
     @Override
@@ -150,7 +193,11 @@ public boolean contains( Circle c )
     @Override
     public String toString()
     {
-        return minLon + "," + maxLon + "," + minLat + "," + maxLat;
+        String str = minLon + "," + maxLon + "," + minLat + "," + maxLat;
+        if (elevation)
+            str += "," + minEle + "," + maxEle;
+
+        return str;
     }
 
     public String toLessPrecisionString()
@@ -189,22 +236,49 @@ public int hashCode()
 
     public boolean isValid()
     {
-        return Double.doubleToLongBits(maxLat) != Double.doubleToLongBits(INVERSE.maxLat)
-                && Double.doubleToLongBits(minLat) != Double.doubleToLongBits(INVERSE.minLat)
-                && Double.doubleToLongBits(maxLon) != Double.doubleToLongBits(INVERSE.maxLon)
-                && Double.doubleToLongBits(minLon) != Double.doubleToLongBits(INVERSE.minLon);
+        // second longitude should be bigger than the first
+        if (minLon >= maxLon)
+            return false;
+
+        // second latitude should be smaller than the first
+        if (minLat >= maxLat)
+            return false;
+
+        if (elevation)
+        {
+            // equal elevation is okay
+            if (minEle > maxEle)
+                return false;
+
+            if (Double.compare(maxEle, -Double.MAX_VALUE) == 0
+                    || Double.compare(minEle, Double.MAX_VALUE) == 0)
+                return false;
+        }
+
+        return Double.compare(maxLat, -Double.MAX_VALUE) != 0
+                && Double.compare(minLat, Double.MAX_VALUE) != 0
+                && Double.compare(maxLon, -Double.MAX_VALUE) != 0
+                && Double.compare(minLon, Double.MAX_VALUE) != 0;
     }
 
     /**
-     * @return array containing this bounding box. Attention: GeoJson is lon,lat!
+     * @return array containing this bounding box. Attention: GeoJson is lon,lat! If 3D is gets even
+     * worse: lon,lat,ele
      */
     public List<Double> toGeoJson()
     {
         List<Double> list = new ArrayList<Double>(4);
-        list.add(minLon);
-        list.add(minLat);
-        list.add(maxLon);
-        list.add(maxLat);
+        list.add(Helper.round6(minLon));
+        list.add(Helper.round6(minLat));
+        // hmh
+        if (elevation)
+            list.add(Helper.round2(minEle));
+
+        list.add(Helper.round6(maxLon));
+        list.add(Helper.round6(maxLat));
+        if (elevation)
+            list.add(Helper.round2(maxEle));
+
         return list;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Circle.java b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
index 2ff252007a..0eee29724e 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/Circle.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
@@ -18,15 +18,14 @@
 package com.graphhopper.util.shapes;
 
 import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
 
 /**
  * @author Peter Karich
  */
 public class Circle implements Shape
 {
-    private final static DistanceCalc SINGLETON = new DistanceCalcEarth();
-    private DistanceCalc calc = SINGLETON;
+    private DistanceCalc calc = Helper.DIST_EARTH;
     private final double radiusInKm;
     private final double lat;
     private final double lon;
@@ -35,7 +34,7 @@
 
     public Circle( double lat, double lon, double radiusInMeter )
     {
-        this(lat, lon, radiusInMeter, SINGLETON);
+        this(lat, lon, radiusInMeter, Helper.DIST_EARTH);
     }
 
     public Circle( double lat, double lon, double radiusInMeter, DistanceCalc calc )
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordFloat.java b/core/src/main/java/com/graphhopper/util/shapes/CoordFloat.java
deleted file mode 100644
index b33603bc3a..0000000000
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordFloat.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util.shapes;
-
-/**
- * Single precision coordinates without an associated value. To add one -
- * subclass.
- * <p/>
- * @author Peter Karich
- */
-public class CoordFloat<T> {
-
-    public float lat;
-    public float lon;
-
-    public CoordFloat() {
-    }
-
-    public CoordFloat(float lat, float lon) {
-        this.lat = lat;
-        this.lon = lon;
-    }
-
-    public void setValue(T t) {
-        throw new UnsupportedOperationException("Use CoordTrigObjEntry for value access");
-    }
-
-    public T getValue() {
-        throw new UnsupportedOperationException("Use CoordTrigObjEntry for value access");
-    }
-
-    @Override
-    public String toString() {
-        return lat + "," + lon;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordTrig.java b/core/src/main/java/com/graphhopper/util/shapes/CoordTrig.java
deleted file mode 100644
index b4258be814..0000000000
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordTrig.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util.shapes;
-
-import com.graphhopper.util.NumHelper;
-
-/**
- * Double precision coordinates without an associated value. To add one - subclass.
- * <p/>
- * @author Peter Karich
- */
-public class CoordTrig<T>
-{
-    public double lat = Double.NaN;
-    public double lon = Double.NaN;
-
-    public CoordTrig()
-    {
-    }
-
-    public CoordTrig( double lat, double lon )
-    {
-        this.lat = lat;
-        this.lon = lon;
-    }
-
-    public double getLon()
-    {
-        return lon;
-    }
-
-    public double getLat()
-    {
-        return lat;
-    }
-
-    public boolean isValid()
-    {
-        return !Double.isNaN(lat) && !Double.isNaN(lon);
-    }
-
-    public void setValue( T t )
-    {
-        throw new UnsupportedOperationException("Use CoordTrigObjEntry for value access");
-    }
-
-    public T getValue()
-    {
-        throw new UnsupportedOperationException("Use CoordTrigObjEntry for value access");
-    }
-
-    @Override
-    public int hashCode()
-    {
-        int hash = 7;
-        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lat) ^ (Double.doubleToLongBits(this.lat) >>> 32));
-        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lon) ^ (Double.doubleToLongBits(this.lon) >>> 32));
-        return hash;
-    }
-
-    @Override
-    public boolean equals( Object obj )
-    {
-        if (obj == null)
-            return false;
-
-        @SuppressWarnings("unchecked")
-        final CoordTrig<T> other = (CoordTrig<T>) obj;
-        return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
-    }
-
-    @Override
-    public String toString()
-    {
-        return lat + "," + lon;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigIntEntry.java b/core/src/main/java/com/graphhopper/util/shapes/CoordTrigIntEntry.java
deleted file mode 100644
index 1bae9fd822..0000000000
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigIntEntry.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util.shapes;
-
-/**
- *
- * @author Peter Karich
- */
-public class CoordTrigIntEntry extends CoordTrig<Integer>
-{
-    private int v;
-
-    public CoordTrigIntEntry()
-    {
-    }
-
-    public CoordTrigIntEntry( int o, double lat, double lon )
-    {
-        super(lat, lon);
-        this.v = o;
-    }
-
-    @Override
-    public void setValue( Integer t )
-    {
-        v = t;
-    }
-
-    @Override
-    public Integer getValue()
-    {
-        return v;
-    }
-
-    @Override
-    public String toString()
-    {
-        return super.toString() + " value:" + v;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigObjEntry.java b/core/src/main/java/com/graphhopper/util/shapes/CoordTrigObjEntry.java
deleted file mode 100644
index 6db7def40a..0000000000
--- a/core/src/main/java/com/graphhopper/util/shapes/CoordTrigObjEntry.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util.shapes;
-
-/**
- *
- * @author Peter Karich
- */
-public class CoordTrigObjEntry<T> extends CoordTrig<T>
-{
-    private T v;
-
-    public CoordTrigObjEntry()
-    {
-    }
-
-    public CoordTrigObjEntry( T o, double lat, double lon )
-    {
-        super(lat, lon);
-        this.v = o;
-    }
-
-    @Override
-    public void setValue( T t )
-    {
-        v = t;
-    }
-
-    @Override
-    public T getValue()
-    {
-        return v;
-    }
-
-    @Override
-    public String toString()
-    {
-        return super.toString() + " value:" + v;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java b/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
index ae5a826283..5d855629bc 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPlace.java
@@ -24,7 +24,7 @@
  * <p/>
  * @author Peter Karich
  */
-public class GHPlace extends CoordTrig<String>
+public class GHPlace extends GHPoint
 {
     private String name = "";
 
@@ -39,11 +39,9 @@ public GHPlace( String name )
 
     public GHPlace( double lat, double lon )
     {
-        this.lat = lat;
-        this.lon = lon;
+        super(lat, lon);
     }
 
-    @Override
     public void setValue( String t )
     {
         setName(t);
@@ -77,33 +75,4 @@ public String toString()
 
         return str.trim();
     }
-
-    public static GHPlace parse( String str )
-    {
-        // if the point is in the format of lat,lon we don't need to call geocoding service
-        String[] fromStrs = str.split(",");
-        if (fromStrs.length == 2)
-        {
-            try
-            {
-                double fromLat = Double.parseDouble(fromStrs[0]);
-                double fromLon = Double.parseDouble(fromStrs[1]);
-                return new GHPlace(fromLat, fromLon);
-            } catch (Exception ex)
-            {
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Attention: geoJson is LON,LAT
-     */
-    public Double[] toGeoJson()
-    {
-        return new Double[]
-        {
-            lon, lat
-        };
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 866b1ef911..5ca18aa337 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -17,18 +17,76 @@
  */
 package com.graphhopper.util.shapes;
 
+import com.graphhopper.util.NumHelper;
+
 /**
  * @author Peter Karich
  */
-public class GHPoint extends CoordTrig<Void>
+public class GHPoint
 {
+    public double lat = Double.NaN;
+    public double lon = Double.NaN;
+
     public GHPoint()
     {
     }
 
     public GHPoint( double lat, double lon )
     {
-        super(lat, lon);
+        this.lat = lat;
+        this.lon = lon;
+    }
+
+    public double getLon()
+    {
+        return lon;
+    }
+
+    public double getLat()
+    {
+        return lat;
+    }
+
+    public boolean isValid()
+    {
+        return !Double.isNaN(lat) && !Double.isNaN(lon);
+    }
+
+    @Override
+    public int hashCode()
+    {
+        int hash = 7;
+        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lat) ^ (Double.doubleToLongBits(this.lat) >>> 32));
+        hash = 83 * hash + (int) (Double.doubleToLongBits(this.lon) ^ (Double.doubleToLongBits(this.lon) >>> 32));
+        return hash;
+    }
+
+    @Override
+    public boolean equals( Object obj )
+    {
+        if (obj == null)
+            return false;
+
+        @SuppressWarnings("unchecked")
+        final GHPoint other = (GHPoint) obj;
+        return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
+    }
+
+    @Override
+    public String toString()
+    {
+        return lat + "," + lon;
+    }
+
+    /**
+     * Attention: geoJson is LON,LAT
+     */
+    public Double[] toGeoJson()
+    {
+        return new Double[]
+        {
+            lon, lat
+        };
     }
 
     public static GHPoint parse( String str )
diff --git a/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
new file mode 100644
index 0000000000..cab721686c
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/shapes/GHPoint3D.java
@@ -0,0 +1,84 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.shapes;
+
+import com.graphhopper.util.NumHelper;
+
+/**
+ * @author Peter Karich
+ */
+public class GHPoint3D extends GHPoint
+{
+    public double ele;
+
+    public GHPoint3D( double lat, double lon, double elevation )
+    {
+        super(lat, lon);
+        this.ele = elevation;
+    }
+
+    public double getElevation()
+    {
+        return ele;
+    }
+
+    public double getEle()
+    {
+        return ele;
+    }
+
+    @Override
+    public int hashCode()
+    {
+        int hash = 59 * super.hashCode()
+                + (int) (Double.doubleToLongBits(this.ele) ^ (Double.doubleToLongBits(this.ele) >>> 32));
+        return hash;
+    }
+
+    @Override
+    public boolean equals( Object obj )
+    {
+        if (obj == null)
+            return false;
+
+        @SuppressWarnings("unchecked")
+        final GHPoint3D other = (GHPoint3D) obj;
+        if (Double.isNaN(ele))
+            // very special case necessary in QueryGraph, asserted via test
+            return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
+        else
+            return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon)
+                    && NumHelper.equalsEps(ele, other.ele);
+    }
+
+    @Override
+    public String toString()
+    {
+        return super.toString() + "," + ele;
+    }
+
+    @Override
+    public Double[] toGeoJson()
+    {
+        return new Double[]
+        {
+            lon, lat, ele
+        };
+    }
+}
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Africa_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/Africa_names.txt.zip
new file mode 100644
index 0000000000..968a5c0c88
Binary files /dev/null and b/core/src/main/resources/com/graphhopper/reader/dem/Africa_names.txt.zip differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Australia_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/Australia_names.txt.zip
new file mode 100644
index 0000000000..8b0b0b3ab5
Binary files /dev/null and b/core/src/main/resources/com/graphhopper/reader/dem/Australia_names.txt.zip differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Eurasia_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/Eurasia_names.txt.zip
new file mode 100644
index 0000000000..0fefc171d4
Binary files /dev/null and b/core/src/main/resources/com/graphhopper/reader/dem/Eurasia_names.txt.zip differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/Islands_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/Islands_names.txt.zip
new file mode 100644
index 0000000000..8a8aa9c177
Binary files /dev/null and b/core/src/main/resources/com/graphhopper/reader/dem/Islands_names.txt.zip differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/North_America_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/North_America_names.txt.zip
new file mode 100644
index 0000000000..de10d69e00
Binary files /dev/null and b/core/src/main/resources/com/graphhopper/reader/dem/North_America_names.txt.zip differ
diff --git a/core/src/main/resources/com/graphhopper/reader/dem/South_America_names.txt.zip b/core/src/main/resources/com/graphhopper/reader/dem/South_America_names.txt.zip
new file mode 100644
index 0000000000..d1db72dc34
Binary files /dev/null and b/core/src/main/resources/com/graphhopper/reader/dem/South_America_names.txt.zip differ
diff --git a/core/src/main/resources/com/graphhopper/util/bg.txt b/core/src/main/resources/com/graphhopper/util/bg.txt
index 303332d6a1..6051b86336 100644
--- a/core/src/main/resources/com/graphhopper/util/bg.txt
+++ b/core/src/main/resources/com/graphhopper/util/bg.txt
@@ -1,26 +1,31 @@
-sharp_left=рязко няляво
-sharp_right=рязко надясно
-left=наляво
-right=надясно
-slight_left=леко наляво
-slight_right=леко надясно
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=продължи
 continue_onto=продължи по %1$s
-turn=завий %1$s
-turn_onto=завий %1$s по %2$s
+turn_left=завий наляво
+turn_right=завий надясно
+turn_slight_left=завий леко наляво
+turn_slight_right=завий леко надясно
+turn_sharp_left=завий рязко наляво
+turn_sharp_right=завий рязко надясно
+turn_onto=%1$s по %2$s
 web.searchButton=Търсене
 web.fromHint=От
+web.viaHint=през
 web.toHint=До
 web.moreButton=още
-web.gpxExportButton=GPX export
-web.routeInfo=%1$s ще отнеме %2$s
+web.gpxExportButton=GPX експорт
+web.routeInfo=%1$s ще отнемат %2$s
 web.locationsNotFound=Не са изтеглени упътвания. Търсеното местоположение не е открито.
 web.bike=Велосипед
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=Състезателно колело
+web.mtb=Планинско колело
 web.car=Автомобил
 web.foot=Пеш
-finish=мишена
+web.staticlink=статична връзка
+web.motorcycle=Мотоциклет
+via=през
+finish=Крайна цел!
 hourAbbr=ч
 dayAbbr=д
 minAbbr=мин
@@ -28,9 +33,13 @@ kmAbbr=км
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
+road=улица
+off_bike=в този участък трябва да слезеш от колелото!
+cycleway=велоалея
+way=път
+paved=асфалтиран
+unpaved=черен
+stopover=прехвърляне %1$s
+roundaboutEnter=Влез в кръговото кръстовище
+roundaboutExit=На кръговото кръстовище използвайте изход %1$s
+roundaboutExitOnto=На кръговото кръстовище използвайте изход %1$s по %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ca.txt b/core/src/main/resources/com/graphhopper/util/ca.txt
new file mode 100644
index 0000000000..512ca12aa6
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ca.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=continua
+continue_onto=continua per %1$s
+turn_left=gira a l'esquerra
+turn_right=gira a la dreta
+turn_slight_left=gira lleugerament a l'esquerra
+turn_slight_right=gira lleugerament a la dreta
+turn_sharp_left=gira just a l'esquerra
+turn_sharp_right=gira just a la dreta
+turn_onto=%1$s per %2$s
+web.searchButton=Buscar
+web.fromHint=Des de
+web.viaHint=passant per
+web.toHint=Cap a
+web.moreButton=més
+web.gpxExportButton=Exportar GPX
+web.routeInfo=%1$s trigaràs %2$s
+web.locationsNotFound=No hi ha cap ruta. El destí no es troba dins l'àrea.
+web.bike=Bicicleta
+web.racingbike=Bicicleta de carrera
+web.mtb=Bicicleta de montanya
+web.car=Cotxe
+web.foot=A peu
+web.staticlink=Enllaç
+web.motorcycle=Motocicleta
+via=passant per
+finish=Has arribat !!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=pe
+road=carretera
+off_bike=Tros a peu
+cycleway=via ciclista
+way=camí
+paved=pavimentat
+unpaved=sense pavimentar
+stopover=passant per %1$s
+roundaboutEnter=Entra a la rotonda
+roundaboutExit=A la rotonda, agafa la %1$s sortida
+roundaboutExitOnto=A la rotonda, agafa la sortida %1$s cap a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/de_DE.txt b/core/src/main/resources/com/graphhopper/util/de_DE.txt
index 23cc4a344f..e778c5cc28 100644
--- a/core/src/main/resources/com/graphhopper/util/de_DE.txt
+++ b/core/src/main/resources/com/graphhopper/util/de_DE.txt
@@ -1,18 +1,20 @@
-sharp_left=scharf links
-sharp_right=scharf rechts
-left=links
-right=rechts
-slight_left=leicht links
-slight_right=leicht rechts
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=geradeaus
 continue_onto=geradeaus auf %1$s
-turn=%1$s abbiegen
-turn_onto=%1$s abbiegen auf %2$s
+turn_left=links abbiegen
+turn_right=rechts abbiegen
+turn_slight_left=leicht links abbiegen
+turn_slight_right=leicht rechts abbiegen
+turn_sharp_left=scharf links abbiegen
+turn_sharp_right=scharf rechts abbiegen
+turn_onto=%1$s auf %2$s
 web.searchButton=Suche
 web.fromHint=Von
+web.viaHint=Über
 web.toHint=Nach
 web.moreButton=mehr
-web.gpxExportButton=GPX Export
+web.gpxExportButton=GPX export
 web.routeInfo=%1$s werden %2$s brauchen
 web.locationsNotFound=Routing war nicht möglich. Ort(e) nicht gefunden in diesem Gebiet.
 web.bike=Fahrrad
@@ -20,6 +22,9 @@ web.racingbike=Rennrad
 web.mtb=Mountainbike
 web.car=Auto
 web.foot=Zu Fuß
+web.staticlink=Link
+web.motorcycle=Motorrad
+via=über
 finish=Ziel erreicht!
 hourAbbr=h
 dayAbbr=d
@@ -28,9 +33,13 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=Strasse
-pushing_section=Schiebestrecke
+road=Straße
+off_bike=Schiebestrecke
 cycleway=Radweg
 way=Weg
 paved=befestigt
 unpaved=unbefestigt
+stopover=Zwischenziel %1$s
+roundaboutEnter=In den Kreisverkehr einfahren
+roundaboutExit=Im Kreisverkehr Ausfahrt %1$s nehmen
+roundaboutExitOnto=Im Kreisverkehr Ausfahrt %1$s auf %2$s nehmen
diff --git a/core/src/main/resources/com/graphhopper/util/el.txt b/core/src/main/resources/com/graphhopper/util/el.txt
new file mode 100644
index 0000000000..b60ca9b5cd
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/el.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=συνεχίστε
+continue_onto=συνεχίστε στην %1$s
+turn_left=στρίψτε αριστερά
+turn_right=στρίψτε δεξιά
+turn_slight_left=στρίψτε λοξά αριστερά
+turn_slight_right=στρίψτε λοξά δεξιά
+turn_sharp_left=στρίψτε κλειστά αριστερά
+turn_sharp_right=στρίψτε κλειστά δεξιά
+turn_onto=%1$s στην %2$s
+web.searchButton=Αναζήτηση
+web.fromHint=Αφετηρία
+web.viaHint=Μέσω
+web.toHint=Προορισμός
+web.moreButton=περισσότερα
+web.gpxExportButton=Εξαγωγή GPX
+web.routeInfo=%1$s σε %2$s
+web.locationsNotFound=Η δρομολόγηση δεν είναι δυνατή. Οι τοποθεσίες δεν βρέθηκαν στην περιοχή.
+web.bike=Ποδήλατο
+web.racingbike=Αγωνιστικό ποδήλατο
+web.mtb=Ποδήλατο βουνού
+web.car=Αυτοκίνητο
+web.foot=Πεζός
+web.staticlink=στατική διεύθυνση
+web.motorcycle=Μοτοσυκλέτα
+via=μέσω
+finish=Τέρμα!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=δρόμος
+off_bike=κατεβείτε από το ποδήλατο
+cycleway=ποδηλατόδρομος
+way=δρόμος
+paved=ασφαλτοστρωμένος
+unpaved=χωματόδρομος
+stopover=ενδιάμεση στάση %1$s
+roundaboutEnter=Μπείτε στον κυκλικό κόμβο
+roundaboutExit=Στον κυκλικό κόμβο βγείτε στην έξοδο %1$s
+roundaboutExitOnto=Στον κυκλικό κόμβο βγείτε στην έξοδο %1$s στην %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index 5c8035891f..c886850443 100644
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -1,15 +1,17 @@
-sharp_left=sharp left
-sharp_right=sharp right
-left=left
-right=right
-slight_left=slight left
-slight_right=slight right
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=continue
 continue_onto=continue onto %1$s
-turn=turn %1$s
-turn_onto=turn %1$s onto %2$s
+turn_left=turn left
+turn_right=turn right
+turn_slight_left=turn slight left
+turn_slight_right=turn slight right
+turn_sharp_left=turn sharp left
+turn_sharp_right=turn sharp right
+turn_onto=%1$s onto %2$s
 web.searchButton=Search
 web.fromHint=From
+web.viaHint=Via
 web.toHint=To
 web.moreButton=more
 web.gpxExportButton=GPX export
@@ -20,6 +22,9 @@ web.racingbike=Racingbike
 web.mtb=Mountainbike
 web.car=Car
 web.foot=Foot
+web.staticlink=static link
+web.motorcycle=Motorcycle
+via=via
 finish=Finish!
 hourAbbr=h
 dayAbbr=d
@@ -29,8 +34,12 @@ mAbbr=m
 miAbbr=mi
 ftAbbr=ft
 road=road
-pushing_section=pushing section
+off_bike=get off the bike
 cycleway=cycleway
 way=way
 paved=paved
 unpaved=unpaved
+stopover=stopover %1$s
+roundaboutEnter=Enter roundabout
+roundaboutExit=At roundabout, take exit %1$s
+roundaboutExitOnto=At roundabout, take exit %1$s onto %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/es.txt b/core/src/main/resources/com/graphhopper/util/es.txt
index dcfa1d101c..487ae279b0 100644
--- a/core/src/main/resources/com/graphhopper/util/es.txt
+++ b/core/src/main/resources/com/graphhopper/util/es.txt
@@ -1,26 +1,31 @@
-sharp_left=justo a la izquierda
-sharp_right=justo a la derecha
-left=izquierda
-right=derecha
-slight_left=gire a la izquierda
-slight_right=gire a la derecha
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=continúe
 continue_onto=continúe por %1$s
-turn=gire %1$s
-turn_onto=gire %1$s por %2$s
+turn_left=gire a la izquierda
+turn_right=gire a la derecha
+turn_slight_left=gire leve a la izquierda
+turn_slight_right=gire leve a la derecha
+turn_sharp_left=gire fuerte a la izquierda
+turn_sharp_right=gire fuerte a la derecha
+turn_onto=%1$s por %2$s
 web.searchButton=Buscar
 web.fromHint=Desde
-web.toHint=hasta
+web.viaHint=Pasando por
+web.toHint=Hasta
 web.moreButton=más
-web.gpxExportButton=GPX export
+web.gpxExportButton=Exportar GPX
 web.routeInfo=%1$s tardará %2$s 
 web.locationsNotFound=No se ha encontrado la ruta. El destino no se encuentra en el área.
 web.bike=Bicicleta
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=Bicicleta de carrera
+web.mtb=Bicicleta de montaña
 web.car=Coche
-web.foot=A pié
-finish=Objetivo logrado
+web.foot=A pie
+web.staticlink=enlace estático
+web.motorcycle=Motocicleta
+via=pasando por
+finish=¡Fin del recorrido!
 hourAbbr=h
 dayAbbr=d
 minAbbr=min
@@ -28,9 +33,13 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
+road=carretera
+off_bike=bájese de la bicicleta
+cycleway=Ciclovía 
+way=camino
+paved=pavimentado
+unpaved=no pavimentado
+stopover=pasando por %1$s
+roundaboutEnter=Entre en la rotonda
+roundaboutExit=En la rotonda, tome la salida %1$s
+roundaboutExitOnto=En la rotonda, tome la salida %1$s hacia %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fi.txt b/core/src/main/resources/com/graphhopper/util/fi.txt
new file mode 100644
index 0000000000..b5d23f834a
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/fi.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=jatka
+continue_onto=jatka tielle %1$S
+turn_left=käänny vasemmalle
+turn_right=käänny oikealle
+turn_slight_left=käänny loivasti vasemmalle
+turn_slight_right=käänny loivasti oikealle
+turn_sharp_left=käänny jyrkästi vasemmalle
+turn_sharp_right=käänny jyrkästi oikealle
+turn_onto=%1$S tielle %2$S
+web.searchButton=Etsi
+web.fromHint=Lähtöpaikka
+web.viaHint=Reittipiste
+web.toHint=Määränpää
+web.moreButton=lisää
+web.gpxExportButton=GPX-tuonti
+web.routeInfo=%1$s kestää %2$s
+web.locationsNotFound=Reittiohjeiden luonti epäonnistui. Paikkaa ei löydy tältä alueelta.
+web.bike=Pyörällä
+web.racingbike=Kilpapyörällä
+web.mtb=Maastopyörällä
+web.car=Autolla
+web.foot=Kävellen
+web.staticlink=
+web.motorcycle=Moottoripyörällä
+via=kautta
+finish=Olet perillä!
+hourAbbr=h
+dayAbbr=pv
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=tie
+off_bike=taluta pyörää
+cycleway=pyörätie
+way=tie
+paved=päällystetty
+unpaved=päällystämätön
+stopover=%1$s. pysähdys
+roundaboutEnter=Aja liikenneympyrään
+roundaboutExit=Liikenneympyrästä poistu %1$s. liittymästä
+roundaboutExitOnto=Liikenneympyrästä poistu %1$s. liittymästä suuntaan %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fil.txt b/core/src/main/resources/com/graphhopper/util/fil.txt
new file mode 100644
index 0000000000..31b7c554cd
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/fil.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=tuwirín ang daán
+continue_onto=magpatuloy papunta sa %1$s
+turn_left=pagliko kaliwa
+turn_right=pagliko karapatan
+turn_slight_left=pagliko bahagyang kaliwa
+turn_slight_right=pagliko bahagyang kanan
+turn_sharp_left=pagliko matalim kaliwa
+turn_sharp_right=pagliko matalim karapatan
+turn_onto=%1$s papunta sa %2$s
+web.searchButton=Paghahanap
+web.fromHint=mula sa 
+web.viaHint=
+web.toHint=upang sa
+web.moreButton=mas
+web.gpxExportButton=GPX Export
+web.routeInfo=%1$s ay magdadala sa %2$s
+web.locationsNotFound=Routing hindi maaari, hindi nahanap Lokasyon sa lugar.
+web.bike=Bike
+web.racingbike=RacingBike
+web.mtb=MountainBike
+web.car=kotse
+web.foot=lumakad
+web.staticlink=static link
+web.motorcycle=motorsiklo
+via=sa pamamagitan ng
+finish=Tapusin!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=kalsada 
+off_bike=seksyon pagtulak 
+cycleway=cycleway
+way=landas
+paved=aspaltado 
+unpaved=hindi aspaltado
+stopover=pamahingahan %1$s
+roundaboutEnter=Lpasok Rotonda
+roundaboutExit=Sa rotonda, lumabas sa exit %1$s
+roundaboutExitOnto=Sa rotonda, lumabas sa exit papunta %1$s %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fr.txt b/core/src/main/resources/com/graphhopper/util/fr.txt
index 9d69f55191..7f77887d4f 100644
--- a/core/src/main/resources/com/graphhopper/util/fr.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr.txt
@@ -1,25 +1,30 @@
-sharp_left=fort à gauche
-sharp_right=fort à droite
-left=à gauche
-right=à droite
-slight_left=légèrement à gauche
-slight_right=légèrement à droite
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=continuez
 continue_onto=continuez sur %1$s
-turn=tournez %1$s
-turn_onto=tournez %1$s sur %2$s
+turn_left=tournez à gauche
+turn_right=tournez à droite
+turn_slight_left=tournez légèrement à gauche
+turn_slight_right=tournez légèrement à droite
+turn_sharp_left=tournez fort à gauche
+turn_sharp_right=tournez fort à droite
+turn_onto=%1$s sur %2$s
 web.searchButton=Rechercher
 web.fromHint=De
+web.viaHint=via
 web.toHint=À
 web.moreButton=plus
-web.gpxExportButton=GPX export
+web.gpxExportButton=Export GPX
 web.routeInfo=%1$s durera %2$s 
 web.locationsNotFound=Calcul d'itinéraire impossible. Position(s) non trouvée(s) dans la zone.
 web.bike=Vélo
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=Vélo de route
+web.mtb=VTT
 web.car=Voiture
 web.foot=À pied
+web.staticlink=Lien
+web.motorcycle=Vélo
+via=via
 finish=Fini!
 hourAbbr=h
 dayAbbr=j
@@ -28,9 +33,13 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
+road=route
+off_bike=Descendez du vélo
+cycleway=piste cyclable
+way=chemin
+paved=pavé
+unpaved=non-pavé
+stopover=escale %1$s
+roundaboutEnter=Empruntez le rond-point
+roundaboutExit=Au rond-point, prennez la %1$s sortie
+roundaboutExitOnto=Au rond-point, prennez la %1$s sortie vers %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/gl.txt b/core/src/main/resources/com/graphhopper/util/gl.txt
new file mode 100644
index 0000000000..8a91be54a8
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/gl.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=continúe
+continue_onto=continúe por %1$s
+turn_left=vire por esquerda
+turn_right=vire por dereita
+turn_slight_left=vire á esquerda
+turn_slight_right=vire á dereita
+turn_sharp_left=vire por xusto á esquerda
+turn_sharp_right=vire por xusto á dereita
+turn_onto=%1$s por %2$s
+web.searchButton=buscar
+web.fromHint=dende
+web.viaHint=Vía
+web.toHint=ata
+web.moreButton=máis
+web.gpxExportButton=GPX Exportación
+web.routeInfo=%1$s tardará %2$s
+web.locationsNotFound=Non se atopou a ruta. O destino non se atopa na área
+web.bike=Bicicleta
+web.racingbike=Bicleta de carreiras
+web.mtb=Bicicleta de montaña
+web.car=automóbil
+web.foot=A pé
+web.staticlink=Enlace
+web.motorcycle=
+via=vía
+finish=Obxectivo acadado
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=mts
+miAbbr=mi
+ftAbbr=ft
+road=estrada
+off_bike=sector a pé
+cycleway=vía ciclista
+way=vía 
+paved=asfaltada
+unpaved=non pavimentada
+stopover=escala%1$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/he.txt b/core/src/main/resources/com/graphhopper/util/he.txt
new file mode 100644
index 0000000000..963ba6a920
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/he.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=להמשיך
+continue_onto=להמשיך לתוך %1$s
+turn_left=שמאלה
+turn_right=ימינה
+turn_slight_left=מעט שמאלה
+turn_slight_right=מעט ימינה
+turn_sharp_left=שמאלה בחדות
+turn_sharp_right=ימינה בחדות
+turn_onto=יש לפנות %1$s לתוך %2$s
+web.searchButton=חיפוש
+web.fromHint=מוצא
+web.viaHint=דרך
+web.toHint=יעד
+web.moreButton=עוד
+web.gpxExportButton=ייצוא GPX
+web.routeInfo=%1$s ייקחו %2$s
+web.locationsNotFound=אין נתיב ישיר אל היעד. המיקום לא נמצא באזור.
+web.bike=אופניים
+web.racingbike=מסלולי אופניים
+web.mtb=אופני הרים
+web.car=מכונית
+web.foot=רגל
+web.staticlink=קישור קבוע
+web.motorcycle=אופנוע
+via=דרך
+finish=סיימת!
+hourAbbr=שע׳
+dayAbbr=דק׳
+minAbbr=דקות
+kmAbbr=ק״מ
+mAbbr=מ׳
+miAbbr=מייל
+ftAbbr=רגל
+road=כביש
+off_bike=לרדת מהאופניים
+cycleway=דרך לאופניים
+way=דרך
+paved=סלולה
+unpaved=לא סלולה
+stopover=נקודת עצירה מס׳ %1$s
+roundaboutEnter=יש להיכנס לכיכר
+roundaboutExit=בכיכר, יש לצאת ביציאה %1$s
+roundaboutExitOnto=בכיכר, יש לצאת ביציאה %1$s לתוך %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
new file mode 100644
index 0000000000..869881f239
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=continua
+continue_onto=continua su %1$s
+turn_left=gira a sinistra
+turn_right=gira a destra
+turn_slight_left=gira leggermente a sinistra
+turn_slight_right=gira leggermente a destra
+turn_sharp_left=gira nettamente a sinistra
+turn_sharp_right=gira nettamente a destra
+turn_onto=%1$s su %2$s
+web.searchButton=Ricerca
+web.fromHint=Da
+web.viaHint=attraverso
+web.toHint=A
+web.moreButton=altro
+web.gpxExportButton=Esporta GPX
+web.routeInfo=%1$s in %2$s
+web.locationsNotFound=Percorso non calcolabile. Località non trovata(e) nell'area.
+web.bike=Bicicletta
+web.racingbike=Bici da corsa
+web.mtb=Mountainbike
+web.car=Auto
+web.foot=A piedi
+web.staticlink=permalink
+web.motorcycle=Moto
+via=attraverso
+finish=Arrivo!
+hourAbbr=hh
+dayAbbr=gg
+minAbbr=mm
+kmAbbr=km
+mAbbr=mt
+miAbbr=mi
+ftAbbr=ft
+road=strada
+off_bike=sezione a piedi
+cycleway=pista ciclabile
+way=via
+paved=pavimentata
+unpaved=non pavimentata
+stopover=sosta %1$s
+roundaboutEnter=Entrare nella rotatoria
+roundaboutExit=Nella rotatoria, prendere l'uscita %1$s
+roundaboutExitOnto=Nella rotatoria, prendere l'uscita %1$s su %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ja.txt b/core/src/main/resources/com/graphhopper/util/ja.txt
index 40e4636e27..08de85884e 100644
--- a/core/src/main/resources/com/graphhopper/util/ja.txt
+++ b/core/src/main/resources/com/graphhopper/util/ja.txt
@@ -1,25 +1,30 @@
-sharp_left=左
-sharp_right=右
-left=左
-right=右
-slight_left=左
-slight_right=右
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=進む
 continue_onto=%1$sまで進む
-turn=%1$sに曲がる
+turn_left=左に曲がる
+turn_right=右に曲がる
+turn_slight_left=左に曲がる
+turn_slight_right=右に曲がる
+turn_sharp_left=左に曲がる
+turn_sharp_right=右に曲がる
 turn_onto=%1$sに曲がって%2$sに入る
 web.searchButton=検索
 web.fromHint=出発地点
+web.viaHint=
 web.toHint=目的地点
 web.moreButton=詳細
-web.gpxExportButton=GPX export
+web.gpxExportButton=GPX形式でエクスポート
 web.routeInfo=%1$s 所要時間 %2$s
 web.locationsNotFound=経路を検索できませんでした．指定の地点が存在しません．
 web.bike=自転車
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=レースバイク
+web.mtb=マウンテンバイク
 web.car=車
 web.foot=徒歩
+web.staticlink=パーマリンク
+web.motorcycle=オートバイ
+via=経由
 finish=目標達成
 hourAbbr=時間
 dayAbbr=日
@@ -28,9 +33,13 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
+road=路
+off_bike=自転車を押して歩く
+cycleway=自転車用道路
+way=道
+paved=舗装された道
+unpaved=未舗装の道
+stopover=%1$sで降りる
+roundaboutEnter=円形交差点に入る
+roundaboutExit=円形交差点の出口%1$sへ
+roundaboutExitOnto=円形交差点の出口%1$sから%2$sへ
diff --git a/core/src/main/resources/com/graphhopper/util/ne.txt b/core/src/main/resources/com/graphhopper/util/ne.txt
new file mode 100644
index 0000000000..e502256a5e
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ne.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=गहिरख्नुहोस
+continue_onto=%1$s गहिरख्नुहोस
+turn_left=बाया मोड्नुहोस 
+turn_right=दाया मोड्नुहोस 
+turn_slight_left=थोरै बाया मोड्नुहोस 
+turn_slight_right=थोरै दाया मोड्नुहोस 
+turn_sharp_left=धेरै बाया मोड्नुहोस 
+turn_sharp_right=धेरै दाया मोड्नुहोस 
+turn_onto=%2$s मा %1$s मोड्नुहोस 
+web.searchButton=खोज 
+web.fromHint=सुरु 
+web.viaHint=बाट
+web.toHint=अन्त्य
+web.moreButton=अझै
+web.gpxExportButton=GPX मा परिबर्तन गर्नुहोस
+web.routeInfo=%1$s को लागि %2$s लाग्नेछ
+web.locationsNotFound=ठाउँ नभेटीनाले बाटो पत्ता लगाउन सकिएन
+web.bike=बाईक 
+web.racingbike=छिटो गतिका बाईक
+web.mtb=माउन्टेन बाईक
+web.car=गाडी
+web.foot=पैदल
+web.staticlink=ईस्ट्यातिक लिंक
+web.motorcycle=मोटरसाइकल 
+via=बाट
+finish=सकियो
+hourAbbr=घण्टा
+dayAbbr=दिन
+minAbbr=मिनेट
+kmAbbr=किलोमीटर 
+mAbbr=मीटर
+miAbbr=माइल्स
+ftAbbr=फुट
+road=सडक
+off_bike=बाईक बाट ओर्लनुहोस
+cycleway=साइकल हिड्ने बाटो
+way=बाटो
+paved=पक्कि
+unpaved=कच्ची
+stopover=%1$s रोकिने ठाउँ 
+roundaboutEnter=घुम्ती मा छिर्नुहोस
+roundaboutExit=घुम्तीमा %1$s नम्बर को मोडबाट निस्कनुहोस 
+roundaboutExitOnto=घुम्तीमा %1$s नम्बर को मोडबाट निस्केर %2$s मा जानुहोस
diff --git a/core/src/main/resources/com/graphhopper/util/nl.txt b/core/src/main/resources/com/graphhopper/util/nl.txt
new file mode 100644
index 0000000000..059c334c4a
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/nl.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=neem 
+continue_onto=blijf op %1$s
+turn_left=links afbuigen
+turn_right=rechts afbuigen
+turn_slight_left=houd links aan afbuigen
+turn_slight_right=houd rechts aan afbuigen
+turn_sharp_left=ga linksaf afbuigen
+turn_sharp_right=ga rechtsaf afbuigen
+turn_onto=%1$s af naar %2$s
+web.searchButton=zoek
+web.fromHint=van
+web.viaHint=via
+web.toHint=naar
+web.moreButton=meer
+web.gpxExportButton=GPX export
+web.routeInfo=%1$s duurt %2$s
+web.locationsNotFound=Route niet mogelijk. Locatie(s) niet gevonden.
+web.bike=fiets
+web.racingbike=racefiets
+web.mtb=mountainbike
+web.car=auto
+web.foot=te voet
+web.staticlink=statische link
+web.motorcycle=motorfiets
+via=via
+finish=Bestemming bereikt
+hourAbbr=u
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=weg
+off_bike=voetpad
+cycleway=fietspad
+way=weg
+paved=verhard
+unpaved=onverhard
+stopover=tussenstop %1$s
+roundaboutEnter=ga de rotonde op
+roundaboutExit=neem afslag %1$s op de rotonde 
+roundaboutExitOnto=neem afslag %1$s naar %2$s op de rotonde 
diff --git a/core/src/main/resources/com/graphhopper/util/pt_BR.txt b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
new file mode 100644
index 0000000000..9672f19f3f
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=continuar
+continue_onto=continue na %1$s
+turn_left=vire à esquerda
+turn_right=vire à direita
+turn_slight_left=vire à curva suave à esquerda
+turn_slight_right=vire à curva suave à direita
+turn_sharp_left=vire à curva acentuada à esquerda
+turn_sharp_right=vire à curva acentuada à direita
+turn_onto=%1$s em %2$s
+web.searchButton=Pesquisar
+web.fromHint=De
+web.viaHint=Via
+web.toHint=Para
+web.moreButton=mais
+web.gpxExportButton=Exportar GPX
+web.routeInfo=%1$s irá levar %2$s
+web.locationsNotFound=Roteamento impossível. Localização(ões) não encontrada(s) na área.
+web.bike=Bicicleta
+web.racingbike=Bicicleta de corrida
+web.mtb=Mountainbike
+web.car=Carro
+web.foot=A pé
+web.staticlink=Link estático
+web.motorcycle=Motocicleta
+via=via
+finish=Destino alcançado
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=pés
+road=estrada
+off_bike=descer da bicicleta
+cycleway=ciclovia
+way=caminho
+paved=pavimentada
+unpaved=não pavimentada
+stopover=parada %1$s
+roundaboutEnter=Entre na rotatória
+roundaboutExit=Na rotatória, saia na %1$ saída
+roundaboutExitOnto=Na rotatória, saia na %1$ saida em direção a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/pt_PT.txt b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
index 9863488fd1..1103e54ae1 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_PT.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
@@ -1,26 +1,31 @@
-sharp_left=esquerda apertada
-sharp_right=direita apertada
-left=esquerda
-right=direita
-slight_left=esquerda ligeira
-slight_right=direita ligeira
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=continuar
-continue_onto=continue para %1$s
-turn=vire %1$s
-turn_onto=vire à %1$s para %2$s
+continue_onto=continue na %1$s
+turn_left=vire à esquerda
+turn_right=vire à direita
+turn_slight_left=vire à curva ligeira à esquerda
+turn_slight_right=vire à curva ligeira à direita
+turn_sharp_left=vire à curva apertada à esquerda
+turn_sharp_right=vire à curva apertada à direita
+turn_onto=%1$s para %2$s
 web.searchButton=Pesquisar
 web.fromHint=De
+web.viaHint=Por
 web.toHint=Para
 web.moreButton=mais
-web.gpxExportButton=GPX export
-web.routeInfo=%1$s irá levar %2$s
+web.gpxExportButton=Exportar GPX
+web.routeInfo=%1$s irá demorar %2$s
 web.locationsNotFound=Roteamento impossível. Localização(ões) não encontrada(s) na área.
 web.bike=Bicicleta
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=Bicicleta de corrida
+web.mtb=Bicicleta de montanha
 web.car=Carro
 web.foot=A pé
-finish=meta alcançada
+web.staticlink=Ligação permanente
+web.motorcycle=Motocicleta
+via=por
+finish=Chegou ao seu destino!
 hourAbbr=h
 dayAbbr=d
 minAbbr=min
@@ -28,9 +33,13 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
+road=estrada
+off_bike=saia da bicicleta
+cycleway=ciclovia
+way=caminho
+paved=pavimentado
+unpaved=não pavimentada
+stopover=paragem %1$s
+roundaboutEnter=Entre na rotunda
+roundaboutExit=Na rotunda, saia na %1$ saída
+roundaboutExitOnto=Na rotunda, saia na %1$ saida em direção a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ro.txt b/core/src/main/resources/com/graphhopper/util/ro.txt
index 1028d36d25..67e0da87ad 100644
--- a/core/src/main/resources/com/graphhopper/util/ro.txt
+++ b/core/src/main/resources/com/graphhopper/util/ro.txt
@@ -1,36 +1,45 @@
-sharp_left=stânga
-sharp_right=dreapta
-left=stânga
-right=dreapta
-slight_left=stânga
-slight_right=dreapta
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=continuă
 continue_onto=continuă pe %1$s
-turn=turn %1$s
-turn_onto=turn %1$s onto %2$s
+turn_left=schimbați direcția la stânga
+turn_right=schimbați direcția la dreapta
+turn_slight_left=schimbați direcția la ușor la stânga
+turn_slight_right=schimbați direcția la ușor la dreapta
+turn_sharp_left=schimbați direcția la brusc la stânga
+turn_sharp_right=schimbați direcția la brusc la dreapta
+turn_onto=%1$s pe %2$s
 web.searchButton=Caută
-web.fromHint=de la
-web.toHint=la
+web.fromHint=De la
+web.viaHint=Prin
+web.toHint=La
 web.moreButton=mai mult
-web.gpxExportButton=GPX export
+web.gpxExportButton=Exportă GPX
 web.routeInfo=%1$s durează %2$s
 web.locationsNotFound=Traseul nu este posibil. Locul(locurile) nu pot fi găsite în zonă.
 web.bike=bicicletă
-web.racingbike=Racingbike
+web.racingbike=bicicletă de curse
 web.mtb=Mountainbike
 web.car=mașină
 web.foot=pe jos
+web.staticlink=link
+web.motorcycle=Motocicletă
+via=prin
 finish=obiectiv atins
 hourAbbr=h
-dayAbbr=d
+dayAbbr=z
 minAbbr=min
 kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=road
-pushing_section=pushing section
-cycleway=cycleway
-way=way
-paved=paved
-unpaved=unpaved
+road=stradă
+off_bike=zonă pentru împins
+cycleway=pistă pentru biciclete
+way=cale
+paved=pavat
+unpaved=nepavat
+stopover=escala %1$s
+roundaboutEnter=Intrați în giratoriu 
+roundaboutExit=La giratoriu folosiți ieșirea %1$
+roundaboutExitOnto=La giratoriu folosiți ieșirea %1$ către %2$
diff --git a/core/src/main/resources/com/graphhopper/util/ru.txt b/core/src/main/resources/com/graphhopper/util/ru.txt
index d611fae831..d5b796eae4 100644
--- a/core/src/main/resources/com/graphhopper/util/ru.txt
+++ b/core/src/main/resources/com/graphhopper/util/ru.txt
@@ -1,30 +1,45 @@
-sharp_left=резко налево
-sharp_right=резко направо
-left=налево
-right=направо
-slight_left=немного левее
-slight_right=немного правее
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=продолжайте
 continue_onto=продолжайте по %1$s
-turn=Поверните %1$s
-turn_onto=Поверните %1$s на %2$s
+turn_left=Поверните налево
+turn_right=Поверните направо
+turn_slight_left=Поверните немного левее
+turn_slight_right=Поверните немного правее
+turn_sharp_left=Поверните резко налево
+turn_sharp_right=Поверните резко направо
+turn_onto=%1$s на %2$s
 web.searchButton=Поиск
 web.fromHint=От
+web.viaHint=Через
 web.toHint=До
 web.moreButton=еще
-web.gpxExportButton=GPX export
+web.gpxExportButton=Экспорт GPX
 web.routeInfo=%1$s займет %2$s
-web.locationsNotFound=Построение маршрута невозвозможно. Местоположение не определено
+web.locationsNotFound=Построить маршрут невозможно. Не определено местоположение.
 web.bike=Велосипед
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=Гоночный велосипед
+web.mtb=Горный велосипед
 web.car=Автомобиль
 web.foot=Пешком
-finish=Целевая достигнуто
-hourAbbr=h
-dayAbbr=d
-minAbbr=min
-kmAbbr=km
-mAbbr=m
-miAbbr=mi
-ftAbbr=ft
+web.staticlink=Ссылка
+web.motorcycle=Мотоцикл
+via=через
+finish=Цель достигнута!
+hourAbbr=ч
+dayAbbr=д
+minAbbr=мин
+kmAbbr=км
+mAbbr=м
+miAbbr=ми
+ftAbbr=фт
+road=дорога
+off_bike=слезьте с велосипеда
+cycleway=велодорожка
+way=путь
+paved=с покрытием
+unpaved=без покрытия
+stopover=остановка %1$s
+roundaboutEnter=Въезжайте на кольцо
+roundaboutExit=У кольца используйте съезд %1$s
+roundaboutExitOnto=У кольца используйте съезд %1$s на %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/si.txt b/core/src/main/resources/com/graphhopper/util/si.txt
index c3e75c3f27..7276fc5fa4 100644
--- a/core/src/main/resources/com/graphhopper/util/si.txt
+++ b/core/src/main/resources/com/graphhopper/util/si.txt
@@ -1,25 +1,30 @@
-sharp_left=ostro levo
-sharp_right=ostro desno
-left=levo
-right=desno
-slight_left=rahlo levo
-slight_right=rahlo desno
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=nadaljujte
 continue_onto=nadaljujte po %1$s
-turn=zavite %1$s
-turn_onto=zavite %1$s na %2$s
+turn_left=zavite levo
+turn_right=zavite desno
+turn_slight_left=zavite rahlo levo
+turn_slight_right=zavite rahlo desno
+turn_sharp_left=zavite ostro levo
+turn_sharp_right=zavite ostro desno
+turn_onto=%1$s na %2$s
 web.searchButton=Išči
 web.fromHint=Od 
+web.viaHint=
 web.toHint=Do
 web.moreButton=več
-web.gpxExportButton=GPX export
+web.gpxExportButton=izvozi GPX
 web.routeInfo=%1$s bo trajalo %2$s
 web.locationsNotFound=Usmerjanje ni mogoče. Lokacije ne pokaže na tem območju.
 web.bike=Kolo
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=cestno kolo
+web.mtb=gorsko kolo
 web.car=Avto
 web.foot=Peš
+web.staticlink=povezava
+web.motorcycle=motorno kolo
+via=preko
 finish=Konec!
 hourAbbr=h
 dayAbbr=d
@@ -28,3 +33,13 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
+road=cesta
+off_bike=peš odsek
+cycleway=kolesarska steza
+way=smer
+paved=tlakovana
+unpaved=netlakovana
+stopover=postanek %1$s
+roundaboutEnter=zapeljite v krožišče
+roundaboutExit=v krožišču izberite izhod %1$s
+roundaboutExitOnto=v krožišču izberite izhod %1$s na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
new file mode 100644
index 0000000000..623154278c
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=pokračujte
+continue_onto=pokračujte na %1$s
+turn_left=odbočte doľava
+turn_right=odbočte doprava
+turn_slight_left=odbočte mierne doľava
+turn_slight_right=odbočte mierne doprava
+turn_sharp_left=odbočte ostro doľava
+turn_sharp_right=odbočte ostro doprava
+turn_onto=%1$s na %2$s
+web.searchButton=Vyhľadať
+web.fromHint=Z
+web.viaHint=Cez
+web.toHint=Do
+web.moreButton=viac
+web.gpxExportButton=Export do GPX
+web.routeInfo=%1$s bude trvať %2$s
+web.locationsNotFound=Navigovanie nie je možné. Umiestnenie nebolo nájdené v oblasti.
+web.bike=Bicykel
+web.racingbike=Závodný bicykel
+web.mtb=Horský bicykel
+web.car=Automobil
+web.foot=Pešo
+web.staticlink=nemenný odkaz
+web.motorcycle=Motocykel
+via=cez
+finish=Cieľ!
+hourAbbr=Horský bicykel
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=cesta
+off_bike=zosadnite z bicykla
+cycleway=cyklotrasa
+way=smer
+paved=spevnená
+unpaved=nespevnená
+stopover=zastávka %1$s
+roundaboutEnter=Vojdite na kruhový objazd
+roundaboutExit=Na kruhovom objazde, ho opustite cez %1$s. výjazd
+roundaboutExitOnto=Na kruhovom objazde, ho opustite cez %1$s. výjazd na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/sv_SE.txt b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
new file mode 100644
index 0000000000..07d7aba218
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=fortsätt
+continue_onto=fortsätt in på %1$s
+turn_left=sväng vänster
+turn_right=sväng höger
+turn_slight_left=sväng svagt vänster
+turn_slight_right=sväng svagt höger
+turn_sharp_left=sväng kraftigt vänster
+turn_sharp_right=sväng kraftigt höger
+turn_onto=%1$s in på %2$s
+web.searchButton=Sök
+web.fromHint=Från
+web.viaHint=Via
+web.toHint=Till
+web.moreButton=fler
+web.gpxExportButton=exportera GPX-fil
+web.routeInfo=%1$s med körtid %2$s
+web.locationsNotFound=Kan inte beräkna rutt. Platsen eller platserna kan inte hittas i området.
+web.bike=Cykel
+web.racingbike=Tävlingscykel
+web.mtb=Mountain bike
+web.car=Bil
+web.foot=Gång
+web.staticlink=Direktlänk
+web.motorcycle=
+via=via
+finish=Framme!
+hourAbbr= tim
+dayAbbr= d
+minAbbr= min
+kmAbbr= km
+mAbbr= m
+miAbbr= mi
+ftAbbr= ft
+road=gata
+off_bike=hoppa av cykeln
+cycleway=cykelväg
+way=väg
+paved=belagd
+unpaved=obelagd
+stopover=delmål %1$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/tr.txt b/core/src/main/resources/com/graphhopper/util/tr.txt
index fce2e33322..2b774ce29a 100644
--- a/core/src/main/resources/com/graphhopper/util/tr.txt
+++ b/core/src/main/resources/com/graphhopper/util/tr.txt
@@ -1,30 +1,45 @@
-sharp_left=sola keskin dönüş
-sharp_right=sağa keskin dönüş
-left=sol 
-right=sağ 
-slight_left=hafif sola
-slight_right=hafif sağa
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
 continue=devam
 continue_onto=-e devam %1$s
-turn=dön %1$s
-turn_onto=-e dön %1$s %2$s
+turn_left=dön sol 
+turn_right=dön sağ 
+turn_slight_left=dön hafif sola
+turn_slight_right=dön hafif sağa
+turn_sharp_left=dön sola keskin dönüş
+turn_sharp_right=dön sağa keskin dönüş
+turn_onto=%1$s %2$s
 web.searchButton=ara
 web.fromHint=-den 
+web.viaHint=araciligi ile
 web.toHint=yönüne
 web.moreButton=daha fazlası
-web.gpxExportButton=GPX export
+web.gpxExportButton=GPX ihracat
 web.routeInfo=%1$s alacak %2$s
 web.locationsNotFound=Rota planlanamadı. Bölgede yer bulunamadı.
 web.bike=Bisiklet
-web.racingbike=Racingbike
-web.mtb=Mountainbike
+web.racingbike=yaris bisikleti
+web.mtb=dag bisikleti
 web.car=Otomobil
 web.foot=Yürüyerek
+web.staticlink=duragan baglanti
+web.motorcycle=
+via=araciligi ile
 finish=Bitti !
 hourAbbr=s
 dayAbbr=g
-minAbbr=d
+minAbbr=dak
 kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
+road=yol
+off_bike=bisikletten inmek
+cycleway=bisiklet yolu
+way=yol
+paved=kaldırım
+unpaved=kaldırımsız yol
+stopover=mola yeri %1$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
new file mode 100644
index 0000000000..a356a96217
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=продовжуйте
+continue_onto=продовжуйте по „%1$s“
+turn_left=Поверніть наліво
+turn_right=Поверніть направо
+turn_slight_left=Поверніть трохи лівіше
+turn_slight_right=Поверніть трохи правіше
+turn_sharp_left=Поверніть різко наліво
+turn_sharp_right=Поверніть різко направо
+turn_onto=%1$s на „%2$s“
+web.searchButton=Пошук
+web.fromHint=Від
+web.viaHint=через
+web.toHint=До
+web.moreButton=ще
+web.gpxExportButton=Експорт в GPX
+web.routeInfo=%1$s займе %2$s
+web.locationsNotFound=Побудова маршруту неможлива. Місцезнаходження не визначено.
+web.bike=Велосипед
+web.racingbike=Шосейний велосипед
+web.mtb=Гірський велосипед
+web.car=Автомобіль
+web.foot=Пішки
+web.staticlink=статичне посилання
+web.motorcycle=Мотоцикл
+via=через
+finish=Ви прибули до пункту призначення!
+hourAbbr= год
+dayAbbr= д
+minAbbr= хв
+kmAbbr= км
+mAbbr= м
+miAbbr= милі
+ftAbbr= фути
+road=дорога
+off_bike=злізьте з велосипеда
+cycleway=велосипедна доріжка
+way=шлях
+paved=з покриттям
+unpaved=без покриття
+stopover=зупинка %1$s
+roundaboutEnter=В’їжджайте на кільце
+roundaboutExit=На кільці використовуйте з’їзд %1$s
+roundaboutExitOnto=На кільці використовуйте з’їзд %1$s на %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VI.txt b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
new file mode 100644
index 0000000000..015af51a0e
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=tiếp tục
+continue_onto=tiếp tục theo %1$s
+turn_left=rẽ trái
+turn_right=rẽ phải
+turn_slight_left=rẽ nhẹ trái
+turn_slight_right=rẽ nhẹ phải
+turn_sharp_left=rẽ trái ngay
+turn_sharp_right=rẽ phải ngay
+turn_onto=%1$s theo %1$s
+web.searchButton=Tìm
+web.fromHint=Từ
+web.viaHint=Qua
+web.toHint=Đến
+web.moreButton=thêm
+web.gpxExportButton=Xuất GPX
+web.routeInfo=%1$s mất %2$s
+web.locationsNotFound=Không tìm thấy lộ trình! Các điểm đã chọn không tìm thấy trong vùng này
+web.bike=Xe đạp
+web.racingbike=Xe đua
+web.mtb=Xe leo núi
+web.car=Ô tô
+web.foot=Đi bộ
+web.staticlink=liên kết tĩnh
+web.motorcycle=Mô tô
+via=qua
+finish=Kết thúc!
+hourAbbr=g
+dayAbbr=n
+minAbbr=p
+kmAbbr=km
+mAbbr=m
+miAbbr=dặm
+ftAbbr=ft
+road=đường
+off_bike=bỏ xe đạp
+cycleway=đường xe đạp
+way=đường
+paved=đường lát
+unpaved=đường không lát
+stopover=điểm nghỉ %1$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/zh_CN.txt b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
new file mode 100644
index 0000000000..1a5809a030
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=继续
+continue_onto=继续行驶到 %1$s
+turn_left=左转
+turn_right=右转
+turn_slight_left=偏左转
+turn_slight_right=偏右转
+turn_sharp_left=左急转
+turn_sharp_right=右急转
+turn_onto=%1$s 到  %2$s
+web.searchButton=搜索
+web.fromHint=起点
+web.viaHint=途经点
+web.toHint=终点
+web.moreButton=更多
+web.gpxExportButton=GPX导出
+web.routeInfo=%1$s 的路线，需要 %2$s 时间
+web.locationsNotFound=地点未找到
+web.bike=自行车
+web.racingbike=竞技自行车
+web.mtb=山地自行车
+web.car=驾车
+web.foot=步行
+web.staticlink=静态链接
+web.motorcycle=摩托车
+via=途经
+finish=终点到达
+hourAbbr=小时
+dayAbbr=天
+minAbbr=分钟
+kmAbbr=公里
+mAbbr=米
+miAbbr=英里
+ftAbbr=英尺
+road=道路
+off_bike=下自行车
+cycleway=自行车道
+way=路
+paved=路面铺就
+unpaved=路面未铺就
+stopover=途中休息 %1$s
+roundaboutEnter=进入环岛
+roundaboutExit=在环岛内，使用%1$s出口出环岛
+roundaboutExitOnto=在环岛内，使用%1$s出口出环岛，进入%2$s
diff --git a/core/src/main/resources/log4j.properties b/core/src/main/resources/log4j.properties
deleted file mode 100644
index fedf9e0962..0000000000
--- a/core/src/main/resources/log4j.properties
+++ /dev/null
@@ -1,11 +0,0 @@
-# overwrite this file from command line via:
-# -Dlog4j.configuration=file
-# print internal debug => -Dlog4j.debug
-
-log4j.appender.StdoutApp=org.apache.log4j.ConsoleAppender
-log4j.appender.StdoutApp.layout=org.apache.log4j.PatternLayout
-log4j.appender.StdoutApp.layout.conversionPattern=%d [%t] %-5p %C{3} - %m%n
-
-log4j.rootLogger=WARN
-
-log4j.logger.com.graphhopper=INFO, StdoutApp
diff --git a/core/src/test/java/com/graphhopper/GHRequestTest.java b/core/src/test/java/com/graphhopper/GHRequestTest.java
new file mode 100644
index 0000000000..e679159dc2
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/GHRequestTest.java
@@ -0,0 +1,39 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class GHRequestTest
+{
+    @Test
+    public void testGetHint()
+    {
+        GHRequest instance = new GHRequest(10, 12, 12, 10);
+        instance.getHints().put("something", "1");
+        assertEquals(1, instance.getHints().getInt("something", 2));
+        // #173 - will throw an error: Integer cannot be cast to Double
+        assertEquals(1, instance.getHints().getDouble("something", 2d), 1e1);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index 1a2fe1e1c5..fd7d4a3721 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -20,6 +20,7 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.NodeAccess;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -35,11 +36,12 @@
     public void testLoad()
     {
         GraphStorage graph = new GraphBuilder(encodingManager).create();
-        graph.setNode(0, 42, 10);
-        graph.setNode(1, 42.1, 10.1);
-        graph.setNode(2, 42.1, 10.2);
-        graph.setNode(3, 42, 10.4);
-        graph.setNode(4, 41.9, 10.2);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 42, 10);
+        na.setNode(1, 42.1, 10.1);
+        na.setNode(2, 42.1, 10.2);
+        na.setNode(3, 42, 10.4);
+        na.setNode(4, 41.9, 10.2);
 
         graph.edge(0, 1, 10, true);
         graph.edge(1, 2, 10, false);
@@ -47,22 +49,61 @@ public void testLoad()
         graph.edge(0, 4, 40, true);
         graph.edge(4, 3, 40, true);
 
-        GraphHopperAPI instance = new GraphHopper().setEncodingManager(encodingManager).disableCHShortcuts().loadGraph(graph);
-        GHResponse ph = instance.route(new GHRequest(42, 10.4, 42, 10));
-        assertTrue(ph.isFound());
-        assertEquals(80, ph.getDistance(), 1e-6);
-        assertEquals(42, ph.getPoints().getLatitude(0), 1e-5);
-        assertEquals(10.4, ph.getPoints().getLongitude(0), 1e-5);
-        assertEquals(41.9, ph.getPoints().getLatitude(1), 1e-5);
-        assertEquals(10.2, ph.getPoints().getLongitude(1), 1e-5);
-        assertEquals(3, ph.getPoints().getSize());
+        GraphHopper instance = new GraphHopper().
+                setStoreOnFlush(false).
+                setEncodingManager(encodingManager).
+                setCHEnable(false).
+                loadGraph(graph);
+        GHResponse rsp = instance.route(new GHRequest(42, 10.4, 42, 10));
+        assertFalse(rsp.hasErrors());
+        assertEquals(80, rsp.getDistance(), 1e-6);
+        assertEquals(42, rsp.getPoints().getLatitude(0), 1e-5);
+        assertEquals(10.4, rsp.getPoints().getLongitude(0), 1e-5);
+        assertEquals(41.9, rsp.getPoints().getLatitude(1), 1e-5);
+        assertEquals(10.2, rsp.getPoints().getLongitude(1), 1e-5);
+        assertEquals(3, rsp.getPoints().getSize());
+        instance.close();
     }
 
     @Test
-    public void testNoLoad()
+    public void testDisconnected179()
     {
+        GraphStorage graph = new GraphBuilder(encodingManager).create();
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 42, 10);
+        na.setNode(1, 42.1, 10.1);
+        na.setNode(2, 42.1, 10.2);
+        na.setNode(3, 42, 10.4);
+
+        graph.edge(0, 1, 10, true);
+        graph.edge(2, 3, 10, true);
+
+        GraphHopper instance = new GraphHopper().
+                setStoreOnFlush(false).
+                setEncodingManager(encodingManager).
+                setCHEnable(false).
+                loadGraph(graph);
+        GHResponse rsp = instance.route(new GHRequest(42, 10, 42, 10.4));
+        assertTrue(rsp.hasErrors());
 
-        GraphHopperAPI instance = new GraphHopper().setEncodingManager(encodingManager).disableCHShortcuts();
+        try
+        {
+            rsp.getPoints();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+
+        instance.close();
+    }
+
+    @Test
+    public void testNoLoad()
+    {
+        GraphHopper instance = new GraphHopper().
+                setStoreOnFlush(false).
+                setEncodingManager(encodingManager).
+                setCHEnable(false);
         try
         {
             instance.route(new GHRequest(42, 10.4, 42, 10));
@@ -81,6 +122,5 @@ public void testNoLoad()
         {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Call load or importOrLoad before routing"));
         }
-
     }
 }
diff --git a/core/src/test/java/com/graphhopper/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
new file mode 100644
index 0000000000..072d094b7f
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -0,0 +1,384 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper;
+
+import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+import org.junit.*;
+import static org.junit.Assert.*;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperIT
+{
+    private static GraphHopper hopper;
+    private static final String graphFileFoot = "target/graphhopperIT-foot";
+    private static final String osmFile = "files/monaco.osm.gz";
+    private static final String importVehicles = "FOOT";
+    private static final String vehicle = "FOOT";
+    private static final String weightCalcStr = "shortest";
+
+    private final String tmpGraphFile = "target/graphhopperIT-tmp";
+
+    @Before
+    public void setUp()
+    {
+        Helper.removeDir(new File(tmpGraphFile));
+    }
+
+    @After
+    public void tearDown()
+    {
+        Helper.removeDir(new File(tmpGraphFile));
+    }
+
+    @BeforeClass
+    public static void beforeClass()
+    {
+        // make sure we are using fresh graphhopper files with correct vehicle
+        Helper.removeDir(new File(graphFileFoot));
+
+        hopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(graphFileFoot).
+                setEncodingManager(new EncodingManager(importVehicles)).
+                importOrLoad();
+    }
+
+    @AfterClass
+    public static void afterClass()
+    {
+        Helper.removeDir(new File(graphFileFoot));
+    }
+
+    @Test
+    public void testMonacoWithInstructions() throws Exception
+    {
+        GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+
+        // identify the number of counts to compare with CH foot route
+        assertEquals(698, hopper.getVisitedSum());
+        assertEquals(3437.6, rsp.getDistance(), .1);
+        assertEquals(89, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(13, il.size());
+
+        List<Map<String, Object>> resultJson = il.createJson();
+        // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
+        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
+        assertEquals("Turn left", resultJson.get(3).get("text"));
+        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+
+        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
+        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
+        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
+        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
+        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
+        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+
+        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
+        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
+        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
+        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
+        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
+        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+
+        List<GPXEntry> list = rsp.getInstructions().createGPXList();
+        assertEquals(89, list.size());
+        final long lastEntryMillis = list.get(list.size() - 1).getMillis();
+        final long totalResponseMillis = rsp.getMillis();
+        assertEquals(totalResponseMillis, lastEntryMillis);
+    }
+
+    @Test
+    public void testMonacoVia()
+    {
+        GHResponse rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.74958, 7.436566)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+
+        assertEquals(6875.1, rsp.getDistance(), .1);
+        assertEquals(179, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(26, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
+        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
+        assertEquals("Turn left", resultJson.get(3).get("text"));
+        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+
+        assertEquals("Stopover 1", resultJson.get(12).get("text"));
+
+        assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
+        assertEquals("Turn left", resultJson.get(21).get("text"));
+        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
+        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
+        assertEquals("Turn slight right onto Avenue des Guelfes", resultJson.get(24).get("text"));
+        assertEquals("Finish!", resultJson.get(25).get("text"));
+
+        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
+        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
+        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
+        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
+        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
+        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+
+        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
+        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
+        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
+        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
+        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
+        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+
+        // special case of identical start and end point
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(1, rsp.getPoints().getSize());
+        assertEquals(1, rsp.getInstructions().size());
+        assertEquals("Finish!", rsp.getInstructions().createJson().get(0).get("text"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(0).get("sign"));
+
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(2, rsp.getPoints().getSize());
+        assertEquals(2, rsp.getInstructions().size());
+        assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().createJson().get(0).get("sign"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
+    }
+
+    @Test
+    public void testSRTMWithInstructions() throws Exception
+    {
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(importVehicles));
+
+        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
+        tmpHopper.importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+
+        assertEquals(1626.8, rsp.getDistance(), .1);
+        assertEquals(60, rsp.getPoints().getSize());
+        assertTrue(rsp.getPoints().is3D());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(10, il.size());
+        assertTrue(il.get(0).getPoints().is3D());
+
+        String str = rsp.getPoints().toString();
+        assertEquals("(43.73068455771767,7.421283689825812,62.0), (43.73067957305937,7.421382123709815,66.0), "
+                + "(43.73109792316924,7.421546222751131,45.0), (43.73129908884985,7.421589994913116,45.0), "
+                + "(43.731327028527716,7.421414533736137,45.0), (43.73125047381037,7.421366291225693,45.0), "
+                + "(43.73125457162979,7.421274090288746,52.0), "
+                + "(43.73128213877862,7.421115579183003,52.0), (43.731362232521825,7.421145381506057,52.0), "
+                + "(43.731371359483255,7.421123216028286,52.0), (43.731485725897976,7.42117332118392,52.0), "
+                + "(43.731575132867135,7.420868778695214,52.0), (43.73160605277731,7.420824820268709,52.0), "
+                + "(43.7316401391843,7.420850152243305,52.0), (43.731674039326776,7.421050014072285,52.0)",
+                str.substring(0, 662));
+
+        assertEquals("(43.727778875703635,7.418772930326453,11.0), (43.72768239068275,7.419007064826944,11.0), "
+                + "(43.727680946587874,7.4191987684222065,11.0)",
+                str.substring(str.length() - 133));
+
+        List<GPXEntry> list = rsp.getInstructions().createGPXList();
+        assertEquals(60, list.size());
+        final long lastEntryMillis = list.get(list.size() - 1).getMillis();
+        assertEquals(new GPXEntry(43.73068455771767, 7.421283689825812, 62.0, 0), list.get(0));
+        assertEquals(new GPXEntry(43.727680946587874, 7.4191987684222065, 11.0, lastEntryMillis), list.get(list.size() - 1));
+
+        assertEquals(62, il.createGPXList().get(0).getElevation(), 1e-2);
+        assertEquals(66, il.createGPXList().get(1).getElevation(), 1e-2);
+        assertEquals(52, il.createGPXList().get(10).getElevation(), 1e-2);
+    }
+
+    @Test
+    public void testKremsCyclewayInstructionsWithWayTypeInfo()
+    {
+        String tmpOsmFile = "files/krems.osm.gz";
+        String tmpVehicle = "BIKE";
+        String tmpImportVehicles = "CAR,BIKE";
+        String tmpWeightCalcStr = "fastest";
+
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+
+        assertEquals(6932.24, rsp.getDistance(), .1);
+        assertEquals(110, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(19, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+
+        assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
+        assertEquals("get off the bike", resultJson.get(0).get("annotationText"));
+        assertEquals("Turn sharp left onto Kirchengasse", resultJson.get(1).get("text"));
+        assertEquals("get off the bike", resultJson.get(1).get("annotationText"));
+
+        assertEquals("Turn sharp right onto Pfarrplatz", resultJson.get(2).get("text"));
+        assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
+        assertEquals("Turn left onto Hoher Markt", resultJson.get(4).get("text"));
+        assertEquals("Turn slight right onto Wegscheid", resultJson.get(5).get("text"));
+        assertEquals("Turn slight left onto Untere Landstraße", resultJson.get(6).get("text"));
+        assertEquals("Turn right onto Ringstraße, L73", resultJson.get(7).get("text"));
+        assertEquals("Continue onto Eyblparkstraße", resultJson.get(8).get("text"));
+        assertEquals("Continue onto Austraße", resultJson.get(9).get("text"));
+        assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
+        //..
+        assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
+        assertEquals("cycleway", resultJson.get(15).get("annotationText"));
+    }
+
+    @Test
+    public void testRoundaboutInstructionsWithCH()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpVehicle = "car";
+        String tmpImportVehicles = "car,bike";
+        String tmpWeightCalcStr = "fastest";
+
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        assertEquals(tmpVehicle, tmpHopper.getDefaultVehicle().toString());
+        assertFalse(RoutingAlgorithmFactorySimple.class.isAssignableFrom(tmpHopper.getAlgorithmFactory().getClass()));
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.745084, 7.430513, 43.745247, 7.430347)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+
+        rsp = tmpHopper.route(new GHRequest(43.745968, 7.42907, 43.745832, 7.428614)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+
+        rsp = tmpHopper.route(new GHRequest(43.745948, 7.42914, 43.746173, 7.428834)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(1, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+
+        rsp = tmpHopper.route(new GHRequest(43.735817,7.417096, 43.735666,7.416587)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+    }
+
+    @Test
+    public void testMultipleVehiclesAndDoCHForBike()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpImportVehicles = "bike,car";
+
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+        assertEquals("bike", tmpHopper.getDefaultVehicle().toString());
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("car"));
+        assertEquals(207, rsp.getMillis() / 1000f, 1);
+        assertEquals(2838, rsp.getDistance(), 1);
+
+        rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("bike"));
+        assertEquals(494, rsp.getMillis() / 1000f, 1);
+        assertEquals(2192, rsp.getDistance(), 1);
+
+        rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("foot"));
+        assertTrue("only bike and car were imported. foot request should fail", rsp.hasErrors());
+    }
+
+    @Test
+    public void testIfCHIsUsed() throws Exception
+    {
+        // route directly after import
+        executeCHFootRoute();
+
+        // now only load is called
+        executeCHFootRoute();
+    }
+
+    private void executeCHFootRoute()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpImportVehicles = "foot";
+
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setCHWeighting(weightCalcStr).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        // same query as in testMonacoWithInstructions
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
+                setVehicle(vehicle));
+
+        // identify the number of counts to compare with none-CH foot route which had nearly 700 counts
+        assertTrue("Too many nodes visited " + tmpHopper.getVisitedSum(), tmpHopper.getVisitedSum() < 120);
+        assertEquals(3437.6, rsp.getDistance(), .1);
+        assertEquals(89, rsp.getPoints().getSize());
+        tmpHopper.close();
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index cbdd06ecae..fe5e04f20c 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -17,12 +17,20 @@
  */
 package com.graphhopper;
 
+import com.graphhopper.reader.DataReader;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.Instruction;
 import com.graphhopper.util.shapes.GHPoint;
 import java.io.File;
 import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import org.junit.After;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -48,105 +56,256 @@ public void setUp()
     @After
     public void tearDown()
     {
-        instance.close();
+        if (instance != null)
+            instance.close();
         Helper.removeDir(new File(ghLoc));
     }
 
     @Test
     public void testLoadOSM()
     {
-        instance = new GraphHopper().setInMemory(true, true).
+        GraphHopper closableInstance = new GraphHopper().setStoreOnFlush(true).
                 setEncodingManager(new EncodingManager("CAR")).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
-        instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        closableInstance.importOrLoad();
+        GHResponse rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
-        instance.close();
-        instance = new GraphHopper().setInMemory(true, true);
-        assertTrue(instance.load(ghLoc));
-        ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        closableInstance.close();
+
+        // no encoding manager necessary
+        closableInstance = new GraphHopper().setStoreOnFlush(true);
+        assertTrue(closableInstance.load(ghLoc));
+        rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+
+        closableInstance.close();
+        try
+        {
+            rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertEquals("You need to create a new GraphHopper instance as it is already closed", ex.getMessage());
+        }
+
+        try
+        {
+            QueryResult qr = closableInstance.getLocationIndex().findClosest(51.2492152, 9.4317166, EdgeFilter.ALL_EDGES);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertEquals("You need to create a new LocationIndex instance as it is already closed", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void testLoadOSMNoCH()
+    {
+        GraphHopper gh = new GraphHopper().setStoreOnFlush(true).
+                setCHEnable(false).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        gh.importOrLoad();
+        GHResponse rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+
+        gh.close();
+        gh = new GraphHopper().setStoreOnFlush(true).
+                setCHEnable(false).
+                setEncodingManager(new EncodingManager("CAR"));
+        assertTrue(gh.load(ghLoc));
+        rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+
+        gh.close();
+    }
+
+    @Test
+    public void testAllowMultipleReadingInstances()
+    {
+        GraphHopper instance1 = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        instance1.importOrLoad();
+
+        GraphHopper instance2 = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setOSMFile(testOsm);
+        instance2.load(ghLoc);
+
+        GraphHopper instance3 = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setOSMFile(testOsm);
+        instance3.load(ghLoc);
+
+        instance1.close();
+        instance2.close();
+        instance3.close();
+    }
+
+    @Test
+    public void testDoNotAllowWritingAndLoadingAtTheSameTime() throws Exception
+    {
+        final CountDownLatch latch1 = new CountDownLatch(1);
+        final CountDownLatch latch2 = new CountDownLatch(1);
+        final GraphHopper instance1 = new GraphHopper()
+        {
+            @Override
+            protected DataReader importData() throws IOException
+            {
+                try
+                {
+                    latch2.countDown();
+                    latch1.await(3, TimeUnit.SECONDS);
+                } catch (InterruptedException ex)
+                {
+                }
+                return super.importData();
+            }
+        }.setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm);
+        final AtomicReference<Exception> ar = new AtomicReference<Exception>();
+        Thread thread = new Thread()
+        {
+            @Override
+            public void run()
+            {
+                try
+                {
+                    instance1.importOrLoad();
+                } catch (Exception ex)
+                {
+                    ar.set(ex);
+                }
+            }
+        };
+        thread.start();
+
+        GraphHopper instance2 = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
+                setOSMFile(testOsm);
+        try
+        {
+            // let thread reach the CountDownLatch
+            latch2.await(3, TimeUnit.SECONDS);
+            // now importOrLoad should have create a lock which this load call does not like
+            instance2.load(ghLoc);
+            assertTrue(false);
+        } catch (RuntimeException ex)
+        {
+            assertNotNull(ex);
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("To avoid reading partial data"));
+        } finally
+        {
+            instance2.close();
+            latch1.countDown();
+            // make sure the import process wasn't interrupted and no other error happened
+            thread.join();
+        }
+
+        if (ar.get() != null)
+            assertNull(ar.get().getMessage(), ar.get());
+        instance1.close();
     }
 
     @Test
     public void testPrepare()
     {
-        instance = new GraphHopper().setInMemory(true, false).
+        instance = new GraphHopper().
+                setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("CAR")).
-                setCHShortcuts("shortest").
+                setCHWeighting("shortest").
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).setAlgorithm("dijkstrabi"));
-        assertTrue(ph.isFound());
-        assertEquals("(51.24921503475044,9.431716451757769), (52.0,9.0), (51.199999850988384,9.39999970197677)", ph.getPoints().toString());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+                setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
+        assertFalse(rsp.hasErrors());
+        assertEquals(Helper.createPointList(51.249215, 9.431716, 52.0, 9.0, 51.2, 9.4), rsp.getPoints());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
     public void testSortedGraph_noCH()
     {
-        instance = new GraphHopper().setInMemory(true, false).
+        instance = new GraphHopper().setStoreOnFlush(false).
                 setSortGraph(true).
                 setEncodingManager(new EncodingManager("CAR")).
-                disableCHShortcuts().
+                setCHEnable(false).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).setAlgorithm("dijkstrabi"));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
-        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), ph.getPoints().toGHPoint(0));
-        assertEquals(new GHPoint(52.0, 9.0), ph.getPoints().toGHPoint(1));
-        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), ph.getPoints().toGHPoint(2));
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+                setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().toGHPoint(0));
+        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().toGHPoint(1));
+        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().toGHPoint(2));
+
+        GHRequest req = new GHRequest(51.2492152, 9.4317166, 51.2, 9.4);
+        boolean old = instance.enableInstructions;
+        req.getHints().put("instructions", true);
+        instance.route(req);
+        assertEquals(old, instance.enableInstructions);
+
+        req.getHints().put("instructions", false);
+        instance.route(req);
+        assertEquals("route method should not change instance field", old, instance.enableInstructions);
     }
 
     @Test
     public void testFootAndCar()
     {
         // now all ways are imported
-        instance = new GraphHopper().setInMemory(true, false).
+        instance = new GraphHopper().setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("CAR,FOOT")).
-                disableCHShortcuts().
+                setCHEnable(false).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm3);
         instance.importOrLoad();
 
         assertEquals(5, instance.getGraph().getNodes());
-        assertEquals(8, instance.getGraph().getAllEdges().getMaxId());
+        assertEquals(8, instance.getGraph().getAllEdges().getCount());
 
         // A to D
-        GHResponse res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
-        assertFalse(res.hasErrors());
-        assertTrue(res.isFound());
-        assertEquals(3, res.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
         // => found A and D
-        assertEquals(50, res.getPoints().getLongitude(0), 1e-3);
-        assertEquals(11.1, res.getPoints().getLatitude(0), 1e-3);
-        assertEquals(51, res.getPoints().getLongitude(2), 1e-3);
-        assertEquals(11.3, res.getPoints().getLatitude(2), 1e-3);
+        assertEquals(50, rsp.getPoints().getLongitude(0), 1e-3);
+        assertEquals(11.1, rsp.getPoints().getLatitude(0), 1e-3);
+        assertEquals(51, rsp.getPoints().getLongitude(2), 1e-3);
+        assertEquals(11.3, rsp.getPoints().getLatitude(2), 1e-3);
 
         // A to D not allowed for foot. But the location index will choose a node close to D accessible to FOOT        
-        res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(2, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().getSize());
         // => found a point on edge A-B        
-        assertEquals(11.680, res.getPoints().getLatitude(1), 1e-3);
-        assertEquals(50.644, res.getPoints().getLongitude(1), 1e-3);
+        assertEquals(11.680, rsp.getPoints().getLatitude(1), 1e-3);
+        assertEquals(50.644, rsp.getPoints().getLongitude(1), 1e-3);
 
         // A to E only for foot
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(2, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().size());
 
         // A D E for car
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
-        assertTrue(res.isFound());
-        assertEquals(3, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
@@ -154,42 +313,54 @@ public void testFailsForWrongConfig() throws IOException
     {
         instance = new GraphHopper().init(
                 new CmdArgs().
-                put("osmreader.acceptWay", "FOOT,CAR").
-                put("prepare.chShortcuts", "no").
-                put("osmreader.osm", testOsm3)).
+                put("osmreader.osm", testOsm3).
+                put("osmreader.dataaccess", "RAM").
+                put("graph.flagEncoders", "FOOT,CAR").
+                put("prepare.chWeighting", "no")).
                 setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
         assertEquals(5, instance.getGraph().getNodes());
         instance.close();
 
-        instance = new GraphHopper().init(
-                new CmdArgs().
-                put("osmreader.acceptWay", "FOOT").
-                put("prepare.chShortcuts", "no").
-                put("osmreader.osm", testOsm3)).setOSMFile(testOsm3);
+        // different config (flagEncoder list)
         try
         {
-            instance.load(ghLoc);
+            GraphHopper tmpGH = new GraphHopper().init(
+                    new CmdArgs().
+                    put("osmreader.osm", testOsm3).
+                    put("osmreader.dataaccess", "RAM").
+                    put("graph.flagEncoders", "FOOT").
+                    put("prepare.chWeighting", "no")).
+                    setOSMFile(testOsm3);
+            tmpGH.load(ghLoc);
             assertTrue(false);
         } catch (Exception ex)
         {
         }
 
-        // different order should be ok
-        instance = new GraphHopper().init(
-                new CmdArgs().
-                put("osmreader.acceptWay", "CAR,FOOT").
-                put("prepare.chShortcuts", "no").
-                put("osmreader.osm", testOsm3)).setOSMFile(testOsm3);
-        assertTrue(instance.load(ghLoc));
-        assertEquals(5, instance.getGraph().getNodes());
+        // different order is no longer okay, see #350
+        try
+        {
+            GraphHopper tmpGH = new GraphHopper().init(new CmdArgs().
+                    put("osmreader.osm", testOsm3).
+                    put("osmreader.dataaccess", "RAM").
+                    put("prepare.chWeighting", "no").
+                    put("graph.flagEncoders", "CAR,FOOT")).
+                    setOSMFile(testOsm3);
+            tmpGH.load(ghLoc);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
     }
 
     @Test
-    public void testNoNPE_ifOnlyLoad()
+    public void testNoNPE_ifLoadNotSuccessful()
     {
         // missing import of graph
-        instance = new GraphHopper().setInMemory(true, true);
+        instance = new GraphHopper().
+                setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR"));
         try
         {
             assertFalse(instance.load(ghLoc));
@@ -208,7 +379,7 @@ public void testFailsForMissingParameters() throws IOException
         instance = new GraphHopper();
         try
         {
-            instance.importOSM(testOsm);
+            instance.setOSMFile(testOsm).importData();
             assertTrue(false);
         } catch (IllegalStateException ex)
         {
@@ -226,8 +397,10 @@ public void testFailsForMissingParameters() throws IOException
             assertEquals("graphHopperLocation is not specified. call init before", ex.getMessage());
         }
 
-        // missing encoding manager
-        instance = new GraphHopper().setInMemory(true, true).
+        // missing OSM file to import
+        instance = new GraphHopper().
+                setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("CAR")).
                 setGraphHopperLocation(ghLoc);
         try
         {
@@ -235,7 +408,37 @@ public void testFailsForMissingParameters() throws IOException
             assertTrue(false);
         } catch (IllegalStateException ex)
         {
-            assertEquals("No encodingManager was specified", ex.getMessage());
+            assertEquals("Couldn't load from existing folder: " + ghLoc
+                    + " but also cannot import from OSM file as it wasn't specified!", ex.getMessage());
+        }
+
+        // missing encoding manager          
+        instance = new GraphHopper().
+                setStoreOnFlush(true).
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm3);
+        try
+        {
+            instance.importOrLoad();
+            assertTrue(false);
+        } catch (IllegalStateException ex)
+        {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Cannot load properties to fetch EncodingManager"));
+        }
+
+        // Import is possible even if no storeOnFlush is specified BUT here we miss the OSM file
+        instance = new GraphHopper().
+                setStoreOnFlush(false).
+                setEncodingManager(new EncodingManager("CAR")).
+                setGraphHopperLocation(ghLoc);
+        try
+        {
+            instance.importOrLoad();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertEquals("Couldn't load from existing folder: " + ghLoc
+                    + " but also cannot import from OSM file as it wasn't specified!", ex.getMessage());
         }
     }
 
@@ -243,26 +446,26 @@ public void testFailsForMissingParameters() throws IOException
     public void testFootOnly()
     {
         // now only footable ways are imported => no A D C and B D E => the other both ways have pillar nodes!
-        instance = new GraphHopper().setInMemory(true, false).
+        instance = new GraphHopper().setStoreOnFlush(false).
                 setEncodingManager(new EncodingManager("FOOT")).
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm3);
         instance.importOrLoad();
 
         assertEquals(2, instance.getGraph().getNodes());
-        assertEquals(2, instance.getGraph().getAllEdges().getMaxId());
+        assertEquals(2, instance.getGraph().getAllEdges().getCount());
 
         // A to E only for foot
         GHResponse res = instance.route(new GHRequest(11.1, 50, 11.2, 52).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
+        assertFalse(res.hasErrors());
         assertEquals(3, res.getPoints().getSize());
     }
 
     @Test
     public void testPrepareOnly()
     {
-        instance = new GraphHopper().setInMemory(true, true).
-                setCHShortcuts("shortest").
+        instance = new GraphHopper().setStoreOnFlush(true).
+                setCHWeighting("shortest").
                 setEncodingManager(new EncodingManager("FOOT")).
                 setDoPrepare(false).
                 setGraphHopperLocation(ghLoc).
@@ -270,9 +473,10 @@ public void testPrepareOnly()
         instance.importOrLoad();
         instance.close();
 
-        instance = new GraphHopper().setInMemory(true, true).
-                setCHShortcuts("shortest").
-                setGraphHopperLocation(ghLoc).setOSMFile(testOsm3);
+        instance = new GraphHopper().setStoreOnFlush(true).
+                setCHWeighting("shortest").
+                setGraphHopperLocation(ghLoc).
+                setOSMFile(testOsm3);
 
         // wrong encoding manager
         instance.setEncodingManager(new EncodingManager("CAR"));
@@ -286,10 +490,43 @@ public void testPrepareOnly()
         }
 
         // use the encoding manager from the graph
-        instance = new GraphHopper().setInMemory(true, true).
-                setCHShortcuts("shortest").
+        instance = new GraphHopper().setStoreOnFlush(true).
+                setEncodingManager(new EncodingManager("FOOT")).
+                setCHWeighting("shortest").
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm3);
         instance.load(ghLoc);
     }
+
+    @Test
+    public void testVia()
+    {
+        instance = new GraphHopper().setStoreOnFlush(true).
+                init(new CmdArgs().
+                        put("osmreader.osm", testOsm3).
+                        put("prepare.minNetworkSize", "1").
+                        put("graph.flagEncoders", "CAR")).
+                setGraphHopperLocation(ghLoc);
+        instance.importOrLoad();
+
+        // A -> B -> C
+        GHPoint first = new GHPoint(11.1, 50);
+        GHPoint second = new GHPoint(12, 51);
+        GHPoint third = new GHPoint(11.2, 51.9);
+        GHResponse rsp12 = instance.route(new GHRequest().addPoint(first).addPoint(second));
+        assertFalse("should find 1->2", rsp12.hasErrors());
+        assertEquals(147930.5, rsp12.getDistance(), .1);
+        GHResponse rsp23 = instance.route(new GHRequest().addPoint(second).addPoint(third));
+        assertFalse("should find 2->3", rsp23.hasErrors());
+        assertEquals(176608.9, rsp23.getDistance(), .1);
+
+        GHResponse rsp = instance.route(new GHRequest().addPoint(first).addPoint(second).addPoint(third));
+
+        assertFalse(rsp.hasErrors());
+        assertFalse("should find 1->2->3", rsp.hasErrors());
+        assertEquals(rsp12.getDistance() + rsp23.getDistance(), rsp.getDistance(), 1e-6);
+        assertEquals(5, rsp.getPoints().getSize());
+        assertEquals(5, rsp.getInstructions().size());
+        assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().get(1).getSign());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
index be1c661a03..4e9b580902 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.coll;
 
-import com.graphhopper.storage.Edge;
+import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIterator;
 import java.util.PriorityQueue;
 import java.util.Random;
@@ -123,7 +123,7 @@ public void testRekey()
     @Test
     public void testSize()
     {
-        PriorityQueue<Edge> juQueue = new PriorityQueue<Edge>(100);
+        PriorityQueue<EdgeEntry> juQueue = new PriorityQueue<EdgeEntry>(100);
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
 
         Random rand = new Random(1);
@@ -132,14 +132,14 @@ public void testSize()
         {
             int val = rand.nextInt();
             binHeap.insert(val, i);
-            juQueue.add(new Edge(EdgeIterator.NO_EDGE, i, val));
+            juQueue.add(new EdgeEntry(EdgeIterator.NO_EDGE, i, val));
         }
 
         assertEquals(juQueue.size(), binHeap.getSize());
 
         for (int i = 0; i < N; i++)
         {
-            assertEquals(juQueue.poll().endNode, binHeap.pollElement(), 1e-5);
+            assertEquals(juQueue.poll().adjNode, binHeap.pollElement(), 1e-5);
         }
 
         assertEquals(binHeap.getSize(), 0);
diff --git a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
index 971d0d6e8d..359acc5890 100644
--- a/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
+++ b/core/src/test/java/com/graphhopper/coll/CompressedArrayTest.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.coll;
 
-import com.graphhopper.util.shapes.CoordTrig;
+import com.graphhopper.util.shapes.GHPoint;
 import java.util.Random;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -37,7 +37,7 @@ public void testCompress() throws Exception
         arr.write(12, 3);
         arr.flush();
 
-        CoordTrig coord = arr.get(0);
+        GHPoint coord = arr.get(0);
         assertEquals(10, coord.lat, 1e-6);
         assertEquals(1, coord.lon, 1e-6);
 
@@ -64,7 +64,7 @@ public void testCompress2() throws Exception
         }
 
         arr.flush();
-        CoordTrig coord = arr.get(0);
+        GHPoint coord = arr.get(0);
         assertEquals(0, coord.lat, 1e-6);
         assertEquals(65.787100, coord.lon, 1e-6);
 
diff --git a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java b/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
index 4bd696e0af..cdb07c9544 100644
--- a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
@@ -26,6 +26,7 @@
  */
 public class OSMIDSegmentedMapTest
 {
+
     @Test
     public void testZeroKey()
     {
diff --git a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
index dfa388056e..36dfb74cd2 100644
--- a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.geohash;
 
-import com.graphhopper.util.shapes.CoordTrig;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import static org.junit.Assert.*;
 import org.junit.Test;
@@ -68,4 +68,21 @@ public void testDecode()
         assertEquals(16.3333333, latLon.lat, 1e-7);
         assertEquals(5.25, latLon.lon, 1e-7);
     }
+    /*
+    * Test if different constructors yield same results
+     */
+    @Test
+    public void testInstantiation()
+    {
+        double minLon = 0; 
+        double minLat = 2;
+        double maxLat = 6;
+        double maxLon = 5;
+        
+        BBox bounds = new BBox(minLon,maxLon,minLat,maxLat);
+        LinearKeyAlgo algo1 = new LinearKeyAlgo(4,4).setBounds(bounds);
+        LinearKeyAlgo algo2 = new LinearKeyAlgo(4,4).setBounds(minLon, maxLon, minLat, maxLat);
+        assertEquals(algo1.getLonDelta(), algo2.getLonDelta(), 1e-7);
+        assertEquals(algo1.getLatDelta(), algo2.getLatDelta(), 1e-7);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
index 5d1cbd0c65..ca681b6bcd 100644
--- a/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/SpatialKeyAlgoTest.java
@@ -18,9 +18,7 @@
 package com.graphhopper.geohash;
 
 import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.shapes.CoordTrig;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -148,11 +146,11 @@ public void testBijection()
     public void testBijection( int bits )
     {
         SpatialKeyAlgo algo = new SpatialKeyAlgo(bits);
-        CoordTrig coord11 = new CoordTrig();
+        GHPoint coord11 = new GHPoint();
         long key = algo.encode(1, 1);
         algo.decode(key, coord11);
         long resKey = algo.encode(coord11.lat, coord11.lon);
-        CoordTrig coord2 = new CoordTrig();
+        GHPoint coord2 = new GHPoint();
         algo.decode(resKey, coord2);
         assertEquals(key, resKey);
 
@@ -197,7 +195,7 @@ public void testNoFurtherIterationIfBitsIs1()
     {
         SpatialKeyAlgo algo = new SpatialKeyAlgo(4).setBounds(0, 5, 0, 5);
         // 1001
-        CoordTrig coord = new CoordTrig();
+        GHPoint coord = new GHPoint();
         algo.decode(9, coord);
         assertEquals(3.125, coord.lat, 1e-4);
         assertEquals(1.875, coord.lon, 1e-4);
@@ -206,7 +204,7 @@ public void testNoFurtherIterationIfBitsIs1()
     @Test
     public void testOddBits()
     {
-        CoordTrig coord = new CoordTrig();
+        GHPoint coord = new GHPoint();
         SpatialKeyAlgo algo = new SpatialKeyAlgo(8);
         long key = algo.encode(5, 30);
         assertEquals("11000001", BitUtil.BIG.toLastBitString(key, 8));
@@ -228,11 +226,26 @@ public void testDifferentInitialBounds()
         assertEquals(1, algo.encode(0, 0.5));
         assertEquals(5, algo.encode(0, 1));
 
-        CoordTrig coord = new CoordTrig();
+        GHPoint coord = new GHPoint();
         algo.decode(5, coord);
         assertEquals(5, algo.encode(coord));
 
         algo.decode(1, coord);
         assertEquals(1, algo.encode(coord));
     }
+    
+    @Test
+    public void testEdgeCases() {
+        double minLon = -1, maxLon = 1.6;
+        double minLat = -1, maxLat = 0.5;
+        int parts = 4;
+        int bits = (int) (Math.log(parts * parts) / Math.log(2));
+        final KeyAlgo keyAlgo = new SpatialKeyAlgo(bits).setBounds(minLon, maxLon, minLat, maxLat);
+        // lat border 0.125
+        assertEquals(11, keyAlgo.encode(0.125, -0.2));
+        assertEquals(9, keyAlgo.encode(0.124, -0.2));
+        // lon border -0.35
+        assertEquals(11, keyAlgo.encode(0.2, -0.35));
+        assertEquals(10, keyAlgo.encode(0.2, -0.351));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
index 489554650b..ec6753870c 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMElementTest.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.reader;
 
+import java.util.HashMap;
+import java.util.Map;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -34,4 +36,17 @@ public void testHasTag()
         assertTrue(instance.hasTag("surface", "now", "something"));
         assertFalse(instance.hasTag("surface", "now", "not"));
     }
+
+    @Test
+    public void testSetTags()
+    {
+        OSMElement instance = new OSMWay(1);
+        Map<String, String> map = new HashMap<String, String>();
+        map.put("test", "xy");
+        instance.setTags(map);
+        assertTrue(instance.hasTag("test", "xy"));
+
+        instance.setTags(null);
+        assertFalse(instance.hasTag("test", "xy"));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
new file mode 100644
index 0000000000..ff3610c9ae
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/OSMNodeTest.java
@@ -0,0 +1,54 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class OSMNodeTest
+{
+    @Test
+    public void testSetTags()
+    {
+        OSMNode instance = new OSMNode(0, 10, 10);
+        assertTrue(Double.isNaN(instance.getEle()));
+
+        instance.setTag("ele", "-10.1");
+        assertEquals(-10.1, instance.getEle(), 1e-1);
+
+        // oh OSM
+        instance.setTag("ele", "-10,1");
+        assertEquals(-10.1, instance.getEle(), 1e-1);
+        // do not parse other stuff
+        instance.setTag("ele", "-9.1 m.");
+        assertEquals(-10.1, instance.getEle(), 1e-1);
+
+        // empty values
+        instance.setTag("ele", "");
+        assertTrue(Double.isNaN(instance.getEle()));
+        instance.setTag("ele", "-10.1");
+        assertEquals(-10.1, instance.getEle(), 1e-1);
+        instance.setTag("ele", null);
+        assertTrue(Double.isNaN(instance.getEle()));
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index 526a5f0905..7cdfdf5867 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -17,10 +17,7 @@
  */
 package com.graphhopper.reader;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 import gnu.trove.list.TLongList;
 
 import java.io.File;
@@ -31,7 +28,6 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.After;
@@ -39,24 +35,17 @@
 import org.junit.Test;
 
 import com.graphhopper.GraphHopper;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EncodedValue;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FootFlagEncoder;
-import com.graphhopper.storage.AbstractGraphStorageTester;
-import com.graphhopper.storage.ExtendedStorage;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
+import java.util.*;
 
 /**
  * Tests the OSMReader with the normal helper initialized.
@@ -74,9 +63,9 @@
     private final String fileTurnRestrictions = "test-restrictions.xml";
     private final String dir = "./target/tmp/test-db";
     private CarFlagEncoder carEncoder;
-    private FootFlagEncoder footEncoder;
+    private BikeFlagEncoder bikeEncoder;
+    private FlagEncoder footEncoder;
     private EdgeExplorer carOutExplorer;
-    private EdgeExplorer carInExplorer;
     private EdgeExplorer carAllExplorer;
 
     @Before
@@ -91,48 +80,64 @@ public void tearDown()
         Helper.removeDir(new File(dir));
     }
 
-    GraphStorage buildGraph( String directory, EncodingManager encodingManager, boolean turnRestrictionsImport )
+    GraphStorage newGraph( String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport )
     {
-        return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager, (turnRestrictionsImport) ? new TurnCostStorage()
-                : new ExtendedStorage.NoExtendedStorage());
+        return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager,
+                is3D, turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoExtendedStorage());
     }
 
     class GraphHopperTest extends GraphHopper
     {
-        String testFile;
+        public GraphHopperTest( String osmFile )
+        {
+            this(osmFile, false);
+        }
 
-        public GraphHopperTest( String file )
+        public GraphHopperTest( String osmFile, boolean turnCosts )
         {
-            this.testFile = file;
+            setStoreOnFlush(false);
+            setOSMFile(osmFile);
             setGraphHopperLocation(dir);
             setEncodingManager(new EncodingManager("CAR,FOOT"));
-            disableCHShortcuts();
+            setCHEnable(false);
+
+            if (turnCosts)
+            {
+                carEncoder = new CarFlagEncoder(5, 5, 3);
+                bikeEncoder = new BikeFlagEncoder(4, 2, 3);
+            } else
+            {
+                carEncoder = new CarFlagEncoder();
+                bikeEncoder = new BikeFlagEncoder();
+            }
 
-            carEncoder = (CarFlagEncoder) getEncodingManager().getEncoder("CAR");
-            footEncoder = (FootFlagEncoder) getEncodingManager().getEncoder("FOOT");
+            footEncoder = new FootFlagEncoder();
+
+            setEncodingManager(new EncodingManager(footEncoder, carEncoder, bikeEncoder));
         }
 
-        OSMReader createReader( GraphStorage tmpGraph )
+        @Override
+        protected DataReader createReader( GraphStorage tmpGraph )
         {
-            return new OSMReader(tmpGraph, 1000);
+            return initOSMReader(new OSMReader(tmpGraph));
         }
 
         @Override
-        protected OSMReader importOSM( String ignore ) throws IOException
+        protected DataReader importData() throws IOException
         {
-            GraphStorage tmpGraph = buildGraph(dir, getEncodingManager(), isEnableTurnRestrictions());
+            GraphStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(), getEncodingManager().needsTurnCostsSupport());
             setGraph(tmpGraph);
-            OSMReader osmReader = createReader(tmpGraph);
-            osmReader.setEncodingManager(getEncodingManager());
+
+            DataReader osmReader = createReader(tmpGraph);
             try
             {
-                osmReader.doOSM2Graph(new File(getClass().getResource(testFile).toURI()));
+                ((OSMReader) osmReader).setOSMFile(new File(getClass().getResource(getOSMFile()).toURI()));
             } catch (URISyntaxException e)
             {
                 throw new RuntimeException(e);
             }
+            osmReader.readGraph();
             carOutExplorer = getGraph().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, false, true));
-            carInExplorer = getGraph().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, false));
             carAllExplorer = getGraph().createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, true));
             return osmReader;
         }
@@ -147,7 +152,11 @@ InputStream getResource( String file )
     public void testMain()
     {
         GraphHopper hopper = new GraphHopperTest(file1).importOrLoad();
-        Graph graph = hopper.getGraph();
+        GraphStorage graph = (GraphStorage) hopper.getGraph();
+
+        assertNotNull(graph.getProperties().get("osmreader.import.date"));
+        assertNotEquals("", graph.getProperties().get("osmreader.import.date"));
+
         assertEquals(4, graph.getNodes());
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
         int n10 = AbstractGraphStorageTester.getIdOf(graph, 51.2492152);
@@ -162,7 +171,7 @@ public void testMain()
         assertEquals("street 123, B 122", iter.getName());
         assertEquals(n50, iter.getAdjNode());
         AbstractGraphStorageTester.assertPList(Helper.createPointList(51.25, 9.43), iter.fetchWayGeometry(0));
-        CarFlagEncoder flags = carEncoder;
+        FlagEncoder flags = carEncoder;
         assertTrue(flags.isForward(iter.getFlags()));
         assertTrue(flags.isBackward(iter.getFlags()));
 
@@ -187,12 +196,13 @@ public void testMain()
         assertEquals(n20, iter.getAdjNode());
         assertEquals(93146.888, iter.getDistance(), 1);
 
-        assertEquals(9.4, graph.getLongitude(hopper.getLocationIndex().findID(51.2, 9.4)), 1e-3);
-        assertEquals(10, graph.getLongitude(hopper.getLocationIndex().findID(49, 10)), 1e-3);
-        assertEquals(51.249, graph.getLatitude(hopper.getLocationIndex().findID(51.2492152, 9.4317166)), 1e-3);
+        NodeAccess na = graph.getNodeAccess();
+        assertEquals(9.4, na.getLongitude(hopper.getLocationIndex().findID(51.2, 9.4)), 1e-3);
+        assertEquals(10, na.getLongitude(hopper.getLocationIndex().findID(49, 10)), 1e-3);
+        assertEquals(51.249, na.getLatitude(hopper.getLocationIndex().findID(51.2492152, 9.4317166)), 1e-3);
 
         // node 40 is on the way between 30 and 50 => 9.0
-        assertEquals(9, graph.getLongitude(hopper.getLocationIndex().findID(51.25, 9.43)), 1e-3);
+        assertEquals(9, na.getLongitude(hopper.getLocationIndex().findID(51.25, 9.43)), 1e-3);
     }
 
     @Test
@@ -200,8 +210,9 @@ public void testSort()
     {
         GraphHopper hopper = new GraphHopperTest(file1).setSortGraph(true).importOrLoad();
         Graph graph = hopper.getGraph();
-        assertEquals(10, graph.getLongitude(hopper.getLocationIndex().findID(49, 10)), 1e-3);
-        assertEquals(51.249, graph.getLatitude(hopper.getLocationIndex().findID(51.2492152, 9.4317166)), 1e-3);
+        NodeAccess na = graph.getNodeAccess();
+        assertEquals(10, na.getLongitude(hopper.getLocationIndex().findID(49, 10)), 1e-3);
+        assertEquals(51.249, na.getLatitude(hopper.getLocationIndex().findID(51.2492152, 9.4317166)), 1e-3);
     }
 
     @Test
@@ -210,16 +221,16 @@ public void testWithBounds()
         GraphHopper hopper = new GraphHopperTest(file1)
         {
             @Override
-            OSMReader createReader( GraphStorage tmpGraph )
+            protected DataReader createReader( GraphStorage tmpGraph )
             {
-                return new OSMReader(tmpGraph, 1000)
+                return new OSMReader(tmpGraph)
                 {
                     @Override
                     public boolean isInBounds( OSMNode node )
                     {
                         return node.getLat() > 49 && node.getLon() > 8;
                     }
-                };
+                }.setEncodingManager(getEncodingManager());
             }
         };
 
@@ -277,7 +288,7 @@ public void testOneWay()
         assertTrue(iter.next());
         assertEquals(n30, iter.getAdjNode());
 
-        CarFlagEncoder encoder = carEncoder;
+        FlagEncoder encoder = carEncoder;
         iter = carAllExplorer.setBaseNode(n20);
         assertTrue(iter.next());
         assertEquals(n23, iter.getAdjNode());
@@ -324,13 +335,13 @@ public void cleanUp()
         int n80 = AbstractGraphStorageTester.getIdOf(graph, 54.1);
         EdgeIterator iter = carOutExplorer.setBaseNode(n80);
         iter.next();
-        assertEquals(5, carEncoder.getSpeed(iter.getFlags()));
+        assertEquals(5, carEncoder.getSpeed(iter.getFlags()), 1e-1);
 
-        // more precise speed calculation! ~150km (from 54.0,10.1 to 55.0,10.1) in duration=70 minutes -> wow ;)
-        // => 130km/h => / 1.4 => 92km/h        
+        // duration 01:10 is given => more precise speed calculation! 
+        // ~111km (from 54.0,10.1 to 55.0,10.2) in duration=70 minutes => 95km/h => / 1.4 => 71km/h        
         iter = carOutExplorer.setBaseNode(n40);
         iter.next();
-        assertEquals(100, carEncoder.getSpeed(iter.getFlags()));
+        assertEquals(70, carEncoder.getSpeed(iter.getFlags()), 1e-1);
     }
 
     @Test
@@ -348,7 +359,7 @@ public void cleanUp()
         int n60 = AbstractGraphStorageTester.getIdOf(graph, 56.0);
         EdgeIterator iter = carOutExplorer.setBaseNode(n60);
         iter.next();
-        assertEquals(35, carEncoder.getSpeed(iter.getFlags()));
+        assertEquals(35, carEncoder.getSpeed(iter.getFlags()), 1e-1);
     }
 
     @Test
@@ -427,8 +438,9 @@ public void testBarriers()
         // separate id
         int new20 = 4;
         assertNotEquals(n20, new20);
-        assertEquals(graph.getLatitude(n20), graph.getLatitude(new20), 1e-5);
-        assertEquals(graph.getLongitude(n20), graph.getLongitude(new20), 1e-5);
+        NodeAccess na = graph.getNodeAccess();
+        assertEquals(na.getLatitude(n20), na.getLatitude(new20), 1e-5);
+        assertEquals(na.getLongitude(n20), na.getLongitude(new20), 1e-5);
 
         assertEquals(n20, hopper.getLocationIndex().findID(52, 9.4));
 
@@ -472,8 +484,9 @@ public void testBarriersOnTowerNodes()
     public void testRelation()
     {
         EncodingManager manager = new EncodingManager("bike");
-        OSMReader reader = new OSMReader(new GraphHopperStorage(new RAMDirectory(), manager), -1).setEncodingManager(manager);
-        OSMRelation osmRel = new OSMRelation(1, new HashMap<String, String>());
+        OSMReader reader = new OSMReader(new GraphHopperStorage(new RAMDirectory(), manager, false)).
+                setEncodingManager(manager);
+        OSMRelation osmRel = new OSMRelation(1);
         osmRel.getMembers().add(new OSMRelation.Member(OSMRelation.WAY, 1, ""));
         osmRel.getMembers().add(new OSMRelation.Member(OSMRelation.WAY, 2, ""));
 
@@ -500,64 +513,68 @@ public void testRelation()
     @Test
     public void testTurnRestrictions()
     {
-        GraphHopper hopper = new GraphHopperTest(fileTurnRestrictions).setEnableTurnRestrictions(true).importOrLoad();
-        Graph graph = hopper.getGraph();
-        assertEquals(9, graph.getNodes());
-        assertTrue(((GraphHopperStorage)graph).getExtendedStorage() instanceof TurnCostStorage);
+        GraphHopper hopper = new GraphHopperTest(fileTurnRestrictions, true).
+                importOrLoad();
+        GraphStorage graph = hopper.getGraph();
+        assertEquals(15, graph.getNodes());
+        assertTrue(graph.getExtension() instanceof TurnCostExtension);
+        TurnCostExtension tcStorage = (TurnCostExtension) graph.getExtension();
 
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage)graph).getExtendedStorage();
-        
+        int n1 = AbstractGraphStorageTester.getIdOf(graph, 50, 10);
         int n2 = AbstractGraphStorageTester.getIdOf(graph, 52, 10);
         int n3 = AbstractGraphStorageTester.getIdOf(graph, 52, 11);
         int n4 = AbstractGraphStorageTester.getIdOf(graph, 52, 12);
+        int n5 = AbstractGraphStorageTester.getIdOf(graph, 50, 12);
+        int n6 = AbstractGraphStorageTester.getIdOf(graph, 51, 11);
         int n8 = AbstractGraphStorageTester.getIdOf(graph, 54, 11);
-        
-        int edge2_3 = getEdge(n2, n3);
-        int edge3_4 = getEdge(n3, n4);
-        int edge3_8 = getEdge(n3, n8);
-        
-        int edge3_2 = getEdge(n3, n2);
-        int edge4_3 = getEdge(n4, n3);
-        int edge8_3 = getEdge(n8, n3);
-        
+
+        int edge1_6 = GHUtility.getEdge(graph, n1, n6).getEdge();
+        int edge2_3 = GHUtility.getEdge(graph, n2, n3).getEdge();
+        int edge3_4 = GHUtility.getEdge(graph, n3, n4).getEdge();
+        int edge3_8 = GHUtility.getEdge(graph, n3, n8).getEdge();
+
+        int edge3_2 = GHUtility.getEdge(graph, n3, n2).getEdge();
+        int edge4_3 = GHUtility.getEdge(graph, n4, n3).getEdge();
+        int edge8_3 = GHUtility.getEdge(graph, n8, n3).getEdge();
+
         // (2-3)->(3-4) only_straight_on = (2-3)->(3-8) restricted
         // (4-3)->(3-8) no_right_turn = (4-3)->(3-8) restricted
-        assertTrue(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge2_3, edge3_8)));
-        assertTrue(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge4_3, edge3_8)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge2_3, edge3_4)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge2_3, edge3_2)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge2_3, edge3_4)));        
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge4_3, edge3_2)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n3, edge8_3, edge3_2)));
-        
-        int n1 = AbstractGraphStorageTester.getIdOf(graph, 50, 10);
-        int n5 = AbstractGraphStorageTester.getIdOf(graph, 50, 12);
-        int n6 = AbstractGraphStorageTester.getIdOf(graph, 50, 11);
-        
-        int edge4_5 = getEdge(n4, n5);
-        int edge5_6 = getEdge(n5, n6);
-        int edge5_1 = getEdge(n5, n1);
-        
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_8)) > 0);
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_8)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge8_3, n3, edge3_2)));
+
+        // u-turn restriction for (6-1)->(1-6) but not for (1-6)->(6-1)
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge1_6, n1, edge1_6)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge1_6, n6, edge1_6)));
+
+        int edge4_5 = GHUtility.getEdge(graph, n4, n5).getEdge();
+        int edge5_6 = GHUtility.getEdge(graph, n5, n6).getEdge();
+        int edge5_1 = GHUtility.getEdge(graph, n5, n1).getEdge();
+
         // (4-5)->(5-1) right_turn_only = (4-5)->(5-6) restricted 
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n5, edge4_5, edge5_6)));
-        assertTrue(carEncoder.isTurnRestricted(tcStorage.getTurnCosts(n5, edge4_5, edge5_1)));
-    }
-    
-    private int getEdge(int from, int to){
-        EdgeIterator iter = carOutExplorer.setBaseNode(from);
-        while(iter.next()) {
-            if(iter.getAdjNode() == to){
-                return iter.getEdge();
-            }
-        }
-        return EdgeIterator.NO_EDGE;
-    }
+        long costsFlags = tcStorage.getTurnCostFlags(edge4_5, n5, edge5_6);
+        assertFalse(carEncoder.isTurnRestricted(costsFlags));
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)) > 0);
 
-    @Test
-    public void testFixWayName()
-    {
-        assertEquals("B8, B12", OSMReader.fixWayName("B8;B12"));
-        assertEquals("B8, B12", OSMReader.fixWayName("B8; B12"));
+        // for bike
+        assertFalse(bikeEncoder.isTurnRestricted(costsFlags));
+
+        int n10 = AbstractGraphStorageTester.getIdOf(graph, 40, 10);
+        int n11 = AbstractGraphStorageTester.getIdOf(graph, 40, 11);
+        int n14 = AbstractGraphStorageTester.getIdOf(graph, 39, 11);
+
+        int edge10_11 = GHUtility.getEdge(graph, n10, n11).getEdge();
+        int edge11_14 = GHUtility.getEdge(graph, n11, n14).getEdge();
+
+        assertEquals(0, tcStorage.getTurnCostFlags(edge11_14, n11, edge10_11));
+
+        costsFlags = tcStorage.getTurnCostFlags(edge10_11, n11, edge11_14);
+        assertFalse(carEncoder.isTurnRestricted(costsFlags));
+        assertTrue(bikeEncoder.isTurnRestricted(costsFlags));
     }
 
     @Test
@@ -571,36 +588,20 @@ public void testEstimatedCenter()
             public int defineNodeBits( int index, int shift )
             {
                 shift = super.defineNodeBits(index, shift);
-                objectEncoder = new EncodedValue("oEnc", shift, 2, 1, 0, 3, false, true);
+                objectEncoder = new EncodedValue("oEnc", shift, 2, 1, 0, 3, true);
                 return shift + 2;
             }
 
             @Override
-            public long analyzeNodeTags( OSMNode node )
+            public long handleNodeTags( OSMNode node )
             {
                 if (node.hasTag("test", "now"))
                     return -objectEncoder.setValue(0, 1);
                 return 0;
             }
-
-            @Override
-            public long applyNodeFlags( long wayFlags, long nodeFlags )
-            {
-                int speed = getSpeed(wayFlags);
-                if (objectEncoder.getValue(nodeFlags) != 0)
-                    speed -= 5;
-
-                return speedEncoder.setValue(wayFlags, speed);
-            }
         };
-        EncodingManager manager = new EncodingManager()
-        {
-
-            {
-                super.registerEncoder(encoder);
-            }
-        };
-        GraphStorage graph = buildGraph(dir, manager, false);
+        EncodingManager manager = new EncodingManager(encoder);
+        GraphStorage graph = newGraph(dir, manager, false, false);
         final Map<Integer, Double> latMap = new HashMap<Integer, Double>();
         final Map<Integer, Double> lonMap = new HashMap<Integer, Double>();
         latMap.put(1, 1.1d);
@@ -609,7 +610,7 @@ public long applyNodeFlags( long wayFlags, long nodeFlags )
         lonMap.put(1, 1.0d);
         lonMap.put(2, 1.0d);
         final AtomicInteger increased = new AtomicInteger(0);
-        OSMReader osmreader = new OSMReader(graph, 1000)
+        OSMReader osmreader = new OSMReader(graph)
         {
             // mock data access
             @Override
@@ -627,18 +628,14 @@ public long applyNodeFlags( long wayFlags, long nodeFlags )
             @Override
             Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long wayFlags, long osmId )
             {
-                // reduced speed due to node tags
-                increased.incrementAndGet();
-                assertEquals(100 - 5, encoder.getSpeed(wayFlags));
                 return Collections.emptyList();
             }
         };
         osmreader.setEncodingManager(manager);
         // save some node tags for first node
-        Map<String, String> nodeMap = new HashMap<String, String>();
-        OSMNode osmNode = new OSMNode(1, nodeMap, 1.1d, 1.0d);
+        OSMNode osmNode = new OSMNode(1, 1.1d, 1.0d);
         osmNode.setTag("test", "now");
-        osmreader.getNodeFlagsMap().put(1, encoder.analyzeNodeTags(osmNode));
+        osmreader.getNodeFlagsMap().put(1, encoder.handleNodeTags(osmNode));
 
         OSMWay way = new OSMWay(1L);
         way.getNodes().add(1);
@@ -648,11 +645,150 @@ public long applyNodeFlags( long wayFlags, long nodeFlags )
         osmreader.getNodeMap().put(2, 2);
         osmreader.processWay(way);
 
-        GHPoint p = way.getInternalTag("estimated_center", null);
+        GHPoint p = way.getTag("estimated_center", null);
         assertEquals(1.15, p.lat, 1e-3);
         assertEquals(1.0, p.lon, 1e-3);
-        Double d = way.getInternalTag("estimated_distance", null);
+        Double d = way.getTag("estimated_distance", null);
         assertEquals(11119.5, d, 1e-1);
-        assertEquals(1, increased.get());
+    }
+
+    @Test
+    public void testReadEleFromCustomOSM()
+    {
+        GraphHopper hopper = new GraphHopperTest("custom-osm-ele.xml")
+        {
+            @Override
+            protected DataReader createReader( GraphStorage tmpGraph )
+            {
+                return initOSMReader(new OSMReader(tmpGraph)
+                {
+                    @Override
+                    protected double getElevation( OSMNode node )
+                    {
+                        return node.getEle();
+                    }
+                });
+            }
+        }.setElevation(true).importOrLoad();
+
+        Graph graph = hopper.getGraph();
+        int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
+        int n50 = AbstractGraphStorageTester.getIdOf(graph, 49);
+
+        EdgeIteratorState edge = GHUtility.getEdge(graph, n20, n50);
+        assertEquals(Helper.createPointList3D(52, 9, -10, 51.25, 9.43, 100, 49, 10, -30), edge.fetchWayGeometry(3));
+    }
+
+    @Test
+    public void testReadEleFromDataProvider()
+    {
+        GraphHopper hopper = new GraphHopperTest("test-osm5.xml");
+        // get N10E046.hgt.zip
+        ElevationProvider provider = new SRTMProvider();
+        provider.setCacheDir(new File("./files"));
+        hopper.setElevationProvider(provider);
+        hopper.importOrLoad();
+
+        Graph graph = hopper.getGraph();
+        int n10 = AbstractGraphStorageTester.getIdOf(graph, 49.501);
+        int n30 = AbstractGraphStorageTester.getIdOf(graph, 49.5011);
+        int n50 = AbstractGraphStorageTester.getIdOf(graph, 49.5001);
+
+        EdgeIteratorState edge = GHUtility.getEdge(graph, n50, n30);
+        assertEquals(Helper.createPointList3D(49.5001, 11.501, 426, 49.5002, 11.5015, 441, 49.5011, 11.502, 410.0),
+                edge.fetchWayGeometry(3));
+
+        edge = GHUtility.getEdge(graph, n10, n50);
+        assertEquals(Helper.createPointList3D(49.501, 11.5001, 383.0, 49.5001, 11.501, 426.0),
+                edge.fetchWayGeometry(3));
+    }
+
+    /**
+     * Tests the combination of different turn cost flags by different encoders.
+     */
+    @Test
+    public void testTurnFlagCombination()
+    {
+        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_car = new OSMTurnRelation.TurnCostTableEntry();
+        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_foot = new OSMTurnRelation.TurnCostTableEntry();
+        final OSMTurnRelation.TurnCostTableEntry turnCostEntry_bike = new OSMTurnRelation.TurnCostTableEntry();
+
+        CarFlagEncoder car = new CarFlagEncoder(5, 5, 24);
+        FootFlagEncoder foot = new FootFlagEncoder();
+        BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24);
+        EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
+
+        OSMReader reader = new OSMReader(new GraphBuilder(manager).create())
+        {
+            @Override
+            public Collection<OSMTurnRelation.TurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder,
+                    OSMTurnRelation turnRelation )
+            {
+                // simulate by returning one turn cost entry directly
+                if (encoder.toString().equalsIgnoreCase("car"))
+                {
+
+                    return Collections.singleton(turnCostEntry_car);
+                } else if (encoder.toString().equalsIgnoreCase("foot"))
+                {
+                    return Collections.singleton(turnCostEntry_foot);
+                } else if (encoder.toString().equalsIgnoreCase("bike"))
+                {
+                    return Collections.singleton(turnCostEntry_bike);
+                } else
+                {
+                    throw new IllegalArgumentException("illegal encoder " + encoder.toString());
+                }
+            }
+        }.setEncodingManager(manager);
+
+        // turn cost entries for car and foot are for the same relations (same viaNode, edgeFrom and edgeTo), 
+        // turn cost entry for bike is for another relation (different viaNode) 
+        turnCostEntry_car.edgeFrom = 1;
+        turnCostEntry_foot.edgeFrom = 1;
+        turnCostEntry_bike.edgeFrom = 2;
+
+        // calculating arbitrary flags using the encoders
+        turnCostEntry_car.flags = car.getTurnFlags(true, 0);
+        turnCostEntry_foot.flags = foot.getTurnFlags(true, 0);
+        turnCostEntry_bike.flags = bike.getTurnFlags(false, 10);
+
+        // we expect two different entries: the first one is a combination of turn flags of car and foot, 
+        // since they provide the same relation, the other one is for bike only
+        long assertFlag1 = turnCostEntry_car.flags | turnCostEntry_foot.flags;
+        long assertFlag2 = turnCostEntry_bike.flags;
+
+        // combine flags of all encoders
+        Collection<OSMTurnRelation.TurnCostTableEntry> entries = reader.analyzeTurnRelation(null);
+
+        // we expect two different turnCost entries
+        assertEquals(2, entries.size());
+
+        for (OSMTurnRelation.TurnCostTableEntry entry : entries)
+        {
+            if (entry.edgeFrom == 1)
+            {
+                // the first entry provides turn flags for car and foot only 
+                assertEquals(assertFlag1, entry.flags);
+                assertTrue(car.isTurnRestricted(entry.flags));
+                assertFalse(foot.isTurnRestricted(entry.flags));
+                assertFalse(bike.isTurnRestricted(entry.flags));
+
+                assertTrue(Double.isInfinite(car.getTurnCost(entry.flags)));
+                assertEquals(0, foot.getTurnCost(entry.flags), 1e-1);
+                assertEquals(0, bike.getTurnCost(entry.flags), 1e-1);
+            } else if (entry.edgeFrom == 2)
+            {
+                // the 2nd entry provides turn flags for bike only
+                assertEquals(assertFlag2, entry.flags);
+                assertFalse(car.isTurnRestricted(entry.flags));
+                assertFalse(foot.isTurnRestricted(entry.flags));
+                assertFalse(bike.isTurnRestricted(entry.flags));
+
+                assertEquals(0, car.getTurnCost(entry.flags), 1e-1);
+                assertEquals(0, foot.getTurnCost(entry.flags), 1e-1);
+                assertEquals(10, bike.getTurnCost(entry.flags), 1e-1);
+            }
+        }
     }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
new file mode 100644
index 0000000000..7c3629cd9e
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
@@ -0,0 +1,106 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader;
+
+import com.graphhopper.reader.OSMTurnRelation.Type;
+import com.graphhopper.routing.EdgeBasedRoutingAlgorithmTest;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.util.EdgeExplorer;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class OSMTurnRelationTest
+{
+    @Test
+    public void testGetRestrictionAsEntries()
+    {
+        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 3);
+        final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
+        final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
+                
+        osmNodeToInternal.put(3L, 3);
+        // edge ids are only stored if they occured before in an OSMRelation
+        internalToOSMEdge.put(3, 3L);        
+        internalToOSMEdge.put(4, 4L);        
+
+        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder)).create();
+        EdgeBasedRoutingAlgorithmTest.initGraph(graph);
+        OSMReader osmReader = new OSMReader(graph)
+        {
+
+            @Override
+            public int getInternalNodeIdOfOsmNode( long nodeOsmId )
+            {
+                return osmNodeToInternal.get(nodeOsmId);
+            }
+
+            @Override
+            public long getOsmIdOfInternalEdge( int edgeId )
+            {
+                Long l = internalToOSMEdge.get(edgeId);
+                if(l == null)
+                    return -1;
+                return l;
+            }
+        };
+
+        EdgeExplorer edgeExplorer = graph.createEdgeExplorer();
+
+        // TYPE == ONLY
+        OSMTurnRelation instance = new OSMTurnRelation(4, 3, 3, Type.ONLY);
+        Collection<OSMTurnRelation.TurnCostTableEntry> result
+                = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+
+        assertEquals(2, result.size());
+        Iterator<OSMTurnRelation.TurnCostTableEntry> iter = result.iterator();
+        OSMTurnRelation.TurnCostTableEntry entry = iter.next();
+        assertEquals(4, entry.edgeFrom);
+        assertEquals(6, entry.edgeTo);
+        assertEquals(3, entry.nodeVia);
+        
+        entry = iter.next();
+        assertEquals(4, entry.edgeFrom);
+        assertEquals(2, entry.edgeTo);
+        assertEquals(3, entry.nodeVia);
+        
+        
+        // TYPE == NOT
+        instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
+        result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+
+        assertEquals(1, result.size());
+        iter = result.iterator();
+        entry = iter.next();
+        assertEquals(4, entry.edgeFrom);
+        assertEquals(3, entry.edgeTo);
+        assertEquals(3, entry.nodeVia);       
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
new file mode 100644
index 0000000000..e07c32fe02
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/CGIARProviderTest.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class CGIARProviderTest
+{
+    @Test
+    public void testDown()
+    {
+        CGIARProvider instance = new CGIARProvider();
+        assertEquals(50, instance.down(52.5));
+        assertEquals(0, instance.down(0.1));
+        assertEquals(0, instance.down(0.01));
+        assertEquals(-5, instance.down(-0.01));
+        assertEquals(-5, instance.down(-2));
+        assertEquals(-10, instance.down(-5.1));
+        assertEquals(50, instance.down(50));
+        assertEquals(45, instance.down(49));
+    }
+
+    @Test
+    public void testFileName()
+    {
+        CGIARProvider instance = new CGIARProvider();
+        assertEquals("srtm_36_02", instance.getFileName(52, -0.1));
+        assertEquals("srtm_35_02", instance.getFileName(50, -10));
+
+        assertEquals("srtm_36_23", instance.getFileName(-52, -0.1));
+        assertEquals("srtm_35_22", instance.getFileName(-50, -10));
+
+        assertEquals("srtm_39_03", instance.getFileName(49.9, 11.5));
+        assertEquals("srtm_34_08", instance.getFileName(20, -11));
+        assertEquals("srtm_34_08", instance.getFileName(20, -14));
+        assertEquals("srtm_34_08", instance.getFileName(20, -15));
+        assertEquals("srtm_37_02", instance.getFileName(52.1943832, 0.1363176));
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
new file mode 100644
index 0000000000..f9adbc5ae3
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/HeightTileTest.java
@@ -0,0 +1,139 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.RAMDirectory;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class HeightTileTest
+{
+    @Test
+    public void testGetHeight()
+    {
+        // data access has same coordinate system as graphical or UI systems have (or the original DEM data has).
+        // But HeightTile has lat,lon system ('mathematically')
+        int width = 10;
+        HeightTile instance = new HeightTile(0, 0, width, 1e-6, 10);
+        DataAccess heights = new RAMDirectory().find("tmp");
+        heights.create(2 * 10 * 10);
+        instance.setHeights(heights);
+        init(heights, width, 1);
+
+        // x,y=1,7
+        heights.setShort(2 * (7 * width + 1), (short) 70);
+
+        // x,y=2,9
+        heights.setShort(2 * (9 * width + 2), (short) 90);
+
+        assertEquals(1, instance.getHeight(5, 5), 1e-3);
+        assertEquals(70, instance.getHeight(2.5, 1.5), 1e-3);
+        // edge cases for one tile with the boundaries [min,min+degree/width) for lat and lon
+        assertEquals(1, instance.getHeight(3, 2), 1e-3);
+        assertEquals(70, instance.getHeight(2, 1), 1e-3);
+
+        // edge cases for the whole object        
+        assertEquals(1, instance.getHeight(+1.0, 2), 1e-3);
+        assertEquals(90, instance.getHeight(0.5, 2.5), 1e-3);
+        assertEquals(90, instance.getHeight(0.0, 2.5), 1e-3);
+        assertEquals(1, instance.getHeight(+0.0, 3), 1e-3);
+        assertEquals(1, instance.getHeight(-0.5, 3.5), 1e-3);
+        assertEquals(1, instance.getHeight(-0.5, 3.0), 1e-3);
+        // fall back to "2,9" if within its boundaries
+        assertEquals(90, instance.getHeight(-0.5, 2.5), 1e-3);
+
+        assertEquals(1, instance.getHeight(0, 0), 1e-3);
+        assertEquals(1, instance.getHeight(9, 10), 1e-3);
+        assertEquals(1, instance.getHeight(10, 9), 1e-3);
+        assertEquals(1, instance.getHeight(10, 10), 1e-3);
+
+        // no error
+        assertEquals(1, instance.getHeight(10.5, 5), 1e-3);
+        assertEquals(1, instance.getHeight(-0.5, 5), 1e-3);
+        assertEquals(1, instance.getHeight(1, -0.5), 1e-3);
+        assertEquals(1, instance.getHeight(1, 10.5), 1e-3);
+    }
+
+    @Test
+    public void testGetHeightForNegativeTile()
+    {
+        int width = 10;
+        HeightTile instance = new HeightTile(-20, -20, width, 1e-6, 10);
+        DataAccess heights = new RAMDirectory().find("tmp");
+        heights.create(2 * 10 * 10);
+        instance.setHeights(heights);
+        init(heights, width, 1);
+
+        // x,y=1,7
+        heights.setShort(2 * (7 * width + 1), (short) 70);
+
+        // x,y=2,9
+        heights.setShort(2 * (9 * width + 2), (short) 90);
+
+        assertEquals(1, instance.getHeight(-15, -15), 1e-3);
+        assertEquals(70, instance.getHeight(-17.5, -18.5), 1e-3);
+        // edge cases for one tile with the boundaries [min,min+degree/width) for lat and lon
+        assertEquals(1, instance.getHeight(-17, -18), 1e-3);
+        assertEquals(70, instance.getHeight(-18, -19), 1e-3);
+    }
+
+    @Test
+    public void testCalcMean()
+    {
+        int width = 10;
+        HeightTile instance = new HeightTile(0, 0, width, 1e-6, 10).setCalcMean(true);
+        DataAccess heights = new RAMDirectory().find("tmp");
+        heights.create(2 * 10 * 10);
+        instance.setHeights(heights);
+        init(heights, width, 1);
+
+        // x,y=0,9
+        heights.setShort(2 * (9 * width + 0), (short) 10);
+
+        // x,y=1,7
+        heights.setShort(2 * (7 * width + 1), (short) 70);
+
+        // x,y=2,8
+        heights.setShort(2 * (8 * width + 2), (short) 90);
+
+        assertEquals((70 + 4) / 5d, instance.getHeight(2, 1), 1e-3);
+
+        assertEquals((70 + 90 + 3) / 5d, instance.getHeight(2.5, 2.5), 1e-3);
+
+        assertEquals((90 + 3) / 4d, instance.getHeight(-0.5, 2.5), 1e-3);
+
+        assertEquals((10 + 2) / 3d, instance.getHeight(-0.5, -0.5), 1e-3);
+    }
+
+    private void init( DataAccess da, int width, int i )
+    {
+        for (int x = 0; x < width; x++)
+        {
+            for (int y = 0; y < width; y++)
+            {
+                da.setShort(2 * (y * width + x), (short) 1);
+            }
+        }
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
new file mode 100644
index 0000000000..79631a5a02
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
@@ -0,0 +1,100 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DAType;
+import java.io.File;
+import java.io.IOException;
+import org.junit.After;
+import org.junit.Test;
+import static org.junit.Assert.*;
+import org.junit.Before;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class SRTMProviderTest
+{
+    SRTMProvider instance;
+
+    @Before
+    public void setUp()
+    {
+        instance = new SRTMProvider();
+    }
+
+    @After
+    public void tearDown()
+    {
+        instance.release();
+    }
+
+    @Test
+    public void testGetFileString()
+    {
+        assertEquals("Eurasia/N49E011", instance.getFileString(49, 11));
+        assertEquals("Eurasia/N52W002", instance.getFileString(52.268157, -1.230469));
+        assertEquals("Africa/S06E034", instance.getFileString(-5.965754, 34.804687));
+        assertEquals("Australia/S29E131", instance.getFileString(-28.304381, 131.484375));
+        assertEquals("South_America/S09W045", instance.getFileString(-9, -45));
+        assertEquals("South_America/S10W046", instance.getFileString(-9.1, -45.1));
+        assertEquals("South_America/S10W045", instance.getFileString(-9.6, -45));
+        assertEquals("South_America/S28W071", instance.getFileString(-28, -71));
+        assertEquals("South_America/S29W072", instance.getFileString(-28.88316, -71.070557));
+    }
+
+    @Test
+    public void testGetHeight() throws IOException
+    {
+        instance.setCacheDir(new File("./files/"));
+        // easy to verify orientation of tile:
+//        instance.getEle(43, 13);
+
+        // siegesturm
+        assertEquals(466, instance.getEle(49.968651, 11.574869), 1e-1);
+        // am main
+        assertEquals(330, instance.getEle(49.958233, 11.558647), 1e-1);
+        // south america
+        assertEquals(1678, instance.getEle(-28.88316, -71.070557), 1e-1);
+        assertEquals(0, instance.getEle(-28.671311, -71.38916), 1e-1);
+
+        // montevideo
+        // assertEquals(45, instance.getEle(-34.906205,-56.189575), 1e-1);
+        // new york
+        // assertEquals(21, instance.getEle(40.730348,-73.985882), 1e-1);
+        // use 0 elevation if area not found
+        assertEquals(0, instance.getEle(55.4711873, 19.2501641), 1e-1);
+
+        assertEquals(161, instance.getEle(55.8943144, -3), 1e-1);
+        // precision = 1e6 => -3
+        // assertEquals(160, instance.getEle(55.8943144, -3.0000004), 1e-1);
+        // precision = 1e7 => -4
+        // assertEquals(161, instance.getEle(55.8943144, -3.0004), 1e-1);
+        // assertEquals(161, instance.getEle(55.8943144, -3.0000001), 1e-1);
+    }
+
+    @Test
+    public void testGetHeightMMap() throws IOException
+    {
+        instance.setCacheDir(new File("./files/"));
+        instance.setDAType(DAType.MMAP);
+        assertEquals(161, instance.getEle(55.8943144, -3), 1e-1);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index c2271245f0..ea30e4233c 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -17,28 +17,55 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.Weighting;
+import java.util.Arrays;
+import java.util.Collection;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.storage.Graph;
 
 /**
  *
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class AStarBidirectionTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { TraversalMode.NODE_BASED },
+            { TraversalMode.EDGE_BASED_1DIR },
+            { TraversalMode.EDGE_BASED_2DIR },
+            { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public AStarBidirectionTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph g, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new AStarBidirection(_graph, encoder, w);
+                return new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(g);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 56dcecf7a7..92c5a2b0a7 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -17,27 +17,54 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
 import com.graphhopper.storage.Graph;
 
 /**
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class AStarTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { TraversalMode.NODE_BASED },
+            { TraversalMode.EDGE_BASED_1DIR },
+            { TraversalMode.EDGE_BASED_2DIR },
+            { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public AStarTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph g, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new AStar(_graph, encoder, w);
+                return new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(g);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 06a260057c..5b09bd3268 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -18,18 +18,15 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import java.util.Random;
 import static org.junit.Assert.*;
+import org.junit.Before;
 import org.junit.Test;
 
 /**
@@ -40,48 +37,83 @@
 {
     // problem is: matrix graph is expensive to create to cache it in a static variable
     private static Graph matrixGraph;
-    protected static EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
-    protected CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-    protected FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+    protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
+    protected FlagEncoder carEncoder;
+    protected FlagEncoder footEncoder;
+    protected AlgorithmOptions defaultOpts;
 
-    protected Graph createGraph()
+    @Before
+    public void setUp()
     {
-        return new GraphBuilder(encodingManager).create();
+        carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
+        footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+        defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new ShortestWeighting()).build();
     }
 
-    public AlgorithmPreparation prepareGraph( Graph g )
+    protected Graph createGraph( EncodingManager em, boolean is3D )
     {
-        return prepareGraph(g, carEncoder, new ShortestWeighting());
+        return new GraphBuilder(em).set3D(is3D).create();
     }
 
-    public abstract AlgorithmPreparation prepareGraph( Graph g, FlagEncoder encoder, Weighting w );
+    protected Graph createGraph( boolean is3D )
+    {
+        return createGraph(encodingManager, is3D);
+    }
+
+    public RoutingAlgorithm createAlgo( Graph g )
+    {
+        return createAlgo(g, defaultOpts);
+    }
+
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {
+        return createFactory(g, opts).createAlgo(g, opts);
+    }
+
+    public abstract RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts );
 
     @Test
     public void testCalcShortestPath()
     {
         Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 7);
-        assertEquals(p.toString(), 13, p.getDistance(), 1e-4);
-        assertEquals(p.toString(), 5, p.calcNodes().size());
+        RoutingAlgorithm algo = createAlgo(graph);
+        Path p = algo.calcPath(0, 7);
+        assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
+        assertEquals(p.toString(), 62.1, p.getDistance(), .1);
+    }
+
+    @Test
+    public void testCalcShortestPathWithLimit()
+    {
+        Graph graph = createTestGraph();
+        RoutingAlgorithm algo = createAlgo(graph);
+        algo.setWeightLimit(10);
+        Path p = algo.calcPath(0, 7);
+        assertTrue(algo.getVisitedNodes() < 7);
+        assertFalse(p.isFound());
+        assertEquals(p.toString(), Helper.createTList(), p.calcNodes());
     }
 
     // see calc-fastest-graph.svg
     @Test
     public void testCalcFastestPath()
     {
-        Graph graphShortest = createGraph();
-        initDirectedAndDiffSpeed(graphShortest);
-        Path p1 = prepareGraph(graphShortest, carEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 3);
+        Graph graphShortest = createGraph(false);
+        initDirectedAndDiffSpeed(graphShortest, carEncoder);
+        Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
-        assertEquals(p1.toString(), 24000, p1.getDistance(), 1e-6);
-        assertEquals(p1.toString(), 8640 * 1000, p1.getMillis());
-
-        Graph graphFastest = createGraph();
-        initDirectedAndDiffSpeed(graphFastest);
-        Path p2 = prepareGraph(graphFastest, carEncoder, new FastestWeighting(carEncoder)).createAlgo().calcPath(0, 3);
+        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 144823, p1.getMillis());
+
+        Graph graphFastest = createGraph(false);
+        initDirectedAndDiffSpeed(graphFastest, carEncoder);
+        Path p2 = createAlgo(graphFastest,
+                AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
+                calcPath(0, 3);
         assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
-        assertEquals(p2.toString(), 31000, p2.getDistance(), 1e-6);
-        assertEquals(p2.toString(), 5580 * 1000, p2.getMillis());
+        assertEquals(p2.toString(), 1261.714, p2.getDistance(), 1e-6);
+        assertEquals(p2.toString(), 111437, p2.getMillis());
     }
 
     // 0-1-2-3
@@ -89,42 +121,56 @@ public void testCalcFastestPath()
     // 4-5-- |
     // |/ \--7
     // 6----/
-    void initDirectedAndDiffSpeed( Graph graph )
+    protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
     {
-        graph.edge(0, 1).setDistance(7000).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(0, 4).setDistance(5000).setFlags(carEncoder.setProperties(20, true, false));
+        graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
+        graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(1, 4).setDistance(7000).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setDistance(7000).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 2).setDistance(20000).setFlags(carEncoder.setProperties(10, true, true));
+        graph.edge(1, 4).setFlags(enc.setProperties(10, true, true));
+        graph.edge(1, 5).setFlags(enc.setProperties(10, true, true));
+        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(enc.setProperties(10, true, true));
 
-        graph.edge(5, 2).setDistance(5000).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(2, 3).setDistance(5000).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(5, 2).setFlags(enc.setProperties(10, true, false));
+        graph.edge(2, 3).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(5, 3).setDistance(11000).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(3, 7).setDistance(7000).setFlags(carEncoder.setProperties(10, true, false));
+        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(enc.setProperties(20, true, false));
+        graph.edge(3, 7).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(4, 6).setDistance(5000).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(5, 4).setDistance(7000).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(4, 6).setFlags(enc.setProperties(100, true, false));
+        graph.edge(5, 4).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(5, 6).setDistance(7000).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(7, 5).setDistance(5000).setFlags(carEncoder.setProperties(20, true, false));
+        graph.edge(5, 6).setFlags(enc.setProperties(10, true, false));
+        graph.edge(7, 5).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(6, 7).setDistance(5000).setFlags(carEncoder.setProperties(20, true, true));
+        graph.edge(6, 7).setFlags(enc.setProperties(100, true, true));
+
+        updateDistancesFor(graph, 0, 0.002, 0);
+        updateDistancesFor(graph, 1, 0.002, 0.001);
+        updateDistancesFor(graph, 2, 0.002, 0.002);
+        updateDistancesFor(graph, 3, 0.002, 0.003);
+        updateDistancesFor(graph, 4, 0.0015, 0);
+        updateDistancesFor(graph, 5, 0.0015, 0.001);
+        updateDistancesFor(graph, 6, 0, 0);
+        updateDistancesFor(graph, 7, 0.001, 0.003);
+
+        edge12.setDistance(edge12.getDistance() * 2);
+        edge53.setDistance(edge53.getDistance() * 2);
     }
 
     @Test
     public void testCalcFootPath()
     {
-        Graph graphShortest = createGraph();
+        Graph graphShortest = createGraph(false);
         initFootVsCar(graphShortest);
-        Path p1 = prepareGraph(graphShortest, footEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 7);
+        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new ShortestWeighting()).build()).
+                calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 12240 * 1000, p1.getMillis());
         assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
     }
 
-    void initFootVsCar( Graph graph )
+    protected void initFootVsCar( Graph graph )
     {
         graph.edge(0, 1).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
         graph.edge(0, 4).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
@@ -151,7 +197,7 @@ void initFootVsCar( Graph graph )
     // see test-graph.svg !
     protected Graph createTestGraph()
     {
-        Graph graph = createGraph();
+        Graph graph = createGraph(false);
 
         graph.edge(0, 1, 7, true);
         graph.edge(0, 4, 6, true);
@@ -172,24 +218,26 @@ protected Graph createTestGraph()
         graph.edge(5, 6, 2, true);
         graph.edge(5, 7, 1, true);
 
-        graph.edge(6, 7, 5, true);
-        return graph;
-    }
+        EdgeIteratorState edge6_7 = graph.edge(6, 7, 5, true);
 
-    @Test
-    public void testCalcIfEmptyWay()
-    {
-        Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 0);
-        assertEquals(p.toString(), 0, p.calcNodes().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        updateDistancesFor(graph, 0, 0.0010, 0.00001);
+        updateDistancesFor(graph, 1, 0.0008, 0.0000);
+        updateDistancesFor(graph, 2, 0.0005, 0.0001);
+        updateDistancesFor(graph, 3, 0.0006, 0.0002);
+        updateDistancesFor(graph, 4, 0.0009, 0.0001);
+        updateDistancesFor(graph, 5, 0.0007, 0.0001);
+        updateDistancesFor(graph, 6, 0.0009, 0.0002);
+        updateDistancesFor(graph, 7, 0.0008, 0.0003);
+
+        edge6_7.setDistance(5 * edge6_7.getDistance());
+        return graph;
     }
 
     @Test
     public void testNoPathFound()
     {
-        Graph graph = createGraph();
-        assertFalse(prepareGraph(graph).createAlgo().calcPath(0, 1).isFound());
+        Graph graph = createGraph(false);
+        assertFalse(createAlgo(graph).calcPath(0, 1).isFound());
 
         // two disconnected areas
         graph.edge(0, 1, 7, true);
@@ -198,23 +246,22 @@ public void testNoPathFound()
         graph.edge(5, 7, 1, true);
         graph.edge(5, 8, 1, true);
         graph.edge(7, 8, 1, true);
-        RoutingAlgorithm algo = prepareGraph(graph).createAlgo();
+        RoutingAlgorithm algo = createAlgo(graph);
         assertFalse(algo.calcPath(0, 5).isFound());
-        // assertEquals(4, algo.getVisitedNodes());
+        // assertEquals(3, algo.getVisitedNodes());
 
         // disconnected as directed graph
-        graph = createGraph();
+        graph = createGraph(false);
         graph.edge(0, 1, 1, false);
         graph.edge(0, 2, 1, true);
-        algo = prepareGraph(graph).createAlgo();
-        assertFalse(algo.calcPath(1, 2).isFound());
+        assertFalse(createAlgo(graph).calcPath(1, 2).isFound());
     }
 
     @Test
     public void testWikipediaShortestPath()
     {
         Graph graph = createWikipediaTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 4, p.calcNodes().size());
     }
@@ -223,15 +270,15 @@ public void testWikipediaShortestPath()
     public void testCalcIf1EdgeAway()
     {
         Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(1, 2);
+        Path p = createAlgo(graph).calcPath(1, 2);
         assertEquals(Helper.createTList(1, 2), p.calcNodes());
-        assertEquals(p.toString(), 2, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 35.1, p.getDistance(), .1);
     }
 
     // see wikipedia-graph.svg !
     protected Graph createWikipediaTestGraph()
     {
-        Graph graph = createGraph();
+        Graph graph = createGraph(false);
         graph.edge(0, 1, 7, true);
         graph.edge(0, 2, 9, true);
         graph.edge(0, 5, 14, true);
@@ -249,7 +296,7 @@ protected Graph createWikipediaTestGraph()
     // |    8  |
     // \   /   |
     //  7-6----5
-    public static void initBiGraph( Graph graph )
+    public static Graph initBiGraph( Graph graph )
     {
         // distance will be overwritten in second step as we need to calculate it from lat,lon
         graph.edge(0, 1, 1, true);
@@ -276,36 +323,39 @@ public static void initBiGraph( Graph graph )
         updateDistancesFor(graph, 7, 0, 0);
         updateDistancesFor(graph, 6, 0, 0.001);
         updateDistancesFor(graph, 5, 0, 0.004);
+        return graph;
     }
 
     private static final DistanceCalc distCalc = new DistanceCalcEarth();
 
-    private static void updateDistancesFor( Graph g, int node, double lat, double lon )
+    public static void updateDistancesFor( Graph g, int node, double lat, double lon )
     {
-        g.setNode(node, lat, lon);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(node, lat, lon);
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
         while (iter.next())
         {
             int adj = iter.getAdjNode();
-            double adjLat = g.getLatitude(adj);
-            double adjLon = g.getLongitude(adj);
+            double adjLat = na.getLatitude(adj);
+            double adjLon = na.getLongitude(adj);
             iter.setDistance(distCalc.calcDist(lat, lon, adjLat, adjLon));
+            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
         }
     }
 
     @Test
     public void testBidirectional()
     {
-        Graph graph = createGraph();
+        Graph graph = createGraph(false);
         initBiGraph(graph);
 
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
         assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
         assertEquals(p.toString(), 335.77, p.getDistance(), 1e-2);
 
-        p = prepareGraph(graph).createAlgo().calcPath(1, 2);
+        p = createAlgo(graph).calcPath(1, 2);
         // the other way around is even larger as 0-1 is already 11008.452
         assertEquals(p.toString(), Helper.createTList(1, 2), p.calcNodes());
         assertEquals(p.toString(), 10007.679, p.getDistance(), 1e-4);
@@ -319,7 +369,7 @@ public void testBidirectional()
     @Test
     public void testBidirectional2()
     {
-        Graph graph = createGraph();
+        Graph graph = createGraph(false);
 
         graph.edge(0, 1, 100, true);
         graph.edge(1, 2, 1, true);
@@ -332,7 +382,7 @@ public void testBidirectional2()
         graph.edge(3, 8, 20, true);
         graph.edge(8, 6, 20, true);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 40, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 5, p.calcNodes().size());
         assertEquals(Helper.createTList(0, 7, 6, 5, 4), p.calcNodes());
@@ -341,8 +391,8 @@ public void testBidirectional2()
     @Test
     public void testRekeyBugOfIntBinHeap()
     {
-        // using DijkstraSimple + IntBinHeap then rekey loops endlessly
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(36, 91);
+        // using Dijkstra + IntBinHeap then rekey loops endlessly
+        Path p = createAlgo(getMatrixGraph()).calcPath(36, 91);
         assertEquals(12, p.calcNodes().size());
 
         TIntList list = p.calcNodes();
@@ -357,7 +407,7 @@ public void testRekeyBugOfIntBinHeap()
     @Test
     public void testBug1()
     {
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(34, 36);
+        Path p = createAlgo(getMatrixGraph()).calcPath(34, 36);
         assertEquals(Helper.createTList(34, 35, 36), p.calcNodes());
         assertEquals(3, p.calcNodes().size());
         assertEquals(17, p.getDistance(), 1e-5);
@@ -366,7 +416,7 @@ public void testBug1()
     @Test
     public void testCorrectWeight()
     {
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(45, 72);
+        Path p = createAlgo(getMatrixGraph()).calcPath(45, 72);
         assertEquals(Helper.createTList(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
         assertEquals(38f, p.getDistance(), 1e-3);
     }
@@ -374,18 +424,18 @@ public void testCorrectWeight()
     @Test
     public void testCannotCalculateSP()
     {
-        Graph graph = createGraph();
+        Graph graph = createGraph(false);
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 2);
+        Path p = createAlgo(graph).calcPath(0, 2);
         assertEquals(p.toString(), 3, p.calcNodes().size());
     }
 
     @Test
     public void testDirectedGraphBug1()
     {
-        Graph graph = createGraph();
+        Graph graph = createGraph(false);
         graph.edge(0, 1, 3, false);
         graph.edge(1, 2, 2.99, false);
 
@@ -393,7 +443,7 @@ public void testDirectedGraphBug1()
         graph.edge(3, 4, 3, false);
         graph.edge(4, 2, 1, false);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 2);
+        Path p = createAlgo(graph).calcPath(0, 2);
         assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
         assertEquals(p.toString(), 5.99, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 3, p.calcNodes().size());
@@ -402,14 +452,14 @@ public void testDirectedGraphBug1()
     @Test
     public void testDirectedGraphBug2()
     {
-        Graph graph = createGraph();
+        Graph graph = createGraph(false);
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
         graph.edge(2, 3, 1, false);
 
         graph.edge(3, 1, 4, true);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 3);
+        Path p = createAlgo(graph).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 2, 3), p.calcNodes());
     }
 
@@ -420,12 +470,13 @@ public void testDirectedGraphBug2()
     @Test
     public void testWithCoordinates()
     {
-        Graph graph = createGraph();
-        graph.setNode(0, 0, 2);
-        graph.setNode(1, 0, 3.5);
-        graph.setNode(2, 1, 1);
-        graph.setNode(3, 1.5, 2.5);
-        graph.setNode(4, 0.5, 4.5);
+        Graph graph = createGraph(false);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0, 2);
+        na.setNode(1, 0, 3.5);
+        na.setNode(2, 1, 1);
+        na.setNode(3, 1.5, 2.5);
+        na.setNode(4, 0.5, 4.5);
 
         graph.edge(0, 1, 2, true).setWayGeometry(Helper.createPointList(0, 3));
         graph.edge(2, 3, 2, true);
@@ -436,45 +487,69 @@ public void testWithCoordinates()
         graph.edge(1, 3, 1.3, true);
         graph.edge(1, 4, 1, true);
 
-        AlgorithmPreparation prepare = prepareGraph(graph);
-        Path p = prepare.createAlgo().calcPath(4, 0);
+        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, new ShortestWeighting());
+        RoutingAlgorithmFactory prepare = createFactory(graph, opts);
+        Path p = prepare.createAlgo(graph, opts).calcPath(4, 0);
         assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
         assertEquals(Helper.createPointList(0.5, 4.5, 0, 3.5, 0, 3, 0, 2), p.calcPoints());
         assertEquals(291110, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
 
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        p = prepare.createAlgo().calcPath(2, 1);
+        p = prepare.createAlgo(graph, opts).calcPath(2, 1);
         // System.out.println(p.toDetailsString());
         assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
         assertEquals(Helper.createPointList(1, 1, 1, 0, 0, 0, 0, 1.6, 0, 2, 0, 3, 0, 3.5), p.calcPoints());
         assertEquals(611555, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
     }
 
+    @Test
+    public void testCalcIfEmptyWay()
+    {
+        Graph graph = createTestGraph();
+        Path p = createAlgo(graph).calcPath(0, 0);
+        assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+    }
+
+    @Test
+    public void testViaEdges_FromEqualsTo()
+    {
+        Graph graph = createTestGraph();
+        // identical tower nodes
+        Path p = calcPathViaQuery(graph, 0.001, 0.000, 0.001, 0.000);
+        assertTrue(p.isFound());
+        assertEquals(Helper.createTList(0), p.calcNodes());
+        // assertEquals(1, p.calcPoints().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+        // identical query points on edge
+        p = calcPath(graph, 0, 1, 0, 1);
+        assertTrue(p.isFound());
+        assertEquals(Helper.createTList(8), p.calcNodes());
+        // assertEquals(1, p.calcPoints().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+        // very close
+        p = calcPathViaQuery(graph, 0.00092, 0, 0.00091, 0);
+        assertEquals(Helper.createTList(8, 9), p.calcNodes());
+        assertEquals(p.toString(), 1.11, p.getDistance(), .1);
+    }
+
     @Test
     public void testViaEdges_BiGraph()
     {
-        Graph graph = createGraph();
+        Graph graph = createGraph(false);
         initBiGraph(graph);
 
-        // 0-7 to 4-3
+        // 0-7 to 4-3        
         Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
         assertEquals(p.toString(), Helper.createTList(10, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 324.11, p.getDistance(), 1e-2);
+        assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
 
         // 0-1 to 2-3
         p = calcPathViaQuery(graph, 0.001, 0.0001, 0.010, 0.0011);
-        assertEquals(p.toString(), Helper.createTList(10, 0, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 1335.42, p.getDistance(), .2);
-    }
-
-    @Test
-    public void testViaEdges_FromEqualsTo()
-    {
-        Graph graph = createTestGraph();
-        Path p = calcPath(graph, 0, 1, 0, 1);
-        // or one node would be acceptable
-        assertEquals(Helper.createTList(8, 9), p.calcNodes());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 9), p.calcNodes());
+        assertEquals(p.toString(), 1335.35, p.getDistance(), 0.01);
     }
 
     @Test
@@ -483,13 +558,13 @@ public void testViaEdges_WithCoordinates()
         Graph graph = createTestGraph();
         Path p = calcPath(graph, 0, 1, 2, 3);
         assertEquals(Helper.createTList(9, 1, 2, 8), p.calcNodes());
-        assertEquals(p.toString(), 2, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 56.7, p.getDistance(), .1);
     }
 
     @Test
     public void testViaEdges_SpecialCases()
     {
-        Graph graph = createGraph();
+        Graph graph = createGraph(false);
         // 0->1\
         // |    2
         // 4<-3/
@@ -511,9 +586,9 @@ public void testViaEdges_SpecialCases()
         assertEquals(p.toString(), 26.81, p.getDistance(), .1);
 
         // overlapping edges: 2-3 and 3-2
-        p = calcPathViaQuery(graph, 0.000049, 0.00015, 0.00001, 0.0001);
+        p = calcPathViaQuery(graph, 0.000049, 0.00014, 0.00001, 0.0001);
         assertEquals(Helper.createTList(5, 6), p.calcNodes());
-        assertEquals(p.toString(), 7, p.getDistance(), .1);
+        assertEquals(p.toString(), 6.2, p.getDistance(), .1);
 
         // 'from' and 'to' edge share one node '2': 1-2 to 3-2
         p = calcPathViaQuery(graph, 0.00009, 0.00011, 0.00001, 0.00011);
@@ -521,19 +596,38 @@ public void testViaEdges_SpecialCases()
         assertEquals(p.toString(), 12.57, p.getDistance(), .1);
     }
 
+    @Test
+    public void testQueryGraphAndFastest()
+    {
+        Graph graph = createGraph(false);
+        initDirectedAndDiffSpeed(graph, carEncoder);
+        Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
+        assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
+        assertEquals(602.98, p.getDistance(), 1e-1);
+    }
+
     // Problem: for contraction hierarchy we cannot easily select egdes by nodes as some edges are skipped
     Path calcPathViaQuery( Graph graph, double fromLat, double fromLon, double toLat, double toLon )
     {
-        LocationIndex index;
-        if (graph instanceof LevelGraph)
-            index = new LocationIndexTreeSC((LevelGraph) graph, new RAMDirectory());
-        else
-            index = new LocationIndexTree(graph, new RAMDirectory());
+        return calcPathViaQuery("shortest", graph, fromLat, fromLon, toLat, toLon);
+    }
 
+    Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fromLon, double toLat, double toLon )
+    {
+        LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory());
         index.prepareIndex();
         QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
         QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
-        return prepareGraph(graph).createAlgo().calcPath(from, to);
+        Weighting w = new ShortestWeighting();
+        if (weighting.equalsIgnoreCase("fastest"))
+            w = new FastestWeighting(carEncoder);
+
+        // correct order for CH: in factory do prepare and afterwards wrap in query graph
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(w).build();
+        RoutingAlgorithmFactory factory = createFactory(graph, opts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        return factory.createAlgo(qGraph, opts).
+                calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
     Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNode2 )
@@ -541,7 +635,10 @@ Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNod
         // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2        
         QueryResult from = newQR(graph, fromNode1, fromNode2);
         QueryResult to = newQR(graph, toNode1, toNode2);
-        return prepareGraph(graph).createAlgo().calcPath(from, to);
+
+        RoutingAlgorithmFactory factory = createFactory(graph, defaultOpts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        return factory.createAlgo(qGraph, defaultOpts).calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
     /**
@@ -553,10 +650,11 @@ QueryResult newQR( Graph graph, int node1, int node2 )
         if (edge == null)
             throw new IllegalStateException("edge not found? " + node1 + "-" + node2);
 
-        double lat = graph.getLatitude(edge.getBaseNode());
-        double lon = graph.getLongitude(edge.getBaseNode());
-        double latAdj = graph.getLatitude(edge.getAdjNode());
-        double lonAdj = graph.getLongitude(edge.getAdjNode());
+        NodeAccess na = graph.getNodeAccess();
+        double lat = na.getLatitude(edge.getBaseNode());
+        double lon = na.getLongitude(edge.getBaseNode());
+        double latAdj = na.getLatitude(edge.getAdjNode());
+        double lonAdj = na.getLongitude(edge.getAdjNode());
         // calculate query point near the base node but not directly on it!
         QueryResult res = new QueryResult(lat + (latAdj - lat) * .1, lon + (lonAdj - lon) * .1);
         res.setClosestNode(edge.getBaseNode());
@@ -567,6 +665,140 @@ QueryResult newQR( Graph graph, int node1, int node2 )
         return res;
     }
 
+    @Test
+    public void testTwoWeightsPerEdge()
+    {
+        FlagEncoder encoder = new Bike2WeightFlagEncoder();
+        Graph graph = initEleGraph(createGraph(new EncodingManager(encoder), true));
+        // force the other path
+        GHUtility.getEdge(graph, 0, 3).setFlags(encoder.setProperties(10, false, true));
+
+        // for two weights per edge it happened that Path (and also the Weighting) read the wrong side 
+        // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
+        Path p = createAlgo(graph, AlgorithmOptions.start().flagEncoder(encoder).weighting(new FastestWeighting(encoder)).build()).calcPath(0, 10);
+//        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
+        assertEquals(85124371, p.getMillis());
+        assertEquals(425622, p.getDistance(), 1);
+        assertEquals(85124.4, p.getWeight(), 1);
+    }
+
+    @Test
+    public void test0SpeedButUnblocked_Issue242()
+    {
+        Graph graph = createGraph(false);
+        long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
+
+        graph.edge(0, 1).setFlags(flags).setDistance(10);
+        graph.edge(1, 2).setFlags(flags).setDistance(10);
+
+        RoutingAlgorithm algo = createAlgo(graph);
+        try
+        {
+            Path p = algo.calcPath(0, 2);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Speed cannot be 0"));
+        }
+    }
+
+    @Test
+    public void testTwoWeightsPerEdge2()
+    {
+        // other direction should be different!
+        Graph graph = initEleGraph(createGraph(true));
+        Path p = createAlgo(graph).calcPath(0, 10);
+        // GHUtility.printEdgeInfo(graph, carEncoder);
+        assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
+        Weighting fakeWeighting = new Weighting()
+        {
+            @Override
+            public double getMinWeight( double distance )
+            {
+                return distance;
+            }
+
+            @Override
+            public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+            {
+                int adj = edgeState.getAdjNode();
+                int base = edgeState.getBaseNode();
+                if (reverse)
+                {
+                    int tmp = base;
+                    base = adj;
+                    adj = tmp;
+                }
+
+                // a 'hill' at node 6
+                if (adj == 6)
+                    return 3 * edgeState.getDistance();
+                else if (base == 6)
+                    return edgeState.getDistance() * 0.9;
+                else if (adj == 4)
+                    return 2 * edgeState.getDistance();
+
+                return edgeState.getDistance() * 0.8;
+            }
+        };
+
+        graph = initEleGraph(createGraph(true));
+        QueryResult from = newQR(graph, 3, 0);
+        QueryResult to = newQR(graph, 10, 9);
+
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(fakeWeighting).build();
+        RoutingAlgorithmFactory factory = createFactory(graph, opts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        p = factory.createAlgo(qGraph, opts).calcPath(from.getClosestNode(), to.getClosestNode());
+        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
+        assertEquals(37009621, p.getMillis());
+        assertEquals(616827, p.getDistance(), 1);
+        assertEquals(493462, p.getWeight(), 1);
+    }
+
+    // 0-1-2
+    // |\| |
+    // 3 4-11
+    // | | |
+    // 5-6-7
+    // | |\|
+    // 8-9-10
+    Graph initEleGraph( Graph g )
+    {
+        g.edge(0, 1, 10, true);
+        g.edge(0, 4, 12, true);
+        g.edge(0, 3, 5, true);
+        g.edge(1, 2, 10, true);
+        g.edge(1, 4, 5, true);
+        g.edge(3, 5, 5, false);
+        g.edge(5, 6, 10, true);
+        g.edge(5, 8, 10, true);
+        g.edge(6, 4, 5, true);
+        g.edge(6, 7, 10, true);
+        g.edge(6, 10, 12, true);
+        g.edge(6, 9, 12, true);
+        g.edge(2, 11, 5, false);
+        g.edge(4, 11, 10, true);
+        g.edge(7, 11, 5, true);
+        g.edge(7, 10, 5, true);
+        g.edge(8, 9, 10, false);
+        g.edge(9, 8, 9, false);
+        g.edge(10, 9, 10, false);
+        updateDistancesFor(g, 0, 3, 0);
+        updateDistancesFor(g, 3, 2.5, 0);
+        updateDistancesFor(g, 5, 1, 0);
+        updateDistancesFor(g, 8, 0, 0);
+        updateDistancesFor(g, 1, 3, 1);
+        updateDistancesFor(g, 4, 2, 1);
+        updateDistancesFor(g, 6, 1, 1);
+        updateDistancesFor(g, 9, 0, 1);
+        updateDistancesFor(g, 2, 3, 2);
+        updateDistancesFor(g, 11, 2, 2);
+        updateDistancesFor(g, 7, 1, 2);
+        updateDistancesFor(g, 10, 0, 2);
+        return g;
+    }
+
     public Graph getMatrixGraph()
     {
         return getMatrixAlikeGraph();
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index 21acdad1e4..0f67d59627 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -18,24 +18,54 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
 import com.graphhopper.storage.Graph;
 
 /**
  *
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class DijkstraBidirectionRefTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { TraversalMode.NODE_BASED },
+            { TraversalMode.EDGE_BASED_1DIR },
+            { TraversalMode.EDGE_BASED_2DIR },
+            { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public DijkstraBidirectionRefTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new DijkstraBidirectionRef(_graph, encoder, w);
+                return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };    
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 3388245ef5..3f156783dc 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -17,72 +17,138 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+import java.util.Arrays;
+import java.util.Collection;
 import static org.junit.Assert.*;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /**
  *
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class DijkstraOneToManyTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            {
+                TraversalMode.NODE_BASED
+            },
+//            TODO { TraversalMode.EDGE_BASED_1DIR },
+//            TODO { TraversalMode.EDGE_BASED_2DIR },
+//            TODO { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public DijkstraOneToManyTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new DijkstraOneToMany(_graph, encoder, w);
+                return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };
     }
 
     @Override
     public void testViaEdges_BiGraph()
     {
-        // not supported
+        // calcPath with QueryResult not supported
     }
 
     @Override
     public void testViaEdges_SpecialCases()
     {
-        // not supported
+        // calcPath with QueryResult not supported
     }
 
     @Override
     public void testViaEdges_FromEqualsTo()
     {
-        // not supported
+        // calcPath with QueryResult not supported
     }
 
     @Override
     public void testViaEdges_WithCoordinates()
     {
-        // not supported
+        // calcPath with QueryResult not supported
+    }
+
+    @Override
+    public void testQueryGraphAndFastest()
+    {
+        // calcPath with QueryResult not supported
+    }
+
+    @Override
+    public void testTwoWeightsPerEdge2()
+    {
+        // calcPath with QueryResult not supported
+    }
+
+    @Test
+    public void testIssue182()
+    {
+        RoutingAlgorithm algo = createAlgo(initGraph(createGraph(false)));
+        Path p = algo.calcPath(0, 8);
+        assertEquals(Helper.createTList(0, 7, 8), p.calcNodes());
+
+        // expand SPT
+        p = algo.calcPath(0, 10);
+        assertEquals(Helper.createTList(0, 1, 2, 3, 4, 10), p.calcNodes());
+    }
+
+    @Test
+    public void testIssue239()
+    {
+        Graph g = createGraph(false);
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        g.edge(2, 0, 1, true);
+
+        g.edge(4, 5, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(6, 4, 1, true);
+
+        DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
+        assertEquals(-1, algo.findEndNode(0, 4));
+        assertEquals(-1, algo.findEndNode(0, 4));
     }
 
     @Test
     public void testUseCache()
     {
-        AlgorithmPreparation prep = prepareGraph(createTestGraph());
-        RoutingAlgorithm algo = prep.createAlgo();
+        RoutingAlgorithm algo = createAlgo(createTestGraph());
         Path p = algo.calcPath(0, 4);
         assertEquals(Helper.createTList(0, 4), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 7);
-        assertEquals(Helper.createTList(0, 4, 6, 5, 7), p.calcNodes());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p.calcNodes());
 
         // use SPT
         p = algo.calcPath(0, 2);
@@ -99,8 +165,7 @@ public void testDifferentEdgeFilter()
         g.edge(4, 5, 10, true);
         g.edge(5, 6, 10, true);
 
-        AlgorithmPreparation prep = prepareGraph(g);
-        DijkstraOneToMany algo = (DijkstraOneToMany) prep.createAlgo();
+        DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
         algo.setEdgeFilter(new EdgeFilter()
         {
             @Override
@@ -125,4 +190,22 @@ public boolean accept( EdgeIteratorState iter )
         p = algo.calcPath(4, 6);
         assertEquals(Helper.createTList(4, 5, 6), p.calcNodes());
     }
+
+    private Graph initGraph( Graph g )
+    {
+        // 0-1-2-3-4
+        // |       /
+        // 7-10----
+        // \-8
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(4, 10, 1, true);
+
+        g.edge(0, 7, 1, true);
+        g.edge(7, 8, 1, true);
+        g.edge(7, 10, 10, true);
+        return g;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index c0aca220a0..fb8c479901 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -17,28 +17,55 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
 import com.graphhopper.storage.Graph;
 
 /**
  *
  * @author Peter Karich
  */
+@RunWith(Parameterized.class)
 public class DijkstraTest extends AbstractRoutingAlgorithmTester
 {
+    /**
+     * Runs the same test with each of the supported traversal modes
+     */
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { TraversalMode.NODE_BASED },
+            { TraversalMode.EDGE_BASED_1DIR },
+            { TraversalMode.EDGE_BASED_2DIR },
+            { TraversalMode.EDGE_BASED_2DIR_UTURN }
+        });
+    }
+
+    private final TraversalMode traversalMode;
+
+    public DijkstraTest( TraversalMode tMode )
+    {
+        this.traversalMode = tMode;
+    }
+
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting weighting )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new Dijkstra(_graph, encoder, weighting);
+                return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
new file mode 100644
index 0000000000..1bbc864885
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -0,0 +1,232 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+import static org.junit.Assert.*;
+import static com.graphhopper.util.GHUtility.*;
+import java.util.Arrays;
+import java.util.Collection;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/**
+ * @author Peter Karich
+ */
+@RunWith(Parameterized.class)
+public class EdgeBasedRoutingAlgorithmTest
+{
+    private FlagEncoder carEncoder;
+
+    EncodingManager createEncodingManager( boolean restrictedOnly )
+    {
+        if (restrictedOnly)
+            carEncoder = new CarFlagEncoder(5, 5, 1);
+        else
+            // allow for basic costs too
+            carEncoder = new CarFlagEncoder(5, 5, 3);
+        return new EncodingManager(carEncoder);
+    }
+
+    @Parameters(name = "{0}")
+    public static Collection<Object[]> configs()
+    {
+        return Arrays.asList(new Object[][]
+        {
+            { AlgorithmOptions.DIJKSTRA },
+            { AlgorithmOptions.DIJKSTRA_BI },
+            { AlgorithmOptions.ASTAR },
+            { AlgorithmOptions.ASTAR_BI }
+        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
+        });
+    }
+
+    private final String algoStr;
+
+    public EdgeBasedRoutingAlgorithmTest( String algo )
+    {
+        this.algoStr = algo;
+    }
+
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {
+        opts = AlgorithmOptions.start(opts).algorithm(algoStr).build();
+        return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
+    }
+
+    protected GraphStorage createGraph( EncodingManager em )
+    {
+        return new GraphBuilder(em).create();
+    }
+
+    // 0---1
+    // |   /
+    // 2--3--4
+    // |  |  |
+    // 5--6--7
+    public static void initGraph( Graph g )
+    {
+        g.edge(0, 1, 3, true);
+        g.edge(0, 2, 1, true);
+        g.edge(1, 3, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(2, 5, .5, true);
+        g.edge(3, 6, 1, true);
+        g.edge(4, 7, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(6, 7, 1, true);
+    }
+
+    private void initTurnRestrictions( Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder )
+    {
+        long tflags = tEncoder.getTurnFlags(true, 0);
+
+        // only forward from 2-3 to 3-4 => limit 2,3->3,6 and 2,3->3,1
+        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
+
+        // only right   from 5-2 to 2-3 => limit 5,2->2,0
+        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 0).getEdge(), tflags);
+
+        // only right   from 7-6 to 6-3 => limit 7,6->6,5
+        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
+
+        // no 5-6 to 6-3
+        tcs.addTurnInfo(getEdge(g, 5, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
+        // no 4-3 to 3-1
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
+        // no 4-3 to 3-2
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), tflags);
+
+        // no u-turn at 6-7
+        tcs.addTurnInfo(getEdge(g, 6, 7).getEdge(), 7, getEdge(g, 7, 6).getEdge(), tflags);
+
+        // no u-turn at 3-6
+        tcs.addTurnInfo(getEdge(g, 3, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
+    }
+
+    Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs, double turnCosts )
+    {
+        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs).setDefaultUTurnCost(turnCosts);
+    }
+
+    @Test
+    public void testBasicTurnRestriction()
+    {
+        GraphStorage g = createGraph(createEncodingManager(true));
+        initGraph(g);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        initTurnRestrictions(g, tcs, carEncoder);
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
+                calcPath(5, 1);
+        assertEquals(Helper.createTList(5, 2, 3, 4, 7, 6, 3, 1), p.calcNodes());
+
+        // test 7-6-5 and reverse
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 7);
+        assertEquals(Helper.createTList(5, 6, 7), p.calcNodes());
+
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(7, 5);
+        assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
+    }
+
+    @Test
+    public void testUTurns()
+    {
+        GraphStorage g = createGraph(createEncodingManager(true));
+        initGraph(g);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+
+        long tflags = carEncoder.getTurnFlags(true, 0);
+
+        // force u-turn via lowering the cost for it
+        EdgeIteratorState e3_6 = getEdge(g, 3, 6);
+        e3_6.setDistance(0.1);
+        getEdge(g, 3, 2).setDistance(864);
+        getEdge(g, 1, 0).setDistance(864);
+
+        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, e3_6.getEdge(), tflags);
+        AlgorithmOptions opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 50)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        Path p = createAlgo(g, opts).calcPath(7, 5);        
+
+        assertEquals(Helper.createTList(7, 6, 3, 6, 5), p.calcNodes());
+
+        // no u-turn for 6-3
+        opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 100)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
+        p = createAlgo(g, opts).calcPath(7, 5);
+
+        assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
+    }
+
+    @Test
+    public void testBasicTurnCosts()
+    {
+        GraphStorage g = createGraph(createEncodingManager(false));
+        initGraph(g);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 1);
+
+        // no restriction and costs
+        EdgeIteratorState e3_6 = getEdge(g, 5, 6);
+        e3_6.setDistance(2);
+        assertEquals(Helper.createTList(5, 2, 3, 1), p.calcNodes());
+
+        // now introduce some turn costs
+        long tflags = carEncoder.getTurnFlags(false, 2);
+        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
+
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 1);
+        assertEquals(Helper.createTList(5, 6, 3, 1), p.calcNodes());
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java b/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
deleted file mode 100644
index b9585052f8..0000000000
--- a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing;
-
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.*;
-import com.graphhopper.util.TranslationMap.Translation;
-import gnu.trove.list.TDoubleList;
-import gnu.trove.list.TLongList;
-
-import java.io.File;
-import java.util.List;
-import java.util.Locale;
-import org.junit.Test;
-import static org.junit.Assert.*;
-
-/**
- * @author Peter Karich
- */
-public class GraphHopperIT
-{
-    TranslationMap trMap = TranslationMapTest.SINGLETON;
-
-    @Test
-    public void testMonacoWithInstructions()
-    {
-        String osmFile = "files/monaco.osm.gz";
-        String graphFile = "target/graph-monaco";
-        String vehicle = "FOOT";
-        String importVehicles = "FOOT";
-        String weightCalcStr = "shortest";
-
-        try
-        {
-            // make sure we are using fresh graphhopper files with correct vehicle
-            Helper.removeDir(new File(graphFile));
-            GraphHopper hopper = new GraphHopper().setInMemory(true, true).setOSMFile(osmFile).
-                    disableCHShortcuts().
-                    setGraphHopperLocation(graphFile).setEncodingManager(new EncodingManager(importVehicles)).
-                    importOrLoad();
-
-            Graph g = hopper.getGraph();
-            GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
-                    setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
-
-            assertEquals(3437.6, rsp.getDistance(), .1);
-            assertEquals(87, rsp.getPoints().getSize());
-
-            InstructionList il = rsp.getInstructions();
-            assertEquals(13, il.size());
-            Translation tr = trMap.getWithFallBack(Locale.US);
-            List<String> iList = il.createDescription(tr);
-            // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
-            assertEquals("Continue onto Avenue des Guelfes", iList.get(0));
-            assertEquals("Turn slight left onto Avenue des Papalins", iList.get(1));
-            assertEquals("Turn sharp right onto Quai Jean-Charles Rey", iList.get(2));
-            assertEquals("Turn left onto road", iList.get(3));
-            assertEquals("Turn right onto Avenue Albert II", iList.get(4));
-
-            List<Double> dists = il.createDistances();
-            assertEquals(11, dists.get(0), 1);
-            assertEquals(289, dists.get(1), 1);
-            assertEquals(10, dists.get(2), 1);
-            assertEquals(43, dists.get(3), 1);
-            assertEquals(122, dists.get(4), 1);
-            assertEquals(447, dists.get(5), 1);
-
-            List<Long> times = il.createMillis();
-            assertEquals(7, times.get(0) / 1000);
-            assertEquals(207, times.get(1) / 1000);
-            assertEquals(7, times.get(2) / 1000);
-            assertEquals(30, times.get(3) / 1000);
-            assertEquals(87, times.get(4) / 1000);
-            assertEquals(321, times.get(5) / 1000);
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("cannot handle osm file " + osmFile, ex);
-        } finally
-        {
-            Helper.removeDir(new File(graphFile));
-        }
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 47ea9b578e..6b684c5120 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -17,15 +17,17 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
-import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Instruction;
 import com.graphhopper.util.InstructionList;
+import com.graphhopper.storage.EdgeEntry;
+import com.graphhopper.util.*;
+import java.util.*;
+
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -35,40 +37,54 @@
  */
 public class PathTest
 {
+    private final FlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager carManager = new EncodingManager(encoder);
+    private final EncodingManager mixedEncoders = new EncodingManager(
+            new CarFlagEncoder(), new FootFlagEncoder(),new BikeFlagEncoder());
+    private final TranslationMap trMap = TranslationMapTest.SINGLETON;
+    private final Translation tr = trMap.getWithFallBack(Locale.US);
+    private final AngleCalc ac = new AngleCalc();
+    private final RoundaboutGraph roundaboutGraph = new RoundaboutGraph();
+
     @Test
     public void testFound()
     {
-        Path p = new Path(null, null);
+        GraphStorage g = new GraphBuilder(carManager).create();
+        Path p = new Path(g, encoder);
         assertFalse(p.isFound());
         assertEquals(0, p.getDistance(), 1e-7);
         assertEquals(0, p.calcNodes().size());
+        g.close();
     }
 
     @Test
     public void testTime()
     {
-        FlagEncoder encoder = new EncodingManager("CAR").getEncoder("CAR");
-        Path p = new Path(null, encoder);
-        assertEquals(60 * 60 * 1000, p.calcMillis(100000, encoder.setProperties(100, true, true)));
+        FlagEncoder tmpEnc = new Bike2WeightFlagEncoder();
+        GraphStorage g = new GraphBuilder(new EncodingManager(tmpEnc)).create();
+        Path p = new Path(g, tmpEnc);
+        long flags = tmpEnc.setSpeed(tmpEnc.setReverseSpeed(tmpEnc.setAccess(0, true, true), 10), 15);
+        assertEquals(375 * 60 * 1000, p.calcMillis(100000, flags, false));
+        assertEquals(600 * 60 * 1000, p.calcMillis(100000, flags, true));
+
+        g.close();
     }
 
     @Test
     public void testWayList()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
-        FlagEncoder carEnc = carManager.getEncoder("CAR");
-        Graph g = new GraphBuilder(carManager).create();
-
-        g.setNode(0, 0.0, 0.1);
-        g.setNode(1, 1.0, 0.1);
-        g.setNode(2, 2.0, 0.1);
+        GraphStorage g = new GraphBuilder(carManager).create();
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0.0, 0.1);
+        na.setNode(1, 1.0, 0.1);
+        na.setNode(2, 2.0, 0.1);
 
-        EdgeIteratorState edge1 = g.edge(0, 1).setDistance(1000).setFlags(carEnc.setProperties(10, true, true));
+        EdgeIteratorState edge1 = g.edge(0, 1).setDistance(1000).setFlags(encoder.setProperties(10, true, true));
         edge1.setWayGeometry(Helper.createPointList(8, 1, 9, 1));
-        EdgeIteratorState edge2 = g.edge(2, 1).setDistance(2000).setFlags(carEnc.setProperties(50, true, true));
+        EdgeIteratorState edge2 = g.edge(2, 1).setDistance(2000).setFlags(encoder.setProperties(50, true, true));
         edge2.setWayGeometry(Helper.createPointList(11, 1, 10, 1));
 
-        Path path = new Path(g, carEnc);
+        Path path = new Path(g, encoder);
         EdgeEntry e1 = new EdgeEntry(edge2.getEdge(), 2, 1);
         e1.parent = new EdgeEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent = new EdgeEntry(-1, 0, 1);
@@ -76,24 +92,49 @@ public void testWayList()
         path.extract();
         // 0-1-2
         assertPList(Helper.createPointList(0, 0.1, 8, 1, 9, 1, 1, 0.1, 10, 1, 11, 1, 2, 0.1), path.calcPoints());
-        InstructionList instr = path.calcInstructions();
-        assertEquals("[" + 504 * 1000 + ", 0]", instr.createMillis().toString());
-        assertEquals("[3000.0, 0.0]", instr.createDistances().toString());
+        InstructionList instr = path.calcInstructions(tr);
+        List<Map<String, Object>> res = instr.createJson();
+        Map<String, Object> tmp = res.get(0);
+        assertEquals(3000.0, tmp.get("distance"));
+        assertEquals(504000L, tmp.get("time"));
+        assertEquals("Continue", tmp.get("text"));
+        assertEquals("[0, 6]", tmp.get("interval").toString());
+
+        tmp = res.get(1);
+        assertEquals(0.0, tmp.get("distance"));
+        assertEquals(0L, tmp.get("time"));
+        assertEquals("Finish!", tmp.get("text"));
+        assertEquals("[6, 6]", tmp.get("interval").toString());
+        int lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
+        assertEquals(path.calcPoints().size() - 1, lastIndex);
 
         // force minor change for instructions
         edge2.setName("2");
-        path = new Path(g, carEnc);
+        path = new Path(g, encoder);
         e1 = new EdgeEntry(edge2.getEdge(), 2, 1);
         e1.parent = new EdgeEntry(edge1.getEdge(), 1, 1);
         e1.parent.parent = new EdgeEntry(-1, 0, 1);
         path.setEdgeEntry(e1);
         path.extract();
-        instr = path.calcInstructions();
-        assertEquals("[" + 6 * 60 * 1000 + ", " + 144 * 1000 + ", 0]", instr.createMillis().toString());
-        assertEquals("[1000.0, 2000.0, 0.0]", instr.createDistances().toString());
+        instr = path.calcInstructions(tr);
+        res = instr.createJson();
+
+        tmp = res.get(0);
+        assertEquals(1000.0, tmp.get("distance"));
+        assertEquals(360000L, tmp.get("time"));
+        assertEquals("Continue", tmp.get("text"));
+        assertEquals("[0, 3]", tmp.get("interval").toString());
+
+        tmp = res.get(1);
+        assertEquals(2000.0, tmp.get("distance"));
+        assertEquals(144000L, tmp.get("time"));
+        assertEquals("Turn sharp right onto 2", tmp.get("text"));
+        assertEquals("[3, 6]", tmp.get("interval").toString());
+        lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
+        assertEquals(path.calcPoints().size() - 1, lastIndex);
 
         // now reverse order
-        path = new Path(g, carEnc);
+        path = new Path(g, encoder);
         e1 = new EdgeEntry(edge1.getEdge(), 0, 1);
         e1.parent = new EdgeEntry(edge2.getEdge(), 1, 1);
         e1.parent.parent = new EdgeEntry(-1, 2, 1);
@@ -101,8 +142,380 @@ public void testWayList()
         path.extract();
         // 2-1-0
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
-        instr = path.calcInstructions();
-        assertEquals("[" + 144 * 1000 + ", " + 6 * 60 * 1000 + ", 0]", instr.createMillis().toString());
-        assertEquals("[2000.0, 1000.0, 0.0]", instr.createDistances().toString());
+
+        instr = path.calcInstructions(tr);
+        res = instr.createJson();
+        tmp = res.get(0);
+        assertEquals(2000.0, tmp.get("distance"));
+        assertEquals(144000L, tmp.get("time"));
+        assertEquals("Continue onto 2", tmp.get("text"));
+        assertEquals("[0, 3]", tmp.get("interval").toString());
+
+        tmp = res.get(1);
+        assertEquals(1000.0, tmp.get("distance"));
+        assertEquals(360000L, tmp.get("time"));
+        assertEquals("Turn sharp left", tmp.get("text"));
+        assertEquals("[3, 6]", tmp.get("interval").toString());
+        lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
+        assertEquals(path.calcPoints().size() - 1, lastIndex);
+    }
+
+    @Test
+    public void testFindInstruction()
+    {
+        Graph g = new GraphBuilder(carManager).create();
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0.0, 0.0);
+        na.setNode(1, 5.0, 0.0);
+        na.setNode(2, 5.0, 0.5);
+        na.setNode(3, 10.0, 0.5);
+        na.setNode(4, 7.5, 0.25);
+
+        EdgeIteratorState edge1 = g.edge(0, 1).setDistance(1000).setFlags(encoder.setProperties(50, true, true));
+        edge1.setWayGeometry(Helper.createPointList());
+        edge1.setName("Street 1");
+        EdgeIteratorState edge2 = g.edge(1, 2).setDistance(1000).setFlags(encoder.setProperties(50, true, true));
+        edge2.setWayGeometry(Helper.createPointList());
+        edge2.setName("Street 2");
+        EdgeIteratorState edge3 = g.edge(2, 3).setDistance(1000).setFlags(encoder.setProperties(50, true, true));
+        edge3.setWayGeometry(Helper.createPointList());
+        edge3.setName("Street 3");
+        EdgeIteratorState edge4 = g.edge(3, 4).setDistance(500).setFlags(encoder.setProperties(50, true, true));
+        edge4.setWayGeometry(Helper.createPointList());
+        edge4.setName("Street 4");
+
+        Path path = new Path(g, encoder);
+        EdgeEntry e1 = new EdgeEntry(edge4.getEdge(), 4, 1);
+        e1.parent = new EdgeEntry(edge3.getEdge(), 3, 1);
+        e1.parent.parent = new EdgeEntry(edge2.getEdge(), 2, 1);
+        e1.parent.parent.parent = new EdgeEntry(edge1.getEdge(), 1, 1);
+        e1.parent.parent.parent.parent = new EdgeEntry(-1, 0, 1);
+        path.setEdgeEntry(e1);
+        path.extract();
+
+        InstructionList il = path.calcInstructions(tr);
+        Instruction nextInstr0 = il.find(-0.001, 0.0, 1000);
+        assertEquals(Instruction.CONTINUE_ON_STREET, nextInstr0.getSign());
+        
+        Instruction nextInstr1 = il.find(0.001, 0.001, 1000);
+        assertEquals(Instruction.TURN_RIGHT, nextInstr1.getSign());
+
+        Instruction nextInstr2 = il.find(5.0, 0.004, 1000);
+        assertEquals(Instruction.TURN_LEFT, nextInstr2.getSign());
+
+        Instruction nextInstr3 = il.find(9.99, 0.503, 1000);
+        assertEquals(Instruction.TURN_SHARP_LEFT, nextInstr3.getSign());
+
+        // a bit far away ...
+        Instruction nextInstr4 = il.find(7.40, 0.25, 20000);
+        assertEquals(Instruction.FINISH, nextInstr4.getSign());
+
+        // too far away
+        assertNull(il.find(50.8, 50.25, 1000));
+    }
+
+    private class RoundaboutGraph
+    {
+        private EdgeIteratorState edge3to6, edge3to9;
+        boolean clockwise = false;
+        final public Graph g = new GraphBuilder(mixedEncoders).create();
+        final public NodeAccess na = g.getNodeAccess();
+        List<EdgeIteratorState> roundaboutEdges = new LinkedList<EdgeIteratorState>();
+
+        private RoundaboutGraph()
+        {
+            //                          
+            //      8
+            //       \
+            //         5
+            //       /  \
+            //  1 - 2    4 - 7
+            //       \  /
+            //        3
+            //        | \
+            //        6 [ 9 ] edge 9 is turned off in default mode 
+
+            na.setNode(1, 52.514, 13.348);
+            na.setNode(2, 52.514, 13.349);
+            na.setNode(3, 52.5135,13.35);
+            na.setNode(4, 52.514, 13.351);
+            na.setNode(5, 52.5145,13.351);
+            na.setNode(6, 52.513, 13.35);
+            na.setNode(7, 52.514, 13.352);
+            na.setNode(8, 52.515, 13.351);
+            na.setNode(9, 52.513, 13.351);
+          
+           
+            EdgeIteratorState tmpEdge;
+            tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+            
+            // roundabout
+            tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+            roundaboutEdges.add(tmpEdge.detach(false));
+
+            tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+            tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+
+            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+            edge3to6 = tmpEdge.detach(false);
+
+            tmpEdge = g.edge(3, 9, 5, false).setName("3-9");
+            edge3to9 = tmpEdge.detach(false);
+            
+            setRoundabout(clockwise);
+            inverse3to9();
+            
+        }
+        
+        public void setRoundabout(boolean clockwise)
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                for (EdgeIteratorState edge : roundaboutEdges)
+                {
+                    edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
+                    edge.setFlags(encoder.setBool(edge.getFlags(), encoder.K_ROUNDABOUT, true));
+                }
+            }    
+            this.clockwise = clockwise;
+        }
+        
+        public void inverse3to9()
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to9.getFlags();
+                edge3to9.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), false));
+            }
+        }
+
+        public void inverse3to6()
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to6.getFlags();
+                edge3to6.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), true));
+            }
+        }
+        
+
+        private double getAngle(int n1, int n2, int n3, int n4)
+        {
+            double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
+            double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
+            outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+            double delta = (inOrientation - outOrientation);
+            delta = clockwise? (Math.PI+delta) : -1*(Math.PI - delta);
+            return delta;
+        }
+    }
+
+    /**
+     * Test roundabout instructions for different profiles
+     */
+    @Test
+    public void testCalcInstructionsRoundabout()
+    {
+        for(FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+        {
+            Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                    .calcPath(1, 8);
+            InstructionList wayList = p.calcInstructions(tr);
+            // Test instructions
+            List<String> tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 3 onto 5-8",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+            RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+
+            // case of continuing a street through a roundabout
+            p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+            wayList = p.calcInstructions(tr);
+            tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 2 onto MainStreet",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            delta = roundaboutGraph.getAngle(1, 2, 4, 7);
+            instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+        }
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(2, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
+                                    "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * case with one node being containig already exit 
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutDirectExit()
+    {
+        roundaboutGraph.inverse3to9();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto 3-6",
+                        "At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        roundaboutGraph.inverse3to9();
+    }
+
+    /**
+     * case with one edge being not an exit
+     */
+    @Test
+    public void testCalcInstructionsRoundabout2()
+    {
+        roundaboutGraph.inverse3to6();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 2 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+        roundaboutGraph.inverse3to6();
+
+    }
+
+
+    /**
+     * see https://github.com/graphhopper/graphhopper/issues/353
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutIssue353()
+    {
+        final Graph g = new GraphBuilder(carManager).create();
+        final NodeAccess na = g.getNodeAccess();
+
+
+        //
+        //          8
+        //           \
+        //            5
+        //           /  \
+        //  11- 1 - 2    4 - 7
+        //      |     \  /
+        //      10 -9 -3
+        //       \    |
+        //        --- 6
+
+        na.setNode(1, 52.514, 13.348);
+        na.setNode(2, 52.514, 13.349);
+        na.setNode(3, 52.5135,13.35);
+        na.setNode(4, 52.514, 13.351);
+        na.setNode(5, 52.5145,13.351);
+        na.setNode(6, 52.513, 13.35);
+        na.setNode(7, 52.514, 13.352);
+        na.setNode(8, 52.515, 13.351);
+
+        // Sidelane
+        na.setNode(9, 52.5135, 13.349);
+        na.setNode(10, 52.5135, 13.348);
+        na.setNode(11, 52.514, 13.347);
+
+
+        EdgeIteratorState tmpEdge;
+        tmpEdge = g.edge(2, 1, 5, false).setName("MainStreet");
+        tmpEdge = g.edge(1, 11, 5, false).setName("MainStreet");
+
+
+         // roundabout
+        tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(9, 10, 2, false).setName("9-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(6, 10, 2, false).setName("6-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(10, 1, 2, false).setName("10-1");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+
+        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+
+
+        
+        
+        Path p = new Dijkstra(g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 11);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet",
+                                    "Finish!"),
+                tmpList);
     }
+
+    /**
+     * clockwise roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutClockwise()
+    {
+
+        roundaboutGraph.setRoundabout(true);
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                        "At roundabout, take exit 1 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    List<String> pick( String key, List<Map<String, Object>> instructionJson )
+    {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson)
+        {
+            list.add(json.get(key).toString());
+        }
+        return list;
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index 648a67d294..bf667e82dd 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -17,18 +17,18 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import static com.graphhopper.storage.index.QueryResult.Position.*;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import gnu.trove.map.TIntObjectMap;
 import java.util.Arrays;
+import org.junit.After;
 import org.junit.Test;
 import static org.junit.Assert.*;
+import org.junit.Before;
 
 /**
  *
@@ -36,6 +36,24 @@
  */
 public class QueryGraphTest
 {
+    private EncodingManager encodingManager;
+    private FlagEncoder carEncoder;
+    private GraphStorage g;
+
+    @Before
+    public void setUp()
+    {
+        carEncoder = new CarFlagEncoder();
+        encodingManager = new EncodingManager(carEncoder);
+        g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(100);
+    }
+
+    @After
+    public void tearDown()
+    {
+        g.close();
+    }
+
     void initGraph( Graph g )
     {
         //
@@ -43,9 +61,10 @@ void initGraph( Graph g )
         // 0     1
         // |
         // 2
-        g.setNode(0, 1, 0);
-        g.setNode(1, 1, 2.5);
-        g.setNode(2, 0, 0);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 1, 0);
+        na.setNode(1, 1, 2.5);
+        na.setNode(2, 0, 0);
         g.edge(0, 2, 10, true);
         g.edge(0, 1, 10, true).setWayGeometry(Helper.createPointList(1.5, 1, 1.5, 1.5));
     }
@@ -53,8 +72,6 @@ void initGraph( Graph g )
     @Test
     public void testOneVirtualNode()
     {
-        EncodingManager encodingManager = new EncodingManager("CAR");
-        Graph g = new GraphHopperStorage(new RAMDirectory(), encodingManager).create(100);
         initGraph(g);
         EdgeExplorer expl = g.createEdgeExplorer();
 
@@ -92,7 +109,7 @@ public void testOneVirtualNode()
         queryGraph.lookup(Arrays.asList(res));
         assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
         assertEquals(3, res.getClosestNode());
-        assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
+        assertEquals(4, getPoints(queryGraph, 0, 3).getSize());
         assertEquals(2, getPoints(queryGraph, 3, 1).getSize());
 
         queryGraph = new QueryGraph(g);
@@ -100,7 +117,7 @@ public void testOneVirtualNode()
         queryGraph.lookup(Arrays.asList(res));
         assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
         assertEquals(3, res.getClosestNode());
-        assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
+        assertEquals(4, getPoints(queryGraph, 0, 3).getSize());
         assertEquals(2, getPoints(queryGraph, 3, 1).getSize());
 
         // snap to edge which has pillar nodes        
@@ -124,11 +141,45 @@ public void testOneVirtualNode()
         assertEquals(2, getPoints(queryGraph, 3, 2).getSize());
     }
 
+    @Test
+    public void testFillVirtualEdges()
+    {
+        initGraph(g);
+        g.getNodeAccess().setNode(3, 0, 1);
+        g.edge(1, 3);
+
+        final int baseNode = 1;
+        EdgeIterator iter = g.createEdgeExplorer().setBaseNode(baseNode);
+        iter.next();
+        QueryResult res1 = createLocationResult(2, 1.7, iter, 1, PILLAR);
+        QueryGraph queryGraph = new QueryGraph(g)
+        {
+
+            @Override
+            void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
+            {
+                super.fillVirtualEdges(node2Edge, towerNode, mainExpl);
+                // ignore nodes should include baseNode == 1
+                if (towerNode == 3)
+                    assertEquals("[3->4]", node2Edge.get(towerNode).toString());
+                else if (towerNode == 1)
+                    assertEquals("[1->4, 1 1-0]", node2Edge.get(towerNode).toString());
+                else
+                    throw new IllegalStateException("not allowed " + towerNode);
+            }
+        };
+        queryGraph.lookup(Arrays.asList(res1));
+        EdgeIteratorState state = GHUtility.getEdge(queryGraph, 0, 1);
+        assertEquals(4, state.fetchWayGeometry(3).size());
+
+        // fetch virtual edge and check way geometry
+        state = GHUtility.getEdge(queryGraph, 4, 3);
+        assertEquals(2, state.fetchWayGeometry(3).size());
+    }
+
     @Test
     public void testMultipleVirtualNodes()
     {
-        EncodingManager encodingManager = new EncodingManager("CAR");
-        Graph g = new GraphHopperStorage(new RAMDirectory(), encodingManager).create(100);
         initGraph(g);
 
         // snap to edge which has pillar nodes        
@@ -139,7 +190,7 @@ public void testMultipleVirtualNodes()
         queryGraph.lookup(Arrays.asList(res1));
         assertEquals(new GHPoint(1.5, 1.5), res1.getSnappedPoint());
         assertEquals(3, res1.getClosestNode());
-        assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
+        assertEquals(4, getPoints(queryGraph, 0, 3).getSize());
         PointList pl = getPoints(queryGraph, 3, 1);
         assertEquals(2, pl.getSize());
         assertEquals(new GHPoint(1.5, 1.5), pl.toGHPoint(0));
@@ -165,7 +216,7 @@ public void testMultipleVirtualNodes()
         assertEquals(3, res1.getClosestNode());
         assertEquals(new GHPoint(1.5, 1.5), res1.getSnappedPoint());
 
-        assertEquals(3, getPoints(queryGraph, 3, 0).getSize());
+        assertEquals(4, getPoints(queryGraph, 3, 0).getSize());
         assertEquals(2, getPoints(queryGraph, 3, 4).getSize());
         assertEquals(2, getPoints(queryGraph, 4, 1).getSize());
         assertNull(GHUtility.getEdge(queryGraph, 4, 0));
@@ -175,10 +226,9 @@ public void testMultipleVirtualNodes()
     @Test
     public void testOneWay()
     {
-        EncodingManager encodingManager = new EncodingManager("CAR");
-        Graph g = new GraphHopperStorage(new RAMDirectory(), encodingManager).create(100);
-        g.setNode(0, 0, 0);
-        g.setNode(1, 0, 1);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0);
+        na.setNode(1, 0, 1);
         g.edge(0, 1, 10, false);
 
         EdgeIteratorState edge = GHUtility.getEdge(g, 0, 1);
@@ -201,24 +251,117 @@ public void testOneWay()
     @Test
     public void testVirtEdges()
     {
-        EncodingManager encodingManager = new EncodingManager("CAR");
-        Graph g = new GraphHopperStorage(new RAMDirectory(), encodingManager).create(100);
         initGraph(g);
 
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(0);
         iter.next();
 
-        QueryGraph.VirtualEdgeIterator vi = new QueryGraph.VirtualEdgeIterator(2);
-        vi.add(iter.detach());
+        VirtualEdgeIterator vi = new VirtualEdgeIterator(2);
+        vi.add(iter.detach(false));
 
         assertTrue(vi.next());
     }
 
+    @Test
+    public void testUseMeanElevation()
+    {
+        g.close();
+        g = new GraphHopperStorage(new RAMDirectory(), encodingManager, true).create(100);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0, 0);
+        na.setNode(1, 0, 0.0001, 20);
+        EdgeIteratorState edge = g.edge(0, 1);
+        EdgeIteratorState edgeReverse = edge.detach(true);
+
+        DistanceCalc2D distCalc = new DistanceCalc2D();
+        QueryResult qr = new QueryResult(0, 0.00005);
+        qr.setClosestEdge(edge);
+        qr.setWayIndex(0);
+        qr.setSnappedPosition(EDGE);
+        qr.calcSnappedPoint(distCalc);
+        assertEquals(10, qr.getSnappedPoint().getEle(), 1e-1);
+
+        qr = new QueryResult(0, 0.00005);
+        qr.setClosestEdge(edgeReverse);
+        qr.setWayIndex(0);
+        qr.setSnappedPosition(EDGE);
+        qr.calcSnappedPoint(distCalc);
+        assertEquals(10, qr.getSnappedPoint().getEle(), 1e-1);
+    }
+
+    @Test
+    public void testLoopStreet_Issue151()
+    {
+        // do query at x should result in ignoring only the bottom edge 1-3 not the upper one => getNeighbors are 0, 5, 3 and not only 0, 5
+        //
+        // 0--1--3--4
+        //    |  |
+        //    x---
+        //
+        g.edge(0, 1, 10, true);
+        g.edge(1, 3, 10, true);
+        g.edge(3, 4, 10, true);
+        EdgeIteratorState edge = g.edge(1, 3, 20, true).setWayGeometry(Helper.createPointList(-0.001, 0.001, -0.001, 0.002));
+        AbstractRoutingAlgorithmTester.updateDistancesFor(g, 0, 0, 0);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(g, 1, 0, 0.001);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(g, 3, 0, 0.002);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(g, 4, 0, 0.003);
+
+        QueryResult qr = new QueryResult(-0.0005, 0.001);
+        qr.setClosestEdge(edge);
+        qr.setWayIndex(1);
+        qr.calcSnappedPoint(new DistanceCalc2D());
+
+        QueryGraph qg = new QueryGraph(g);
+        qg.lookup(Arrays.asList(qr));
+        EdgeExplorer ee = qg.createEdgeExplorer();
+
+        assertEquals(GHUtility.asSet(0, 5, 3), GHUtility.getNeighbors(ee.setBaseNode(1)));
+    }
+
+    @Test
+    public void testOneWayLoop_Issue162()
+    {
+        // do query at x, where edge is oneway
+        //
+        // |\
+        // | x
+        // 0<-\
+        // |
+        // 1        
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0);
+        na.setNode(1, 0, -0.001);
+        g.edge(0, 1, 10, true);
+        // in the case of identical nodes the wayGeometry defines the direction!
+        EdgeIteratorState edge = g.edge(0, 0).
+                setDistance(100).
+                setFlags(carEncoder.setProperties(20, true, false)).
+                setWayGeometry(Helper.createPointList(0.001, 0, 0, 0.001));
+
+        QueryResult qr = new QueryResult(0.0011, 0.0009);
+        qr.setClosestEdge(edge);
+        qr.setWayIndex(1);
+        qr.calcSnappedPoint(new DistanceCalc2D());
+
+        QueryGraph qg = new QueryGraph(g);
+        qg.lookup(Arrays.asList(qr));
+        EdgeExplorer ee = qg.createEdgeExplorer();
+        assertTrue(qr.getClosestNode() > 1);
+        assertEquals(2, GHUtility.count(ee.setBaseNode(qr.getClosestNode())));
+        EdgeIterator iter = ee.setBaseNode(qr.getClosestNode());
+        iter.next();
+        assertTrue(iter.toString(), carEncoder.isForward(iter.getFlags()));
+        assertFalse(iter.toString(), carEncoder.isBackward(iter.getFlags()));
+
+        iter.next();
+        assertFalse(iter.toString(), carEncoder.isForward(iter.getFlags()));
+        assertTrue(iter.toString(), carEncoder.isBackward(iter.getFlags()));
+    }
+
     @Test
     public void testEdgesShareOneNode()
     {
-        EncodingManager encodingManager = new EncodingManager("CAR");
-        Graph g = new GraphHopperStorage(new RAMDirectory(), encodingManager).create(100);
         initGraph(g);
 
         EdgeIteratorState iter = GHUtility.getEdge(g, 0, 2);
@@ -233,6 +376,49 @@ public void testEdgesShareOneNode()
         assertNotNull(GHUtility.getEdge(queryGraph, 0, 3));
     }
 
+    @Test
+    public void testAvoidDuplicateVirtualNodesIfIdentical()
+    {
+        initGraph(g);
+
+        EdgeIteratorState edgeState = GHUtility.getEdge(g, 0, 2);
+        QueryResult res1 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        QueryResult res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(res1, res2));
+        assertEquals(new GHPoint(0.5, 0), res1.getSnappedPoint());
+        assertEquals(new GHPoint(0.5, 0), res2.getSnappedPoint());
+        assertEquals(3, res1.getClosestNode());
+        assertEquals(3, res2.getClosestNode());
+
+        // force skip due to **tower** node snapping in phase 2, but no virtual edges should be created for res1
+        edgeState = GHUtility.getEdge(g, 0, 1);
+        res1 = createLocationResult(1, 0, edgeState, 0, EDGE);
+        // now create virtual edges
+        edgeState = GHUtility.getEdge(g, 0, 2);
+        res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(res1, res2));
+        // make sure only one virtual node was created
+        assertEquals(queryGraph.getNodes(), g.getNodes() + 1);
+        EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(0);
+        assertEquals(GHUtility.asSet(1, 3), GHUtility.getNeighbors(iter));
+    }
+
+    @Test
+    public void testGetEdgeProps()
+    {
+        initGraph(g);
+        EdgeIteratorState e1 = GHUtility.getEdge(g, 0, 2);
+        QueryGraph queryGraph = new QueryGraph(g);
+        QueryResult res1 = createLocationResult(0.5, 0, e1, 0, EDGE);
+        queryGraph.lookup(Arrays.asList(res1));
+        // get virtual edge
+        e1 = GHUtility.getEdge(queryGraph, res1.getClosestNode(), 0);
+        EdgeIteratorState e2 = queryGraph.getEdgeProps(e1.getEdge(), Integer.MIN_VALUE);
+        assertEquals(e1.getEdge(), e2.getEdge());
+    }
+
     PointList getPoints( Graph g, int base, int adj )
     {
         EdgeIteratorState edge = GHUtility.getEdge(g, base, adj);
@@ -242,15 +428,117 @@ PointList getPoints( Graph g, int base, int adj )
     }
 
     public QueryResult createLocationResult( double lat, double lon,
-            EdgeIteratorState edge, int index, QueryResult.Position pos )
+            EdgeIteratorState edge, int wayIndex, QueryResult.Position pos )
     {
         if (edge == null)
             throw new IllegalStateException("Specify edge != null");
         QueryResult tmp = new QueryResult(lat, lon);
         tmp.setClosestEdge(edge);
-        tmp.setWayIndex(index);
+        tmp.setWayIndex(wayIndex);
         tmp.setSnappedPosition(pos);
         tmp.calcSnappedPoint(new DistanceCalcEarth());
         return tmp;
     }
+
+    @Test
+    public void testIteration_Issue163()
+    {
+        EdgeFilter outEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("CAR"), false, true);
+        EdgeFilter inEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("CAR"), true, false);
+        EdgeExplorer inExplorer = g.createEdgeExplorer(inEdgeFilter);
+        EdgeExplorer outExplorer = g.createEdgeExplorer(outEdgeFilter);
+
+        int nodeA = 0;
+        int nodeB = 1;
+
+        /* init test graph: one directional edge going from A to B, via virtual nodes C and D
+         * 
+         *   (C)-(D)
+         *  /       \
+         * A         B
+         */
+        g.getNodeAccess().setNode(nodeA, 1, 0);
+        g.getNodeAccess().setNode(nodeB, 1, 10);
+        g.edge(nodeA, nodeB, 10, false).setWayGeometry(Helper.createPointList(1.5, 3, 1.5, 7));
+
+        // assert the behavior for classic edgeIterator        
+        assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeA, nodeB);
+
+        // setup query results
+        EdgeIteratorState it = GHUtility.getEdge(g, nodeA, nodeB);
+        QueryResult res1 = createLocationResult(1.5, 3, it, 1, QueryResult.Position.EDGE);
+        QueryResult res2 = createLocationResult(1.5, 7, it, 2, QueryResult.Position.EDGE);
+
+        QueryGraph q = new QueryGraph(g);
+        q.lookup(Arrays.asList(res1, res2));
+        int nodeC = res1.getClosestNode();
+        int nodeD = res2.getClosestNode();
+
+        inExplorer = q.createEdgeExplorer(inEdgeFilter);
+        outExplorer = q.createEdgeExplorer(outEdgeFilter);
+
+        // assert the same behavior for queryGraph
+        assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeA, nodeC);
+        assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeC, nodeD);
+        assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeD, nodeB);
+    }
+
+    private void assertEdgeIdsStayingEqual( EdgeExplorer inExplorer, EdgeExplorer outExplorer, int startNode, int endNode )
+    {
+        EdgeIterator it = outExplorer.setBaseNode(startNode);
+        it.next();
+        assertEquals(startNode, it.getBaseNode());
+        assertEquals(endNode, it.getAdjNode());
+        // we expect the edge id to be the same when exploring in backward direction
+        int expectedEdgeId = it.getEdge();
+        assertFalse(it.next());
+
+        // backward iteration, edge id should remain the same!!
+        it = inExplorer.setBaseNode(endNode);
+        it.next();
+        assertEquals(endNode, it.getBaseNode());
+        assertEquals(startNode, it.getAdjNode());
+        assertEquals("The edge id is not the same,", expectedEdgeId, it.getEdge());
+        assertFalse(it.next());
+    }
+
+    @Test
+    public void testTurnCostsProperlyPropagated_Issue282()
+    {
+        TurnCostExtension turnExt = new TurnCostExtension();
+        FlagEncoder encoder = new CarFlagEncoder(5, 5, 15);
+
+        GraphStorage graphWithTurnCosts = new GraphHopperStorage(new RAMDirectory(),
+                new EncodingManager(encoder), false, turnExt).
+                create(100);
+        NodeAccess na = graphWithTurnCosts.getNodeAccess();
+        na.setNode(0, .00, .00);
+        na.setNode(1, .00, .01);
+        na.setNode(2, .01, .01);
+
+        EdgeIteratorState edge0 = graphWithTurnCosts.edge(0, 1, 10, true);
+        EdgeIteratorState edge1 = graphWithTurnCosts.edge(2, 1, 10, true);
+
+        QueryGraph qGraph = new QueryGraph(graphWithTurnCosts);
+        FastestWeighting weighting = new FastestWeighting(encoder);
+        TurnWeighting turnWeighting = new TurnWeighting(weighting, encoder, (TurnCostExtension) qGraph.getExtension());
+
+        assertEquals(0, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
+
+        // now use turn costs and QueryGraph
+        turnExt.addTurnInfo(edge0.getEdge(), 1, edge1.getEdge(), encoder.getTurnFlags(false, 10));
+        assertEquals(10, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
+
+        QueryResult res1 = createLocationResult(0.000, 0.005, edge0, 0, QueryResult.Position.EDGE);
+        QueryResult res2 = createLocationResult(0.005, 0.010, edge1, 0, QueryResult.Position.EDGE);
+
+        qGraph.lookup(Arrays.asList(res1, res2));
+
+        int fromQueryEdge = GHUtility.getEdge(qGraph, res1.getClosestNode(), 1).getEdge();
+        int toQueryEdge = GHUtility.getEdge(qGraph, res2.getClosestNode(), 1).getEdge();
+
+        assertEquals(10, turnWeighting.calcTurnWeight(fromQueryEdge, 1, toQueryEdge), .1);
+
+        graphWithTurnCosts.close();
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 06ea6fae6a..cf1ece6a4e 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -20,21 +20,22 @@
 import com.graphhopper.routing.util.TestAlgoCollector;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.PrinctonReader;
+import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
+import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
 import java.io.File;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map.Entry;
-import java.util.Random;
+import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
 import static org.junit.Assert.*;
@@ -59,28 +60,103 @@ public void setUp()
     List<OneRun> createMonacoCar()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2581, 91));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3586, 126));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.4277, 2560, 102));
-        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 2227, 105));
-        list.add(new OneRun(43.730949, 7.412338, 43.739643, 7.424542, 2101, 100));
+        list.add(new OneRun(43.730729, 7.42135, 43.727697, 7.419199, 2580, 110));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3588, 170));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.4277, 2561, 133));
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 2230, 137));
+        list.add(new OneRun(43.730949, 7.412338, 43.739643, 7.424542, 2100, 116));
         list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.419333, 0, 1));
 
         // same special cases where GPS-exact routing could have problems (same edge and neighbor edges)
         list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.41934, 0, 1));
-        // on the same edge and very close
-        list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.4193, 2, 2));
+        // on the same edge and very release
+        list.add(new OneRun(43.727592, 7.419333, 43.727712, 7.4193, 3, 2));
         // one way stuff
-        list.add(new OneRun(43.729445, 7.415063, 43.728856, 7.41472, 107, 4));
-        list.add(new OneRun(43.728856, 7.41472, 43.729445, 7.415063, 316, 11));
+        list.add(new OneRun(43.729445, 7.415063, 43.728856, 7.41472, 103, 4));
+        list.add(new OneRun(43.728856, 7.41472, 43.729445, 7.415063, 320, 11));
         return list;
     }
 
     @Test
     public void testMonaco()
     {
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
-                createMonacoCar(), "CAR", true, "CAR", "shortest");
+        Graph g = runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                createMonacoCar(), "CAR", true, "CAR", "shortest", false);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        // When OSM file stays unchanged make static edge and node IDs a requirement
+        assertEquals(GHUtility.asSet(9, 111, 182), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
+        assertEquals(GHUtility.asSet(19, 21), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(20)));
+        assertEquals(GHUtility.asSet(478, 84, 83), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(480)));
+
+        assertEquals(43.736989, g.getNodeAccess().getLat(10), 1e-6);
+        assertEquals(7.429758, g.getNodeAccess().getLon(201), 1e-6);
+    }
+
+    @Test
+    public void testMonacoAllAlgorithmsWithBaseGraph()
+    {
+        String vehicle = "car";
+        String graphFile = "target/monaco-gh";
+        String osmFile = "files/monaco.osm.gz";
+        String importVehicles = vehicle;
+
+        Helper.removeDir(new File(graphFile));
+        GraphHopper hopper = new GraphHopper().
+                // avoid that path.getDistance is too different to path.getPoint.calcDistance
+                setWayPointMaxDistance(0).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(graphFile).
+                setEncodingManager(new EncodingManager(importVehicles));
+
+        hopper.importOrLoad();
+
+        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
+        Weighting weighting = hopper.createWeighting(new WeightingMap("shortest"), encoder);
+
+        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                encoder, true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
+        AlgoHelperEntry chPrepare = prepares.get(prepares.size() - 1);
+        if (!(chPrepare.getQueryGraph() instanceof LevelGraph))
+            throw new IllegalStateException("Last prepared queryGraph has to be a levelGraph");
+
+        // set all normal algorithms to baseGraph of already prepared to see if all algorithms still work
+        Graph baseGraphOfCHPrepared = chPrepare.getQueryGraph().getBaseGraph();
+        for (AlgoHelperEntry ahe : prepares)
+        {
+            if (!(ahe.getQueryGraph() instanceof LevelGraph))
+            {
+                ahe.setQueryGraph(baseGraphOfCHPrepared);
+            }
+        }
+
+        List<OneRun> forEveryAlgo = createMonacoCar();
+        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+        for (AlgoHelperEntry entry : prepares)
+        {
+            LocationIndex idx = entry.getIdx();
+            for (OneRun oneRun : forEveryAlgo)
+            {
+                List<QueryResult> list = oneRun.getList(idx, edgeFilter);
+                testCollector.assertDistance(entry, list, oneRun);
+            }
+        }
+    }
+
+    @Test
+    public void testOneWayCircleBug()
+    {
+        // export from http://www.openstreetmap.org/export#map=19/51.37605/-0.53155
+        List<OneRun> list = new ArrayList<OneRun>();
+        // going the bit longer way out of the circle
+        list.add(new OneRun(51.376197, -0.531576, 51.376509, -0.530863, 153, 18));
+        // now exacle the opposite direction: going into the circle (shorter)
+        list.add(new OneRun(51.376509, -0.530863, 51.376197, -0.531576, 75, 15));
+
+        runAlgo(testCollector, "files/circle-bug.osm.gz", "target/circle-bug-gh",
+                list, "CAR", true, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -88,7 +164,6 @@ public void testMonaco()
     public void testMoscow()
     {
         // extracted via ./graphhopper.sh extract "37.582641,55.805261,37.626929,55.824455"
-
         List<OneRun> list = new ArrayList<OneRun>();
         // choose perpendicular
         // http://localhost:8989/?point=55.818994%2C37.595354&point=55.819175%2C37.596931
@@ -99,8 +174,22 @@ public void testMoscow()
         // respect one way!
         // http://localhost:8989/?point=55.819066%2C37.596374&point=55.818898%2C37.59661
         list.add(new OneRun(55.819066, 37.596374, 55.818898, 37.59661, 1114, 23));
+        runAlgo(testCollector, "files/moscow.osm.gz", "target/moscow-gh",
+                list, "CAR", true, "CAR", "fastest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testMoscowTurnCosts()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(new OneRun(55.813357, 37.5958585, 55.811042, 37.594689, 1043.99, 12));
+        list.add(new OneRun(55.813159, 37.593884, 55.811278, 37.594217, 1048, 13));
+        // TODO include CH
+        boolean testAlsoCH = false, is3D = false;
         runAlgo(testCollector, "files/moscow.osm.gz", "target/graph-moscow",
-                list, "CAR", true, "CAR", "fastest");
+                list, "CAR|turnCosts=true", testAlsoCH, "CAR", "fastest", is3D);
+
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -108,13 +197,14 @@ public void testMoscow()
     public void testMonacoFastest()
     {
         List<OneRun> list = createMonacoCar();
-        list.get(0).locs = 95;
-        list.get(3).dist = 2276;
-        list.get(3).locs = 107;
-        list.get(4).dist = 2150;
-        list.get(4).locs = 102;
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
-                list, "CAR", true, "CAR", "fastest");
+        list.get(0).setLocs(1, 117);
+        list.get(0).setDistance(1, 2584);
+        list.get(3).setDistance(1, 2279);
+        list.get(3).setLocs(1, 141);
+        list.get(4).setDistance(1, 2149);
+        list.get(4).setLocs(1, 120);
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "CAR", true, "CAR", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -124,27 +214,96 @@ public void testMonacoMixed()
         // Additional locations are inserted because of new crossings from foot to highway paths!
         // Distance is the same.
         List<OneRun> list = createMonacoCar();
-        list.get(0).locs = 101;
-        list.get(1).locs = 135;
-        list.get(2).locs = 105;
-        list.get(3).locs = 117;
-        list.get(4).locs = 106;
-
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
-                list, "CAR,FOOT", false, "CAR", "shortest");
+        list.get(0).setLocs(1, 110);
+        list.get(1).setLocs(1, 170);
+        list.get(2).setLocs(1, 132);
+        list.get(3).setLocs(1, 137);
+        list.get(4).setLocs(1, 116);
+
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "CAR,FOOT", false, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
+    List<OneRun> createMonacoFoot()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(new OneRun(43.730729, 7.421288, 43.727697, 7.419199, 1566, 92));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3438, 136));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2085, 112));
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1425, 89));
+        return list;
+    }
+
     @Test
     public void testMonacoFoot()
+    {
+        Graph g = runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                createMonacoFoot(), "FOOT", true, "FOOT", "shortest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        // see testMonaco for similar ID test
+        assertEquals(GHUtility.asSet(2, 906, 570), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
+        assertEquals(GHUtility.asSet(443, 952, 739), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(440)));
+        assertEquals(GHUtility.asSet(909, 580, 912), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(911)));
+
+        assertEquals(43.743705, g.getNodeAccess().getLat(100), 1e-6);
+        assertEquals(7.426362, g.getNodeAccess().getLon(701), 1e-6);
+    }
+
+    @Test
+    public void testMonacoFoot3D()
+    {
+        // most routes have same number of points as testMonaceFoot results but longer distance due to elevation difference
+        List<OneRun> list = createMonacoFoot();
+        list.get(0).setDistance(1, 1627);
+        list.get(2).setDistance(1, 2258);
+        list.get(3).setDistance(1, 1482);
+
+        // or slightly longer tour with less nodes: list.get(1).setDistance(1, 3610);
+        list.get(1).setDistance(1, 3595);
+        list.get(1).setLocs(1, 149);
+
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "FOOT", true, "FOOT", "shortest", true);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testNorthBayreuthFootFastestAnd3D()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730729, 7.421288, 43.727697, 7.419199, 1566, 84));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3435, 123));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2085, 89));
-        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1421, 78));
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
-                list, "FOOT", true, "FOOT", "shortest");
+        // prefer hiking route 'Teufelsloch Unterwaiz' and 'Rotmain-Wanderweg'        
+        list.add(new OneRun(49.974972, 11.515657, 49.991022, 11.512299, 2365, 66));
+        // prefer hiking route 'Markgrafenweg Bayreuth Kulmbach'
+        list.add(new OneRun(49.986111, 11.550407, 50.023182, 11.555386, 5165, 133));
+        runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+                list, "FOOT", true, "FOOT", "fastest", true);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testMonacoBike3D_twoSpeedsPerEdge()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        // 1. alternative: go over steps 'Rampe Major' => 1.7km vs. around 2.7km
+        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2710, 118));
+        // 2.
+        list.add(new OneRun(43.728499, 7.417907, 43.74958, 7.436566, 3777, 194));
+        // 3.
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2776, 167));
+        // 4.
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1544, 84));
+
+        // try reverse direction
+        // 1.
+        list.add(new OneRun(43.727687, 7.418737, 43.730864, 7.420771, 2599, 115));
+        list.add(new OneRun(43.74958, 7.436566, 43.728499, 7.417907, 4199, 165));
+        list.add(new OneRun(43.739213, 7.427806, 43.728677, 7.41016, 3261, 177));
+        // 4. avoid tunnel(s)!
+        list.add(new OneRun(43.739662, 7.424355, 43.733802, 7.413433, 2452, 112));
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "BIKE2", true, "BIKE2", "fastest", true);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -152,25 +311,30 @@ public void testMonacoFoot()
     public void testMonacoBike()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 1641, 76));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3580, 133));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2323, 100));
-        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1434, 80));
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
-                list, "BIKE", true, "BIKE", "shortest");
+        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 1642, 87));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3580, 168));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2323, 121));
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1434, 89));
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "BIKE", true, "BIKE", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
-    
+
     @Test
     public void testMonacoMountainBike()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2332, 102));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3588, 135));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2323, 100));
-        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1475, 80));
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
-                list, "BIKE,MTB,RACINGBIKE", true, "MTB", "fastest");
+        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2322, 110));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3613, 178));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2331, 121));
+        // hard to select between secondard and primary (both are AVOID for mtb)
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1459, 88));
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "MTB", true, "MTB", "fastest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "MTB,RACINGBIKE", false, "MTB", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -178,29 +342,33 @@ public void testMonacoMountainBike()
     public void testMonacoRacingBike()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2597, 110));
-        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3615, 155));
-        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2323, 100));
-        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1490, 74));
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/graph-monaco",
-                list, "CAR,BIKE,RACINGBIKE", true, "RACINGBIKE", "fastest");
+        list.add(new OneRun(43.730864, 7.420771, 43.727687, 7.418737, 2594, 111));
+        list.add(new OneRun(43.727687, 7.418737, 43.74958, 7.436566, 3588, 170));
+        list.add(new OneRun(43.728677, 7.41016, 43.739213, 7.427806, 2572, 135));
+        list.add(new OneRun(43.733802, 7.413433, 43.739662, 7.424355, 1490, 84));
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "RACINGBIKE", true, "RACINGBIKE", "fastest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "BIKE,RACINGBIKE", false, "RACINGBIKE", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
-    
+
     @Test
     public void testKremsBikeRelation()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12489, 141));
-        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3077, 75));
-        list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 85));
+        list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12491, 159));
+        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3113, 87));
+        list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 94));
 
-        runAlgo(testCollector, "files/krems.osm.gz", "target/graph-krems",
-                list, "BIKE", true, "BIKE", "fastest");
+        runAlgo(testCollector, "files/krems.osm.gz", "target/krems-gh",
+                list, "BIKE", true, "BIKE", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
-        
-        runAlgo(testCollector, "files/krems.osm.gz", "target/graph-krems",
-                list, "CAR,BIKE,MTB", true, "BIKE", "fastest");
+
+        runAlgo(testCollector, "files/krems.osm.gz", "target/krems-gh",
+                list, "CAR,BIKE", false, "BIKE", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -208,40 +376,40 @@ public void testKremsBikeRelation()
     public void testKremsMountainBikeRelation()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12563, 148));
-        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3164, 83));
-        list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 86));
-
-        runAlgo(testCollector, "files/krems.osm.gz", "target/graph-krems",
-                list, "CAR,BIKE,MTB", true, "MTB", "fastest");
-        assertEquals(testCollector.toString(), 0, testCollector.errors.size());        
-        
-        runAlgo(testCollector, "files/krems.osm.gz", "target/graph-krems",
-                list, "MTB", true, "MTB", "fastest");
+        list.add(new OneRun(48.409523, 15.602394, 48.375466, 15.72916, 12574, 169));
+        list.add(new OneRun(48.410061, 15.63951, 48.411386, 15.604899, 3101, 94));
+        list.add(new OneRun(48.412294, 15.62007, 48.398306, 15.609667, 3965, 95));
+
+        runAlgo(testCollector, "files/krems.osm.gz", "target/krems-gh",
+                list, "MTB", true, "MTB", "fastest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        runAlgo(testCollector, "files/krems.osm.gz", "target/krems-gh",
+                list, "BIKE,MTB", false, "MTB", "fastest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
-    
+
     List<OneRun> createAndorra()
     {
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(42.56819, 1.603231, 42.571034, 1.520662, 17710, 446));
-        list.add(new OneRun(42.529176, 1.571302, 42.571034, 1.520662, 11411, 259));
+        list.add(new OneRun(42.56819, 1.603231, 42.571034, 1.520662, 17708, 524));
+        list.add(new OneRun(42.529176, 1.571302, 42.571034, 1.520662, 11408, 305));
         return list;
     }
 
     @Test
     public void testAndorra()
     {
-        runAlgo(testCollector, "files/andorra.osm.gz", "target/graph-andorra",
-                createAndorra(), "CAR", true, "CAR", "shortest");
+        runAlgo(testCollector, "files/andorra.osm.gz", "target/andorra-gh",
+                createAndorra(), "CAR", true, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
     @Test
     public void testAndorraPbf()
     {
-        runAlgo(testCollector, "files/andorra.osm.pbf", "target/graph-andorra",
-                createAndorra(), "CAR", true, "CAR", "shortest");
+        runAlgo(testCollector, "files/andorra.osm.pbf", "target/andorra-gh",
+                createAndorra(), "CAR", true, "CAR", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -249,13 +417,13 @@ public void testAndorraPbf()
     public void testAndorraFoot()
     {
         List<OneRun> list = createAndorra();
-        list.get(0).dist = 16354;
-        list.get(0).locs = 523;
-        list.get(1).dist = 12704;
-        list.get(1).locs = 404;
+        list.get(0).setDistance(1, 16354);
+        list.get(0).setLocs(1, 648);
+        list.get(1).setDistance(1, 12701);
+        list.get(1).setLocs(1, 431);
 
-        runAlgo(testCollector, "files/andorra.osm.gz", "target/graph-andorra",
-                list, "FOOT", true, "FOOT", "shortest");
+        runAlgo(testCollector, "files/andorra.osm.gz", "target/andorra-gh",
+                list, "FOOT", true, "FOOT", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
@@ -268,57 +436,112 @@ public void testCampoGrande()
         //   | ./bin/osmosis --read-xml enableDateParsing=no file=- --bounding-box top=-20.4 left=-54.6 bottom=-20.6 right=-54.5 --write-xml file=- 
         //   | bzip2 > campo-grande.extracted.osm.bz2
         List<OneRun> list = new ArrayList<OneRun>();
-        list.add(new OneRun(-20.4, -54.6, -20.6, -54.54, 25515, 253));
-        list.add(new OneRun(-20.43, -54.54, -20.537, -54.674, 18009, 234));
-        runAlgo(testCollector, "files/campo-grande.osm.gz", "target/graph-campo-grande", list,
-                "CAR", false, "CAR", "shortest");
+        list.add(new OneRun(-20.4, -54.6, -20.6, -54.54, 25516, 271));
+        list.add(new OneRun(-20.43, -54.54, -20.537, -54.674, 18009, 237));
+        runAlgo(testCollector, "files/campo-grande.osm.gz", "target/campo-grande-gh", list,
+                "CAR", false, "CAR", "shortest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testMonacoVia()
+    {
+        OneRun oneRun = new OneRun();
+        oneRun.add(43.730729, 7.42135, 0, 0);
+        oneRun.add(43.727697, 7.419199, 2581, 110);
+        oneRun.add(43.726387, 7.4, 3001, 90);
+
+        List<OneRun> list = new ArrayList<OneRun>();
+        list.add(oneRun);
+
+        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+                list, "CAR", true, "CAR", "shortest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testHarsdorf()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        // choose Unterloher Weg and the following residential + cycleway
+        list.add(new OneRun(50.004333, 11.600254, 50.044449, 11.543434, 6931, 184));
+        runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+                list, "bike", true, "bike", "fastest", false);
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testNeudrossenfeld()
+    {
+        List<OneRun> list = new ArrayList<OneRun>();
+        // choose cycleway (Dreschenauer Straße)
+        list.add(new OneRun(49.987132, 11.510496, 50.018839, 11.505024, 3985, 106));
+
+        runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+                list, "bike", true, "bike", "fastest", true);
+
+        runAlgo(testCollector, "files/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+                list, "bike2", true, "bike2", "fastest", true);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
-    void runAlgo( TestAlgoCollector testCollector, String osmFile,
+    /**
+     * @param testAlsoCH if true also the CH algorithms will be tested which needs preparation and
+     * takes a bit longer
+     */
+    Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
             String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
-            boolean ch, String vehicle, String weightCalcStr )
+            boolean testAlsoCH, String vehicle, String weightStr, boolean is3D )
     {
-        AlgorithmPreparation tmpPrepare = null;
+        AlgoHelperEntry algoEntry = null;
         OneRun tmpOneRun = null;
         try
         {
             Helper.removeDir(new File(graphFile));
-            GraphHopper hopper = new GraphHopper().setInMemory(true, true).setOSMFile(osmFile).
-                    disableCHShortcuts().
-                    setGraphHopperLocation(graphFile).setEncodingManager(new EncodingManager(importVehicles)).
-                    importOrLoad();
-
+            GraphHopper hopper = new GraphHopper().
+                    setStoreOnFlush(true).
+                    // avoid that path.getDistance is too different to path.getPoint.calcDistance
+                    setWayPointMaxDistance(0).
+                    setOSMFile(osmFile).
+                    setCHEnable(false).
+                    setGraphHopperLocation(graphFile).
+                    setEncodingManager(new EncodingManager(importVehicles));
+            if (is3D)
+                hopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files")));
+
+            hopper.importOrLoad();
+
+            TraversalMode tMode = importVehicles.toLowerCase().contains("turncosts=true")
+                    ? TraversalMode.EDGE_BASED_1DIR : TraversalMode.NODE_BASED;
             FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
-            Weighting weighting = new ShortestWeighting();
-            if ("fastest".equalsIgnoreCase(weightCalcStr))
-                weighting = new FastestWeighting(encoder);
+            Weighting weighting = hopper.createWeighting(new WeightingMap(weightStr), encoder);
 
-            Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = RoutingAlgorithmSpecialAreaTests.
-                    createAlgos(hopper.getGraph(), hopper.getLocationIndex(), encoder, ch, weighting, hopper.getEncodingManager());
+            Collection<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                    encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
             EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-            for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
+            for (AlgoHelperEntry entry : prepares)
             {
-                tmpPrepare = entry.getKey();
-                LocationIndex idx = entry.getValue();
+                algoEntry = entry;
+                LocationIndex idx = entry.getIdx();
                 for (OneRun oneRun : forEveryAlgo)
                 {
                     tmpOneRun = oneRun;
-                    QueryResult from = idx.findClosest(oneRun.fromLat, oneRun.fromLon, edgeFilter);
-                    QueryResult to = idx.findClosest(oneRun.toLat, oneRun.toLon, edgeFilter);
-                    testCollector.assertDistance(tmpPrepare.createAlgo(), from, to, oneRun.dist, oneRun.locs);
+                    List<QueryResult> list = oneRun.getList(idx, edgeFilter);
+                    testCollector.assertDistance(algoEntry, list, oneRun);
                 }
             }
+
+            return hopper.getGraph();
         } catch (Exception ex)
         {
-            if (tmpPrepare == null)
-                throw new RuntimeException("cannot handle file " + osmFile, ex);
+            if (algoEntry == null)
+                throw new RuntimeException("cannot handle file " + osmFile + ", " + ex.getMessage(), ex);
 
-            throw new RuntimeException("cannot handle " + tmpPrepare.toString() + ", for " + tmpOneRun
-                    + ", file " + osmFile, ex);
+            throw new RuntimeException("cannot handle " + algoEntry.toString() + ", for " + tmpOneRun
+                    + ", file " + osmFile + ", " + ex.getMessage(), ex);
         } finally
         {
-            Helper.removeDir(new File(graphFile));
+            // Helper.removeDir(new File(graphFile));
         }
     }
 
@@ -334,18 +557,17 @@ public void testPerformance() throws IOException
         Graph graph = new GraphBuilder(eManager).create();
 
         String bigFile = "10000EWD.txt.gz";
-        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile), 8 * (1 << 10))).read();
-        Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = RoutingAlgorithmSpecialAreaTests.
-                createAlgos(graph, null, encoder, false, new ShortestWeighting(), eManager);
-        for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
+        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile))).read();
+        Collection<AlgoHelperEntry> prepares = createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED,
+                new ShortestWeighting(), eManager);
+        for (AlgoHelperEntry entry : prepares)
         {
-            AlgorithmPreparation prepare = entry.getKey();
             StopWatch sw = new StopWatch();
             for (int i = 0; i < N; i++)
             {
                 int node1 = Math.abs(rand.nextInt(graph.getNodes()));
                 int node2 = Math.abs(rand.nextInt(graph.getNodes()));
-                RoutingAlgorithm d = prepare.createAlgo();
+                RoutingAlgorithm d = entry.createAlgo(graph);
                 if (i >= noJvmWarming)
                     sw.start();
 
@@ -358,9 +580,9 @@ public void testPerformance() throws IOException
             }
 
             float perRun = sw.stop().getSeconds() / ((float) (N - noJvmWarming));
-            System.out.println("# " + getClass().getSimpleName() + " " + prepare.createAlgo().getName()
+            System.out.println("# " + getClass().getSimpleName() + " " + entry
                     + ":" + sw.stop().getSeconds() + ", per run:" + perRun);
-            assertTrue("speed to low!? " + perRun + " per run", perRun < 0.07);
+            assertTrue("speed to low!? " + perRun + " per run", perRun < 0.08);
         }
     }
 
@@ -368,12 +590,16 @@ public void testPerformance() throws IOException
     public void testMonacoParallel() throws IOException
     {
         System.out.println("testMonacoParallel takes a bit time...");
-        String graphFile = "target/graph-monaco";
+        String graphFile = "target/monaco-gh";
         Helper.removeDir(new File(graphFile));
         final EncodingManager encodingManager = new EncodingManager("CAR");
-        GraphHopper hopper = new GraphHopper().setInMemory(true, true).setEncodingManager(encodingManager).
-                disableCHShortcuts().
-                setOSMFile("files/monaco.osm.gz").setGraphHopperLocation(graphFile).
+        GraphHopper hopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setEncodingManager(encodingManager).
+                setCHEnable(false).
+                setWayPointMaxDistance(0).
+                setOSMFile("files/monaco.osm.gz").
+                setGraphHopperLocation(graphFile).
                 importOrLoad();
         final Graph g = hopper.getGraph();
         final LocationIndex idx = hopper.getLocationIndex();
@@ -381,23 +607,22 @@ public void testMonacoParallel() throws IOException
         List<Thread> threads = new ArrayList<Thread>();
         final AtomicInteger integ = new AtomicInteger(0);
         int MAX = 100;
-        FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
+        final FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
 
         // testing if algorithms are independent. should be. so test only two algorithms. 
         // also the preparing is too costly to be called for every thread
         int algosLength = 2;
-        Weighting weighting = new ShortestWeighting();
+        final Weighting weighting = new ShortestWeighting();
         final EdgeFilter filter = new DefaultEdgeFilter(carEncoder);
         for (int no = 0; no < MAX; no++)
         {
             for (int instanceNo = 0; instanceNo < instances.size(); instanceNo++)
             {
-                RoutingAlgorithm[] algos = new RoutingAlgorithm[]
+                String[] algos = new String[]
                 {
-                    new AStar(g, carEncoder, weighting),
-                    new DijkstraBidirectionRef(g, carEncoder, weighting)
+                    "astar", "dijkstrabi"
                 };
-                for (final RoutingAlgorithm algo : algos)
+                for (final String algoStr : algos)
                 {
                     // an algorithm is not thread safe! reuse via clear() is ONLY appropriated if used from same thread!
                     final int instanceIndex = instanceNo;
@@ -407,9 +632,9 @@ public void testMonacoParallel() throws IOException
                         public void run()
                         {
                             OneRun oneRun = instances.get(instanceIndex);
-                            QueryResult from = idx.findClosest(oneRun.fromLat, oneRun.fromLon, filter);
-                            QueryResult to = idx.findClosest(oneRun.toLat, oneRun.toLon, filter);
-                            testCollector.assertDistance(algo, from, to, oneRun.dist, oneRun.locs);
+                            AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(weighting).algorithm(algoStr).build();
+                            testCollector.assertDistance(new AlgoHelperEntry(g, opts, idx),
+                                    oneRun.getList(idx, filter), oneRun);
                             integ.addAndGet(1);
                         }
                     };
@@ -432,29 +657,49 @@ public void run()
 
         assertEquals(MAX * algosLength * instances.size(), integ.get());
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+        hopper.close();
     }
 
-    static class OneRun
+    static List<AlgoHelperEntry> createAlgos( Graph g,
+            LocationIndex idx, final FlagEncoder encoder, boolean withCh,
+            final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
     {
-        double fromLat, fromLon;
-        double toLat, toLon;
-        double dist;
-        int locs;
-
-        public OneRun( double fromLat, double fromLon, double toLat, double toLon, double dist, int locs )
+        List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
+        // later: include dijkstraOneToMany        
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
+
+        final AlgorithmOptions astarbiOpts = new AlgorithmOptions(AlgorithmOptions.ASTAR_BI, encoder, weighting, tMode);
+        astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
+        final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting, tMode);
+        prepare.add(new AlgoHelperEntry(g, astarbiOpts, idx));
+        prepare.add(new AlgoHelperEntry(g, dijkstrabiOpts, idx));
+
+        if (withCh)
         {
-            this.fromLat = fromLat;
-            this.fromLon = fromLon;
-            this.toLat = toLat;
-            this.toLon = toLon;
-            this.dist = dist;
-            this.locs = locs;
-        }
+            final LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
+                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
+            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(graphCH, encoder, weighting, tMode);
+            prepareCH.doWork();
+            LocationIndex idxCH = new LocationIndexTree(graphCH.getBaseGraph(), new RAMDirectory()).prepareIndex();
+            prepare.add(new AlgoHelperEntry(graphCH, dijkstrabiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, dijkstrabiOpts);
+                }
+            });
 
-        @Override
-        public String toString()
-        {
-            return fromLat + "," + fromLon + " -> " + toLat + "," + toLon + " with dist " + dist + " and locs " + locs;
+            prepare.add(new AlgoHelperEntry(graphCH, astarbiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, astarbiOpts);
+                }
+            });
         }
+        return prepare;
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index af38659d67..9dd71bd9c2 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -17,15 +17,11 @@
  */
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.util.EdgeSkipExplorer;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.EdgeSkipIterState;
@@ -41,7 +37,7 @@
  */
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester
 {
-    // graph is expensive to create and to prepare!
+    // matrix graph is expensive to create and to prepare!
     private static Graph preparedMatrixGraph;
 
     @Override
@@ -49,25 +45,32 @@ public Graph getMatrixGraph()
     {
         if (preparedMatrixGraph == null)
         {
-            LevelGraph lg = createGraph();
+            LevelGraph lg = (LevelGraph) createGraph(false);
             getMatrixAlikeGraph().copyTo(lg);
-            prepareGraph(lg);
+            createFactory(lg, defaultOpts);
             preparedMatrixGraph = lg;
         }
         return preparedMatrixGraph;
     }
 
     @Override
-    protected LevelGraph createGraph()
+    protected LevelGraph createGraph( EncodingManager em, boolean is3D )
     {
-        return new GraphBuilder(encodingManager).levelGraphCreate();
+        return new GraphBuilder(em).set3D(is3D).levelGraphCreate();
     }
 
     @Override
-    public PrepareContractionHierarchies prepareGraph( Graph g, FlagEncoder encoder, Weighting w )
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
     {
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(encoder, w).setGraph(g);
-        // hack: prepare matrixgraph only once
+        return createFactory(g, opts).createAlgo(g, opts);
+    }
+
+    @Override
+    public RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts )
+    {
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies((LevelGraph) g,
+                opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
+        // hack: prepare matrixGraph only once
         if (g != preparedMatrixGraph)
             ch.doWork();
 
@@ -77,10 +80,13 @@ public PrepareContractionHierarchies prepareGraph( Graph g, FlagEncoder encoder,
     @Test
     public void testPathRecursiveUnpacking()
     {
-        LevelGraphStorage g2 = (LevelGraphStorage) createGraph();
+        // use an encoder where it is possible to store 2 weights per edge
+        FlagEncoder encoder = new Bike2WeightFlagEncoder();
+        EncodingManager em = new EncodingManager(encoder);
+        LevelGraphStorage g2 = (LevelGraphStorage) createGraph(em, false);
         g2.edge(0, 1, 1, true);
-        EdgeIteratorState iter1_1 = g2.edge(0, 2, 1.4, true);
-        EdgeIteratorState iter1_2 = g2.edge(2, 5, 1.4, true);
+        EdgeIteratorState iter1_1 = g2.edge(0, 2, 1.4, false);
+        EdgeIteratorState iter1_2 = g2.edge(2, 5, 1.4, false);
         g2.edge(1, 2, 1, true);
         g2.edge(1, 3, 3, true);
         g2.edge(2, 3, 1, true);
@@ -89,17 +95,16 @@ public void testPathRecursiveUnpacking()
         g2.edge(3, 5, 1, true);
         g2.edge(5, 6, 1, true);
         g2.edge(4, 6, 1, true);
-        g2.edge(5, 7, 1.4, true);
         g2.edge(6, 7, 1, true);
+        EdgeIteratorState iter2_2 = g2.edge(5, 7);
+        iter2_2.setDistance(1.4).setFlags(encoder.setProperties(10, true, false));
 
         // simulate preparation
-        EdgeIteratorState iter2_2 = g2.edge(5, 7);
-        iter2_2.setDistance(1.4).setFlags(carEncoder.setProperties(0, true, true));
         EdgeSkipIterState iter2_1 = g2.shortcut(0, 5);
-        iter2_1.setDistance(2.8).setFlags(carEncoder.setProperties(0, true, true));
+        iter2_1.setDistance(2.8).setFlags(encoder.setProperties(10, true, false));
         iter2_1.setSkippedEdges(iter1_1.getEdge(), iter1_2.getEdge());
         EdgeSkipIterState tmp = g2.shortcut(0, 7);
-        tmp.setDistance(4.2).setFlags(carEncoder.setProperties(0, true, true));
+        tmp.setDistance(4.2).setFlags(encoder.setProperties(10, true, false));
         tmp.setSkippedEdges(iter2_1.getEdge(), iter2_2.getEdge());
         g2.setLevel(1, 0);
         g2.setLevel(3, 1);
@@ -110,9 +115,85 @@ public void testPathRecursiveUnpacking()
         g2.setLevel(7, 6);
         g2.setLevel(0, 7);
 
-        Path p = new PrepareContractionHierarchies(carEncoder, new ShortestWeighting()).setGraph(g2).createAlgo().calcPath(0, 7);
+        ShortestWeighting weighting = new ShortestWeighting();
+        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
+        Path p = new PrepareContractionHierarchies(g2, encoder, weighting, TraversalMode.NODE_BASED).
+                createAlgo(g2, opts).calcPath(0, 7);
+
         assertEquals(Helper.createTList(0, 2, 5, 7), p.calcNodes());
-        assertEquals(4, p.calcNodes().size());
+        assertEquals(1064, p.getMillis());
         assertEquals(4.2, p.getDistance(), 1e-5);
     }
+
+    @Override
+    public void testCalcFootPath()
+    {
+        // disable car encoder and move foot to first position => workaround as CH does not allow multiple vehicles
+        FlagEncoder tmpFootEncoder = footEncoder;
+        FlagEncoder tmpCarEncoder = carEncoder;
+        carEncoder = new CarFlagEncoder()
+        {
+            @Override
+            public long setProperties( double speed, boolean forward, boolean backward )
+            {
+                return 0;
+            }
+        };
+
+        footEncoder = new FootFlagEncoder();
+        new EncodingManager(footEncoder);
+        
+        super.testCalcFootPath();
+        footEncoder = tmpFootEncoder;
+        carEncoder = tmpCarEncoder;
+    }
+
+    @Test
+    public void testBaseGraph()
+    {
+        CarFlagEncoder carFE = new CarFlagEncoder();
+        Graph g = createGraph(new EncodingManager(carFE), false);
+        initDirectedAndDiffSpeed(g, carFE);
+
+        // do CH preparation for car
+        createFactory(g, defaultOpts);
+
+        // use base graph for solving normal Dijkstra
+        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(g, defaultOpts).calcPath(0, 3);
+        assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
+        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 144823, p1.getMillis());
+    }
+
+    @Test
+    public void testBaseGraphMultipleVehicles()
+    {
+        Graph g = createGraph(encodingManager, false);
+        initFootVsCar(g);
+
+        AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new FastestWeighting(footEncoder)).build();
+        AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new FastestWeighting(carEncoder)).build();
+
+        // do CH preparation for car
+        RoutingAlgorithmFactory contractedFactory = createFactory(g, carOptions);
+
+        // use contracted graph
+        Path p1 = contractedFactory.createAlgo(g, carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p1.calcNodes());
+        assertEquals(p1.toString(), 15000, p1.getDistance(), 1e-6);
+
+        // use base graph for solving normal Dijkstra via car
+        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p2.calcNodes());
+        assertEquals(p2.toString(), 15000, p2.getDistance(), 1e-6);
+        assertEquals(p2.toString(), 2700 * 1000, p2.getMillis());
+
+        // use base graph for solving normal Dijkstra via foot
+        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), footOptions).calcPath(0, 7);
+        assertEquals(p3.toString(), 17000, p3.getDistance(), 1e-6);
+        assertEquals(p3.toString(), 12240 * 1000, p3.getMillis());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index e1b62879d9..566ae7a8cb 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -17,16 +17,12 @@
  */
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.Dijkstra;
-import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies.Shortcut;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.util.EdgeSkipExplorer;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.*;
 import java.util.Collection;
@@ -39,9 +35,10 @@
  */
 public class PrepareContractionHierarchiesTest
 {
-    private final Weighting weighting = new ShortestWeighting();
     private final EncodingManager encodingManager = new EncodingManager("CAR");
     private final CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
+    private final Weighting weighting = new ShortestWeighting();
+    private final TraversalMode tMode = TraversalMode.NODE_BASED;
 
     LevelGraph createGraph()
     {
@@ -72,10 +69,13 @@ LevelGraph createExampleGraph()
     public void testShortestPathSkipNode()
     {
         LevelGraph g = createExampleGraph();
-        double normalDist = new Dijkstra(g, carEncoder, weighting).calcPath(4, 2).getDistance();
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(100).findEndNode(4, 2);
+        double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
+        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(100);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
 
         algo.clear();
@@ -87,14 +87,17 @@ public void testShortestPathSkipNode()
     public void testShortestPathSkipNode2()
     {
         LevelGraph g = createExampleGraph();
-        double normalDist = new Dijkstra(g, carEncoder, weighting).calcPath(4, 2).getDistance();
+        double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         assertEquals(3, normalDist, 1e-5);
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(10).findEndNode(4, 2);
+        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(10);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
 
-        nodeEntry = algo.setLimitWeight(10).findEndNode(4, 1);
+        nodeEntry = algo.findEndNode(4, 1);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
     }
 
@@ -102,9 +105,12 @@ public void testShortestPathSkipNode2()
     public void testShortestPathLimit()
     {
         LevelGraph g = createExampleGraph();
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(0));
-        int endNode = algo.setLimitWeight(2).findEndNode(4, 1);
+        DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(0));
+        algo.setWeightLimit(2);
+        int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
         assertNotEquals(1, endNode);
     }
@@ -113,20 +119,20 @@ public void testShortestPathLimit()
     public void testAddShortcuts()
     {
         LevelGraph g = createExampleGraph();
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 1, g.getAllEdges().getMaxId());
+        assertEquals(old + 1, g.getAllEdges().getCount());
     }
 
     @Test
     public void testMoreComplexGraph()
     {
         LevelGraph g = initShortcutsGraph(createGraph());
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 10, g.getAllEdges().getMaxId());
+        assertEquals(old + 10, g.getAllEdges().getCount());
     }
 
     @Test
@@ -140,11 +146,10 @@ public void testDirectedGraph()
         g.edge(3, 5, 1, false);
         g.edge(4, 3, 1, false);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        // PrepareTowerNodesShortcutsTest.printEdges(g);
         assertEquals(old + 2, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo();
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 2);
         assertEquals(3, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(4, 3, 5, 2), p.calcNodes());
@@ -156,11 +161,11 @@ public void testDirectedGraph2()
         LevelGraph g = createGraph();
         initDirected2(g);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
         assertEquals(old + 9, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo();
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
@@ -172,8 +177,8 @@ public void testDirectedGraph3()
         LevelGraph g = createGraph();
         //5 6 7
         // \|/
-        //4-3_1<-  0
-        //    \_|/_10
+        //4-3_1<-
+        //    \_|_10
         //   0__2_11
 
         g.edge(0, 2, 2, true);
@@ -189,8 +194,9 @@ public void testDirectedGraph3()
         g.edge(3, 6, 2, true);
         g.edge(3, 7, 2, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.initFromGraph();
+        prepare.prepareNodes();
         // find all shortcuts if we contract node 1
         Collection<Shortcut> scs = prepare.testFindShortcuts(1);
         assertEquals(2, scs.size());
@@ -206,7 +212,7 @@ public void testDirectedGraph3()
 
         // both dirs
         assertTrue(sc1.toString(), sc1.from == 3 && sc1.to == 2);
-        assertTrue(sc1.toString(), carEncoder.isBoth(sc1.flags));
+        assertTrue(sc1.toString(), carEncoder.isForward(sc1.flags) && carEncoder.isBackward(sc1.flags));
 
         // directed
         assertTrue(sc2.toString(), sc2.from == 2 && sc2.to == 3);
@@ -273,11 +279,11 @@ public void testRoundaboutUnpacking()
     {
         LevelGraph g = createGraph();
         initRoundaboutGraph(g);
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 23, g.getAllEdges().getMaxId());
-        RoutingAlgorithm algo = prepare.createAlgo();
+        assertEquals(old + 22, g.getAllEdges().getCount());
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 7);
         assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
     }
@@ -293,24 +299,29 @@ public void testFindShortcuts_Roundabout()
         EdgeIteratorState iter3_1 = g.edge(6, 7, 1, true);
         EdgeIteratorState iter3_2 = g.edge(6, 8, 2, false);
         g.edge(8, 4, 1, false);
-        g.setLevel(3, 3);
-        g.setLevel(5, 5);
-        g.setLevel(7, 7);
-        g.setLevel(8, 8);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         EdgeSkipIterState tmp = g.shortcut(1, 4);
-        tmp.setDistance(2).setFlags(prepare.getScBothDir());
+        tmp.setFlags(PrepareEncoder.getScDirMask());
+        tmp.setWeight(2);
         tmp.setSkippedEdges(iter1_1.getEdge(), iter1_2.getEdge());
-        long f = prepare.getScOneDir();
+        long f = PrepareEncoder.getScFwdDir();
         tmp = g.shortcut(4, 6);
-        tmp.setDistance(2).setFlags(f);
+        tmp.setFlags(f);
+        tmp.setWeight(2);
         tmp.setSkippedEdges(iter2_1.getEdge(), iter2_2.getEdge());
         tmp = g.shortcut(6, 4);
-        tmp.setDistance(3).setFlags(f);
+        tmp.setFlags(f);
+        tmp.setWeight(3);
         tmp.setSkippedEdges(iter3_1.getEdge(), iter3_2.getEdge());
 
         prepare.initFromGraph();
+        prepare.prepareNodes();
+        g.setLevel(3, 3);
+        g.setLevel(5, 5);
+        g.setLevel(7, 7);
+        g.setLevel(8, 8);
+
         // there should be two different shortcuts for both directions!
         Collection<Shortcut> sc = prepare.testFindShortcuts(4);
         assertEquals(2, sc.size());
@@ -319,51 +330,38 @@ public void testFindShortcuts_Roundabout()
     void initUnpackingGraph( LevelGraphStorage g, Weighting w )
     {
         final long flags = carEncoder.setProperties(30, true, false);
-        EdgeIterator edge = new GHUtility.DisabledEdgeIterator()
-        {
-
-            @Override
-            public double getDistance()
-            {
-                return 1;
-            }
-
-            @Override
-            public long getFlags()
-            {
-                return flags;
-            }
-        };
-        g.edge(10, 0).setDistance(w.calcWeight(edge)).setFlags(flags);
+        double dist = 1;
+        g.edge(10, 0).setDistance(dist).setFlags(flags);
         EdgeIteratorState iterTmp1 = g.edge(0, 1);
-        iterTmp1.setDistance(w.calcWeight(edge)).setFlags(flags);
-        EdgeIteratorState iter2 = g.edge(1, 2).setDistance(w.calcWeight(edge)).setFlags(flags);
-        EdgeIteratorState iter3 = g.edge(2, 3).setDistance(w.calcWeight(edge)).setFlags(flags);
-        EdgeIteratorState iter4 = g.edge(3, 4).setDistance(w.calcWeight(edge)).setFlags(flags);
-        EdgeIteratorState iter5 = g.edge(4, 5).setDistance(w.calcWeight(edge)).setFlags(flags);
-        EdgeIteratorState iter6 = g.edge(5, 6).setDistance(w.calcWeight(edge)).setFlags(flags);
-        long oneDirFlags = new PrepareContractionHierarchies(carEncoder, w).getScOneDir();
+        iterTmp1.setDistance(dist).setFlags(flags);
+        EdgeIteratorState iter2 = g.edge(1, 2).setDistance(dist).setFlags(flags);
+        EdgeIteratorState iter3 = g.edge(2, 3).setDistance(dist).setFlags(flags);
+        EdgeIteratorState iter4 = g.edge(3, 4).setDistance(dist).setFlags(flags);
+        EdgeIteratorState iter5 = g.edge(4, 5).setDistance(dist).setFlags(flags);
+        EdgeIteratorState iter6 = g.edge(5, 6).setDistance(dist).setFlags(flags);
+        long oneDirFlags = PrepareEncoder.getScFwdDir();
 
         int tmp = iterTmp1.getEdge();
-        EdgeSkipIterState iter1 = g.shortcut(0, 2);
-        iter1.setDistance(2).setFlags(oneDirFlags);
-        iter1.setSkippedEdges(tmp, iter2.getEdge());
-        tmp = iter1.getEdge();
-        iter1 = g.shortcut(0, 3);
-        iter1.setDistance(3).setFlags(oneDirFlags);
-        iter1.setSkippedEdges(tmp, iter3.getEdge());
-        tmp = iter1.getEdge();
-        iter1 = g.shortcut(0, 4);
-        iter1.setDistance(4).setFlags(oneDirFlags);
-        iter1.setSkippedEdges(tmp, iter4.getEdge());
-        tmp = iter1.getEdge();
-        iter1 = g.shortcut(0, 5);
-        iter1.setDistance(5).setFlags(oneDirFlags);
-        iter1.setSkippedEdges(tmp, iter5.getEdge());
-        tmp = iter1.getEdge();
-        iter1 = g.shortcut(0, 6);
-        iter1.setDistance(6).setFlags(oneDirFlags);
-        iter1.setSkippedEdges(tmp, iter6.getEdge());
+        EdgeSkipIterState sc1 = g.shortcut(0, 2);
+        int x = EdgeIterator.NO_EDGE;
+        sc1.setWeight(w.calcWeight(iterTmp1, false, x) + w.calcWeight(iter2, false, x)).setDistance(2 * dist).setFlags(oneDirFlags);
+        sc1.setSkippedEdges(tmp, iter2.getEdge());
+        tmp = sc1.getEdge();
+        EdgeSkipIterState sc2 = g.shortcut(0, 3);
+        sc2.setWeight(w.calcWeight(sc1, false, x) + w.calcWeight(iter3, false, x)).setDistance(3 * dist).setFlags(oneDirFlags);
+        sc2.setSkippedEdges(tmp, iter3.getEdge());
+        tmp = sc2.getEdge();
+        sc1 = g.shortcut(0, 4);
+        sc1.setWeight(w.calcWeight(sc2, false, x) + w.calcWeight(iter4, false, x)).setDistance(4).setFlags(oneDirFlags);
+        sc1.setSkippedEdges(tmp, iter4.getEdge());
+        tmp = sc1.getEdge();
+        sc2 = g.shortcut(0, 5);
+        sc2.setWeight(w.calcWeight(sc1, false, x) + w.calcWeight(iter5, false, x)).setDistance(5).setFlags(oneDirFlags);
+        sc2.setSkippedEdges(tmp, iter5.getEdge());
+        tmp = sc2.getEdge();
+        sc1 = g.shortcut(0, 6);
+        sc1.setWeight(w.calcWeight(sc2, false, x) + w.calcWeight(iter6, false, x)).setDistance(6).setFlags(oneDirFlags);
+        sc1.setSkippedEdges(tmp, iter6.getEdge());
         g.setLevel(0, 10);
         g.setLevel(6, 9);
         g.setLevel(5, 8);
@@ -379,8 +377,8 @@ public void testUnpackingOrder()
     {
         LevelGraphStorage g = (LevelGraphStorage) createGraph();
         initUnpackingGraph(g, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
-        RoutingAlgorithm algo = prepare.createAlgo();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -393,8 +391,8 @@ public void testUnpackingOrder_Fastest()
         Weighting w = new FastestWeighting(carEncoder);
         initUnpackingGraph(g, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, w).setGraph(g);
-        RoutingAlgorithm algo = prepare.createAlgo();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -411,11 +409,35 @@ public void testCircleBug()
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting).setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
 
+    @Test
+    public void testBug178()
+    {
+        // 5--------6__
+        // |        |  \
+        // 0-1->-2--3--4
+        //   \-<-/
+        //
+        LevelGraph g = createGraph();
+        g.edge(1, 2, 1, false);
+        g.edge(2, 1, 1, false);
+
+        g.edge(5, 0, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(0, 1, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(6, 3, 1, true);
+
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.doWork();
+        assertEquals(2, prepare.getShortcuts());
+    }
+
     // 0-1-2-3-4
     // |     / |
     // |    8  |
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
new file mode 100644
index 0000000000..27e3d9415e
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class PrepareEncoderTest
+{
+
+    @Test
+    public void testOverwrite()
+    {
+        long forward = PrepareEncoder.getScFwdDir();
+        long backward = PrepareEncoder.getScFwdDir() ^ PrepareEncoder.getScDirMask();
+        long both = PrepareEncoder.getScDirMask();
+        assertTrue(PrepareEncoder.canBeOverwritten(forward, forward));
+        assertTrue(PrepareEncoder.canBeOverwritten(backward, backward));
+        assertTrue(PrepareEncoder.canBeOverwritten(forward, both));
+        assertTrue(PrepareEncoder.canBeOverwritten(backward, both));
+
+        assertTrue(PrepareEncoder.canBeOverwritten(both, both));
+        assertFalse(PrepareEncoder.canBeOverwritten(both, forward));
+        assertFalse(PrepareEncoder.canBeOverwritten(both, backward));
+        assertFalse(PrepareEncoder.canBeOverwritten(forward, backward));
+        assertFalse(PrepareEncoder.canBeOverwritten(backward, forward));
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index dd7e175197..5485a7a5bd 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -17,17 +17,13 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
-import com.graphhopper.util.InstructionList;
-import com.graphhopper.util.TranslationMap;
+import static com.graphhopper.routing.util.PriorityCode.*;
+import com.graphhopper.util.Translation;
 import static com.graphhopper.util.TranslationMapTest.SINGLETON;
-import java.util.HashMap;
 import java.util.Locale;
-import java.util.Map;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -37,7 +33,7 @@
  */
 public abstract class AbstractBikeFlagEncoderTester
 {
-    protected BikeFlagCommonEncoder encoder;
+    protected BikeCommonFlagEncoder encoder;
 
     @Before
     public void setUp()
@@ -45,197 +41,368 @@ public void setUp()
         encoder = createBikeEncoder();
     }
 
-    abstract BikeFlagCommonEncoder createBikeEncoder();
+    protected abstract BikeCommonFlagEncoder createBikeEncoder();
 
-    public int getEncodedDecodedSpeed( OSMWay way )
+    protected void assertPriority( int expectedPrio, OSMWay way )
+    {
+        assertPriority(expectedPrio, way, 0);
+    }
+
+    protected void assertPriority( int expectedPrio, OSMWay way, long relationFlags )
+    {
+        assertEquals(expectedPrio, encoder.handlePriority(way, (int) encoder.relationCodeEncoder.getValue(relationFlags)));
+    }
+
+    protected double getSpeedFromFlags( OSMWay way )
     {
         long allowed = encoder.acceptBit;
         long flags = encoder.handleWayTags(way, allowed, 0);
         return encoder.getSpeed(flags);
     }
 
-    public String encodeDecodeWayType( String name, OSMWay way )
+    protected String getWayTypeFromFlags( OSMWay way )
     {
-        long allowed = encoder.acceptBit;
-        long flags = encoder.handleWayTags(way, allowed, 0);
-        int pavement = encoder.getPavementCode(flags);
-        int wayType = encoder.getWayTypeCode(flags);
+        return getWayTypeFromFlags(way, 0);
+    }
 
-        TranslationMap.Translation enMap = SINGLETON.getWithFallBack(Locale.UK);
-        return InstructionList.getWayName(name, pavement, wayType, enMap);
+    protected String getWayTypeFromFlags( OSMWay way, long relationFlags )
+    {
+        long allowed = encoder.acceptBit;
+        long flags = encoder.handleWayTags(way, allowed, relationFlags);
+        Translation enMap = SINGLETON.getWithFallBack(Locale.UK);
+        return encoder.getAnnotation(flags, enMap).getMessage();
     }
 
     @Test
     public void testAccess()
     {
-        Map<String, String> map = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, map);
+        OSMWay way = new OSMWay(1);
 
-        map.put("highway", "motorway");
+        way.setTag("highway", "motorway");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        map.put("highway", "footway");
+        way.setTag("highway", "motorway");
+        way.setTag("bicycle", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("highway", "footway");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.put("bicycle", "no");
+        way.setTag("bicycle", "no");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        map.put("highway", "footway");
-        map.put("bicycle", "yes");
+        way.setTag("highway", "footway");
+        way.setTag("bicycle", "yes");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.put("highway", "pedestrian");
-        map.put("bicycle", "no");
+        way.setTag("highway", "pedestrian");
+        way.setTag("bicycle", "no");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        map.put("highway", "pedestrian");
-        map.put("bicycle", "yes");
+        way.setTag("highway", "pedestrian");
+        way.setTag("bicycle", "yes");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.put("bicycle", "yes");
-        map.put("highway", "cycleway");
+        way.setTag("bicycle", "yes");
+        way.setTag("highway", "cycleway");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "path");
+        way.clearTags();
+        way.setTag("highway", "path");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.put("highway", "path");
-        map.put("bicycle", "yes");
+        way.setTag("highway", "path");
+        way.setTag("bicycle", "yes");
         assertTrue(encoder.acceptWay(way) > 0);
-        map.clear();
+        way.clearTags();
 
-        map.put("highway", "track");
-        map.put("bicycle", "yes");
+        way.setTag("highway", "track");
+        way.setTag("bicycle", "yes");
         assertTrue(encoder.acceptWay(way) > 0);
-        map.clear();
+        way.clearTags();
 
-        map.put("highway", "track");
+        way.setTag("highway", "track");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.put("mtb", "yes");
+        way.setTag("mtb", "yes");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "path");
-        map.put("foot", "official");
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("foot", "official");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.put("bicycle", "official");
+        way.setTag("bicycle", "official");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "service");
-        map.put("access", "no");
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "no");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "tertiary");
-        map.put("motorroad", "yes");
+        way.clearTags();
+        way.setTag("highway", "tertiary");
+        way.setTag("motorroad", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "track");
-        map.put("ford", "yes");
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("ford", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
-        map.put("bicycle", "yes");
+        way.setTag("bicycle", "yes");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("route", "ferry");
+        way.clearTags();
+        way.setTag("route", "ferry");
         assertTrue(encoder.acceptWay(way) > 0);
-        map.put("bicycle", "no");
+        way.setTag("bicycle", "no");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("route", "ferry");
-        map.put("foot", "yes");
+        way.clearTags();
+        way.setTag("route", "ferry");
+        way.setTag("foot", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "cycleway");
+        way.setTag("cycleway", "track");
+        way.setTag("railway", "abandoned");
+        assertTrue(encoder.acceptWay(way) > 0);
     }
 
     @Test
     public void testTramStations()
     {
-        Map<String, String> map = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, map);
-        map.put("highway", "secondary");
-        map.put("railway", "rail");
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "secondary");
+        way.setTag("railway", "rail");
         // disallow rail
         assertEquals(0, encoder.acceptWay(way));
 
-        way = new OSMWay(1, map);
-        map.put("highway", "secondary");
-        map.put("railway", "station");
+        way = new OSMWay(1);
+        way.setTag("highway", "secondary");
+        way.setTag("railway", "station");
         // disallow stations
         assertEquals(0, encoder.acceptWay(way));
 
-        way = new OSMWay(1, map);
-        map.put("highway", "secondary");
-        map.put("railway", "station");
-        map.put("bicycle", "yes");
+        way = new OSMWay(1);
+        way.setTag("highway", "secondary");
+        way.setTag("railway", "station");
+        way.setTag("bicycle", "yes");
         // allow stations if explicitely tagged
         assertNotSame(0, encoder.acceptWay(way));
 
-        way = new OSMWay(1, map);
-        map.put("highway", "secondary");
-        map.put("railway", "station");
-        map.put("bicycle", "no");
+        way = new OSMWay(1);
+        way.setTag("highway", "secondary");
+        way.setTag("railway", "station");
+        way.setTag("bicycle", "no");
         // disallow
         assertEquals(0, encoder.acceptWay(way));
     }
 
+    @Test
+    public void testAvoidTunnel()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "residential");
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("tunnel", "yes");
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("highway", "secondary");
+        osmWay.setTag("tunnel", "yes");
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
+
+        osmWay.setTag("bicycle", "designated");
+        assertPriority(PREFER.getValue(), osmWay);
+    }
+
+    @Test
+    public void testTram()
+    {
+        OSMWay way = new OSMWay(1);
+        // very dangerous
+        way.setTag("highway", "secondary");
+        way.setTag("railway", "tram");
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), way);
+
+        // should be safe now
+        way.setTag("bicycle", "designated");
+        assertPriority(PREFER.getValue(), way);
+    }
+
     @Test
     public void testHandleCommonWayTags()
     {
-        Map<String, String> wayMap = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, wayMap);
+        OSMWay way = new OSMWay(1);
         String wayType;
 
-        wayMap.put("highway", "steps");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
+        way.setTag("highway", "steps");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
 
-        wayMap.put("highway", "steps");
-        wayType = encodeDecodeWayType("Famous steps", way);
-        assertEquals("Famous steps, pushing section", wayType);
+        way.setTag("highway", "footway");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
 
-        wayMap.put("highway", "footway");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
+        way.setTag("highway", "footway");
+        way.setTag("surface", "pebblestone");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
 
-        wayMap.put("highway", "footway");
-        wayMap.put("surface", "pebblestone");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
+        way.setTag("highway", "residential");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
+        assertPriority(PREFER.getValue(), way);
 
-        wayMap.put("highway", "residential");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("road", wayType);
-
-        wayMap.put("highway", "cycleway");
-        wayType = encodeDecodeWayType("", way);
+        way.clearTags();
+        way.setTag("highway", "cycleway");
+        wayType = getWayTypeFromFlags(way);
         assertEquals("cycleway", wayType);
+        assertPriority(VERY_NICE.getValue(), way);
 
-        wayMap.put("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
+        way.setTag("surface", "grass");
+        wayType = getWayTypeFromFlags(way);
         assertEquals("cycleway, unpaved", wayType);
 
-        wayMap.put("surface", "asphalt");
-        wayType = encodeDecodeWayType("", way);
+        way.setTag("surface", "asphalt");
+        wayType = getWayTypeFromFlags(way);
         assertEquals("cycleway", wayType);
+        assertPriority(VERY_NICE.getValue(), way);
 
-        wayMap.put("highway", "footway");
-        wayMap.put("bicycle", "yes");
-        wayMap.put("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("cycleway, unpaved", wayType);
+        way.setTag("highway", "footway");
+        way.setTag("bicycle", "yes");
+        way.setTag("surface", "grass");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("way, unpaved", wayType);
 
-        wayMap.clear();
-        wayMap.put("highway", "footway");
-        wayMap.put("bicycle", "yes");
-        wayMap.put("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
+        way.setTag("bicycle", "designated");
+        wayType = getWayTypeFromFlags(way);
         assertEquals("cycleway, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "footway");
+        way.setTag("bicycle", "yes");
+        way.setTag("surface", "grass");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("way, unpaved", wayType);
     }
 
+    @Test
+    public void testService()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        assertEquals(14, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
+        way.setTag("service", "parking_aisle");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+    }
+
+    @Test
+    public void testSacScale()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        way.setTag("sac_scale", "hiking");
+        // allow
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("sac_scale", "alpine_hiking");
+        assertTrue(encoder.acceptWay(way) == 0);
+    }
+
+    @Test
+    public void testReduceToMaxSpeed()
+    {
+        OSMWay way = new OSMWay(12);
+        way.setTag("maxspeed", "90");
+        assertEquals(12, encoder.applyMaxSpeed(way, 12, false), 1e-2);
+    }
+
+    @Test
+    public void testMaxAndMinSpeed()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "tertiary");
+        assertEquals(30, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 49, false))), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay);
+
+        osmWay.setTag("highway", "tertiary");
+        osmWay.setTag("maxspeed", "90");
+        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20, false))), 1e-1);
+        assertPriority(REACH_DEST.getValue(), osmWay);
+    }
+
+    @Test
+    public void testHandleWayTagsCallsHandlePriority()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "cycleway");
+        long encoded = encoder.handleWayTags(osmWay, encoder.acceptBit, 0);
+        assertEquals((double) VERY_NICE.getValue() / BEST.getValue(), encoder.getDouble(encoded, PriorityWeighting.KEY), 1e-3);
+    }
+
+    @Test
+    public void testAvoidMotorway()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "motorway");
+        osmWay.setTag("bicycle", "yes");
+        assertPriority(REACH_DEST.getValue(), osmWay);
+    }
+
+    @Test
+    public void testPriority()
+    {
+        long flags = encoder.setLong(0L, PriorityWeighting.KEY, PriorityCode.BEST.getValue());
+        assertEquals(1, encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+
+        flags = encoder.setLong(0L, PriorityWeighting.KEY, PriorityCode.AVOID_IF_POSSIBLE.getValue());
+        assertEquals(3d / 7d, encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+    }
+
+    @Test
+    public void testBarrierAccess()
+    {
+        // by default allow access through the gate for bike & foot!
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        // no barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        node.setTag("bicycle", "yes");
+        // no barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "yes");
+        node.setTag("bicycle", "no");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        node.setTag("foot", "yes");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        node.setTag("bicycle", "yes");
+        // no barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
index 9177c6122b..2fc14399fb 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractFlagEncoderTest.java
@@ -29,15 +29,15 @@
     @Test
     public void testAcceptsCar()
     {
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40 km/h"));
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40km/h"));
-        assertEquals(40, AbstractFlagEncoder.parseSpeed("40kmh"));
-        assertEquals(64, AbstractFlagEncoder.parseSpeed("40mph"));
-        assertEquals(48, AbstractFlagEncoder.parseSpeed("30 mph"));
-        assertEquals(-1, AbstractFlagEncoder.parseSpeed(null));
-        assertEquals(19, AbstractFlagEncoder.parseSpeed("10 knots"));
-        assertEquals(19, AbstractFlagEncoder.parseSpeed("19 kph"));
-        assertEquals(19, AbstractFlagEncoder.parseSpeed("19kph"));
+        assertEquals(40, AbstractFlagEncoder.parseSpeed("40 km/h"), 1e-3);
+        assertEquals(40, AbstractFlagEncoder.parseSpeed("40km/h"), 1e-3);
+        assertEquals(40, AbstractFlagEncoder.parseSpeed("40kmh"), 1e-3);
+        assertEquals(64.374, AbstractFlagEncoder.parseSpeed("40mph"), 1e-3);
+        assertEquals(48.28, AbstractFlagEncoder.parseSpeed("30 mph"), 1e-3);
+        assertEquals(-1, AbstractFlagEncoder.parseSpeed(null), 1e-3);
+        assertEquals(18.52, AbstractFlagEncoder.parseSpeed("10 knots"), 1e-3);
+        assertEquals(19, AbstractFlagEncoder.parseSpeed("19 kph"), 1e-3);
+        assertEquals(19, AbstractFlagEncoder.parseSpeed("19kph"), 1e-3);
     }
 
     @Test
@@ -51,4 +51,11 @@ public void testParseDuration()
         assertEquals(60 * 20, AbstractFlagEncoder.parseDuration("0:20:00"));
         assertEquals(60 * 24 * 2 + 60 * 20 + 2, AbstractFlagEncoder.parseDuration("02:20:02"));
     }
+    
+    @Test
+    public void testParseProperties()
+    {
+        assertEquals(10, AbstractFlagEncoder.parseDouble("car|x", "prop", 10), .1);
+        assertEquals(12.2, AbstractFlagEncoder.parseDouble("car|x|prop=12.2", "prop", 10), .1);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
new file mode 100644
index 0000000000..51894b72b3
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
@@ -0,0 +1,80 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.OSMWay;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class Bike2WeightFlagEncoderTest extends BikeFlagEncoderTest
+{
+    private Graph initExampleGraph( FlagEncoder instance )
+    {
+        EncodingManager em = new EncodingManager(instance);
+        GraphStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true).create(1000);
+        NodeAccess na = gs.getNodeAccess();
+        // 50--(0.0001)-->49--(0.0004)-->55--(0.0005)-->60
+        na.setNode(0, 51.1, 12.001, 50);
+        na.setNode(1, 51.1, 12.002, 60);
+        EdgeIteratorState edge = gs.edge(0, 1).
+                setWayGeometry(Helper.createPointList3D(51.1, 12.0011, 49, 51.1, 12.0015, 55));
+        edge.setDistance(100);
+
+        edge.setFlags(instance.setReverseSpeed(instance.setProperties(10, true, true), 15));
+        return gs;
+    }
+
+    @Test
+    public void testApplyWayTags()
+    {
+        Bike2WeightFlagEncoder instance = new Bike2WeightFlagEncoder();
+        Graph graph = initExampleGraph(instance);
+        EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
+        OSMWay way = new OSMWay(1);
+        instance.applyWayTags(way, edge);
+
+        long flags = edge.getFlags();
+        // decrease speed
+        assertEquals(2, instance.getSpeed(flags), 1e-1);
+        // increase speed but use maximum speed (calculated was 24)
+        assertEquals(18, instance.getReverseSpeed(flags), 1e-1);
+    }
+        
+    @Test
+    public void testUnchangedForStepsBridgeAndTunnel()
+    {
+        Bike2WeightFlagEncoder instance = new Bike2WeightFlagEncoder();
+        Graph graph = initExampleGraph(instance);
+        EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
+        long oldFlags = edge.getFlags();
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "steps");
+        instance.applyWayTags(way, edge);
+
+        assertEquals(oldFlags, edge.getFlags());
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index adaf02df5f..239692901b 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -19,245 +19,383 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
-import static com.graphhopper.routing.util.BikeFlagCommonEncoder.PUSHING_SECTION_SPEED;
+import static com.graphhopper.routing.util.PriorityCode.*;
 import org.junit.Test;
 
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicInteger;
-
 import static org.junit.Assert.*;
 
 /**
- *
  * @author Peter Karich
+ * @author ratrun
  */
 public class BikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
 {
     @Override
-    BikeFlagCommonEncoder createBikeEncoder()
+    protected BikeCommonFlagEncoder createBikeEncoder()
     {
-        return (BikeFlagCommonEncoder) new EncodingManager("BIKE,MTB,RACINGBIKE").getEncoder("BIKE");
+        return (BikeCommonFlagEncoder) new EncodingManager("BIKE,MTB").getEncoder("BIKE");
     }
 
     @Test
     public void testGetSpeed()
     {
         long result = encoder.setProperties(10, true, true);
-        assertEquals(10, encoder.getSpeed(result));
+        assertEquals(10, encoder.getSpeed(result), 1e-1);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "primary");
         assertEquals(18, encoder.getSpeed(way));
+        assertPriority(REACH_DEST.getValue(), way);
 
-        way.setTag("highway", "residential");
-        assertEquals(20, encoder.getSpeed(way));
-        // Test pushing section speeds
         way.setTag("highway", "footway");
         assertEquals(4, encoder.getSpeed(way));
-        way.setTag("highway", "track");
-        assertEquals(4, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
 
-        way.setTag("highway", "steps");
-        assertEquals(2, encoder.getSpeed(way));
+        way.setTag("highway", "track");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
 
-        way.setTag("highway", "service");
-        assertEquals(20, encoder.getSpeed(way));
-        way.setTag("service", "parking_aisle");
-        assertEquals(15, encoder.getSpeed(way));
-        way.clearTags();
+        way.setTag("tracktype", "grade1");
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
 
-        // test speed for allowed pushing section types
         way.setTag("highway", "track");
-        way.setTag("bicycle", "yes");
-        assertEquals(20, encoder.getSpeed(way));
+        way.setTag("tracktype", "grade2");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
 
+        // test speed for allowed get off the bike types
         way.setTag("highway", "track");
         way.setTag("bicycle", "yes");
-        way.setTag("tracktype", "grade3");
         assertEquals(12, encoder.getSpeed(way));
 
+        way.clearTags();
+        way.setTag("highway", "steps");
+        assertEquals(2, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
+        way.clearTags();
+        way.setTag("highway", "track");
         way.setTag("surface", "paved");
-        assertEquals(20, encoder.getSpeed(way));
-        
+        assertEquals(18, encoder.getSpeed(way));
+
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("surface", "ground");
         assertEquals(4, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("bicycle", "yes");
+        way.setTag("surface", "fine_gravel");
+        assertEquals(18, encoder.getSpeed(way));
+
+        way.setTag("surface", "unknown_surface");
+        assertEquals(4, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "residential");
+        way.setTag("surface", "asphalt");
+        assertEquals(18, encoder.getSpeed(way));
+
+        way.clearTags();
+        way.setTag("highway", "motorway");
+        way.setTag("bicycle", "yes");
+        assertEquals(18, encoder.getSpeed(way));
     }
 
     @Test
     public void testHandleWayTags()
     {
-        Map<String, String> wayMap = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, wayMap);
+        OSMWay way = new OSMWay(1);
         String wayType;
-        
-        wayMap.put("highway", "track");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section, unpaved", wayType);
-        
-        wayMap.clear();
-        wayMap.put("highway", "path");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section, unpaved", wayType);
-
-        wayMap.clear();
-        wayMap.put("highway", "path");
-        wayMap.put("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section, unpaved", wayType);
-
-        wayMap.clear();
-        wayMap.put("highway", "path");
-        wayMap.put("surface", "concrete");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
-
-        wayMap.clear();
-        wayMap.put("highway", "track");
-        wayMap.put("foot", "yes");
-        wayMap.put("surface", "paved");
-        wayMap.put("tracktype", "grade1");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section", wayType);
-
-        wayMap.clear();
-        wayMap.put("highway", "track");
-        wayMap.put("foot", "yes");
-        wayMap.put("surface", "paved");
-        wayMap.put("tracktype", "grade2");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("pushing section, unpaved", wayType);
-        
+        way.setTag("highway", "track");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("way, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "path");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("surface", "grass");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("surface", "concrete");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("foot", "yes");
+        way.setTag("surface", "paved");
+        way.setTag("tracktype", "grade1");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
+
+        way.setTag("tracktype", "grade2");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("junction", "roundabout");
+        way.setTag("highway", "tertiary");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
     @Test
-    public void testHandleWayTagsInfluencedByRelation()
+    public void testOneway()
     {
-        Map<String, String> wayMap = new HashMap<String, String>();
-        OSMWay osmWay = new OSMWay(1, wayMap);
-        wayMap.put("highway", "track");
-        long allowed=encoder.acceptBit;
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "tertiary");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.setTag("oneway", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("motor_vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        // attention bicycle:backward=no/yes has a completely different meaning!
+        // https://wiki.openstreetmap.org/wiki/Key:access#One-way_restrictions
+        way.setTag("highway", "tertiary");
+        way.setTag("oneway", "yes");
+        way.setTag("bicycle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));        
 
-        Map<String, String> relMap = new HashMap<String, String>();
-        OSMRelation osmRel = new OSMRelation(1, relMap);
+        way.setTag("bicycle:backward", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+    }
+    
+    @Test
+    public void testHandleWayTagsInfluencedByRelation()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "road");
+        long allowed = encoder.acceptBit;
 
+        OSMRelation osmRel = new OSMRelation(1);
         long relFlags = encoder.handleRelationTags(osmRel, 0);
         // unchanged
         long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(14, encoder.getSpeed(flags));
-        assertEquals(1, encoder.getWayTypeCode(flags));
-        assertEquals(1, encoder.getPavementCode(flags));
+        assertEquals(12, encoder.getSpeed(flags), 1e-1);
+        assertPriority(UNCHANGED.getValue(), osmWay, relFlags);
 
         // relation code is PREFER
-        relMap.put("route", "bicycle");
-        relMap.put("network", "lcn");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(18, encoder.getSpeed(flags));
-        assertEquals(1, encoder.getWayTypeCode(flags));
-        assertEquals(1, encoder.getPavementCode(flags));
+        assertEquals(12, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay, relFlags);
 
         // relation code is VERY_NICE
-        relMap.put("network", "rcn");
+        osmRel.setTag("network", "rcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(22, encoder.getSpeed(flags));
+        assertPriority(VERY_NICE.getValue(), osmWay, relFlags);
 
-        // relation code is OUTSTANDING_NICE
-        relMap.put("network", "ncn");
+        // relation code is BEST
+        osmRel.setTag("network", "ncn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(26, encoder.getSpeed(flags));
+        assertPriority(BEST.getValue(), osmWay, relFlags);
 
-        // PREFER relation, but tertiary road
-        // => no pushing section but road wayTypeCode and faster
-        wayMap.clear();
-        wayMap.put("highway", "tertiary");
+        // PREFER relation, but tertiary road => no get off the bike but road wayTypeCode and faster
+        osmWay.clearTags();
+        osmWay.setTag("highway", "tertiary");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        assertPriority(PREFER.getValue(), osmWay, relFlags);
 
-        relMap.put("route", "bicycle");
-        relMap.put("network", "lcn");
+        // A footway is not of waytype get off the bike in case that it is part of a cycle route
+        osmRel.clearTags();
+        osmWay.clearTags();
+        osmWay.setTag("highway", "footway");
+        osmWay.setTag("surface", "grass");
+
+        // First tests without a cycle route relation, this is a get off the bike
         relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(22, encoder.getSpeed(flags));
-        assertEquals(0, encoder.getWayTypeCode(flags));
-        
-        // test max and min speed
-        final AtomicInteger fakeSpeed = new AtomicInteger(40);
-        BikeFlagEncoder fakeEncoder = new BikeFlagEncoder()
-        {
-            @Override
-            int relationWeightCodeToSpeed( int highwaySpeed, int relationCode )
-            {
-                return fakeSpeed.get();
-            }
-        };
-        // call necessary register
-        new EncodingManager().registerEncoder(fakeEncoder);
-        allowed = fakeEncoder.acceptBit;
-
-        flags = fakeEncoder.handleWayTags(osmWay, allowed, 1);
-        assertEquals(30, fakeEncoder.getSpeed(flags));
-
-        fakeSpeed.set(-2);
-        flags = fakeEncoder.handleWayTags(osmWay, allowed, 1);
-        assertEquals(0, fakeEncoder.getSpeed(flags));
-        
+        String wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("get off the bike, unpaved", wayType);
+
+        // now as part of a cycle route relation
+        osmRel.setTag("type", "route");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("way, unpaved", wayType);
+
+        // steps are still shown as get off the bike
+        osmWay.clearTags();
+        osmWay.setTag("highway", "steps");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("get off the bike", wayType);
     }
-    
+
+    @Test
+    public void testUnchangedRelationShouldNotInfluencePriority()
+    {
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "secondary");
+
+        OSMRelation osmRel = new OSMRelation(1);
+        osmRel.setTag("description", "something");
+        long relFlags = encoder.handleRelationTags(osmRel, 0);
+        assertPriority(REACH_DEST.getValue(), osmWay, relFlags);
+    }
+
+    @Test
+    public void testSacScale()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "path");
+        way.setTag("sac_scale", "hiking");
+        // allow
+        assertEquals(1, encoder.acceptWay(way));
+
+        way.setTag("highway", "path");
+        way.setTag("sac_scale", "mountain_hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");
+        // allow
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "mountain_hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+    }
+
     @Test
-    public void testTurnFlagEncoding_noCosts() {
-        encoder.defineTurnBits(0, 0, 0);
-        
+    public void testCalcPriority()
+    {
+        long allowed = encoder.acceptBit;
+        OSMWay osmWay = new OSMWay(1);
+        OSMRelation osmRel = new OSMRelation(1);
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "icn");
+        long relFlags = encoder.handleRelationTags(osmRel, 0);
+        long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        assertEquals((double) BEST.getValue() / BEST.getValue(), encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+
+        // important: UNCHANGED should not get 0 priority!
+        osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "somethingelse");
+        flags = encoder.handleWayTags(osmWay, allowed, 0);
+        assertEquals((double) UNCHANGED.getValue() / BEST.getValue(), encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+    }
+
+    @Test
+    public void testMaxSpeed()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "secondary");
+        way.setTag("maxspeed", "10");
+        long allowed = encoder.acceptWay(way);
+        long encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(10, encoder.getSpeed(encoded), 1e-1);
+    }
+
+    @Test
+    public void testTurnFlagEncoding_DefaultNoRestrictionsAndNoCosts()
+    {
+        // default is disabled turn costs and no restrictions
         long flags_r0 = encoder.getTurnFlags(true, 0);
         long flags_0 = encoder.getTurnFlags(false, 0);
-        
+
         long flags_r20 = encoder.getTurnFlags(true, 20);
         long flags_20 = encoder.getTurnFlags(false, 20);
-        
-        assertEquals(0, encoder.getTurnCosts(flags_r0));
-        assertEquals(0, encoder.getTurnCosts(flags_0));
-        
-        assertEquals(0, encoder.getTurnCosts(flags_r20));
-        assertEquals(0, encoder.getTurnCosts(flags_20));
-        
-        assertTrue(encoder.isTurnRestricted(flags_r0));
+
+        assertEquals(0, encoder.getTurnCost(flags_r0), .1);
+        assertEquals(0, encoder.getTurnCost(flags_0), .1);
+
+        assertEquals(0, encoder.getTurnCost(flags_r20), .1);
+        assertEquals(0, encoder.getTurnCost(flags_20), .1);
+
+        assertFalse(encoder.isTurnRestricted(flags_r0));
         assertFalse(encoder.isTurnRestricted(flags_0));
-        
-        assertTrue(encoder.isTurnRestricted(flags_r20));
+
+        assertFalse(encoder.isTurnRestricted(flags_r20));
         assertFalse(encoder.isTurnRestricted(flags_20));
     }
-    
+
     @Test
-    public void testTurnFlagEncoding_withCosts() {
-        //arbitrary shift, 7 turn cost bits: [0,127]
-        encoder.defineTurnBits(0, 2, 7);
-        
+    public void testTurnFlagEncoding_withCosts()
+    {
+        encoder = new BikeFlagEncoder(4, 2, 127);
+        new EncodingManager(encoder);
+
         long flags_r0 = encoder.getTurnFlags(true, 0);
         long flags_0 = encoder.getTurnFlags(false, 0);
-        
-        long flags_r20 = encoder.getTurnFlags(true, 20);
-        long flags_20 = encoder.getTurnFlags(false, 20);
-        
-        long flags_r220 = encoder.getTurnFlags(true, 220);
-        long flags_220 = encoder.getTurnFlags(false, 220);
-        
-        assertEquals(0, encoder.getTurnCosts(flags_r0));
-        assertEquals(0, encoder.getTurnCosts(flags_0));
-        
-        assertEquals(20, encoder.getTurnCosts(flags_r20));
-        assertEquals(20, encoder.getTurnCosts(flags_20));
-        
-        assertEquals(127, encoder.getTurnCosts(flags_r220));
-        assertEquals(127, encoder.getTurnCosts(flags_220));
-        
+        assertTrue(Double.isInfinite(encoder.getTurnCost(flags_r0)));
+        assertEquals(0, encoder.getTurnCost(flags_0), .1);
         assertTrue(encoder.isTurnRestricted(flags_r0));
         assertFalse(encoder.isTurnRestricted(flags_0));
-        
+
+        long flags_r20 = encoder.getTurnFlags(true, 0);
+        long flags_20 = encoder.getTurnFlags(false, 20);
+        assertTrue(Double.isInfinite(encoder.getTurnCost(flags_r20)));
+        assertEquals(20, encoder.getTurnCost(flags_20), .1);
         assertTrue(encoder.isTurnRestricted(flags_r20));
         assertFalse(encoder.isTurnRestricted(flags_20));
-        
+
+        long flags_r220 = encoder.getTurnFlags(true, 0);
+        try
+        {
+            encoder.getTurnFlags(false, 220);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+        long flags_126 = encoder.getTurnFlags(false, 126);
+        assertTrue(Double.isInfinite(encoder.getTurnCost(flags_r220)));
+
+        assertEquals(126, encoder.getTurnCost(flags_126), .1);
         assertTrue(encoder.isTurnRestricted(flags_r220));
-        assertFalse(encoder.isTurnRestricted(flags_220));
+        assertFalse(encoder.isTurnRestricted(flags_126));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index ed385de529..5581ed84a0 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -18,13 +18,8 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.OSMNode;
-import java.util.HashMap;
-import java.util.Map;
-
 import com.graphhopper.reader.OSMWay;
-
 import org.junit.Test;
-
 import static org.junit.Assert.*;
 
 /**
@@ -39,35 +34,101 @@
     @Test
     public void testAccess()
     {
-        Map<String, String> map = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, map);
+        OSMWay way = new OSMWay(1);
+        assertFalse(encoder.acceptWay(way) > 0);
+        way.setTag("highway", "service");
+        assertTrue(encoder.acceptWay(way) > 0);
+        way.setTag("access", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("motorcar", "no");
         assertFalse(encoder.acceptWay(way) > 0);
-        map.put("highway", "service");
+
+        // for now allow grade1+2+3 for every country, see #253
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("tracktype", "grade2");
         assertTrue(encoder.acceptWay(way) > 0);
-        map.put("access", "no");
+        way.setTag("tracktype", "grade4");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "track");
-        map.put("motorcar", "no");
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "no");
+        way.setTag("motorcar", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "delivery");
         assertFalse(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "unclassified");
-        map.put("ford", "yes");
+        way.clearTags();
+        way.setTag("highway", "unclassified");
+        way.setTag("ford", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
-        map.put("motorcar", "yes");
+        way.setTag("motorcar", "yes");
         assertTrue(encoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("route", "ferry");
+        way.clearTags();
+        way.setTag("route", "ferry");
         assertTrue(encoder.acceptWay(way) > 0);
-        map.put("motorcar", "no");
+        assertTrue(encoder.isFerry(encoder.acceptWay(way)));
+        way.setTag("motorcar", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("route", "ferry");
+        way.setTag("foot", "yes");
         assertFalse(encoder.acceptWay(way) > 0);
+        assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+    }
+
+    @Test
+    public void testOneway()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "primary");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.setTag("oneway", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+    }
 
-        map.clear();
-        map.put("route", "ferry");
-        map.put("foot", "yes");
+    @Test
+    public void testMilitaryAccess()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("access", "military");
         assertFalse(encoder.acceptWay(way) > 0);
     }
 
@@ -82,58 +143,79 @@ public void testSetAccess()
 
         assertFalse(encoder.isForward(encoder.setProperties(0, false, true)));
         assertTrue(encoder.isBackward(encoder.setProperties(0, false, true)));
+
+        assertTrue(encoder.isForward(encoder.flagsDefault(true, true)));
+        assertTrue(encoder.isBackward(encoder.flagsDefault(true, true)));
+
+        assertTrue(encoder.isForward(encoder.flagsDefault(true, false)));
+        assertFalse(encoder.isBackward(encoder.flagsDefault(true, false)));
+
+        long flags = encoder.flagsDefault(true, true);
+        // disable access
+        assertFalse(encoder.isForward(encoder.setAccess(flags, false, false)));
+        assertFalse(encoder.isBackward(encoder.setAccess(flags, false, false)));
     }
 
     @Test
-    public void testSpeedLimitBiggerThanMaxValue()
+    public void testMaxSpeed()
     {
-        Map<String, String> map = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, map);
-        map.put("highway", "trunk");
-        map.put("maxspeed", "500");
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "trunk");
+        way.setTag("maxspeed", "500");
         long allowed = encoder.acceptWay(way);
         long encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(100, encoder.getSpeed(encoded));
+        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "primary");
+        way.setTag("maxspeed:backward", "10");
+        way.setTag("maxspeed:forward", "20");
+        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(10, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "primary");
+        way.setTag("maxspeed:forward", "20");
+        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "primary");
+        way.setTag("maxspeed:backward", "20");
+        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(20, encoder.getSpeed(encoded), 1e-1);
     }
 
     @Test
     public void testSpeed()
     {
         // limit bigger than default road speed
-        Map<String, String> map = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, map);
-        map.put("highway", "trunk");
-        map.put("maxspeed", "110");
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "trunk");
+        way.setTag("maxspeed", "110");
         long allowed = encoder.acceptWay(way);
         long encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(95, encoder.getSpeed(encoded));
-
-        map.clear();
-        map.put("highway", "residential");
-        map.put("surface", "cobblestone");
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(30, encoder.getSpeed(encoded));
+        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
 
-        map.clear();
-        map.put("highway", "track");
+        way.clearTags();
+        way.setTag("highway", "residential");
+        way.setTag("surface", "cobblestone");
         allowed = encoder.acceptWay(way);
         encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(15, encoder.getSpeed(encoded));
+        assertEquals(30, encoder.getSpeed(encoded), 1e-1);
 
-        map.clear();
-        map.put("highway", "track");
-        map.put("tracktype", "grade1");
+        way.clearTags();
+        way.setTag("highway", "track");
         allowed = encoder.acceptWay(way);
         encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(20, encoder.getSpeed(encoded));
+        assertEquals(15, encoder.getSpeed(encoded), 1e-1);
 
-        map.clear();
-        map.put("highway", "track");
-        map.put("tracktype", "grade5");
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("tracktype", "grade1");
         allowed = encoder.acceptWay(way);
         encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(5, encoder.getSpeed(encoded));
+        assertEquals(20, encoder.getSpeed(encoded), 1e-1);
 
         try
         {
@@ -147,7 +229,35 @@ public void testSpeed()
     @Test
     public void testSetSpeed()
     {
-        assertEquals(10, encoder.getSpeed(encoder.setSpeed(0, 10)));
+        assertEquals(10, encoder.getSpeed(encoder.setSpeed(0, 10)), 1e-1);
+    }
+
+    @Test
+    public void testRoundabout()
+    {
+        long flags = encoder.setAccess(0, true, true);
+        long resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, true);
+        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
+
+        resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, false);
+        assertFalse(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
+
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "motorway");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        assertFalse(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+
+        way.setTag("junction", "roundabout");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
     @Test
@@ -157,69 +267,56 @@ public void testRailway()
         way.setTag("highway", "secondary");
         way.setTag("railway", "rail");
         // disallow rail
-        assertEquals(0, encoder.acceptWay(way));
+        assertTrue(encoder.acceptWay(way) == 0);
+
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("railway", "abandoned");
+        assertTrue(encoder.acceptWay(way) == 0);
+
+        // on disallowed highway, railway is allowed, sometimes incorrectly mapped
+        way.setTag("highway", "track");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        // this is fully okay as sometimes old rails are on the road
+        way.setTag("highway", "primary");
+        way.setTag("railway", "historic");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("motorcar", "no");
+        assertTrue(encoder.acceptWay(way) == 0);
 
         way = new OSMWay(1);
         way.setTag("highway", "secondary");
         way.setTag("railway", "tram");
         // but allow tram to be on the same way
-        assertNotSame(0, encoder.acceptWay(way));
+        assertTrue(encoder.acceptWay(way) > 0);
 
         way = new OSMWay(1);
         way.setTag("route", "shuttle_train");
         way.setTag("motorcar", "yes");
         way.setTag("bicycle", "no");
         way.setTag("duration", "35");
-        way.setInternalTag("estimated_distance", 50000);
+        way.setTag("estimated_distance", 50000);
         // accept
-        assertNotSame(0, encoder.acceptWay(way));
+        assertTrue(encoder.acceptWay(way) > 0);
         // calculate speed from estimated_distance and duration
-        assertEquals(60, encoder.getSpeed(encoder.handleFerry(way, 20, 30, 40)));
-    }
-
-    @Test
-    public void testBasics()
-    {
-        assertTrue(encoder.isForward(encoder.flagsDefault(true, true)));
-        assertTrue(encoder.isBackward(encoder.flagsDefault(true, true)));
-        assertTrue(encoder.isBoth(encoder.flagsDefault(true, true)));
-
-        assertTrue(encoder.isForward(encoder.flagsDefault(true, false)));
-        assertFalse(encoder.isBackward(encoder.flagsDefault(true, false)));
-        assertFalse(encoder.isBoth(encoder.flagsDefault(true, false)));
-    }
-
-    @Test
-    public void testOverwrite()
-    {
-        long forward = encoder.setProperties(10, true, false);
-        long backward = encoder.swapDirection(forward);
-        long both = encoder.setProperties(20, true, true);
-        assertTrue(encoder.canBeOverwritten(forward, forward));
-        assertTrue(encoder.canBeOverwritten(backward, backward));
-        assertTrue(encoder.canBeOverwritten(forward, both));
-        assertTrue(encoder.canBeOverwritten(backward, both));
-
-        assertTrue(encoder.canBeOverwritten(both, both));
-        assertFalse(encoder.canBeOverwritten(both, forward));
-        assertFalse(encoder.canBeOverwritten(both, backward));
-        assertFalse(encoder.canBeOverwritten(forward, backward));
-        assertFalse(encoder.canBeOverwritten(backward, forward));
+        assertEquals(60, encoder.getSpeed(encoder.handleFerryTags(way, 20, 30, 40)), 1e-1);
     }
 
     @Test
     public void testSwapDir()
     {
-        long swappedFlags = encoder.swapDirection(encoder.flagsDefault(true, true));
+        long swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, true));
         assertTrue(encoder.isForward(swappedFlags));
         assertTrue(encoder.isBackward(swappedFlags));
 
-        swappedFlags = encoder.swapDirection(encoder.flagsDefault(true, false));
+        swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, false));
 
         assertFalse(encoder.isForward(swappedFlags));
         assertTrue(encoder.isBackward(swappedFlags));
 
-        assertEquals(0, encoder.swapDirection(0));
+        assertEquals(0, encoder.reverseFlags(0));
     }
 
     @Test
@@ -229,84 +326,173 @@ public void testBarrierAccess()
         node.setTag("barrier", "lift_gate");
         node.setTag("access", "yes");
         // no barrier!
-        assertTrue(encoder.analyzeNodeTags(node) == 0);
+        assertTrue(encoder.handleNodeTags(node) == 0);
 
         node = new OSMNode(1, -1, -1);
         node.setTag("barrier", "lift_gate");
         node.setTag("bicycle", "yes");
         // barrier!
-        assertTrue(encoder.analyzeNodeTags(node) > 0);
-        
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
         node = new OSMNode(1, -1, -1);
         node.setTag("barrier", "lift_gate");
         node.setTag("access", "yes");
         node.setTag("bicycle", "yes");
         // should this be a barrier for motorcars too?
-        // assertTrue(encoder.analyzeNodeTags(node) > 0);
-        
+        // assertTrue(encoder.handleNodeTags(node) > 0);
+
         node = new OSMNode(1, -1, -1);
         node.setTag("barrier", "lift_gate");
         node.setTag("access", "no");
         node.setTag("motorcar", "yes");
         // no barrier!
-        assertTrue(encoder.analyzeNodeTags(node) == 0);
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "bollard");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        // ignore other access tags for absolute barriers!
+        node.setTag("motorcar", "yes");
+        // still barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
     }
 
     @Test
     public void testTurnFlagEncoding_noCosts()
     {
-        encoder.defineTurnBits(0, 0, 0);
+        FlagEncoder tmpEnc = new CarFlagEncoder(8, 5, 0);
+        EncodingManager em = new EncodingManager(tmpEnc);
 
-        long flags_r0 = encoder.getTurnFlags(true, 0);
-        long flags_0 = encoder.getTurnFlags(false, 0);
+        long flags_r0 = tmpEnc.getTurnFlags(true, 0);
+        long flags_0 = tmpEnc.getTurnFlags(false, 0);
 
-        long flags_r20 = encoder.getTurnFlags(true, 20);
-        long flags_20 = encoder.getTurnFlags(false, 20);
+        long flags_r20 = tmpEnc.getTurnFlags(true, 0);
+        long flags_20 = tmpEnc.getTurnFlags(false, 20);
 
-        assertEquals(0, encoder.getTurnCosts(flags_r0));
-        assertEquals(0, encoder.getTurnCosts(flags_0));
+        assertEquals(0, tmpEnc.getTurnCost(flags_r0), 1e-1);
+        assertEquals(0, tmpEnc.getTurnCost(flags_0), 1e-1);
 
-        assertEquals(0, encoder.getTurnCosts(flags_r20));
-        assertEquals(0, encoder.getTurnCosts(flags_20));
+        assertEquals(0, tmpEnc.getTurnCost(flags_r20), 1e-1);
+        assertEquals(0, tmpEnc.getTurnCost(flags_20), 1e-1);
 
-        assertTrue(encoder.isTurnRestricted(flags_r0));
-        assertFalse(encoder.isTurnRestricted(flags_0));
+        assertFalse(tmpEnc.isTurnRestricted(flags_r0));
+        assertFalse(tmpEnc.isTurnRestricted(flags_0));
 
-        assertTrue(encoder.isTurnRestricted(flags_r20));
-        assertFalse(encoder.isTurnRestricted(flags_20));
+        assertFalse(tmpEnc.isTurnRestricted(flags_r20));
+        assertFalse(tmpEnc.isTurnRestricted(flags_20));
     }
 
     @Test
     public void testTurnFlagEncoding_withCosts()
     {
-        //arbitrary shift, 7 turn cost bits: [0,127]
-        encoder.defineTurnBits(0, 2, 7);
-
-        long flags_r0 = encoder.getTurnFlags(true, 0);
-        long flags_0 = encoder.getTurnFlags(false, 0);
+        FlagEncoder tmpEncoder = new CarFlagEncoder(8, 5, 127);
+        EncodingManager em = new EncodingManager(tmpEncoder);
+
+        long flags_r0 = tmpEncoder.getTurnFlags(true, 0);
+        long flags_0 = tmpEncoder.getTurnFlags(false, 0);
+        assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r0)));
+        assertEquals(0, tmpEncoder.getTurnCost(flags_0), 1e-1);
+        assertTrue(tmpEncoder.isTurnRestricted(flags_r0));
+        assertFalse(tmpEncoder.isTurnRestricted(flags_0));
+
+        long flags_r20 = tmpEncoder.getTurnFlags(true, 0);
+        long flags_20 = tmpEncoder.getTurnFlags(false, 20);
+        assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r20)));
+        assertEquals(20, tmpEncoder.getTurnCost(flags_20), 1e-1);
+        assertTrue(tmpEncoder.isTurnRestricted(flags_r20));
+        assertFalse(tmpEncoder.isTurnRestricted(flags_20));
+
+        long flags_r220 = tmpEncoder.getTurnFlags(true, 0);
+        try
+        {
+            tmpEncoder.getTurnFlags(false, 220);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+        assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r220)));
+        assertTrue(tmpEncoder.isTurnRestricted(flags_r220));
+    }
 
-        long flags_r20 = encoder.getTurnFlags(true, 20);
-        long flags_20 = encoder.getTurnFlags(false, 20);
+    @Test
+    public void testMaxValue()
+    {
+        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        EncodingManager em = new EncodingManager(instance);
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "motorway_link");
+        way.setTag("maxspeed", "70 mph");
+        long flags = instance.handleWayTags(way, 1, 0);
+
+        // double speed = AbstractFlagEncoder.parseSpeed("70 mph");
+        // => 112.654 * 0.9 => 101
+        flags = instance.reverseFlags(flags);
+        assertEquals(100, instance.getSpeed(flags), 1e-1);
+    }
 
-        long flags_r220 = encoder.getTurnFlags(true, 220);
-        long flags_220 = encoder.getTurnFlags(false, 220);
+    @Test
+    public void testRegisterOnlyOnceAllowed()
+    {
+        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        EncodingManager em = new EncodingManager(instance);
+        try
+        {
+            em = new EncodingManager(instance);
+            assertTrue(false);
+        } catch (IllegalStateException ex)
+        {
+        }
+    }
 
-        assertEquals(0, encoder.getTurnCosts(flags_r0));
-        assertEquals(0, encoder.getTurnCosts(flags_0));
+    @Test
+    public void testSetToMaxSpeed()
+    {
+        OSMWay way = new OSMWay(12);
+        way.setTag("maxspeed", "90");
+        assertEquals(90, encoder.getMaxSpeed(way), 1e-2);
+    }
 
-        assertEquals(20, encoder.getTurnCosts(flags_r20));
-        assertEquals(20, encoder.getTurnCosts(flags_20));
+    @Test
+    public void testFordAccess()
+    {
+        OSMNode node = new OSMNode(0, 0.0, 0.0);
+        node.setTag("ford", "yes");
 
-        assertEquals(127, encoder.getTurnCosts(flags_r220)); // max costs is 2^7-1 = 127
-        assertEquals(127, encoder.getTurnCosts(flags_220));
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "unclassified");
+        way.setTag("ford", "yes");
 
-        assertTrue(encoder.isTurnRestricted(flags_r0));
-        assertFalse(encoder.isTurnRestricted(flags_0));
+        // Node and way are initially blocking
+        assertTrue(encoder.isBlockFords());
+        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.handleNodeTags(node) > 0);
 
-        assertTrue(encoder.isTurnRestricted(flags_r20));
-        assertFalse(encoder.isTurnRestricted(flags_20));
+        try
+        {
+            // Now they are passable
+            encoder.setBlockFords(false);
+            assertTrue(encoder.acceptWay(way) > 0);
+            assertFalse(encoder.handleNodeTags(node) > 0);
+        } finally
+        {
+            encoder.setBlockFords(true);
+        }
+    }
 
-        assertTrue(encoder.isTurnRestricted(flags_r220));
-        assertFalse(encoder.isTurnRestricted(flags_220));
+    @Test
+    public void testCombination()
+    {
+        OSMWay way = new OSMWay(123);
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");        
+
+        long flags = em.acceptWay(way);
+        long edgeFlags = em.handleWayTags(way, flags, 0);
+        assertFalse(encoder.isBackward(edgeFlags));
+        assertFalse(encoder.isForward(edgeFlags));
+        assertTrue(em.getEncoder("bike").isBackward(edgeFlags));
+        assertTrue(em.getEncoder("bike").isForward(edgeFlags));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
new file mode 100644
index 0000000000..220a204e0f
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
@@ -0,0 +1,67 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.OSMWay;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class EncodedDoubleValueTest
+{
+    @Test
+    public void testSetDoubleValue()
+    {
+        EncodedDoubleValue instance = new EncodedDoubleValue("test", 6, 10, 0.01, 5, 10);
+        assertEquals(10.12, instance.getDoubleValue(instance.setDoubleValue(0, 10.12)), 1e-4);
+    }
+
+    @Test
+    public void testMaxValue()
+    {
+        EncodedDoubleValue instance1 = new EncodedDoubleValue("test1", 0, 8, 0.5, 60, 100);
+        long flags = instance1.setDoubleValue(0, instance1.getMaxValue());
+        assertEquals(100, instance1.getDoubleValue(flags), 1e-1);
+    }
+
+    @Test
+    public void testMaxValueAndSwap()
+    {
+        EncodedDoubleValue instance1 = new EncodedDoubleValue("test1", 0, 8, 0.5, 60, 100);
+        EncodedDoubleValue instance2 = new EncodedDoubleValue("test2", 8, 8, 0.5, 60, 100);
+        long flags = instance2.setDoubleValue(instance1.setDoubleValue(0, 100), 90);
+        long expectedFlags = instance2.setDoubleValue(instance1.setDoubleValue(0, 90), 100);
+        long swappedFlags = instance1.swap(flags, instance2);
+        assertEquals(expectedFlags, swappedFlags);
+
+        CarFlagEncoder carEncoder = new CarFlagEncoder(8, 0.5, 0);
+        new EncodingManager(carEncoder);
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "motorway_link");
+        way.setTag("maxspeed", "70 mph");
+        flags = carEncoder.handleWayTags(way, 1, 0);
+
+        // double speed = AbstractFlagEncoder.parseSpeed("70 mph");
+        flags = carEncoder.reverseFlags(flags);
+        assertEquals(100, carEncoder.getSpeed(flags), 1e-1);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
index e1e03789f2..9fcb71771d 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
@@ -38,4 +38,14 @@ public void testSetValue()
         instance = new EncodedValue("test", 0, 4, 1, 5, 10);
         assertEquals(5, instance.getValue(instance.setDefaultValue(0)));
     }
+
+    @Test
+    public void testSwap()
+    {
+        EncodedValue instance1 = new EncodedValue("test1", 0, 10, 1, 5, 1000);
+        EncodedValue instance2 = new EncodedValue("test2", 10, 10, 1, 5, 1000);
+        long flags = instance2.setValue(instance1.setValue(0, 13), 874);
+        long swappedFlags = instance1.setValue(instance2.setValue(0, 13), 874);
+        assertEquals(swappedFlags, instance1.swap(flags, instance2));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index 73bb4c6445..c6ec097254 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -22,18 +22,9 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
 import org.junit.Test;
 
-import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
 
@@ -55,15 +46,13 @@ public void testCompatibility()
         assertNotEquals(car.hashCode(), bike.hashCode());
         assertNotEquals(car.hashCode(), foot.hashCode());
 
-        EncodingManager manager2 = new EncodingManager();
         FootFlagEncoder foot2 = new FootFlagEncoder();
-        manager2.registerEncoder(foot2);
+        EncodingManager manager2 = new EncodingManager(foot2);
         assertNotEquals(foot, foot2);
         assertNotEquals(foot.hashCode(), foot2.hashCode());
 
-        EncodingManager manager3 = new EncodingManager();
         FootFlagEncoder foot3 = new FootFlagEncoder();
-        manager3.registerEncoder(foot3);
+        EncodingManager manager3 = new EncodingManager(foot3);
         assertEquals(foot3, foot2);
         assertEquals(foot3.hashCode(), foot2.hashCode());
     }
@@ -77,35 +66,37 @@ public void testEncoderAcceptNoException()
     }
 
     @Test
-    public void testTooManyEncoders()
+    public void testWrongEncoders()
     {
-        EncodingManager manager = new EncodingManager();
-        for (int i = 0; i < 4; i++)
+        try
         {
-            manager.registerEncoder(new FootFlagEncoder());
+            FootFlagEncoder foot = new FootFlagEncoder();
+            new EncodingManager(foot, foot);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertEquals("You must not register a FlagEncoder (foot) twice!", ex.getMessage());
         }
+
         try
         {
-            manager.registerEncoder(new FootFlagEncoder());
+            new EncodingManager(new FootFlagEncoder(), new CarFlagEncoder(), new BikeFlagEncoder(), new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder());
             assertTrue(false);
         } catch (Exception ex)
         {
+            assertEquals("Encoders are requesting more than 32 bits of way flags. Decrease the number of vehicles or increase the flags to take long.",
+                    ex.getMessage());
         }
     }
 
     @Test
     public void testCombineRelations()
     {
-        Map<String, String> wayMap = new HashMap<String, String>();
-        wayMap.put("highway", "track");
-        OSMWay osmWay = new OSMWay(1, wayMap);
-
-        Map<String, String> relMap = new HashMap<String, String>();
-        OSMRelation osmRel = new OSMRelation(1, relMap);
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "track");
+        OSMRelation osmRel = new OSMRelation(1);
 
-        EncodingManager manager = new EncodingManager();
         BikeFlagEncoder defaultBike = new BikeFlagEncoder();
-        manager.registerEncoder(defaultBike);
         BikeFlagEncoder lessRelationCodes = new BikeFlagEncoder()
         {
             @Override
@@ -122,61 +113,58 @@ public long handleRelationTags( OSMRelation relation, long oldRelFlags )
                     return relationCodeEncoder.setValue(0, 2);
                 return relationCodeEncoder.setValue(0, 0);
             }
-            @Override            
-            int relationWeightCodeToSpeed( int highwaySpeed, int relationCode )
+
+            @Override
+            protected int handlePriority( OSMWay way, int priorityFromRelation )
             {
-                return highwaySpeed;
-            }            
+                return priorityFromRelation;
+            }
+
             @Override
             public String toString()
             {
-               return "lessRelationsBits";
+                return "lessRelationsBits";
             }
         };
-        manager.registerEncoder(lessRelationCodes);
+        EncodingManager manager = new EncodingManager(defaultBike, lessRelationCodes);
 
         // relation code is PREFER
-        relMap.put("route", "bicycle");
-        relMap.put("network", "lcn");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
         long relFlags = manager.handleRelationTags(osmRel, 0);
         long allow = defaultBike.acceptBit | lessRelationCodes.acceptBit;
         long flags = manager.handleWayTags(osmWay, allow, relFlags);
 
-        assertEquals(18, defaultBike.getSpeed(flags));
-        assertEquals(4, lessRelationCodes.getSpeed(flags));
+        assertTrue(defaultBike.getDouble(flags, PriorityWeighting.KEY)
+                > lessRelationCodes.getDouble(flags, PriorityWeighting.KEY));
     }
 
     @Test
     public void testMixBikeTypesAndRelationCombination()
     {
-        Map<String, String> wayMap = new HashMap<String, String>();
-        wayMap.put("highway", "track");
-        wayMap.put("tracktype", "grade1");
-        OSMWay osmWay = new OSMWay(1, wayMap);
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "track");
+        osmWay.setTag("tracktype", "grade1");
 
-        Map<String, String> relMap = new HashMap<String, String>();
-        OSMRelation osmRel = new OSMRelation(1, relMap);
+        OSMRelation osmRel = new OSMRelation(1);
 
-        EncodingManager manager = new EncodingManager();
-        BikeFlagEncoder bikeencoder = new BikeFlagEncoder();
-        manager.registerEncoder(bikeencoder);
-        MountainBikeFlagEncoder mountainbikeencoder = new MountainBikeFlagEncoder();
-        manager.registerEncoder(mountainbikeencoder);
-        
+        BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
+        MountainBikeFlagEncoder mtbEncoder = new MountainBikeFlagEncoder();
+        EncodingManager manager = new EncodingManager(bikeEncoder, mtbEncoder);
 
         // relation code for network rcn is VERY_NICE for bike and PREFER for mountainbike
-        relMap.put("route", "bicycle");
-        relMap.put("network", "rcn");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "rcn");
         long relFlags = manager.handleRelationTags(osmRel, 0);
-        long allow = bikeencoder.acceptBit | mountainbikeencoder.acceptBit;
+        long allow = bikeEncoder.acceptBit | mtbEncoder.acceptBit;
         long flags = manager.handleWayTags(osmWay, allow, relFlags);
 
-        //Uninfluenced speed for grade1 bikeencoder = 4 (pushing section) -> smaller than 15 -> VERYNICE -> 22
-        assertEquals(22, bikeencoder.getSpeed(flags));
-        //Uninfluenced speed for grade1 bikeencoder = 12 -> smaller than 15 -> PREFER -> 18
-        assertEquals(18, mountainbikeencoder.getSpeed(flags));
+        // bike: uninfluenced speed for grade but via network => VERY_NICE                
+        // mtb: uninfluenced speed only PREFER
+        assertTrue(bikeEncoder.getDouble(flags, PriorityWeighting.KEY)
+                > mtbEncoder.getDouble(flags, PriorityWeighting.KEY));
     }
-    
+
     public void testFullBitMask()
     {
         BitUtil bitUtil = BitUtil.LITTLE;
@@ -189,154 +177,36 @@ public void testFullBitMask()
     }
 
     @Test
-    public void testApplyNodeTags()
+    public void testFixWayName()
     {
-        EncodingManager manager = new EncodingManager();
-        CarFlagEncoder car = new CarFlagEncoder();
-        manager.registerEncoder(car);
-        CarFlagEncoder car2 = new CarFlagEncoder(7, 1)
-        {
-            protected EncodedValue nodeEncoder;
-
-            @Override
-            public int defineNodeBits( int index, int shift )
-            {
-                shift = super.defineNodeBits(index, shift);
-                nodeEncoder = new EncodedValue("nodeEnc", shift, 2, 1, 0, 3);
-                return shift + 2;
-            }
-
-            @Override
-            public long analyzeNodeTags( OSMNode node )
-            {
-                String tmp = node.getTags().get("test");
-                // return negative value to indicate that this is not a barrier
-                if (tmp == null)
-                    return -nodeEncoder.setValue(0, 1);
-                return -nodeEncoder.setValue(0, 2);
-            }
-
-            @Override
-            public long applyNodeFlags( long wayFlags, long nodeFlags )
-            {
-                int speed = (int) speedEncoder.getValue(wayFlags);
-                int speedDecrease = (int) nodeEncoder.getValue(nodeFlags);
-                return speedEncoder.setValue(wayFlags, speed - speedDecrease);
-            }
-        };
-        manager.registerEncoder(car2);
-
-        Map<String, String> nodeMap = new HashMap<String, String>();
-        OSMNode node = new OSMNode(1, nodeMap, Double.NaN, Double.NaN);
-        Map<String, String> wayMap = new HashMap<String, String>();
-        wayMap.put("highway", "secondary");
-        OSMWay way = new OSMWay(2, wayMap);
-
-        long wayFlags = manager.handleWayTags(way, manager.acceptWay(way), 0);
-        long nodeFlags = manager.analyzeNodeTags(node);
-        wayFlags = manager.applyNodeFlags(wayFlags, -nodeFlags);
-        assertEquals(60, car.getSpeed(wayFlags));
-        assertEquals(59, car2.getSpeed(wayFlags));
-
-        nodeMap.put("test", "something");
-        wayFlags = manager.handleWayTags(way, manager.acceptWay(way), 0);
-        nodeFlags = manager.analyzeNodeTags(node);
-        wayFlags = manager.applyNodeFlags(wayFlags, -nodeFlags);
-        assertEquals(58, car2.getSpeed(wayFlags));
-        assertEquals(60, car.getSpeed(wayFlags));
-
-        wayMap.put("maxspeed", "130");
-        wayFlags = manager.handleWayTags(way, manager.acceptWay(way), 0);
-        assertEquals(car.getMaxSpeed(), car2.getSpeed(wayFlags));
-        nodeFlags = manager.analyzeNodeTags(node);
-        wayFlags = manager.applyNodeFlags(wayFlags, -nodeFlags);
-        assertEquals(98, car2.getSpeed(wayFlags));
-        assertEquals(100, car.getSpeed(wayFlags));
+        assertEquals("B8, B12", EncodingManager.fixWayName("B8;B12"));
+        assertEquals("B8, B12", EncodingManager.fixWayName("B8; B12"));
     }
 
-    /**
-     * Tests the combination of different turn cost flags by different encoders.
-     */
     @Test
-    public void testTurnFlagCombination()
+    public void testCompatibilityBug()
     {
-        final TurnCostTableEntry turnCostEntry_car = new TurnCostTableEntry();
-        final TurnCostTableEntry turnCostEntry_foot = new TurnCostTableEntry();
-        final TurnCostTableEntry turnCostEntry_bike = new TurnCostTableEntry();
-
-        EncodingManager manager = new EncodingManager();
-        CarFlagEncoder car = new CarFlagEncoder()
-        {
-            public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-            {
-                return Collections.singleton(turnCostEntry_car); //simulate by returning one turn cost entry directly
-            };
-        };
-        FootFlagEncoder foot = new FootFlagEncoder()
-        {
-            public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-            {
-                return Collections.singleton(turnCostEntry_foot); //simulate by returning one turn cost entry directly
-            };
-        };
-        BikeFlagEncoder bike = new BikeFlagEncoder()
-        {
-            public Collection<TurnCostTableEntry> analyzeTurnRelation( OSMTurnRelation turnRelation, OSMReader osmReader )
-            {
-                return Collections.singleton(turnCostEntry_bike); //simulate by returning one turn cost entry directly
-            };
-        };
-
-        manager.maxTurnCost = 127; //allow turn costs
-
-        manager.registerEncoder(bike);
-        manager.registerEncoder(foot);
-        manager.registerEncoder(car);
-
-        //turn cost entries for car and foot are for the same relations (same viaNode, edgeFrom and edgeTo), turn cost entry for bike is for another relation (different viaNode) 
-        turnCostEntry_car.edgeFrom = 1;
-        turnCostEntry_foot.edgeFrom = 1;
-        turnCostEntry_bike.edgeFrom = 2;
-
-        //calculating arbitrary flags using the encoders
-        turnCostEntry_car.flags = car.getTurnFlags(true, 20);
-        turnCostEntry_foot.flags = foot.getTurnFlags(true, 0);
-        turnCostEntry_bike.flags = bike.getTurnFlags(false, 10);
-
-        //we expect two different entries: the first one is a combination of turn flags of car and foot, since they provide the same relation, the other one is for bike only
-        long assertFlag1 = turnCostEntry_car.flags | turnCostEntry_foot.flags;
-        long assertFlag2 = turnCostEntry_bike.flags;
-
-        //RUN: analyze = combine flags of all encoders
-        Collection<TurnCostTableEntry> entries = manager.analyzeTurnRelation(null, null);
-
-        assertEquals(2, entries.size()); //we expect two different turnCost entries
-
-        for (TurnCostTableEntry entry : entries)
-        {
-            if (entry.edgeFrom == 1)
-            { //the first entry provides turn flags for car and foot only 
-                assertEquals(assertFlag1, entry.flags);
-                assertTrue(car.isTurnRestricted(entry.flags));
-                assertFalse(foot.isTurnRestricted(entry.flags));
-                assertFalse(bike.isTurnRestricted(entry.flags));
-
-                assertEquals(20, car.getTurnCosts(entry.flags));
-                assertEquals(0, foot.getTurnCosts(entry.flags));
-                assertEquals(0, bike.getTurnCosts(entry.flags));
-            } else if (entry.edgeFrom == 2)
-            { //the 2nd entry provides turn flags for bike only
-                assertEquals(assertFlag2, entry.flags);
-                assertFalse(car.isTurnRestricted(entry.flags));
-                assertFalse(foot.isTurnRestricted(entry.flags));
-                assertFalse(bike.isTurnRestricted(entry.flags));
-
-                assertEquals(0, car.getTurnCosts(entry.flags));
-                assertEquals(0, foot.getTurnCosts(entry.flags));
-                assertEquals(10, bike.getTurnCosts(entry.flags));
-            }
-        }
-
+        EncodingManager manager2 = new EncodingManager("bike2", 8);
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "footway");
+        osmWay.setTag("name", "test");
+
+        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getEncoder("bike2");
+        long flags = manager2.handleWayTags(osmWay, singleBikeEnc.acceptBit, 0);
+        double singleSpeed = singleBikeEnc.getSpeed(flags);
+        assertEquals(4, singleSpeed, 1e-3);
+        assertEquals(singleSpeed, singleBikeEnc.getReverseSpeed(flags), 1e-3);
+
+        EncodingManager manager = new EncodingManager("bike2,bike,foot", 8);
+        FootFlagEncoder foot = (FootFlagEncoder) manager.getEncoder("foot");
+        BikeFlagEncoder bike = (BikeFlagEncoder) manager.getEncoder("bike2");
+
+        long acceptBits = foot.acceptBit | bike.acceptBit;
+        flags = manager.handleWayTags(osmWay, acceptBits, 0);
+        assertEquals(singleSpeed, bike.getSpeed(flags), 1e-2);
+        assertEquals(singleSpeed, bike.getReverseSpeed(flags), 1e-2);
+
+        assertEquals(5, foot.getSpeed(flags), 1e-2);
+        assertEquals(5, foot.getReverseSpeed(flags), 1e-2);
     }
-
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
index 0faf73f6c5..816310c551 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FastestWeightingTest.java
@@ -34,14 +34,18 @@ public void testMinWeightHasSameUnitAs_getWeight()
     {
         FastestWeighting instance = new FastestWeighting(encoder);
         long flags = encoder.setProperties(encoder.getMaxSpeed(), true, true);
-        assertEquals(instance.getMinWeight(10), instance.calcWeight(createEdge(10, flags)), 1e-8);
+        assertEquals(instance.getMinWeight(10), instance.calcWeight(createEdge(10, flags), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
     @Test
     public void testSpeed0()
     {
         FastestWeighting instance = new FastestWeighting(encoder);
-        assertEquals(1.0 / 0, instance.calcWeight(createEdge(10, encoder.setProperties(0, true, true))), 1e-8);
+
+        assertEquals(1.0 / 0, instance.calcWeight(createEdge(10, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
+
+        // 0 / 0 returns NaN but calcWeight should not return NaN!
+        assertEquals(1.0 / 0, instance.calcWeight(createEdge(0, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
     EdgeIterator createEdge( final double distance, final long flags )
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index f289a3fa95..f39640cb08 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -17,17 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.GHUtility;
 
-import java.util.HashMap;
-import java.util.Map;
-
 import org.junit.Test;
-
 import static org.junit.Assert.*;
 
 /**
@@ -36,25 +33,25 @@
  */
 public class FootFlagEncoderTest
 {
-    private EncodingManager encodingManager = new EncodingManager("CAR,BIKE,FOOT");
-    private FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+    private final EncodingManager encodingManager = new EncodingManager("CAR,BIKE,FOOT");
+    private final FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
 
     @Test
     public void testGetSpeed()
     {
         long fl = footEncoder.setProperties(10, true, true);
-        assertEquals(10, footEncoder.getSpeed(fl));
+        assertEquals(10, footEncoder.getSpeed(fl), 1e-1);
     }
 
     @Test
     public void testBasics()
     {
         long fl = footEncoder.flagsDefault(true, true);
-        assertEquals(FootFlagEncoder.MEAN, footEncoder.getSpeed(fl));
+        assertEquals(FootFlagEncoder.MEAN_SPEED, footEncoder.getSpeed(fl), 1e-1);
 
         long fl1 = footEncoder.flagsDefault(true, false);
-        long fl2 = footEncoder.swapDirection(fl1);
-        assertEquals(footEncoder.getSpeed(fl2), footEncoder.getSpeed(fl1));
+        long fl2 = footEncoder.reverseFlags(fl1);
+        assertEquals(footEncoder.getSpeed(fl2), footEncoder.getSpeed(fl1), 1e-1);
     }
 
     @Test
@@ -62,15 +59,15 @@ public void testCombined()
     {
         FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
         long fl = footEncoder.setProperties(10, true, true) | carEncoder.setProperties(100, true, false);
-        assertEquals(10, footEncoder.getSpeed(fl));
+        assertEquals(10, footEncoder.getSpeed(fl), 1e-1);
         assertTrue(footEncoder.isForward(fl));
         assertTrue(footEncoder.isBackward(fl));
 
-        assertEquals(100, carEncoder.getSpeed(fl));
+        assertEquals(100, carEncoder.getSpeed(fl), 1e-1);
         assertTrue(carEncoder.isForward(fl));
         assertFalse(carEncoder.isBackward(fl));
 
-        assertEquals(0, carEncoder.getSpeed(footEncoder.setProperties(10, true, true)));
+        assertEquals(0, carEncoder.getSpeed(footEncoder.setProperties(10, true, true)), 1e-1);
     }
 
     @Test
@@ -89,121 +86,182 @@ public void testGraph()
     @Test
     public void testAccess()
     {
-        Map<String, String> map = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, map);
+        OSMWay way = new OSMWay(1);
 
-        map.put("highway", "motorway");
-        map.put("sidewalk", "yes");
+        way.setTag("highway", "motorway");
+        way.setTag("sidewalk", "yes");
         assertTrue(footEncoder.acceptWay(way) > 0);
-        map.put("sidewalk", "left");
+        way.setTag("sidewalk", "left");
         assertTrue(footEncoder.acceptWay(way) > 0);
 
-        map.put("sidewalk", "none");
+        way.setTag("sidewalk", "none");
         assertFalse(footEncoder.acceptWay(way) > 0);
-        map.clear();
+        way.clearTags();
 
-        map.put("highway", "pedestrian");
+        way.setTag("highway", "pedestrian");
         assertTrue(footEncoder.acceptWay(way) > 0);
 
-        map.put("highway", "footway");
+        way.setTag("highway", "footway");
         assertTrue(footEncoder.acceptWay(way) > 0);
 
-        map.put("highway", "motorway");
+        way.setTag("highway", "motorway");
         assertFalse(footEncoder.acceptWay(way) > 0);
 
-        map.put("highway", "path");
+        way.setTag("highway", "path");
         assertTrue(footEncoder.acceptWay(way) > 0);
 
-        map.put("bicycle", "official");
+        way.setTag("bicycle", "official");
+        assertTrue(footEncoder.acceptWay(way) > 0);
+        way.setTag("foot", "no");
         assertFalse(footEncoder.acceptWay(way) > 0);
 
-        map.put("foot", "official");
+        way.setTag("foot", "official");
         assertTrue(footEncoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "service");
-        map.put("access", "no");
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "no");
         assertFalse(footEncoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "tertiary");
-        map.put("motorroad", "yes");
+        way.clearTags();
+        way.setTag("highway", "tertiary");
+        way.setTag("motorroad", "yes");
         assertFalse(footEncoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "cycleway");
-        assertFalse(footEncoder.acceptWay(way) > 0);
-        map.put("foot", "yes");
+        way.clearTags();
+        way.setTag("highway", "cycleway");
         assertTrue(footEncoder.acceptWay(way) > 0);
+        way.setTag("foot", "no");
+        assertFalse(footEncoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("highway", "track");
-        map.put("ford", "yes");
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("ford", "yes");
         assertFalse(footEncoder.acceptWay(way) > 0);
-        map.put("foot", "yes");
+        way.setTag("foot", "yes");
         assertTrue(footEncoder.acceptWay(way) > 0);
 
-        map.clear();
-        map.put("route", "ferry");
+        way.clearTags();
+        way.setTag("route", "ferry");
         assertTrue(footEncoder.acceptWay(way) > 0);
-        map.put("foot", "no");
+        way.setTag("foot", "no");
         assertFalse(footEncoder.acceptWay(way) > 0);
     }
 
     @Test
     public void testMixSpeedAndSafe()
     {
-        Map<String, String> map = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, map);
-
-        map.put("highway", "motorway");
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "motorway");
         long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
         assertEquals(0, flags);
 
-        map.put("sidewalk", "yes");
+        way.setTag("sidewalk", "yes");
         flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertEquals(5, footEncoder.getSpeed(flags));
+        assertEquals(5, footEncoder.getSpeed(flags), 1e-1);
 
-        map.clear();
-        map.put("highway", "track");
+        way.clearTags();
+        way.setTag("highway", "track");
         flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertEquals(5, footEncoder.getSpeed(flags));
+        assertEquals(5, footEncoder.getSpeed(flags), 1e-1);
+    }
+
+    @Test
+    public void testPriority()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "cycleway");
+        assertEquals(PriorityCode.UNCHANGED.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.setTag("highway", "track");
+        way.setTag("bicycle", "official");
+        assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
+        
+        way.setTag("highway", "track");
+        way.setTag("bicycle", "designated");
+        assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
     }
 
     @Test
     public void testSlowHiking()
     {
-        Map<String, String> map = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, map);
-        map.put("highway", "track");
-        map.put("sac_scale", "hiking");
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("sac_scale", "hiking");
         long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertEquals(FootFlagEncoder.MEAN, footEncoder.getSpeed(flags));
+        assertEquals(FootFlagEncoder.MEAN_SPEED, footEncoder.getSpeed(flags), 1e-1);
 
-        map.put("highway", "track");
-        map.put("sac_scale", "mountain_hiking");
+        way.setTag("highway", "track");
+        way.setTag("sac_scale", "mountain_hiking");
         flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertEquals(FootFlagEncoder.SLOW, footEncoder.getSpeed(flags));
+        assertEquals(FootFlagEncoder.SLOW_SPEED, footEncoder.getSpeed(flags), 1e-1);
     }
-    
+
     @Test
-    public void testTurnFlagEncoding_noCostsAndRestrictions() {
+    public void testTurnFlagEncoding_noCostsAndRestrictions()
+    {
         long flags_r0 = footEncoder.getTurnFlags(true, 0);
         long flags_0 = footEncoder.getTurnFlags(false, 0);
-        
+
         long flags_r20 = footEncoder.getTurnFlags(true, 20);
         long flags_20 = footEncoder.getTurnFlags(false, 20);
-        
-        assertEquals(0, footEncoder.getTurnCosts(flags_r0));
-        assertEquals(0, footEncoder.getTurnCosts(flags_0));
-        
-        assertEquals(0,footEncoder.getTurnCosts(flags_r20));
-        assertEquals(0, footEncoder.getTurnCosts(flags_20));
-        
+
+        assertEquals(0, footEncoder.getTurnCost(flags_r0), 1e-1);
+        assertEquals(0, footEncoder.getTurnCost(flags_0), 1e-1);
+
+        assertEquals(0, footEncoder.getTurnCost(flags_r20), 1e-1);
+        assertEquals(0, footEncoder.getTurnCost(flags_20), 1e-1);
+
         assertFalse(footEncoder.isTurnRestricted(flags_r0));
         assertFalse(footEncoder.isTurnRestricted(flags_0));
-        
+
         assertFalse(footEncoder.isTurnRestricted(flags_r20));
         assertFalse(footEncoder.isTurnRestricted(flags_20));
     }
+
+    @Test
+    public void testBarrierAccess()
+    {
+        // by default allow access through the gate for bike & foot!
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        // no barrier!
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "yes");
+        // no barrier!
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        // barrier!
+        assertTrue(footEncoder.handleNodeTags(node) > 0);
+
+        node.setTag("bicycle", "yes");
+        // no barrier!?
+        // assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        node.setTag("access", "no");
+        node.setTag("foot", "yes");
+        // no barrier!
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+
+        node.setTag("locked", "yes");
+        // barrier!
+        assertTrue(footEncoder.handleNodeTags(node) > 0);
+    }
+
+    @Test
+    public void handleWayTagsRoundabout() {
+        OSMWay way = new OSMWay(1);
+        way.setTag("junction", "roundabout");
+        way.setTag("highway", "tertiary");
+        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/trees/QuadTreeSimpleTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
similarity index 57%
rename from core/src/test/java/com/graphhopper/trees/QuadTreeSimpleTest.java
rename to core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 67c6090060..92f737654c 100644
--- a/core/src/test/java/com/graphhopper/trees/QuadTreeSimpleTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -2,21 +2,22 @@
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
  *  license agreements. See the NOTICE file distributed with this work for 
  *  additional information regarding copyright ownership.
- * 
+ *
  *  GraphHopper licenses this file to you under the Apache License, 
  *  Version 2.0 (the "License"); you may not use this file except in 
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.trees;
+package com.graphhopper.routing.util;
 
+import com.graphhopper.reader.OSMWay;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -24,25 +25,20 @@
  *
  * @author Peter Karich
  */
-public class QuadTreeSimpleTest extends QuadTreeTester
+public class MotorcycleFlagEncoderTest
 {
-    @Override
-    protected QuadTree<Long> createQuadTree( long items )
-    {
-        QuadTreeSimple<Long> qt = new QuadTreeSimple<Long>();
-        qt.init(items);
-        return qt;
-    }
+    private final EncodingManager em = new EncodingManager("motorcycle,foot");
+    private final MotorcycleFlagEncoder encoder = (MotorcycleFlagEncoder) em.getEncoder("motorcycle");
 
     @Test
-    public void testNodePutNull()
+    public void testHandleWayTags()
     {
-        try
-        {
-            createQuadTree(10).add(10, 10, null);
-            assertTrue("an exception should be thrown on 'storing null' as we rely on this in datanode", false);
-        } catch (Exception ex)
-        {
-        }
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        long flags = encoder.acceptWay(way);
+        assertTrue(flags > 0);
+        long result = encoder.handleWayTags(way, flags, 0);
+        assertEquals(20, encoder.getSpeed(result), .1);
+        assertEquals(20, encoder.getReverseSpeed(result), .1);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
index 3bd1054885..6fcd32a6f8 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
@@ -1,200 +1,204 @@
 /*
- * Copyright 2013 User.
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *       http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
  */
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
+import static com.graphhopper.routing.util.PriorityCode.*;
 import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicInteger;
-
 import static org.junit.Assert.*;
 
 public class MountainBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
 {
     @Override
-    BikeFlagCommonEncoder createBikeEncoder()
+    protected BikeCommonFlagEncoder createBikeEncoder()
     {
-        return (BikeFlagCommonEncoder) new EncodingManager("BIKE,MTB").getEncoder("MTB");
+        return (BikeCommonFlagEncoder) new EncodingManager("BIKE,MTB").getEncoder("MTB");
     }
 
     @Test
     public void testGetSpeed()
     {
         long result = encoder.setProperties(10, true, true);
-        assertEquals(10, encoder.getSpeed(result));
+        assertEquals(10, encoder.getSpeed(result), 1e-1);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "primary");
-        assertEquals(10, encoder.getSpeed(way));
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(REACH_DEST.getValue(), way);
 
         way.setTag("highway", "residential");
-        assertEquals(15, encoder.getSpeed(way));
+        assertEquals(16, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
         // Test pushing section speeds
         way.setTag("highway", "footway");
         assertEquals(4, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
         way.setTag("highway", "track");
-        assertEquals(24, encoder.getSpeed(way));
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
 
         way.setTag("highway", "steps");
-        assertEquals(2, encoder.getSpeed(way));
-
-        way.setTag("highway", "service");
-        assertEquals(15, encoder.getSpeed(way));
-        way.setTag("service", "parking_aisle");
-        assertEquals(15, encoder.getSpeed(way));
+        assertEquals(4, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
         way.clearTags();
 
         // test speed for allowed pushing section types
         way.setTag("highway", "track");
         way.setTag("bicycle", "yes");
-        assertEquals(24, encoder.getSpeed(way));
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
 
         way.setTag("highway", "track");
         way.setTag("bicycle", "yes");
         way.setTag("tracktype", "grade3");
-        assertEquals(20, encoder.getSpeed(way));
+        assertPriority(VERY_NICE.getValue(), way);
 
         way.setTag("surface", "paved");
-        assertEquals(12, encoder.getSpeed(way));
+        assertEquals(18, encoder.getSpeed(way));
+        assertPriority(VERY_NICE.getValue(), way);
 
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("surface", "ground");
-        assertEquals(20, encoder.getSpeed(way));
+        assertEquals(16, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+    }
+
+    @Test
+    @Override
+    public void testSacScale()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        way.setTag("sac_scale", "hiking");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("highway", "service");
+        way.setTag("sac_scale", "mountain_hiking");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("sac_scale", "alpine_hiking");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("sac_scale", "demanding_alpine_hiking");
+        assertTrue(encoder.acceptWay(way) == 0);
     }
 
     @Test
     public void testHandleWayTags()
     {
-        Map<String, String> wayMap = new HashMap<String, String>();
-        OSMWay way = new OSMWay(1, wayMap);
+        OSMWay way = new OSMWay(1);
         String wayType;
 
-        wayMap.put("highway", "track");
-        wayType = encodeDecodeWayType("", way);
+        way.setTag("highway", "track");
+        wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
 
-        wayMap.clear();
-        wayMap.put("highway", "path");
-        wayType = encodeDecodeWayType("", way);
+        way.clearTags();
+        way.setTag("highway", "path");
+        wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
 
-        wayMap.clear();
-        wayMap.put("highway", "path");
-        wayMap.put("surface", "grass");
-        wayType = encodeDecodeWayType("", way);
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("surface", "grass");
+        wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
 
-        wayMap.clear();
-        wayMap.put("highway", "path");
-        wayMap.put("surface", "concrete");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("way", wayType);
-
-        wayMap.clear();
-        wayMap.put("highway", "track");
-        wayMap.put("foot", "yes");
-        wayMap.put("surface", "paved");
-        wayMap.put("tracktype", "grade1");
-        wayType = encodeDecodeWayType("", way);
-        assertEquals("way", wayType);
-
-        wayMap.clear();
-        wayMap.put("highway", "track");
-        wayMap.put("foot", "yes");
-        wayMap.put("surface", "paved");
-        wayMap.put("tracktype", "grade2");
-        wayType = encodeDecodeWayType("", way);
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("surface", "concrete");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("foot", "yes");
+        way.setTag("surface", "paved");
+        way.setTag("tracktype", "grade1");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("foot", "yes");
+        way.setTag("surface", "paved");
+        way.setTag("tracktype", "grade2");
+        wayType = getWayTypeFromFlags(way);
         assertEquals("way, unpaved", wayType);
 
+        way.clearTags();
+        way.setTag("highway", "pedestrian");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
     }
 
     @Test
     public void testHandleWayTagsInfluencedByRelation()
     {
-        Map<String, String> wayMap = new HashMap<String, String>();
-        OSMWay osmWay = new OSMWay(1, wayMap);
-        wayMap.put("highway", "track");
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "track");
         long allowed = encoder.acceptBit;
 
-        Map<String, String> relMap = new HashMap<String, String>();
-        OSMRelation osmRel = new OSMRelation(1, relMap);
-
+        OSMRelation osmRel = new OSMRelation(1);
         long relFlags = encoder.handleRelationTags(osmRel, 0);
         // unchanged
         long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(24, encoder.getSpeed(flags));
-        assertEquals(3, encoder.getWayTypeCode(flags));
-        assertEquals(1, encoder.getPavementCode(flags));
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals("way, unpaved", getWayTypeFromFlags(osmWay));
 
         // relation code is PREFER
-        relMap.put("route", "bicycle");
-        relMap.put("network", "lcn");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(28, encoder.getSpeed(flags));
-        assertEquals(3, encoder.getWayTypeCode(flags));
-        assertEquals(1, encoder.getPavementCode(flags));
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals("way, unpaved", getWayTypeFromFlags(osmWay));
 
         // relation code is PREFER
-        relMap.put("network", "rcn");
+        osmRel.setTag("network", "rcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(28, encoder.getSpeed(flags));
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
 
         // relation code is PREFER
-        relMap.put("network", "ncn");
+        osmRel.setTag("network", "ncn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(28, encoder.getSpeed(flags));
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
 
         // PREFER relation, but tertiary road
         // => no pushing section but road wayTypeCode and faster
-        wayMap.clear();
-        wayMap.put("highway", "tertiary");
+        osmWay.clearTags();
+        osmWay.setTag("highway", "tertiary");
 
-        relMap.put("route", "bicycle");
-        relMap.put("network", "lcn");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(18, encoder.getSpeed(flags));
-        assertEquals(0, encoder.getWayTypeCode(flags));
-
-        // test max and min speed
-        final AtomicInteger fakeSpeed = new AtomicInteger(40);
-        MountainBikeFlagEncoder fakeEncoder = new MountainBikeFlagEncoder()
-        {
-            @Override
-            int relationWeightCodeToSpeed( int highwaySpeed, int relationCode )
-            {
-                return fakeSpeed.get();
-            }
-        };
-        // call necessary register
-        new EncodingManager().registerEncoder(fakeEncoder);
-        allowed = fakeEncoder.acceptBit;
-
-        flags = fakeEncoder.handleWayTags(osmWay, allowed, 1);
-        assertEquals(30, fakeEncoder.getSpeed(flags));
-
-        fakeSpeed.set(-2);
-        flags = fakeEncoder.handleWayTags(osmWay, allowed, 1);
-        assertEquals(0, fakeEncoder.getSpeed(flags));
-
+        assertEquals(18, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PriorityCode.PREFER.getValue(), osmWay);
+        assertEquals("", getWayTypeFromFlags(osmWay));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index f172436b74..61a2936111 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -17,13 +17,14 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.reader.OSMWay;
-import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.GHUtility;
+
+import gnu.trove.list.array.TIntArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Map;
 import org.junit.*;
 import static org.junit.Assert.*;
@@ -34,7 +35,7 @@
  */
 public class PrepareRoutingSubnetworksTest
 {
-    private final EncodingManager em = new EncodingManager("CAR");
+    private final EncodingManager em = new EncodingManager("car");
 
     GraphStorage createGraph( EncodingManager eman )
     {
@@ -148,4 +149,109 @@ public void testRemoveSubnetworkIfOnlyOneVehicle()
         g.optimize();
         assertEquals(7, g.getNodes());
     }
+
+    GraphStorage createDeadEndUnvisitedNetworkGraph( EncodingManager em )
+    {
+        GraphStorage g = createGraph(em);
+        // 0 <-> 1 <-> 2 <-> 3 <-> 4 <- 5 <-> 6
+        g.edge(0, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        g.edge(2, 3, 1, true);
+        g.edge(3, 4, 1, true);
+        g.edge(5, 4, 1, false);
+        g.edge(5, 6, 1, true);
+
+        // 7 -> 8 <-> 9 <-> 10
+        g.edge(7, 8, 1, false);
+        g.edge(8, 9, 1, true);
+        g.edge(9, 10, 1, true);
+
+        return g;
+    }
+
+    GraphStorage createTarjanTestGraph()
+    {
+        GraphStorage g = createGraph(em);
+
+        g.edge(1, 2, 1, false);
+        g.edge(2, 3, 1, false);
+        g.edge(3, 1, 1, false);
+
+        g.edge(4, 2, 1, false);
+        g.edge(4, 3, 1, false);
+        g.edge(4, 5, 1, true);
+        g.edge(5, 6, 1, false);
+
+        g.edge(6, 3, 1, false);
+        g.edge(6, 7, 1, true);
+
+        g.edge(8, 5, 1, false);
+        g.edge(8, 7, 1, false);
+        g.edge(8, 8, 1, false);
+
+        return g;
+    }
+
+    @Test
+    public void testRemoveDeadEndUnvisitedNetworks()
+    {
+        GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
+        assertEquals(11, g.getNodes());
+
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(3);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
+
+        assertEquals(3, removed);
+
+        g.optimize();
+        assertEquals(8, g.getNodes());
+    }
+
+    @Test
+    public void testTarjan()
+    {
+        GraphStorage g = createSubnetworkTestGraph();
+
+        // Requires a single vehicle type, otherwise we throw.
+        final FlagEncoder flagEncoder = em.getEncoder("car");
+        final EdgeFilter filter = new DefaultEdgeFilter(flagEncoder, false, true);
+
+        TarjansStronglyConnectedComponentsAlgorithm tarjan = new TarjansStronglyConnectedComponentsAlgorithm(g, filter);
+
+        List<TIntArrayList> components = tarjan.findComponents();
+
+        assertEquals(4, components.size());
+        assertEquals(new TIntArrayList(new int[]
+        {
+            13, 5, 3, 7, 0
+        }), components.get(0));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            2, 4, 12, 11, 8, 1
+        }), components.get(1));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            10, 14, 6
+        }), components.get(2));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            9
+        }), components.get(3));
+    }
+
+    // Previous two-pass implementation failed on 1 -> 2 -> 0
+    @Test
+    public void testNodeOrderingRegression()
+    {
+        // 1 -> 2 -> 0
+        GraphStorage g = createGraph(em);
+        g.edge(1, 2, 1, false);
+        g.edge(2, 0, 1, false);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(2);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
+
+        assertEquals(3, removed);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
index e6add0c5a1..6012124c1a 100644
--- a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
@@ -19,9 +19,8 @@
 
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMWay;
-import static com.graphhopper.routing.util.BikeFlagCommonEncoder.PUSHING_SECTION_SPEED;
-import java.util.HashMap;
-import java.util.Map;
+import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
+import static com.graphhopper.routing.util.PriorityCode.*;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -32,72 +31,159 @@
 public class RacingBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester
 {
     @Override
-    BikeFlagCommonEncoder createBikeEncoder()
+    protected BikeCommonFlagEncoder createBikeEncoder()
     {
-        return (BikeFlagCommonEncoder) new EncodingManager("BIKE,MTB,RACINGBIKE").getEncoder("RACINGBIKE");
+        return (BikeCommonFlagEncoder) new EncodingManager("BIKE,RACINGBIKE").getEncoder("RACINGBIKE");
+    }
+
+    @Test
+    @Override
+    public void testAvoidTunnel()
+    {
+        // tunnel is not that bad for racing bike
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "residential");
+        osmWay.setTag("tunnel", "yes");
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("highway", "secondary");
+        osmWay.setTag("tunnel", "yes");
+        assertPriority(UNCHANGED.getValue(), osmWay);
+
+        osmWay.setTag("bicycle", "designated");
+        assertPriority(PREFER.getValue(), osmWay);
+    }
+
+    @Test
+    @Override
+    public void testService()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        assertEquals(12, encoder.getSpeed(way));
+        assertPriority(UNCHANGED.getValue(), way);
+
+        way.setTag("service", "parking_aisle");
+        assertEquals(6, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+    }
+
+    @Test
+    @Override
+    public void testSacScale()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "service");
+        way.setTag("sac_scale", "mountain_hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+        
+        way.setTag("highway", "path");
+        way.setTag("sac_scale", "hiking");
+        // disallow
+        assertEquals(0, encoder.acceptWay(way));
+        
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");
+        // but allow this as there is no reason for not allowing it
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        // This looks to be tagging error:
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "mountain_hiking");
+        // we are coutious and disallow this
+        assertEquals(0, encoder.acceptWay(way));
     }
 
     @Test
     public void testGetSpeed()
     {
         long result = encoder.setProperties(10, true, true);
-        assertEquals(10, encoder.getSpeed(result));
+        assertEquals(10, encoder.getSpeed(result), 1e-1);
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "track");
         way.setTag("tracktype", "grade3");
-        // Pushing section speed/2
-        assertEquals(PUSHING_SECTION_SPEED / 2, getEncodedDecodedSpeed(way));
+        // Pushing section
+        assertEquals(PUSHING_SECTION_SPEED, getSpeedFromFlags(way), 1e-1);
 
-        // Even if it is part of a cycle way PUSHING_SECTION_SPEED/2
+        // Even if it is part of a cycle way
         way.setTag("bicycle", "yes");
-        assertEquals(PUSHING_SECTION_SPEED / 2, getEncodedDecodedSpeed(way));
+        assertEquals(PUSHING_SECTION_SPEED, getSpeedFromFlags(way), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "steps");
-        assertEquals(2, getEncodedDecodedSpeed(way));
-
+        assertEquals(2, getSpeedFromFlags(way), 1e-1);
     }
 
     @Test
     public void testHandleWayTagsInfluencedByRelation()
     {
-        Map<String, String> wayMap = new HashMap<String, String>();
-        OSMWay osmWay = new OSMWay(1, wayMap);
-        wayMap.put("highway", "track");
-        long allowed = encoder.acceptBit;
-
-        Map<String, String> relMap = new HashMap<String, String>();
-        OSMRelation osmRel = new OSMRelation(1, relMap);
-
-        assertEquals(PUSHING_SECTION_SPEED / 2, getEncodedDecodedSpeed(osmWay));
+        OSMWay osmWay = new OSMWay(1);
+        osmWay.setTag("highway", "track");
+        assertEquals(PUSHING_SECTION_SPEED / 2, getSpeedFromFlags(osmWay), 1e-1);
+        assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, 0));
 
         // relation code is PREFER
-        relMap.put("route", "bicycle");
-        relMap.put("network", "lcn");
+        long allowed = encoder.acceptBit;
+        OSMRelation osmRel = new OSMRelation(1);
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
         long relFlags = encoder.handleRelationTags(osmRel, 0);
         long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(2, encoder.getSpeed(flags));
-        assertEquals(1, encoder.getWayTypeCode(flags)); // Pushing section
-        assertEquals(1, encoder.getPavementCode(flags)); //  Unpaved
+        assertEquals(2, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
+        assertEquals("way, unpaved", getWayTypeFromFlags(osmWay, relFlags));
 
         // relation code is OUTSTANDING NICE but as unpaved, the speed is still PUSHING_SECTION_SPEED/2
-        relMap.put("network", "icn");
+        osmRel.setTag("network", "icn");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(2, encoder.getSpeed(flags));
+        assertEquals(2, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
 
         // Now we assume bicycle=yes, anyhow still unpaved
-        wayMap.put("bicycle", "yes");
+        osmWay.setTag("bicycle", "yes");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(2, encoder.getSpeed(flags));
+        assertEquals(2, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
 
-        // Now we assume bicycle=yes, and paved -> The speed is pushed!
-        wayMap.put("tracktype", "grade1");
+        // Now we assume bicycle=yes, and paved
+        osmWay.setTag("tracktype", "grade1");
         relFlags = encoder.handleRelationTags(osmRel, 0);
         flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals(30, encoder.getSpeed(flags));
+        assertEquals(20, encoder.getSpeed(flags), 1e-1);
+        assertPriority(PREFER.getValue(), osmWay, relFlags);
+        assertEquals("", getWayTypeFromFlags(osmWay, relFlags));
 
-    }
+        // Now we assume bicycle=yes, and unpaved as part of a cycle relation
+        osmWay.setTag("tracktype", "grade2");
+        osmWay.setTag("bicycle", "yes");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        assertEquals(10, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
+        assertEquals("way, unpaved", getWayTypeFromFlags(osmWay, relFlags));
+
+        // Now we assume bicycle=yes, and unpaved not part of a cycle relation
+        osmRel.clearTags();
+        osmWay.clearTags();
+        osmWay.setTag("highway", "track");
+        osmWay.setTag("tracktype", "grade3");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        assertEquals(4, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
+        assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, relFlags));
 
+        // Now we assume bicycle=yes, and tracktype = null
+        osmRel.clearTags();
+        osmWay.clearTags();
+        osmWay.setTag("highway", "track");
+        relFlags = encoder.handleRelationTags(osmRel, 0);
+        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        assertEquals(2, encoder.getSpeed(flags), 1e-1);
+        assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
+        assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, relFlags));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/search/NameIndexTest.java b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
index c990ad6065..746d286993 100644
--- a/core/src/test/java/com/graphhopper/search/NameIndexTest.java
+++ b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
@@ -37,7 +37,7 @@ public void testNoErrorOnLargeName()
         {
             str += "ß";
         }
-        int result = index.put(str);
+        long result = index.put(str);
         assertEquals(127, index.get(result).length());
     }
 
@@ -45,10 +45,10 @@ public void testNoErrorOnLargeName()
     public void testPut()
     {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
-        int result = index.put("Something Streetä");
+        long result = index.put("Something Streetä");
         assertEquals("Something Streetä", index.get(result));
 
-        int existing = index.put("Something Streetä");
+        long existing = index.put("Something Streetä");
         assertEquals(result, existing);
 
         result = index.put("testing");
@@ -65,10 +65,10 @@ public void testCreate()
     {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
         String str1 = "nice";
-        int pointer1 = index.put(str1);
+        long pointer1 = index.put(str1);
 
         String str2 = "nice work äöß";
-        int pointer2 = index.put(str2);
+        long pointer2 = index.put(str2);
 
         assertEquals(str2, index.get(pointer2));
         assertEquals(str1, index.get(pointer1));
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
index ed7764e4a1..8850b1c893 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractDirectoryTester.java
@@ -48,24 +48,14 @@ public void setUp()
         Helper.removeDir(new File(location));
     }
 
-    @Test
-    public void testRename()
-    {
-        Directory dir = createDir();
-        da = dir.find("testing");
-        da.create(100);
-        da.flush();
-        dir.rename(da, "newtesting");
-    }
-
     @Test
     public void testRequestedDataAccessHasToBeTheIdenticalType()
     {
         Directory dir = createDir();
-        da = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false));
+        da = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false, false));
         try
         {
-            dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, true));
+            dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false, true));
             assertFalse(true);
         } catch (Exception ex)
         {
@@ -76,8 +66,8 @@ public void testRequestedDataAccessHasToBeTheIdenticalType()
     public void testSynched()
     {
         Directory dir = createDir();
-        DataAccess da1 = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, false));
-        da = dir.find("testing_synched", new DAType(DAType.MemRef.HEAP, false, false, true));
+        DataAccess da1 = dir.find("testing", new DAType(DAType.MemRef.HEAP, false, false, true, false));
+        da = dir.find("testing_synched", new DAType(DAType.MemRef.HEAP, false, false, true, true));
         assertFalse(da.getClass() == da1.getClass());
         da1.close();
     }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index c5f80db2dd..b16536a2c3 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -23,7 +23,9 @@
 import com.graphhopper.util.shapes.BBox;
 import java.io.Closeable;
 import java.io.File;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import static org.junit.Assert.*;
 import org.junit.After;
 import org.junit.Before;
@@ -37,9 +39,9 @@
  */
 public abstract class AbstractGraphStorageTester
 {
-    private final String location = "./target/graphstorage";
+    private final String locationParent = "./target/graphstorage";
     protected int defaultSize = 100;
-    protected String defaultGraph = "./target/graphstorage/default";
+    protected String defaultGraphLoc = "./target/graphstorage/default";
     protected EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
     protected CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
     protected FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
@@ -52,31 +54,31 @@
 
     protected GraphStorage createGraph()
     {
-        GraphStorage g = createGraph(defaultGraph, defaultSize);
+        GraphStorage g = createGraph(defaultGraphLoc, false);
         carOutExplorer = g.createEdgeExplorer(carOutFilter);
         carInExplorer = g.createEdgeExplorer(carInFilter);
         carAllExplorer = g.createEdgeExplorer();
         return g;
     }
 
-    abstract GraphStorage createGraph( String location, int size );
+    abstract GraphStorage createGraph( String location, boolean is3D );
 
     protected GraphStorage newRAMGraph()
     {
-        return new GraphHopperStorage(new RAMDirectory(), encodingManager);
+        return new GraphHopperStorage(new RAMDirectory(), encodingManager, false);
     }
 
     @Before
     public void setUp()
     {
-        Helper.removeDir(new File(location));
+        Helper.removeDir(new File(locationParent));
     }
 
     @After
     public void tearDown()
     {
         Helper.close((Closeable) graph);
-        Helper.removeDir(new File(location));
+        Helper.removeDir(new File(locationParent));
     }
 
     @Test
@@ -92,9 +94,10 @@ public void testInfinityWeight()
     public void testSetNodes()
     {
         graph = createGraph();
+        NodeAccess na = graph.getNodeAccess();
         for (int i = 0; i < defaultSize * 2; i++)
         {
-            graph.setNode(i, 2 * i, 3 * i);
+            na.setNode(i, 2 * i, 3 * i);
         }
         graph.edge(defaultSize + 1, defaultSize + 2, 10, true);
         graph.edge(defaultSize + 1, defaultSize + 3, 10, true);
@@ -232,13 +235,14 @@ public void testClone()
     {
         graph = createGraph();
         graph.edge(1, 2, 10, true);
-        graph.setNode(0, 12, 23);
-        graph.setNode(1, 8, 13);
-        graph.setNode(2, 2, 10);
-        graph.setNode(3, 5, 9);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 12, 23);
+        na.setNode(1, 8, 13);
+        na.setNode(2, 2, 10);
+        na.setNode(3, 5, 9);
         graph.edge(1, 3, 10, true);
 
-        Graph clone = graph.copyTo(createGraph(location + "/clone", defaultSize));
+        Graph clone = graph.copyTo(createGraph(locationParent + "/clone", false));
         assertEquals(graph.getNodes(), clone.getNodes());
         assertEquals(count(carOutExplorer.setBaseNode(1)), count(clone.createEdgeExplorer(carOutFilter).setBaseNode(1)));
         clone.edge(1, 4, 10, true);
@@ -247,12 +251,27 @@ public void testClone()
         Helper.close((Closeable) clone);
     }
 
+    @Test
+    public void testCopyProperties()
+    {
+        graph = createGraph();
+        EdgeIteratorState edge = graph.edge(1, 3, 10, false).setName("testing").setWayGeometry(Helper.createPointList(1, 2));
+
+        EdgeIteratorState newEdge = graph.edge(1, 3, 10, false);
+        edge.copyPropertiesTo(newEdge);
+        assertEquals(edge.getName(), newEdge.getName());
+        assertEquals(edge.getDistance(), newEdge.getDistance(), 1e-7);
+        assertEquals(edge.getFlags(), newEdge.getFlags());
+        assertEquals(edge.fetchWayGeometry(0), newEdge.fetchWayGeometry(0));
+    }
+
     @Test
     public void testGetLocations()
     {
         graph = createGraph();
-        graph.setNode(0, 12, 23);
-        graph.setNode(1, 22, 23);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 12, 23);
+        na.setNode(1, 22, 23);
         assertEquals(2, graph.getNodes());
 
         graph.edge(0, 1, 10, true);
@@ -308,12 +327,13 @@ public void testAddLocation()
 
     protected void initExampleGraph( Graph g )
     {
-        g.setNode(0, 12, 23);
-        g.setNode(1, 38.33f, 135.3f);
-        g.setNode(2, 6, 139);
-        g.setNode(3, 78, 89);
-        g.setNode(4, 2, 1);
-        g.setNode(5, 7, 5);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 12, 23);
+        na.setNode(1, 38.33f, 135.3f);
+        na.setNode(2, 6, 139);
+        na.setNode(3, 78, 89);
+        na.setNode(4, 2, 1);
+        na.setNode(5, 7, 5);
         g.edge(0, 1, 12, true);
         g.edge(0, 2, 212, true);
         g.edge(0, 3, 212, true);
@@ -323,17 +343,18 @@ protected void initExampleGraph( Graph g )
 
     private void checkExampleGraph( Graph graph )
     {
-        assertEquals(12f, graph.getLatitude(0), 1e-6);
-        assertEquals(23f, graph.getLongitude(0), 1e-6);
+        NodeAccess na = graph.getNodeAccess();
+        assertEquals(12f, na.getLatitude(0), 1e-6);
+        assertEquals(23f, na.getLongitude(0), 1e-6);
 
-        assertEquals(38.33f, graph.getLatitude(1), 1e-6);
-        assertEquals(135.3f, graph.getLongitude(1), 1e-6);
+        assertEquals(38.33f, na.getLatitude(1), 1e-6);
+        assertEquals(135.3f, na.getLongitude(1), 1e-6);
 
-        assertEquals(6, graph.getLatitude(2), 1e-6);
-        assertEquals(139, graph.getLongitude(2), 1e-6);
+        assertEquals(6, na.getLatitude(2), 1e-6);
+        assertEquals(139, na.getLongitude(2), 1e-6);
 
-        assertEquals(78, graph.getLatitude(3), 1e-6);
-        assertEquals(89, graph.getLongitude(3), 1e-6);
+        assertEquals(78, na.getLatitude(3), 1e-6);
+        assertEquals(89, na.getLongitude(3), 1e-6);
 
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(carOutExplorer.setBaseNode((1))));
         assertEquals(GHUtility.asSet(5, 4, 3, 2, 1), GHUtility.getNeighbors(carOutExplorer.setBaseNode(0)));
@@ -425,10 +446,11 @@ public void testCheckFirstNode()
     public void testDeleteNodeForUnidir()
     {
         graph = createGraph();
-        graph.setNode(10, 10, 1);
-        graph.setNode(6, 6, 1);
-        graph.setNode(20, 20, 1);
-        graph.setNode(21, 21, 1);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(10, 10, 1);
+        na.setNode(6, 6, 1);
+        na.setNode(20, 20, 1);
+        na.setNode(21, 21, 1);
 
         graph.edge(10, 20, 10, false);
         graph.edge(21, 6, 10, false);
@@ -467,17 +489,18 @@ public void testComplexDeleteNode2()
     public void testDeleteNodes( int fillToSize )
     {
         graph = createGraph();
-        graph.setNode(0, 12, 23);
-        graph.setNode(1, 38.33f, 135.3f);
-        graph.setNode(2, 3, 3);
-        graph.setNode(3, 78, 89);
-        graph.setNode(4, 2, 1);
-        graph.setNode(5, 2.5f, 1);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 12, 23);
+        na.setNode(1, 38.33f, 135.3f);
+        na.setNode(2, 3, 3);
+        na.setNode(3, 78, 89);
+        na.setNode(4, 2, 1);
+        na.setNode(5, 2.5f, 1);
 
         int deleted = 2;
         for (int i = 6; i < fillToSize; i++)
         {
-            graph.setNode(i, i * 1.5, i * 1.6);
+            na.setNode(i, i * 1.5, i * 1.6);
             if (i % 3 == 0)
             {
                 graph.markNodeRemoved(i);
@@ -513,21 +536,22 @@ public void testDeleteNodes( int fillToSize )
 
         assertEquals(fillToSize - deleted, graph.getNodes());
         int id1 = getIdOf(graph, 38.33f);
-        assertEquals(135.3f, graph.getLongitude(id1), 1e-4);
+        assertEquals(135.3f, na.getLongitude(id1), 1e-4);
         assertTrue(containsLatitude(graph, carAllExplorer.setBaseNode(id1), 2.5));
         assertFalse(containsLatitude(graph, carAllExplorer.setBaseNode(id1), 12));
 
         int id3 = getIdOf(graph, 78);
-        assertEquals(89, graph.getLongitude(id3), 1e-4);
+        assertEquals(89, na.getLongitude(id3), 1e-4);
         assertTrue(containsLatitude(graph, carAllExplorer.setBaseNode(id3), 2.5));
         assertFalse(containsLatitude(graph, carAllExplorer.setBaseNode(id3), 12));
     }
 
     public boolean containsLatitude( Graph g, EdgeIterator iter, double latitude )
     {
+        NodeAccess na = g.getNodeAccess();
         while (iter.next())
         {
-            if (Math.abs(g.getLatitude(iter.getAdjNode()) - latitude) < 1e-4)
+            if (Math.abs(na.getLatitude(iter.getAdjNode()) - latitude) < 1e-4)
                 return true;
         }
         return false;
@@ -537,10 +561,11 @@ public boolean containsLatitude( Graph g, EdgeIterator iter, double latitude )
     public void testSimpleDelete()
     {
         graph = createGraph();
-        graph.setNode(0, 12, 23);
-        graph.setNode(1, 38.33f, 135.3f);
-        graph.setNode(2, 3, 3);
-        graph.setNode(3, 78, 89);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 12, 23);
+        na.setNode(1, 38.33f, 135.3f);
+        na.setNode(2, 3, 3);
+        na.setNode(3, 78, 89);
 
         graph.edge(3, 0, 21, true);
         graph.edge(5, 0, 22, true);
@@ -567,12 +592,13 @@ public void testSimpleDelete()
     public void testSimpleDelete2()
     {
         graph = createGraph();
+        NodeAccess na = graph.getNodeAccess();
         assertEquals(-1, getIdOf(graph, 12));
-        graph.setNode(9, 9, 1);
+        na.setNode(9, 9, 1);
         assertEquals(-1, getIdOf(graph, 12));
 
-        graph.setNode(11, 11, 1);
-        graph.setNode(12, 12, 1);
+        na.setNode(11, 11, 1);
+        na.setNode(12, 12, 1);
 
         // mini subnetwork which gets completely removed:
         graph.edge(5, 10, 510, true);
@@ -580,8 +606,8 @@ public void testSimpleDelete2()
         graph.markNodeRemoved(10);
 
         PointList pl = new PointList();
-        pl.add(1, 2);
-        pl.add(1, 3);
+        pl.add(1, 2, Double.NaN);
+        pl.add(1, 3, Double.NaN);
         graph.edge(9, 11, 911, true).setWayGeometry(pl);
         graph.edge(9, 12, 912, true).setWayGeometry(pl);
 
@@ -615,10 +641,11 @@ public void testSimpleDelete2()
     public void testSimpleDelete3()
     {
         graph = createGraph();
-        graph.setNode(7, 7, 1);
-        graph.setNode(8, 8, 1);
-        graph.setNode(9, 9, 1);
-        graph.setNode(11, 11, 1);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(7, 7, 1);
+        na.setNode(8, 8, 1);
+        na.setNode(9, 9, 1);
+        na.setNode(11, 11, 1);
 
         // mini subnetwork which gets completely removed:
         graph.edge(5, 10, 510, true);
@@ -646,11 +673,12 @@ public void testSimpleDelete3()
     public void testDeleteAndOptimize()
     {
         graph = createGraph();
-        graph.setNode(20, 10, 10);
-        graph.setNode(21, 10, 11);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(20, 10, 10);
+        na.setNode(21, 10, 11);
         graph.markNodeRemoved(20);
         graph.optimize();
-        assertEquals(11, graph.getLongitude(20), 1e-5);
+        assertEquals(11, na.getLongitude(20), 1e-5);
     }
 
     @Test
@@ -658,13 +686,14 @@ public void testBounds()
     {
         graph = createGraph();
         BBox b = graph.getBounds();
-        assertEquals(BBox.INVERSE.maxLat, b.maxLat, 1e-6);
+        assertEquals(BBox.createInverse(false).maxLat, b.maxLat, 1e-6);
 
-        graph.setNode(0, 10, 20);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 10, 20);
         assertEquals(10, b.maxLat, 1e-6);
         assertEquals(20, b.maxLon, 1e-6);
 
-        graph.setNode(0, 15, -15);
+        na.setNode(0, 15, -15);
         assertEquals(15, b.maxLat, 1e-6);
         assertEquals(20, b.maxLon, 1e-6);
         assertEquals(10, b.minLat, 1e-6);
@@ -772,13 +801,13 @@ public void testCreateDuplicateEdges()
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(2, oneIter.getBaseNode());
         assertTrue(carEncoder.isForward(oneIter.getFlags()));
-        assertFalse(carEncoder.isBoth(oneIter.getFlags()));
+        assertFalse(carEncoder.isBackward(oneIter.getFlags()));
 
         oneIter = graph.getEdgeProps(iter.getEdge(), 2);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(3, oneIter.getBaseNode());
+        assertFalse(carEncoder.isForward(oneIter.getFlags()));
         assertTrue(carEncoder.isBackward(oneIter.getFlags()));
-        assertFalse(carEncoder.isBoth(oneIter.getFlags()));
 
         graph.edge(3, 2, 14, true);
         assertEquals(4, GHUtility.count(carOutExplorer.setBaseNode(2)));
@@ -817,10 +846,11 @@ public void testEdgeReturn()
     public void testPillarNodes()
     {
         graph = createGraph();
-        graph.setNode(0, 0.01, 0.01);
-        graph.setNode(4, 0.4, 0.4);
-        graph.setNode(14, 0.14, 0.14);
-        graph.setNode(10, 0.99, 0.99);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0.01, 0.01);
+        na.setNode(4, 0.4, 0.4);
+        na.setNode(14, 0.14, 0.14);
+        na.setNode(10, 0.99, 0.99);
 
         PointList pointList = Helper.createPointList(1, 1, 1, 2, 1, 3);
         graph.edge(0, 4).setDistance(100).setFlags(carEncoder.setProperties(10, true, false)).setWayGeometry(pointList);
@@ -906,24 +936,37 @@ public void testGetAllEdges()
     public void testGetAllEdgesWithDelete()
     {
         graph = createGraph();
-        graph.setNode(0, 0, 5);
-        graph.setNode(1, 1, 5);
-        graph.setNode(2, 2, 5);
-        graph.setNode(3, 3, 5);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0, 5);
+        na.setNode(1, 1, 5);
+        na.setNode(2, 2, 5);
+        na.setNode(3, 3, 5);
         graph.edge(0, 1, 1, true);
         graph.edge(0, 2, 1, true);
         graph.edge(1, 2, 1, true);
         graph.edge(2, 3, 1, true);
         AllEdgesIterator iter = graph.getAllEdges();
         assertEquals(4, GHUtility.count(iter));
-        assertEquals(4, iter.getMaxId());
+        assertEquals(4, iter.getCount());
 
         // delete
         graph.markNodeRemoved(1);
         graph.optimize();
         iter = graph.getAllEdges();
         assertEquals(2, GHUtility.count(iter));
-        assertEquals(4, iter.getMaxId());
+        assertEquals(4, iter.getCount());
+
+        iter = graph.getAllEdges();
+        iter.next();
+        EdgeIteratorState eState = iter.detach(false);
+        assertEquals(iter.toString(), eState.toString());
+        iter.next();
+        assertNotEquals(iter.toString(), eState.toString());
+
+        EdgeIteratorState eState2 = iter.detach(true);
+        assertEquals(iter.getAdjNode(), eState2.getBaseNode());
+        iter.next();
+        assertNotEquals(iter.getAdjNode(), eState2.getBaseNode());
     }
 
     public static void assertPList( PointList expected, PointList list )
@@ -939,9 +982,10 @@ public static void assertPList( PointList expected, PointList list )
     public static int getIdOf( Graph g, double latitude )
     {
         int s = g.getNodes();
+        NodeAccess na = g.getNodeAccess();
         for (int i = 0; i < s; i++)
         {
-            if (Math.abs(g.getLatitude(i) - latitude) < 1e-4)
+            if (Math.abs(na.getLatitude(i) - latitude) < 1e-4)
             {
                 return i;
             }
@@ -952,14 +996,15 @@ public static int getIdOf( Graph g, double latitude )
     public static int getIdOf( Graph g, double latitude, double longitude )
     {
         int s = g.getNodes();
+        NodeAccess na = g.getNodeAccess();
         for (int i = 0; i < s; i++)
         {
-            if (Math.abs(g.getLatitude(i) - latitude) < 1e-4 && Math.abs(g.getLongitude(i) - longitude) < 1e-4)
+            if (Math.abs(na.getLatitude(i) - latitude) < 1e-4 && Math.abs(na.getLongitude(i) - longitude) < 1e-4)
             {
                 return i;
             }
         }
-        return -1;
+        throw new IllegalArgumentException("did not find node with location " + (float) latitude + "," + (float) longitude);
     }
 
     @Test
@@ -975,4 +1020,116 @@ public void testNameIndex()
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
     }
+
+    @Test
+    public void test8BytesFlags()
+    {
+        Directory dir = new RAMDirectory();
+        List<FlagEncoder> list = new ArrayList<FlagEncoder>();
+        list.add(new TmpCarFlagEncoder(29, 0.001, 0));
+        list.add(new TmpCarFlagEncoder(29, 0.001, 0));
+        EncodingManager manager = new EncodingManager(list, 8);
+        graph = new GraphHopperStorage(dir, manager, false).create(defaultSize);
+
+        EdgeIteratorState edge = graph.edge(0, 1);
+        edge.setFlags(Long.MAX_VALUE / 3);
+        // System.out.println(BitUtil.LITTLE.toBitString(Long.MAX_VALUE / 3) + "\n" + BitUtil.LITTLE.toBitString(edge.getFlags()));
+        assertEquals(Long.MAX_VALUE / 3, edge.getFlags());
+        graph.close();
+
+        graph = new GraphHopperStorage(dir, manager, false).create(defaultSize);
+
+        edge = graph.edge(0, 1);
+        edge.setFlags(list.get(0).setProperties(99.123, true, true));
+        assertEquals(99.123, list.get(0).getSpeed(edge.getFlags()), 1e-3);
+        long flags = GHUtility.getEdge(graph, 1, 0).getFlags();
+        assertEquals(99.123, list.get(0).getSpeed(flags), 1e-3);
+        assertTrue(list.get(0).isForward(flags));
+        assertTrue(list.get(0).isBackward(flags));
+        edge = graph.edge(2, 3);
+        edge.setFlags(list.get(1).setProperties(44.123, true, false));
+        assertEquals(44.123, list.get(1).getSpeed(edge.getFlags()), 1e-3);
+
+        flags = GHUtility.getEdge(graph, 3, 2).getFlags();
+        assertEquals(44.123, list.get(1).getSpeed(flags), 1e-3);
+        assertEquals(44.123, list.get(1).getReverseSpeed(flags), 1e-3);
+        assertFalse(list.get(1).isForward(flags));
+        assertTrue(list.get(1).isBackward(flags));
+    }
+
+    @Test
+    public void testEnabledElevation()
+    {
+        graph = createGraph(defaultGraphLoc, true);
+        NodeAccess na = graph.getNodeAccess();
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 20, -10);
+        na.setNode(1, 11, 2, 100);
+        assertEquals(-10, na.getEle(0), 1e-1);
+        assertEquals(100, na.getEle(1), 1e-1);
+
+        graph.edge(0, 1).setWayGeometry(Helper.createPointList3D(10, 27, 72, 11, 20, 1));
+        assertEquals(Helper.createPointList3D(10, 27, 72, 11, 20, 1), GHUtility.getEdge(graph, 0, 1).fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(10, 20, -10, 10, 27, 72, 11, 20, 1, 11, 2, 100), GHUtility.getEdge(graph, 0, 1).fetchWayGeometry(3));
+        assertEquals(Helper.createPointList3D(11, 2, 100, 11, 20, 1, 10, 27, 72, 10, 20, -10), GHUtility.getEdge(graph, 1, 0).fetchWayGeometry(3));
+    }
+
+    @Test
+    public void testDetachEdge()
+    {
+        graph = createGraph();
+        graph.edge(0, 1, 2, true);
+        long flags = carEncoder.setProperties(10, true, false);
+        graph.edge(0, 2, 2, true).setWayGeometry(Helper.createPointList(1, 2, 3, 4)).setFlags(flags);
+        graph.edge(1, 2, 2, true);
+
+        EdgeIterator iter = graph.createEdgeExplorer().setBaseNode(0);
+        try
+        {
+            // currently not possible to detach without next, without introducing a new property inside EdgeIterable
+            iter.detach(false);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+
+        iter.next();
+        EdgeIteratorState edgeState2 = iter.detach(false);
+        assertEquals(2, iter.getAdjNode());
+        assertEquals(1, edgeState2.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertEquals(2, edgeState2.getAdjNode());
+        assertTrue(carEncoder.isForward(edgeState2.getFlags()));
+
+        EdgeIteratorState edgeState3 = iter.detach(true);
+        assertEquals(0, edgeState3.getAdjNode());
+        assertEquals(2, edgeState3.getBaseNode());
+        assertEquals(3, edgeState3.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertFalse(carEncoder.isForward(edgeState3.getFlags()));
+        assertEquals(GHUtility.getEdge(graph, 0, 2).getFlags(), edgeState2.getFlags());
+        assertEquals(GHUtility.getEdge(graph, 2, 0).getFlags(), edgeState3.getFlags());
+
+        iter.next();
+        assertEquals(1, iter.getAdjNode());
+        assertEquals(2, edgeState2.getAdjNode());
+        assertEquals(2, edgeState3.getBaseNode());
+
+        assertEquals(0, iter.fetchWayGeometry(0).size());
+        assertEquals(1, edgeState2.fetchWayGeometry(0).getLatitude(0), 1e-1);
+        assertEquals(3, edgeState3.fetchWayGeometry(0).getLatitude(0), 1e-1);
+
+        // #162 a directed self referencing edge should be able to reverse its state too
+        graph.edge(3, 3, 2, true).setFlags(flags);
+        EdgeIterator iter2 = graph.createEdgeExplorer().setBaseNode(3);
+        iter2.next();
+        assertEquals(edgeState2.getFlags(), iter2.detach(false).getFlags());
+        assertEquals(edgeState3.getFlags(), iter2.detach(true).getFlags());
+    }
+
+    static class TmpCarFlagEncoder extends CarFlagEncoder
+    {
+        public TmpCarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
+        {
+            super(speedBits, speedFactor, maxTurnCosts);
+        }
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
new file mode 100644
index 0000000000..6e73952da5
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/AbstractLockFactoryTester.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.util.Constants;
+import com.graphhopper.util.Helper;
+import java.io.File;
+import org.junit.After;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * @author Peter Karich
+ */
+public abstract class AbstractLockFactoryTester
+{
+    protected final File lockDir = new File("./target/lockingtest/");
+
+    protected abstract LockFactory createLockFactory();
+
+    @Before
+    public void setUp()
+    {
+        lockDir.mkdirs();
+    }
+
+    @After
+    public void tearDown()
+    {
+        Helper.removeDir(lockDir);
+    }
+
+    @Test
+    public void testObtain()
+    {
+        LockFactory instance = createLockFactory();
+        instance.setLockDir(lockDir);
+        Lock lock = instance.create("test", true);
+        assertTrue(lock.tryLock());
+        assertTrue(lock.isLocked());
+        assertFalse(lock.tryLock());
+        assertTrue(lock.isLocked());
+
+        Lock lock2 = instance.create("test", true);
+        assertFalse(lock2.tryLock());
+        assertTrue(lock2.isLocked());
+
+        // fails for SimpleFSLockFactory:
+        // although it is locked do not allow release:
+        // lock2.release();
+        // assertTrue(lock.isLocked());
+
+        lock.release();
+        assertFalse(lock.isLocked());
+    }
+
+    @Test
+    public void testForceDelete()
+    {
+        LockFactory instance = createLockFactory();
+        instance.setLockDir(lockDir);
+        Lock lock = instance.create("testlock", true);
+        assertTrue(lock.tryLock());
+        assertTrue(lock.isLocked());
+
+        // on windows we cannot forcefully remove an unreleased lock
+        if (Constants.WINDOWS)
+            lock.release();
+        
+        instance.forceRemove(lock.getName(), true);
+        assertFalse(lock.isLocked());
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
index ec7a0f4189..f5ae8eb1d9 100644
--- a/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/DataAccessTest.java
@@ -75,7 +75,14 @@ public void testLoadFlush()
         da.close();
 
         // cannot load data if already closed
-        assertFalse(da.loadExisting());
+        try
+        {
+            da.loadExisting();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertEquals("already closed", ex.getMessage());
+        }
 
         da = createDataAccess(name);
         assertTrue(da.loadExisting());
@@ -88,7 +95,7 @@ public void testExceptionIfNoEnsureCapacityWasCalled()
     {
         DataAccess da = createDataAccess(name);
         assertFalse(da.loadExisting());
-        // throw some undefined exception if no incCapacity was called
+        // throw some undefined exception if no ensureCapacity was called
         try
         {
             da.setInt(2 * 4, 321);
@@ -142,7 +149,7 @@ public void testEnsureCapacity()
         da.setInt(31 * 4, 200);
 
         assertEquals(200, da.getInt(31 * 4));
-        da.incCapacity(2 * 128);
+        da.ensureCapacity(2 * 128);
         assertEquals(200, da.getInt(31 * 4));
         // now it shouldn't fail
         da.setInt(32 * 4, 220);
@@ -152,7 +159,7 @@ public void testEnsureCapacity()
         // ensure some bigger area
         da = createDataAccess(name);
         da.create(200 * 4);
-        da.incCapacity(600 * 4);
+        da.ensureCapacity(600 * 4);
         da.close();
     }
 
@@ -161,6 +168,7 @@ public void testCopy()
     {
         DataAccess da1 = createDataAccess(name);
         da1.create(1001 * 4);
+        da1.setHeader(4, 12);
         da1.setInt(1 * 4, 1);
         da1.setInt(123 * 4, 321);
         da1.setInt(1000 * 4, 1111);
@@ -168,6 +176,7 @@ public void testCopy()
         DataAccess da2 = createDataAccess(name + "2");
         da2.create(10);
         da1.copyTo(da2);
+        assertEquals(12, da2.getHeader(4));
         assertEquals(1, da2.getInt(1 * 4));
         assertEquals(321, da2.getInt(123 * 4));
         assertEquals(1111, da2.getInt(1000 * 4));
@@ -189,7 +198,7 @@ public void testSegments()
         da.setSegmentSize(128);
         da.create(10);
         assertEquals(1, da.getSegments());
-        da.incCapacity(500);
+        da.ensureCapacity(500);
         int olds = da.getSegments();
         assertTrue(olds > 3);
 
@@ -346,4 +355,26 @@ public void testSet_GetBytes()
         assertEquals(256, bufferIndex);
         assertEquals(11111, index);
     }
+
+    @Test
+    public void testSet_Get_Short_Long()
+    {
+        DataAccess da = createDataAccess(name);
+        da.create(300);
+        da.setShort(6, (short) (Short.MAX_VALUE / 5));
+        assertEquals(Short.MAX_VALUE / 5, da.getShort(6));
+
+        da.setShort(8, (short) (Short.MAX_VALUE / 7));
+        assertEquals(Short.MAX_VALUE / 7, da.getShort(8));
+
+        // currently RAMIntDA does not support arbitrary byte positions
+        if (!(da instanceof RAMIntDataAccess))
+        {
+            da.setShort(7, (short) (Short.MAX_VALUE / 3));
+            assertEquals(Short.MAX_VALUE / 3, da.getShort(7));
+            // should be overwritten
+            assertNotEquals(Short.MAX_VALUE / 3, da.getShort(8));
+        }
+        da.close();
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index b4db18b0c0..ff4bdbacc0 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -30,23 +30,18 @@
 public class GraphHopperStorageTest extends AbstractGraphStorageTester
 {
     @Override
-    public GraphStorage createGraph( String location, int size )
+    public GraphStorage createGraph( String location, boolean enabled3D )
     {
         // reduce segment size in order to test the case where multiple segments come into the game
-        GraphStorage gs = newGraph(new RAMDirectory(location));
-        gs.setSegmentSize(size / 2);
-        gs.create(size);
+        GraphStorage gs = newGraph(new RAMDirectory(location), enabled3D);
+        gs.setSegmentSize(defaultSize / 2);
+        gs.create(defaultSize);
         return gs;
     }
 
-    protected GraphStorage newGraph( Directory dir )
+    protected GraphStorage newGraph( Directory dir, boolean enabled3D )
     {
-        return new GraphHopperStorage(dir, encodingManager);
-    }
-
-    protected GraphStorage createGraphStorage( Directory dir )
-    {
-        return newGraph(dir).create(defaultSize);
+        return new GraphHopperStorage(dir, encodingManager, enabled3D);
     }
 
     @Test
@@ -72,15 +67,17 @@ public void testNoCreateCalled() throws IOException
     @Test
     public void testSave_and_fileFormat() throws IOException
     {
-        GraphStorage graph = createGraphStorage(new RAMDirectory(defaultGraph, true));
-        graph.setNode(0, 10, 10);
-        graph.setNode(1, 11, 20);
-        graph.setNode(2, 12, 12);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
+        NodeAccess na = graph.getNodeAccess();
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
@@ -92,7 +89,7 @@ public void testSave_and_fileFormat() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraph));
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -100,79 +97,82 @@ public void testSave_and_fileFormat() throws IOException
 
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
-        graph.close();
     }
 
     protected void checkGraph( Graph g )
     {
-        assertEquals(new BBox(10, 20, 10, 12), g.getBounds());
-        assertEquals(10, g.getLatitude(0), 1e-2);
-        assertEquals(10, g.getLongitude(0), 1e-2);
+        NodeAccess na = g.getNodeAccess();
+        assertTrue(na.is3D());
+        assertTrue(g.getBounds().isValid());
+        
+        assertEquals(new BBox(10, 20, 10, 12, 0, 1), g.getBounds());
+        assertEquals(10, na.getLatitude(0), 1e-2);
+        assertEquals(10, na.getLongitude(0), 1e-2);
         EdgeExplorer explorer = g.createEdgeExplorer(carOutFilter);
         assertEquals(2, GHUtility.count(explorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(2, 1), GHUtility.getNeighbors(explorer.setBaseNode(0)));
 
         EdgeIterator iter = explorer.setBaseNode(0);
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(3.5, 4.5, 5, 6), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0), iter.fetchWayGeometry(0));
 
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3), iter.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(10, 10, 1.5, 1, 2, 3), iter.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3, 11, 20), iter.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(10, 10, 0, 1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0, 11, 20, 1), iter.fetchWayGeometry(2));
 
-        assertEquals(11, g.getLatitude(1), 1e-2);
-        assertEquals(20, g.getLongitude(1), 1e-2);
+        assertEquals(11, na.getLatitude(1), 1e-2);
+        assertEquals(20, na.getLongitude(1), 1e-2);
         assertEquals(2, GHUtility.count(explorer.setBaseNode(1)));
         assertEquals(GHUtility.asSet(2, 0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
 
-        assertEquals(12, g.getLatitude(2), 1e-2);
-        assertEquals(12, g.getLongitude(2), 1e-2);
+        assertEquals(12, na.getLatitude(2), 1e-2);
+        assertEquals(12, na.getLongitude(2), 1e-2);
         assertEquals(1, GHUtility.count(explorer.setBaseNode(2)));
 
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
 
         EdgeIteratorState eib = GHUtility.getEdge(g, 1, 2);
-        assertEquals(Helper.createPointList(), eib.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(11, 20), eib.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(12, 12), eib.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(), eib.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(11, 20, 1), eib.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(12, 12, 0.4), eib.fetchWayGeometry(2));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
     }
 
     @Test
     public void internalDisconnect()
     {
-        GraphHopperStorage tmpGS = (GraphHopperStorage) createGraph();
-        EdgeIteratorState iter0 = tmpGS.edge(0, 1, 10, true);
-        EdgeIteratorState iter2 = tmpGS.edge(1, 2, 10, true);
-        EdgeIteratorState iter3 = tmpGS.edge(0, 3, 10, true);
+        GraphHopperStorage graph = (GraphHopperStorage) createGraph();
+        EdgeIteratorState iter0 = graph.edge(0, 1, 10, true);
+        EdgeIteratorState iter2 = graph.edge(1, 2, 10, true);
+        EdgeIteratorState iter3 = graph.edge(0, 3, 10, true);
 
-        EdgeExplorer explorer = tmpGS.createEdgeExplorer();
+        EdgeExplorer explorer = graph.createEdgeExplorer();
 
         assertEquals(GHUtility.asSet(3, 1), GHUtility.getNeighbors(explorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(2, 0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
         // remove edge "1-2" but only from 1 not from 2
-        tmpGS.internalEdgeDisconnect(iter2.getEdge(), -1, iter2.getBaseNode(), iter2.getAdjNode());
+        graph.internalEdgeDisconnect(iter2.getEdge(), -1, iter2.getBaseNode(), iter2.getAdjNode());
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
         assertEquals(GHUtility.asSet(1), GHUtility.getNeighbors(explorer.setBaseNode(2)));
         // let 0 unchanged -> no side effects
         assertEquals(GHUtility.asSet(3, 1), GHUtility.getNeighbors(explorer.setBaseNode(0)));
 
         // remove edge "0-1" but only from 0
-        tmpGS.internalEdgeDisconnect(iter0.getEdge(), (long) iter3.getEdge() * tmpGS.edgeEntryBytes, iter0.getBaseNode(), iter0.getAdjNode());
+        graph.internalEdgeDisconnect(iter0.getEdge(), (long) iter3.getEdge() * graph.edgeEntryBytes, iter0.getBaseNode(), iter0.getAdjNode());
         assertEquals(GHUtility.asSet(3), GHUtility.getNeighbors(explorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(3)));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
-        tmpGS.close();
+        graph.close();
     }
 
     @Test
     public void testEnsureSize()
     {
         Directory dir = new RAMDirectory();
-        graph = new GraphHopperStorage(dir, encodingManager).create(defaultSize);
+        graph = newGraph(dir, false).create(defaultSize);
         int testIndex = dir.find("edges").getSegmentSize() * 3;
         graph.edge(0, testIndex, 10, true);
 
@@ -184,39 +184,29 @@ public void testEnsureSize()
     public void testBigDataEdge()
     {
         Directory dir = new RAMDirectory();
-        GraphHopperStorage tmpGS = new GraphHopperStorage(dir, encodingManager);
-        tmpGS.create(defaultSize);
-        tmpGS.setEdgeCount(Integer.MAX_VALUE / 2);
-        assertTrue(tmpGS.getAllEdges().next());
-        tmpGS.close();
+        GraphHopperStorage graph = new GraphHopperStorage(dir, encodingManager, false);
+        graph.create(defaultSize);
+        graph.setEdgeCount(Integer.MAX_VALUE / 2);
+        assertTrue(graph.getAllEdges().next());
+        graph.close();
     }
 
     @Test
-    public void testDetachEdge()
+    public void testDoThrowExceptionIfDimDoesNotMatch()
     {
-        Directory dir = new RAMDirectory();
-        graph = new GraphHopperStorage(dir, encodingManager).create(defaultSize);
-        graph.edge(0, 1, 2, true);
-        graph.edge(0, 2, 2, true);
-        graph.edge(1, 2, 2, true);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
+        graph.create(1000);
+        graph.flush();
+        graph.close();
 
-        EdgeIterator iter = graph.createEdgeExplorer().setBaseNode(0);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true);
         try
         {
-            // currently not possible to implement without a new property inside EdgeIterable
-            iter.detach();
+            graph.loadExisting();
             assertTrue(false);
         } catch (Exception ex)
         {
-        }
-
-        iter.next();
-        EdgeIteratorState iter2 = iter.detach();
-        assertEquals(2, iter.getAdjNode());
-        assertEquals(2, iter2.getAdjNode());
 
-        iter.next();
-        assertEquals(1, iter.getAdjNode());
-        assertEquals(2, iter2.getAdjNode());
+        }
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index ea19f30055..e624d5ce83 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -17,15 +17,15 @@
  */
 package com.graphhopper.storage;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
 import java.io.IOException;
-
-import org.junit.Test;
+import java.util.Random;
 
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  *
@@ -33,40 +33,43 @@
  */
 public class GraphHopperStorageWithTurnCostsTest extends GraphHopperStorageTest
 {
-    private TurnCostStorage turnCostStorage;
+    private TurnCostExtension turnCostStorage;
 
     @Override
-    protected GraphStorage newGraph( Directory dir )
+    protected GraphStorage newGraph( Directory dir, boolean is3D )
     {
-        turnCostStorage = new TurnCostStorage();
-        return new GraphHopperStorage(dir, encodingManager, turnCostStorage);
+        turnCostStorage = new TurnCostExtension();
+        return new GraphHopperStorage(dir, encodingManager, is3D, turnCostStorage);
     }
 
     @Override
     protected GraphStorage newRAMGraph()
     {
-        return newGraph(new RAMDirectory());
+        return newGraph(new RAMDirectory(), false);
     }
 
+    @Override
     @Test
-    public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
+    public void testSave_and_fileFormat() throws IOException
     {
-        graph = createGraphStorage(new RAMDirectory(defaultGraph, true));
-        graph.setNode(0, 10, 10);
-        graph.setNode(1, 11, 20);
-        graph.setNode(2, 12, 12);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
+        NodeAccess na = graph.getNodeAccess();
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
 
-        turnCostStorage.setTurnCosts(0, iter1.getEdge(), iter2.getEdge(), 1337);
-        turnCostStorage.setTurnCosts(0, iter2.getEdge(), iter1.getEdge(), 666);
-        turnCostStorage.setTurnCosts(1, iter1.getEdge(), iter2.getEdge(), 815);
+        turnCostStorage.addTurnInfo(iter1.getEdge(), 0, iter2.getEdge(), 1337);
+        turnCostStorage.addTurnInfo(iter2.getEdge(), 0, iter1.getEdge(), 666);
+        turnCostStorage.addTurnInfo(iter1.getEdge(), 1, iter2.getEdge(), 815);
 
         iter1.setName("named street1");
         iter2.setName("named street2");
@@ -75,7 +78,7 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraph));
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -84,12 +87,58 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
 
-        assertEquals(1337, turnCostStorage.getTurnCosts(0, iter1.getEdge(), iter2.getEdge()));
-        assertEquals(666, turnCostStorage.getTurnCosts(0, iter2.getEdge(), iter1.getEdge()));
-        assertEquals(815, turnCostStorage.getTurnCosts(1, iter1.getEdge(), iter2.getEdge()));
-        assertEquals(0, turnCostStorage.getTurnCosts(3, iter1.getEdge(), iter2.getEdge()));
+        assertEquals(1337, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 0, iter2.getEdge()));
+        assertEquals(666, turnCostStorage.getTurnCostFlags(iter2.getEdge(), 0, iter1.getEdge()));
+        assertEquals(815, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 1, iter2.getEdge()));
+        assertEquals(0, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 3, iter2.getEdge()));
 
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
+
+    @Test
+    public void testEnsureCapacity() throws IOException
+    {
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph.setSegmentSize(128);
+        graph.create(100); // 100 is the minimum size
+
+        // assert that turnCostStorage can hold 104 turn cost entries at the beginning
+        assertEquals(104, turnCostStorage.getCapacity() / 16);
+
+        Random r = new Random();
+
+        NodeAccess na = graph.getNodeAccess();
+        for (int i = 0; i < 100; i++)
+        {
+            double randomLat = 90 * r.nextDouble();
+            double randomLon = 180 * r.nextDouble();
+
+            na.setNode(i, randomLat, randomLon);
+        }
+
+        // Make node 50 the 'center' node
+        for (int nodeId = 51; nodeId < 100; nodeId++)
+        {
+            graph.edge(50, nodeId, r.nextDouble(), true);
+        }
+        for (int nodeId = 0; nodeId < 50; nodeId++)
+        {
+            graph.edge(nodeId, 50, r.nextDouble(), true);
+        }
+
+        // add 100 turn cost entries around node 50
+        for (int edgeId = 0; edgeId < 50; edgeId++)
+        {
+            turnCostStorage.addTurnInfo(edgeId, 50, edgeId + 50, 1337);
+            turnCostStorage.addTurnInfo(edgeId + 50, 50, edgeId, 1337);
+        }
+
+        turnCostStorage.addTurnInfo(0, 50, 1, 1337);
+        assertEquals(104, turnCostStorage.getCapacity() / 16); // we are still good here
+
+        turnCostStorage.addTurnInfo(0, 50, 2, 1337);
+        // A new segment should be added, which will support 128 / 16 = 8 more entries.
+        assertEquals(112, turnCostStorage.getCapacity() / 16);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphStorage3DTest.java b/core/src/test/java/com/graphhopper/storage/GraphStorage3DTest.java
deleted file mode 100644
index 7ab2358815..0000000000
--- a/core/src/test/java/com/graphhopper/storage/GraphStorage3DTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-import com.graphhopper.routing.DijkstraBidirection;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.util.DistanceCalc3D;
-import com.graphhopper.util.Helper;
-import static org.junit.Assert.*;
-import org.junit.Test;
-
-/**
- *
- * @author Peter Karich
- */
-public class GraphStorage3DTest
-{
-    final EncodingManager encodingManager = new EncodingManager("CAR");
-
-    @Test
-    public void testGetHeight()
-    {
-        GraphStorage3D g = new GraphStorage3D(new RAMDirectory(), encodingManager).create(100);
-        g.setNode(0, 50, 20000.00, 100);
-        g.setNode(1, 50, 20000.02, 100);
-
-        g.setNode(2, 50, 20000.01, 200);
-        g.setNode(3, 50, 20000.01, 50);
-        g.setNode(4, 50, 20000.01, 5);
-
-        DistanceCalc3D dist = new DistanceCalc3D();
-        edge(g, dist, 0, 2);
-        edge(g, dist, 0, 3);
-        edge(g, dist, 0, 4);
-        edge(g, dist, 1, 2);
-        edge(g, dist, 1, 3);
-        edge(g, dist, 1, 4);
-
-        Path p = new DijkstraBidirection(g, encodingManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(0, 1);
-        assertEquals(Helper.createTList(0, 3, 1), p.calcNodes());
-        assertEquals(100, p.getDistance(), .1);
-    }
-
-    public static void edge( GraphStorage3D g, DistanceCalc3D dist, int from, int to )
-    {
-        double tmpDist = dist.calcDist(g.getLatitude(from), g.getLongitude(from), g.getHeight(from),
-                g.getLatitude(to), g.getLongitude(to), g.getHeight(to));
-        // System.out.println(from + "->" + to + " " + tmpDist);
-        g.edge(from, to, tmpDist, true);
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java b/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
index 036c8573ec..3a69d6c9af 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphStorageViaMMapTest.java
@@ -23,11 +23,11 @@
 public class GraphStorageViaMMapTest extends AbstractGraphStorageTester
 {
     @Override
-    public GraphStorage createGraph( String location, int size )
+    public GraphStorage createGraph( String location, boolean is3D )
     {
-        GraphStorage gs = new GraphBuilder(encodingManager).setLocation(location).setMmap(true).build();
-        gs.setSegmentSize(size / 2);
-        gs.create(size);
+        GraphStorage gs = new GraphBuilder(encodingManager).set3D(is3D).setLocation(location).setMmap(true).build();
+        gs.setSegmentSize(defaultSize / 2);
+        gs.create(defaultSize);
         return gs;
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
index 17d1fccb46..b7c216b4fb 100644
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
@@ -17,11 +17,15 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.LevelEdgeFilter;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeSkipExplorer;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.GHUtility;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
 import static org.junit.Assert.*;
 import org.junit.Test;
 
@@ -37,25 +41,19 @@ protected LevelGraphStorage createGraph()
     }
 
     @Override
-    protected LevelGraphStorage createGraphStorage( Directory dir )
+    public GraphStorage newGraph( Directory dir, boolean is3D )
     {
-        return (LevelGraphStorage) super.createGraphStorage(dir);
-    }
-
-    @Override
-    public GraphStorage newGraph( Directory dir )
-    {
-        return new LevelGraphStorage(dir, encodingManager);
+        return new LevelGraphStorage(dir, encodingManager, is3D);
     }
 
     @Test
-    public void testCannotBeLoadedViaDifferentClass()
+    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
     {
-        GraphStorage g = createGraphStorage(new RAMDirectory(defaultGraph, true));
+        GraphStorage g = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
         g.flush();
         g.close();
 
-        g = new GraphBuilder(encodingManager).setLocation(defaultGraph).setMmap(false).setStore(true).create();
+        g = new GraphBuilder(encodingManager).setLocation(defaultGraphLoc).setMmap(false).setStore(true).create();
         try
         {
             g.loadExisting();
@@ -64,14 +62,17 @@ public void testCannotBeLoadedViaDifferentClass()
         {
         }
 
-        g = newGraph(new RAMDirectory(defaultGraph, true));
+        g = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
         assertTrue(g.loadExisting());
+        // empty graph still has invalid bounds
+        assertEquals(g.getBounds(), BBox.createInverse(false));
     }
 
     @Test
     public void testPriosWhileDeleting()
     {
         LevelGraphStorage g = createGraph();
+        g.getNodeAccess().ensureNode(19);
         for (int i = 0; i < 20; i++)
         {
             g.setLevel(i, i);
@@ -80,13 +81,14 @@ public void testPriosWhileDeleting()
         g.optimize();
         assertEquals(9, g.getLevel(9));
         assertNotSame(10, g.getLevel(10));
-        assertEquals(19, g.getNodes());
     }
 
     @Test
     public void testPrios()
     {
         LevelGraph g = createGraph();
+        g.getNodeAccess().ensureNode(30);
+
         assertEquals(0, g.getLevel(10));
 
         g.setLevel(10, 100);
@@ -108,8 +110,7 @@ public void testEdgeFilter()
         assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge1());
         assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge2());
 
-        // shortcut
-        g.edge(0, 4, 40, true);
+        g.shortcut(0, 4).setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
         g.setLevel(0, 1);
         g.setLevel(4, 1);
 
@@ -156,4 +157,102 @@ public void testDisconnectEdge()
         g.disconnect(g.createEdgeExplorer(), iter);
         assertEquals(0, GHUtility.count(carOutExplorer.setBaseNode(2)));
     }
+
+    @Test
+    public void testGetWeight()
+    {
+        LevelGraphStorage g = (LevelGraphStorage) createGraph();
+        assertFalse(g.edge(0, 1).isShortcut());
+        assertFalse(g.edge(1, 2).isShortcut());
+
+        // only remove edges
+        long flags = carEncoder.setProperties(10, true, true);
+        EdgeSkipIterState sc1 = g.shortcut(0, 1);
+        assertTrue(sc1.isShortcut());
+        sc1.setWeight(2.001);
+        assertEquals(2.001, sc1.getWeight(), 1e-3);
+        sc1.setWeight(100.123);
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        sc1.setWeight(Double.MAX_VALUE);
+        assertTrue(Double.isInfinite(sc1.getWeight()));
+
+        sc1.setFlags(flags);
+        sc1.setWeight(100.123);
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        assertTrue(carEncoder.isForward(sc1.getFlags()));
+        assertTrue(carEncoder.isBackward(sc1.getFlags()));
+
+        flags = carEncoder.setProperties(10, false, true);
+        sc1.setFlags(flags);
+        sc1.setWeight(100.123);
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
+        assertFalse(carEncoder.isForward(sc1.getFlags()));
+        assertTrue(carEncoder.isBackward(sc1.getFlags()));
+    }
+
+    @Test
+    public void testGetWeightIfAdvancedEncoder()
+    {
+        FlagEncoder customEncoder = new Bike2WeightFlagEncoder();
+        LevelGraphStorage g = new GraphBuilder(new EncodingManager(customEncoder)).levelGraphCreate();
+
+        EdgeSkipIterState sc1 = g.shortcut(0, 1);
+        long flags = customEncoder.setProperties(10, false, true);
+        sc1.setFlags(flags);
+        sc1.setWeight(100.123);
+
+        assertEquals(100.123, g.getEdgeProps(sc1.getEdge(), sc1.getAdjNode()).getWeight(), 1e-3);
+        assertEquals(100.123, g.getEdgeProps(sc1.getEdge(), sc1.getBaseNode()).getWeight(), 1e-3);
+        assertEquals(100.123, ((EdgeSkipIterState) GHUtility.getEdge(g, sc1.getBaseNode(), sc1.getAdjNode())).getWeight(), 1e-3);
+        assertEquals(100.123, ((EdgeSkipIterState) GHUtility.getEdge(g, sc1.getAdjNode(), sc1.getBaseNode())).getWeight(), 1e-3);
+
+        sc1 = g.shortcut(1, 0);
+        assertTrue(sc1.isShortcut());
+        sc1.setFlags(PrepareEncoder.getScDirMask());
+        sc1.setWeight(1.011011);
+        assertEquals(1.011011, sc1.getWeight(), 1e-3);
+    }
+
+    @Test
+    public void testQueryGraph()
+    {
+        LevelGraph levelGraph = createGraph();
+        NodeAccess na = levelGraph.getNodeAccess();
+        na.setNode(0, 1.00, 1.00);
+        na.setNode(1, 1.02, 1.00);
+        na.setNode(2, 1.04, 1.00);
+
+        EdgeIteratorState edge1 = levelGraph.edge(0, 1);
+        EdgeIteratorState edge2 = levelGraph.edge(1, 2);
+        levelGraph.shortcut(0, 1);
+        
+        QueryGraph qGraph = new QueryGraph(levelGraph);
+        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
+        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
+        qGraph.lookup(fromRes, toRes);
+
+        Graph oGraph = qGraph.getBaseGraph();
+        EdgeExplorer explorer = oGraph.createEdgeExplorer();
+
+        assertTrue(levelGraph.getNodes() < qGraph.getNodes());
+        assertTrue(oGraph.getNodes() == qGraph.getNodes());
+
+        // traverse virtual edges and normal edges but no shortcuts!
+        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
+        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
+
+        // get neighbors from virtual nodes
+        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
+        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
+    }
+
+    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
+    {
+        QueryResult res = new QueryResult(lat, lon);
+        res.setClosestEdge(edge);
+        res.setWayIndex(wayIndex);
+        res.setSnappedPosition(QueryResult.Position.EDGE);
+        res.calcSnappedPoint(Helper.DIST_PLANE);
+        return res;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
index f7f7f1c74f..941d81b485 100644
--- a/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
+++ b/core/src/test/java/com/graphhopper/storage/MMapDataAccessTest.java
@@ -28,7 +28,7 @@
     @Override
     public DataAccess createDataAccess( String name )
     {
-        return new MMapDataAccess(name, directory, defaultOrder).setSegmentSize(128);
+        return new MMapDataAccess(name, directory, defaultOrder, true).setSegmentSize(128);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
new file mode 100644
index 0000000000..ddeaa9e012
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/NativeFSLockFactoryTest.java
@@ -0,0 +1,70 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import java.nio.channels.OverlappingFileLockException;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class NativeFSLockFactoryTest extends AbstractLockFactoryTester
+{
+    @Override
+    protected LockFactory createLockFactory()
+    {
+        return new NativeFSLockFactory(lockDir);
+    }
+
+    @Test
+    public void testMultiReadObtain()
+    {
+        LockFactory instance = createLockFactory();
+        instance.setLockDir(lockDir);
+        Lock writeLock1 = instance.create("test", true);
+        assertTrue(writeLock1.tryLock());
+
+        // BUT disallow more than one write lock!
+        Lock lock2 = instance.create("test", false);
+        assertFalse(lock2.tryLock());
+
+        writeLock1.release();
+
+        assertTrue(lock2.tryLock());
+
+        // http://stackoverflow.com/q/24367887/194609
+        // we cannot test 'allow multiple read locks' as multiple reads are only allowed for different processes        
+        // Lock lock3 = instance.create("test", false);
+        // assertFalse(lock3.tryLock());
+        // lock3.release();
+        // still the lock should be valid
+        assertTrue(lock2.isLocked());
+
+        // disallow write lock if currently reading
+        Lock writeLock4 = instance.create("test", true);
+        assertFalse(writeLock4.tryLock());
+        assertEquals(OverlappingFileLockException.class, writeLock4.getObtainFailedReason().getClass());
+        writeLock4.release();
+
+        assertTrue(lock2.isLocked());
+        lock2.release();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/Graph3D.java b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
similarity index 54%
rename from core/src/main/java/com/graphhopper/storage/Graph3D.java
rename to core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
index 9f077d3ac3..1f9badefe4 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph3D.java
+++ b/core/src/test/java/com/graphhopper/storage/SimpleFSLockFactoryTest.java
@@ -1,14 +1,15 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,11 +19,14 @@
 package com.graphhopper.storage;
 
 /**
+ *
  * @author Peter Karich
  */
-public interface Graph3D extends Graph
+public class SimpleFSLockFactoryTest extends AbstractLockFactoryTester
 {
-    void setNode( int index, double lat, double lon, double height );
-
-    double getHeight( int index );
+    @Override
+    protected LockFactory createLockFactory()
+    {
+        return new SimpleFSLockFactory(lockDir);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index e82b7776c0..e447b1c058 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -25,6 +25,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.MMapDirectory;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
@@ -73,7 +74,7 @@ public void testSimpleGraph()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 8);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -103,13 +104,14 @@ public void initSimpleGraph( Graph g )
         // ---|-------------------
         //    |-2 -1 0 1 2 3 4
         //
-        g.setNode(0, -1, -2);
-        g.setNode(1, 2, -1);
-        g.setNode(2, 0, 1);
-        g.setNode(3, 1, 2);
-        g.setNode(4, 6, 1);
-        g.setNode(5, 4, 4);
-        g.setNode(6, 4.5, -0.5);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, -1, -2);
+        na.setNode(1, 2, -1);
+        na.setNode(2, 0, 1);
+        na.setNode(3, 1, 2);
+        na.setNode(4, 6, 1);
+        na.setNode(5, 4, 4);
+        na.setNode(6, 4.5, -0.5);
         g.edge(0, 1, 3.5, true);
         g.edge(0, 2, 2.5, true);
         g.edge(2, 3, 1, true);
@@ -126,7 +128,7 @@ public void testSimpleGraph2()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 28);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -151,14 +153,15 @@ public void testGrid()
         Graph g = createSampleGraph(new EncodingManager("CAR"));
         int locs = g.getNodes();
 
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
         // if we would use less array entries then some points gets the same key so avoid that for this test
         // e.g. for 16 we get "expected 6 but was 9" i.e 6 was overwritten by node j9 which is a bit closer to the grid center        
         // go through every point of the graph if all points are reachable
+        NodeAccess na = g.getNodeAccess();
         for (int i = 0; i < locs; i++)
         {
-            double lat = g.getLatitude(i);
-            double lon = g.getLongitude(i);
+            double lat = na.getLatitude(i);
+            double lon = na.getLongitude(i);
             assertEquals("nodeId:" + i + " " + (float) lat + "," + (float) lon, i, idx.findID(lat, lon));
         }
 
@@ -176,12 +179,12 @@ public void testGrid()
             double lat = rand.nextDouble() * 5;
             double lon = rand.nextDouble() * 5;
             int fullId = fullIndex.findID(lat, lon);
-            double fullLat = g.getLatitude(fullId);
-            double fullLon = g.getLongitude(fullId);
+            double fullLat = na.getLatitude(fullId);
+            double fullLon = na.getLongitude(fullId);
             float fullDist = (float) dist.calcDist(lat, lon, fullLat, fullLon);
             int newId = idx.findID(lat, lon);
-            double newLat = g.getLatitude(newId);
-            double newLon = g.getLongitude(newId);
+            double newLat = na.getLatitude(newId);
+            double newLon = na.getLongitude(newId);
             float newDist = (float) dist.calcDist(lat, lon, newLat, newLon);
 
             if (testGridIgnore(i))
@@ -208,7 +211,7 @@ boolean testGridIgnore( int i )
     public void testSinglePoints120()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
 
         assertEquals(1, idx.findID(1.637, 2.23));
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -224,7 +227,7 @@ public void testSinglePoints120()
     public void testSinglePoints32()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
 
         // 10 or 6
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -245,11 +248,12 @@ public void testNoErrorOnEdgeCase_lastIndex()
     {
         final EncodingManager encodingManager = new EncodingManager("CAR");
         int locs = 10000;
-        Graph g = createGraph(new MMapDirectory(location), encodingManager);
+        Graph g = createGraph(new MMapDirectory(location), encodingManager, false);
+        NodeAccess na = g.getNodeAccess();
         Random rand = new Random(12);
         for (int i = 0; i < locs; i++)
         {
-            g.setNode(i, (float) rand.nextDouble() * 10 + 10, (float) rand.nextDouble() * 10 + 10);
+            na.setNode(i, (float) rand.nextDouble() * 10 + 10, (float) rand.nextDouble() * 10 + 10);
         }
         idx = createIndex(g, 200);
         Helper.close((Closeable) g);
@@ -257,12 +261,12 @@ public void testNoErrorOnEdgeCase_lastIndex()
 
     Graph createGraph( EncodingManager encodingManager )
     {
-        return createGraph(new RAMDirectory(), encodingManager);
+        return createGraph(new RAMDirectory(), encodingManager, false);
     }
 
-    Graph createGraph( Directory dir, EncodingManager encodingManager )
+    Graph createGraph( Directory dir, EncodingManager encodingManager, boolean is3D )
     {
-        return new GraphHopperStorage(dir, encodingManager).create(100);
+        return new GraphHopperStorage(dir, encodingManager, is3D).create(100);
     }
 
     public Graph createSampleGraph( EncodingManager encodingManager )
@@ -286,39 +290,40 @@ public Graph createSampleGraph( EncodingManager encodingManager )
 //        
 //   lon: 0   1   2   3   4   5
         int a0 = 0;
-        graph.setNode(0, 0, 1.0001f);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0, 1.0001f);
         int b1 = 1;
-        graph.setNode(1, 1, 2);
+        na.setNode(1, 1, 2);
         int c2 = 2;
-        graph.setNode(2, 0.5f, 4.5f);
+        na.setNode(2, 0.5f, 4.5f);
         int d3 = 3;
-        graph.setNode(3, 1.5f, 3.8f);
+        na.setNode(3, 1.5f, 3.8f);
         int e4 = 4;
-        graph.setNode(4, 2.01f, 0.5f);
+        na.setNode(4, 2.01f, 0.5f);
         int f5 = 5;
-        graph.setNode(5, 2, 3);
+        na.setNode(5, 2, 3);
         int g6 = 6;
-        graph.setNode(6, 3, 1.5f);
+        na.setNode(6, 3, 1.5f);
         int h7 = 7;
-        graph.setNode(7, 2.99f, 3.01f);
+        na.setNode(7, 2.99f, 3.01f);
         int i8 = 8;
-        graph.setNode(8, 3, 4);
+        na.setNode(8, 3, 4);
         int j9 = 9;
-        graph.setNode(9, 3.3f, 2.2f);
+        na.setNode(9, 3.3f, 2.2f);
         int k10 = 10;
-        graph.setNode(10, 4, 1);
+        na.setNode(10, 4, 1);
         int l11 = 11;
-        graph.setNode(11, 4.1f, 3);
+        na.setNode(11, 4.1f, 3);
         int m12 = 12;
-        graph.setNode(12, 4, 4.5f);
+        na.setNode(12, 4, 4.5f);
         int n13 = 13;
-        graph.setNode(13, 4.5f, 4.1f);
+        na.setNode(13, 4.5f, 4.1f);
         int o14 = 14;
-        graph.setNode(14, 5, 0);
+        na.setNode(14, 5, 0);
         int p15 = 15;
-        graph.setNode(15, 4.9f, 2.5f);
+        na.setNode(15, 4.9f, 2.5f);
         int q16 = 16;
-        graph.setNode(16, 5, 5);
+        na.setNode(16, 5, 5);
         // => 17 locations
 
         graph.edge(a0, b1, 1, true);
@@ -350,7 +355,7 @@ public void testDifferentVehicles()
         final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
         Graph g = createGraph(encodingManager);
         initSimpleGraph(g);
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         assertEquals(1, idx.findID(1, -1));
 
         // now make all edges from node 1 accessible for CAR only
@@ -362,7 +367,7 @@ public void testDifferentVehicles()
         }
         idx.close();
 
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
         assertEquals(2, idx.findClosest(1, -1, new DefaultEdgeFilter(footEncoder)).getClosestNode());
         Helper.close((Closeable) g);
diff --git a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
index 669bde9b61..50d76f5d68 100644
--- a/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/BresenhamLineTest.java
@@ -33,7 +33,7 @@
  */
 public class BresenhamLineTest
 {
-    final PointList points = new PointList();
+    final PointList points = new PointList(10, false);
     PointEmitter emitter = new PointEmitter()
     {
         @Override
@@ -52,39 +52,63 @@ public void setUp()
     @Test
     public void testBresenhamLineLeftDown()
     {
-        BresenhamLine.calcPoints(2, 1, -3, -1, emitter);
-        assertEquals(Helper.createPointList(2, 1, 1, 1, 0, 0, -1, 0, -2, 0, -3, -1), points);
+        BresenhamLine.calcPoints(5, 2, 0, 0, emitter);
+        // 5,2, 4,2, 3,2, 3,1, 2,1, 1,1, 0,0
+        assertEquals(Helper.createPointList(5, 2, 4, 2, 3, 1, 2, 1, 1, 0, 0, 0), points);
+    }
+
+    @Test
+    public void testLineRightDown2()
+    {
+        // example http://stackoverflow.com/a/12370474/194609
+        BresenhamLine.voxelTraversal(0.25, 0.25, 2.75, 5.25, emitter);
+        assertEquals(Helper.createPointList(0, 0, 0, 1, 1, 1, 1, 2, 1, 3, 2, 3, 2, 4, 2, 5), points);
+    }
+
+    @Test
+    public void testBresenhamLineRightDown()
+    {
+        BresenhamLine.calcPoints(3, 1, 0, 3, emitter);
+        // 3,1, 2,1, 1,1, 1,2, 0,2, 0,3
+        assertEquals(Helper.createPointList(3, 1, 2, 2, 1, 2, 0, 3), points);
     }
 
     @Test
     public void testBresenhamLineLeftUp()
     {
-        BresenhamLine.calcPoints(2, 1, 3, -1, emitter);
-        assertEquals(Helper.createPointList(2, 1, 2, 0, 3, -1), points);
+        BresenhamLine.calcPoints(2, 2, 3, 0, emitter);
+        // 2,2, 2,1, 2,0, 3,0
+
+        assertEquals(Helper.createPointList(2, 2, 2, 1, 3, 0), points);
+    }
+
+    @Test
+    public void testBresenhamLineRightUp()
+    {
+        BresenhamLine.calcPoints(0, 0, 2, 3, emitter);
+        // 0,0, 0,1, 1,1, 1,2, 2,2, 2,3
+        assertEquals(Helper.createPointList(0, 0, 1, 1, 1, 2, 2, 3), points);
     }
 
     @Test
     public void testBresenhamBug()
     {
         BresenhamLine.calcPoints(0.5, -0.5, -0.6, 1.6, emitter, -1, -1, 0.75, 1.3);
-//        assertEquals(Helper.createPointList(0.875, -0.35, 0.125, 0.95, -0.625, 2.25), points);
-        assertEquals(Helper.createPointList(0.5, -1, 0.5, 0.3, -0.25, 1.6), points);
+        assertEquals(Helper.createPointList(0.575, -0.87, -0.175, 0.43, -0.925, 1.73), points);
     }
 
     @Test
     public void testBresenhamHorizontal()
     {
         BresenhamLine.calcPoints(.5, -.5, .5, 1, emitter, -1, -1, 0.6, 0.4);
-        // assertEquals(Helper.createPointList(.5, -.4, .5, 0, .5, .4, .5, .8, .5, 1.2), points);
-        assertEquals(Helper.createPointList(.8, -.6, .8, -0.2, .8, .2, .8, .6, .8, 1.0), points);
+        assertEquals(Helper.createPointList(.26, -.56, .26, -0.16, .26, .24, .26, .64, .26, 1.04), points);
     }
 
     @Test
     public void testBresenhamVertical()
     {
         BresenhamLine.calcPoints(-.5, .5, 1, 0.5, emitter, 0, 0, 0.4, 0.6);
-//        assertEquals(Helper.createPointList(-.2, .3, 0.2, .3, 0.6, 0.3, 1.0, 0.3), points);
-        assertEquals(Helper.createPointList(-.4, .6, 0, .6, 0.4, 0.6, .8, .6, 1.2, 0.6), points);
+        assertEquals(Helper.createPointList(-0.36, .06, 0.04, 0.06, 0.44, 0.06, 0.84, 0.06), points);
     }
 
     @Test
@@ -106,11 +130,23 @@ public void set( double lat, double lon )
                 keys.add(keyAlgo.encode(lat, lon));
             }
         };
+        keys.clear();
+        BresenhamLine.calcPoints(.3, -.3, -0.2, 0.2, tmpEmitter, minLat, minLon,
+                deltaLat, deltaLon);
+        assertEquals(Arrays.asList(11L, 9L), keys);
+
+        keys.clear();
+        BresenhamLine.calcPoints(.3, -.1, -0.2, 0.4, tmpEmitter, minLat, minLon,
+                deltaLat, deltaLon);
+
+        // 11, 9, 12
+        assertEquals(Arrays.asList(11L, 12L), keys);
+
+        keys.clear();
         BresenhamLine.calcPoints(.5, -.5, -0.1, 0.9, tmpEmitter, minLat, minLon,
                 deltaLat, deltaLon);
-        // TODO Either 10, 11, 12 or 11, 12, 7 is correct but 10,9,7 is a minor incorrect encoding
-        assertEquals(Arrays.asList(10L, 9L, 7L), keys);
-//        assertEquals(Arrays.asList(11L, 12L, 7L), keys);
+        // precise: 10, 11, 14, 12
+        assertEquals(Arrays.asList(10L, 11L, 12L), keys);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index 801367d298..bb43cef11b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -33,13 +33,16 @@
     @Override
     public LocationIndex createIndex( Graph g, int resolution )
     {
-        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).setResolution(resolution).prepareIndex();
+        if(resolution < 0)
+            resolution = 120;
+        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).
+                setResolution(resolution).prepareIndex();
     }
 
     @Test
     public void testNormedDist()
     {
-        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager()), new RAMDirectory());
+        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
         assertEquals(2, index.getNormedDist(0, 7), 1e-6);
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
similarity index 74%
rename from core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
rename to core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
index 954c48bd97..0f3c93d92b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
@@ -23,9 +23,9 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.LevelGraphStorage;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.EdgeSkipExplorer;
 import com.graphhopper.util.EdgeSkipIterState;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.TIntList;
@@ -40,40 +40,46 @@
 /**
  * @author Peter Karich
  */
-public class LocationIndexTreeSCTest extends LocationIndexTreeTest
+public class LocationIndexTreeForLevelGraphTest extends LocationIndexTreeTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
+    @Override
+    public LocationIndexTree createIndex( Graph g, int resolution )
+    {
+        if (resolution < 0)
+            resolution = 500000;
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
+    }
 
     @Override
-    public LocationIndexTreeSC createIndex( Graph g, int resolution )
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
-        LocationIndexTreeSC idx = new LocationIndexTreeSC((LevelGraph) g, dir);
-        idx.setResolution(1000000).prepareIndex();
-        return idx;
+        LocationIndexTree tmpIdx = new LocationIndexTree(g.getBaseGraph(), dir);
+        tmpIdx.setResolution(resolution);
+        return tmpIdx;
     }
 
     @Override
-    LevelGraph createGraph( Directory dir, EncodingManager encodingManager )
+    LevelGraph createGraph( Directory dir, EncodingManager encodingManager, boolean is3D )
     {
-        return new LevelGraphStorage(dir, encodingManager).create(100);
+        return new LevelGraphStorage(dir, encodingManager, is3D).create(100);
     }
 
     @Test
     public void testLevelGraph()
     {
-        LevelGraph g = createGraph(new RAMDirectory(), encodingManager);
+        LevelGraph g = createGraph(new RAMDirectory(), encodingManager, false);
         // 0
         // 1
         // 2
         //  3
         //   4
-
-        g.setNode(0, 1, 0);
-        g.setNode(1, 0.5, 0);
-        g.setNode(2, 0, 0);
-        g.setNode(3, -1, 1);
-        g.setNode(4, -2, 2);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 1, 0);
+        na.setNode(1, 0.5, 0);
+        na.setNode(2, 0, 0);
+        na.setNode(3, -1, 1);
+        na.setNode(4, -2, 2);
 
         EdgeIteratorState iter1 = g.edge(0, 1, 10, true);
         EdgeIteratorState iter2 = g.edge(1, 2, 10, true);
@@ -100,7 +106,8 @@ public void testLevelGraph()
     @Test
     public void testSortHighLevelFirst()
     {
-        final LevelGraph lg = createGraph(new RAMDirectory(), encodingManager);
+        final LevelGraph lg = createGraph(new RAMDirectory(), encodingManager, false);
+        lg.getNodeAccess().ensureNode(4);
         lg.setLevel(1, 10);
         lg.setLevel(2, 30);
         lg.setLevel(3, 20);
@@ -130,13 +137,14 @@ public void testLevelGraphBug()
         // |
         // 1
 
-        LevelGraphStorage lg = (LevelGraphStorage) createGraph(new RAMDirectory(), encodingManager);
-        lg.setNode(0, 1, 0);
-        lg.setNode(1, 0, 0);
-        lg.setNode(2, 0.5, 0.5);
-        lg.setNode(3, 0.5, 1);
+        LevelGraphStorage lg = (LevelGraphStorage) createGraph(new RAMDirectory(), encodingManager, false);
+        NodeAccess na = lg.getNodeAccess();
+        na.setNode(0, 1, 0);
+        na.setNode(1, 0, 0);
+        na.setNode(2, 0.5, 0.5);
+        na.setNode(3, 0.5, 1);
         EdgeIteratorState iter1 = lg.edge(1, 0, 100, true);
-        EdgeIteratorState iter2 = lg.edge(2, 3, 100, true);
+        lg.edge(2, 3, 100, true);
 
         lg.setLevel(0, 11);
         lg.setLevel(1, 10);
@@ -148,15 +156,17 @@ public void testLevelGraphBug()
         // disconnect higher 3 from lower 2
         lg.disconnect(lg.createEdgeExplorer(), iter1);
 
-        LocationIndexTreeSC index = new LocationIndexTreeSC(lg, new RAMDirectory());
-        index.setResolution(100000);
-        index.prepareIndex();
+        LocationIndexTree index = createIndex(lg, 100000);
+
         // very close to 2, but should match the edge 0--1
-        TIntHashSet set = index.findNetworkEntries(0.51, 0.2);
+        TIntHashSet set = index.findNetworkEntries(0.51, 0.2, index.maxRegionSearch);
+        assertEquals(0, index.findID(0.51, 0.2));
+        assertEquals(1, index.findID(0.1, 0.1));
+        assertEquals(2, index.findID(0.51, 0.51));
+        assertEquals(3, index.findID(0.51, 1.1));
         TIntSet expectedSet = new TIntHashSet();
-        expectedSet.add(1);
+        expectedSet.add(0);
         expectedSet.add(2);
         assertEquals(expectedSet, set);
-        assertEquals(0, index.findID(0.51, 0.2));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index ec89f029dc..f4a24cfc41 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -21,12 +21,12 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.set.hash.TIntHashSet;
+import java.util.Arrays;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -42,15 +42,17 @@
     @Override
     public LocationIndexTree createIndex( Graph g, int resolution )
     {
-        return internalCreateIndex(g, 500000);
+        if (resolution < 0)
+            resolution = 500000;        
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
     }
 
-    public LocationIndexTree internalCreateIndex( Graph g, int minMeter )
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
-        LocationIndexTree idx = new LocationIndexTree(g, dir);
-        idx.setResolution(minMeter).prepareIndex();
-        return idx;
+        LocationIndexTree tmpIDX = new LocationIndexTree(g, dir);
+        tmpIDX.setResolution(resolution);
+        return tmpIDX;
     }
 
     @Override
@@ -66,12 +68,13 @@ public boolean hasEdgeSupport()
     // 2---/---/
     Graph createTestGraph()
     {
-        Graph graph = createGraph(new RAMDirectory(), encodingManager);
-        graph.setNode(0, 0.5, -0.5);
-        graph.setNode(1, -0.5, -0.5);
-        graph.setNode(2, -1, -1);
-        graph.setNode(3, -0.4, 0.9);
-        graph.setNode(4, -0.6, 1.6);
+        Graph graph = createGraph(new RAMDirectory(), encodingManager, false);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0.5, -0.5);
+        na.setNode(1, -0.5, -0.5);
+        na.setNode(2, -1, -1);
+        na.setNode(3, -0.4, 0.9);
+        na.setNode(4, -0.6, 1.6);
         graph.edge(0, 1, 1, true);
         graph.edge(0, 2, 1, true);
         graph.edge(0, 4, 1, true);
@@ -86,7 +89,7 @@ Graph createTestGraph()
     public void testSnappedPointAndGeometry()
     {
         Graph graph = createTestGraph();
-        LocationIndex index = createIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         // query directly the tower node
         QueryResult res = index.findClosest(-0.4, 0.9, EdgeFilter.ALL_EDGES);
         assertEquals(new GHPoint(-0.4, 0.9), res.getSnappedPoint());
@@ -102,13 +105,13 @@ public void testSnappedPointAndGeometry()
     public void testInMemIndex()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 50000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
 
-        assertEquals(3, inMemIndex.getEntriesOf(0).size());
-        assertEquals(8, inMemIndex.getEntriesOf(1).size());
+        assertEquals(4, inMemIndex.getEntriesOf(0).size());
+        assertEquals(10, inMemIndex.getEntriesOf(1).size());
         assertEquals(0, inMemIndex.getEntriesOf(2).size());
         // [LEAF 0 {} {0, 2}, LEAF 2 {} {0, 1}, LEAF 1 {} {2}, LEAF 3 {} {1}, LEAF 8 {} {0}, LEAF 10 {} {0}, LEAF 9 {} {0}, LEAF 4 {} {2}, LEAF 6 {} {0, 1, 2, 3}, LEAF 5 {} {0, 2, 3}, LEAF 7 {} {1, 2, 3}, LEAF 13 {} {1}]        
         // System.out.println(inMemIndex.getLayer(2));
@@ -118,11 +121,12 @@ public void testInMemIndex()
         // [LEAF 0 {2} {},    LEAF 2 {1} {},    LEAF 1 {2} {}, LEAF 3 {1} {}, LEAF 8 {0} {}, LEAF 10 {0} {}, LEAF 9 {0} {}, LEAF 4 {2} {}, LEAF 6 {0, 3} {},       LEAF 5 {0, 2, 3} {}, LEAF 7 {1, 2, 3} {}, LEAF 13 {1} {}]
         // System.out.println(inMemIndex.getLayer(2));
 
-        index.setSearchRegion(false);
         TIntHashSet set = new TIntHashSet();
         set.add(0);
-        assertEquals(set, index.findNetworkEntries(0.5, -0.5));
-        assertEquals(set, index.findNetworkEntries(-0.5, -0.9));
+        assertEquals(set, index.findNetworkEntries(0.5, -0.5, 2));
+        set.add(1);
+        set.add(2);
+        assertEquals(set, index.findNetworkEntries(-0.5, -0.9, 2));
         assertEquals(2, index.findID(-0.5, -0.9));
 
         // The optimization if(dist > normedHalf) => feed nodeA or nodeB
@@ -142,30 +146,29 @@ public void testInMemIndex()
     public void testInMemIndex2()
     {
         Graph graph = createTestGraph2();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(500).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 500);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
-        assertEquals(1, inMemIndex.getEntriesOf(0).size());
-        assertEquals(4, inMemIndex.getEntriesOf(1).size());
+        assertEquals(3, inMemIndex.getEntriesOf(0).size());
+        assertEquals(5, inMemIndex.getEntriesOf(1).size());
         assertEquals(0, inMemIndex.getEntriesOf(2).size());
 
         index.dataAccess.create(10);
         inMemIndex.store(inMemIndex.root, LocationIndexTree.START_POINTER);
-        index.setSearchRegion(false);
 
         // 0
         assertEquals(2L, index.keyAlgo.encode(49.94653, 11.57114));
         // 1
         assertEquals(3L, index.keyAlgo.encode(49.94653, 11.57214));
         // 28
-        assertEquals(3L, index.keyAlgo.encode(49.95053, 11.57714));
+        assertEquals(6L, index.keyAlgo.encode(49.95053, 11.57714));
         // 29
         assertEquals(6L, index.keyAlgo.encode(49.95053, 11.57814));
         // 8
         assertEquals(1L, index.keyAlgo.encode(49.94553, 11.57214));
         // 34
-        assertEquals(9L, index.keyAlgo.encode(49.95153, 11.57714));
+        assertEquals(12L, index.keyAlgo.encode(49.95153, 11.57714));
 
         // Query near point 25 (49.95053, 11.57314).
         // If we would have a perfect compaction (takes a lot longer) we would
@@ -173,24 +176,20 @@ public void testInMemIndex2()
         // The other subnetwork is already perfect {26}.
         // For compaction see: https://github.com/graphhopper/graphhopper/blob/5594f7f9d98d932f365557dc37b4b2d3b7abf698/core/src/main/java/com/graphhopper/storage/index/Location2NodesNtree.java#L277
         TIntHashSet set = new TIntHashSet();
-        set.add(16);
-        set.add(26);
-        set.add(27);
-        set.add(28);
-        assertEquals(set, index.findNetworkEntries(49.950, 11.5732));
+        set.addAll(Arrays.asList(28, 27, 26, 24, 23, 21, 19, 18, 16, 14, 6, 5, 4, 3, 2, 1, 0));
+        assertEquals(set, index.findNetworkEntries(49.950, 11.5732, 1));
     }
 
     @Test
     public void testInMemIndex3()
     {
-        Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(10000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(createTestGraph(), 10000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(64, 4), index.getEntries());
 
         assertEquals(33, inMemIndex.getEntriesOf(0).size());
-        assertEquals(59, inMemIndex.getEntriesOf(1).size());
+        assertEquals(69, inMemIndex.getEntriesOf(1).size());
         assertEquals(0, inMemIndex.getEntriesOf(2).size());
 
         index.dataAccess.create(1024);
@@ -204,8 +203,7 @@ public void testInMemIndex3()
     @Test
     public void testReverseSpatialKey()
     {
-        LocationIndexTree index = new LocationIndexTree(createTestGraph(), new RAMDirectory());
-        index.setMinResolutionInMeter(200).prepareAlgo();
+        LocationIndexTree index = createIndex(createTestGraph(), 200);
         assertEquals(Helper.createTList(64, 64, 64, 4), index.getEntries());
 
         // 10111110111110101010
@@ -217,15 +215,16 @@ public void testReverseSpatialKey()
     public void testMoreReal()
     {
         Graph graph = createGraph(new EncodingManager("CAR"));
-        graph.setNode(1, 51.2492152, 9.4317166);
-        graph.setNode(0, 52, 9);
-        graph.setNode(2, 51.2, 9.4);
-        graph.setNode(3, 49, 10);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(1, 51.2492152, 9.4317166);
+        na.setNode(0, 52, 9);
+        na.setNode(2, 51.2, 9.4);
+        na.setNode(3, 49, 10);
 
         graph.edge(1, 0, 1000, true);
         graph.edge(0, 2, 1000, true);
         graph.edge(0, 3, 1000, true).setWayGeometry(Helper.createPointList(51.21, 9.43));
-        LocationIndex index = internalCreateIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         assertEquals(2, index.findID(51.2, 9.4));
     }
 
@@ -241,11 +240,12 @@ public void testMoreReal()
     private Graph createTestGraphWithWayGeometry()
     {
         Graph graph = createGraph(encodingManager);
-        graph.setNode(0, 0.5, -0.5);
-        graph.setNode(1, -0.5, -0.5);
-        graph.setNode(2, -1, -1);
-        graph.setNode(3, -0.4, 0.9);
-        graph.setNode(4, -0.6, 1.6);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 0.5, -0.5);
+        na.setNode(1, -0.5, -0.5);
+        na.setNode(2, -1, -1);
+        na.setNode(3, -0.4, 0.9);
+        na.setNode(4, -0.6, 1.6);
         graph.edge(0, 1, 1, true);
         graph.edge(0, 2, 1, true);
         // insert A and B, without this we would get 0 for 0,0
@@ -261,7 +261,7 @@ private Graph createTestGraphWithWayGeometry()
     public void testWayGeometry()
     {
         Graph g = createTestGraphWithWayGeometry();
-        LocationIndex index = createIndex(g, 1000);
+        LocationIndex index = createIndex(g, -1);
         assertEquals(1, index.findID(0, 0));
         assertEquals(1, index.findID(0, 0.1));
         assertEquals(1, index.findID(0.1, 0.1));
@@ -272,10 +272,11 @@ public void testWayGeometry()
     public void testFindingWayGeometry()
     {
         Graph g = createGraph(encodingManager);
-        g.setNode(10, 51.2492152, 9.4317166);
-        g.setNode(20, 52, 9);
-        g.setNode(30, 51.2, 9.4);
-        g.setNode(50, 49, 10);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(10, 51.2492152, 9.4317166);
+        na.setNode(20, 52, 9);
+        na.setNode(30, 51.2, 9.4);
+        na.setNode(50, 49, 10);
         g.edge(20, 50, 1, true).setWayGeometry(Helper.createPointList(51.25, 9.43));
         g.edge(10, 20, 1, true);
         g.edge(20, 30, 1, true);
@@ -288,7 +289,7 @@ public void testFindingWayGeometry()
     public void testEdgeFilter()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = createIndex(graph, 1000);
+        LocationIndexTree index = createIndex(graph, -1);
 
         assertEquals(1, index.findClosest(-.6, -.6, EdgeFilter.ALL_EDGES).getClosestNode());
         assertEquals(2, index.findClosest(-.6, -.6, new EdgeFilter()
@@ -304,57 +305,57 @@ public boolean accept( EdgeIteratorState iter )
     // see testgraph2.jpg
     Graph createTestGraph2()
     {
-        Graph graph = createGraph(new RAMDirectory(), encodingManager);
-
-        graph.setNode(8, 49.94553, 11.57214);
-        graph.setNode(9, 49.94553, 11.57314);
-        graph.setNode(10, 49.94553, 11.57414);
-        graph.setNode(11, 49.94553, 11.57514);
-        graph.setNode(12, 49.94553, 11.57614);
-        graph.setNode(13, 49.94553, 11.57714);
-
-        graph.setNode(0, 49.94653, 11.57114);
-        graph.setNode(1, 49.94653, 11.57214);
-        graph.setNode(2, 49.94653, 11.57314);
-        graph.setNode(3, 49.94653, 11.57414);
-        graph.setNode(4, 49.94653, 11.57514);
-        graph.setNode(5, 49.94653, 11.57614);
-        graph.setNode(6, 49.94653, 11.57714);
-        graph.setNode(7, 49.94653, 11.57814);
-
-        graph.setNode(14, 49.94753, 11.57214);
-        graph.setNode(15, 49.94753, 11.57314);
-        graph.setNode(16, 49.94753, 11.57614);
-        graph.setNode(17, 49.94753, 11.57814);
-
-        graph.setNode(18, 49.94853, 11.57114);
-        graph.setNode(19, 49.94853, 11.57214);
-        graph.setNode(20, 49.94853, 11.57814);
-
-        graph.setNode(21, 49.94953, 11.57214);
-        graph.setNode(22, 49.94953, 11.57614);
-
-        graph.setNode(23, 49.95053, 11.57114);
-        graph.setNode(24, 49.95053, 11.57214);
-        graph.setNode(25, 49.95053, 11.57314);
-        graph.setNode(26, 49.95053, 11.57514);
-        graph.setNode(27, 49.95053, 11.57614);
-        graph.setNode(28, 49.95053, 11.57714);
-        graph.setNode(29, 49.95053, 11.57814);
-
-        graph.setNode(30, 49.95153, 11.57214);
-        graph.setNode(31, 49.95153, 11.57314);
-        graph.setNode(32, 49.95153, 11.57514);
-        graph.setNode(33, 49.95153, 11.57614);
-        graph.setNode(34, 49.95153, 11.57714);
-
-        graph.setNode(34, 49.95153, 11.57714);
+        Graph graph = createGraph(new RAMDirectory(), encodingManager, false);
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(8, 49.94553, 11.57214);
+        na.setNode(9, 49.94553, 11.57314);
+        na.setNode(10, 49.94553, 11.57414);
+        na.setNode(11, 49.94553, 11.57514);
+        na.setNode(12, 49.94553, 11.57614);
+        na.setNode(13, 49.94553, 11.57714);
+
+        na.setNode(0, 49.94653, 11.57114);
+        na.setNode(1, 49.94653, 11.57214);
+        na.setNode(2, 49.94653, 11.57314);
+        na.setNode(3, 49.94653, 11.57414);
+        na.setNode(4, 49.94653, 11.57514);
+        na.setNode(5, 49.94653, 11.57614);
+        na.setNode(6, 49.94653, 11.57714);
+        na.setNode(7, 49.94653, 11.57814);
+
+        na.setNode(14, 49.94753, 11.57214);
+        na.setNode(15, 49.94753, 11.57314);
+        na.setNode(16, 49.94753, 11.57614);
+        na.setNode(17, 49.94753, 11.57814);
+
+        na.setNode(18, 49.94853, 11.57114);
+        na.setNode(19, 49.94853, 11.57214);
+        na.setNode(20, 49.94853, 11.57814);
+
+        na.setNode(21, 49.94953, 11.57214);
+        na.setNode(22, 49.94953, 11.57614);
+
+        na.setNode(23, 49.95053, 11.57114);
+        na.setNode(24, 49.95053, 11.57214);
+        na.setNode(25, 49.95053, 11.57314);
+        na.setNode(26, 49.95053, 11.57514);
+        na.setNode(27, 49.95053, 11.57614);
+        na.setNode(28, 49.95053, 11.57714);
+        na.setNode(29, 49.95053, 11.57814);
+
+        na.setNode(30, 49.95153, 11.57214);
+        na.setNode(31, 49.95153, 11.57314);
+        na.setNode(32, 49.95153, 11.57514);
+        na.setNode(33, 49.95153, 11.57614);
+        na.setNode(34, 49.95153, 11.57714);
+
+        na.setNode(34, 49.95153, 11.57714);
 
         // to create correct bounds
         // bottom left
-        graph.setNode(100, 49.94053, 11.56614);
-        // bottom right
-        graph.setNode(101, 49.96053, 11.58814);
+        na.setNode(100, 49.941, 11.56614);
+        // top right
+        na.setNode(101, 49.96053, 11.58814);
 
         graph.edge(0, 1, 10, true);
         graph.edge(1, 2, 10, true);
@@ -396,4 +397,36 @@ Graph createTestGraph2()
         graph.edge(28, 34, 10, true);
         return graph;
     }
+
+    @Test
+    public void testRMin()
+    {
+        Graph graph = createTestGraph();
+        LocationIndexTree index = createIndex(graph, 50000);
+
+        //query: 0.05 | -0.3
+        DistanceCalc distCalc = new DistancePlaneProjection();
+
+        double rmin = index.calculateRMin(0.05, -0.3);
+        double check = distCalc.calcDist(0.05, Math.abs(graph.getNodeAccess().getLon(2)) - index.getDeltaLon(), -0.3, -0.3);
+
+        assertTrue((rmin - check) < 0.0001);
+
+        double rmin2 = index.calculateRMin(0.05, -0.3, 1);
+        double check2 = distCalc.calcDist(0.05, Math.abs(graph.getNodeAccess().getLat(0)), -0.3, -0.3);
+
+        assertTrue((rmin2 - check2) < 0.0001);
+
+        TIntHashSet points = new TIntHashSet();
+        assertEquals(Double.MAX_VALUE, index.calcMinDistance(0.05, -0.3, points), 1e-1);
+
+        points.add(0);
+        points.add(1);
+        assertEquals(54757.03, index.calcMinDistance(0.05, -0.3, points), 1e-1);
+
+        /*GraphVisualizer gv = new GraphVisualizer(graph, index.getDeltaLat(), index.getDeltaLon(), index.getCenter(0, 0).lat, index.getCenter(0, 0).lon);
+         try {
+         Thread.sleep(4000);
+         } catch(InterruptedException ie) {}*/
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/trees/QTDataNodeTest.java b/core/src/test/java/com/graphhopper/trees/QTDataNodeTest.java
deleted file mode 100644
index 54ea583e5a..0000000000
--- a/core/src/test/java/com/graphhopper/trees/QTDataNodeTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.trees;
-
-import org.junit.*;
-import static org.junit.Assert.*;
-
-/**
- *
- * @author Peter Karich
- */
-public class QTDataNodeTest
-{
-    @Test
-    public void testGetMemoryUsageInBytes()
-    {
-        QTDataNode<Integer> dn = new QTDataNode<Integer>(8);
-        dn.keys[1] = 111;
-        // dn.values[1] = (Integer) 222;
-        assertEquals(0, dn.count());
-        dn.add(1, 1);
-        assertEquals(1, dn.count());
-    }
-
-    @Test
-    public void testAddDuplicates()
-    {
-        QTDataNode<String> dn = new QTDataNode<String>(4);
-        dn.add(1, "test1");
-        assertEquals(1, dn.count());
-        dn.add(1, "test5");
-        dn.add(1, "test2");
-        assertEquals(3, dn.count());
-    }
-
-    @Test
-    public void testNodeAdd()
-    {
-        QTDataNode<String> dn = new QTDataNode<String>(2);
-        assertFalse(dn.add(1, "test1"));
-        assertFalse(dn.add(5, "test5"));
-        assertTrue(dn.add(2, "test2"));
-    }
-
-    @Test
-    public void testNodeRemove()
-    {
-        QTDataNode<String> dn = new QTDataNode<String>(4);
-        dn.add(1, "test1");
-        dn.add(5, "test5");
-        dn.add(2, "test2");
-        dn.add(3, "test3");
-
-        assertEquals(1, dn.remove(3));
-        assertEquals(1, dn.remove(5));
-
-        assertNull(dn.getValue(5));
-        assertNull(dn.getValue(3));
-        assertEquals("test1", dn.getValue(1));
-        assertEquals("test2", dn.getValue(2));
-    }
-
-    @Test
-    public void testNodeRemoveWithDuplicates()
-    {
-        QTDataNode<String> dn = new QTDataNode<String>(4);
-        dn.add(1, "test1");
-        dn.add(1, "test5");
-
-        assertEquals(2, dn.remove(1));
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/trees/QuadTreeSimple8Test.java b/core/src/test/java/com/graphhopper/trees/QuadTreeSimple8Test.java
deleted file mode 100644
index 4111ba07f9..0000000000
--- a/core/src/test/java/com/graphhopper/trees/QuadTreeSimple8Test.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.trees;
-
-/**
- *
- * @author Peter Karich
- */
-public class QuadTreeSimple8Test extends QuadTreeTester
-{
-    @Override
-    protected QuadTree<Long> createQuadTree( long items )
-    {
-        QuadTreeSimple<Long> qt = new QuadTreeSimple<Long>(8);
-        qt.init(items);
-        return qt;
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/trees/QuadTreeTester.java b/core/src/test/java/com/graphhopper/trees/QuadTreeTester.java
deleted file mode 100644
index dffe79dc04..0000000000
--- a/core/src/test/java/com/graphhopper/trees/QuadTreeTester.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.trees;
-
-import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.CoordTrig;
-import java.util.Collection;
-import java.util.Iterator;
-import org.junit.*;
-import static org.junit.Assert.*;
-
-/**
- *
- * @author Peter Karich
- */
-public abstract class QuadTreeTester
-{
-    protected abstract QuadTree<Long> createQuadTree( long items );
-
-    @Test
-    public void testSize()
-    {
-        QuadTree instance = createQuadTree(100);
-        assertEquals(0, instance.getSize());
-    }
-
-    @Test
-    public void testPutAndGet()
-    {
-        QuadTree<Long> instance = createQuadTree(100);
-        assertEquals(0, instance.getNodesFromValue(12, 10, null).size());
-        instance.add(12, 10, 111L);
-        assertEquals(1, instance.getSize());
-        assertEquals(111, (long) instance.getNodesFromValue(12, 10, null).iterator().next().getValue());
-
-        instance.add(12, 10, 222L);
-        assertEquals(2, instance.getSize());
-
-        instance.add(12, 12, 333L);
-        assertEquals(3, instance.getSize());
-
-        assertEquals(2, instance.getNodesFromValue(12, 10, null).size());
-        instance.add(12.0001, 12.0001, 444L);
-        assertEquals(4, instance.getSize());
-        assertEquals(444, (long) instance.getNodesFromValue(12.0001, 12.0001, null).iterator().next().getValue());
-        assertEquals(0, instance.getNodesFromValue(12.0001, 12.0001, 445L).size());
-
-        instance.add(10, 10, 1010L);
-        assertEquals(5, instance.getSize());
-        assertEquals(1010, (long) instance.getNodesFromValue(10, 10, null).iterator().next().getValue());
-
-        instance.add(10, 12, 1012L);
-
-        assertEquals(6, instance.getSize());
-        assertEquals(444, (long) instance.getNodesFromValue(12.0001, 12.0001, null).iterator().next().getValue());
-        assertEquals(1010, (long) instance.getNodesFromValue(10, 10, null).iterator().next().getValue());
-        assertEquals(1012, (long) instance.getNodesFromValue(10, 12, null).iterator().next().getValue());
-
-        instance.clear();
-        assertEquals(0, instance.getSize());
-    }
-
-    @Test
-    public void testPutBatch()
-    {
-        int max = 100;
-        QuadTree<Long> instance = createQuadTree(max);
-        for (long i = 0; i < max; i++)
-        {
-            instance.add(i / 100.0, i / 100.0, i);
-            assertEquals(i + 1, instance.getSize());
-        }
-
-        assertEquals(max, instance.getSize());
-        for (int i = 0; i < max; i++)
-        {
-            Collection<CoordTrig<Long>> coll = instance.getNodesFromValue(i / 100.0, i / 100.0, null);
-            assertEquals(i + "/" + max, 1, coll.size());
-            Long val = (Long) coll.iterator().next().getValue();
-            assertNotNull(i + "/" + max, val);
-            assertEquals(i + "/" + max, i, (long) val);
-        }
-
-        for (int i = 0; i < max; i++)
-        {
-            assertEquals(max - i, instance.getSize());
-            Collection<CoordTrig<Long>> res = instance.getNodes(i / 100.0, i / 100.0, 1d);
-            CoordTrig<Long> coord = res.iterator().next();
-            assertEquals("couldn't remove " + i / 100.0 + " -> " + coord, 1, instance.remove(coord.lat, coord.lon));
-        }
-    }
-
-    @Test
-    public void testRemove()
-    {
-        QuadTree<Long> instance = createQuadTree(100);
-
-        assertEquals(0, instance.remove(7.002f, 7.001f));
-        instance.add(12, 10, 111L);
-        assertEquals(1, instance.getSize());
-
-        assertEquals(1, instance.remove(12, 10));
-        assertEquals(0, instance.getNodesFromValue(12, 10, null).size());
-        assertEquals(0, instance.getSize());
-
-        instance.add(12, 10, 111L);
-        instance.add(12, 10.1, 222L);
-        assertEquals(2, instance.getSize());
-        // System.out.println(instance.toDetailString());
-        assertEquals(1, instance.remove(12, 10));
-        // System.out.println(instance.toDetailString());
-        assertEquals(1, instance.getSize());
-        assertEquals(0, instance.getNodesFromValue(12, 10, null).size());
-        assertEquals(222, (long) instance.getNodesFromValue(12, 10.1, null).iterator().next().getValue());
-    }
-
-    @Test
-    public void testGetNeighboursExactHit()
-    {
-        QuadTree<Long> instance = createQuadTree(100);
-        Collection<CoordTrig<Long>> coll = instance.getNodes(8.124, 8.123, 10000);
-        assertTrue(coll.isEmpty());
-
-        instance.add(8.124, 8.123, 1L);
-        instance.add(8.123, 8.123, 2L);
-        instance.add(9.124, 8.123, 3l);
-        assertEquals(3, instance.getSize());
-
-        // search in 10km - exact hit
-        coll = instance.getNodes(8.124, 8.123, 10000);
-        assertEquals(2, coll.size());
-
-        coll = instance.getNodes(8.124, 8.123, 120000);
-        assertEquals(3, coll.size());
-    }
-
-    @Test
-    public void testGetNeighboursSearch()
-    {
-        QuadTree<Long> instance = createQuadTree(100);
-        Collection<CoordTrig<Long>> coll = instance.getNodes(8.124, 8.123, 10000);
-        assertTrue(coll.isEmpty());
-
-        instance.add(8.124, 8.123, 1L);
-        instance.add(8.123, 8.123, 2L);
-        instance.add(9.124, 8.123, 3L);
-        instance.add(8, 9, 4L);
-        instance.add(9, 9, 5L);
-        instance.add(7, 7, 6L);
-        instance.add(7, 8, 7L);
-        instance.add(7, 9, 8L);
-        instance.add(8, 7, 9L);
-        instance.add(9, 7, 10L);
-
-        // distances from 8.12, 8.12
-        //
-        // 9,7: 157.29199    9.124,8.123: 111.64019   9,9: 137.61365
-        //
-        // 8,7: 124.02789    distance:0               8,9: 97.79944
-        //
-        // 7,7: 175.3585     7,8: 125.23878           7,9: 157.85646
-        //
-//        CalcDistance c = new CalcDistance();
-//        System.out.println("9.124, 8.123:" + c.calcDistKm(9.124, 8.123, 8.12, 8.12));
-//        System.out.println("8,9:" + c.calcDistKm(8, 9, 8.12, 8.12));
-//        System.out.println("9,9:" + c.calcDistKm(9, 9, 8.12, 8.12));
-//        System.out.println("7,7:" + c.calcDistKm(7, 7, 8.12, 8.12));
-//        System.out.println("7,8:" + c.calcDistKm(7, 8, 8.12, 8.12));
-//        System.out.println("7,9:" + c.calcDistKm(7, 9, 8.12, 8.12));
-//        System.out.println("8,7:" + c.calcDistKm(8, 7, 8.12, 8.12));
-//        System.out.println("9,7:" + c.calcDistKm(9, 7, 8.12, 8.12));
-        assertEquals(10, instance.getSize());
-
-        assertEquals(2, instance.getNodes(8.12, 8.12, 10000).size());
-        assertEquals(2, instance.getNodes(8.12, 8.12, 50000).size());
-        assertEquals(1, instance.getNodes(8.12, 8.12, 500).size());
-        Iterator<CoordTrig<Long>> iter = instance.getNodes(8.12, 8.12, 500).iterator();
-        assertEquals(2, (long) iter.next().getValue());
-        assertEquals(3, instance.getNodes(8.12, 8.12, 100000).size());
-//        System.out.println(instance.getNodes(8.12, 8.12, 130));
-        assertEquals(6, instance.getNodes(8.12, 8.12, 130000).size());
-        assertEquals(9, instance.getNodes(8.12, 8.12, 175000).size());
-        assertEquals(10, instance.getNodes(8.12, 8.12, 176000).size());
-    }
-
-    public static void assertOrder( Collection<CoordTrig> coll, double... latitudes )
-    {
-        Iterator<CoordTrig> iter = coll.iterator();
-        for (int i = 0; i < latitudes.length; i++)
-        {
-            double f = latitudes[i];
-            CoordTrig f2d = iter.next();
-            assertEquals(f, f2d.lat, 1e-8);
-        }
-        assertFalse("There are more than " + latitudes.length + " items", iter.hasNext());
-    }
-
-    public static void assertCount( int c, Iterator iter )
-    {
-        for (int i = c; i >= 0; i--)
-        {
-            iter.next();
-        }
-        assertFalse("There are more than " + c + " items", iter.hasNext());
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
index 8f44409ddb..48a9fc00ac 100644
--- a/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
+++ b/core/src/test/java/com/graphhopper/util/AbstractBitUtilTester.java
@@ -59,6 +59,22 @@ public void testToInt()
         assertEquals(Integer.MAX_VALUE / 3, bitUtil.toInt(bytes));
     }
 
+    @Test
+    public void testToShort()
+    {
+        byte[] bytes = bitUtil.fromShort(Short.MAX_VALUE);
+        assertEquals(Short.MAX_VALUE, bitUtil.toShort(bytes));
+
+        bytes = bitUtil.fromShort((short) (Short.MAX_VALUE / 3));
+        assertEquals(Short.MAX_VALUE / 3, bitUtil.toShort(bytes));
+
+        bytes = bitUtil.fromShort((short) -123);
+        assertEquals(-123, bitUtil.toShort(bytes));
+
+        bytes = bitUtil.fromShort((short) (0xFF | 0xFF));
+        assertEquals(0xFF | 0xFF, bitUtil.toShort(bytes));
+    }
+
     @Test
     public void testToLong()
     {
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
new file mode 100644
index 0000000000..e47b52da9d
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -0,0 +1,90 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+/**
+ * @author Johannes Pelzer
+ * @author Peter Karich
+ */
+public class AngleCalcTest
+{
+    private final AngleCalc ac = new AngleCalc();
+
+    @Test
+    public void testOrientation()
+    {
+        assertEquals(90.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 0)), 0.001);
+        assertEquals(45.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 10)), 0.001);
+        assertEquals(0.0, Math.toDegrees(ac.calcOrientation(0, 0, 0, 10)), 0.001);
+        assertEquals(-45.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, 10)), 0.001);
+        assertEquals(-135.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, -10)), 0.001);
+    }
+
+    @Test
+    public void testAlignOrientation()
+    {
+        assertEquals(90.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(90), Math.toRadians(90))), 0.001);
+        assertEquals(225.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(90), Math.toRadians(-135))), 0.001);
+        assertEquals(-45.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(-135), Math.toRadians(-45))), 0.001);
+        assertEquals(-270.0, Math.toDegrees(ac.alignOrientation(Math.toRadians(-135), Math.toRadians(90))), 0.001);
+    }
+
+    @Test
+    public void testCombined()
+    {
+        double orientation = ac.calcOrientation(52.414918, 13.244221, 52.415333, 13.243595);
+        assertEquals(146.5, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+
+        orientation = ac.calcOrientation(52.414918, 13.244221, 52.414573, 13.243627);
+        assertEquals(-149.7, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+    }
+
+    @Test
+    public void testCalcAzimuth()
+    {
+        assertEquals(45.0, ac.calcAzimuth(0, 0, 10, 10), 0.001);
+        assertEquals(90.0, ac.calcAzimuth(0, 0, 0, 10), 0.001);
+        assertEquals(180.0, ac.calcAzimuth(0, 0, -10, 0), 0.001);
+        assertEquals(270.0, ac.calcAzimuth(0, 0, 0, -10), 0.001);
+        assertEquals(0.0, ac.calcAzimuth(49.942, 11.580, 49.944, 11.580), 0.001);
+    }
+
+    @Test
+    public void testAzimuthCompassPoint()
+    {
+        assertEquals("S", ac.azimuth2compassPoint(199));
+    }
+
+    @Test
+    public void testAtan2()
+    {
+        // assertEquals(0, AngleCalc.atan2(0, 0), 1e-4);
+        // assertEquals(0, AngleCalc.atan2(-0.002, 0), 1e-4);
+        assertEquals(45, AngleCalc.atan2(5, 5) * 180 / Math.PI, 1e-2);
+        assertEquals(-45, AngleCalc.atan2(-5, 5) * 180 / Math.PI, 1e-2);
+        assertEquals(11.14, AngleCalc.atan2(1, 5) * 180 / Math.PI, 1);
+        assertEquals(180, AngleCalc.atan2(0, -5) * 180 / Math.PI, 1e-2);
+        assertEquals(-90, AngleCalc.atan2(-5, 0) * 180 / Math.PI, 1e-2);
+
+        assertEquals(90, Math.atan2(1, 0) * 180 / Math.PI, 1e-2);
+        assertEquals(90, AngleCalc.atan2(1, 0) * 180 / Math.PI, 1e-2);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/util/XFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
similarity index 63%
rename from core/src/test/java/com/graphhopper/util/XFirstSearchTest.java
rename to core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
index cb5b7fe1d6..80d48d7f28 100644
--- a/core/src/test/java/com/graphhopper/util/XFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
@@ -20,6 +20,8 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.Graph;
+import gnu.trove.list.TIntList;
+import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Before;
 import org.junit.Test;
@@ -29,10 +31,11 @@
  *
  * @author Peter Karich
  */
-public class XFirstSearchTest
+public class BreadthFirstSearchTest
 {
     int counter;
     TIntHashSet set = new TIntHashSet();
+    TIntList list = new TIntArrayList();
 
     @Before
     public void setup()
@@ -43,7 +46,7 @@ public void setup()
     @Test
     public void testBFS()
     {
-        XFirstSearch bfs = new XFirstSearch()
+        BreadthFirstSearch bfs = new BreadthFirstSearch()
         {
             @Override
             public boolean goFurther( int v )
@@ -51,6 +54,7 @@ public boolean goFurther( int v )
                 counter++;
                 assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
                 set.add(v);
+                list.add(v);
                 return super.goFurther(v);
             }
         };
@@ -69,9 +73,42 @@ public boolean goFurther( int v )
         g.edge(9, 10, 8, true);
         g.edge(5, 10, 1, true);
 
-        bfs.start(g.createEdgeExplorer(), 0, false);
+        bfs.start(g.createEdgeExplorer(), 0);
 
         assertTrue(counter > 0);
         assertEquals(g.getNodes(), counter);
+        assertEquals("{0, 5, 3, 2, 1, 10, 8, 7, 6, 9, 4}", list.toString());
     }
+    
+    @Test
+    public void testBFS2()
+    {
+        BreadthFirstSearch bfs = new BreadthFirstSearch()
+        {
+            @Override
+            public boolean goFurther( int v )
+            {
+                counter++;
+                assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
+                set.add(v);
+                list.add(v);
+                return super.goFurther(v);
+            }
+        };
+
+        Graph g = new GraphBuilder(new EncodingManager("CAR")).create();
+        g.edge(1, 2, 1, false);
+        g.edge(2, 3, 1, false);
+        g.edge(3, 4, 1, false);
+        g.edge(1, 5, 1, false);
+        g.edge(5, 6, 1, false);
+        g.edge(6, 4, 1, false);
+
+        bfs.start(g.createEdgeExplorer(), 1);
+
+        assertTrue(counter > 0);
+        assertEquals("{1, 5, 2, 6, 3, 4}", list.toString());
+    }
+
+    
 }
diff --git a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
new file mode 100644
index 0000000000..9aa311807b
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2014 jan.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.util;
+
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import gnu.trove.list.TIntList;
+import gnu.trove.list.array.TIntArrayList;
+import gnu.trove.set.hash.TIntHashSet;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author jan
+ */
+public class DepthFirstSearchTest {
+    
+    int counter;
+    TIntHashSet set = new TIntHashSet();
+    TIntList list = new TIntArrayList();
+
+    @Before
+    public void setup()
+    {
+        counter = 0;
+    }
+    
+    @Test
+    public void testDFS1()
+    {
+        DepthFirstSearch dfs = new DepthFirstSearch()
+        {
+            @Override
+            public boolean goFurther( int v )
+            {
+                counter++;
+                assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
+                set.add(v);
+                list.add(v);
+                return super.goFurther(v);
+            }
+        };
+        
+        EncodingManager em = new EncodingManager("CAR");
+        FlagEncoder fe = em.getEncoder("CAR");
+        Graph g = new GraphBuilder(em).create();
+        g.edge(1, 2, 1, false);
+        g.edge(1, 5, 1, false);
+        g.edge(1, 4, 1, false);       
+        g.edge(2, 3, 1, false);
+        g.edge(3, 4, 1, false);
+        g.edge(5, 6, 1, false);
+        g.edge(6, 4, 1, false);
+
+        dfs.start(g.createEdgeExplorer(new DefaultEdgeFilter(fe, false, true)), 1);
+
+        assertTrue(counter > 0);
+        assertEquals("{1, 2, 3, 4, 5, 6}", list.toString());
+    }
+    
+    @Test
+    public void testDFS2()
+    {
+        DepthFirstSearch dfs = new DepthFirstSearch()
+        {
+            @Override
+            public boolean goFurther( int v )
+            {
+                counter++;
+                assertTrue("v " + v + " is already contained in set. iteration:" + counter, !set.contains(v));
+                set.add(v);
+                list.add(v);
+                return super.goFurther(v);
+            }
+        };
+        
+        EncodingManager em = new EncodingManager("CAR");
+        FlagEncoder fe = em.getEncoder("CAR");
+        Graph g = new GraphBuilder(em).create();
+        g.edge(1, 2, 1, false);
+        g.edge(1, 4, 1, true);
+        g.edge(1, 3, 1, false);
+        g.edge(2, 3, 1, false);
+        g.edge(4, 3, 1, true);
+
+        dfs.start(g.createEdgeExplorer(new DefaultEdgeFilter(fe, false, true)), 1);
+
+        assertTrue(counter > 0);
+        assertEquals("{1, 2, 3, 4}", list.toString());
+    }
+    
+}
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
index 3413d0dc91..4c8f3b0928 100644
--- a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
+++ b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
@@ -35,14 +35,6 @@ public void testCalcCircumference()
         assertEquals(DistanceCalcEarth.C, dc.calcCircumference(0), 1e-7);
     }
 
-    @Test
-    public void testRound()
-    {
-        assertEquals(100.94, DistanceCalcEarth.round(100.94, 2), 1e-7);
-        assertEquals(100.9, DistanceCalcEarth.round(100.94, 1), 1e-7);
-        assertEquals(101.0, DistanceCalcEarth.round(100.95, 1), 1e-7);
-    }
-
     @Test
     public void testGeohashMaxDist()
     {
@@ -138,6 +130,9 @@ public void testValidEdgeDistance()
         assertFalse(dc.validEdgeDistance(49.944482, 11.555446, 49.937964, 11.541824, 49.942272, 11.555643));
         // right bottom of the edge
         assertFalse(dc.validEdgeDistance(49.94085, 11.557356, 49.937964, 11.541824, 49.942272, 11.555643));
+
+        // rounding error
+        // assertFalse(dc.validEdgeDistance(0.001, 0.001, 0.001, 0.002, 0.00099987, 0.00099987));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
index 9bec61fda7..c13e850f06 100644
--- a/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
+++ b/core/src/test/java/com/graphhopper/util/DouglasPeuckerTest.java
@@ -28,7 +28,7 @@
 {
 
     // get some real life points from graphhopper API
-    // http://217.92.216.224:8080/api?from=49.945642,11.571436&to=49.946001,11.580706
+    // http://217.92.216.224:8080/?point=49.945642,11.571436&point=49.946001,11.580706
     String points1 = "[[11.571499218899739,49.945605917549265],[11.571664621792689,49.94570668665409],[11.571787742639804,49.94578156499077],[11.572065649302282,49.94590338198625],[11.572209445511016,49.94595944760649],[11.57229438213172,49.94598850487147],"
             + "[11.573315297960832,49.946237913062525],[11.57367665112786,49.946338495902836],[11.573895511937787,49.94641784458796],[11.574013417378367,49.94646347939514],[11.574228180368875,49.94654916107392],[11.574703899950622,49.94677509993557],"
             + "[11.575003599561832,49.946924670344394],[11.575434615658997,49.94711838544425],[11.575559971680342,49.94716010869652],[11.57563783024932,49.947186185729194],[11.57609697228887,49.94727875919518],[11.57656188852851,49.947290121330845],"
@@ -40,7 +40,7 @@
     public void testParse()
     {
         PointList pointList = new PointList();
-        pointList.parseJSON("[[11.571499218899739,49.945605917549265],[11.571664621792689,49.94570668665409]]");
+        pointList.parse2DJSON("[[11.571499218899739,49.945605917549265],[11.571664621792689,49.94570668665409]]");
         assertEquals(49.945605917549265, pointList.getLatitude(0), 1e-6);
         assertEquals(11.571499218899739, pointList.getLongitude(0), 1e-6);
         assertEquals(49.94570668665409, pointList.getLatitude(1), 1e-6);
@@ -51,7 +51,7 @@ public void testParse()
     public void testPathSimplify()
     {
         PointList pointList = new PointList();
-        pointList.parseJSON(points1);
+        pointList.parse2DJSON(points1);
         assertEquals(32, pointList.getSize());
         new DouglasPeucker().setMaxDistance(.5).simplify(pointList);
         // Arrays.asList(2, 4, 6, 7, 8, 9, 12, 14, 15, 17, 18, 19, 20, 22, 24, 27, 28, 29, 31, 33),
@@ -62,7 +62,7 @@ public void testPathSimplify()
     public void testSimplifyCheckPointCount()
     {
         PointList pointList = new PointList();
-        pointList.parseJSON(points1);
+        pointList.parse2DJSON(points1);
         DouglasPeucker dp = new DouglasPeucker().setMaxDistance(.5);
         assertEquals(32, pointList.getSize());
         dp.simplify(pointList);
@@ -76,7 +76,7 @@ public void testSimplifyCheckPointCount()
     public void testSimplifyCheckPointOrder()
     {
         PointList pointList = new PointList();
-        pointList.parseJSON(points2);
+        pointList.parse2DJSON(points2);
         assertEquals(13, pointList.getSize());
         new DouglasPeucker().setMaxDistance(.5).simplify(pointList);
         assertEquals(11, pointList.getSize());
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index be3c671cdd..a9a8e09991 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -21,6 +21,7 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
+import com.graphhopper.storage.NodeAccess;
 import static org.junit.Assert.*;
 import org.junit.Test;
 
@@ -39,15 +40,16 @@ Graph createGraph()
 
     Graph initUnsorted( Graph g )
     {
-        g.setNode(0, 0, 1);
-        g.setNode(1, 2.5, 4.5);
-        g.setNode(2, 4.5, 4.5);
-        g.setNode(3, 3, 0.5);
-        g.setNode(4, 2.8, 2.8);
-        g.setNode(5, 4.2, 1.6);
-        g.setNode(6, 2.3, 2.2);
-        g.setNode(7, 5, 1.5);
-        g.setNode(8, 4.6, 4);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 1);
+        na.setNode(1, 2.5, 4.5);
+        na.setNode(2, 4.5, 4.5);
+        na.setNode(3, 3, 0.5);
+        na.setNode(4, 2.8, 2.8);
+        na.setNode(5, 4.2, 1.6);
+        na.setNode(6, 2.3, 2.2);
+        na.setNode(7, 5, 1.5);
+        na.setNode(8, 4.6, 4);
         g.edge(8, 2, 0.5, true);
         g.edge(7, 3, 2.1, false);
         g.edge(1, 0, 3.9, true);
@@ -63,13 +65,14 @@ public void testSort()
         Graph g = initUnsorted(createGraph());
         Graph newG = GHUtility.sortDFS(g, createGraph());
         assertEquals(g.getNodes(), newG.getNodes());
-        assertEquals(0, newG.getLatitude(0), 1e-4); // 0
-        assertEquals(2.5, newG.getLatitude(1), 1e-4); // 1
-        assertEquals(4.6, newG.getLatitude(2), 1e-4); // 8
-        assertEquals(4.5, newG.getLatitude(3), 1e-4); // 2                
-        assertEquals(3.0, newG.getLatitude(4), 1e-4); // 3
-        assertEquals(5.0, newG.getLatitude(5), 1e-4); // 7
-        assertEquals(4.2, newG.getLatitude(6), 1e-4); // 5
+        NodeAccess na = newG.getNodeAccess();
+        assertEquals(0, na.getLatitude(0), 1e-4); // 0
+        assertEquals(2.5, na.getLatitude(1), 1e-4); // 1
+        assertEquals(4.5, na.getLatitude(2), 1e-4); // 2
+        assertEquals(4.6, na.getLatitude(3), 1e-4); // 8                
+        assertEquals(3.0, na.getLatitude(4), 1e-4); // 3
+        assertEquals(5.0, na.getLatitude(5), 1e-4); // 7
+        assertEquals(4.2, na.getLatitude(6), 1e-4); // 5
     }
 
     @Test
@@ -79,24 +82,38 @@ public void testSort2()
         Graph newG = GHUtility.sortDFS(g, createGraph());
         // TODO does not handle subnetworks
         assertEquals(g.getNodes(), newG.getNodes());
-        assertEquals(0, newG.getLatitude(0), 1e-4); // 0
-        assertEquals(2.5, newG.getLatitude(1), 1e-4); // 1
-        assertEquals(4.6, newG.getLatitude(2), 1e-4); // 8
-        assertEquals(4.5, newG.getLatitude(3), 1e-4); // 2        
+        NodeAccess na = newG.getNodeAccess();
+        assertEquals(0, na.getLatitude(0), 1e-4); // 0
+        assertEquals(2.5, na.getLatitude(1), 1e-4); // 1
+        assertEquals(4.5, na.getLatitude(2), 1e-4); // 2
+        assertEquals(4.6, na.getLatitude(3), 1e-4); // 8        
     }
 
     @Test
     public void testSortDirected()
     {
         Graph g = createGraph();
-        g.setNode(0, 0, 1);
-        g.setNode(1, 2.5, 2);
-        g.setNode(2, 3.5, 3);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 1);
+        na.setNode(1, 2.5, 2);
+        na.setNode(2, 3.5, 3);
         g.edge(0, 1, 1.1, false);
         g.edge(2, 1, 1.1, false);
         GHUtility.sortDFS(g, createGraph());
     }
 
+    @Test
+    public void testCopyWithSelfRef()
+    {
+        Graph g = initUnsorted(createGraph());
+        EdgeIteratorState eb = g.edge(0, 0, 11, true);
+
+        LevelGraph lg = new GraphBuilder(encodingManager).levelGraphCreate();
+        GHUtility.copyTo(g, lg);
+
+        assertEquals(g.getAllEdges().getCount(), lg.getAllEdges().getCount());
+    }
+
     @Test
     public void testCopy()
     {
@@ -111,17 +128,18 @@ public void testCopy()
 
         assertEquals(0, lg.getLevel(0));
         assertEquals(0, lg.getLevel(1));
-        assertEquals(0, lg.getLatitude(0), 1e-6);
-        assertEquals(1, lg.getLongitude(0), 1e-6);
-        assertEquals(2.5, lg.getLatitude(1), 1e-6);
-        assertEquals(4.5, lg.getLongitude(1), 1e-6);
+        NodeAccess na = lg.getNodeAccess();
+        assertEquals(0, na.getLatitude(0), 1e-6);
+        assertEquals(1, na.getLongitude(0), 1e-6);
+        assertEquals(2.5, na.getLatitude(1), 1e-6);
+        assertEquals(4.5, na.getLongitude(1), 1e-6);
         assertEquals(9, lg.getNodes());
         EdgeIterator iter = lg.createEdgeExplorer().setBaseNode(8);
         iter.next();
-        assertEquals(0.5, iter.getDistance(), 1e-6);
+        assertEquals(2.05, iter.getDistance(), 1e-6);
         assertEquals("11", BitUtil.BIG.toLastBitString(iter.getFlags(), 2));
         iter.next();
-        assertEquals(2.05, iter.getDistance(), 1e-6);
+        assertEquals(0.5, iter.getDistance(), 1e-6);
         assertEquals("11", BitUtil.BIG.toLastBitString(iter.getFlags(), 2));
 
         iter = lg.createEdgeExplorer().setBaseNode(7);
@@ -133,4 +151,20 @@ public void testCopy()
         assertEquals("01", BitUtil.BIG.toLastBitString(iter.getFlags(), 2));
         assertFalse(iter.next());
     }
+
+    @Test
+    public void testEdgeStuff()
+    {
+        assertEquals(6, GHUtility.createEdgeKey(1, 2, 3, false));
+        assertEquals(7, GHUtility.createEdgeKey(2, 1, 3, false));
+        assertEquals(7, GHUtility.createEdgeKey(1, 2, 3, true));
+        assertEquals(6, GHUtility.createEdgeKey(2, 1, 3, true));
+
+        assertEquals(8, GHUtility.createEdgeKey(1, 2, 4, false));
+        assertEquals(9, GHUtility.createEdgeKey(2, 1, 4, false));
+
+        assertTrue(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(1, 2, 4, false), GHUtility.createEdgeKey(1, 2, 4, false)));
+        assertTrue(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(2, 1, 4, false), GHUtility.createEdgeKey(1, 2, 4, false)));
+        assertFalse(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(1, 2, 4, false), GHUtility.createEdgeKey(1, 2, 5, false)));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/HelperTest.java b/core/src/test/java/com/graphhopper/util/HelperTest.java
index 74538a6243..26c942a3db 100644
--- a/core/src/test/java/com/graphhopper/util/HelperTest.java
+++ b/core/src/test/java/com/graphhopper/util/HelperTest.java
@@ -42,6 +42,13 @@ public void tearDown()
         Helper.removeDir(new File("test"));
     }
 
+    @Test
+    public void testCountBitValue() throws Exception
+    {
+        assertEquals(2, Helper.countBitValue(4));
+        assertEquals(5, Helper.countBitValue(20));
+    }
+
     @Test
     public void testUnzip() throws Exception
     {
@@ -63,4 +70,20 @@ public void testGetLocale() throws Exception
         assertEquals(Locale.ENGLISH, Helper.getLocale("en"));
         assertEquals(Locale.US, Helper.getLocale("en_US"));
     }
+
+    @Test
+    public void testRound()
+    {
+        assertEquals(100.94, Helper.round(100.94, 2), 1e-7);
+        assertEquals(100.9, Helper.round(100.94, 1), 1e-7);
+        assertEquals(101.0, Helper.round(100.95, 1), 1e-7);
+    }
+
+    @Test
+    public void testKeepIn()
+    {
+        assertEquals(2, Helper.keepIn(2, 1, 4), 1e-2);
+        assertEquals(3, Helper.keepIn(2, 3, 4), 1e-2);
+        assertEquals(3, Helper.keepIn(-2, 3, 4), 1e-2);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 0fcdf82801..79b9fc9f95 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -17,19 +17,30 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.reader.OSMWay;
-import com.graphhopper.routing.Dijkstra;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import gnu.trove.list.array.TDoubleArrayList;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+
+import com.graphhopper.reader.OSMWay;
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
+import java.io.*;
+import java.util.*;
+import javax.xml.XMLConstants;
+import javax.xml.transform.Source;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import javax.xml.validation.Validator;
+
+import org.json.JSONObject;
 import org.junit.Test;
 import static org.junit.Assert.*;
+import org.junit.Before;
+import org.xml.sax.SAXException;
 
 /**
  *
@@ -37,30 +48,41 @@
  */
 public class InstructionListTest
 {
-    TranslationMap trMap = TranslationMapTest.SINGLETON;
+    private final TranslationMap trMap = TranslationMapTest.SINGLETON;
+    private final Translation usTR = trMap.getWithFallBack(Locale.US);
+    private final TraversalMode tMode = TraversalMode.NODE_BASED;
+    private EncodingManager carManager;
+    private FlagEncoder carEncoder;
+    
+    @Before
+    public void setUp() {
+        carEncoder = new CarFlagEncoder();
+        carManager = new EncodingManager(carEncoder);
+    }
 
+    @SuppressWarnings("unchecked")
     @Test
     public void testWayList()
-    {
-        EncodingManager carManager = new EncodingManager("CAR");
+    {                
         Graph g = new GraphBuilder(carManager).create();
         // 0-1-2
         // | | |
         // 3-4-5  9-10
         // | | |  |
         // 6-7-8--*
-        g.setNode(0, 1.2, 1.0);
-        g.setNode(1, 1.2, 1.1);
-        g.setNode(2, 1.2, 1.2);
-        g.setNode(3, 1.1, 1.0);
-        g.setNode(4, 1.1, 1.1);
-        g.setNode(5, 1.1, 1.2);
-        g.setNode(9, 1.1, 1.3);
-        g.setNode(10, 1.1, 1.4);
-
-        g.setNode(6, 1.0, 1.0);
-        g.setNode(7, 1.0, 1.1);
-        g.setNode(8, 1.0, 1.2);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 1.2, 1.0);
+        na.setNode(1, 1.2, 1.1);
+        na.setNode(2, 1.2, 1.2);
+        na.setNode(3, 1.1, 1.0);
+        na.setNode(4, 1.1, 1.1);
+        na.setNode(5, 1.1, 1.2);
+        na.setNode(9, 1.1, 1.3);
+        na.setNode(10, 1.1, 1.4);
+
+        na.setNode(6, 1.0, 1.0);
+        na.setNode(7, 1.0, 1.1);
+        na.setNode(8, 1.0, 1.2);
         g.edge(0, 1, 10000, true).setName("0-1");
         g.edge(1, 2, 11000, true).setName("1-2");
 
@@ -87,22 +109,21 @@ public void testWayList()
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(0, 10);
-        InstructionList wayList = p.calcInstructions();
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 10);
+        InstructionList wayList = p.calcInstructions(usTR);
+        List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
-                "Turn left onto 7-8", "Continue onto 8-9", "Turn right onto road", "Finish!"),
-                wayList.createDescription(trMap.getWithFallBack(Locale.CANADA)));
+                "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
+                tmpList);
 
+        wayList = p.calcInstructions(trMap.getWithFallBack(Locale.GERMAN));
+        tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Geradeaus auf 0-1", "Rechts abbiegen auf 1-4", "Geradeaus auf 4-7",
-                "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen auf Strasse", "Ziel erreicht!"),
-                wayList.createDescription(trMap.getWithFallBack(Locale.GERMAN)));
-
-        List<Double> distList = wayList.createDistances();
-        assertEquals(70000.0, sum(distList), 1e-1);
-        List<String> distStrings = wayList.createDistances(trMap.get("de"), false);
-        assertEquals(Arrays.asList("10.0 km", "10.0 km", "10.0 km", "10.0 km", "20.0 km", "10.0 km", "0 m"), distStrings);
-        distStrings = wayList.createDistances(trMap.get("en_US"), true);
-        assertEquals(Arrays.asList("6.21 mi", "6.21 mi", "6.21 mi", "6.21 mi", "12.43 mi", "6.21 mi", "0 ft"), distStrings);
+                "Links abbiegen auf 7-8", "Geradeaus auf 8-9", "Rechts abbiegen", "Ziel erreicht!"),
+                tmpList);
+
+        assertEquals(70000.0, sumDistances(wayList), 1e-1);
+
         List<GPXEntry> gpxes = wayList.createGPXList();
         assertEquals(10, gpxes.size());
         // check order of tower nodes        
@@ -112,20 +133,79 @@ public void testWayList()
         // check order of pillar nodes        
         assertEquals(1.15, gpxes.get(4).getLon(), 1e-6);
         assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
+        assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
 
-        p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(6, 2);
+        compare(Arrays.asList(asL(1.2d, 1.0d), asL(1.2d, 1.1), asL(1.1d, 1.1), asL(1.0, 1.1),
+                asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
+                wayList.createStartPoints());
+
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
-        wayList = p.calcInstructions();
+        assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
+
+        wayList = p.calcInstructions(usTR);
+        tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 6-7", "Continue onto 7-8", "Turn left onto 5-8", "Continue onto 5-2", "Finish!"),
-                wayList.createDescription(trMap.getWithFallBack(Locale.CANADA)));
+                tmpList);
+
+        compare(Arrays.asList(asL(1d, 1d), asL(1d, 1.1), asL(1d, 1.2), asL(1.1, 1.2), asL(1.2, 1.2)),
+                wayList.createStartPoints());
+
+        // special case of identical start and end
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 0);
+        wayList = p.calcInstructions(usTR);
+        assertEquals(1, wayList.size());
+        assertEquals("Finish!", wayList.get(0).getTurnDescription(usTR));
+    }
+
+    List<String> pick( String key, List<Map<String, Object>> instructionJson )
+    {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson)
+        {
+            list.add(json.get(key).toString());
+        }
+        return list;
+    }
+
+    List<List<Double>> createList( PointList pl, List<Integer> integs )
+    {
+        List<List<Double>> list = new ArrayList<List<Double>>();
+        for (int i : integs)
+        {
+            List<Double> entryList = new ArrayList<Double>(2);
+            entryList.add(pl.getLatitude(i));
+            entryList.add(pl.getLongitude(i));
+            list.add(entryList);
+        }
+        return list;
     }
 
-    double sum( List<Double> list )
+    void compare( List<List<Double>> expected, List<List<Double>> was )
+    {
+        for (int i = 0; i < expected.size(); i++)
+        {
+            List<Double> e = expected.get(i);
+            List<Double> wasE = was.get(i);
+            for (int j = 0; j < e.size(); j++)
+            {
+                assertEquals("at " + j + " value " + e + " vs " + wasE, e.get(j), wasE.get(j), 1e-5d);
+            }
+        }
+    }
+
+    List<Double> asL( Double... list )
+    {
+        return Arrays.asList(list);
+    }
+
+    double sumDistances( InstructionList il )
     {
         double val = 0;
-        for (Double d : list)
+        for (Instruction i : il)
         {
-            val += d;
+            val += i.getDistance();
         }
         return val;
     }
@@ -133,7 +213,6 @@ public void testWayList()
     @Test
     public void testWayList2()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -141,10 +220,11 @@ public void testWayList2()
         //      4
         //     /
         //    3
-        g.setNode(2, 10.3, 10.15);
-        g.setNode(3, 10.0, 10.08);
-        g.setNode(4, 10.1, 10.10);
-        g.setNode(5, 10.2, 10.13);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(2, 10.3, 10.15);
+        na.setNode(3, 10.0, 10.08);
+        na.setNode(4, 10.1, 10.10);
+        na.setNode(5, 10.2, 10.13);
         g.edge(3, 4, 100, true).setName("3-4");
         g.edge(4, 5, 100, true).setName("4-5");
 
@@ -154,22 +234,24 @@ public void testWayList2()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(2, 3);
-        InstructionList wayList = p.calcInstructions();
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
+
+        InstructionList wayList = p.calcInstructions(usTR);
+        List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Finish!"),
-                wayList.createDescription(trMap.getWithFallBack(Locale.CANADA)));
+                tmpList);
 
-        p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(3, 5);
-        wayList = p.calcInstructions();
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(3, 5);
+        wayList = p.calcInstructions(usTR);
+        tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-4", "Continue onto 4-5", "Finish!"),
-                wayList.createDescription(trMap.getWithFallBack(Locale.CANADA)));
+                tmpList);
     }
 
     // problem: we normally don't want instructions if streetname stays but here it is suboptimal:
     @Test
     public void testNoInstructionIfSameStreet()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -177,10 +259,11 @@ public void testNoInstructionIfSameStreet()
         //      4
         //     /
         //    3
-        g.setNode(2, 10.3, 10.15);
-        g.setNode(3, 10.0, 10.05);
-        g.setNode(4, 10.1, 10.10);
-        g.setNode(5, 10.2, 10.15);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(2, 10.3, 10.15);
+        na.setNode(3, 10.0, 10.05);
+        na.setNode(4, 10.1, 10.10);
+        na.setNode(5, 10.2, 10.15);
         g.edge(3, 4, 100, true).setName("street");
         g.edge(4, 5, 100, true).setName("4-5");
 
@@ -190,90 +273,183 @@ public void testNoInstructionIfSameStreet()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(2, 3);
-        InstructionList wayList = p.calcInstructions();
-        assertEquals(Arrays.asList("Continue onto street", "Finish!"), wayList.createDescription(trMap.getWithFallBack(Locale.CANADA)));
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
+        InstructionList wayList = p.calcInstructions(usTR);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto street", "Finish!"), tmpList);
     }
 
     @Test
     public void testInstructionsWithTimeAndPlace()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   4-5
         //   |
         //   3-2
         //     |
         //     1
-        g.setNode(1, 15.0, 10);
-        g.setNode(2, 15.1, 10);
-        g.setNode(3, 15.1, 9.9);
-        g.setNode(4, 15.2, 9.9);
-        g.setNode(5, 15.2, 10);
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(1, 15.0, 10);
+        na.setNode(2, 15.1, 10);
+        na.setNode(3, 15.1, 9.9);
+        na.setNode(4, 15.2, 9.9);
+        na.setNode(5, 15.2, 10);
 
         g.edge(1, 2, 7000, true).setName("1-2").setFlags(flagsForSpeed(carManager, 70));
         g.edge(2, 3, 8000, true).setName("2-3").setFlags(flagsForSpeed(carManager, 80));
         g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
         g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
 
-        Path p = new Dijkstra(g, carManager.getEncoder("CAR"), new ShortestWeighting()).calcPath(1, 5);
-        InstructionList wayList = p.calcInstructions();
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
+        InstructionList wayList = p.calcInstructions(usTR);
         assertEquals(5, wayList.size());
 
         List<GPXEntry> gpxList = wayList.createGPXList();
-        // distances and times are not identical (only similar) as we only guessed the edge distance
         assertEquals(34000, p.getDistance(), 1e-1);
-        assertEquals(34000, sum(wayList.createDistances()), 1e-1);
+        assertEquals(34000, sumDistances(wayList), 1e-1);
         assertEquals(5, gpxList.size());
-        assertEquals(1636428, p.getMillis());
-        assertEquals(2148878, gpxList.get(gpxList.size() - 1).getMillis());
+        assertEquals(1604120, p.getMillis());
+        assertEquals(1604120, gpxList.get(gpxList.size() - 1).getMillis());
 
-        assertEquals(Instruction.CONTINUE_ON_STREET, wayList.get(0).getIndication());
+        assertEquals(Instruction.CONTINUE_ON_STREET, wayList.get(0).getSign());
         assertEquals(15, wayList.get(0).getFirstLat(), 1e-3);
         assertEquals(10, wayList.get(0).getFirstLon(), 1e-3);
 
-        assertEquals(Instruction.TURN_LEFT, wayList.get(1).getIndication());
+        assertEquals(Instruction.TURN_LEFT, wayList.get(1).getSign());
         assertEquals(15.1, wayList.get(1).getFirstLat(), 1e-3);
         assertEquals(10, wayList.get(1).getFirstLon(), 1e-3);
 
-        assertEquals(Instruction.TURN_RIGHT, wayList.get(2).getIndication());
+        assertEquals(Instruction.TURN_RIGHT, wayList.get(2).getSign());
         assertEquals(15.1, wayList.get(2).getFirstLat(), 1e-3);
         assertEquals(9.9, wayList.get(2).getFirstLon(), 1e-3);
 
-        assertEquals(Instruction.TURN_RIGHT, wayList.get(3).getIndication());
+        assertEquals(Instruction.TURN_RIGHT, wayList.get(3).getSign());
         assertEquals(15.2, wayList.get(3).getFirstLat(), 1e-3);
         assertEquals(9.9, wayList.get(3).getFirstLon(), 1e-3);
 
         String gpxStr = wayList.createGPX("test", 0, "GMT+1");
-        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T01:00:00+01:00</time></trkpt>"));
+        verifyGPX(gpxStr);
+
+        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T01:00:00+01:00</time>"));
+        assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
+        assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
+        assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
+
+        assertFalse(gpxStr, gpxStr.contains("NaN"));
+    }
+
+    @Test
+    public void testRoundaboutJsonIntegrity()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setDirOfRotation(-0.1)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        // assert that all information is present in map for JSON
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
+        assertEquals("2", json.get("exit_number").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
+    // Roundabout with unknown dir of rotation
+    @Test
+    public void testRoundaboutJsonNaN()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertNull(json.get("turn_angle"));
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
+    @Test
+    public void testCreateGPXWithEle()
+    {
+        final List<GPXEntry> fakeList = new ArrayList<GPXEntry>();
+        fakeList.add(new GPXEntry(12, 13, 0));
+        fakeList.add(new GPXEntry(12.5, 13, 1000));
+        InstructionList il = new InstructionList(usTR)
+        {
+            @Override
+            public List<GPXEntry> createGPXList()
+            {
+                return fakeList;
+            }
+        };
+        String gpxStr = il.createGPX("test", 0, "GMT");
+        verifyGPX(gpxStr);
+        assertFalse(gpxStr, gpxStr.contains("NaN"));
+        assertFalse(gpxStr, gpxStr.contains("<ele>"));
+
+        fakeList.clear();
+        fakeList.add(new GPXEntry(12, 13, 11, 0));
+        fakeList.add(new GPXEntry(12.5, 13, 10, 1000));
+        gpxStr = il.createGPX("test", 0, "GMT", true);
+
+        assertTrue(gpxStr, gpxStr.contains("<ele>11.0</ele>"));
+        assertFalse(gpxStr, gpxStr.contains("NaN"));
     }
 
     @Test
     public void testCreateGPX()
     {
-        InstructionList instructions = new InstructionList();
+        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
+        InstructionList instructions = new InstructionList(usTR);
         PointList pl = new PointList();
         pl.add(49.942576, 11.580384);
         pl.add(49.941858, 11.582422);
-        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", 0, 0, pl).setDistance(240).setMillis(15000));
+        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
 
         pl = new PointList();
         pl.add(49.941575, 11.583501);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", 0, 0, pl).setDistance(25).setMillis(4000));
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
 
         pl = new PointList();
         pl.add(49.941389, 11.584311);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", 0, 0, pl).setDistance(25).setMillis(3000));
-        instructions.add(new FinishInstruction(49.941029, 11.584514));
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
+        instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
 
         List<GPXEntry> result = instructions.createGPXList();
         assertEquals(5, result.size());
 
         assertEquals(0, result.get(0).getMillis());
         assertEquals(10391, result.get(1).getMillis());
-        assertEquals(15602, result.get(2).getMillis());
-        assertEquals(25449, result.get(3).getMillis());
-        assertEquals(30559, result.get(4).getMillis());
+        assertEquals(15000, result.get(2).getMillis());
+        assertEquals(19000, result.get(3).getMillis());
+        assertEquals(22000, result.get(4).getMillis());
+
+        verifyGPX(instructions.createGPX());
     }
 
     private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour )
@@ -283,4 +459,38 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
         way.setTag("maxspeed", String.format("%d km/h", speedKmPerHour));
         return encodingManager.handleWayTags(way, 1, 0);
     }
+
+    @Test
+    public void testEmptyList()
+    {        
+        Graph g = new GraphBuilder(carManager).create();
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 1);
+        InstructionList il = p.calcInstructions(usTR);
+        assertEquals(0, il.size());
+        assertEquals(0, il.createStartPoints().size());
+    }
+
+    public void verifyGPX( String gpx )
+    {
+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+        Schema schema = null;
+        try
+        {
+            Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
+            schema = schemaFactory.newSchema(schemaFile);
+
+            // using more schemas: http://stackoverflow.com/q/1094893/194609
+        } catch (SAXException e1)
+        {
+            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
+        }
+        Validator validator = schema.newValidator();
+        try
+        {
+            validator.validate(new StreamSource(new StringReader(gpx)));
+        } catch (Exception e)
+        {
+            throw new RuntimeException(e);
+        }
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
new file mode 100644
index 0000000000..f65170813b
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -0,0 +1,74 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Johannes Pelzer
+ */
+public class InstructionTest
+{
+    @Test
+    public void testCalcAzimuthAndGetDirection()
+    {
+        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
+        PointList pl = new PointList();
+        pl.add(49.942, 11.584);
+        
+        PointList nextPl = new PointList();
+        nextPl.add(49.942, 11.582);
+        Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl);
+        Instruction nextI = new Instruction(Instruction.CONTINUE_ON_STREET, "next", ea, nextPl);
+
+        assertEquals(270, currI.calcAzimuth(nextI), .1);
+        assertEquals("W", currI.calcDirection(nextI));
+
+        PointList p2 = new PointList();
+        p2.add(49.942, 11.580);
+        p2.add(49.944, 11.582);
+        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2);
+
+        assertEquals(45, i2.calcAzimuth(null), .1);
+        assertEquals("NE", i2.calcDirection(null));
+
+        PointList p3 = new PointList();
+        p3.add(49.942, 11.580);
+        p3.add(49.944, 11.580);
+        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3);
+
+        assertEquals(0, i3.calcAzimuth(null), .1);
+        assertEquals("N", i3.calcDirection(null));
+
+        PointList p4 = new PointList();
+        p4.add(49.940, 11.580);
+        p4.add(49.920, 11.586);
+        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4);
+
+        assertEquals("S", i4.calcDirection(null));
+
+        PointList p5 = new PointList();
+        p5.add(49.940, 11.580);
+        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5);
+
+        assertTrue(Double.isNaN(i5.calcAzimuth(null)));
+        assertEquals("", i5.calcDirection(null));
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index c0a4ce8902..f5314e557f 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -55,4 +55,36 @@ public void testReverse()
 
         assertEquals(clonedList, instance.clone(true));
     }
+
+    @Test
+    public void testAddPL()
+    {
+        PointList instance = new PointList();
+        for (int i = 0; i < 7; i++)
+        {
+            instance.add(0, 0);
+        }
+        assertEquals(7, instance.getSize());
+        assertEquals(10, instance.getCapacity());
+
+        PointList toAdd = new PointList();
+        instance.add(toAdd);
+        assertEquals(7, instance.getSize());
+        assertEquals(10, instance.getCapacity());
+
+        toAdd.add(1, 1);
+        toAdd.add(2, 2);
+        toAdd.add(3, 3);
+        toAdd.add(4, 4);
+        toAdd.add(5, 5);
+        instance.add(toAdd);
+
+        assertEquals(12, instance.getSize());
+        assertEquals(24, instance.getCapacity());
+
+        for (int i = 0; i < toAdd.size(); i++)
+        {
+            assertEquals(toAdd.getLatitude(i), instance.getLatitude(7 + i), 1e-1);
+        }
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index 0e66e5fc8d..7bd65b5213 100644
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.util.TranslationMap.Translation;
 import java.util.Locale;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -37,19 +36,29 @@ public void testToString()
         Translation enMap = SINGLETON.getWithFallBack(Locale.UK);
         assertEquals("continue onto blp street", enMap.tr("continue_onto", "blp street"));
 
-        Translation deMap = SINGLETON.getWithFallBack(Locale.GERMANY);
-        assertEquals("Zu Fuß", deMap.tr("web.FOOT"));
+        Translation trMap = SINGLETON.getWithFallBack(Locale.GERMANY);
+        assertEquals("Zu Fuß", trMap.tr("web.FOOT"));
 
         Translation ruMap = SINGLETON.getWithFallBack(new Locale("ru"));
         assertEquals("Пешком", ruMap.tr("web.FOOT"));
+        
+        Translation zhMap = SINGLETON.getWithFallBack(new Locale("vi", "VI"));
+        assertEquals("Đi bộ", zhMap.tr("web.FOOT"));
 
-        deMap = SINGLETON.get("de_DE");
-        assertEquals("Zu Fuß", deMap.tr("web.FOOT"));
+        trMap = SINGLETON.get("de_DE");
+        assertEquals("Zu Fuß", trMap.tr("web.FOOT"));
 
-        deMap = SINGLETON.get("de");
-        assertEquals("Zu Fuß", deMap.tr("web.FOOT"));
+        trMap = SINGLETON.get("de");
+        assertEquals("Zu Fuß", trMap.tr("web.FOOT"));
 
-        deMap = SINGLETON.get("de_AT");
-        assertEquals("Zu Fuß", deMap.tr("web.FOOT"));
+        trMap = SINGLETON.get("de_AT");
+        assertEquals("Zu Fuß", trMap.tr("web.FOOT"));
+
+        trMap = SINGLETON.get("he");
+        assertEquals("רגל", trMap.tr("web.FOOT"));
+        trMap = SINGLETON.get("iw");
+        assertEquals("רגל", trMap.tr("web.FOOT"));
+
+        // indonesia assertEquals("in", new Locale("id").getLanguage());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
index 3c08212aa1..e8847d47fd 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/CoordTrigTest.java
@@ -27,15 +27,5 @@
  */
 public class CoordTrigTest
 {
-    @Test
-    public void testIsValid()
-    {
-        CoordTrig instance = new CoordTrig();
-        assertFalse(instance.isValid());
-        instance.lat = 1;
-        assertFalse(instance.isValid());
-        instance.lon = 1;
-        assertTrue(instance.isValid());
-    }
 
 }
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
new file mode 100644
index 0000000000..aa8c97562e
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPoint3DTest.java
@@ -0,0 +1,49 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.shapes;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class GHPoint3DTest
+{
+    @Test
+    public void testEquals()
+    {
+        GHPoint3D point1 = new GHPoint3D(1, 2, Double.NaN);
+        GHPoint3D point2 = new GHPoint3D(1, 2, Double.NaN);
+        assertEquals(point1, point2);
+
+        point1 = new GHPoint3D(1, 2, 0);
+        point2 = new GHPoint3D(1, 2, 1);
+        assertNotEquals(point1, point2);
+
+        point1 = new GHPoint3D(1, 2, 0);
+        point2 = new GHPoint3D(1, 2.1, 0);
+        assertNotEquals(point1, point2);
+
+        point1 = new GHPoint3D(1, 2.1, 0);
+        point2 = new GHPoint3D(1, 2.1, 0);
+        assertEquals(point1, point2);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
new file mode 100644
index 0000000000..6adac39794
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/shapes/GHPointTest.java
@@ -0,0 +1,40 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.shapes;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class GHPointTest
+{
+    @Test
+    public void testIsValid()
+    {
+        GHPoint instance = new GHPoint();
+        assertFalse(instance.isValid());
+        instance.lat = 1;
+        assertFalse(instance.isValid());
+        instance.lon = 1;
+        assertTrue(instance.isValid());
+    }
+}
diff --git a/core/src/test/resources/com/graphhopper/reader/custom-osm-ele.xml b/core/src/test/resources/com/graphhopper/reader/custom-osm-ele.xml
new file mode 100644
index 0000000000..09093ea247
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/reader/custom-osm-ele.xml
@@ -0,0 +1,56 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version="0.6" generator="pbf2osm">
+    <node id="10" lat="51.2492152" lon="9.4317166" uid="24853">
+        <tag k="is_in" v="Wiesbaden,Hessen,Germany,Europe" />
+        <tag k="name" v="Wiesbaden-Naurod" />
+        <tag k="place" v="village" />
+        <tag k="ele" v="3" />
+    </node>
+    <node id="20" lat="52" lon="9" uid="24854">
+        <tag k="name" v="Halbendorf-Spree" />
+        <tag k="ele" v="-10" />
+    </node>
+    <node id="30" lat="51.2" lon="9.4" uid="24855">
+        <tag k="name" v="Dresden" />
+        <tag k="ele" v="10" />
+    </node>
+    
+    <node id="35" lat="45.2" lon="13.431" uid="3212487">
+        <tag k="name" v="Unused1" />
+        <tag k="ele" v="4" />
+    </node>
+
+    <node id="40" lat="51.25" lon="9.43" uid="24856">
+        <tag k="name" v="Cottbus" />
+        <tag k="ele" v="100" />
+    </node>
+    <node id="41" lat="51.23" lon="11.43" uid="3214857">
+        <tag k="name" v="Unused2" />
+        <tag k="ele" v="1000" />
+    </node>
+    <node id="45" lat="41.2" lon="10.431" uid="32124857">
+        <tag k="name" v="Unused3" />
+        <tag k="ele" v="20" />
+    </node>
+    <node id="50" lat="49" lon="10" uid="24857">
+        <tag k="name" v="Tester" />
+        <tag k="ele" v="-30" />
+    </node>
+    
+    <way id="10" uid="85761">
+        <nd ref="10"/>
+        <nd ref="20"/>        
+        <nd ref="30"/>
+        <tag k="name" v="route 666" />
+        <tag k="highway" v="motorway_link" />
+        <tag k="destination" v="hof;fürth" />
+    </way> 
+    
+    <way id="11" uid="85762">
+        <nd ref="20"/>
+        <nd ref="40"/>
+        <nd ref="50"/>        
+        <tag k="name" v="street 123;B 122" />
+        <tag k="highway" v="service" />
+    </way>
+</osm>
diff --git a/core/src/test/resources/com/graphhopper/reader/test-osm3.xml b/core/src/test/resources/com/graphhopper/reader/test-osm3.xml
index ca75a0f670..e56f318909 100644
--- a/core/src/test/resources/com/graphhopper/reader/test-osm3.xml
+++ b/core/src/test/resources/com/graphhopper/reader/test-osm3.xml
@@ -29,7 +29,7 @@
         <nd ref="10"/>
         <nd ref="20"/>
         <nd ref="30"/>
-        <tag k="tmpStr" v="A B C" />
+        <tag k="name" v="A B C" />
         <tag k="oneway" v="true" />
         <tag k="highway" v="secondary" />
     </way>    
@@ -38,7 +38,7 @@
         <nd ref="10"/>
         <nd ref="40"/>
         <nd ref="30"/>
-        <tag k="tmpStr" v="A D C" />
+        <tag k="name" v="A D C" />
         <tag k="oneway" v="true" />
         <tag k="highway" v="motorway" />      
     </way>
@@ -47,15 +47,15 @@
         <nd ref="10"/>
         <nd ref="50"/>
         <nd ref="30"/>
-        <tag k="tmpStr" v="A E C" />
-        <tag k="highway" v="footway"/>
+        <tag k="name" v="A E C" />
+        <tag k="highway" v="footway"/>        
     </way>    
     
     <way id="13">
         <nd ref="20"/>
         <nd ref="40"/>
         <nd ref="50"/>
-        <tag k="tmpStr" v="B D E" />
+        <tag k="name" v="B D E" />
         <tag k="highway" v="motorway" />
         <tag k="maxspeed" v="40" />
     </way>
diff --git a/core/src/test/resources/com/graphhopper/reader/test-osm5.xml b/core/src/test/resources/com/graphhopper/reader/test-osm5.xml
new file mode 100644
index 0000000000..f99ddde32d
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/reader/test-osm5.xml
@@ -0,0 +1,66 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version="0.6" generator="pbf2osm">
+    
+    <!--  __B__ 
+         /  |  \
+        A___D__C
+         \  |  /
+          \_E_F    
+    -->
+          
+    <node id="10" lat="49.501" lon="11.5001" uid="24853">
+        <tag k="name" v="A" />
+    </node>
+    <node id="20" lat="49.502" lon="11.501" uid="24854">
+        <tag k="name" v="B" />
+    </node>
+    <node id="30" lat="49.5011" lon="11.502" uid="24855">
+        <tag k="name" v="C" />
+    </node>
+    <node id="40" lat="49.5009" lon="11.501" uid="24854">
+        <tag k="name" v="D" />
+    </node>
+    <node id="50" lat="49.5001" lon="11.501">
+        <tag k="name" v="E" />
+    </node>
+    <node id="60" lat="49.5002" lon="11.5015">
+        <tag k="name" v="F" />
+    </node>
+        
+    <way id="10" uid="85761">
+        <nd ref="10"/>
+        <nd ref="20"/>
+        <nd ref="30"/>
+        <tag k="tmpStr" v="A B C" />
+        <tag k="oneway" v="true" />
+        <tag k="highway" v="secondary" />
+    </way>    
+    
+    <way id="12" uid="85762">
+        <nd ref="10"/>
+        <nd ref="40"/>
+        <nd ref="30"/>
+        <tag k="tmpStr" v="A D C" />
+        <tag k="oneway" v="true" />
+        <tag k="highway" v="motorway" />      
+    </way>
+    
+    <way id="11" uid="85761">
+        <nd ref="10"/>
+        <nd ref="50"/>
+        <nd ref="60"/>
+        <nd ref="30"/>
+        <tag k="tmpStr" v="A E F C" />
+        <tag k="highway" v="footway"/>
+    </way>    
+    
+    <way id="13">
+        <nd ref="20"/>
+        <nd ref="40"/>
+        <nd ref="50"/>
+        <tag k="tmpStr" v="B D E" />
+        <tag k="highway" v="motorway" />
+        <tag k="maxspeed" v="40" />
+    </way>
+
+</osm>
\ No newline at end of file
diff --git a/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml b/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml
index c049547376..0b27af2da6 100644
--- a/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml
+++ b/core/src/test/resources/com/graphhopper/reader/test-restrictions.xml
@@ -11,29 +11,36 @@
       (2,3)->(3,4): straight_only
       (4,3)->(3,8): no_right_turn
       (4,5)->(5,6): right_turn_only
-      (6,1)->(1,5): no_u_turn
+      (6,1)->(1,6): no_u_turn
+    -->
+    
+   <!-- 
+       bike only
+       
+       10~~11~~12
+       |   |   |
+       13~~14~~15
+       
+       
+      (10,11)->(11,14): no_right_turn
     -->
 
-
-    <node id="1" lat="50" lon="10">
-    </node>
-    <node id="2" lat="52" lon="10">
-    </node>
-    <node id="3" lat="52" lon="11">
-    </node>
-    <node id="4" lat="52" lon="12">
-    </node>
-    <node id="5" lat="50" lon="12">
-    </node>
-    <node id="6" lat="51" lon="11">
-    </node>
-    <node id="7" lat="54" lon="12">
-    </node>
-    <node id="8" lat="54" lon="11">
-    </node>
-    <node id="9" lat="54" lon="10">
-    </node>
+    <node id="1" lat="50" lon="10"> </node>
+    <node id="2" lat="52" lon="10"> </node>
+    <node id="3" lat="52" lon="11"> </node>
+    <node id="4" lat="52" lon="12"> </node>
+    <node id="5" lat="50" lon="12"> </node>
+    <node id="6" lat="51" lon="11"> </node>
+    <node id="7" lat="54" lon="12"> </node>
+    <node id="8" lat="54" lon="11"> </node>
+    <node id="9" lat="54" lon="10"> </node>
     
+    <node id="10" lat="40" lon="10"></node>    
+    <node id="11" lat="40" lon="11"></node>    
+    <node id="12" lat="40" lon="12"></node>
+    <node id="13" lat="39" lon="10"></node>
+    <node id="14" lat="39" lon="11"></node>
+    <node id="15" lat="39" lon="12"></node>    
                       
     <!-- 1-2 -->
     <way id="12">
@@ -105,6 +112,54 @@
         <tag k="highway" v="motorway" />
     </way>
     
+    <way id="510">
+        <nd ref="5"/>     
+        <nd ref="10"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1011">
+        <nd ref="10"/>     
+        <nd ref="11"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1112">
+        <nd ref="11"/>     
+        <nd ref="12"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1013">
+        <nd ref="10"/>     
+        <nd ref="13"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1114">
+        <nd ref="11"/>     
+        <nd ref="14"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1215">
+        <nd ref="12"/>     
+        <nd ref="15"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1314">
+        <nd ref="13"/>     
+        <nd ref="14"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+    
+    <way id="1415">
+        <nd ref="14"/>     
+        <nd ref="15"/>
+        <tag k="highway" v="cycleway" />
+    </way>
+        
     <relation id="1001">
         <member type="way" ref="23" role="from"/>
         <member type="way" ref="34" role="to"/>
@@ -112,7 +167,7 @@
         <tag k="restriction" v="only_straight_on"/>
         <tag k="type" v="restriction"/>
     </relation>
-    
+        
     <relation id="1002">
         <member type="way" ref="34" role="from"/>
         <member type="way" ref="38" role="to"/>
@@ -131,10 +186,18 @@
     
     <relation id="1004">
         <member type="way" ref="61" role="from"/>
-        <member type="way" ref="51" role="to"/>
+        <member type="way" ref="61" role="to"/>
         <member type="node" ref="1" role="via"/>
         <tag k="restriction" v="no_u_turn"/>
         <tag k="type" v="restriction"/>
     </relation>
     
+    <relation id="1005">
+        <member type="way" ref="1011" role="from"/>
+        <member type="way" ref="1114" role="to"/>
+        <member type="node" ref="11" role="via"/>
+        <tag k="restriction" v="no_right_turn"/>
+        <tag k="type" v="restriction"/>
+    </relation>
+    
 </osm>
diff --git a/core/src/test/resources/com/graphhopper/routing/test-graph.svg b/core/src/test/resources/com/graphhopper/routing/test-graph.svg
index b08e85183c..c9c1adc45e 100644
--- a/core/src/test/resources/com/graphhopper/routing/test-graph.svg
+++ b/core/src/test/resources/com/graphhopper/routing/test-graph.svg
@@ -2,184 +2,338 @@
 <!-- Created with Inkscape (http://www.inkscape.org/) -->
 
 <svg
-    xmlns:dc="http://purl.org/dc/elements/1.1/"
-    xmlns:cc="http://creativecommons.org/ns#"
-    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-    xmlns:svg="http://www.w3.org/2000/svg"
-    xmlns="http://www.w3.org/2000/svg"
-    xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-    xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-    width="210mm"
-    height="297mm"
-    id="svg2"
-    version="1.1"
-    inkscape:version="0.48.0 r9654"
-    sodipodi:docname="wikipedia-graph.svg">
-    <defs
-        id="defs4" />
-    <sodipodi:namedview
-        id="base"
-        pagecolor="#ffffff"
-        bordercolor="#666666"
-        borderopacity="1.0"
-        inkscape:pageopacity="0.0"
-        inkscape:pageshadow="2"
-        inkscape:zoom="1.4"
-        inkscape:cx="176.76414"
-        inkscape:cy="898.21698"
-        inkscape:document-units="px"
-        inkscape:current-layer="layer1"
-        showgrid="false"
-        inkscape:window-width="789"
-        inkscape:window-height="678"
-        inkscape:window-x="740"
-        inkscape:window-y="60"
-        inkscape:window-maximized="0" />
-    <metadata
-        id="metadata7">
-        <rdf:RDF>
-            <cc:Work
-                rdf:about="">
-                <dc:format>image/svg+xml</dc:format>
-                <dc:type
-                    rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-                <dc:title></dc:title>
-            </cc:Work>
-        </rdf:RDF>
-    </metadata>
-    <g
-        inkscape:label="Ebene 1"
-        inkscape:groupmode="layer"
-        id="layer1">
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 49.684603,95.607751 39.395949,40.189332 178.797,75.544671"
-            id="path2985"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="ccc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 50.507627,95.747722 179.80715,74.534519"
-            id="path2987"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="32.324883"
-            y="33.118263"
-            id="text2989"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan2991"
-            x="32.324883"
-            y="33.118263">0</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="25.766541"
-            y="114.74118"
-            id="text2993"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan2995"
-            x="25.766541"
-            y="114.74118">1</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="176.82745"
-            y="65.768753"
-            id="text2997"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan2999"
-            x="176.82745"
-            y="65.768753">4</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="180.27634"
-            y="163.46999"
-            id="text3001"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3003"
-            x="180.27634"
-            y="163.46999">5</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="149.85793"
-            y="212.35471"
-            id="text3005"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3007"
-            x="149.85793"
-            y="212.35471">2</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 179.80715,127.06245 c 0,0 -125.258913,-30.304575 -129.299523,-30.304575 L 176.7767,183.63099 z"
-            id="path3009"
-            inkscape:connector-curvature="0" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 174.75639,182.62084 278.8021,145.2452"
-            id="path3011"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="272.74118"
-            y="176.55992"
-            id="text3013"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3015"
-            x="272.74118"
-            y="176.55992">3</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 180.81731,127.06245 95.96449,19.1929 81.82235,-50.507628"
-            id="path3017"
-            inkscape:connector-curvature="0" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 178.797,126.0523 0,-50.507629 96.97464,-7.071068"
-            id="path3019"
-            inkscape:connector-curvature="0" />
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="267.69043"
-            y="56.351772"
-            id="text3021"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3023"
-            x="267.69043"
-            y="56.351772">6</tspan></text>
-        <text
-            xml:space="preserve"
-            style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
-            x="361.63461"
-            y="82.615738"
-            id="text3025"
-            sodipodi:linespacing="100%"><tspan
-            sodipodi:role="line"
-            id="tspan3027"
-            x="361.63461"
-            y="82.615738">7</tspan></text>
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="M 276.7818,68.473603 178.61317,127.18501 356.58385,95.747722"
-            id="path3029"
-            inkscape:connector-curvature="0"
-            sodipodi:nodetypes="ccc" />
-        <path
-            style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-            d="m 275.71429,68.790753 81.42857,26.428571"
-            id="path3031"
-            inkscape:connector-curvature="0" />
-    </g>
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="210mm"
+   height="297mm"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.48.4 r9939"
+   sodipodi:docname="test-graph.svg">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="0.98994949"
+     inkscape:cx="186.32012"
+     inkscape:cy="855.76121"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     inkscape:window-width="1600"
+     inkscape:window-height="1136"
+     inkscape:window-x="0"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Ebene 1"
+     inkscape:groupmode="layer"
+     id="layer1">
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 49.684603,95.607751 39.395949,40.189332 178.797,75.544671"
+       id="path2985"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 50.507627,95.747722 179.80715,74.534519"
+       id="path2987"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="32.324883"
+       y="33.118263"
+       id="text2989"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan2991"
+         x="32.324883"
+         y="33.118263">0</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="25.766541"
+       y="114.74118"
+       id="text2993"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan2995"
+         x="25.766541"
+         y="114.74118">1</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="176.82745"
+       y="65.768753"
+       id="text2997"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan2999"
+         x="176.82745"
+         y="65.768753">4</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="181.28648"
+       y="156.39893"
+       id="text3001"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3003"
+         x="181.28648"
+         y="156.39893">5</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="149.85793"
+       y="212.35471"
+       id="text3005"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3007"
+         x="149.85793"
+         y="212.35471">2</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 179.80715,127.06245 c 0,0 -125.258913,-30.304575 -129.299523,-30.304575 L 176.7767,183.63099 z"
+       id="path3009"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 174.75639,182.62084 278.8021,145.2452"
+       id="path3011"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="272.74118"
+       y="176.55992"
+       id="text3013"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3015"
+         x="272.74118"
+         y="176.55992">3</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 180.81731,127.06245 95.96449,19.1929 81.82235,-50.507628"
+       id="path3017"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 178.797,126.0523 0,-50.507629 96.97464,-7.071068"
+       id="path3019"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="267.69043"
+       y="56.351772"
+       id="text3021"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3023"
+         x="267.69043"
+         y="56.351772">6</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:36px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;text-align:start;line-height:100%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Comic Sans MS;-inkscape-font-specification:Comic Sans MS Bold"
+       x="361.63461"
+       y="82.615738"
+       id="text3025"
+       sodipodi:linespacing="100%"><tspan
+         sodipodi:role="line"
+         id="tspan3027"
+         x="361.63461"
+         y="82.615738">7</tspan></text>
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="M 276.7818,68.473603 178.61317,127.18501 356.58385,95.747722"
+       id="path3029"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 275.71429,68.790753 81.42857,26.428571"
+       id="path3031"
+       inkscape:connector-curvature="0" />
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="104.04571"
+       y="51.30101"
+       id="text3006"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3008"
+         x="104.04571"
+         y="51.30101">(111)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="47.477169"
+       y="67.463455"
+       id="text3010"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3012"
+         x="47.477169"
+         y="67.463455">(111)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="97.984795"
+       y="81.605591"
+       id="text3014"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3016"
+         x="97.984795"
+         y="81.605591">(89)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="119.19799"
+       y="111.91016"
+       id="text3018"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3020"
+         x="119.19799"
+         y="111.91016">(89)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="86.873123"
+       y="153.32642"
+       id="text3022"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3024"
+         x="86.873123"
+         y="153.32642">(89)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="147.48227"
+       y="157.36703"
+       id="text3026"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3028"
+         x="147.48227"
+         y="157.36703">(22)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="215.16249"
+       y="180.60054"
+       id="text3030"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3032"
+         x="215.16249"
+         y="180.60054">(57)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="228.29448"
+       y="136.15382"
+       id="text3034"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3036"
+         x="228.29448"
+         y="136.15382">(70)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="309.10669"
+       y="137.16399"
+       id="text3038"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3040"
+         x="309.10669"
+         y="137.16399">(70)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="268.70059"
+       y="105.84925"
+       id="text3042"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3044"
+         x="268.70059"
+         y="105.84925">(79)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="208.09143"
+       y="95.747719"
+       id="text3046"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3048"
+         x="208.09143"
+         y="95.747719">(79)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="153.54318"
+       y="102.81879"
+       id="text3050"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3052"
+         x="153.54318"
+         y="102.81879">(101)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="221.2234"
+       y="66.4533"
+       id="text3054"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3056"
+         x="221.2234"
+         y="66.4533">(101)</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
+       x="307.08636"
+       y="75.544678"
+       id="text3058"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3060"
+         x="307.08636"
+         y="75.544678">(103)</tspan></text>
+  </g>
 </svg>
diff --git a/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd b/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
new file mode 100644
index 0000000000..58cfdeb1ba
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
@@ -0,0 +1,789 @@
+<?xml version="1.0" encoding="utf-8"?>
+<xsd:schema
+    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
+    xmlns="http://www.topografix.com/GPX/1/1"
+    targetNamespace="http://www.topografix.com/GPX/1/1"    
+    elementFormDefault="qualified">
+
+    <xsd:annotation>
+        <xsd:documentation>
+            GPX schema version 1.1 - For more information on GPX and this schema, visit http://www.topografix.com/gpx.asp
+
+            GPX uses the following conventions: all coordinates are relative to the WGS84 datum.  All measurements are in metric units.
+        </xsd:documentation>
+    </xsd:annotation>
+
+    <xsd:element name="gpx"	type="gpxType">
+        <xsd:annotation>
+            <xsd:documentation>
+                GPX is the root element in the XML file.
+            </xsd:documentation>
+        </xsd:annotation>
+    </xsd:element>
+
+    <xsd:complexType name="gpxType">
+        <xsd:annotation>
+            <xsd:documentation>
+                GPX documents contain a metadata header, followed by waypoints, routes, and tracks.  You can add your own elements
+                to the extensions section of the GPX document.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>
+            <xsd:element name="metadata"	type="metadataType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Metadata about the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="wpt"			type="wptType"	minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A list of waypoints.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="rte"			type="rteType"	minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A list of routes.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="trk"			type="trkType"	minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A list of tracks.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+
+        <xsd:attribute name="version" type="xsd:string" use="required" fixed="1.1">
+            <xsd:annotation>
+                <xsd:documentation>
+                    You must include the version number in your GPX document.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="creator" type="xsd:string" use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    You must include the name or URL of the software that created your GPX document.  This allows others to
+                    inform the creator of a GPX instance document that fails to validate.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="metadataType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Information about the GPX file, author, and copyright restrictions goes in the metadata section.  Providing rich,
+                meaningful information about your GPX files allows others to search for and use your GPS data.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="name"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The name of the GPX file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="desc"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A description of the contents of the GPX file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="author"		type="personType"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The person or organization who created the GPX file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="copyright"	type="copyrightType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Copyright and license information governing use of the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"		type="linkType"			minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        URLs associated with the location described in the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="time"		type="xsd:dateTime"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The creation date of the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="keywords"	type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Keywords associated with the file.  Search engines or databases can use this information to classify the data.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="bounds"		type="boundsType"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Minimum and maximum coordinates which describe the extent of the coordinates in the file.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="wptType">
+        <xsd:annotation>
+            <xsd:documentation>
+                wpt represents a waypoint, point of interest, or named feature on a map.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <!-- Position info -->
+            <xsd:element name="ele"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Elevation (in meters) of the point.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="time"			type="xsd:dateTime"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Creation/modification timestamp for element. Date and time in are in Univeral Coordinated Time (UTC), not local time! Conforms to ISO 8601 specification for date/time representation. Fractional seconds are allowed for millisecond timing in tracklogs. 
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="magvar"		type="degreesType"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Magnetic variation (in degrees) at the point
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="geoidheight"	type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Height (in meters) of geoid (mean sea level) above WGS84 earth ellipsoid.  As defined in NMEA GGA message.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <!-- Description info -->
+            <xsd:element name="name"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The GPS name of the waypoint. This field will be transferred to and from the GPS. GPX does not place restrictions on the length of this field or the characters contained in it. It is up to the receiving application to validate the field before sending it to the GPS.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="cmt"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS waypoint comment. Sent to GPS as comment. 
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="desc"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A text description of the element. Holds additional information about the element intended for the user, not the GPS.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="src"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Source of data. Included to give user some idea of reliability and accuracy of data.  "Garmin eTrex", "USGS quad Boston North", e.g.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"			type="linkType"			minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Link to additional information about the waypoint.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="sym"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Text of GPS symbol name. For interchange with other programs, use the exact spelling of the symbol as displayed on the GPS.  If the GPS abbreviates words, spell them out.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="type"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Type (classification) of the waypoint.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <!-- Accuracy info -->
+            <xsd:element name="fix"			type="fixType"			minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Type of GPX fix.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="sat"			type="xsd:nonNegativeInteger"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Number of satellites used to calculate the GPX fix.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="hdop"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Horizontal dilution of precision.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="vdop"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Vertical dilution of precision.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="pdop"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Position dilution of precision.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="ageofdgpsdata"	type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Number of seconds since last DGPS update.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="dgpsid"		type="dgpsStationType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        ID of DGPS station used in differential correction.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"		type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+
+        <xsd:attribute name="lat"			type="latitudeType"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The latitude of the point.  This is always in decimal degrees, and always in WGS84 datum.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="lon"			type="longitudeType"	use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The longitude of the point.  This is always in decimal degrees, and always in WGS84 datum.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="rteType">
+        <xsd:annotation>
+            <xsd:documentation>
+                rte represents route - an ordered list of waypoints representing a series of turn points leading to a destination.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>
+            <xsd:element name="name"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS name of route.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="cmt"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS comment for route.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="desc"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Text description of route for user.  Not sent to GPS.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="src"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Source of data. Included to give user some idea of reliability and accuracy of data.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"			type="linkType"		minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Links to external information about the route.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="number"		type="xsd:nonNegativeInteger"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS route number.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="type"			type="xsd:string"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Type (classification) of route.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"		type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+ 
+            <xsd:element name="rtept"	type="wptType" minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A list of route points.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="trkType">
+        <xsd:annotation>
+            <xsd:documentation>
+                trk represents a track - an ordered list of points describing a path.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>
+            <xsd:element name="name"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS name of track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="cmt"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS comment for track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="desc"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        User description of track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="src"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Source of data. Included to give user some idea of reliability and accuracy of data.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"			type="linkType"			minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Links to external information about track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="number"		type="xsd:nonNegativeInteger"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        GPS track number.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="type"			type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Type (classification) of track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+  
+            <xsd:element name="trkseg"		type="trksegType"		minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A Track Segment holds a list of Track Points which are logically connected in order. To represent a single GPS track where GPS reception was lost, or the GPS receiver was turned off, start a new Track Segment for each continuous span of track data.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+ 
+    <xsd:complexType name="extensionsType">
+        <xsd:annotation>
+            <xsd:documentation>
+                You can add extend GPX by adding your own elements from another schema here.
+            </xsd:documentation>
+        </xsd:annotation>
+        <!-- as we need separate namespace 'gh' could not get it working with proper validation :( so ignoring this for now-->
+        <xsd:sequence>
+            <xsd:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:any>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="trksegType">
+        <xsd:annotation>
+            <xsd:documentation>
+                A Track Segment holds a list of Track Points which are logically connected in order. To represent a single GPS track where GPS reception was lost, or the GPS receiver was turned off, start a new Track Segment for each continuous span of track data.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="trkpt"	type="wptType" minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        A Track Point holds the coordinates, elevation, timestamp, and metadata for a single point in a track.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+
+            <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="copyrightType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Information about the copyright holder and any license governing use of this file.  By linking to an appropriate license,
+                you may place your data into the public domain or grant additional usage rights.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="year"		type="xsd:gYear"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Year of copyright.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="license"		type="xsd:anyURI"	minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Link to external file containing license text.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+        <xsd:attribute name="author" type="xsd:string" use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    Copyright holder (TopoSoft, Inc.)
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="linkType">
+        <xsd:annotation>
+            <xsd:documentation>
+                A link to an external resource (Web page, digital photo, video clip, etc) with additional information.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="text"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Text of hyperlink.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="type"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Mime type of content (image/jpeg)
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+        <xsd:attribute name="href" type="xsd:anyURI" use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    URL of hyperlink.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="emailType">
+        <xsd:annotation>
+            <xsd:documentation>
+                An email address.  Broken into two parts (id and domain) to help prevent email harvesting.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:attribute name="id"			type="xsd:string"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    id half of email address (billgates2004)
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="domain"		type="xsd:string"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    domain half of email address (hotmail.com)
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="personType">
+        <xsd:annotation>
+            <xsd:documentation>
+                A person or organization.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="name"		type="xsd:string"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Name of person or organization.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="email"		type="emailType"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Email address.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="link"		type="linkType"			minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Link to Web site or other external information about person.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="ptType">
+        <xsd:annotation>
+            <xsd:documentation>
+                A geographic point with optional elevation and time.  Available for use by other schemas.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="ele"			type="xsd:decimal"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The elevation (in meters) of the point.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+            <xsd:element name="time"		type="xsd:dateTime"		minOccurs="0">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        The time that the point was recorded.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+        <xsd:attribute name="lat"			type="latitudeType"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The latitude of the point.  Decimal degrees, WGS84 datum.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="lon"			type="longitudeType"	use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The latitude of the point.  Decimal degrees, WGS84 datum.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+    <xsd:complexType name="ptsegType">
+        <xsd:annotation>
+            <xsd:documentation>
+                An ordered sequence of points.  (for polygons or polylines, e.g.)
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:sequence>	<!-- elements must appear in this order -->
+            <xsd:element name="pt"	type="ptType"	minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        Ordered list of geographic points.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:element>
+        </xsd:sequence>
+    </xsd:complexType>
+
+    <xsd:complexType name="boundsType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Two lat/lon pairs defining the extent of an element.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:attribute name="minlat"		type="latitudeType"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The minimum latitude.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="minlon"		type="longitudeType"	use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The minimum longitude.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="maxlat"		type="latitudeType"		use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The maximum latitude.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+        <xsd:attribute name="maxlon"		type="longitudeType"	use="required">
+            <xsd:annotation>
+                <xsd:documentation>
+                    The maximum longitude.
+                </xsd:documentation>
+            </xsd:annotation>
+        </xsd:attribute>
+    </xsd:complexType>
+
+
+    <xsd:simpleType name="latitudeType">
+        <xsd:annotation>
+            <xsd:documentation>
+                The latitude of the point.  Decimal degrees, WGS84 datum.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:decimal">
+            <xsd:minInclusive value="-90.0"/>
+            <xsd:maxInclusive value="90.0"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+    <xsd:simpleType name="longitudeType">
+        <xsd:annotation>
+            <xsd:documentation>
+                The longitude of the point.  Decimal degrees, WGS84 datum.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:decimal">
+            <xsd:minInclusive value="-180.0"/>
+            <xsd:maxExclusive value="180.0"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+    <xsd:simpleType name="degreesType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Used for bearing, heading, course.  Units are decimal degrees, true (not magnetic).
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:decimal">
+            <xsd:minInclusive value="0.0"/>
+            <xsd:maxExclusive value="360.0"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+    <xsd:simpleType name="fixType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Type of GPS fix.  none means GPS had no fix.  To signify "the fix info is unknown, leave out fixType entirely. pps = military signal used
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:string">
+            <xsd:enumeration value="none"/>
+            <xsd:enumeration value="2d"/>
+            <xsd:enumeration value="3d"/>
+            <xsd:enumeration value="dgps"/>
+            <xsd:enumeration value="pps"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+    <xsd:simpleType name="dgpsStationType">
+        <xsd:annotation>
+            <xsd:documentation>
+                Represents a differential GPS station.
+            </xsd:documentation>
+        </xsd:annotation>
+        <xsd:restriction base="xsd:integer">
+            <xsd:minInclusive value="0"/>
+            <xsd:maxInclusive value="1023"/>
+        </xsd:restriction>
+    </xsd:simpleType>
+
+</xsd:schema>
diff --git a/core/src/test/resources/log4j.properties b/core/src/test/resources/log4j.properties
deleted file mode 100644
index 0a4d4c5e06..0000000000
--- a/core/src/test/resources/log4j.properties
+++ /dev/null
@@ -1,9 +0,0 @@
-# separate logging config to disable INFO
-
-log4j.appender.StdoutApp=org.apache.log4j.ConsoleAppender
-log4j.appender.StdoutApp.layout=org.apache.log4j.PatternLayout
-log4j.appender.StdoutApp.layout.conversionPattern=%d [%t] %-5p %c - %m%n
-
-log4j.rootLogger=WARN
-
-log4j.logger.com.graphhopper=WARN, StdoutApp
diff --git a/core/src/test/resources/log4j.xml b/core/src/test/resources/log4j.xml
new file mode 100644
index 0000000000..a9bb71c09f
--- /dev/null
+++ b/core/src/test/resources/log4j.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration>
+    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
+        </layout>
+    </appender>
+    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
+        <param name="BufferSize" value="500"/>
+        <appender-ref ref="stdout"/>
+    </appender>    
+    <logger name="com.graphhopper" additivity="false">
+        <level value="warn" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <root>
+        <priority value="warn"></priority>
+        <appender-ref ref="ASYNC"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
diff --git a/docs/android/android-studio-setup.md b/docs/android/android-studio-setup.md
new file mode 100644
index 0000000000..2e455b0867
--- /dev/null
+++ b/docs/android/android-studio-setup.md
@@ -0,0 +1,20 @@
+# Open Demo App with Android Studio
+
+Get the [GraphHopper sources and demo](./index.md) before you proceed.
+
+## Setup
+
+[Download](http://developer.android.com/sdk/index.html) and start android studio
+
+Open existing Android studio project and then open 'graphhopper/android' not the parent 'graphhopper'
+
+![Open Existing](./images/android-studio-open-existing.png)
+
+Import project from Gradle, but make sure the 'Gradle project' points to graphhopper/android
+
+![Import project from Gradle](./images/android-studio-import-project-from-gradle.png)
+
+## Start Demo
+
+ 1. Connect your device in development mode (USB debugging)
+ 2. Then hit SHIFT+F10 or click Run->Run 'app' in the menu
diff --git a/docs/android/images/android-studio-import-project-from-gradle.png b/docs/android/images/android-studio-import-project-from-gradle.png
new file mode 100644
index 0000000000..2b4aacf171
Binary files /dev/null and b/docs/android/images/android-studio-import-project-from-gradle.png differ
diff --git a/docs/android/images/android-studio-open-existing.png b/docs/android/images/android-studio-open-existing.png
new file mode 100644
index 0000000000..9e5891ef3f
Binary files /dev/null and b/docs/android/images/android-studio-open-existing.png differ
diff --git a/docs/android/index.md b/docs/android/index.md
new file mode 100644
index 0000000000..db67b378d7
--- /dev/null
+++ b/docs/android/index.md
@@ -0,0 +1,88 @@
+# Get Demo
+
+[Download GraphHopper Demo APK](http://graphhopper.com/#download)
+
+# Set-up Development
+
+As starting point you can use [the demo project](https://github.com/graphhopper/graphhopper/tree/master/android) 
+which can be used from Android Studio, NetBeans, gradle or maven.
+
+Before the installation fetch the source, the OpenStreetMap data and the dependencies:
+
+```bash
+$ git clone git://github.com/graphhopper/graphhopper.git graphhopper
+$ cd graphhopper
+$ ./graphhopper.sh import your-area.pbf
+```
+
+## Android Studio
+
+Please read [here](./android-studio-setup.md) for a detailed instruction.
+
+## None-Android Studio
+
+Download the [Android SDK](http://developer.android.com/sdk/installing/index.html?pkg=tools) and 
+go to the Android SDK Manager and install at least 2.3 (API 9).
+
+### Maven or NetBeans
+ 1. Download [Maven SDK Deployer](https://github.com/mosabua/maven-android-sdk-deployer) and execute `mvn install -P 2.3` - it uses [Android Maven Plugin](http://code.google.com/p/maven-android-plugin/wiki/GettingStarted) under the hood where you need to set up ANDROID_HOME
+ 2. Now do `./graphhopper.sh android`
+
+### Gradle
+
+```bash
+$ cd graphhopper/android
+$ ./gradlew clean build
+# push to device, start manually
+$ gradle installDebug
+```
+
+## Maps
+
+Now that you have a running android app you need to copy somehow the routing and maps data. 
+
+ 1. [Download the raw openstreetmap file](http://download.geofabrik.de/openstreetmap/) - you'll need that only for the next step to create the routing data
+ 2. Execute `./graphhopper.sh import <your-osm-file>`. This creates the routing data
+ 3. [Download a map](http://download.mapsforge.org/maps/) e.g. berlin.map
+ 4. Copy berlin.map into the created berlin-gh folder
+ 5. Optional Compression Step: Bundle a graphhopper zip file via `cd berlin-gh; zip -r berlin.ghz *`
+ 6. Now copy the berlin-gh folder from step 4 (or the .ghz file from step 5) to your Android device. /[download-folder]/graphhopper/maps, where the download-folder can e.g. be /mnt/sdcard/download or /storage/sdcard/Download/ - e.g. use [SSHDroid](https://play.google.com/store/apps/details?id=berserker.android.apps.sshdroid): `scp -P 2222 berlin.ghz root@$URL:/mnt/sdcard/download/graphhopper/maps/`
+
+## Limitations
+
+ * You have to create the graphhopper folder on your desktop and copy it to the Android storage.
+
+ * [A memory bound a* algoritm](http://en.wikipedia.org/wiki/SMA*) is not yet implemented so you can use disableShortcuts only for small routes.
+
+## Problems
+
+If you encounter problems like 'trouble writing output: Too many methods: 72332; max is 65536.' or you 
+want to reduce the size of the jar/apk size you can try to apply autojar on trove4j:
+
+```bash
+java -jar autojar-2.1/autojar.jar -o trove4j-stripped.jar -c $TROVE_SRC/target/classes @trove-class.list
+```
+
+where trove-class.list is a file with the required classes for GraphHopper as content:
+
+```text
+gnu.trove.list.TDoubleList.class
+gnu.trove.list.TIntList.class
+gnu.trove.list.array.TDoubleArrayList.class
+gnu.trove.list.array.TIntArrayList.class
+gnu.trove.map.TIntObjectMap.class
+gnu.trove.map.hash.TIntObjectHashMap.class
+gnu.trove.map.hash.TIntIntHashMap.class
+gnu.trove.set.hash.TIntHashSet.class
+gnu.trove.iterator.TIntIterator.class
+gnu.trove.procedure.TIntProcedure.class
+gnu.trove.procedure.TObjectProcedure.class
+gnu.trove.stack.array.TIntArrayStack.class
+```
+
+
+## Example
+
+Routes for areas of up to 500km^2 are calculated in under 5s with the help of Contraction Hierarchies
+
+![simple routing](http://karussell.files.wordpress.com/2012/09/graphhopper-android.png)
\ No newline at end of file
diff --git a/docs/core/ch.md b/docs/core/ch.md
new file mode 100644
index 0000000000..4d55a5c847
--- /dev/null
+++ b/docs/core/ch.md
@@ -0,0 +1,11 @@
+# Contraction Hierarchies
+
+CH is a post-import process which makes routing faster. 
+In GraphHopper CH is enabled by default but can be easily disabled.
+
+To make CH work in GraphHopper a LevelGraphStorage instead of the normal GraphStorage 
+is necessary which allows to store shortcuts too.
+
+A prepared graph can also be used for normal graph traversal IF you use graph.getBaseGraph().
+
+If CH is enabled multiple vehicles will work but only one works in speed-up mode and is faster, see issue #111.
diff --git a/docs/core/create-new-flagencoder.md b/docs/core/create-new-flagencoder.md
new file mode 100644
index 0000000000..ff93ae5036
--- /dev/null
+++ b/docs/core/create-new-flagencoder.md
@@ -0,0 +1,29 @@
+# How to create new routing profile aka a new FlagEncoder?
+
+Copy e.g. a simple FlagEncoder like CarFlagEncoder or extend from it. Then change the toString method to a 
+different desired name.
+
+Make sure that it supports the required speed resolution via calling the appropriate (super) constructor. 
+E.g. speedBits means how many bits should reserved for the speed information, 
+the speedFactor means by which factor the speed should be devided before storing 
+(e.g. 5 for car and 1 for bikes for more precision).
+
+As a third step you need to tune the speeds for the different road types and surfaces. Maybe
+now it is time to write a first test for your new FlagEncoder.
+
+If you need to support two different speed values for one street (one edge) you need to create
+a separate EncodedDoubleValue instance (reverseSpeedEncoder) managing the reverse speed, 
+see Bike2WeightFlagEncoder for an example. You'll have to overwrite the following methods:
+
+ * setReverseSpeed, getReverseSpeed to use the reverseSpeedEncoder
+ * handleSpeed, to handle oneway tags correctly
+ * flagsDefault 
+ * setProperties
+ * reverseFlags
+
+To incorporate or precalculate values based on the elevation data you can hook into applyWayTags
+and call edge.fetchWayGeometry(3) or again, see Bike2WeightFlagEncoder.
+
+If you want to include your FlagEncoder in GraphHopper you have to add the creation in
+EncodingManager.parseEncoderString to let the EncodingManager pick the correct class when faced
+with the string. The convention is that encoder.toString is identical to the string.
\ No newline at end of file
diff --git a/docs/core/eclipse-setup.md b/docs/core/eclipse-setup.md
new file mode 100644
index 0000000000..eb2093e9a2
--- /dev/null
+++ b/docs/core/eclipse-setup.md
@@ -0,0 +1,153 @@
+Getting started with GraphHopper in Eclipse
+=========
+This manual covers step by step instructions on setting up a development and run environment for GraphHopper (web App only) using Eclipse. The instructions and tools used are platform independent and should be applicable for windows, Linux and Mac operating systems. 
+Instructions for Android branch will be provided in future.
+
+The first part of this document covers configuring Eclipse for cloning and importing GraphHopper repository. Setting up Apache Tomcat server and configuring it to run GraphHopper will be covered in subsequent documents.
+
+###1. Download Eclipse
+
+The first step is to download latest version of Eclipse. We recommend that you download the ["Eclipse IDE for Java EE Developers"](http://www.eclipse.org/downloads/) package, instead of the package "for Java developers", as it includes many of the necessary plugins for webapp and API development.  
+
+**Note:** Make sure you grab the correct 32-bit or 64-bit version, depending on your machine and the version of the java installed in your computer. If for example you have a 32 bit java in your x64 machine, you still need to download a 32 bit version of eclipse or you may get an error while trying to open the eclipse.exe file.
+
+**Note:** GraphHopper is set to run with JRE 1.6. This document is written based on setting Eclipse Luna using JRE 1.6.  It may also work with newer versions of JRE, but it has not been tested yet.
+
+
+###2.	Eclipse Addition al Plugins
+Before getting started, you'll need to have a few Eclipse plugins installed to help with development. GraphHopper is versioned using Git and its build process and dependencies are managed by Maven, so certain additional Eclipse components will be needed to tie everything together:
+
+*	A git plugin, a popular choice is [EGit](http://eclipse.org/egit/) which is an "Eclipse team provider" (i.e. version control system plugin) for Git.
+*	The Eclipse Maven plugin, [m2eclipse](http://www.eclipse.org/m2e/) which adds Maven support to Eclipse, for editing project models and (automatically) running builds
+*	If you want to work on the web interfaces you also need [Web Tools Platform (WTP)](http://www.eclipse.org/webtools/)
+
+**Note**: EGit, WTP, and m2eclipse (as of version 1.0) are hosted by the [Eclipse foundation](http://www.eclipse.org/org/), and they are bundled with some packages of Eclipse.
+
+###3.	Configuring Eclipse with additional plugins
+Depending on the Eclipse package you chose, you may need to install one or more of the Eclipse components mentioned previously. You should be able to add all the needed components using either the "Install new software" dialog or the "Eclipse marketplace" component available under Eclipse's help menu. 
+
+####3.1. Using Eclipse Marketplace
+The Eclipse Marketplace seems to do a good job with EGit, m2eclipse (also referred to as m2e or "Maven Integration for Eclipse"), and m2e-wtp ("Maven Integration for Eclipse WTP").
+
+You should take the below steps to install your needed components:
+
+* In Eclipse, under _help_ menu, choose _Eclipse Marketplace_. 
+
+* In the opened window, search all _markets/all categories_ and in the _find_ dialoge box type the name of the needed component and click on _Go_ button:
+
+ * Search for “egit” if you need “EGIT” and “EGit – Git Team Provider” should be among first items to appear.
+ 
+ * Search for “maven” or “m2eclipse” if you need “m2eclipse” and “m2eclipse – "Maven Integration for Eclipse” should be among first items to appear. 
+   
+ * Search for “wtp” if you need “m2e-wtp” and “m2eclipse – "Maven Integration for Eclipse WTP” should be among first items to appear. 
+
+*   Click on _Install_ button. Please note if the component is already installed then there are two other buttons available instead of _Install_. _Update_ if there is an update for the component and _Uninstall_. For example in picture below the user has tried to install EGit using market place, while it has already been included in the package. 
+
+![](./images/egit.png)
+
+*	The Web Tools components can in fact be installed via the Eclipse Marketplace system, but they will not be found in a search unless you switch to the "EclipseSource Yoxos Marketplace" instead of the "Eclipse marketplace". This is accomplished by clicking on the Orange circle icon next to the purple Eclipse icon at the bottom of the Marketplace dialog box. 
+
+
+####3.2. Using “Install New Software…” Option
+Alternatively, you can use the “Install New Software” option under the _help_ menu to install the needed components. Also if you do happen to miss some web development components try “Install New Software Option” instead of the “Marketplace”. 
+
+Based on needed components take the below steps:
+ 
+*	To install “EGit” in the "Work with:" dialog box, type the EGit server address  at http://download.eclipse.org/egit/updates. Select Eclipse Git Team Provider and JGit form option and click _Next_ and _Finish_ install.
+ 
+![](./images/egit2.png)  
+
+*	To install “m2e” In the "Work with:" dialog box, type the me2eclipse server address at http://download.eclipse.org/technology/m2e/releases. Select Maven Integration for Eclipse form option and click _Next_ and _Finish_ install. 
+
+![](./images/maven.png) 
+
+*	Also if you do happen to miss some web development components,   in the "Work with:" dialog box, type your eclipse server version (e.g. luna) address at http://download.eclipse.org/releases/luna and try  checking the "Web, XML, Java EE, and OSGi Enterprise Development" category, which should include everything you need.  
+
+
+###4.	Clone and import the GraphHopper Source
+At this step you need to clone the GraphHopper GitHub repository locally (get a copy of the GraphHopper source code). Repository cloning can be done using one of the below approaches:
+
+1. EGit Repositories View from within Eclipse
+
+2. Command-line Git tools. Once they are cloned into the local filesystem, the Maven projects in the GraphHopper Git repository can then be imported into Eclipse. 
+
+3. The clone and import operations can be done together using _File -> Import -> Maven -> Import Maven projects from SCM in Eclipse_.
+ 
+**Note:** When the initial clone operation is not done using the clone button in the EGit Repositories View (For example if it is done using command-line Git or "Import Maven projects from SCM"), you  need to inform Eclipse that your project is under Git version control if you want to do pull / push / commit operations from within Eclipse. In any case you can just perform these operations using command-line Git tools.
+
+**Note:**  It is suggested that repositories should be cloned somewhere outside your Eclipse workspace to avoid any misinterpretation or misuse of Git metadata by Eclipse and vice-versa. 
+
+Below we talk more about the first and third approaches of cloning.
+
+
+####4.1. Approach 1: Clone the GraphHopper repository with the EGit Repositories View
+
+* Switch to the "Git Repository Exploring" perspective in Eclipse by selecting:  _Window -> Open Perspective -> Git Repositories_ .
+If you don't see this option under "Open Perspective", choose:  _Window -> Open Perspective -> Other..._ and select "Git Repository Exploring". 
+
+![](./images/clone1.png)
+
+The "Repository Exploring perspective" is preconfigured to contain the Git Repositories view. Alternatively, you can add the Git Repositories view to your main Java perspective: _Window -> Show View -> Other -> Git Repositories_. 
+
+* In the Git Repositories view, click on the "Clone a Git Repository and add clone to this view" button as shown below:
+
+![](./images/clone2.png)
+
+* Enter https://github.com/graphhopper/graphhopper/ for the URI, select "HTTPS" for the protocol. Entering the GitHub username and password is not necessary for cloning the repository. However, if you want to contribute edits back, you'll need to enter your GitHub username and password here too.
+
+![](./images/clone3.png)
+
+* Click _Next_, then select all branches (the “master” branch is probably what need).
+
+* Click _Next_, then select the directory where you want the code to be checked out to. Then click _Finish_. It will take Eclipse a minute or two to download the source to your computer, and then the GraphHopper repository should appear in the "Git Repositories" panel. 
+
+**Note:** An alternate and easy way to this approach is to manually download the GraphHopper zip file directly from GitHub and save it in a local drive in your machine.
+
+**Note:** You still need to import the GraphHopper Maven projects from the local clone of the repository into Eclipse (see Importing existing GraphHopper Maven projects into Eclipse part).
+
+
+
+####4.2. Importing existing GraphHopper Maven projects into Eclipse
+
+If you used approach 1 or if you have downloaded the GraphHopper zip file directly form GitHub, you have cloned the GraphHopper repository but the GraphHopper Maven projects are not yet visible in Eclipse. To make the projects visible,cover the below steps:
+
+* Choose the menu option _File -> Import, and then browse to the Maven / Existing Maven Projects element_.
+
+![](./images/import1.png)
+
+* Browse to the local directory where you cloned the GraphHopper Git repository, and then select all the projects of interest.
+
+![](./images/import2.png)
+
+* Click _Finish_. It may take a while to initially build all the projects in your workspace. In the background, the Maven plugin is downloading all the project dependencies. If everything works fine you should be able to see each GraphHopper maven module checked out as an individual Eclipse project in your workspace.
+
+####4.3. Approach 2: Clone the GraphHopper repository and import Maven projects all at once
+To use this method follow the below steps:
+* In Eclipse, choose _File -> Import..._ then choose _Maven / Check out Maven projects from SCM_ in the dialog box, as shown below:
+
+![](./images/clone4.png)
+
+* Click _Next_, then confirm that you are using the Git version control sytstem using the dropdown box next to the label "SCM URL". 
+
+**Note:** The first time you use this option, this "git" option will probably not be available because an m2e/git connector must be installed. Use the blue "m2e marketplace" link in the lower right corner of this dialog box to find and install the m2e Maven SCM handler for Egit,  and the 'git' option should become available in the drop-down box.
+
+* specify the "Target Location" (in this case, the URL of the remote Github repository that you want to clone locally), as shown in below figure. This URL should be https://github.com/graphhopper/graphhopper/
+
+![](./images/clone5.png)
+
+* Click _Next_, then uncheck "Use default workspace location" and specify a directory outside your Eclipse workspace (e.g. ~/git). Your cloned copy of the repository will be placed in a subdirectory of the specified directory, with a rather uninformative name (e.g. ~/git/ maven.1424033308371).
+
+* Click _Finish_, and m2eclipse should both clone the repository and import the Maven projects into your workspace. The Graphhopper top-level maven module, as well as all the other sub-modules, should then appear in your project explorer view. 
+
+####4.4 Making Eclipse aware of your local GraphHopper Git repository
+
+If you use approach 2 or a command-line method, EGit will not be aware of the Git metadata in the new local repository. Therefore operations on the local Git repository will not automatically be possible from within Eclipse.You can choose to do all Git operations on the command line, or make EGit aware of the repository as follows: 
+
+*	Right-click the top-level GraphHopper project in the Project Explorer view and choose _Team -> Share Project_.
+
+*	Specify Git as the repository type and check Use or create repository in parent folder of project on the next page. The .git metadata directory should be found and indicated in the dialog box. At this point you can click the _Finish_ button. An orange cylinder should appear on the GraphHopper folder icon in the "Package Explorer", indicating that it is under version control.
+
+Now, you should be able to open the Git repositories view: _Window -> Show View -> Other -> Git Repositories_, and do push, pull, and commit operations in Eclipse. The advantage of this method over the command line is using EGit's graphical diff window which allows you to review changes and select files to commit.
+
+
+
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
new file mode 100644
index 0000000000..d973969aa5
--- /dev/null
+++ b/docs/core/elevation.md
@@ -0,0 +1,40 @@
+# Elevation
+
+Per default elevation is disabled. But you can easily enable it:
+`graph.elevation.provider=cgiar`
+or
+`graph.elevation.provider=srtm`
+
+then GraphHopper will automatically download the necessary data for the area and include elevation 
+for all vehicles - making also the distances a bit more precise. 
+
+The default cache directory (/tmp/srtm) will be used. For large areas it is highly recommended to 
+use a SSD disc, thus you need to specify the cache directory:
+`graph.elevation.cachedir=/myssd/ele_cache/`
+
+## What to download and where to store it? 
+
+All should work automatically. Another setting is to specify the location where the files are 
+downloaded - e.g. if the servers are not reachable, then you set:
+`graph.elevation.baseurl`
+
+E.g. for CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
+`http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/`
+where the last one is only accessibly if you specify the 
+[full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
+
+If the area is small and you need a faster import you can change the default MMAP setting to:
+`graph.elevation.dataaccess=RAM_STORE`
+
+## CGIAR vs. SRTM
+
+The CGIAR data is preferred because of the quality but is in general not public domain. 
+But we got a license for our and our users' usage: https://graphhopper.com/public/license/CGIAR.txt
+
+Using SRTM instead CGIAR has the minor advantage of a faster download, especially for smaller areas.
+
+## Custom Elevation Data
+
+Integrating your own elevation data is easy and just requires you to implement the
+ElevationProvider interface and then specify it via GraphHopper.setElevationProvider.
+Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
\ No newline at end of file
diff --git a/docs/core/images/clone1.png b/docs/core/images/clone1.png
new file mode 100644
index 0000000000..b05ec6fc9f
Binary files /dev/null and b/docs/core/images/clone1.png differ
diff --git a/docs/core/images/clone2.png b/docs/core/images/clone2.png
new file mode 100644
index 0000000000..7a8297f4a1
Binary files /dev/null and b/docs/core/images/clone2.png differ
diff --git a/docs/core/images/clone3.png b/docs/core/images/clone3.png
new file mode 100644
index 0000000000..d5a76bfe93
Binary files /dev/null and b/docs/core/images/clone3.png differ
diff --git a/docs/core/images/clone4.png b/docs/core/images/clone4.png
new file mode 100644
index 0000000000..b89d2a0ee3
Binary files /dev/null and b/docs/core/images/clone4.png differ
diff --git a/docs/core/images/clone5.png b/docs/core/images/clone5.png
new file mode 100644
index 0000000000..abef84335e
Binary files /dev/null and b/docs/core/images/clone5.png differ
diff --git a/docs/core/images/egit.png b/docs/core/images/egit.png
new file mode 100644
index 0000000000..b7b9ab7a61
Binary files /dev/null and b/docs/core/images/egit.png differ
diff --git a/docs/core/images/egit2.png b/docs/core/images/egit2.png
new file mode 100644
index 0000000000..1fad659389
Binary files /dev/null and b/docs/core/images/egit2.png differ
diff --git a/docs/core/images/import1.png b/docs/core/images/import1.png
new file mode 100644
index 0000000000..76c746f7ba
Binary files /dev/null and b/docs/core/images/import1.png differ
diff --git a/docs/core/images/import2.png b/docs/core/images/import2.png
new file mode 100644
index 0000000000..a384664bb6
Binary files /dev/null and b/docs/core/images/import2.png differ
diff --git a/docs/core/images/maven.png b/docs/core/images/maven.png
new file mode 100644
index 0000000000..2177c5296f
Binary files /dev/null and b/docs/core/images/maven.png differ
diff --git a/docs/core/location-index.md b/docs/core/location-index.md
new file mode 100644
index 0000000000..69a18b839a
--- /dev/null
+++ b/docs/core/location-index.md
@@ -0,0 +1,23 @@
+You get the location index from the GraphHopper instance, after you imported or loaded the data:
+
+```java
+GraphHopper hopper = new GraphHopper();
+hopper.set...
+hopper.importOrLoad();
+
+LocationIndex index = hopper.getLocationIndex();
+
+//  now you can fetch the closest edge via:
+QueryResult qr = findClosest(lat, lon, EdgeFilter.ALL_EDGES );
+EdgeIteratorState edge = qr.getClosestEdge();
+```
+
+If you don't use the GraphHopper class you have to use the low level API:
+
+```java
+LocationIndexTree index = new LocationIndexTree(graph.getBaseGraph(), dir);
+index.setResolution(preciseIndexResolution);
+index.setMaxRegionSearch(maxRegionSearch);
+if (!index.loadExisting())
+    index.prepareIndex();
+```
\ No newline at end of file
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
new file mode 100644
index 0000000000..a054535cc8
--- /dev/null
+++ b/docs/core/low-level-api.md
@@ -0,0 +1,106 @@
+## Low level API
+
+If you just start to use GraphHopper please refer to [routing docs](./routing.md)
+or [the quickstart for developers](./quickstart-from-source.md)
+and come back here later if the higher level API does not suit your needs.
+
+### What are pillar and tower nodes?
+
+From road network sources like OpenStreetMap we fetch all nodes and create the routing graph but 
+only a sub-set of them are actual junctions, which are the ones we are interested in while routing.
+
+Those junction nodes (and end-standing nodes of dead alleys) we call *tower nodes* which also 
+have a graphhopper node ID associated, going from 0 to graph.getNodes(). 
+The helper nodes between the junctions we call 'pillar nodes' which can be fetched via
+`edgeIteratorState.fetchWayGeometry(0)`. Avoiding the traversal of pillar nodes while routing makes 
+routing a lot faster (~8 times).
+
+That splitting into pillar and tower nodes is also the reason why there can't be a unique mapping from 
+one OSM node ID to exactly one GraphHopper node ID. And as one OSM Way is often splitted into multiple 
+edges the same applies for edge IDs too.
+
+### Create and save the graph
+
+```java
+FlagEncoder encoder = new CarFlagEncoder();
+EncodingManager em = new EncodingManager(encoder);
+GraphBuilder gb = new GraphBuilder(em).setLocation("graphhopper-folder").setStore(true);
+GraphStorage graph = gb.create();
+// Make a weighted edge between two nodes.
+EdgeIteratorState edge = graph.edge(fromId, toId);
+edge.setDistance(distance);
+edge.setFlags(encoder.setProperties(speed, true, true));
+// Store to disc
+graph.flush();
+```
+
+### Load the graph
+
+```java
+...
+GraphStorage graph = gb.load();
+// Load index
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
+if (!index.loadExisting())
+    throw new IllegalStateException("location index cannot be loaded!");
+```
+
+### Calculate Path with LocationIndex
+
+```java
+QueryResult fromQR = index.findClosest(latitudeFrom, longituteFrom, EdgeFilter.ALL_EDGES);
+QueryResult toQR = index.findID(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
+QueryGraph queryGraph = new QueryGraph(graph);
+queryGraph.lookup(fromQR, toQR);
+Path path = new Dijkstra(queryGraph, encoder).calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
+```
+
+### Calculate Path without LocationIndex
+
+```java
+// get the fromId and toId nodes from other code parts
+Path path = new Dijkstra(graph, encoder).calcPath(fromId, toId);
+```
+
+### Use LevelGraph to make queries faster
+
+```java
+// Creating and saving the graph
+GraphBuilder gb = new GraphBuilder(em).
+    setLocation("graphhopper-folder").
+    setStore(true).
+    setLevelGraph(true);
+GraphStorage graph = gb.create();
+// Create a new edge between two nodes, set access, distance, speed, geometry, ..
+EdgeIteratorState edge = graph.edge(fromId, toId);
+...
+
+// Prepare the graph for fast querying ...
+TraversalMode tMode = TraversalMode.NODE_BASED;
+PrepareContractionHierarchies pch = new PrepareContractionHierarchies(graph, encoder, weighting, tMode);
+pch.doWork();
+
+// flush after preparation!
+graph.flush();
+
+// Load and use the graph
+GraphStorage graph = gb.load();
+
+ // Load index
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
+if (!index.loadExisting())
+    throw new IllegalStateException("location2id index cannot be loaded!");
+
+// calculate path is identical
+QueryResult fromQR = index.findClosest(latitudeFrom, longituteFrom, EdgeFilter.ALL_EDGES);
+QueryResult toQR = index.findID(latitudeTo, longituteTo, EdgeFilter.ALL_EDGES);
+QueryGraph queryGraph = new QueryGraph(graph);
+queryGraph.lookup(fromQR, toQR);
+
+// create the algorithm using the PrepareContractionHierarchies object
+AlgorithmOptions algoOpts = AlgorithmOptions.start().
+   algorithm(AlgorithmOptions.DIJKSTRA_BI).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+   build();
+RoutingAlgorithm algorithm = pch.createAlgo(queryGraph, algoOpts);
+Path path = algorithm.calcPath(fromQR.getClosestNode(), toQR.getClosestNode());
+```
\ No newline at end of file
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
new file mode 100644
index 0000000000..f6cab16714
--- /dev/null
+++ b/docs/core/quickstart-from-source.md
@@ -0,0 +1,131 @@
+# GraphHopper - Quick Start Guide for Developers
+
+## Try out
+
+For a start which requires only the JRE have a look [here](../web/quickstart.md). 
+Windows user can find a quick guide [here](./windows-setup.md). 
+
+Now, before you proceed install git and jdk6, 7 or 8. Then do:
+
+```bash
+$ git clone git://github.com/graphhopper/graphhopper.git
+$ cd graphhopper; git checkout master
+$ ./graphhopper.sh web europe_germany_berlin.pbf
+now go to http://localhost:8989/
+```
+
+  1. These steps make the Berlin area routable. It'll download and unzip the osm file for you.
+  2. It builds the graphhopper jars. If Maven is not available it will automatically download it.
+  3. Then it creates routable files for graphhopper in the folder europe_germany_berlin-gh. It'll skip this step if files are already present.
+  4. Also check the instructions for [Android](../android/index.md)
+
+For you favourite area do
+
+```bash
+$ ./graphhopper.sh web europe_france.pbf
+$ ./graphhopper.sh web north-america_us_new-york.pbf
+# the format follows the link structure at http://download.geofabrik.de
+```
+
+## Start Development
+
+Open the project with NetBeans or enable Maven in your IDE. 
+[Maven](http://maven.apache.org/download.cgi) is downloaded to ```graphhopper/maven``` if not 
+installed when executing graphhopper.sh.
+
+### Java, Embedded Usage
+
+Have a look into the [Java API documentation](./) for further details e.g. how [GraphHopper can
+be embedded](./routing.md) into your application and like a [custom weighting](./weighting.md) 
+can be implemented.
+
+Look [here](http://graphhopper.com/#community) for the maven snippet to use GraphHopper in your
+application. To use an unreleased snapshot version of GraphHopper you need the following snippet in your pom.xml
+as those versions are not in maven central:
+
+```xml
+    <repositories>
+        <repository>
+            <id>sonatype-oss-public</id>
+            <url>https://oss.sonatype.org/content/groups/public/</url>
+            <releases>
+                <enabled>true</enabled>
+            </releases>
+            <snapshots>
+                <enabled>true</enabled>
+            </snapshots>
+        </repository>
+    </repositories>
+```
+
+### Java, Routing Server Usage
+
+The Web API documentation is [here](../web). 
+We provide Java client code [here](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java#L43)
+to query the routing server.
+
+The routing API (json,jsonp,gpx) is optimized regarding several aspects:
+ * It tries to return a smallish data set (encoded polyline, gzip filter)
+ * It enables cross-site scripting on the server- and client-site
+ * The JavaScript client utilizes the jquery Deferred object to chain ajax requests and avoids browser UI blocking when resolving locations in parallel.
+
+#### Routing Service Deployment
+
+For simplicity you could just start jetty from maven and schedule it as background job: 
+`export GH_FOREGROUND=false && export JETTY_PORT=11111 && ./graphhopper.sh web europe_germany_berlin.pbf`. 
+Then the service will be accessible on port 11111.
+
+For production usage you can install the latest jetty (8 or 9) as a service but we prefer to have it bundled as a 
+simple jar. Tomcat should work too. To create a war file do `mvn clean install war:war` and copy it from the target/ 
+folder to your jetty installation. Then copy web/config.properties also there and change this properties 
+file to point to the required graphhopper folder. Increase the Xmx/Xms values of your jetty server e.g. 
+for world wide coverage with a hierarchical graph I do the following in bin/jetty.sh
+```bash
+export JAVA=java-home/bin/java
+export JAVA_OPTIONS="-server -Xconcurrentio -Xmx17000m -Xms17000m"
+```
+
+For [World-Wide-Road-Network](./world-wide.md) we have a separate information page.
+
+Important notes:
+ * jsonp support needs to be enabled in the config.properties
+ * none-hierarchical graphs should be limited to a certain distance otherwise you'll require lots of RAM per request! See [#104](https://github.com/graphhopper/graphhopper/issues/104)
+ * if you have strange speed problems which could be related to low memory you can try to [entire disable swap](http://askubuntu.com/questions/103915/how-do-i-configure-swappiness). Or just try it out via `sudo swapoff -a`. Swapping out is very harmful to Java programs especially when the GC kicks in.
+
+### JavaScript Usage
+
+For an example of how to use graphhopper in a web application see the 
+[web subfolder](https://github.com/graphhopper/graphhopper/tree/master/web)
+
+The routing server can be queried from [JavaScript](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/webapp/js/ghrequest.js)
+as well. You can see this in action at [GraphHopper Maps](https://graphhopper.com/maps/).
+
+If you need **offline** routing in the browser like for smaller areas or hybrid routing solution
+then there is a highly experimental version of GraphHopper using TeaVM. 
+Have a look into this [blog post](http://karussell.wordpress.com/2014/05/04/graphhopper-in-the-browser-teavm-makes-offline-routing-via-openstreetmap-possible-in-javascript/) 
+for a demo and more information.
+
+### Android Usage
+ 
+For details on Android-usage have a look into this [Android site](../android/index.md) or at the
+[Android example](https://github.com/graphhopper/graphhopper/tree/master/android)
+
+### Swing and Desktop Usage
+
+You can use graphhopper on the Desktop with the help of the latest mapsforge swing library too. No example code
+yet but with the Android example combined with the Desktop example of the mapsforge project it should not be
+that hard.
+
+For smallish graph (e.g. size of Berlin) use a RAMDataAccess driven GraphStorage (loads all into memory).
+For larger ones use the ContractionHierarchies preparation class and MMapDataAccess to avoid OutOfMemoryErrors. 
+
+Raspberry Pi usage is also possible. Have a look into this [blog post](https://karussell.wordpress.com/2014/01/09/road-routing-on-raspberry-pi-with-graphhopper/).
+
+## Technical Details
+
+Have a look in the more [technical documentation](./technical.md) or the [low level API](./low-level-api.md).
+
+Further Links
+---------------
+ * [Spatial Key](http://karussell.wordpress.com/2012/05/23/spatial-keys-memory-efficient-geohashes/)
+ * [Author@Twitter](https://twitter.com/timetabling)
diff --git a/docs/core/routing.md b/docs/core/routing.md
new file mode 100644
index 0000000000..ae1fd60d9d
--- /dev/null
+++ b/docs/core/routing.md
@@ -0,0 +1,82 @@
+To do routing in your Java code you'll need just a few lines of code:
+
+```java
+GraphHopper hopper = new GraphHopper().forServer();
+hopper.setInMemory(true);
+hopper.setOSMFile(osmFile);
+// where to store graphhopper files?
+hopper.setGraphHopperLocation(graphFolder);
+hopper.setEncodingManager(new EncodingManager("car"));
+
+// now this can take minutes if it imports or a few seconds for loading
+// of course this is dependent on the area you import
+hopper.importOrLoad();
+
+// simple configuration of the request object, see the GraphHopperServlet classs for more possibilities.
+GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
+    setWeighting("fastest").
+    setVehicle("car");
+GHResponse rsp = hopper.route(req);
+
+// first check for errors
+if(rsp.hasErrors()) {
+   // handle them!
+   // rsp.getErrors()
+   return;
+}
+
+// route was found? e.g. if disconnected areas (like island) 
+// no route can ever be found
+if(!rsp.isFound()) {
+   // handle properly
+   return;
+}
+
+// points, distance in meters and time in millis of the full path
+PointList pointList = rsp.getPoints();
+double distance = rsp.getDistance();
+long millis = rsp.getMillis();
+
+// get the turn instructions for the path
+InstructionList il = rsp.getInstructions();
+Translation tr = trMap.getWithFallBack(Locale.US);
+List<String> iList = il.createDescription(tr);
+
+// or get the result as gpx entries:
+List<GPXEntry> list = il.createGPXList();
+```
+
+The default is to use the speed-up mode for one profile. If you need multiple profiles you 
+specify a list of profiles (e.g. car,bike) and the speed-up mode is applied to the first profile only (e.g. car).
+The other vehicles then use a more flexible routing.
+
+You can also completely disable the speed-up mode to make all vehicles using the flexibility mode.
+Then pick one vehicle and optionally the algorithm like 'bidirectional astar' as algorithm:
+
+```java
+GraphHopper hopper = new GraphHopper().forServer();
+hopper.disableCHShortcuts();
+hopper.setInMemory(true);
+hopper.setOSMFile(osmFile);
+hopper.setGraphHopperLocation(graphFolder);
+hopper.setEncodingManager(new EncodingManager("car,bike"));
+
+hopper.importOrLoad();
+
+GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
+    setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR_BI);
+GHResponse res = hopper.route(req);
+```
+
+In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
+ see the 'web' sub module.
+
+```java
+GraphHopperAPI gh = new GraphHopperWeb();
+gh.load("http://your-graphhopper-service.com");
+
+// or for the GraphHopper Directions API https://graphhopper.com/#directions-api
+// gh.load("https://graphhopper.com/api/1/route");
+
+GHResponse rsp = gh.route(new GHRequest(...));
+```
\ No newline at end of file
diff --git a/docs/core/technical.md b/docs/core/technical.md
new file mode 100644
index 0000000000..4b45a58200
--- /dev/null
+++ b/docs/core/technical.md
@@ -0,0 +1,83 @@
+## Technical Overview of GraphHopper
+
+To get a better understanding also take a look in the source code, especially in the unit tests and in 
+some resources we [published](http://karussell.wordpress.com/2014/01/23/graphhopper-news-article-in-java-magazine-and-fosdem-2014/)
+or [here](http://graphhopper.com/public/slides/).
+
+There are mainly three parts:
+
+### 1. Data Import
+
+The default import is done via OSMReader which imports OpenStreetMap data. You can configure it via API 
+or use the graphhopper.sh script which utilizes the config.properties where you can specify if it should 
+read CAR, FOOT etc or all at once. You'll have to make sure that you allocate enough memory for your 
+specific graph (E.g. ~1GB for Germany) e.g. `export JAVA_OPTS="-Xmx1g"`. The import process is fast e.g. 
+complete germany takes about 10 minutes on my oldish laptop. Additionally it will take time if you choose 
+prepare.chWeighting=fastest in the config.properties which will dramatically improve query time
+but requires more RAM on import.
+
+### 2. The Graph
+
+To process algorithms you need a _Graph_. At the moment there is one main implementation GraphHopperStorage 
+which can be used: 
+  * in-memory with a safe/flush option (RAMDataAccess) and 
+  * a memory mapped (MMapDataAccess).
+
+The interface _Graph_ is developed in the sense that the implementation can be as much efficient as possible
+ - i.e. node ids and edge ids are successive (and so are just _indices_) and in the range of 0 to MAX-1. 
+This design could be used to have an array-like structure in the underlying DataAccess implementation like 
+it is currently the case.
+
+The data layout for the DataAccess objects in GraphHopperStorage called 'nodes' and 'edges' is the following:
+
+![storage layout](http://karussell.files.wordpress.com/2013/08/wiki-graph.png)
+
+Some explanations:
+ * One 'node row' consists of latitude,longitude (not shown) and the first edgeID
+ * One 'edge row' consists of two edgeIDs: nextA and nextB, then two nodeIDs nodeA and nodeB, and finally some properties like the distance and the flags.
+ * One node has several edges which is implemented as a linked list. E.g. node 3 points to its first edge in the edge area at position 0 to edge 0-3 (nodeA-nodeB where nodeA is always smaller than nodeB). To get the next edge of node 3 you need nextB and this goes to edge 1-3, again node 3 is nodeB, but for the next edge 3-5 node 3 is nodeA ... and so on.
+ * For you custom data import keep in mind that although the nodes 4 and 6 have no edges they still 'exist' and consume space in the current implementations of DataAccess. For OSMReader this cannot be the case as separate networks with only a small number of nodes are removed (very likely OSM bugs).
+
+For some algorithms there are special implementations of the Graph. E.g. there is a LevelGraphStorage which is a Graph with the possibility to store shortcut edges and a level for every node. This special storage is necessary for _Contraction Hierarchies_. For this the graph needs also some preprocessing (which can take several hours for bigger areas like Europe) which is done in the OSMReader when configured (prepare.chWeighting=fastest) or via API in PrepareContractionHierarchies. In order to use the shortcuts and get the benefits of the optimized graph you must use the algorithm returned from createAlgo() in the preparation class.
+
+A LevelGraphStorage (and all subclasses of GraphStorage) cannot read files created with GraphStorage and vice versa. Also there is a file version which is changed if the data structure of GraphHopper gets incompatible to the previous versions.
+
+### 3. The Algorithms
+
+In the routing package you'll find some shortest path algorithms like Dijkstra or A* etc. For those 
+algorithms you need a _Graph_.
+
+An algorithm needs a kind of path extraction: from the shortest-path-tree one needs to determine the route 
+(list of edges) including the distance and time. Afterwards from this list the exact point (latitude,longitude) 
+can be determined. For bidirectional algorithms this is a bit more complicated and done in PathBidirRef. 
+For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teaching/EfficientRoutePlanningSS2012)
+ we use the _LevelGraph_ which additionally holds shortcuts. While path extraction we need to identify those
+ shortcuts and get the edges recursivly, this is done in Path4CH.
+
+## 3.1 Base Graph
+
+In order to traverse the _LevelGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
+is done automatically for you if you call graph.getBaseGraph(). This is necessary in a 
+_LocationIndex_ and in the _Path_ class in order to identify how many streets leave a junction
+or similar. See issue #116 for more information.
+
+
+### 4. Connecting the Real World to the Graph
+
+## 4.1 LocationIndex
+
+In real world we have addresses and/or coordinates for the start and end point. 
+To get the coordinate from an address you will need a geocoding solution not part of GraphHopper,
+e.g. have a look into our [Routing Web API](http://graphhopper.com/#enterprise) for more information about this topic.
+
+To get the closest node or edge id from a coordinate we provide you with an efficient lookup concept:
+the LocationIndex. There are multiple implementations
+where the LocationIndexTree is the most precise and scalable one and used in almost all places.
+See [here](./location-index.md) for more information. See #17 and #221.
+
+
+## 4.2 QueryGraph
+
+In order to route not only from junctions (which are nodes) we introduced the _QueryGraph_ in issue #27,
+which creates virtual nodes and edges at the query coordinates. It provides a lightweight wrapper around
+the _Graph_ and is created per query so that queries do not influence each other.
diff --git a/docs/core/translations.md b/docs/core/translations.md
new file mode 100644
index 0000000000..4f7d6eb502
--- /dev/null
+++ b/docs/core/translations.md
@@ -0,0 +1,40 @@
+# Translation
+
+You can help improve GraphHopper by adding your language!
+
+See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
+and add a column for your language. Revisit it regularly to update or add new items. And see your language live at GraphHopper Maps e.g. explicitely specify the locale via:
+
+[https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de](https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de) 
+
+de -> German, en -> Englisch, zh -> Simplified Chinese, ...
+
+## Questions
+
+ 1. **What does the string after the language name mean ala 'Spanish: es'?**
+    This is the language its ISO code (639-1) with two characters. E.g. look up your language on wikipedia to get this code. 
+    See [Spanish](http://en.wikipedia.org/wiki/Spanish_language) as an example again.
+ 2. **What does the strange characters ala '%1$s' in the items means?**
+    This is a placeholder which is filled by GraphHopper. It is important to have as in some languages the position
+    is different than in other languages or the translation is completely different. 
+    Example: "Enter roundabout and use exit %1$s". In German language you have to add the word 'nehmen' after the
+    exit-number parameter: "In den Kreisverkehr einfahren und Ausfahrt %1$s nehmen". 
+    It is very important that you do not forget about these parameter placeholders, please ask if you are unsure.
+
+## Integrate into GraphHopper
+
+We'll regularly update GraphHopper with new translations or fixes so no need to do this work for you. But if you still
+want to try your changes or want to speed up the integration you can do the following:
+
+ * Make GraphHopper working on your computer, where you need to git clone the repository - see [here](./quickstart-from-source.md) for more information.
+ * If you created a new language then add it in lexicographical order to TranslationMap.LOCALES (core/src/main/java/com/graphhopper/util) and to the script: core/files/update-translations.sh
+ * Do `cd graphhopper/core; curl "https://docs.google.com/spreadsheet/pub?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc&single=true&gid=0&output=txt" > tmp.tsv`
+ * Then `./files/update-translations.sh tmp.tsv && rm tmp.tsv`
+ * Now you can see your changes via `git diff`. Make sure that is the only one with `git status`
+ * Now execute `mvn clean test` to see if you did not miss arguments in your translation (see point 2 in the questions above)
+ * You can start a simple GraphHopper instance via './graphhopper.sh web europe_germany_berlin.pbf' and go to localhost:8989 append e.g. &locale=de if your translation does not show up automatically
+ * Read the [contributing guide](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md) to submit your changes
+
+## License Agreement
+
+Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
diff --git a/docs/core/weighting.md b/docs/core/weighting.md
new file mode 100644
index 0000000000..0cfe351f42
--- /dev/null
+++ b/docs/core/weighting.md
@@ -0,0 +1,74 @@
+## Weighting
+
+In order to create a custom Weighting you need to do the following:
+
+ 1. implement the Weighting class
+ 2. create a subclass of GraphHopper and overwrite createWeighting where you return a new instance of your custom weighting if e.g. the string 'customweighting' is specified. Otherwise let the super class handle it.
+
+Here is an example of a custom weighting which avoids certain edges (i.e. returns infinity weight):
+
+```java
+
+class BlockingWeighting implements Weighting 
+{
+    private final FlagEncoder encoder;
+    private final double maxSpeed;
+    private Set<Integer> forbiddenEdges;
+
+    public BlockingWeighting( FlagEncoder encoder, Set<Integer> forbiddenEdges)
+    {
+        this.encoder = encoder;
+        this.maxSpeed = encoder.getMaxSpeed();
+        this.forbiddenEdges = forbiddenEdges;
+    }
+
+    @Override
+    public double getMinWeight( double distance )
+    {
+        return distance / maxSpeed;
+    }
+
+    @Override
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+    {
+        if(forbiddenEdges.contains(edge.getEdge()))
+            return Double.POSITIVE_INFINITY;
+
+        double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
+        if (speed == 0)
+            return Double.POSITIVE_INFINITY;
+        return edge.getDistance() / speed;
+    }
+
+    @Override
+    public String toString()
+    {
+        return "BLOCKING";
+    }
+}
+```
+
+Now you need to create your custom GraphHopper:
+
+```java
+class MyGraphHopper extends GraphHopper {
+
+    Set<Integer> forbiddenEdges;
+    public void determineForbiddenEdges() {
+       forbiddenEdges = ...
+    }
+
+    @Override
+    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )
+    {
+        String weighting = wMap.getWeighting();
+        if ("BLOCKING".equalsIgnoreCase(weighting))
+            return new BlockingWeighting(encoder, forbiddenEdges);
+        else
+            return super.createWeighting(weighting, encoder);
+    }
+}
+```
+
+For forbiddenEdges you need to determine the edges from some GPS coordinates. 
+Have a look into the [location index docs](./location-index.md).
diff --git a/docs/core/windows-setup.md b/docs/core/windows-setup.md
new file mode 100644
index 0000000000..0686ac25a8
--- /dev/null
+++ b/docs/core/windows-setup.md
@@ -0,0 +1,27 @@
+# Windows Setup from Source
+
+Download [cygwin](http://www.cygwin.com/) to execute bash scripts. Click on the setup and select wget, git and unzip
+
+```bash
+# go to your development area
+$ cd /cygdrive/c/Dokumente und Einstellungen/peter/dev
+
+# get the sources
+$ git clone https://github.com/graphhopper/graphhopper.git
+
+# go into graphhopper root
+$ cd graphhopper
+
+# and execute
+$ ./graphhopper.sh web europe_germany_berlin.osm
+```
+
+Now graphhopper web should start. After this open [http://localhost:8989/](http://localhost:8989/) in your browser.
+
+### Troubleshooting
+ * Make sure you have the JDK installed (6,7 or 8) and not only the JRE
+ * For me JAVA_HOME was not correct so I had to overwrite it:
+   ```bash
+   $ export JAVA_HOME=/cygdrive/c/Programme/Java/jdk1.7.0_17
+   $ ./graphhopper.sh web europe_germany_berlin.osm
+   ```
\ No newline at end of file
diff --git a/docs/core/world-wide.md b/docs/core/world-wide.md
new file mode 100644
index 0000000000..bba235e159
--- /dev/null
+++ b/docs/core/world-wide.md
@@ -0,0 +1,31 @@
+GraphHopper is able to handle coverage for the whole [Openstreetmap road network](http://planet.osm.org/). 
+It needs approximately 22GB RAM for the import (CAR only) and ~1 hour (plus ~5h for contraction). 
+If you can accept slower import times this can be reduced to 14GB RAM - you'll need to set osmreader.dataaccess=MMAP
+
+Then, to run the web service with this world wide graph 'only' 15GB are necessary. Without contraction hierarchy 
+this would be about 9GB.
+
+With CH the service is able to handle about 180 queries per second (from localhost to localhost this was 300qps). 
+Measured for CAR routing, real world requests, at least 100km long, on a linux machine with 8 cores and 32GB, 
+java 1.7.0_25, jetty 8.1.10 via custom QueryTorture class (10 worker threads).
+
+## JVM
+
+If GC pauses are too long try `-XX:+UseG1GC`
+
+## Elevation Data 
+
+If you want to use elevation data you need to increase the allowed number of open files. Under linux this works as follows:
+
+ * sudo vi /etc/security/limits.conf
+ * add: `* - nofile 100000`
+   which means set hard and soft limit of "number of open files" for all users to 100K
+ * sudo vi /etc/sysctl.conf
+ * add: `fs.file-max = 90000`
+ * reboot now (or sudo sysctl -p; and re-login)
+ * afterwards `ulimit -Hn` and `ulimit -Sn` should give you 100000
+
+
+## TODOs
+
+ * Try out to disable NUMA -> http://engineering.linkedin.com/performance/optimizing-linux-memory-management-low-latency-high-throughput-databases
\ No newline at end of file
diff --git a/docs/index.md b/docs/index.md
new file mode 100644
index 0000000000..9a5a7530e0
--- /dev/null
+++ b/docs/index.md
@@ -0,0 +1,40 @@
+# Users
+
+ * [Quickstart](./web/quickstart.md) for users
+ * [Read Overview](http://graphhopper.com/#overview)
+ * [Add GraphHopper Maps to your Browser](./web/open-search.md)
+ * [GraphHopper on Twitter](https://twitter.com/graphhopper)
+
+# Translators
+
+* [Translations](./core/translations.md)
+
+
+# Developers
+
+ * [Quickstart](./core/quickstart-from-source.md) for developers with git checkout and IDE setup etc
+ * [Android](./android/index.md)
+ * [Windows](./core/windows-setup.md)
+ * [Set up and run GraphHopper in Eclipse](./core/eclipse-setup.md)
+ * [iOS](https://github.com/graphhopper/graphhopper-ios/)
+
+## Core
+
+ * [Simple routing](./core/routing.md) to integrate GraphHopper in your Java application (or pick any JVM language)
+ * [Create custom weighting](./core/weighting.md)
+ * [Elevation](./core/elevation.md)
+ * [Technical overview](./core/technical.md)
+ * [Slides from 2014](http://graphhopper.com/public/slides/)
+ * [Contraction Hierarchies](./core/ch.md)
+
+## Web
+
+ * [Routing API](./web/api-doc.md)
+ 
+## Advanced Topics
+
+ * [Low level API](./core/low-level-api.md)
+ * [Create new FlagEncoder](./core/create-new-flagencoder.md)
+ * [LocationIndex](./core/location-index.md)
+ * [World-Wide-Road-Network](./core/world-wide.md)
+ * [Changelog](https://github.com/graphhopper/graphhopper/blob/master/core/files/changelog.txt)
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
new file mode 100644
index 0000000000..328585b83d
--- /dev/null
+++ b/docs/web/api-doc.md
@@ -0,0 +1,178 @@
+## Routing Web API Docs
+
+In order to communicate with your or [our](http://graphhopper.com/#enterprise) hosted GraphHopper 
+server you need to understand how to use it.
+
+### A simple example
+[http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959](http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959)
+
+The end point of the local instance is [http://localhost:8989](http://localhost:8989)
+
+The URL path to obtain the route is `/route`
+
+All official parameters are shown in the following table
+
+Parameter   | Default | Description
+:-----------|:--------|:-----------
+point       | -       | Specifiy multiple points for which the route should be calculated. The order is important. Specify at least two points.
+locale      | en      | The locale of the result. E.g. `pt_PT` for Portuguese or `de` for German
+instructions| true    | If instruction should be calculated and returned
+vehicle     | car     | The vehicle for which the route should be calculated. Other vehicles are foot and bike
+weighting   | fastest | Which kind of 'best' route calculation you need. Other option is 'shortest', currently not available in the WEB API.
+elevation   | false   | If `true` a third dimension - the elevation - is included in the polyline or in the GeoJson. IMPORTANT: If enabled you have to use a modified version of the decoding method or set points_encoded to `false`. See the points_encoded attribute for more details. Additionally a request can fail if the vehicle does not support elevation. See the features object for every vehicle.
+algorithm   | dijkstrabi     | The algorithm to calculate the route. Other options are dijkstra, astar and astarbi. The WEB API supports only dijkstrabi.
+points_encoded     | true    | If `false` a GeoJson array in `point` is returned. If `true` the resulting route will be encoded leading to big bandwith reduction. You'll need a special handling for the decoding of this string on the client-side. We provide Open Source code in [Java](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/java/com/graphhopper/http/WebHelper.java#L43) and [JavaScript](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/webapp/js/ghrequest.js#L139). It is especially important to use our decoding methods if you set `elevation=true`!
+debug              | false   | If true, the output will be formated.
+calc_points        | true    | If the points for the route should be calculated at all. Sometimes only the distance and time is necessary.
+type               | json    | Specifies the resulting format of the route, for json the content type will be application/json. Other possible format options: <br> jsonp you'll need to provide the callback function via the callback parameter. The content type will be application/javascript<br> gpx, the content type will be application/xml
+
+## Example output for the case type=json
+
+Keep in mind that some attributes which are not documented here can be removed in the future - you should not rely on them!
+
+```json
+{
+  "info": {"took": 4},
+  "paths": [{
+    "bbox": [
+      13.362853824187303,
+      52.469481955531585,
+      13.385836736460217,
+      52.473849308838446
+    ],
+    "distance": 2138.3027624572337,
+    "instructions": [
+      {
+        "distance": 1268.519329705091,
+        "interval": [
+          0,
+          10
+        ],
+        "sign": 0,
+        "text": "Geradeaus auf A 100",
+        "time": 65237
+      },
+      {
+        "distance": 379.74399999999997,
+        "interval": [
+          10,
+          11
+        ],
+        "sign": 0,
+        "text": "Geradeaus auf Strasse",
+        "time": 24855
+      },
+      {
+        "distance": 16.451,
+        "interval": [
+          11,
+          11
+        ],
+        "sign": 0,
+        "text": "Geradeaus auf Tempelhofer Damm",
+        "time": 1316
+      },
+      {
+        "distance": 473.58843275214315,
+        "interval": [
+          11,
+          12
+        ],
+        "sign": -2,
+        "text": "Links abbiegen auf Tempelhofer Damm, B 96",
+        "time": 37882
+      },
+      {
+        "distance": 0,
+        "interval": [
+          12,
+          12
+        ],
+        "sign": 4,
+        "text": "Ziel erreicht!",
+        "time": 0
+      }
+    ],
+    "points": "oxg_Iy|ppAl@wCdE}LfFsN|@_Ej@eEtAaMh@sGVuDNcDb@{PFyGdAi]FoC?q@sXQ_@?",
+    "points_encoded": true,
+    "time": 129290
+  }]
+}
+```
+
+The JSON result contains the following structure:
+
+JSON path/attribute        | Description
+:--------------------------|:------------
+info.took                  | How many ms the request took on the server, of course without network latency taken into account.
+paths                      | An array of possible paths
+paths[0].distance          | The overall distance of the route, in meter
+paths[0].time              | The overall time of the route, in ms
+paths[0].points            | The polyline encoded coordinates of the path. Order is lat,lon,elelevation as it is no geoJson!
+paths[0].points_encoded    | Is true if the points are encoded, if not paths[0].points contains the geo json of the path (then order is lon,lat,elevation), which is easier to handle but consumes more bandwidth compared to encoded version
+paths[0].bbox              | The bounding box of the route, format: <br> minLon, minLat, maxLon, maxLat
+paths[0].instructions      | Contains information about the instructions for this route. The last instruction is always the Finish instruction and takes 0ms and 0meter. Keep in mind that instructions are currently under active development and can sometimes contain misleading information, so, make sure you always show an image of the map at the same time when navigating your users!
+paths[0].instructions[0].text                 | A description what the user has to do in order to follow the route. The language depends on the locale parameter.
+paths[0].instructions[0].distance             | The distance for this instruction, in meter
+paths[0].instructions[0].time                 | The duration for this instruction, in ms
+paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
+paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
+paths[0].instructions[0].annotationText       | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
+paths[0].instructions[0].annotationImportance | [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
+paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Is null the direction of rotation is undefined.
+
+
+## Area information
+
+If you need to find out details about the area or need to ping the service use '/info'
+
+[http://localhost:8989/info](http://localhost:8989/info)
+
+### Example output:
+```json
+{ "build_date":"2014-02-21T16:52",
+  "bbox":[13.072624,52.333508,13.763972,52.679616],
+  "version":"0.3",
+  "features": { "foot" : { "elevation" : true  }, 
+                "car"  : { "elevation" : false } }
+}
+```
+
+JSON path/attribute | Description
+:-------------------|:------------
+version             | The GraphHopper version
+bbox                | The maximum bounding box of the area, format: <br> minLon, minLat, maxLon, maxLat
+features            | A json object per supported vehicles with name and supported features like elevation
+build_date          | [optional] The GraphHopper build date
+import_date         | [optional] The date time at which the OSM import was done
+prepare_date        | [optional] The date time at which the preparation (contraction hierarchies) was done. If nothing was done this is empty
+supported_vehicles  | [deprecated] An array of strings for all supported vehicles
+
+### Output if expected error(s) while routing:
+```json
+{
+  "info": {"errors": [{
+    "details": "java.lang.IllegalArgumentException",
+    "message": "Cannot find point 2: 2248.224673, 3.867187"
+  }]}
+}
+```
+
+Sometimes a point can be "off the road" and you'll get 'cannot find point', this normally does not
+indicate a bug in the routing engine and is expected to a certain degree if too far away.
+
+JSON path/attribute    | Description
+:----------------------|:------------
+info.errors            | A list of error messages
+info.errors[0].details | E.g. to see the underlying exception, if any
+info.errors[0].message | Not intended to be displayed to the user as it is currently not translated
+
+
+### HTTP Error codes
+
+HTTP error code | Reason
+:---------------|:------------
+500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
+501             | Only a special list of vehicles is supported
+400             | Something was wrong in your request
diff --git a/docs/web/open-search.md b/docs/web/open-search.md
new file mode 100644
index 0000000000..ce5f526239
--- /dev/null
+++ b/docs/web/open-search.md
@@ -0,0 +1,16 @@
+Add GraphHopper Maps to your Browser
+----
+
+## Firefox
+
+1. go to http://graphhopper.com/maps
+2. Then right click into the search bar and select 'add GraphHopper Maps' (here 'GraphHopper Maps' hinzufügen)
+3. Finally select 'GraphHopper Maps' and type your locations. Put 'p:' before your every location.
+
+![firefox](http://karussell.files.wordpress.com/2013/08/firefox.png)
+
+## Chrome
+
+1. Open your settings in chrome and go to 'search' to add a new search engine. Use the URL `http://graphhopper.com/maps/?q=%s`
+2. Finally search via GraphHopper Maps: type 'gh ' and then put 'p:' before your locations.
+![chrome](http://karussell.files.wordpress.com/2013/08/chrome.png)
\ No newline at end of file
diff --git a/docs/web/quickstart.md b/docs/web/quickstart.md
new file mode 100644
index 0000000000..30ae92802c
--- /dev/null
+++ b/docs/web/quickstart.md
@@ -0,0 +1,18 @@
+## Quickstart
+
+If you want to build GraphHopper from source look at the [Developers page](../core/quickstart-from-source.md). 
+The following steps are simpler and only need the JRE, a jar file and an OSM file.
+
+ 1. Install the latest JRE and get GraphHopper Server as [zip](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.4-SNAPSHOT/) (~7MB)
+ 2. Unzip it and copy an OSM file into the created directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
+ 3. Start GraphHopper Maps via: `java -jar *.jar jetty.resourcebase=webapp config=config-example.properties osmreader.osm=berlin-latest.osm.pbf`
+ 4. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
+
+
+## Troubleshooting
+
+ * Make sure JRE7 or 8 is installed. If not get Java [here](http://java.com).
+ * Regarding step 2:
+    * The folder where you execute the java command should contain the following files: berlin-latest.osm.pbf, config-example.properties and `graphhopper-web-[version].jar`
+    * The first time you execute this it'll take ~30 seconds (for Berlin), further starts will only load the graph and should be nearly instantaneous. You should see log statements but no exceptions and the last entry should be something like: Started server at HTTP 8989
+ * Join the [mailing list](http://graphhopper.com/#developers) and do not hesitate to ask questions!
\ No newline at end of file
diff --git a/graphhopper.sh b/graphhopper.sh
index a27a183083..04aa03f6f2 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -1,15 +1,15 @@
 #!/bin/bash
 
-GH_CLASS=com.graphhopper.GraphHopper
-GH_HOME=$(dirname $0)
+GH_CLASS=com.graphhopper.tools.Import
+GH_HOME=$(dirname "$0")
 JAVA=$JAVA_HOME/bin/java
-if [ "x$JAVA_HOME" = "x" ]; then
+if [ "$JAVA_HOME" = "" ]; then
  JAVA=java
 fi
 
-vers=`$JAVA -version 2>&1 | grep "java version" | awk '{print $3}' | tr -d \"`
-bit64=`$JAVA -version 2>&1 | grep "64-Bit"`
-if [ "x$bit64" != "x" ]; then
+vers=$($JAVA -version 2>&1 | grep "java version" | awk '{print $3}' | tr -d \")
+bit64=$($JAVA -version 2>&1 | grep "64-Bit")
+if [ "$bit64" != "" ]; then
   vers="$vers (64bit)"
 fi
 echo "## using java $vers from $JAVA_HOME"
@@ -22,13 +22,29 @@ fi
 ACTION=$1
 FILE=$2
 
-USAGE="./graphhopper.sh import|ui|test|measurement|miniui|extract|build <your-osm-file>"
-if [ "x$ACTION" = "x" ]; then
- echo -e "## action $ACTION not found. try \n$USAGE"
+function printUsage {
+ echo
+ echo "./graphhopper.sh import|web <your-osm-file>"
+ echo "./graphhopper.sh clean|build|help"
+ echo
+ echo "  help        this message"
+ echo "  import      creates the graphhopper files used for later (faster) starts"
+ echo "  web         starts a local server for user access at localhost:8989 and developer access at localhost:8989/route"
+ echo "  build       creates the graphhopper JAR (without the web module)"
+ echo "  clean       removes all JARs, necessary if you need to use the latest source (e.g. after switching the branch etc)"
+ echo "  measurement does performance analysis of the current source version via artificial, random routes (Measurement class)"
+ echo "  torture     can be used to test real world routes via feeding graphhopper logs into a graphhopper system (Torture class)"
+ echo "  miniui      is a simple Java/Swing application used for debugging purposes only (MiniGraphUI class)"
+ echo "  extract     calls the overpass API to easily grab any area as .osm file"
+}
+
+if [ "$ACTION" = "" ]; then
+ echo "## action $ACTION not found. try" 
+ printUsage
 fi
 
 function ensureOsmXml { 
-  if [ "x$OSM_FILE" = "x" ]; then
+  if [ "$OSM_FILE" = "" ]; then
     # skip
     return
   elif [ ! -s "$OSM_FILE" ]; then
@@ -39,15 +55,15 @@ function ensureOsmXml {
     echo "## now downloading OSM file from $LINK and extracting to $OSM_FILE"
     
     if [ ${OSM_FILE: -4} == ".pbf" ]; then
-       wget -S -nv -O $OSM_FILE $LINK
+       wget -S -nv -O "$OSM_FILE" "$LINK"
     elif [ ${OSM_FILE: -4} == ".ghz" ]; then
-       wget -S -nv -O $OSM_FILE $LINK
-       unzip $FILE -d $NAME-gh             
+       wget -S -nv -O "$OSM_FILE" "$LINK"
+       unzip "$FILE" -d "$NAME-gh"
     else    
        # make sure aborting download does not result in loading corrupt osm file
        TMP_OSM=temp.osm
-       wget -S -nv -O - $LINK | bzip2 -d > $TMP_OSM
-       mv $TMP_OSM $OSM_FILE
+       wget -S -nv -O - "$LINK" | bzip2 -d > $TMP_OSM
+       mv $TMP_OSM "$OSM_FILE"
     fi
   
     if [[ ! -s "$OSM_FILE" ]]; then
@@ -61,17 +77,17 @@ function ensureOsmXml {
 
 function ensureMaven {
   # maven home existent?
-  if [ "x$MAVEN_HOME" = "x" ]; then
+  if [ "$MAVEN_HOME" = "" ]; then
     # not existent but probably is maven in the path?
-    MAVEN_HOME=`mvn -v | grep "Maven home" | cut -d' ' -f3`
-    if [ "x$MAVEN_HOME" = "x" ]; then
+    MAVEN_HOME=$(mvn -v | grep "Maven home" | cut -d' ' -f3)
+    if [ "$MAVEN_HOME" = "" ]; then
       # try to detect previous downloaded version
       MAVEN_HOME="$GH_HOME/maven"
       if [ ! -f "$MAVEN_HOME/bin/mvn" ]; then
         echo "No Maven found in the PATH. Now downloading+installing it to $MAVEN_HOME"
         cd "$GH_HOME"
-        MVN_PACKAGE=apache-maven-3.0.5
-        wget -O maven.zip http://www.eu.apache.org/dist/maven/maven-3/3.0.5/binaries/$MVN_PACKAGE-bin.zip
+        MVN_PACKAGE=apache-maven-3.2.5
+        wget -O maven.zip http://archive.apache.org/dist/maven/maven-3/3.2.5/binaries/$MVN_PACKAGE-bin.zip
         unzip maven.zip
         mv $MVN_PACKAGE maven
         rm maven.zip
@@ -96,7 +112,7 @@ function packageCoreJar {
     echo "## now building graphhopper jar: $JAR"
     echo "## using maven at $MAVEN_HOME"
     #mvn clean
-    "$MAVEN_HOME/bin/mvn" --projects core -DskipTests=true install assembly:single > /tmp/graphhopper-compile.log
+    "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests=true install assembly:single > /tmp/graphhopper-compile.log
     returncode=$?
     if [[ $returncode != 0 ]] ; then
         echo "## compilation of core failed"
@@ -111,59 +127,60 @@ function packageCoreJar {
 function prepareEclipse {
  ensureMaven   
  packageCoreJar
- cp core/target/graphhopper-*-android.jar android/libs/   
+ # cp core/target/graphhopper-*-android.jar android/libs/   
 }
 
 
 ## now handle actions which do not take an OSM file
-if [ "x$ACTION" = "xclean" ]; then
- rm -rf */target
+if [ "$ACTION" = "clean" ]; then
+ rm -rf ./*/target
  exit
 
-elif [ "x$ACTION" = "xeclipse" ]; then
+elif [ "$ACTION" = "eclipse" ]; then
  prepareEclipse
  exit
 
-elif [ "x$ACTION" = "xbuild" ]; then
+elif [ "$ACTION" = "build" ]; then
  prepareEclipse
  exit  
  
-elif [ "x$ACTION" = "xextract" ]; then
+elif [ "$ACTION" = "extract" ]; then
  echo use "./graphhopper.sh extract \"left,bottom,right,top\""
  URL="http://overpass-api.de/api/map?bbox=$2"
  #echo "$URL"
- wget -O extract.osm $URL
+ wget -O extract.osm "$URL"
  exit
  
-elif [ "x$ACTION" = "xandroid" ]; then
+elif [ "$ACTION" = "android" ]; then
  prepareEclipse
- "$MAVEN_HOME/bin/mvn" --projects android install android:deploy android:run
+ "$MAVEN_HOME/bin/mvn" -P include-android --projects android install android:deploy android:run
  exit
 fi
 
-if [ "x$FILE" = "x" ]; then
-  echo -e "no file specified? try \n$USAGE"
+if [ "$FILE" = "" ]; then
+  echo -e "no file specified? try"
+  printUsage
   exit
 fi
 
 # NAME = file without extension if any
 NAME="${FILE%.*}"
 
-if [ "x$FILE" == "x-" ]; then
+if [ "$FILE" == "-" ]; then
    OSM_FILE=
 elif [ ${FILE: -4} == ".osm" ]; then
-   OSM_FILE=$FILE
+   OSM_FILE="$FILE"
 elif [ ${FILE: -4} == ".pbf" ]; then
-   OSM_FILE=$FILE
+   OSM_FILE="$FILE"
 elif [ ${FILE: -7} == ".osm.gz" ]; then
-   OSM_FILE=$FILE   
+   OSM_FILE="$FILE"
 elif [ ${FILE: -3} == "-gh" ]; then
-   OSM_FILE=$FILE
+   OSM_FILE="$FILE"
    NAME=${FILE%%???}
 elif [ ${FILE: -4} == ".ghz" ]; then
-   OSM_FILE=$FILE
+   OSM_FILE="$FILE"
    if [[ ! -d "$NAME-gh" ]]; then
-      unzip $FILE -d $NAME-gh
+      unzip "$FILE" -d "$NAME-gh"
    fi
 else
    # no known end -> no import
@@ -171,11 +188,11 @@ else
 fi
 
 GRAPH=$NAME-gh
-VERSION=`grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<' -f1`
-JAR=core/target/graphhopper-$VERSION-jar-with-dependencies.jar
+VERSION=$(grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<' -f1)
+JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar
 
-LINK=`echo $NAME | tr '_' '/'`
-if [ "x$FILE" == "x-" ]; then
+LINK=$(echo $NAME | tr '_' '/')
+if [ "$FILE" == "-" ]; then
    LINK=
 elif [ ${FILE: -4} == ".osm" ]; then 
    LINK="http://download.geofabrik.de/$LINK-latest.osm.bz2"
@@ -188,8 +205,8 @@ else
    LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 fi
 
-if [ "x$JAVA_OPTS" = "x" ]; then
-  JAVA_OPTS="-XX:PermSize=60m -XX:MaxPermSize=60m -Xmx1000m -Xms1000m -server"
+if [ "$JAVA_OPTS" = "" ]; then
+  JAVA_OPTS="-Xmx1000m -Xms1000m -server"
 fi
 
 
@@ -199,54 +216,69 @@ packageCoreJar
 
 echo "## now $ACTION. JAVA_OPTS=$JAVA_OPTS"
 
-if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
+if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
   export MAVEN_OPTS="$MAVEN_OPTS $JAVA_OPTS"
-  if [ "x$JETTY_PORT" = "x" ]; then  
+  if [ "$JETTY_PORT" = "" ]; then  
     JETTY_PORT=8989
   fi
-  "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/web/pom.xml" -Djetty.port=$JETTY_PORT -Djetty.reload=manual \
-      -Dgraphhopper.config=$CONFIG \
-      $GH_WEB_OPTS -Dgraphhopper.graph.location="$GRAPH" -Dgraphhopper.osmreader.osm="$OSM_FILE" \
-      jetty:run
-
+  WEB_JAR="$GH_HOME/web/target/graphhopper-web-$VERSION-with-dep.jar"
+  if [ ! -s "$WEB_JAR" ]; then         
+    "$MAVEN_HOME/bin/mvn" --projects web -DskipTests=true install assembly:single > /tmp/graphhopper-web-compile.log
+    returncode=$?
+    if [[ $returncode != 0 ]] ; then
+      echo "## compilation of web failed"
+      cat /tmp/graphhopper-web-compile.log
+      exit $returncode
+    fi
+  fi
 
-elif [ "x$ACTION" = "ximport" ]; then
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true \
-      config=$CONFIG \
-      $GH_IMPORT_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
+  RC_BASE=./web/src/main/webapp
 
+  if [ "$GH_FOREGROUND" = "" ]; then
+    exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
+	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
+    	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
+    # foreground => we never reach this here
+  else
+    exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
+    	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
+    	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE" <&- &
+    if [ "$GH_PID_FILE" != "" ]; then
+       echo $! > $GH_PID_FILE
+    fi
+    exit $?                    
+  fi
 
-elif [ "x$ACTION" = "xtest" ]; then
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true config=$CONFIG \
-       graph.location="$GRAPH" osmreader.osm="$OSM_FILE" prepare.chShortcuts=false \
-       graph.testIT=true
+elif [ "$ACTION" = "import" ]; then
+ "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS config=$CONFIG \
+      $GH_IMPORT_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
 
 
-elif [ "x$ACTION" = "xtorture" ]; then
- "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.util.QueryTorture $3 $4 $5 $6 $7 $8 $9
+elif [ "$ACTION" = "torture" ]; then
+ "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.QueryTorture $3 $4 $5 $6 $7 $8 $9
 
 
-elif [ "x$ACTION" = "xminiui" ]; then
- "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/tools/pom.xml" -DskipTests clean install assembly:single
+elif [ "$ACTION" = "xminiui" ]; then
+ "$MAVEN_HOME/bin/mvn" --projects tools -DskipTests clean install assembly:single
  JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar   
- "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI osmreader.osm="$OSM_FILE" printVersion=true config=$CONFIG \
+ "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI osmreader.osm="$OSM_FILE" config=$CONFIG \
               graph.location="$GRAPH"
 
 
-elif [ "x$ACTION" = "xmeasurement" ]; then
- ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chShortcuts=fastest osmreader.acceptWay=CAR"
- # graph.doSort=true"
+elif [ "$ACTION" = "measurement" ]; then
+ ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chWeighting=fastest graph.flagEncoders=CAR"
  echo -e "\ncreate graph via $ARGS, $JAR"
  START=$(date +%s)
- "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false
+ # avoid islands for measurement at all costs
+ "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false prepare.minNetworkSize=10000 prepare.minOnewayNetworkSize=10000
  END=$(date +%s)
  IMPORT_TIME=$(($END - $START))
 
  function startMeasurement {
     COUNT=5000
-    commit_info=`git log -n 1 --pretty=oneline`     
+    commit_info=$(git log -n 1 --pretty=oneline)
     echo -e "\nperform measurement via jar=> $JAR and ARGS=> $ARGS"
-    "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.util.Measurement $ARGS measurement.count=$COUNT measurement.location=$M_FILE_NAME \
+    "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.Measurement $ARGS measurement.count=$COUNT measurement.location="$M_FILE_NAME" \
             graph.importTime=$IMPORT_TIME measurement.gitinfo="$commit_info"
  }
  
@@ -254,24 +286,24 @@ elif [ "x$ACTION" = "xmeasurement" ]; then
  # use all <last_commits> versions starting from HEAD
  last_commits=$3
   
- if [ "x$last_commits" = "x" ]; then
+ if [ "$last_commits" = "" ]; then
    # use current version
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
    exit
  fi
 
- current_commit=`git log -n 1 --pretty=oneline | cut -d' ' -f1` 
+ current_commit=$(git log -n 1 --pretty=oneline | cut -d' ' -f1)
  commits=$(git rev-list HEAD -n $last_commits)
  for commit in $commits; do
    git checkout $commit -q
-   M_FILE_NAME=`git log -n 1 --pretty=oneline | grep -o "\ .*" |  tr " ,;" "_"`
+   M_FILE_NAME=$(git log -n 1 --pretty=oneline | grep -o "\ .*" |  tr " ,;" "_")
    M_FILE_NAME="measurement$M_FILE_NAME.properties"
    echo -e "\nusing commit $commit and $M_FILE_NAME"
    
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
-   echo -e "\nmeasurement.commit=$commit\n" >> $M_FILE_NAME
+   echo -e "\nmeasurement.commit=$commit\n" >> "$M_FILE_NAME"
  done
  # revert checkout
  git checkout $current_commit
diff --git a/index.html b/index.html
deleted file mode 100644
index 347a3312b4..0000000000
--- a/index.html
+++ /dev/null
@@ -1,80 +0,0 @@
-<!DOCTYPE html>
-<html>
-    <head>        
-        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
-        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
-        <meta name="keywords" content="road routing,shortest path,maps,openstreetmap,android,navigation,routenplaner,gis"/>
-        <link type="image/png" rel="icon" href="/favicon.ico"/>        
-        <link rel="search" type="application/opensearchdescription+xml" title="GraphHopper Maps" href="opensearch.xml"/>
-        <title>GraphHopper Maps</title>
-
-        <link rel="stylesheet" href="css/leaflet.css" />
-        <!--[if lte IE 8]>
-            <link rel="stylesheet" href="css/leaflet.ie.css" />
-        <![endif]-->
-        <script type="text/javascript" src="js/leaflet.js?v=0.6.4"></script>
-        <script type="text/javascript" src="js/jquery-1.10.2.min.js"></script>
-        <script type="text/javascript" src="js/jquery.history.js"></script>
-<!--        <script type="text/javascript" src="js/jquery.autocomplete.min.js"></script>-->
-        <script type="text/javascript" src="js/jquery.autocomplete.js"></script>
-        <script type="text/javascript" src="js/ghrequest.js?v=3"></script>
-        <script type="text/javascript" src="js/main.js?v=14"></script>
-        <link rel="stylesheet" type="text/css" href="css/style.css" />
-    </head>
-    <body>
-        <div id="input">
-            <div id="header_img">
-                <a class="no_link" href="http://graphhopper.com">
-                    <img alt="GraphHopper" src="http://graphhopper.com/img/header.png"/>                    
-                </a>
-            </div>
-            <div id="options">
-                <span id="vehicles">
-
-                </span>
-            </div>
-            <form id="locationform">
-                <div id="fromDiv">
-                    <img id="fromIndicator" class="hidden" src="img/indicator.gif"/>
-                    <img id="fromFlag" src="img/marker-small-green.png"/>
-                    <input id="fromInput" type="text" placeholder="From"/>
-                    <div id="fromFound"></div>
-                </div>
-                <div id="toDiv">
-                    <img id="toIndicator" class="hidden" src="img/indicator.gif"/>
-                    <img id="toFlag" src="img/marker-small-red.png"/>                    
-                    <input id="toInput" type="text" placeholder="To"/>
-                    <div id="toFound"></div>
-                </div>
-                <div id="exportLink" class="left"><a href="/maps"><img src='img/link.png'></a></div>
-                <input id="searchButton" type="submit" value="Search">
-            </form>      
-            <div class="clear"> </div>
-            <div id="info" class="small_text">
-            </div>
-            <div id="error" class="error">
-            </div>
-        </div>
-
-        <div id="map">
-        </div>
-        <!-- Piwik -->
-        <script type="text/javascript">
-            PIWIK=false;
-            if(PIWIK) {
-                var pkBaseURL = (("https:" == document.location.protocol) ? "https://www.pannous.info/piwik/" : "http://www.pannous.info/piwik/");
-                document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
-            }
-        </script>
-        <script type="text/javascript">
-            if(PIWIK)
-                try { 
-                    var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 7);
-                    piwikTracker.trackPageView();
-                    piwikTracker.enableLinkTracking();
-                } catch( err ) {}
-        </script>
-        <noscript><p><img src="http://www.pannous.info/piwik/piwik.php?idsite=7" style="border:0" alt="" /></p></noscript>
-        <!-- End Piwik Tracking Code -->
-    </body>
-</html>
diff --git a/pom.xml b/pom.xml
index 4908f05306..0837ca65c5 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-parent</artifactId>
     <name>GraphHopper Parent Project</name>
-    <version>0.3-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <packaging>pom</packaging> 
     <url>http://graphhopper.com</url> 
     <inceptionYear>2012</inceptionYear>
@@ -16,13 +16,14 @@
     <parent>
         <groupId>org.sonatype.oss</groupId>
         <artifactId>oss-parent</artifactId>
-        <version>7</version>
+        <version>9</version>
+        <relativePath></relativePath>
     </parent>
 
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-        <slf4j.version>1.7.5</slf4j.version>
+        <slf4j.version>1.7.10</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
         
         <!-- netbeans formatting rules -->
@@ -52,10 +53,15 @@
     </scm>
     <developers>
         <developer>
-            <id>peterka</id>
+            <id>karussell</id>
             <name>Peter Karich</name>
             <email>my.name@graphhopper.com</email>
         </developer>
+        <developer>
+            <id>jansoe</id>
+            <name>Jan Sölter</name>
+            <email>my.name@graphhopper.com</email>
+        </developer>
     </developers>
     
     <mailingLists>
@@ -76,7 +82,6 @@
         <module>core</module>
         <module>tools</module>
         <module>web</module>
-        <module>android</module>
     </modules>
         
     <build>        
@@ -86,12 +91,15 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
+                <version>3.2</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
                     
+                    <!-- suppress warning about Unsafe functionality -->
+                    <compilerArgument>-XDignore.symbol.file</compilerArgument>
+                    <fork>true</fork>
                     <source>1.6</source>
                     <target>1.6</target>
                 </configuration>
@@ -101,7 +109,7 @@
             <plugin>                
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.15</version>
+                <version>2.18.1</version>
                 <configuration>
                     <argLine>-Xmx100m -Xms100m</argLine>
                 </configuration>
@@ -110,7 +118,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.15</version>
+                <version>2.18.1</version>
                 <executions>
                     <execution>
                         <goals>
@@ -124,18 +132,32 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-deploy-plugin</artifactId>
-                <version>2.7</version>
+                <version>2.8.2</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.9.1</version>
+                <version>2.10.1</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-source-plugin</artifactId>
-                <version>2.2.1</version>
+                <version>2.4</version>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-assembly-plugin</artifactId>
+                <version>2.5.3</version>                    
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <version>2.5</version>
+            </plugin>
+            <plugin>
+                <artifactId>maven-war-plugin</artifactId>
+                <version>2.6</version>                
+            </plugin>            
         </plugins>
     </build>    
     
@@ -143,7 +165,7 @@
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
-            <version>4.11</version>
+            <version>4.12</version>
             <scope>test</scope>
         </dependency>        
     </dependencies>
@@ -163,7 +185,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-gpg-plugin</artifactId>
-                        <version>1.4</version>
+                        <version>1.5</version>
                         <executions>
                             <execution>
                                 <id>sign-artifacts</id>
@@ -177,6 +199,16 @@
                 </plugins>
             </build>
         </profile>
+        
+        <profile>
+            <id>include-android</id>
+            <activation>
+                <activeByDefault>false</activeByDefault>
+            </activation>
+            <modules>
+                <module>android/app</module>
+            </modules>
+        </profile>
     </profiles>
     
 </project>
diff --git a/tools/pom.xml b/tools/pom.xml
index 40f6ae364f..35aeb6f029 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools</artifactId>
-    <version>0.3-SNAPSHOT</version>
+    <version>0.5-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.3-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -41,22 +41,21 @@
         <dependency>
             <groupId>org.apache.commons</groupId>
             <artifactId>commons-compress</artifactId>
-            <version>1.5</version>
+            <version>1.9</version>
         </dependency>
     </dependencies>
     <build>
-        <plugins>   
-            <plugin> 
+        <plugins>
+            <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.4</version>
+                <artifactId>maven-assembly-plugin</artifactId>                
                 <configuration>
-                    <archive>  
-                        <manifest> 
-                            <mainClass>com.graphhopper.ui.MiniGraphUI</mainClass>
+                    <archive>
+                        <manifest>
+                            <mainClass>com.graphhopper.tools.Import</mainClass>
                         </manifest>
                     </archive>
-                     
+                        	                    
                     <!-- for standalone usage -->
                     <descriptorRefs>
                         <descriptorRef>jar-with-dependencies</descriptorRef>
diff --git a/tools/src/main/java/com/graphhopper/tools/Import.java b/tools/src/main/java/com/graphhopper/tools/Import.java
index 1c615e7858..1627869017 100644
--- a/tools/src/main/java/com/graphhopper/tools/Import.java
+++ b/tools/src/main/java/com/graphhopper/tools/Import.java
@@ -1,14 +1,18 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.GraphHopper;
+import com.graphhopper.util.CmdArgs;
 
 /**
  * @author Peter Karich
  */
 public class Import
 {
-    public static void main( String[] args ) throws Exception
+    public static void main( String[] strs ) throws Exception
     {
-        GraphHopper.main(args);
+        CmdArgs args = CmdArgs.read(strs);
+        GraphHopper hopper = new GraphHopper().init(args);
+        hopper.importOrLoad();
+        hopper.close();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
similarity index 77%
rename from core/src/main/java/com/graphhopper/util/Measurement.java
rename to tools/src/main/java/com/graphhopper/tools/Measurement.java
index 255d8520a3..48fd784f85 100644
--- a/core/src/main/java/com/graphhopper/util/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -15,7 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.tools;
 
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
@@ -24,6 +24,15 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Constants;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.MiniPerfTest;
+import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.BBox;
 import java.io.FileWriter;
 import java.io.IOException;
@@ -68,12 +77,14 @@ protected void ensureNotLoaded()
 
         public void doPostProcessing()
         {
+            // re-create index to avoid bug as pickNode in locationIndex.prepare could be wrong while indexing if level is not taken into account and assumed to be 0 for pre-initialized graph            
             StopWatch sw = new StopWatch().start();
-            int edges = getGraph().getAllEdges().getMaxId();
-            initCHPrepare();
+            int edges = getGraph().getAllEdges().getCount();
+            setAlgorithmFactory(createPrepare());
             super.prepare();
+            setLocationIndex(createLocationIndex(new RAMDirectory()));
             put("prepare.time", sw.stop().getTime());
-            put("prepare.shortcuts", getGraph().getAllEdges().getMaxId() - edges);
+            put("prepare.shortcuts", getGraph().getAllEdges().getCount() - edges);
         }
     }
 
@@ -97,33 +108,34 @@ void start( CmdArgs args )
         int count = args.getInt("measurement.count", 5000);
 
         MeasureHopper hopper = new MeasureHopper();
-        hopper.forDesktop().setEnableInstructions(false);
+        hopper.forDesktop();
         if (!hopper.load(graphLocation))
             throw new IllegalStateException("Cannot load existing levelgraph at " + graphLocation);
 
-        GraphStorage g = (GraphStorage) hopper.getGraph();
+        GraphStorage g = hopper.getGraph();
         if ("true".equals(g.getProperties().get("prepare.done")))
             throw new IllegalStateException("Graph has to be unprepared but wasn't!");
 
-        String vehicleStr = args.get("osmreader.acceptWay");
+        String vehicleStr = args.get("graph.flagEncoders", "");
         StopWatch sw = new StopWatch().start();
         try
         {
             maxNode = g.getNodes();
-            printGraphDetails(g);
-            printLocation2IDQuery(g, hopper.getLocationIndex(), count);
+            printGraphDetails(g, vehicleStr);
+            printLocationIndexQuery(g, hopper.getLocationIndex(), count);
 
             // Route via dijkstrabi. Normal routing takes a lot of time => smaller query number than CH
             // => values are not really comparable to routingCH as e.g. the mean distance etc is different            
-            hopper.disableCHShortcuts();
-            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr);
+            hopper.setCHEnable(false);
+            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr, true);
 
             System.gc();
 
             // route via CH. do preparation before                        
-            hopper.setCHShortcuts("fastest");
+            hopper.setCHEnable(true);
             hopper.doPostProcessing();
-            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr);
+            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr, true);
+            printTimeOfRouteQuery(hopper, count, "routingCH_no_instr", vehicleStr, false);
             logger.info("store into " + propLocation);
         } catch (Exception ex)
         {
@@ -149,16 +161,16 @@ void start( CmdArgs args )
         }
     }
 
-    private void printGraphDetails( GraphStorage g )
+    private void printGraphDetails( GraphStorage g, String vehicleStr )
     {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
-        put("graph.edges", g.getAllEdges().getMaxId());
+        put("graph.edges", g.getAllEdges().getCount());
         put("graph.sizeInMB", g.getCapacity() / Helper.MB);
-        put("graph.encoder", g.getEncodingManager().getSingle().toString());
+        put("graph.encoder", vehicleStr);
     }
 
-    private void printLocation2IDQuery( Graph g, final LocationIndex idx, int count )
+    private void printLocationIndexQuery( Graph g, final LocationIndex idx, int count )
     {
         count *= 2;
         final BBox bbox = g.getBounds();
@@ -183,7 +195,8 @@ public int doCalc( boolean warmup, int run )
         print("location2id", miniPerf);
     }
 
-    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix, final String vehicle )
+    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix,
+            final String vehicle, final boolean withInstructions )
     {
         final Graph g = hopper.getGraph();
         final AtomicLong maxDistance = new AtomicLong(0);
@@ -198,6 +211,7 @@ private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String
 //        final AtomicLong calcDistTimeSum = new AtomicLong(0);
 //        final AtomicLong tmpDist = new AtomicLong(0);
         final Random rand = new Random(seed);
+        final NodeAccess na = g.getNodeAccess();
         MiniPerfTest miniPerf = new MiniPerfTest()
         {
             @Override
@@ -205,23 +219,39 @@ public int doCalc( boolean warmup, int run )
             {
                 int from = rand.nextInt(maxNode);
                 int to = rand.nextInt(maxNode);
-                double fromLat = g.getLatitude(from);
-                double fromLon = g.getLongitude(from);
-                double toLat = g.getLatitude(to);
-                double toLon = g.getLongitude(to);
-                GHResponse res = hopper.route(new GHRequest(fromLat, fromLon, toLat, toLon).setWeighting("fastest").setVehicle(vehicle));
+                double fromLat = na.getLatitude(from);
+                double fromLon = na.getLongitude(from);
+                double toLat = na.getLatitude(to);
+                double toLon = na.getLongitude(to);
+                GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
+                        setWeighting("fastest").
+                        setVehicle(vehicle);
+                req.getHints().put("instructions", withInstructions);
+                GHResponse res;
+                try
+                {
+                    res = hopper.route(req);
+                } catch (Exception ex)
+                {
+                    // 'not found' can happen if import creates more than one subnetwork
+                    throw new RuntimeException("Error while calculating route! "
+                            + "nodes:" + from + " -> " + to + ", request:" + req, ex);
+                }
+
                 if (res.hasErrors())
-                    throw new IllegalStateException("errors should NOT happen in Measurement! " + res.getErrors());
+                {
+                    if (!warmup)
+                        failedCount.incrementAndGet();
+
+                    if (!res.getErrors().get(0).getMessage().toLowerCase().contains("not found"))
+                        logger.error("errors should NOT happen in Measurement! " + req + " => " + res.getErrors());
+
+                    return 0;
+                }
 
                 if (!warmup)
                 {
                     long dist = (long) res.getDistance();
-                    if (dist < 1)
-                    {
-                        failedCount.incrementAndGet();
-                        return 0;
-                    }
-
                     distSum.addAndGet(dist);
 
                     airDistSum.addAndGet((long) distCalc.calcDist(fromLat, fromLon, toLat, toLon));
diff --git a/core/src/main/java/com/graphhopper/util/QueryTorture.java b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
similarity index 73%
rename from core/src/main/java/com/graphhopper/util/QueryTorture.java
rename to tools/src/main/java/com/graphhopper/tools/QueryTorture.java
index c2a81464d2..b5f0a20353 100644
--- a/core/src/main/java/com/graphhopper/util/QueryTorture.java
+++ b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
@@ -15,16 +15,22 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.tools;
 
-import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.shapes.GHPoint;
 import java.io.*;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
+import java.net.URLEncoder;
+import java.util.*;
+import java.util.Map.Entry;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.zip.GZIPInputStream;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -53,6 +59,7 @@ public static void main( String[] args )
     private int readQueries;
     private int maxQueries;
     private int timeout;
+    private int statusUpdateCnt;
 
     public QueryTorture()
     {
@@ -60,18 +67,19 @@ public QueryTorture()
 
     public void start( CmdArgs read )
     {
-        String logfile = read.get("logfile");
+        String logfile = read.get("logfile", "");
         int workers = read.getInt("workers", 1);
-        baseUrl = read.get("baseurl");
+        baseUrl = read.get("baseurl", "");
         maxQueries = read.getInt("maxqueries", 1000);
         timeout = read.getInt("timeout", 3000);
+        statusUpdateCnt = maxQueries / 10;
         if (Helper.isEmpty(baseUrl))
             throw new IllegalArgumentException("baseUrl cannot be empty!?");
 
-        if (baseUrl.endsWith("/"))
-            baseUrl = baseUrl.substring(0, baseUrl.length() - 1);
-        if (!baseUrl.endsWith("/api/route"))
-            baseUrl += "/api/route";
+        if (!baseUrl.endsWith("/"))
+            baseUrl += "/";
+        if (!baseUrl.endsWith("route/"))
+            baseUrl += "route/";
         if (!baseUrl.endsWith("?"))
             baseUrl += "?";
 
@@ -167,11 +175,17 @@ void execute( int workerNo ) throws InterruptedException
         Query query = queryQueue.take();
         try
         {
-            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(baseUrl + query.queryString);
+            String url = baseUrl + query.createQueryString();
+            String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url);
             if (res.contains("errors"))
                 routingErrorCounter.incrementAndGet();
             else
                 successfullQueries.incrementAndGet();
+
+            if (successfullQueries.get() % statusUpdateCnt == 0)
+            {
+                logger.info("progress: " + (int) (successfullQueries.get() * 100 / maxQueries) + "%");
+            }
         } catch (IOException ex)
         {
             // logger.error("Error while querying " + query.queryString, ex);
@@ -189,14 +203,18 @@ public void run()
             {
                 try
                 {
-                    BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(logFile), "UTF-8"));
+                    InputStream is;
+                    if (logFile.endsWith(".gz"))
+                        is = new GZIPInputStream(new FileInputStream(logFile));
+                    else
+                        is = new FileInputStream(logFile);
+
+                    BufferedReader reader = new BufferedReader(new InputStreamReader(is, Helper.UTF_CS));
                     try
                     {
-                        int logLineNo = 0;
                         String logLine;
                         while ((logLine = reader.readLine()) != null)
                         {
-                            logLineNo++;
                             Query q = Query.parse(logLine);
                             if (q == null)
                                 continue;
@@ -227,7 +245,8 @@ public void run()
                 {
                     logger.error("Stopped reading logs", ex);
                     // do not wait, just shut down
-                    service.shutdownNow();
+                    if (service != null)
+                        service.shutdownNow();
                 }
             }
         }.start();
@@ -235,9 +254,10 @@ public void run()
 
     static class Query
     {
-        String queryString;
-        GHPlace start;
-        GHPlace end;
+        GHPoint start;
+        GHPoint end;
+        List<String> points = new ArrayList<String>();
+        Map<String, String> params = new HashMap<String, String>();
 
         static Query parse( String logLine )
         {
@@ -252,24 +272,32 @@ static Query parse( String logLine )
                 return null;
 
             Query q = new Query();
-            q.queryString = logLine.substring(0, index);
-
-            for (String param : q.queryString.split("\\&"))
+            String queryString = logLine.substring(0, index);
+            String[] tmpStrings = queryString.split("\\&");
+            for (String paramStr : tmpStrings)
             {
-                if (!param.startsWith("point="))
+                int equalIndex = paramStr.indexOf("=");
+                if (equalIndex <= 0)
                     continue;
 
-                GHPlace place = GHPlace.parse(param.substring(6));
-                if (place == null)
+                String key = paramStr.substring(0, equalIndex);
+                String value = paramStr.substring(equalIndex + 1);
+                if (!paramStr.startsWith("point="))
+                {
+                    q.params.put(key, value);
                     continue;
+                }
 
+                value = value.replace("%2C", ",");
+                GHPoint point = GHPoint.parse(value);
+                if (point == null)
+                    continue;
+
+                q.points.add(value);
                 if (q.start == null)
-                    q.start = place;
+                    q.start = point;
                 else if (q.end == null)
-                {
-                    q.end = place;
-                    break;
-                }
+                    q.end = point;
             }
             if (q.start != null && q.end != null)
                 return q;
@@ -277,31 +305,47 @@ else if (q.end == null)
             return null;
         }
 
-        @Override
-        public int hashCode()
+        public void put( String key, String value )
         {
-            int hash = 5;
-            hash = 47 * hash + (this.queryString != null ? this.queryString.hashCode() : 0);
-            return hash;
+            params.put(key, value);
         }
 
-        @Override
-        public boolean equals( Object obj )
+        public String createQueryString()
         {
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
-            final Query other = (Query) obj;
-            if ((this.queryString == null) ? (other.queryString != null) : !this.queryString.equals(other.queryString))
-                return false;
-            return true;
+            String qStr = "";
+            for (String pointStr : points)
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += "point=" + pointStr;
+            }
+            for (Entry<String, String> e : params.entrySet())
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += e.getKey() + "=" + encodeURL(e.getValue());
+            }
+
+            return qStr;
+        }
+
+        static String encodeURL( String str )
+        {
+            try
+            {
+                return URLEncoder.encode(str, "UTF-8");
+            } catch (Exception _ignore)
+            {
+                return str;
+            }
         }
 
         @Override
         public String toString()
         {
-            return queryString;
+            return createQueryString();
         }
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
index 23b5bbe438..94afcf8e3d 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
@@ -19,9 +19,11 @@
 
 import com.graphhopper.routing.AStar;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.util.EdgeIteratorState;
 import java.awt.Color;
 import java.awt.Graphics2D;
 
@@ -33,9 +35,9 @@
     private GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugAStar( Graph graph, FlagEncoder encoder, Weighting type, GraphicsWrapper mg )
+    public DebugAStar( Graph graph, FlagEncoder encoder, Weighting type, TraversalMode tMode, GraphicsWrapper mg )
     {
-        super(graph, encoder, type);
+        super(graph, encoder, type, tMode);
         this.mg = mg;
     }
 
@@ -46,12 +48,12 @@ public void setGraphics2D( Graphics2D g2 )
     }
 
     @Override
-    public void updateShortest( EdgeEntry shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState es, EdgeEntry bestEE, int currLoc )
     {
         if (g2 != null)
         {
             mg.plotNode(g2, currLoc, Color.YELLOW);
         }
-        super.updateShortest(shortestDE, currLoc);
+        super.updateBestPath(es, bestEE, currLoc);
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
index 77df456145..f7872e7bcf 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
@@ -19,9 +19,11 @@
 
 import com.graphhopper.routing.AStarBidirection;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.util.EdgeIteratorState;
 import java.awt.Color;
 import java.awt.Graphics2D;
 
@@ -33,9 +35,9 @@
     private GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugAStarBi( Graph graph, FlagEncoder encoder, Weighting type, GraphicsWrapper mg )
+    public DebugAStarBi( Graph graph, FlagEncoder encoder, Weighting type, TraversalMode tMode, GraphicsWrapper mg )
     {
-        super(graph, encoder, type);
+        super(graph, encoder, type, tMode);
         this.mg = mg;
     }
 
@@ -46,12 +48,12 @@ public void setGraphics2D( Graphics2D g2 )
     }
 
     @Override
-    public void updateShortest( EdgeEntry shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState es, EdgeEntry bestEE, int currLoc )
     {
         if (g2 != null)
         {
             mg.plotNode(g2, currLoc, Color.YELLOW);
         }
-        super.updateShortest(shortestDE, currLoc);
+        super.updateBestPath(es, bestEE, currLoc);
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
index c53ee5ffb3..0ee0376450 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
@@ -19,9 +19,11 @@
 
 import com.graphhopper.routing.DijkstraBidirectionRef;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.util.EdgeIteratorState;
 import java.awt.Color;
 import java.awt.Graphics2D;
 
@@ -33,9 +35,9 @@
     private GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugDijkstraBidirection( Graph graph, FlagEncoder encoder, Weighting type, GraphicsWrapper mg )
+    public DebugDijkstraBidirection( Graph graph, FlagEncoder encoder, Weighting type, TraversalMode tMode, GraphicsWrapper mg )
     {
-        super(graph, encoder, type);
+        super(graph, encoder, type, tMode);
         this.mg = mg;
     }
 
@@ -46,13 +48,13 @@ public void setGraphics2D( Graphics2D g2 )
     }
 
     @Override
-    public void updateShortest( EdgeEntry shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState es, EdgeEntry bestEE, int currLoc )
     {
         if (g2 != null)
         {
             mg.plotNode(g2, currLoc, Color.BLUE);
         }
         // System.out.println("new node:" + currLoc);
-        super.updateShortest(shortestDE, currLoc);
+        super.updateBestPath(es, bestEE, currLoc);
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
index ff91a22c38..3b6e1264fa 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraSimple.java
@@ -19,9 +19,11 @@
 
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.EdgeEntry;
+import com.graphhopper.util.EdgeIteratorState;
 import java.awt.Color;
 import java.awt.Graphics2D;
 
@@ -33,9 +35,9 @@
     private GraphicsWrapper mg;
     private Graphics2D g2;
 
-    public DebugDijkstraSimple( Graph graph, FlagEncoder encoder, Weighting weighting, GraphicsWrapper mg )
+    public DebugDijkstraSimple( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode, GraphicsWrapper mg )
     {
-        super(graph, encoder, weighting);
+        super(graph, encoder, weighting, tMode);
         this.mg = mg;
     }
 
@@ -46,12 +48,12 @@ public void setGraphics2D( Graphics2D g2 )
     }
 
     @Override
-    public void updateShortest( EdgeEntry shortestDE, int currLoc )
+    public void updateBestPath( EdgeIteratorState es, EdgeEntry bestEE, int currLoc )
     {
         if (g2 != null)
         {
             mg.plotNode(g2, currLoc, Color.YELLOW);
         }
-        super.updateShortest(shortestDE, currLoc);
+        super.updateBestPath(es, bestEE, currLoc);
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugLocation2IDQuadtree.java b/tools/src/main/java/com/graphhopper/ui/DebugLocation2IDQuadtree.java
deleted file mode 100644
index 546a2d3229..0000000000
--- a/tools/src/main/java/com/graphhopper/ui/DebugLocation2IDQuadtree.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.ui;
-
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.Location2IDQuadtree;
-import java.awt.Color;
-import java.awt.Graphics2D;
-
-/**
- * @author Peter Karich
- */
-class DebugLocation2IDQuadtree extends Location2IDQuadtree
-{
-    private GraphicsWrapper mg;
-    private Graphics2D g2;
-
-    public DebugLocation2IDQuadtree( Graph g, GraphicsWrapper mg, Directory dir )
-    {
-        super(g, dir);
-        this.mg = mg;
-    }
-
-    public void setGraphics( Graphics2D g2 )
-    {
-        this.g2 = g2;
-        double w = getMaxRasterWidthMeter();
-        // System.out.println("w:" + w);
-        double startLon = mg.getLon(0);
-        double lat1 = mg.getLat(0);
-        double lat2 = mg.getLat(500);
-        g2.setColor(Color.ORANGE);
-        int lines = 1000;
-        for (int i = 0; i < lines; i++)
-        {
-            double c1 = distCalc.calcCircumference(lat1);
-            double addLon1 = 360 * i * w / c1;
-            double c2 = distCalc.calcCircumference(lat1);
-            double addLon2 = 360 * i * w / c2;
-            int x1 = (int) mg.getX(startLon + addLon1);
-            int x2 = (int) mg.getX(startLon + addLon2);
-            g2.drawLine(x1, (int) mg.getY(lat1), x2, (int) mg.getY(lat2));
-        }
-    }
-
-    @Override
-    public int findID( double lat, double lon )
-    {
-        int ret = super.findID(lat, lon);
-        mg.plotNode(g2, ret, Color.GREEN);
-        return ret;
-    }
-
-    @Override
-    public void goFurtherHook( int n )
-    {
-        if (g2 != null)
-        {
-            mg.plotNode(g2, n, Color.RED);
-        }
-    }
-}
diff --git a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
index cd452a0e27..635f2f76c4 100644
--- a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
+++ b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
@@ -18,6 +18,7 @@
 package com.graphhopper.ui;
 
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.shapes.BBox;
 import java.awt.BasicStroke;
 import java.awt.Color;
@@ -30,7 +31,8 @@
  */
 public class GraphicsWrapper
 {
-    private Graph g;
+    private final Graph g;
+    private final NodeAccess na;
     private double scaleX;
     private double scaleY;
     private double offsetX;
@@ -40,6 +42,7 @@
     public GraphicsWrapper( Graph g )
     {
         this.g = g;
+        this.na = g.getNodeAccess();
         BBox b = g.getBounds();
         scaleX = scaleY = 0.002 * (b.maxLat - b.minLat);
         offsetY = b.maxLat - 90;
@@ -104,8 +107,8 @@ public double getLat( int y )
 
     public void plotNode( Graphics2D g2, int loc, Color c )
     {
-        double lat = g.getLatitude(loc);
-        double lon = g.getLongitude(loc);
+        double lat = na.getLatitude(loc);
+        double lon = na.getLongitude(loc);
         if (lat < bounds.minLat || lat > bounds.maxLat || lon < bounds.minLon || lon > bounds.maxLon)
         {
             return;
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index e8a751a499..0049944ee0 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -20,15 +20,11 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -41,17 +37,18 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * A rough graphical user interface for visualizing the OSM graph. Mainly for
- * debugging algorithms and spatial datastructures.
+ * A rough graphical user interface for visualizing the OSM graph. Mainly for debugging algorithms
+ * and spatial datastructures.
  * <p/>
  * Use the project at https://github.com/graphhopper/graphhopper-web for a
  * better/faster/userfriendly/... alternative!
  * <p/>
  * @author Peter Karich
  */
-public class MiniGraphUI {
-
-    public static void main(String[] strs) throws Exception {
+public class MiniGraphUI
+{
+    public static void main( String[] strs ) throws Exception
+    {
         CmdArgs args = CmdArgs.read(strs);
         GraphHopper hopper = new GraphHopper().init(args).importOrLoad();
         boolean debug = args.getBool("minigraphui.debug", false);
@@ -59,40 +56,47 @@ public static void main(String[] strs) throws Exception {
     }
     private Logger logger = LoggerFactory.getLogger(getClass());
     private Path path;
-    private AlgorithmPreparation prepare;
+    private RoutingAlgorithmFactory algoFactory;
     private final Graph graph;
-    private LocationIndex index;
+    private final NodeAccess na;
+    private LocationIndexTree index;
     private String latLon = "";
     private GraphicsWrapper mg;
     private JPanel infoPanel;
     private LayeredPanel mainPanel;
     private MapLayer roadsLayer;
-    private MapLayer pathLayer;
+    private final MapLayer pathLayer;
     private boolean fastPaint = false;
-    private Weighting weighting = new ShortestWeighting();
+    private final Weighting weighting;
+    private final FlagEncoder encoder;
+    private AlgorithmOptions algoOpts;
 
-    public MiniGraphUI(GraphHopper hopper, boolean debug) {
+    public MiniGraphUI( GraphHopper hopper, boolean debug )
+    {
         this.graph = hopper.getGraph();
-        prepare = hopper.getPreparation();
-        if (prepare == null)
-            prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph,
-                    "dijkstra", hopper.getEncodingManager().getEncoder("foot"), weighting);
+        this.na = graph.getNodeAccess();
+        algoFactory = hopper.getAlgorithmFactory();
+        encoder = hopper.getEncodingManager().getEncoder("car");
+        weighting = hopper.createWeighting(new WeightingMap("fastest"), encoder);
+        algoOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
 
-        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algo:" + prepare.createAlgo().getName());
+        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algoOpts:" + algoOpts);
         mg = new GraphicsWrapper(graph);
 
         // prepare node quadtree to 'enter' the graph. create a 313*313 grid => <3km
 //         this.index = new DebugLocation2IDQuadtree(roadGraph, mg);
-        this.index = hopper.getLocationIndex();
+        this.index = (LocationIndexTree) hopper.getLocationIndex();
 //        this.algo = new DebugDijkstraBidirection(graph, mg);
         // this.algo = new DijkstraBidirection(graph);
 //        this.algo = new DebugAStar(graph, mg);
 //        this.algo = new AStar(graph);
 //        this.algo = new DijkstraSimple(graph);
 //        this.algo = new DebugDijkstraSimple(graph, mg);
-        infoPanel = new JPanel() {
+        infoPanel = new JPanel()
+        {
             @Override
-            protected void paintComponent(Graphics g) {
+            protected void paintComponent( Graphics g )
+            {
                 g.setColor(Color.WHITE);
                 Rectangle b = infoPanel.getBounds();
                 g.fillRect(0, 0, b.width, b.height);
@@ -110,105 +114,126 @@ protected void paintComponent(Graphics g) {
 
         // TODO make it correct with bitset-skipping too
         final GHBitSet bitset = new GHTBitSet(graph.getNodes());
-        mainPanel.addLayer(roadsLayer = new DefaultMapLayer() {
+        mainPanel.addLayer(roadsLayer = new DefaultMapLayer()
+        {
             Random rand = new Random();
 
             @Override
-            public void paintComponent(Graphics2D g2) {
+            public void paintComponent( Graphics2D g2 )
+            {
                 clearGraphics(g2);
                 int locs = graph.getNodes();
                 Rectangle d = getBounds();
                 BBox b = mg.setBounds(0, d.width, 0, d.height);
-                if (fastPaint) {
+                if (fastPaint)
+                {
                     rand.setSeed(0);
                     bitset.clear();
                 }
 
-                g2.setColor(Color.BLUE);
-
-                double fromLat = 42.56819, fromLon = 1.603231;
-                mg.plotText(g2, fromLat, fromLon, "from");
-                QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
-                double toLat = 42.571034, toLon = 1.520662;
-                mg.plotText(g2, toLat, toLon, "to");
-                QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
-
-                g2.setColor(Color.RED.brighter().brighter());
-                path = prepare.createAlgo().calcPath(from, to);
-                System.out.println("now: " + path.toDetailsString());
-                plotPath(path, g2, 1);
+//                g2.setColor(Color.BLUE);
+//                double fromLat = 42.56819, fromLon = 1.603231;
+//                mg.plotText(g2, fromLat, fromLon, "from");
+//                QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
+//                double toLat = 42.571034, toLon = 1.520662;
+//                mg.plotText(g2, toLat, toLon, "to");
+//                QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
+//
+//                g2.setColor(Color.RED.brighter().brighter());
+//                path = prepare.createAlgo().calcPath(from, to);
+//                System.out.println("now: " + path.toDetailsString());
+//                plotPath(path, g2, 1);
                 g2.setColor(Color.black);
 
                 EdgeExplorer explorer = graph.createEdgeExplorer(EdgeFilter.ALL_EDGES);
-                for (int nodeIndex = 0; nodeIndex < locs; nodeIndex++) {
-                    if (fastPaint && rand.nextInt(30) > 1) {
+                for (int nodeIndex = 0; nodeIndex < locs; nodeIndex++)
+                {
+                    if (fastPaint && rand.nextInt(30) > 1)
                         continue;
-                    }
-                    double lat = graph.getLatitude(nodeIndex);
-                    double lon = graph.getLongitude(nodeIndex);
+                    double lat = na.getLatitude(nodeIndex);
+                    double lon = na.getLongitude(nodeIndex);
+
                     // mg.plotText(g2, lat, lon, "" + nodeIndex);
-                    if (lat < b.minLat || lat > b.maxLat || lon < b.minLon || lon > b.maxLon) {
+                    if (lat < b.minLat || lat > b.maxLat || lon < b.minLon || lon > b.maxLon)
                         continue;
-                    }
 
-                    // accept all
                     EdgeIterator iter = explorer.setBaseNode(nodeIndex);
-//                    {
-//                        @Override public boolean accept(EdgeIterator iter) {
-//                            int flags = iter.flags();
-//                            return footEncoder.isForward(flags);
-//                        }
-//                    });
-                    while (iter.next()) {
+                    while (iter.next())
+                    {
                         int nodeId = iter.getAdjNode();
                         int sum = nodeIndex + nodeId;
-                        if (fastPaint) {
-                            if (bitset.contains(sum)) {
+                        if (fastPaint)
+                        {
+                            if (bitset.contains(sum))
                                 continue;
-                            }
+
                             bitset.add(sum);
                         }
-                        double lat2 = graph.getLatitude(nodeId);
-                        double lon2 = graph.getLongitude(nodeId);
+                        double lat2 = na.getLatitude(nodeId);
+                        double lon2 = na.getLongitude(nodeId);
+
+                        // mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, iter.getName());
+                        //mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, "s:" + (int) encoder.getSpeed(iter.getFlags()));
+                        //g2.setColor(Color.BLACK);                        
                         mg.plotEdge(g2, lat, lon, lat2, lon2);
+                        g2.setColor(Color.BLACK);
                     }
                 }
             }
         });
 
-        mainPanel.addLayer(pathLayer = new DefaultMapLayer() {
+        mainPanel.addLayer(pathLayer = new DefaultMapLayer()
+        {
             @Override
-            public void paintComponent(Graphics2D g2) {
-                if (dijkstraFromId < 0 || dijkstraToId < 0) {
+            public void paintComponent( Graphics2D g2 )
+            {
+                if (fromRes == null || toRes == null)
                     return;
-                }
 
                 makeTransparent(g2);
-                RoutingAlgorithm algo = prepare.createAlgo();
-                if (algo instanceof DebugAlgo) {
+                QueryGraph qGraph = new QueryGraph(graph).lookup(fromRes, toRes);
+                RoutingAlgorithm algo = algoFactory.createAlgo(qGraph, algoOpts);
+                if (algo instanceof DebugAlgo)
+                {
                     ((DebugAlgo) algo).setGraphics2D(g2);
                 }
 
                 StopWatch sw = new StopWatch().start();
-                logger.info("start searching from:" + dijkstraFromId + " to:" + dijkstraToId + " " + weighting);
-                path = algo.calcPath(dijkstraFromId, dijkstraToId);
-//                mg.plotNode(g2, dijkstraFromId, Color.red);
-//                mg.plotNode(g2, dijkstraToId, Color.BLUE);
+                logger.info("start searching from:" + fromRes + " to:" + toRes + " " + weighting);
+
+//                GHPoint qp = fromRes.getQueryPoint();
+//                TIntHashSet set = index.findNetworkEntries(qp.lat, qp.lon, 1);
+//                TIntIterator nodeIter = set.iterator();
+//                DistanceCalc distCalc = new DistancePlaneProjection();
+//                System.out.println("set:" + set.size());
+//                while (nodeIter.hasNext())
+//                {
+//                    int nodeId = nodeIter.next();
+//                    double lat = graph.getNodeAccess().getLat(nodeId);
+//                    double lon = graph.getNodeAccess().getLon(nodeId);
+//                    int dist = (int) Math.round(distCalc.calcDist(qp.lat, qp.lon, lat, lon));
+//                    mg.plotText(g2, lat, lon, nodeId + ": " + dist);
+//                    mg.plotNode(g2, nodeId, Color.red);
+//                }
+                path = algo.calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
                 sw.stop();
 
                 // if directed edges
-                if (!path.isFound()) {
+                if (!path.isFound())
+                {
                     logger.warn("path not found! direction not valid?");
                     return;
                 }
 
-                logger.info("found path in " + sw.getSeconds() + "s with " + path.calcNodes().size() + " nodes: " + path);
+                logger.info("found path in " + sw.getSeconds() + "s with nodes:"
+                        + path.calcNodes().size() + ", millis: " + path.getMillis() + ", " + path);
                 g2.setColor(Color.BLUE.brighter().brighter());
                 plotPath(path, g2, 1);
             }
         });
 
-        if (debug) {
+        if (debug)
+        {
             // disable double buffering for debugging drawing - nice! when do we need DebugGraphics then?
             RepaintManager repaintManager = RepaintManager.currentManager(mainPanel);
             repaintManager.setDoubleBufferingEnabled(false);
@@ -217,7 +242,8 @@ public void paintComponent(Graphics2D g2) {
     }
 
     // for debugging
-    private Path calcPath(RoutingAlgorithm algo) {
+    private Path calcPath( RoutingAlgorithm algo )
+    {
 //        int from = index.findID(50.042, 10.19);
 //        int to = index.findID(50.049, 10.23);
 //
@@ -229,34 +255,42 @@ private Path calcPath(RoutingAlgorithm algo) {
         return algo.calcPath(162810, 35120);
     }
 
-    void plotNodeName(Graphics2D g2, int node) {
-        double lat = graph.getLatitude(node);
-        double lon = graph.getLongitude(node);
+    void plotNodeName( Graphics2D g2, int node )
+    {
+        double lat = na.getLatitude(node);
+        double lon = na.getLongitude(node);
         mg.plotText(g2, lat, lon, "" + node);
     }
 
-    private Path plotPath(Path tmpPath, Graphics2D g2, int w) {
-        if (!tmpPath.isFound()) {
+    private Path plotPath( Path tmpPath, Graphics2D g2, int w )
+    {
+        if (!tmpPath.isFound())
+        {
             logger.info("nothing found " + w);
             return tmpPath;
         }
 
         double prevLat = Double.NaN;
         double prevLon = Double.NaN;
-        boolean plotNodes = true;
+        boolean plotNodes = false;
         TIntList nodes = tmpPath.calcNodes();
-        if (plotNodes) {
-            for (int i = 0; i < nodes.size(); i++) {
+        if (plotNodes)
+        {
+            for (int i = 0; i < nodes.size(); i++)
+            {
                 plotNodeName(g2, nodes.get(i));
             }
         }
         PointList list = tmpPath.calcPoints();
-        for (int i = 0; i < list.getSize(); i++) {
+        for (int i = 0; i < list.getSize(); i++)
+        {
             double lat = list.getLatitude(i);
             double lon = list.getLongitude(i);
-            if (!Double.isNaN(prevLat)) {
+            if (!Double.isNaN(prevLat))
+            {
                 mg.plotEdge(g2, prevLat, prevLon, lat, lon, w);
-            } else {
+            } else
+            {
                 mg.plot(g2, lat, lon, w);
             }
             prevLat = lat;
@@ -265,14 +299,18 @@ private Path plotPath(Path tmpPath, Graphics2D g2, int w) {
         logger.info("dist:" + tmpPath.getDistance() + ", path points(" + list.getSize() + "):" + list + ", nodes:" + nodes);
         return tmpPath;
     }
-    private int dijkstraFromId = -1;
-    private int dijkstraToId = -1;
-
-    public void visualize() {
-        try {
-            SwingUtilities.invokeAndWait(new Runnable() {
+    private QueryResult fromRes;
+    private QueryResult toRes;
+
+    public void visualize()
+    {
+        try
+        {
+            SwingUtilities.invokeAndWait(new Runnable()
+            {
                 @Override
-                public void run() {
+                public void run()
+                {
                     int frameHeight = 800;
                     int frameWidth = 1200;
                     JFrame frame = new JFrame("GraphHopper UI - Small&Ugly ;)");
@@ -283,9 +321,11 @@ public void run() {
                     infoPanel.setPreferredSize(new Dimension(300, 100));
 
                     // scale
-                    mainPanel.addMouseWheelListener(new MouseWheelListener() {
+                    mainPanel.addMouseWheelListener(new MouseWheelListener()
+                    {
                         @Override
-                        public void mouseWheelMoved(MouseWheelEvent e) {
+                        public void mouseWheelMoved( MouseWheelEvent e )
+                        {
                             mg.scale(e.getX(), e.getY(), e.getWheelRotation() < 0);
                             repaintRoads();
                         }
@@ -309,26 +349,30 @@ public void mouseWheelMoved(MouseWheelEvent e) {
 //                            updateLatLon(e);
 //                        }
 //                    };
-                    MouseAdapter ml = new MouseAdapter() {
+                    MouseAdapter ml = new MouseAdapter()
+                    {
                         // for routing:
                         double fromLat, fromLon;
                         boolean fromDone = false;
 
                         @Override
-                        public void mouseClicked(MouseEvent e) {
-                            if (!fromDone) {
+                        public void mouseClicked( MouseEvent e )
+                        {
+                            if (!fromDone)
+                            {
                                 fromLat = mg.getLat(e.getY());
                                 fromLon = mg.getLon(e.getX());
-                            } else {
+                            } else
+                            {
                                 double toLat = mg.getLat(e.getY());
                                 double toLon = mg.getLon(e.getX());
                                 StopWatch sw = new StopWatch().start();
                                 logger.info("start searching from " + fromLat + "," + fromLon
                                         + " to " + toLat + "," + toLon);
                                 // get from and to node id
-                                dijkstraFromId = index.findID(fromLat, fromLon);
-                                dijkstraToId = index.findID(toLat, toLon);
-                                logger.info("found ids " + dijkstraFromId + " -> " + dijkstraToId + " in " + sw.stop().getSeconds() + "s");
+                                fromRes = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
+                                toRes = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
+                                logger.info("found ids " + fromRes + " -> " + toRes + " in " + sw.stop().getSeconds() + "s");
 
                                 repaintPaths();
                             }
@@ -338,7 +382,8 @@ public void mouseClicked(MouseEvent e) {
                         boolean dragging = false;
 
                         @Override
-                        public void mouseDragged(MouseEvent e) {
+                        public void mouseDragged( MouseEvent e )
+                        {
                             dragging = true;
                             fastPaint = true;
                             update(e);
@@ -346,8 +391,10 @@ public void mouseDragged(MouseEvent e) {
                         }
 
                         @Override
-                        public void mouseReleased(MouseEvent e) {
-                            if (dragging) {
+                        public void mouseReleased( MouseEvent e )
+                        {
+                            if (dragging)
+                            {
                                 // update only if mouse release comes from dragging! (at the moment equal to fastPaint)
                                 dragging = false;
                                 fastPaint = false;
@@ -355,18 +402,21 @@ public void mouseReleased(MouseEvent e) {
                             }
                         }
 
-                        public void update(MouseEvent e) {
+                        public void update( MouseEvent e )
+                        {
                             mg.setNewOffset(e.getX() - currentPosX, e.getY() - currentPosY);
                             repaintRoads();
                         }
 
                         @Override
-                        public void mouseMoved(MouseEvent e) {
+                        public void mouseMoved( MouseEvent e )
+                        {
                             updateLatLon(e);
                         }
 
                         @Override
-                        public void mousePressed(MouseEvent e) {
+                        public void mousePressed( MouseEvent e )
+                        {
                             updateLatLon(e);
                         }
                     };
@@ -394,7 +444,8 @@ public void mousePressed(MouseEvent e) {
                     frame.setVisible(true);
                 }
             });
-        } catch (Exception ex) {
+        } catch (Exception ex)
+        {
             throw new RuntimeException(ex);
         }
     }
@@ -402,19 +453,22 @@ public void mousePressed(MouseEvent e) {
     int currentPosX;
     int currentPosY;
 
-    void updateLatLon(MouseEvent e) {
+    void updateLatLon( MouseEvent e )
+    {
         latLon = mg.getLat(e.getY()) + "," + mg.getLon(e.getX());
         infoPanel.repaint();
         currentPosX = e.getX();
         currentPosY = e.getY();
     }
 
-    void repaintPaths() {
+    void repaintPaths()
+    {
         pathLayer.repaint();
         mainPanel.repaint();
     }
 
-    void repaintRoads() {
+    void repaintRoads()
+    {
         // avoid threading as there should be no updated to scale or offset while painting 
         // (would to lead to artifacts)
         StopWatch sw = new StopWatch().start();
diff --git a/tools/src/main/resources/log4j.xml b/tools/src/main/resources/log4j.xml
new file mode 100644
index 0000000000..01cc086902
--- /dev/null
+++ b/tools/src/main/resources/log4j.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration>
+    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
+        </layout>
+    </appender>
+    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
+        <param name="BufferSize" value="500"/>
+        <appender-ref ref="stdout"/>
+    </appender>   
+    <logger name="com.graphhopper" additivity="false">
+        <level value="info" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <!-- order important otherwise we'll get a warning -->
+    <root>
+        <priority value="warn"></priority>
+        <appender-ref ref="ASYNC"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/util/QueryTortureTest.java b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
similarity index 92%
rename from core/src/test/java/com/graphhopper/util/QueryTortureTest.java
rename to tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
index bb5bee81be..fa5d018259 100644
--- a/core/src/test/java/com/graphhopper/util/QueryTortureTest.java
+++ b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
@@ -15,9 +15,9 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.tools;
 
-import com.graphhopper.util.QueryTorture.Query;
+import com.graphhopper.tools.QueryTorture.Query;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -31,7 +31,7 @@
     public void testGetQuery()
     {
         Query result = Query.parse("2013-08-07 18:06:50,905 [qtp1329318374-81] INFO  graphhopper.http.GraphHopperServlet - point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp 46.4.67.134 en_US Wget/1.13.4 (linux-gnu) 51.076329, 13.738409->52.517037, 13.38886, distance: 189.4806800000001, time:123min, points:907, took:0.007393159, debug - idLookup:0.002483692s, algoInit:1.20837E-4s, dijkstraCH-routing:0.003138361s, extract time:1.66755E-4, simplify (1219->907):0.001040086s, instructions:2.26986E-4s, dijkstrabi, fastest, CAR");
-        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.queryString);
+        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.createQueryString());
         assertEquals(51.076329, result.start.lat, 1e-5);
         assertEquals(13.38886, result.end.lon, 1e-5);
     }
diff --git a/web/Readme.md b/web/Readme.md
deleted file mode 100644
index 83570d51d2..0000000000
--- a/web/Readme.md
+++ /dev/null
@@ -1,5 +0,0 @@
-This application uses jQuery and Leaflet to display the calculated route from GraphHopper.
-Execute `./graphhopper.sh web europe_germany_berlin.osm` in the parent folder. Then go to [http://localhost:8989/](http://localhost:8989/).
-Get the raw json query [here](http://localhost:8989/api/route?from=52.439688,13.276863&to=52.532932,13.479424)
-
-[![GraphHopper Maps image](http://karussell.files.wordpress.com/2013/07/maps-preview1.png)](http://graphhopper.com/maps/?point=new%20york&point=los%20angeles)
\ No newline at end of file
diff --git a/web/nb-configuration.xml b/web/nb-configuration.xml
index d07afc98fa..a40fe01b7d 100644
--- a/web/nb-configuration.xml
+++ b/web/nb-configuration.xml
@@ -13,6 +13,6 @@
         That way multiple projects can share the same settings (useful for formatting rules for example).
         Any value defined here will override the pom.xml file value but is only applicable to the current project.
         -->
-        <netbeans.compile.on.save>all</netbeans.compile.on.save>      
+        <netbeans.compile.on.save>all</netbeans.compile.on.save>
     </properties>
 </project-shared-configuration>
diff --git a/web/nbactions.xml b/web/nbactions.xml
index 93150a5202..53ff82d694 100644
--- a/web/nbactions.xml
+++ b/web/nbactions.xml
@@ -1,36 +1,64 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <actions>
     <action>
-        <actionName>CUSTOM-jetty:run</actionName>
-        <displayName>jetty:run</displayName>
+        <actionName>CUSTOM-install</actionName>
+        <displayName>install</displayName>
         <goals>
-            <goal>jetty:run</goal>
+            <goal>install</goal>
         </goals>
         <properties>
-            <maven.test.skip>true</maven.test.skip>
-            <!-- for germany we need roughly 500MB -->
-            <Env.MAVEN_OPTS>-Djetty.port=8989 -Dgraphhopper.config=../config.properties -Dgraphhopper.osmreader.osm=/media/SAMSUNG/maps/berlin.pbf -Xms1500m -Xms1500m -XX:PermSize=50m -XX:MaxPermSize=50m</Env.MAVEN_OPTS>
+            <skipTests>true</skipTests>
         </properties>
     </action>
     <action>
-        <actionName>CUSTOM-jetty:run debug</actionName>
-        <displayName>jetty:run debug</displayName>
+        <actionName>CUSTOM-failsafe verify</actionName>
+        <displayName>failsafe verify</displayName>
         <goals>
-            <goal>jetty:run</goal>
+            <goal>failsafe:integration-test</goal>
+            <goal>verify</goal>
+        </goals>
+    </action>
+    <action>
+        <actionName>run</actionName>
+        <packagings>
+            <packaging>jar</packaging>
+        </packagings>
+        <goals>
+            <goal>process-classes</goal>
+            <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
         </goals>
-        
         <properties>
-            <maven.test.skip>true</maven.test.skip>
-            <!-- for germany we need a bit more RAM -->
-            <Env.MAVEN_OPTS>-Djetty.port=8989 -Dgraphhopper.config=../config.properties -Dgraphhopper.osmreader.osm=/media/SAMSUNG/maps/berlin.pbf -Xms1500m -Xms1500m -XX:PermSize=50m -XX:MaxPermSize=50m -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000</Env.MAVEN_OPTS>
+            <exec.args>-classpath %classpath com.graphhopper.http.GHServer graph.elevation.cachedir=../srtmprovider jetty.port=8989 config=../config.properties osmreader.osm=../europe_germany_berlin.pbf</exec.args>
+            <exec.executable>java</exec.executable>
         </properties>
     </action>
     <action>
-            <actionName>CUSTOM-failsafe verify</actionName>
-            <displayName>failsafe verify</displayName>
-            <goals>
-                <goal>failsafe:integration-test</goal>
-                <goal>verify</goal>
-            </goals>
-        </action>
+        <actionName>debug</actionName>
+        <packagings>
+            <packaging>jar</packaging>
+        </packagings>
+        <goals>
+            <goal>process-classes</goal>
+            <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
+        </goals>
+        <properties>
+            <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.graphhopper.http.GHServer graph.elevation.cachedir=../srtmprovider jetty.port=8989 config=../config.properties osmreader.osm=../europe_germany_berlin.pbf</exec.args>
+            <exec.executable>java</exec.executable>
+            <jpda.listen>true</jpda.listen>
+        </properties>
+    </action>
+    <action>
+        <actionName>profile</actionName>
+        <packagings>
+            <packaging>jar</packaging>
+        </packagings>
+        <goals>
+            <goal>process-classes</goal>
+            <goal>org.codehaus.mojo:exec-maven-plugin:1.2.1:exec</goal>
+        </goals>
+        <properties>
+            <exec.args>-classpath %classpath com.graphhopper.http.GHServer graph.elevation.cachedir=../srtmprovider jetty.port=8989 config=../config.properties osmreader.osm=../europe_germany_berlin.pbf</exec.args>
+            <exec.executable>java</exec.executable>
+        </properties>
+    </action>
 </actions>
diff --git a/web/pom.xml b/web/pom.xml
index a739d22359..8600391382 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -5,18 +5,18 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web</artifactId>
-    <packaging>war</packaging>
-    <version>0.3-SNAPSHOT</version>
+    <packaging>jar</packaging>
+    <version>0.5-SNAPSHOT</version>
     <name>GraphHopper Web</name>
     <description>Example on how to use GraphHopper in a web-based application</description>
         
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.3-SNAPSHOT</version>
+        <version>0.5-SNAPSHOT</version>
     </parent>
     <properties>
-        <jetty.version>8.1.10.v20130312</jetty.version>
+        <jetty.version>8.1.16.v20140903</jetty.version>
     </properties>
     
     <dependencies>
@@ -25,21 +25,13 @@
             <artifactId>graphhopper</artifactId>
             <version>${project.parent.version}</version>            
         </dependency>
-        <!--  TODO <dependency>
-            <groupId>org.codehaus.jackson</groupId>
-            <artifactId>jackson-core-asl</artifactId>
-            <version>1.9.12</version>
-        </dependency>       
-        <dependency>
-            <groupId>org.codehaus.jackson</groupId>
-            <artifactId>jackson-mapper-asl</artifactId>
-            <version>1.9.12</version>
-        </dependency>-->
+        
         <dependency>
             <groupId>org.json</groupId>
-            <artifactId>json</artifactId>
-            <version>20090211</version>            
-        </dependency>        
+            <artifactId>json</artifactId>            
+            <version>20140107</version>
+        </dependency>    
+        
         <dependency>
             <groupId>com.google.inject</groupId>
             <artifactId>guice</artifactId>
@@ -52,11 +44,11 @@
             <artifactId>guice-servlet</artifactId>
             <version>3.0</version>
         </dependency>
-        
+                
         <dependency>
             <groupId>javax.servlet</groupId>
             <artifactId>javax.servlet-api</artifactId>
-            <version>3.0.1</version>
+            <version>3.1.0</version>
             <scope>provided</scope>
         </dependency>
         <dependency>
@@ -84,58 +76,64 @@
             <version>${jetty.version}</version>
         </dependency>
         
-        <!-- for integration tests of service -->
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-webapp</artifactId>
+            <artifactId>jetty-server</artifactId>
+            <version>${jetty.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-servlet</artifactId>
             <version>${jetty.version}</version>
-            <scope>test</scope>
         </dependency>
-        <!--
+        
+        <!-- for integration tests of service -->
         <dependency>
-            <groupId>org.apache.httpcomponents</groupId>
-            <artifactId>httpclient</artifactId>
-            <version>4.2.5</version>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-webapp</artifactId>
+            <version>${jetty.version}</version>
             <scope>test</scope>
         </dependency>
-        -->
+      
     </dependencies>
 
     <build>
         <plugins>
+            <!-- create a jar file too, so others can use it more easily -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.14</version>
-            </plugin>
-            <plugin>
-                <groupId>org.mortbay.jetty</groupId>
-                <artifactId>jetty-maven-plugin</artifactId>
-                <version>${jetty.version}</version>
+                <artifactId>maven-war-plugin</artifactId>                
                 <configuration>
-                    <!--
-                    <connectors>
-                        <connector implementation="org.eclipse.jetty.server.nio.SelectChannelConnector">	
-                            <port>8989</port>
-                        </connector>
-                    </connectors>
-                    -->
-                                        
-                    <!-- to be used in combination with netbeans compile on save feature -->
-                    <scanTargets>
-                        <scanTarget>target/classes/</scanTarget>
-                    </scanTargets>
-                    <scanIntervalSeconds>1</scanIntervalSeconds>
+                    <attachClasses>true</attachClasses>
                 </configuration>
-            </plugin>
-            <!-- create a jar file too, so others can use it more easily -->
+            </plugin>            
             <plugin>
-                <artifactId>maven-war-plugin</artifactId>
-                <version>2.4</version>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-assembly-plugin</artifactId>
                 <configuration>
-                    <attachClasses>true</attachClasses>
+                    <archive>
+                        <manifest>
+                            <mainClass>com.graphhopper.http.GHServer</mainClass>
+                        </manifest>
+                    </archive>
+                    <descriptors>
+                        <descriptor>src/main/assembly/jar.xml</descriptor>
+                        <!-- this is defined to be executed afterwards -->
+                        <descriptor>src/main/assembly/zip.xml</descriptor>
+                    </descriptors>
                 </configuration>
+                <executions>
+                    <execution>
+                        <id>make-assembly</id>
+                        <!-- bind to verify and not package to pass integration tests before creating assemblies -->
+                        <phase>integration-test</phase> 
+                       <goals>
+                            <goal>single</goal>
+                        </goals>
+                    </execution>
+                </executions>
             </plugin>
+ 
         </plugins>
     </build>
 
diff --git a/web/src/main/assembly/jar.xml b/web/src/main/assembly/jar.xml
new file mode 100644
index 0000000000..9deb284f62
--- /dev/null
+++ b/web/src/main/assembly/jar.xml
@@ -0,0 +1,39 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied.  See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+
+<!-- START SNIPPET: jar-with-dependencies -->
+<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/${mdoVersion}" 
+          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+          xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/${mdoVersion} http://maven.apache.org/xsd/assembly-${mdoVersion}.xsd">
+    <id>with-dep</id>
+    <formats>
+        <format>jar</format>
+    </formats>
+    <includeBaseDirectory>false</includeBaseDirectory>
+    <dependencySets>
+        <dependencySet>
+            <outputDirectory>/</outputDirectory>
+            <useProjectArtifact>true</useProjectArtifact>
+            <unpack>true</unpack>
+            <scope>runtime</scope>
+        </dependencySet>
+    </dependencySets>
+</assembly>
+<!-- END SNIPPET: jar-with-dependencies -->
diff --git a/web/src/main/assembly/zip.xml b/web/src/main/assembly/zip.xml
new file mode 100644
index 0000000000..128b9a092b
--- /dev/null
+++ b/web/src/main/assembly/zip.xml
@@ -0,0 +1,35 @@
+<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0"
+          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+          xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd">
+    <id>bin</id>
+    <formats>
+        <format>zip</format>
+    </formats>
+    <includeBaseDirectory>false</includeBaseDirectory>
+    <fileSets>
+        <fileSet>
+            <directory>${project.basedir}/src/main/</directory>
+            <outputDirectory/>
+            <includes>
+                <include>webapp/**</include>
+            </includes>
+        </fileSet>
+        <fileSet>
+            <directory>${project.basedir}/..</directory>
+            <outputDirectory/>
+            <includes>
+                <include>NOTICE*</include>
+                <include>LICENSE*</include>
+                <include>CONTRIBUTORS*</include>
+                <include>config-example.properties</include>
+            </includes>
+        </fileSet>
+        <fileSet>
+            <directory>${project.build.directory}</directory>
+            <outputDirectory/>
+            <includes>
+                <include>*-with-dep.jar</include>
+            </includes>
+        </fileSet>
+    </fileSets>
+</assembly>
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionTest.java b/web/src/main/java/com/graphhopper/http/CORSFilter.java
similarity index 52%
rename from core/src/test/java/com/graphhopper/routing/DijkstraBidirectionTest.java
rename to web/src/main/java/com/graphhopper/http/CORSFilter.java
index 726885a637..c29d7c55f9 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionTest.java
+++ b/web/src/main/java/com/graphhopper/http/CORSFilter.java
@@ -1,40 +1,45 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing;
+package com.graphhopper.http;
 
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.Graph;
+import java.io.IOException;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletResponse;
+import org.eclipse.jetty.servlets.UserAgentFilter;
 
 /**
  * @author Peter Karich
  */
-public class DijkstraBidirectionTest extends AbstractRoutingAlgorithmTester
+public class CORSFilter extends UserAgentFilter
 {
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public void doFilter( ServletRequest request, ServletResponse response, FilterChain chain ) throws IOException, ServletException
     {
-        return new NoOpAlgorithmPreparation()
+        if (!"jsonp".equals(request.getParameter("type")))
         {
-            @Override
-            public RoutingAlgorithm createAlgo()
-            {
-                return new DijkstraBidirection(_graph, encoder, w);
-            }
-        }.setGraph(defaultGraph);
+            HttpServletResponse rsp = (HttpServletResponse) response;
+            rsp.setHeader("Access-Control-Allow-Origin", "*");
+        }
+
+        super.doFilter(request, response, chain);
     }
+
 }
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/DefaultModule.java
index a8c9ef669c..7829d78286 100644
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/DefaultModule.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.search.Geocoding;
 import com.google.inject.AbstractModule;
 import com.google.inject.name.Names;
 import com.graphhopper.GraphHopper;
@@ -31,34 +30,53 @@
  */
 public class DefaultModule extends AbstractModule
 {
-    private Logger logger = LoggerFactory.getLogger(getClass());
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    protected final CmdArgs args;
+    private GraphHopper graphHopper;
+
+    public DefaultModule( CmdArgs args )
+    {
+        this.args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
+    }
+
+    public GraphHopper getGraphHopper()
+    {
+        if (graphHopper == null)
+            throw new IllegalStateException("createGraphHopper not called");
+
+        return graphHopper;
+    }
+
+    /**
+     * @return an initialized GraphHopper instance
+     */
+    protected GraphHopper createGraphHopper( CmdArgs args )
+    {
+        GraphHopper tmp = new GraphHopper().forServer().init(args);
+        tmp.importOrLoad();
+        logger.info("loaded graph at:" + tmp.getGraphHopperLocation()
+                + ", source:" + tmp.getOSMFile()
+                + ", flagEncoders:" + tmp.getEncodingManager()
+                + ", class:" + tmp.getGraph().getClass().getSimpleName());
+        return tmp;
+    }
 
     @Override
     protected void configure()
     {
         try
         {
-            CmdArgs args = CmdArgs.readFromConfig("config.properties", "graphhopper.config");
-            GraphHopper hopper = new GraphHopper().forServer().init(args);
-            hopper.importOrLoad();
-            logger.info("loaded graph at:" + hopper.getGraphHopperLocation()
-                    + ", source:" + hopper.getOSMFile()
-                    + ", acceptWay:" + hopper.getEncodingManager()
-                    + ", class:" + hopper.getGraph().getClass().getSimpleName());
-
-            bind(GraphHopper.class).toInstance(hopper);
-
-            String algo = args.get("routing.defaultAlgorithm", "dijkstrabi");
-            bind(String.class).annotatedWith(Names.named("defaultAlgorithm")).toInstance(algo);
+            graphHopper = createGraphHopper(args);
+            bind(GraphHopper.class).toInstance(graphHopper);
+            bind(TranslationMap.class).toInstance(graphHopper.getTranslationMap());
 
             long timeout = args.getLong("web.timeout", 3000);
             bind(Long.class).annotatedWith(Names.named("timeout")).toInstance(timeout);
-            bind(Geocoding.class).toInstance(new NominatimGeocoder().
-                    setTimeout((int) timeout).
-                    setBounds(hopper.getGraph().getBounds()));
-            bind(GHThreadPool.class).toInstance(new GHThreadPool(1000, 50).startService());
+            boolean jsonpAllowed = args.getBool("web.jsonpAllowed", false);
+            if (!jsonpAllowed)
+                logger.info("jsonp disabled");
 
-            bind(TranslationMap.class).toInstance(new TranslationMap().doImport());
+            bind(Boolean.class).annotatedWith(Names.named("jsonpAllowed")).toInstance(jsonpAllowed);
         } catch (Exception ex)
         {
             throw new IllegalStateException("Couldn't load graph", ex);
diff --git a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
index 276c86db2e..07fe5d9f38 100644
--- a/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GHBaseServlet.java
@@ -18,6 +18,8 @@
 package com.graphhopper.http;
 
 import java.io.IOException;
+import javax.inject.Named;
+import javax.inject.Inject;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
@@ -33,8 +35,11 @@
 public class GHBaseServlet extends HttpServlet
 {
     protected Logger logger = LoggerFactory.getLogger(getClass());
+    @Inject
+    @Named("jsonpAllowed")
+    private boolean jsonpAllowed;
 
-    protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONObject json ) throws JSONException
+    protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONObject json ) throws JSONException, IOException
     {
         String type = getParam(req, "type", "json");
         res.setCharacterEncoding("UTF-8");
@@ -42,7 +47,19 @@ protected void writeJson( HttpServletRequest req, HttpServletResponse res, JSONO
         if ("jsonp".equals(type))
         {
             res.setContentType("application/javascript");
+            if (!jsonpAllowed)
+            {
+                res.sendError(SC_BAD_REQUEST, "Server is not configured to allow jsonp!");
+                return;
+            }
+
             String callbackName = getParam(req, "callback", null);
+            if (callbackName == null)
+            {
+                res.sendError(SC_BAD_REQUEST, "No callback provided, necessary if type=jsonp");
+                return;
+            }
+
             if (debug)
             {
                 writeResponse(res, callbackName + "(" + json.toString(2) + ")");
diff --git a/web/src/main/java/com/graphhopper/http/MyGZIPHook.java b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
similarity index 97%
rename from web/src/main/java/com/graphhopper/http/MyGZIPHook.java
rename to web/src/main/java/com/graphhopper/http/GHGZIPHook.java
index 70668ecd55..828684f0d1 100644
--- a/web/src/main/java/com/graphhopper/http/MyGZIPHook.java
+++ b/web/src/main/java/com/graphhopper/http/GHGZIPHook.java
@@ -31,7 +31,7 @@
  * <p/>
  * @author Peter Karich
  */
-public class MyGZIPHook extends GzipFilter
+public class GHGZIPHook extends GzipFilter
 {
     private Logger logger = LoggerFactory.getLogger(getClass());
 
diff --git a/web/src/main/java/com/graphhopper/http/GHServer.java b/web/src/main/java/com/graphhopper/http/GHServer.java
new file mode 100644
index 0000000000..4a749c50ad
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GHServer.java
@@ -0,0 +1,135 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.google.inject.AbstractModule;
+import com.google.inject.Guice;
+import com.google.inject.Injector;
+import com.google.inject.Module;
+import com.google.inject.servlet.GuiceFilter;
+import com.graphhopper.util.CmdArgs;
+import java.net.InetSocketAddress;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.servlet.ServletHolder;
+
+import java.util.EnumSet;
+import javax.servlet.DispatcherType;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.handler.HandlerList;
+import org.eclipse.jetty.server.handler.ResourceHandler;
+import org.eclipse.jetty.server.nio.SelectChannelConnector;
+import org.eclipse.jetty.servlet.FilterHolder;
+import org.eclipse.jetty.servlet.ServletContextHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Simple server similar to integration tests setup.
+ */
+public class GHServer
+{
+    public static void main( String[] args ) throws Exception
+    {
+        new GHServer(CmdArgs.read(args)).start();
+    }
+
+    private final CmdArgs args;
+    private Server server;
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+
+    public GHServer( CmdArgs args )
+    {
+        this.args = args;
+    }
+
+    public void start() throws Exception
+    {
+        Injector injector = Guice.createInjector(createModule());
+        start(injector);
+    }
+
+    public void start( Injector injector ) throws Exception
+    {
+        ResourceHandler resHandler = new ResourceHandler();
+        resHandler.setDirectoriesListed(false);
+        resHandler.setWelcomeFiles(new String[]
+        {
+            "index.html"
+        });
+        resHandler.setResourceBase(args.get("jetty.resourcebase", "./src/main/webapp"));
+
+        server = new Server();
+        // getSessionHandler and getSecurityHandler should always return null
+        ServletContextHandler servHandler = new ServletContextHandler(ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);
+        servHandler.setContextPath("/");
+
+        servHandler.addServlet(new ServletHolder(new InvalidRequestServlet()), "/*");
+
+        FilterHolder guiceFilter = new FilterHolder(injector.getInstance(GuiceFilter.class));
+        servHandler.addFilter(guiceFilter, "/*", EnumSet.allOf(DispatcherType.class));
+
+        SelectChannelConnector connector0 = new SelectChannelConnector();
+        int httpPort = args.getInt("jetty.port", 8989);
+        String host = args.get("jetty.host", "");
+        connector0.setPort(httpPort);
+        if (!host.isEmpty())
+            connector0.setHost(host);
+
+        server.addConnector(connector0);
+
+        HandlerList handlers = new HandlerList();
+        handlers.setHandlers(new Handler[]
+        {
+            resHandler, servHandler
+        });
+        server.setHandler(handlers);
+        server.start();
+        logger.info("Started server at HTTP " + host + ":" + httpPort);
+    }
+
+    protected Module createModule()
+    {
+        return new AbstractModule()
+        {
+            @Override
+            protected void configure()
+            {
+                binder().requireExplicitBindings();
+
+                install(new DefaultModule(args));
+                install(new GHServletModule(args));
+
+                bind(GuiceFilter.class);
+            }
+        };
+    }
+
+    public void stop()
+    {
+        if (server == null)
+            return;
+
+        try
+        {
+            server.stop();
+        } catch (Exception ex)
+        {
+            logger.error("Cannot stop jetty", ex);
+        }
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
new file mode 100644
index 0000000000..76c04d1493
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -0,0 +1,68 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.google.inject.servlet.ServletModule;
+import com.graphhopper.util.CmdArgs;
+import java.util.HashMap;
+import java.util.Map;
+import javax.inject.Singleton;
+
+/**
+ * @author Peter Karich
+ */
+public class GHServletModule extends ServletModule
+{
+    protected Map<String, String> params = new HashMap<String, String>();
+    protected final CmdArgs args;
+
+    public GHServletModule( CmdArgs args )
+    {
+        this.args = args;
+        params.put("mimeTypes", "text/html,"
+                + "text/plain,"
+                + "text/xml,"
+                + "application/xhtml+xml,"
+                + "text/css,"
+                + "application/json,"
+                + "application/javascript,"
+                + "image/svg+xml");
+    }
+
+    @Override
+    protected void configureServlets()
+    {
+        filter("*").through(GHGZIPHook.class, params);
+        bind(GHGZIPHook.class).in(Singleton.class);
+
+        filter("*").through(CORSFilter.class, params);
+        bind(CORSFilter.class).in(Singleton.class);
+
+        filter("*").through(IPFilter.class);
+        bind(IPFilter.class).toInstance(new IPFilter(args.get("jetty.whiteips", ""), args.get("jetty.blackips", "")));
+
+        serve("/i18n*").with(I18NServlet.class);
+        bind(I18NServlet.class).in(Singleton.class);
+
+        serve("/info*").with(InfoServlet.class);
+        bind(InfoServlet.class).in(Singleton.class);
+
+        serve("/route*").with(GraphHopperServlet.class);
+        bind(GraphHopperServlet.class).in(Singleton.class);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GHThreadPool.java b/web/src/main/java/com/graphhopper/http/GHThreadPool.java
deleted file mode 100644
index 96fb6ded3d..0000000000
--- a/web/src/main/java/com/graphhopper/http/GHThreadPool.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.http;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.RejectedExecutionException;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * @author Peter Karich
- */
-public class GHThreadPool
-{
-    private Logger logger = LoggerFactory.getLogger(getClass());
-    private final ExecutorService service;
-    private final int threads;
-    private BlockingQueue<GHWorker> resolverQueue;
-
-    public GHThreadPool( int queueSize, int threads )
-    {
-        resolverQueue = new LinkedBlockingQueue<GHWorker>(queueSize);
-        this.threads = threads;
-        service = Executors.newFixedThreadPool(threads);
-    }
-
-    /**
-     * Starts this thread pool in background
-     */
-    public GHThreadPool startService()
-    {
-        new Thread("ThreadPool Service Executor")
-        {
-            @Override
-            public void run()
-            {
-                Collection<Callable<Object>> callableCollection = new ArrayList<Callable<Object>>(threads);
-                for (int i = 0; i < threads; i++)
-                {
-                    final int threadNo = i;
-                    callableCollection.add(new Callable<Object>()
-                    {
-                        @Override
-                        public Object call() throws Exception
-                        {
-                            try
-                            {
-                                while (!isInterrupted())
-                                {
-                                    execute(threadNo);
-                                }
-                            } catch (InterruptedException ex)
-                            {
-                                logger.debug(getName() + " - thread " + threadNo + " interrupted. Error: " + ex.getMessage());
-                            } catch (Throwable ex)
-                            {
-                                logger.error(getName() + " - thread " + threadNo + " died", ex);
-                            }
-                            return null;
-                        }
-                    });
-                }
-                try
-                {
-                    logger.info(getName() + " STARTED");
-                    service.invokeAll(callableCollection);
-                    logger.info(getName() + " FINISHED");
-                } catch (RejectedExecutionException ex)
-                {
-                    logger.info(getName() + " cannot create threads, " + ex.getMessage());
-                } catch (InterruptedException ex)
-                {
-                    logger.info(getName() + " was interrupted, " + ex.getMessage());
-                }
-            }
-        }.start();
-        return this;
-    }
-
-    public void enqueue( GHWorker worker )
-    {
-        if (!resolverQueue.offer(worker.doEnqueue()))
-        {
-            logger.error("Queue full!? " + resolverQueue.size() + " couldn't enqueue " + worker);
-        }
-    }
-
-    protected void execute( int workerNo ) throws InterruptedException
-    {
-        GHWorker worker = resolverQueue.take();
-        try
-        {
-            if (!worker.isTimedOut())
-            {
-                worker.run();
-            } else
-            {
-                logger.warn(worker + " timed out - maximum livetime reached (" + worker.maxLiveTimeInMillis + ")");
-            }
-        } catch (Exception ex)
-        {
-            logger.warn(workerNo + " Error for worker " + worker + ", error:" + ex.getMessage());
-        }
-        worker.finish();
-    }
-
-    public void stopService()
-    {
-        service.shutdown();
-    }
-
-    public void waitFor( List<GHWorker> workers, long timeOutInMillis )
-    {
-        long remainingTimeout = timeOutInMillis;
-        try
-        {
-            for (GHWorker w : workers)
-            {
-                long tmp = System.currentTimeMillis();
-                synchronized (w)
-                {
-                    w.wait(timeOutInMillis);
-                }
-                remainingTimeout -= (System.currentTimeMillis() - tmp);
-                if (remainingTimeout < 10)
-                {
-                    break;
-                }
-            }
-        } catch (InterruptedException ex)
-        {
-            logger.warn("workers were interrupted " + workers);
-        }
-    }
-
-    public static abstract class GHWorker implements Runnable
-    {
-        private long maxLiveTimeInMillis = 5000;
-        private long startTime = -1;
-
-        public GHWorker( long maxLiveTimeInMillis )
-        {
-            this.maxLiveTimeInMillis = maxLiveTimeInMillis;
-        }
-
-        private GHWorker doEnqueue()
-        {
-            startTime = System.currentTimeMillis();
-            return this;
-        }
-
-        private boolean isTimedOut()
-        {
-            if (startTime < 0)
-            {
-                throw new IllegalStateException("Call doEnqueue before");
-            }
-            return (System.currentTimeMillis() - startTime) > maxLiveTimeInMillis;
-        }
-
-        public abstract String getName();
-
-        @Override
-        public String toString()
-        {
-            return getName();
-        }
-
-        private void finish()
-        {
-            synchronized (this)
-            {
-                notifyAll();
-            }
-        }
-    }
-}
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 7b7e904d00..e4dd2bc3f1 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -17,277 +17,260 @@
  */
 package com.graphhopper.http;
 
-import com.graphhopper.search.Geocoding;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.*;
-import com.graphhopper.util.TranslationMap.Translation;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.util.shapes.GHPoint;
 import java.io.IOException;
+import java.io.StringWriter;
 import java.util.*;
+import java.util.Map.Entry;
 import javax.inject.Inject;
-import javax.inject.Named;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import static javax.servlet.http.HttpServletResponse.*;
-import org.json.JSONException;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+import org.json.JSONObject;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
 
 /**
- * Servlet to use GraphHopper in a remote application (mobile or browser).
- * Attention: If type is json it returns the points in GeoJson format
- * (longitude,latitude) unlike the format "lat,lon" used otherwise.
+ * Servlet to use GraphHopper in a remote application (mobile or browser). Attention: If type is
+ * json it returns the points in GeoJson format (longitude,latitude) unlike the format "lat,lon"
+ * used otherwise.
  * <p/>
  * @author Peter Karich
  */
-public class GraphHopperServlet extends GHBaseServlet {
-
+public class GraphHopperServlet extends GHBaseServlet
+{
     @Inject
     private GraphHopper hopper;
-    @Inject
-    private Geocoding geocoding;
-    @Inject
-    @Named("defaultAlgorithm")
-    private String defaultAlgorithm;
-    @Inject
-    @Named("timeout")
-    private Long timeOutInMillis;
-    @Inject
-    private GHThreadPool threadPool;
-    @Inject
-    private TranslationMap trMap;
 
     @Override
-    public void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
-        try {
-            if ("/info".equals(req.getPathInfo())) {
-                writeInfos(req, res);
-            } else if ("/route".equals(req.getPathInfo())) {
-                writePath(req, res);
-            }
-        } catch (Exception ex) {
+    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
+    {
+        try
+        {
+            writePath(req, res);
+        } catch (IllegalArgumentException ex)
+        {
+            writeError(res, SC_BAD_REQUEST, ex.getMessage());
+        } catch (Exception ex)
+        {
             logger.error("Error while executing request: " + req.getQueryString(), ex);
             writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
         }
     }
 
-    void writeInfos(HttpServletRequest req, HttpServletResponse res) throws Exception {
-        BBox bb = hopper.getGraph().getBounds();
-        List<Double> list = new ArrayList<Double>(4);
-        list.add(bb.minLon);
-        list.add(bb.minLat);
-        list.add(bb.maxLon);
-        list.add(bb.maxLat);
-        JSONBuilder json = new JSONBuilder().
-                object("bbox", list).
-                object("supportedVehicles", hopper.getEncodingManager()).
-                object("version", Constants.VERSION).
-                object("buildDate", Constants.BUILD_DATE);
-        writeJson(req, res, json.build());
-    }
+    void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exception
+    {
+        List<GHPoint> infoPoints = getPoints(httpReq, "point");
 
-    void writePath(HttpServletRequest req, HttpServletResponse res) throws Exception {
-        StopWatch sw = new StopWatch().start();
-        List<GHPlace> infoPoints = getPoints(req);
-        float tookGeocoding = sw.stop().getSeconds();
-        GHPlace start = infoPoints.get(0);
-        GHPlace end = infoPoints.get(1);
-        try {
-            // we can reduce the path length based on the maximum differences to the original coordinates
-            double minPathPrecision = getDoubleParam(req, "minPathPrecision", 1d);
-            boolean writeGPX = "gpx".equalsIgnoreCase(getParam(req, "type", "json"));
-            boolean enableInstructions = writeGPX || getBooleanParam(req, "instructions", true);
-            boolean calcPoints = getBooleanParam(req, "calcPoints", true);
-            String vehicleStr = getParam(req, "vehicle", "CAR").toUpperCase();
-            String weighting = getParam(req, "weighting", "fastest");
-            // REMOVE_IN 0.3
-            if (req.getParameterMap().containsKey("algoType"))
-                weighting = getParam(req, "algoType", "fastest");
+        // we can reduce the path length based on the maximum differences to the original coordinates
+        double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
+        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
+        boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
+        boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
+        boolean elevation = getBooleanParam(httpReq, "elevation", false);
+        String vehicleStr = getParam(httpReq, "vehicle", "car");
+        String weighting = getParam(httpReq, "weighting", "fastest");
+        String algoStr = getParam(httpReq, "algorithm", "");
+        String localeStr = getParam(httpReq, "locale", "en");
 
-            String algoStr = getParam(req, "algorithm", defaultAlgorithm);
+        StopWatch sw = new StopWatch().start();
+        GHResponse ghRsp;
+        if (!hopper.getEncodingManager().supports(vehicleStr))
+        {
+            ghRsp = new GHResponse().addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
+        } else if (elevation && !hopper.hasElevation())
+        {
+            ghRsp = new GHResponse().addError(new IllegalArgumentException("Elevation not supported!"));
+        } else
+        {
+            FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
+            GHRequest request = new GHRequest(infoPoints);
 
-            sw = new StopWatch().start();
-            GHResponse rsp;
-            if (hopper.getEncodingManager().supports(vehicleStr)) {
-                FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
-                rsp = hopper.route(new GHRequest(start, end).
-                        setVehicle(algoVehicle.toString()).
-                        setWeighting(weighting).
-                        setAlgorithm(algoStr).
-                        putHint("calcPoints", calcPoints).
-                        putHint("instructions", enableInstructions).
-                        putHint("douglas.minprecision", minPathPrecision));
-            } else {
-                rsp = new GHResponse().addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
-            }
+            initHints(request, httpReq.getParameterMap());
+            request.setVehicle(algoVehicle.toString()).
+                    setWeighting(weighting).
+                    setAlgorithm(algoStr).
+                    setLocale(localeStr).
+                    getHints().
+                    put("calcPoints", calcPoints).
+                    put("instructions", enableInstructions).
+                    put("wayPointMaxDistance", minPathPrecision);
 
-            float took = sw.stop().getSeconds();
-            String infoStr = req.getRemoteAddr() + " " + req.getLocale() + " " + req.getHeader("User-Agent");
-            PointList points = rsp.getPoints();
-            String logStr = req.getQueryString() + " " + infoStr + " " + start + "->" + end
-                    + ", distance: " + rsp.getDistance() + ", time:" + Math.round(rsp.getMillis() / 60000f)
-                    + "min, points:" + points.getSize() + ", took:" + took
-                    + ", debug - " + rsp.getDebugInfo() + ", " + algoStr + ", "
-                    + weighting + ", " + vehicleStr;
+            ghRsp = hopper.route(request);
+        }
 
-            if (rsp.hasErrors())
-                logger.error(logStr + ", errors:" + rsp.getErrors());
-            else
-                logger.info(logStr);
+        float took = sw.stop().getSeconds();
+        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
+        String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+                + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
 
-            if (writeGPX)
-                writeGPX(req, res, rsp);
-            else
-                writeJson(req, res, rsp, start, end, tookGeocoding, took);
+        if (ghRsp.hasErrors())
+            logger.error(logStr + ", errors:" + ghRsp.getErrors());
+        else
+            logger.info(logStr + ", distance: " + ghRsp.getDistance()
+                    + ", time:" + Math.round(ghRsp.getMillis() / 60000f)
+                    + "min, points:" + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
 
-        } catch (Exception ex) {
-            logger.error("Error while query:" + start + "->" + end, ex);
-            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
-        }
+        if (writeGPX)
+            writeResponse(res, createGPXString(httpReq, res, ghRsp));
+        else
+            writeJson(httpReq, res, new JSONObject(createJson(httpReq, ghRsp, took)));
     }
 
-    private void writeGPX(HttpServletRequest req, HttpServletResponse res, GHResponse rsp) {
+    protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
+            throws Exception
+    {
+        boolean includeElevation = getBooleanParam(req, "elevation", false);
         res.setCharacterEncoding("UTF-8");
         res.setContentType("application/xml");
         String trackName = getParam(req, "track", "GraphHopper Track");
-        res.setHeader( "Content-Disposition", "attachment;filename=" + "GraphHopper.gpx" );
+        res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
         String timeZone = getParam(req, "timezone", "GMT");
         long time = getLongParam(req, "millis", System.currentTimeMillis());
-        writeResponse(res, rsp.getInstructions().createGPX(trackName, time, timeZone));
+        if (rsp.hasErrors())
+            return errorsToXML(rsp.getErrors());
+        else
+            return rsp.getInstructions().createGPX(trackName, time, timeZone, includeElevation);
+    }
+
+    String errorsToXML( List<Throwable> list ) throws Exception
+    {
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        DocumentBuilder builder = factory.newDocumentBuilder();
+        Document doc = builder.newDocument();
+        Element gpxElement = doc.createElement("gpx");
+        gpxElement.setAttribute("creator", "GraphHopper");
+        gpxElement.setAttribute("version", "1.1");
+        doc.appendChild(gpxElement);
+
+        Element mdElement = doc.createElement("metadata");
+        gpxElement.appendChild(mdElement);
+
+        Element errorsElement = doc.createElement("extensions");
+        mdElement.appendChild(errorsElement);
+
+        for (Throwable t : list)
+        {
+            Element error = doc.createElement("error");
+            errorsElement.appendChild(error);
+            error.setAttribute("message", t.getMessage());
+            error.setAttribute("details", t.getClass().getName());
+        }
+        TransformerFactory transformerFactory = TransformerFactory.newInstance();
+        Transformer transformer = transformerFactory.newTransformer();
+        StringWriter writer = new StringWriter();
+        transformer.transform(new DOMSource(doc), new StreamResult(writer));
+        return writer.toString();
     }
 
-    private void writeJson(HttpServletRequest req, HttpServletResponse res,
-            GHResponse rsp, GHPlace start, GHPlace end,
-            float tookGeocoding, float took) throws JSONException {
+    protected Map<String, Object> createJson( HttpServletRequest req, GHResponse rsp, float took )
+    {
         boolean enableInstructions = getBooleanParam(req, "instructions", true);
-        boolean useMiles = getBooleanParam(req, "useMiles", false);
-        Locale locale = Helper.getLocale(getParam(req, "locale", "en"));
-        boolean encodedPolylineParam = getBooleanParam(req, "encodedPolyline", true);
-        JSONBuilder builder;
-        if (rsp.hasErrors()) {
-            builder = new JSONBuilder().startObject("info");
+        boolean pointsEncoded = getBooleanParam(req, "points_encoded", true);
+        boolean calcPoints = getBooleanParam(req, "calc_points", true);
+        boolean includeElevation = getBooleanParam(req, "elevation", false);
+        Map<String, Object> json = new HashMap<String, Object>();
+        Map<String, Object> jsonInfo = new HashMap<String, Object>();
+        json.put("info", jsonInfo);
+        jsonInfo.put("copyrights", Arrays.asList("GraphHopper", "OpenStreetMap contributors"));
+
+        if (rsp.hasErrors())
+        {
             List<Map<String, String>> list = new ArrayList<Map<String, String>>();
-            for (Throwable t : rsp.getErrors()) {
+            for (Throwable t : rsp.getErrors())
+            {
                 Map<String, String> map = new HashMap<String, String>();
                 map.put("message", t.getMessage());
                 map.put("details", t.getClass().getName());
                 list.add(map);
             }
-            builder = builder.object("errors", list).endObject();
-        } else {
-            builder = new JSONBuilder().
-                    startObject("info").
-                    object("routeFound", rsp.isFound()).
-                    object("took", took).
-                    object("tookGeocoding", tookGeocoding).
-                    endObject();
-            builder = builder.startObject("route").
-                    object("from", new Double[]{
-                        start.lon, start.lat
-                    }).
-                    object("to", new Double[]{
-                        end.lon, end.lat
-                    }).
-                    object("distance", rsp.getDistance()).
-                    object("time", rsp.getMillis());
-
-            if (enableInstructions) {
-                Translation tr = trMap.getWithFallBack(locale);
-                InstructionList instructions = rsp.getInstructions();
-                builder.startObject("instructions").
-                        object("descriptions", instructions.createDescription(tr)).
-                        object("distances", instructions.createDistances()).
-                        object("indications", instructions.createIndications()).
-                        object("millis", instructions.createMillis()).
-                        object("latLngs", instructions.createLatLngs()).
-                        endObject();
-            }
+            jsonInfo.put("errors", list);
+        } else
+        {
+            jsonInfo.put("took", Math.round(took * 1000));
+            Map<String, Object> jsonPath = new HashMap<String, Object>();
+            jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
+            jsonPath.put("weight", Helper.round6(rsp.getDistance()));
+            jsonPath.put("time", rsp.getMillis());
 
-            PointList points = rsp.getPoints();
-            if (points.getSize() >= 2)
-                builder.object("bbox", rsp.calcRouteBBox(hopper.getGraph().getBounds()).toGeoJson());
+            if (calcPoints)
+            {
+                jsonPath.put("points_encoded", pointsEncoded);
 
-            if (encodedPolylineParam) {
-                String encodedPolyline = WebHelper.encodePolyline(points);
-                builder.object("coordinates", encodedPolyline);
-            } else {
-                builder.startObject("data").
-                        object("type", "LineString").
-                        object("coordinates", points.toGeoJson()).
-                        endObject();
-            }
-            // end route
-            builder = builder.endObject();
-        }
+                PointList points = rsp.getPoints();
+                if (points.getSize() >= 2)
+                {
+                    BBox maxBounds = hopper.getGraph().getBounds();
+                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
+                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+                }
 
-        writeJson(req, res, builder.build());
-    }
+                jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
 
-    private List<GHPlace> getPoints(HttpServletRequest req) throws IOException {
-        String[] pointsAsStr = getParams(req, "point");
-        // allow two formats
-        if (pointsAsStr.length == 0) {
-            String from = getParam(req, "from", "");
-            String to = getParam(req, "to", "");
-            if (!Helper.isEmpty(from) && !Helper.isEmpty(to)) {
-                pointsAsStr = new String[]{
-                    from, to
-                };
+                if (enableInstructions)
+                {
+                    InstructionList instructions = rsp.getInstructions();
+                    jsonPath.put("instructions", instructions.createJson());
+                }
             }
+            json.put("paths", Collections.singletonList(jsonPath));
         }
+        return json;
+    }
 
-        final List<GHPlace> infoPoints = new ArrayList<GHPlace>();
-        List<GHThreadPool.GHWorker> workers = new ArrayList<GHThreadPool.GHWorker>();
-        for (int pointNo = 0; pointNo < pointsAsStr.length; pointNo++) {
-            final String str = pointsAsStr[pointNo];
-            String[] fromStrs = str.split(",");
-            if (fromStrs.length == 2) {
-                GHPlace place = GHPlace.parse(str);
-                if (place != null)
-                    infoPoints.add(place);
-                continue;
-            }
+    protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
+    {
+        if (pointsEncoded)
+            return WebHelper.encodePolyline(points, includeElevation);
 
-            // now it is not a coordinate and we need to call geo resolver
-            final int index = infoPoints.size();
-            infoPoints.add(new GHPlace(Double.NaN, Double.NaN).setName(str));
-            GHThreadPool.GHWorker worker = new GHThreadPool.GHWorker(timeOutInMillis) {
-                @Override
-                public String getName() {
-                    return "geocoding search " + str;
-                }
+        Map<String, Object> jsonPoints = new HashMap<String, Object>();
+        jsonPoints.put("type", "LineString");
+        jsonPoints.put("coordinates", points.toGeoJson(includeElevation));
+        return jsonPoints;
+    }
 
-                @Override
-                public void run() {
-                    List<GHPlace> tmpPoints = geocoding.name2point(new GHPlace(str));
-                    if (!tmpPoints.isEmpty()) {
-                        infoPoints.set(index, tmpPoints.get(0));
-                    }
+    protected List<GHPoint> getPoints( HttpServletRequest req, String key ) throws IOException
+    {
+        String[] pointsAsStr = getParams(req, key);
+        final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
+        for (String str : pointsAsStr)
+        {
+            String[] fromStrs = str.split(",");
+            if (fromStrs.length == 2)
+            {
+                GHPoint point = GHPoint.parse(str);
+                if (point != null)
+                {
+                    infoPoints.add(point);
                 }
-            };
-            workers.add(worker);
-            threadPool.enqueue(worker);
-        }
-        threadPool.waitFor(workers, timeOutInMillis);
-        for (GHPlace p : infoPoints) {
-            if (Double.isNaN(p.lat)) {
-                throw new IllegalArgumentException("[nominatim] Not all points could be resolved! " + infoPoints);
             }
         }
 
-        // TODO resolve name in a thread if only lat,lon is given but limit to a certain timeout
-        if (infoPoints == null || infoPoints.size() < 2) {
-            throw new IllegalArgumentException("Did you specify point=<from>&point=<to> ? Use at least 2 points! " + infoPoints);
-        }
+        return infoPoints;
+    }
 
-        // TODO execute algorithm multiple times!
-        if (infoPoints.size() != 2) {
-            throw new IllegalArgumentException("TODO! At the moment only 2 points can be specified");
+    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
+    {
+        WeightingMap m = request.getHints();
+        for (Entry<String, String[]> e : parameterMap.entrySet())
+        {
+            if (e.getValue().length == 1)
+                m.put(e.getKey(), e.getValue()[0]);
         }
-
-        return infoPoints;
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 1d87410adf..c1445d9616 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -20,9 +20,9 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
-import com.graphhopper.util.Downloader;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
+import java.util.Arrays;
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -37,16 +37,24 @@
 {
     public static void main( String[] args )
     {
-        GraphHopperAPI gh = new GraphHopperWeb();
-        gh.load("http://localhost:8989/api/route");
+        GraphHopperWeb gh = new GraphHopperWeb();
+        gh.setKey("<your-key>");
+
+        // for local server: gh.load("http://localhost:8989/route");        
+        gh.load("https://graphhopper.com/api/1/route");
+
         //GHResponse ph = gh.route(new GHRequest(53.080827, 9.074707, 50.597186, 11.184082));
         GHResponse ph = gh.route(new GHRequest(49.6724, 11.3494, 49.6550, 11.4180));
         System.out.println(ph);
     }
-    private Logger logger = LoggerFactory.getLogger(getClass());
+    private final Logger logger = LoggerFactory.getLogger(getClass());
     private String serviceUrl;
-    private boolean encodePolyline = true;
+    private boolean pointsEncoded = true;
     private Downloader downloader = new Downloader("GraphHopperWeb");
+    private boolean instructions = true;
+    private String key = "";
+    private boolean withElevation = false;
+    private final TranslationMap trMap = new TranslationMap().doImport();
 
     public GraphHopperWeb()
     {
@@ -58,7 +66,7 @@ public void setDownloader( Downloader downloader )
     }
 
     /**
-     * Example url: http://localhost:8989/api or http://217.92.216.224:8080/api
+     * Example url: http://localhost:8989 or http://217.92.216.224:8080
      */
     @Override
     public boolean load( String url )
@@ -67,53 +75,154 @@ public boolean load( String url )
         return true;
     }
 
-    public GraphHopperWeb setEncodePolyline( boolean b )
+    public GraphHopperWeb setPointsEncoded( boolean b )
     {
-        encodePolyline = b;
+        pointsEncoded = b;
+        return this;
+    }
+
+    public GraphHopperWeb setInstructions( boolean b )
+    {
+        instructions = b;
+        return this;
+    }
+
+    public GraphHopperWeb setElevation( boolean withElevation )
+    {
+        this.withElevation = withElevation;
+        return this;
+    }
+
+    public GraphHopperWeb setKey( String key )
+    {
+        this.key = key;
         return this;
     }
 
     @Override
     public GHResponse route( GHRequest request )
     {
-        request.check();
         StopWatch sw = new StopWatch().start();
         double took = 0;
         try
         {
+            String places = "";
+            for (GHPoint p : request.getPoints())
+            {
+                places += "point=" + p.lat + "," + p.lon + "&";
+            }
+
             String url = serviceUrl
-                    + "?from=" + request.getFrom().lat + "," + request.getFrom().lon
-                    + "&to=" + request.getTo().lat + "," + request.getTo().lon
+                    + "?"
+                    + places
                     + "&type=json"
-                    + "&encodedPolyline=" + encodePolyline
-                    + "&minPathPrecision=" + request.getHint("douglas.minprecision", 1)
-                    + "&algo=" + request.getAlgorithm();
+                    + "&points_encoded=" + pointsEncoded
+                    + "&way_point_max_distance=" + request.getHints().getDouble("wayPointMaxDistance", 1)
+                    + "&algo=" + request.getAlgorithm()
+                    + "&locale=" + request.getLocale().toString()
+                    + "&elevation=" + withElevation;
+
+            if (!request.getVehicle().isEmpty())
+                url += "&vehicle=" + request.getVehicle();
+
+            if (!key.isEmpty())
+                url += "&key=" + key;
+
             String str = downloader.downloadAsString(url);
             JSONObject json = new JSONObject(str);
-            took = json.getJSONObject("info").getDouble("took");
-            JSONObject route = json.getJSONObject("route");
-            double distance = route.getDouble("distance");
-            int millis = route.getInt("time");
-            PointList list;
-            if (encodePolyline)
+            GHResponse res = new GHResponse();
+
+            if (json.getJSONObject("info").has("errors"))
             {
-                list = WebHelper.decodePolyline(route.getString("coordinates"), 100);
+                JSONArray errors = json.getJSONObject("info").getJSONArray("errors");
+
+                for (int i = 0; i < errors.length(); i++)
+                {
+                    JSONObject error = errors.getJSONObject(i);
+                    String exClass = error.getString("details");
+                    String exMessage = error.getString("message");
+
+                    if (exClass.equals(UnsupportedOperationException.class.getName()))
+                    {
+                        res.addError(new UnsupportedOperationException(exMessage));
+                    } else if (exClass.equals(IllegalStateException.class.getName()))
+                    {
+                        res.addError(new IllegalStateException(exMessage));
+                    } else if (exClass.equals(RuntimeException.class.getName()))
+                    {
+                        res.addError(new RuntimeException(exMessage));
+                    } else if (exClass.equals(IllegalArgumentException.class.getName()))
+                    {
+                        res.addError(new IllegalArgumentException(exMessage));
+                    } else
+                    {
+                        res.addError(new Exception(exClass + " " + exMessage));
+                    }
+                }
+
+                return res;
+
             } else
             {
-                JSONArray coords = route.getJSONObject("data").getJSONArray("coordinates");
-                list = new PointList(coords.length());
-                for (int i = 0; i < coords.length(); i++)
+                took = json.getJSONObject("info").getDouble("took");
+                JSONArray paths = json.getJSONArray("paths");
+                JSONObject firstPath = paths.getJSONObject(0);
+                double distance = firstPath.getDouble("distance");
+                int time = firstPath.getInt("time");
+                PointList pointList;
+                if (pointsEncoded)
+                {
+                    String pointStr = firstPath.getString("points");
+                    pointList = WebHelper.decodePolyline(pointStr, 100, withElevation);
+                } else
+                {
+                    JSONArray coords = firstPath.getJSONObject("points").getJSONArray("coordinates");
+                    pointList = new PointList(coords.length(), withElevation);
+                    for (int i = 0; i < coords.length(); i++)
+                    {
+                        JSONArray arr = coords.getJSONArray(i);
+                        double lon = arr.getDouble(0);
+                        double lat = arr.getDouble(1);
+                        if (withElevation)
+                            pointList.add(lat, lon, arr.getDouble(2));
+                        else
+                            pointList.add(lat, lon);
+                    }
+                }
+
+                if (instructions)
                 {
-                    JSONArray arr = coords.getJSONArray(i);
-                    double lon = arr.getDouble(0);
-                    double lat = arr.getDouble(1);
-                    list.add(lat, lon);
+                    JSONArray instrArr = firstPath.getJSONArray("instructions");
+
+                    InstructionList il = new InstructionList(trMap.getWithFallBack(request.getLocale()));
+                    for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
+                    {
+                        JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
+                        double instDist = jsonObj.getDouble("distance");
+                        String text = jsonObj.getString("text");
+                        long instTime = jsonObj.getLong("time");
+                        int sign = jsonObj.getInt("sign");
+                        JSONArray iv = jsonObj.getJSONArray("interval");
+                        int from = iv.getInt(0);
+                        int to = iv.getInt(1);
+                        PointList instPL = new PointList(to - from, withElevation);
+                        for (int j = from; j <= to; j++)
+                        {
+                            instPL.add(pointList, j);
+                        }
+
+                        // TODO way and payment type
+                        Instruction instr = new Instruction(sign, text, InstructionAnnotation.EMPTY, instPL).
+                                setDistance(instDist).setTime(instTime);
+                        il.add(instr);
+                    }
+                    res.setInstructions(il);
                 }
+                return res.setPoints(pointList).setDistance(distance).setMillis(time);
             }
-            return new GHResponse().setPoints(list).setDistance(distance).setMillis(millis);
         } catch (Exception ex)
         {
-            throw new RuntimeException("Problem while fetching path " + request.getFrom() + "->" + request.getTo(), ex);
+            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
         } finally
         {
             logger.debug("Full request took:" + sw.stop().getSeconds() + ", API took:" + took);
diff --git a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java b/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
index 25047c67b6..830e6e03cd 100644
--- a/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
+++ b/web/src/main/java/com/graphhopper/http/GuiceServletConfig.java
@@ -20,14 +20,11 @@
 import com.google.inject.Guice;
 import com.google.inject.Injector;
 import com.google.inject.Module;
-import com.google.inject.Singleton;
 import com.google.inject.servlet.GuiceServletContextListener;
-import com.google.inject.servlet.ServletModule;
-import java.util.HashMap;
-import java.util.Map;
+import com.graphhopper.util.CmdArgs;
 
 /**
- * Replacement of web.xml
+ * Replacement of web.xml used only for container deployment. Preferred method is to use GHServer.
  * <p/>
  * http://code.google.com/p/google-guice/wiki/ServletModule
  * <p/>
@@ -35,6 +32,19 @@
  */
 public class GuiceServletConfig extends GuiceServletContextListener
 {
+    private final CmdArgs args;
+
+    public GuiceServletConfig()
+    {
+        try
+        {
+            args = CmdArgs.readFromConfig("config.properties", "graphhopper.config");
+        } catch (Exception ex)
+        {
+            throw new RuntimeException(ex);
+        }
+    }
+
     @Override
     protected Injector getInjector()
     {
@@ -43,35 +53,11 @@ protected Injector getInjector()
 
     protected Module createDefaultModule()
     {
-        return new DefaultModule();
+        return new DefaultModule(args);
     }
 
     protected Module createServletModule()
     {
-        return new ServletModule()
-        {
-            @Override
-            protected void configureServlets()
-            {
-                Map<String, String> params = new HashMap<String, String>();
-                params.put("mimeTypes", "text/html,"
-                        + "text/plain,"
-                        + "text/xml,"
-                        + "application/xhtml+xml,"
-                        + "text/css,"
-                        + "application/json,"
-                        + "application/javascript,"
-                        + "image/svg+xml");
-
-                filter("/*").through(MyGZIPHook.class, params);
-                bind(MyGZIPHook.class).in(Singleton.class);
-
-                serve("/api/i18n*").with(I18NServlet.class);
-                bind(I18NServlet.class).in(Singleton.class);
-
-                serve("/api*").with(GraphHopperServlet.class);
-                bind(GraphHopperServlet.class).in(Singleton.class);
-            }
-        };
+        return new GHServletModule(args);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/I18NServlet.java b/web/src/main/java/com/graphhopper/http/I18NServlet.java
index 714ae86582..833246508a 100644
--- a/web/src/main/java/com/graphhopper/http/I18NServlet.java
+++ b/web/src/main/java/com/graphhopper/http/I18NServlet.java
@@ -19,7 +19,7 @@
 
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.TranslationMap;
-import com.graphhopper.util.TranslationMap.Translation;
+import com.graphhopper.util.Translation;
 import java.io.IOException;
 import java.util.Locale;
 import javax.inject.Inject;
diff --git a/web/src/main/java/com/graphhopper/http/IPFilter.java b/web/src/main/java/com/graphhopper/http/IPFilter.java
new file mode 100644
index 0000000000..9b40dd4c02
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/IPFilter.java
@@ -0,0 +1,116 @@
+package com.graphhopper.http;
+
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+import javax.servlet.*;
+import javax.servlet.http.HttpServletResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * This IP filter class accepts a list of IPs for blacklisting OR for whitelisting (but not both).
+ * <p>
+ * Additionally to exact match a simple wildcard expression ala 1.2.3* or 1.*.3.4 is allowed.
+ * <p>
+ * The internal ip filter from jetty did not work (NP exceptions)
+ * <p>
+ * @author Peter Karich
+ */
+public class IPFilter implements Filter
+{
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Set<String> whites;
+    private final Set<String> blacks;
+
+    public IPFilter( String whiteList, String blackList )
+    {
+        whites = createSet(whiteList.split(","));
+        blacks = createSet(blackList.split(","));
+        if (!whites.isEmpty())
+            logger.debug("whitelist:" + whites);
+        if (!blackList.isEmpty())
+            logger.debug("blacklist:" + blacks);
+
+        if (!blacks.isEmpty() && !whites.isEmpty())
+            throw new IllegalArgumentException("blacklist and whitelist at the same time?");
+    }
+
+    @Override
+    public void doFilter( ServletRequest request, ServletResponse response, FilterChain chain ) throws IOException, ServletException
+    {
+        String ip = request.getRemoteAddr();
+        if (accept(ip))
+        {
+            chain.doFilter(request, response);
+        } else
+        {
+            logger.warn("Did not accept IP " + ip);
+            ((HttpServletResponse) response).sendError(HttpServletResponse.SC_FORBIDDEN);
+        }
+    }
+
+    public boolean accept( String ip )
+    {
+        if (whites.isEmpty() && blacks.isEmpty())
+            return true;
+
+        if (!whites.isEmpty())
+        {
+            for (String w : whites)
+            {
+                if (simpleMatch(ip, w))
+                    return true;
+            }
+            return false;
+        }
+
+        if (blacks.isEmpty())
+            throw new IllegalStateException("cannot happen");
+
+        for (String b : blacks)
+        {
+            if (simpleMatch(ip, b))
+                return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public void init( FilterConfig filterConfig ) throws ServletException
+    {
+    }
+
+    @Override
+    public void destroy()
+    {
+    }
+
+    private Set<String> createSet( String[] split )
+    {
+        Set<String> set = new HashSet<String>(split.length);
+        for (String str : split)
+        {
+            str = str.trim();
+            if (!str.isEmpty())
+                set.add(str);
+        }
+        return set;
+    }
+
+    public boolean simpleMatch( String ip, String pattern )
+    {
+        String[] ipParts = pattern.split("\\*");
+        for (String ipPart : ipParts)
+        {
+            int idx = ip.indexOf(ipPart);
+            if (idx == -1)
+                return false;
+
+            ip = ip.substring(idx + ipPart.length());
+        }
+
+        return true;
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/InfoServlet.java b/web/src/main/java/com/graphhopper/http/InfoServlet.java
new file mode 100644
index 0000000000..824d5c3ee1
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/InfoServlet.java
@@ -0,0 +1,94 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.storage.StorableProperties;
+import com.graphhopper.util.Constants;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+import org.json.JSONObject;
+
+/**
+ * @author Peter Karich
+ */
+public class InfoServlet extends GHBaseServlet
+{
+    @Inject
+    private GraphHopper hopper;
+
+    @Override
+    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
+    {
+        try
+        {
+            writeInfos(req, res);
+        } catch (IllegalArgumentException ex)
+        {
+            writeError(res, SC_BAD_REQUEST, ex.getMessage());
+        } catch (Exception ex)
+        {
+            logger.error("Error while executing request: " + req.getQueryString(), ex);
+            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
+        }
+    }
+
+    void writeInfos( HttpServletRequest req, HttpServletResponse res ) throws Exception
+    {
+        BBox bb = hopper.getGraph().getBounds();
+        List<Double> list = new ArrayList<Double>(4);
+        list.add(bb.minLon);
+        list.add(bb.minLat);
+        list.add(bb.maxLon);
+        list.add(bb.maxLat);
+
+        JSONObject json = new JSONObject();
+        json.put("bbox", list);
+
+        String[] vehicles = hopper.getGraph().getEncodingManager().toString().split(",");
+        json.put("supported_vehicles", vehicles);
+        JSONObject features = new JSONObject();
+        for (String v : vehicles)
+        {
+            JSONObject perVehicleJson = new JSONObject();
+            perVehicleJson.put("elevation", hopper.hasElevation());
+            features.put(v, perVehicleJson);
+        }
+        json.put("features", features);
+
+        json.put("version", Constants.VERSION);
+        json.put("build_date", Constants.BUILD_DATE);
+
+        StorableProperties props = hopper.getGraph().getProperties();
+        json.put("import_date", props.get("osmreader.import.date"));
+
+        if (!Helper.isEmpty(props.get("prepare.date")))
+            json.put("prepare_date", props.get("prepare.date"));
+
+        writeJson(req, res, json);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
new file mode 100644
index 0000000000..b320b38854
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright © 2011. Team Lazer Beez (http://teamlazerbeez.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.http;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import org.json.JSONObject;
+
+public class InvalidRequestServlet extends GHBaseServlet
+{
+    @Override
+    protected void service( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
+    {
+        res.setStatus(HttpServletResponse.SC_NOT_FOUND);
+        res.setContentType("text/plain");
+        res.setContentType("UTF-8");
+        JSONObject json = new JSONObject();
+        json.put("error_code", "404");
+        writeJson(req, res, json);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/JSONBuilder.java b/web/src/main/java/com/graphhopper/http/JSONBuilder.java
deleted file mode 100644
index 39bf080994..0000000000
--- a/web/src/main/java/com/graphhopper/http/JSONBuilder.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.http;
-
-import java.util.HashMap;
-import java.util.Map;
-import org.json.JSONObject;
-
-/**
- * @author Peter Karich
- */
-public class JSONBuilder
-{
-    private String lastObjectName;
-    private JSONBuilder parent;
-    private Map<String, Object> map;
-
-    public JSONBuilder()
-    {
-        map = new HashMap<String, Object>(5);
-    }
-
-    public JSONBuilder setParent( JSONBuilder p )
-    {
-        parent = p;
-        return this;
-    }
-
-    public JSONBuilder startObject( String entry )
-    {
-        lastObjectName = entry;
-        return new JSONBuilder().setParent(this);
-    }
-
-    public JSONBuilder endObject()
-    {
-        if (parent == null)
-        {
-            throw new IllegalStateException("object not opened?");
-        }
-
-        parent.map.put(parent.lastObjectName, map);
-        parent.lastObjectName = null;
-        return parent;
-    }
-
-    public JSONBuilder object( String key, Object val )
-    {
-        map.put(key, val);
-        return this;
-    }
-
-    public JSONObject build()
-    {
-        if (parent != null || lastObjectName != null)
-        {
-            throw new IllegalStateException("json with name " + lastObjectName + " not closed");
-        }
-
-        return new JSONObject(map);
-    }
-}
diff --git a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
index 28631f4ca6..f9cc20ae9a 100644
--- a/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
+++ b/web/src/main/java/com/graphhopper/http/NominatimGeocoder.java
@@ -40,9 +40,9 @@
 {
     public static void main( String[] args )
     {
-        System.out.println("search " + new NominatimGeocoder().name2point(new GHPlace("bayreuth"), new GHPlace("berlin")));
+        System.out.println("search " + new NominatimGeocoder().names2places(new GHPlace("bayreuth"), new GHPlace("berlin")));
 
-        System.out.println("reverse " + new NominatimGeocoder().point2name(new GHPlace(49.9027606, 11.577197),
+        System.out.println("reverse " + new NominatimGeocoder().places2names(new GHPlace(49.9027606, 11.577197),
                 new GHPlace(52.5198535, 13.4385964)));
     }
     private String nominatimUrl;
@@ -71,7 +71,7 @@ public NominatimGeocoder setBounds( BBox bounds )
     }
 
     @Override
-    public List<GHPlace> name2point( GHPlace... places )
+    public List<GHPlace> names2places( GHPlace... places )
     {
         List<GHPlace> resList = new ArrayList<GHPlace>();
         for (GHPlace place : places)
@@ -105,7 +105,7 @@ public NominatimGeocoder setBounds( BBox bounds )
     }
 
     @Override
-    public List<GHPlace> point2name( GHPlace... points )
+    public List<GHPlace> places2names( GHPlace... points )
     {
         List<GHPlace> resList = new ArrayList<GHPlace>();
         for (GHPlace point : points)
diff --git a/web/src/main/java/com/graphhopper/http/WebHelper.java b/web/src/main/java/com/graphhopper/http/WebHelper.java
index 60730a750b..02e515b8e9 100644
--- a/web/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web/src/main/java/com/graphhopper/http/WebHelper.java
@@ -25,6 +25,12 @@
 import java.net.URLEncoder;
 
 /**
+ * Code which handles polyline encoding and other web stuff.
+ * <p>
+ * The necessary information for polyline encoding is in this answer:
+ * http://stackoverflow.com/a/24510799/194609 with a link to official Java sources as well as to a
+ * good explanation.
+ * <p>
  * @author Peter Karich
  */
 public class WebHelper
@@ -40,11 +46,12 @@ public static String encodeURL( String str )
         }
     }
 
-    public static PointList decodePolyline( String encoded, int initCap )
+    public static PointList decodePolyline( String encoded, int initCap, boolean is3D )
     {
-        PointList poly = new PointList(initCap);
-        int index = 0, len = encoded.length();
-        int lat = 0, lng = 0;
+        PointList poly = new PointList(initCap, is3D);
+        int index = 0;
+        int len = encoded.length();
+        int lat = 0, lng = 0, ele = 0;
         while (index < len)
         {
             // latitude
@@ -69,18 +76,42 @@ public static PointList decodePolyline( String encoded, int initCap )
             } while (b >= 0x20);
             int deltaLongitude = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
             lng += deltaLongitude;
-            poly.add((double) lat / 1E5, (double) lng / 1E5);
+
+            if (is3D)
+            {
+                // elevation
+                shift = 0;
+                result = 0;
+                do
+                {
+                    b = encoded.charAt(index++) - 63;
+                    result |= (b & 0x1f) << shift;
+                    shift += 5;
+                } while (b >= 0x20);
+                int deltaElevation = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
+                ele += deltaElevation;
+                poly.add((double) lat / 1e5, (double) lng / 1e5, (double) ele / 100);
+            } else
+                poly.add((double) lat / 1e5, (double) lng / 1e5);
         }
         return poly;
     }
 
-    // https://developers.google.com/maps/documentation/utilities/polylinealgorithm?hl=de
     public static String encodePolyline( PointList poly )
+    {
+        if (poly.isEmpty())
+            return "";
+
+        return encodePolyline(poly, poly.is3D());
+    }
+
+    public static String encodePolyline( PointList poly, boolean includeElevation )
     {
         StringBuilder sb = new StringBuilder();
         int size = poly.getSize();
         int prevLat = 0;
         int prevLon = 0;
+        int prevEle = 0;
         for (int i = 0; i < size; i++)
         {
             int num = (int) Math.floor(poly.getLatitude(i) * 1e5);
@@ -89,6 +120,12 @@ public static String encodePolyline( PointList poly )
             num = (int) Math.floor(poly.getLongitude(i) * 1e5);
             encodeNumber(sb, num - prevLon);
             prevLon = num;
+            if (includeElevation)
+            {
+                num = (int) Math.floor(poly.getElevation(i) * 100);
+                encodeNumber(sb, num - prevEle);
+                prevEle = num;
+            }
         }
         return sb.toString();
     }
diff --git a/web/src/main/resources/log4j.xml b/web/src/main/resources/log4j.xml
new file mode 100644
index 0000000000..01cc086902
--- /dev/null
+++ b/web/src/main/resources/log4j.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration>
+    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
+        </layout>
+    </appender>
+    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
+        <param name="BufferSize" value="500"/>
+        <appender-ref ref="stdout"/>
+    </appender>   
+    <logger name="com.graphhopper" additivity="false">
+        <level value="info" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <!-- order important otherwise we'll get a warning -->
+    <root>
+        <priority value="warn"></priority>
+        <appender-ref ref="ASYNC"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
diff --git a/web/src/main/webapp/css/Leaflet.Elevation-0.0.2.css b/web/src/main/webapp/css/Leaflet.Elevation-0.0.2.css
new file mode 100644
index 0000000000..fe4fc2a013
--- /dev/null
+++ b/web/src/main/webapp/css/Leaflet.Elevation-0.0.2.css
@@ -0,0 +1,11 @@
+.lime-theme .leaflet-control.elevation .background{background-color:rgba(156,194,34,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.lime-theme .leaflet-control.elevation .axis line,.lime-theme .leaflet-control.elevation .axis path{fill:none;stroke:#566b13;stroke-width:2}
+.lime-theme .leaflet-control.elevation .area{fill:#9cc222}.lime-theme .leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#101404}.lime-theme .leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background:url(images/elevation.png) no-repeat center center #f8f8f9}.lime-theme .leaflet-control.elevation-collapsed .background{display:none}.lime-theme .leaflet-control.elevation-collapsed .elevation-toggle{display:block}
+.lime-theme .leaflet-control.elevation .mouse-drag{fill:rgba(99,126,11,.4)}.lime-theme .leaflet-overlay-pane .height-focus{stroke:#9cc222;fill:#9cc222}.lime-theme .leaflet-overlay-pane .height-focus.line{pointer-events:none;stroke-width:2}.steelblue-theme .leaflet-control.elevation .background{background-color:rgba(70,130,180,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.steelblue-theme .leaflet-control.elevation .axis line,.steelblue-theme .leaflet-control.elevation .axis path{fill:none;stroke:#0d1821;stroke-width:2}.steelblue-theme .leaflet-control.elevation .area{fill:#4682b4}.steelblue-theme .leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#0d1821}.steelblue-theme .leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background:url(images/elevation.png) no-repeat center center #f8f8f9}.steelblue-theme .leaflet-control.elevation-collapsed .background{display:none}.steelblue-theme .leaflet-control.elevation-collapsed .elevation-toggle{display:block}.steelblue-theme .leaflet-control.elevation .mouse-drag{fill:rgba(23,74,117,.4)}.steelblue-theme .leaflet-overlay-pane .height-focus{stroke:#4682b4;fill:#4682b4}.steelblue-theme .leaflet-overlay-pane .height-focus.line{pointer-events:none;stroke-width:2}.purple-theme .leaflet-control.elevation .background{background-color:rgba(115,44,123,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.purple-theme .leaflet-control.elevation .axis line,.purple-theme .leaflet-control.elevation .axis path{fill:none;stroke:#2d1130;stroke-width:2}.purple-theme .leaflet-control.elevation .area{fill:#732c7b}.purple-theme .leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#000}.purple-theme .leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background:url(images/elevation.png) no-repeat center center #f8f8f9}.purple-theme .leaflet-control.elevation-collapsed .background{display:none}.purple-theme .leaflet-control.elevation-collapsed .elevation-toggle{display:block}.purple-theme .leaflet-control.elevation .mouse-drag{fill:rgba(74,14,80,.4)}.purple-theme .leaflet-overlay-pane .height-focus{stroke:#732c7b;fill:#732c7b}.purple-theme .leaflet-overlay-pane .height-focus.line{pointer-events:none;stroke-width:2}
+
+.white-theme .leaflet-control.elevation .background{background-color:rgba(250,250,250,.6);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}.white-theme .leaflet-control.elevation .axis path,.white-theme .leaflet-control.elevation .axis line{fill:none;stroke:#0d1821;stroke-width:2}
+.white-theme .leaflet-control.elevation .area{fill:#00cc33; opacity: 0.8}.white-theme .leaflet-control.elevation .mouse-focus-line{pointer-events:none;stroke-width:1;stroke:#0d1821}.white-theme .leaflet-control.elevation .elevation-toggle{cursor:pointer;box-shadow:0 1px 7px rgba(0,0,0,.4);-webkit-border-radius:5px;border-radius:5px;width:36px;height:36px;background:url(images/elevation.png) no-repeat center center #f8f8f9}.white-theme .leaflet-control.elevation-collapsed .background{display:none}.white-theme .leaflet-control.elevation-collapsed .elevation-toggle{display:block}.white-theme .leaflet-overlay-pane .height-focus{stroke:#4682b4;fill:#4682b4}.white-theme .leaflet-overlay-pane .height-focus.line{pointer-events:none;stroke-width:2}
+.white-theme .leaflet-control.elevation .mouse-drag{fill:#00cc33; opacity: 0.2}
+.white-theme .leaflet-control.elevation .axis text{ x: -10; }
+.text {
+    color:#00cc33
+}
\ No newline at end of file
diff --git a/web/src/main/webapp/css/images/elevation.png b/web/src/main/webapp/css/images/elevation.png
new file mode 100644
index 0000000000..68fb537e42
Binary files /dev/null and b/web/src/main/webapp/css/images/elevation.png differ
diff --git a/web/src/main/webapp/css/images/loading.gif b/web/src/main/webapp/css/images/loading.gif
new file mode 100644
index 0000000000..ed65b705af
Binary files /dev/null and b/web/src/main/webapp/css/images/loading.gif differ
diff --git a/web/src/main/webapp/css/leaflet.contextmenu.css b/web/src/main/webapp/css/leaflet.contextmenu.css
new file mode 100644
index 0000000000..568e1a889a
--- /dev/null
+++ b/web/src/main/webapp/css/leaflet.contextmenu.css
@@ -0,0 +1,62 @@
+.leaflet-contextmenu {
+    display: none;
+	box-shadow: 0 1px 7px rgba(0,0,0,0.4);
+	-webkit-border-radius: 4px;
+	border-radius: 4px;
+    padding: 4px 0;
+    background-color: #fff;
+    cursor: default;
+	-webkit-user-select: none;
+	-moz-user-select: none;
+	user-select: none;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item {
+    display: block;
+    color: #222;
+    font-size: 12px;
+    line-height: 20px;
+    text-decoration: none;
+    padding: 0 12px;
+    border-top: 1px solid transparent;
+    border-bottom: 1px solid transparent;
+    cursor: default;
+    outline: none;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item-disabled {
+    opacity: 0.5;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item-hidden {
+    display: none;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item.over {
+    background-color: #f4f4f4;
+    border-top: 1px solid #f0f0f0;
+    border-bottom: 1px solid #f0f0f0;
+}
+
+.leaflet-contextmenu a.leaflet-contextmenu-item-disabled.over {
+    background-color: inherit;
+    border-top: 1px solid transparent;
+    border-bottom: 1px solid transparent;
+}
+
+.leaflet-contextmenu-icon {
+    margin: 2px 8px 0 0;
+    width: 16px;
+    height: 16px;
+    float: left;
+    border: 0;
+}
+
+.leaflet-contextmenu-separator {
+    border-bottom: 1px solid #ccc;
+    margin: 5px 0;
+}
+
+.leaflet-contextmenu-separator-hidden {
+    display: none;
+}
\ No newline at end of file
diff --git a/web/src/main/webapp/css/leaflet.css b/web/src/main/webapp/css/leaflet.css
index 7e77da3460..1232550253 100644
--- a/web/src/main/webapp/css/leaflet.css
+++ b/web/src/main/webapp/css/leaflet.css
@@ -65,6 +65,16 @@
 .leaflet-marker-pane  { z-index: 6; }
 .leaflet-popup-pane   { z-index: 7; }
 
+.leaflet-vml-shape {
+	width: 1px;
+	height: 1px;
+	}
+.lvml {
+	behavior: url(#default#VML);
+	display: inline-block;
+	position: absolute;
+	}
+
 
 /* control positioning */
 
@@ -160,9 +170,8 @@
 .leaflet-control {
 	cursor: auto;
 	}
-.leaflet-dragging,
-.leaflet-dragging .leaflet-clickable,
-.leaflet-dragging .leaflet-container {
+.leaflet-dragging .leaflet-container,
+.leaflet-dragging .leaflet-clickable {
 	cursor: move;
 	cursor: -webkit-grabbing;
 	cursor:    -moz-grabbing;
@@ -182,9 +191,8 @@
 	outline: 2px solid orange;
 	}
 .leaflet-zoom-box {
-	border: 2px dotted #05f;
-	background: white;
-	opacity: 0.5;
+	border: 2px dotted #38f;
+	background: rgba(255,255,255,0.5);
 	}
 
 
@@ -197,11 +205,11 @@
 /* general toolbar styles */
 
 .leaflet-bar {
-	box-shadow: 0 1px 7px rgba(0,0,0,0.65);
-	-webkit-border-radius: 4px;
-	        border-radius: 4px;
+	box-shadow: 0 1px 5px rgba(0,0,0,0.65);
+	border-radius: 4px;
 	}
-.leaflet-bar a, .leaflet-bar a:hover {
+.leaflet-bar a,
+.leaflet-bar a:hover {
 	background-color: #fff;
 	border-bottom: 1px solid #ccc;
 	width: 26px;
@@ -222,16 +230,12 @@
 	background-color: #f4f4f4;
 	}
 .leaflet-bar a:first-child {
-	-webkit-border-top-left-radius: 4px;
-	        border-top-left-radius: 4px;
-	-webkit-border-top-right-radius: 4px;
-	        border-top-right-radius: 4px;
+	border-top-left-radius: 4px;
+	border-top-right-radius: 4px;
 	}
 .leaflet-bar a:last-child {
-	-webkit-border-bottom-left-radius: 4px;
-	        border-bottom-left-radius: 4px;
-	-webkit-border-bottom-right-radius: 4px;
-	        border-bottom-right-radius: 4px;
+	border-bottom-left-radius: 4px;
+	border-bottom-right-radius: 4px;
 	border-bottom: none;
 	}
 .leaflet-bar a.leaflet-disabled {
@@ -240,55 +244,38 @@
 	color: #bbb;
 	}
 
-.leaflet-touch .leaflet-bar {
-	-webkit-border-radius: 10px;
-	        border-radius: 10px;
-	}
 .leaflet-touch .leaflet-bar a {
 	width: 30px;
 	height: 30px;
-	}
-.leaflet-touch .leaflet-bar a:first-child {
-	-webkit-border-top-left-radius: 7px;
-	        border-top-left-radius: 7px;
-	-webkit-border-top-right-radius: 7px;
-	        border-top-right-radius: 7px;
-	}
-.leaflet-touch .leaflet-bar a:last-child {
-	-webkit-border-bottom-left-radius: 7px;
-	        border-bottom-left-radius: 7px;
-	-webkit-border-bottom-right-radius: 7px;
-	        border-bottom-right-radius: 7px;
-	border-bottom: none;
+	line-height: 30px;
 	}
 
 
 /* zoom control */
 
-.leaflet-control-zoom-in {
+.leaflet-control-zoom-in,
+.leaflet-control-zoom-out {
 	font: bold 18px 'Lucida Console', Monaco, monospace;
+	text-indent: 1px;
 	}
 .leaflet-control-zoom-out {
-	font: bold 22px 'Lucida Console', Monaco, monospace;
+	font-size: 20px;
 	}
 
 .leaflet-touch .leaflet-control-zoom-in {
 	font-size: 22px;
-	line-height: 30px;
 	}
 .leaflet-touch .leaflet-control-zoom-out {
-	font-size: 28px;
-	line-height: 30px;
+	font-size: 24px;
 	}
 
 
 /* layers control */
 
 .leaflet-control-layers {
-	box-shadow: 0 1px 7px rgba(0,0,0,0.4);
-	background: #f8f8f9;
-	-webkit-border-radius: 5px;
-	        border-radius: 5px;
+	box-shadow: 0 1px 5px rgba(0,0,0,0.4);
+	background: #fff;
+	border-radius: 5px;
 	}
 .leaflet-control-layers-toggle {
 	background-image: url(images/layers.png);
@@ -334,8 +321,8 @@
 /* attribution and scale controls */
 
 .leaflet-container .leaflet-control-attribution {
-	background-color: rgba(255, 255, 255, 0.7);
-	box-shadow: 0 0 5px #bbb;
+	background: #fff;
+	background: rgba(255, 255, 255, 0.7);
 	margin: 0;
 	}
 .leaflet-control-attribution,
@@ -343,6 +330,12 @@
 	padding: 0 5px;
 	color: #333;
 	}
+.leaflet-control-attribution a {
+	text-decoration: none;
+	}
+.leaflet-control-attribution a:hover {
+	text-decoration: underline;
+	}
 .leaflet-container .leaflet-control-attribution,
 .leaflet-container .leaflet-control-scale {
 	font-size: 11px;
@@ -356,21 +349,21 @@
 .leaflet-control-scale-line {
 	border: 2px solid #777;
 	border-top: none;
-	color: black;
 	line-height: 1.1;
 	padding: 2px 5px 1px;
 	font-size: 11px;
-	text-shadow: 1px 1px 1px #fff;
-	background-color: rgba(255, 255, 255, 0.5);
-	box-shadow: 0 -1px 5px rgba(0, 0, 0, 0.2);
 	white-space: nowrap;
 	overflow: hidden;
+	-moz-box-sizing: content-box;
+	     box-sizing: content-box;
+
+	background: #fff;
+	background: rgba(255, 255, 255, 0.5);
 	}
 .leaflet-control-scale-line:not(:first-child) {
 	border-top: 2px solid #777;
 	border-bottom: none;
 	margin-top: -2px;
-	box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 	}
 .leaflet-control-scale-line:not(:first-child):not(:last-child) {
 	border-bottom: 2px solid #777;
@@ -383,7 +376,8 @@
 	}
 .leaflet-touch .leaflet-control-layers,
 .leaflet-touch .leaflet-bar {
-	border: 4px solid rgba(0,0,0,0.3);
+	border: 2px solid rgba(0,0,0,0.2);
+	background-clip: padding-box;
 	}
 
 
@@ -396,8 +390,7 @@
 .leaflet-popup-content-wrapper {
 	padding: 1px;
 	text-align: left;
-	-webkit-border-radius: 12px;
-	        border-radius: 12px;
+	border-radius: 12px;
 	}
 .leaflet-popup-content {
 	margin: 13px 19px;
@@ -426,7 +419,8 @@
 	     -o-transform: rotate(45deg);
 	        transform: rotate(45deg);
 	}
-.leaflet-popup-content-wrapper, .leaflet-popup-tip {
+.leaflet-popup-content-wrapper,
+.leaflet-popup-tip {
 	background: white;
 
 	box-shadow: 0 3px 14px rgba(0,0,0,0.4);
@@ -454,6 +448,27 @@
 	border-top: 1px solid #ddd;
 	}
 
+.leaflet-oldie .leaflet-popup-content-wrapper {
+	zoom: 1;
+	}
+.leaflet-oldie .leaflet-popup-tip {
+	width: 24px;
+	margin: 0 auto;
+
+	-ms-filter: "progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)";
+	filter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);
+	}
+.leaflet-oldie .leaflet-popup-tip-container {
+	margin-top: -1px;
+	}
+
+.leaflet-oldie .leaflet-control-zoom,
+.leaflet-oldie .leaflet-control-layers,
+.leaflet-oldie .leaflet-popup-content-wrapper,
+.leaflet-oldie .leaflet-popup-tip {
+	border: 1px solid #999;
+	}
+
 
 /* div icon */
 
@@ -461,7 +476,3 @@
 	background: #fff;
 	border: 1px solid #666;
 	}
-.leaflet-editing-icon {
-	-webkit-border-radius: 2px;
-	        border-radius: 2px;
-	}
diff --git a/web/src/main/webapp/css/leaflet.ie.css b/web/src/main/webapp/css/leaflet.ie.css
deleted file mode 100644
index f3daf1f3c0..0000000000
--- a/web/src/main/webapp/css/leaflet.ie.css
+++ /dev/null
@@ -1,51 +0,0 @@
-.leaflet-vml-shape {
-	width: 1px;
-	height: 1px;
-	}
-.lvml {
-	behavior: url(#default#VML);
-	display: inline-block;
-	position: absolute;
-	}
-
-.leaflet-control {
-	display: inline;
-	}
-
-.leaflet-popup-tip {
-	width: 21px;
-	_width: 27px;
-	margin: 0 auto;
-	_margin-top: -3px;
-
-	filter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);
-	-ms-filter: "progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)";
-	}
-.leaflet-popup-tip-container {
-	margin-top: -1px;
-	}
-.leaflet-popup-content-wrapper, .leaflet-popup-tip {
-	border: 1px solid #999;
-	}
-.leaflet-popup-content-wrapper {
-	zoom: 1;
-	}
-
-.leaflet-control-zoom,
-.leaflet-control-layers {
-	border: 3px solid #999;
-	}
-.leaflet-control-layers-toggle {
-	}
-.leaflet-control-attribution,
-.leaflet-control-layers,
-.leaflet-control-scale-line {
-	background: white;
-	}
-.leaflet-zoom-box {
-	filter: alpha(opacity=50);
-	}
-.leaflet-control-attribution {
-	border-top: 1px solid #bbb;
-	border-left: 1px solid #bbb;
-	}
diff --git a/web/src/main/webapp/css/leaflet.loading.css b/web/src/main/webapp/css/leaflet.loading.css
new file mode 100644
index 0000000000..79657a4741
--- /dev/null
+++ b/web/src/main/webapp/css/leaflet.loading.css
@@ -0,0 +1,22 @@
+.leaflet-control-loading {
+    background: url(images/loading.gif);
+}
+
+.leaflet-control-loading,
+.leaflet-control-zoom a.leaflet-control-loading ,
+.leaflet-control-zoomslider a.leaflet-control-loading {
+    display: none;
+}
+
+.leaflet-control-loading.is-loading,
+.leaflet-control-zoom a.leaflet-control-loading.is-loading,
+.leaflet-control-zoomslider a.leaflet-control-loading.is-loading  {
+    display: block;
+}
+
+/* Necessary for display consistency in Leaflet >= 0.6 */
+.leaflet-bar-part-bottom {
+    border-bottom: medium none;
+    border-bottom-left-radius: 4px;
+    border-bottom-right-radius: 4px;
+}
diff --git a/web/src/main/webapp/css/style.css b/web/src/main/webapp/css/style.css
index 9449ce7c01..0d796d4261 100644
--- a/web/src/main/webapp/css/style.css
+++ b/web/src/main/webapp/css/style.css
@@ -1,24 +1,25 @@
 body {                
     color: #000;
     font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;    
-    line-height: 1.4;    
+    line-height: 1.4;
     color: #111111;
-    background-color: #EEEEEE;
+    background-color: white;
     margin: 0;
+    min-width: 600px;
 }
-#map {
-    /*    float: right;*/
-    width: 800px;
-    height: 600px;
+#map {    
+    /* set size via JS */
     cursor: default;
 }
+
 #input {
     float: left;                
-    padding-left: 10px; 
-    padding-right: 15px; 
+    margin-left: 10px; 
+    /*padding-right: 15px; */
 }
 
 #info {
+    margin-top: 10px;
     border: lightgray groove thin;
     display: none;
     padding: 5px;
@@ -28,19 +29,19 @@ body {
     padding-right: 5px;
 }
 #input, #instructions {
-    width: 255px;
+    width: 280px;
 }
-#fromInput, #toInput {
-    width: 225px;
-    float: right;    
+.pointInput {
+    width: 235px;
+    float: left;
 }
 
-#fromResolveFound a, #toResolveFound a {
+.pointResolveFound a {
     background-color: white;
     padding-left: 4px;
     padding-right: 3px;    
 }
-#fromResolveFound, #toResolveFound {
+.pointResolveFound {
     overflow: hidden;
     max-height: 24px;
     font-size: 10px;
@@ -51,10 +52,12 @@ body {
     margin-right: 2px;    
 }
 
-#fromResolveError, #toResolveError {
-    float: right;
+.pointResolveError {
+    float: left;
     font-size: 12px;
     padding-bottom: 4px;
+    width: 100%;
+    text-align: right;
 }
 
 .boxSizingBorder {
@@ -65,7 +68,7 @@ body {
 .warn {
     color: orange;
 }
-.error, #fromResolveError, #toResolveError {
+.error, .pointResolveError {
     color: red;
 }
 #moreattribution a {
@@ -76,15 +79,27 @@ body {
     padding-top: 20px;
     color: #666666                    
 }
-#fromDiv img, #toDiv img {
+#locationpoints {
+    padding-bottom: 10px;
+    float: left;
+}
+.pointDiv { 
+    margin: 6px 0;
+}
+.pointDiv > img {
     margin-top: 4px;
-    padding-right: 3px;                
+    padding-left: 3px;
+    padding-right: 3px;
     float: left;
 }
 .left {
     float: left;
 }
+.right {
+    float: right;
+}
 #routeDetails {
+    padding: 20px;
     font-size: 12px;
 }
 .hidden {
@@ -109,10 +124,11 @@ body {
 }
 #header_img {
     padding-top: 15px;
+    padding-left: 20px;
     padding-bottom: 15px;
 }
 #header_img img {
-    width: 200px;
+    width: 230px;
 }
 #gpxExportButton {
     margin-top: -3px;
@@ -124,44 +140,75 @@ body {
     float: right;
     margin-bottom: 5px;
 }
+
+#searchButton:hover { 
+    cursor: pointer; 
+}
 .clear {
     clear: both;
 }
 #hosting {
-    padding-top: 10px;
-    color: gray;                
+    display: none;
+    /*    float: left;*/
+    padding-top: 4px;
+    padding-bottom: 10px;
+    /* color: #666666; */
+    font-size: smaller;
+    opacity: 0.8;
+    width: 200px;
+}
+
+#footer {
+    position: fixed;
+    bottom: 5px;
+    left: 45px;
+}
+
+#hosting a, .footer-link {
+    text-decoration: none;
+    color: #00cc33;
 }
-#hosting a {
-    color: gray;                
+.footer-link {    
+    padding-right: 12px;    
+    font-size: 12px;    
 }
 
-.instruction {    
-    padding-top: 5px;
-    padding-bottom: 5px;
+#export-link {
+    padding-left: 3px;
+    padding-top: 3px;
+    float: left;
 }
-tr.instruction td {
-    border-bottom: beige groove thin;
+
+tr.instruction {
+    cursor: pointer;
+    border-bottom: #dadada dashed thin;
 }
 #instructions {
+    table-layout:fixed;
     border-collapse: collapse;
     padding-top: 10px;
     width: 100%;
     font-size: smaller;
 }
+
 #instructions th, #instructions td {
-    padding: 3px;
-}
-.instr_title {    
+    padding: 6px 3px;
 }
-.instr_distance_td {
-    min-width: 40px;
+
+td.instr_title {
+    width: 130px;
 }
-.instr_distance {
+td.instr_distance {
+    min-width: 50px;
     float: right;    
     color: gray;
     text-align: right;
 }
-.instr_pic {    
+
+#instructions tr .instr_pic {
+    width: 20px;
+}
+td img.pic {    
     max-height: 24px;
     max-width: 16px;
 }
@@ -188,14 +235,59 @@ tr.instruction td {
     background-image: linear-gradient(to bottom, #9f9f9f, #e7e7e7);    
 }
 
-.complete-1, .complete-2 { border: 1px solid #999; background: #FFF; overflow: auto; }
-.complete-1 strong, .complete-2 strong { font-weight: normal; /*color: #3399FF;*/; color: #04B431; }
-.autocomplete-suggestion { padding: 2px 5px; white-space: nowrap; overflow: hidden; font-size: 12px; }
-.autocomplete-selected { background: #e7e7e7; }
+.autocomplete {
+    border: 1px solid #999; 
+    background: #FFF; 
+    overflow: auto; 
+}
+.autocomplete strong { 
+    font-weight: normal;
+    color: #04B431; 
+}
+.autocomplete-suggestion { 
+    padding: 5px 5px; 
+    white-space: nowrap; 
+    overflow: hidden;
+    font-size: small;
+    background-image: linear-gradient(to bottom, white, #e7e7e7);
+}
+.autocomplete-selected { 
+    padding: 5px 5px; 
+    background: #e7e7e7; 
+    background-image: linear-gradient(to bottom, #9f9f9f, #e7e7e7);
+}
 .light { font-weight: lighter; color: #9f9f9f; font-size: smaller }
 .wikilink { float: right; }
 .wikilink img { max-width: 16px; }
 
-.roadseg {}
-.cityseg {}
-.moreseg { font-size: 9px; }
\ No newline at end of file
+.nameseg { /*border-top: #dadada dashed thin;*/ }
+.cityseg { float: left; font-size: 10px; }
+.moreseg { float: right; font-size: 9px; }
+
+.pointFlag {
+    width: 16px;
+    height: 16px;
+}
+.pointFlag:hover { cursor: n-resize; }
+.pointAdd {
+    padding-left: 3px;
+}
+.pointDelete {
+    float: left;    
+    padding-left: 2px;
+}
+.pointDelete:hover, .pointAdd:hover { cursor: pointer; }
+
+#expandDetails {
+    color: gray;
+    font-size:14px; 
+    float: right;
+    font-weight: bold;    
+
+    width: 20px;
+    height: 20px;    
+    background-image: linear-gradient(to bottom, white, #e7e7e7);
+}
+#moreButton {
+    background-image: linear-gradient(to bottom, white, #e7e7e7);
+}
diff --git a/web/src/main/webapp/css/ui-lightness/images/animated-overlay.gif b/web/src/main/webapp/css/ui-lightness/images/animated-overlay.gif
new file mode 100644
index 0000000000..d441f75ebf
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/animated-overlay.gif differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_18_b81900_40x40.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_18_b81900_40x40.png
new file mode 100644
index 0000000000..4e691deaa0
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_18_b81900_40x40.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_20_666666_40x40.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_20_666666_40x40.png
new file mode 100644
index 0000000000..7bc8a92833
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_diagonals-thick_20_666666_40x40.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_flat_10_000000_40x100.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_flat_10_000000_40x100.png
new file mode 100644
index 0000000000..c5d10e6570
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_flat_10_000000_40x100.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_f6f6f6_1x400.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_f6f6f6_1x400.png
new file mode 100644
index 0000000000..ae8f555ac4
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_f6f6f6_1x400.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_fdf5ce_1x400.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_fdf5ce_1x400.png
new file mode 100644
index 0000000000..c2c57063a1
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_100_fdf5ce_1x400.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_65_ffffff_1x400.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_65_ffffff_1x400.png
new file mode 100644
index 0000000000..b559b14a93
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_glass_65_ffffff_1x400.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_gloss-wave_35_f6a828_500x100.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_gloss-wave_35_f6a828_500x100.png
new file mode 100644
index 0000000000..f8b3d68025
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_gloss-wave_35_f6a828_500x100.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_100_eeeeee_1x100.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_100_eeeeee_1x100.png
new file mode 100644
index 0000000000..c121135c6d
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_100_eeeeee_1x100.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_75_ffe45c_1x100.png b/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_75_ffe45c_1x100.png
new file mode 100644
index 0000000000..9c7d2f6b6b
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-bg_highlight-soft_75_ffe45c_1x100.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_222222_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_222222_256x240.png
new file mode 100644
index 0000000000..1106eef30c
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_222222_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_228ef1_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_228ef1_256x240.png
new file mode 100644
index 0000000000..8c64a89499
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_228ef1_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_ef8c08_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ef8c08_256x240.png
new file mode 100644
index 0000000000..760f14a327
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ef8c08_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffd27a_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffd27a_256x240.png
new file mode 100644
index 0000000000..21fd40e9c6
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffd27a_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffffff_256x240.png b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffffff_256x240.png
new file mode 100644
index 0000000000..7cfcb5c95f
Binary files /dev/null and b/web/src/main/webapp/css/ui-lightness/images/ui-icons_ffffff_256x240.png differ
diff --git a/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.css b/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.css
new file mode 100644
index 0000000000..5ce18d9e9c
--- /dev/null
+++ b/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.css
@@ -0,0 +1,1178 @@
+/*! jQuery UI - v1.10.4 - 2014-04-02
+* http://jqueryui.com
+* Includes: jquery.ui.core.css, jquery.ui.accordion.css, jquery.ui.autocomplete.css, jquery.ui.button.css, jquery.ui.datepicker.css, jquery.ui.dialog.css, jquery.ui.menu.css, jquery.ui.progressbar.css, jquery.ui.resizable.css, jquery.ui.selectable.css, jquery.ui.slider.css, jquery.ui.spinner.css, jquery.ui.tabs.css, jquery.ui.tooltip.css, jquery.ui.theme.css
+* To view and modify this theme, visit http://jqueryui.com/themeroller/?ffDefault=Trebuchet%20MS%2CTahoma%2CVerdana%2CArial%2Csans-serif&fwDefault=bold&fsDefault=1.1em&cornerRadius=4px&bgColorHeader=f6a828&bgTextureHeader=gloss_wave&bgImgOpacityHeader=35&borderColorHeader=e78f08&fcHeader=ffffff&iconColorHeader=ffffff&bgColorContent=eeeeee&bgTextureContent=highlight_soft&bgImgOpacityContent=100&borderColorContent=dddddd&fcContent=333333&iconColorContent=222222&bgColorDefault=f6f6f6&bgTextureDefault=glass&bgImgOpacityDefault=100&borderColorDefault=cccccc&fcDefault=1c94c4&iconColorDefault=ef8c08&bgColorHover=fdf5ce&bgTextureHover=glass&bgImgOpacityHover=100&borderColorHover=fbcb09&fcHover=c77405&iconColorHover=ef8c08&bgColorActive=ffffff&bgTextureActive=glass&bgImgOpacityActive=65&borderColorActive=fbd850&fcActive=eb8f00&iconColorActive=ef8c08&bgColorHighlight=ffe45c&bgTextureHighlight=highlight_soft&bgImgOpacityHighlight=75&borderColorHighlight=fed22f&fcHighlight=363636&iconColorHighlight=228ef1&bgColorError=b81900&bgTextureError=diagonals_thick&bgImgOpacityError=18&borderColorError=cd0a0a&fcError=ffffff&iconColorError=ffd27a&bgColorOverlay=666666&bgTextureOverlay=diagonals_thick&bgImgOpacityOverlay=20&opacityOverlay=50&bgColorShadow=000000&bgTextureShadow=flat&bgImgOpacityShadow=10&opacityShadow=20&thicknessShadow=5px&offsetTopShadow=-5px&offsetLeftShadow=-5px&cornerRadiusShadow=5px
+* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
+
+/* Layout helpers
+----------------------------------*/
+.ui-helper-hidden {
+	display: none;
+}
+.ui-helper-hidden-accessible {
+	border: 0;
+	clip: rect(0 0 0 0);
+	height: 1px;
+	margin: -1px;
+	overflow: hidden;
+	padding: 0;
+	position: absolute;
+	width: 1px;
+}
+.ui-helper-reset {
+	margin: 0;
+	padding: 0;
+	border: 0;
+	outline: 0;
+	line-height: 1.3;
+	text-decoration: none;
+	font-size: 100%;
+	list-style: none;
+}
+.ui-helper-clearfix:before,
+.ui-helper-clearfix:after {
+	content: "";
+	display: table;
+	border-collapse: collapse;
+}
+.ui-helper-clearfix:after {
+	clear: both;
+}
+.ui-helper-clearfix {
+	min-height: 0; /* support: IE7 */
+}
+.ui-helper-zfix {
+	width: 100%;
+	height: 100%;
+	top: 0;
+	left: 0;
+	position: absolute;
+	opacity: 0;
+	filter:Alpha(Opacity=0);
+}
+
+.ui-front {
+	z-index: 100;
+}
+
+
+/* Interaction Cues
+----------------------------------*/
+.ui-state-disabled {
+	cursor: default !important;
+}
+
+
+/* Icons
+----------------------------------*/
+
+/* states and images */
+.ui-icon {
+	display: block;
+	text-indent: -99999px;
+	overflow: hidden;
+	background-repeat: no-repeat;
+}
+
+
+/* Misc visuals
+----------------------------------*/
+
+/* Overlays */
+.ui-widget-overlay {
+	position: fixed;
+	top: 0;
+	left: 0;
+	width: 100%;
+	height: 100%;
+}
+.ui-accordion .ui-accordion-header {
+	display: block;
+	cursor: pointer;
+	position: relative;
+	margin-top: 2px;
+	padding: .5em .5em .5em .7em;
+	min-height: 0; /* support: IE7 */
+}
+.ui-accordion .ui-accordion-icons {
+	padding-left: 2.2em;
+}
+.ui-accordion .ui-accordion-noicons {
+	padding-left: .7em;
+}
+.ui-accordion .ui-accordion-icons .ui-accordion-icons {
+	padding-left: 2.2em;
+}
+.ui-accordion .ui-accordion-header .ui-accordion-header-icon {
+	position: absolute;
+	left: .5em;
+	top: 50%;
+	margin-top: -8px;
+}
+.ui-accordion .ui-accordion-content {
+	padding: 1em 2.2em;
+	border-top: 0;
+	overflow: auto;
+}
+.ui-autocomplete {
+	position: absolute;
+	top: 0;
+	left: 0;
+	cursor: default;
+}
+.ui-button {
+	display: inline-block;
+	position: relative;
+	padding: 0;
+	line-height: normal;
+	margin-right: .1em;
+	cursor: pointer;
+	vertical-align: middle;
+	text-align: center;
+	overflow: visible; /* removes extra width in IE */
+}
+.ui-button,
+.ui-button:link,
+.ui-button:visited,
+.ui-button:hover,
+.ui-button:active {
+	text-decoration: none;
+}
+/* to make room for the icon, a width needs to be set here */
+.ui-button-icon-only {
+	width: 2.2em;
+}
+/* button elements seem to need a little more width */
+button.ui-button-icon-only {
+	width: 2.4em;
+}
+.ui-button-icons-only {
+	width: 3.4em;
+}
+button.ui-button-icons-only {
+	width: 3.7em;
+}
+
+/* button text element */
+.ui-button .ui-button-text {
+	display: block;
+	line-height: normal;
+}
+.ui-button-text-only .ui-button-text {
+	padding: .4em 1em;
+}
+.ui-button-icon-only .ui-button-text,
+.ui-button-icons-only .ui-button-text {
+	padding: .4em;
+	text-indent: -9999999px;
+}
+.ui-button-text-icon-primary .ui-button-text,
+.ui-button-text-icons .ui-button-text {
+	padding: .4em 1em .4em 2.1em;
+}
+.ui-button-text-icon-secondary .ui-button-text,
+.ui-button-text-icons .ui-button-text {
+	padding: .4em 2.1em .4em 1em;
+}
+.ui-button-text-icons .ui-button-text {
+	padding-left: 2.1em;
+	padding-right: 2.1em;
+}
+/* no icon support for input elements, provide padding by default */
+input.ui-button {
+	padding: .4em 1em;
+}
+
+/* button icon element(s) */
+.ui-button-icon-only .ui-icon,
+.ui-button-text-icon-primary .ui-icon,
+.ui-button-text-icon-secondary .ui-icon,
+.ui-button-text-icons .ui-icon,
+.ui-button-icons-only .ui-icon {
+	position: absolute;
+	top: 50%;
+	margin-top: -8px;
+}
+.ui-button-icon-only .ui-icon {
+	left: 50%;
+	margin-left: -8px;
+}
+.ui-button-text-icon-primary .ui-button-icon-primary,
+.ui-button-text-icons .ui-button-icon-primary,
+.ui-button-icons-only .ui-button-icon-primary {
+	left: .5em;
+}
+.ui-button-text-icon-secondary .ui-button-icon-secondary,
+.ui-button-text-icons .ui-button-icon-secondary,
+.ui-button-icons-only .ui-button-icon-secondary {
+	right: .5em;
+}
+
+/* button sets */
+.ui-buttonset {
+	margin-right: 7px;
+}
+.ui-buttonset .ui-button {
+	margin-left: 0;
+	margin-right: -.3em;
+}
+
+/* workarounds */
+/* reset extra padding in Firefox, see h5bp.com/l */
+input.ui-button::-moz-focus-inner,
+button.ui-button::-moz-focus-inner {
+	border: 0;
+	padding: 0;
+}
+.ui-datepicker {
+	width: 17em;
+	padding: .2em .2em 0;
+	display: none;
+}
+.ui-datepicker .ui-datepicker-header {
+	position: relative;
+	padding: .2em 0;
+}
+.ui-datepicker .ui-datepicker-prev,
+.ui-datepicker .ui-datepicker-next {
+	position: absolute;
+	top: 2px;
+	width: 1.8em;
+	height: 1.8em;
+}
+.ui-datepicker .ui-datepicker-prev-hover,
+.ui-datepicker .ui-datepicker-next-hover {
+	top: 1px;
+}
+.ui-datepicker .ui-datepicker-prev {
+	left: 2px;
+}
+.ui-datepicker .ui-datepicker-next {
+	right: 2px;
+}
+.ui-datepicker .ui-datepicker-prev-hover {
+	left: 1px;
+}
+.ui-datepicker .ui-datepicker-next-hover {
+	right: 1px;
+}
+.ui-datepicker .ui-datepicker-prev span,
+.ui-datepicker .ui-datepicker-next span {
+	display: block;
+	position: absolute;
+	left: 50%;
+	margin-left: -8px;
+	top: 50%;
+	margin-top: -8px;
+}
+.ui-datepicker .ui-datepicker-title {
+	margin: 0 2.3em;
+	line-height: 1.8em;
+	text-align: center;
+}
+.ui-datepicker .ui-datepicker-title select {
+	font-size: 1em;
+	margin: 1px 0;
+}
+.ui-datepicker select.ui-datepicker-month,
+.ui-datepicker select.ui-datepicker-year {
+	width: 49%;
+}
+.ui-datepicker table {
+	width: 100%;
+	font-size: .9em;
+	border-collapse: collapse;
+	margin: 0 0 .4em;
+}
+.ui-datepicker th {
+	padding: .7em .3em;
+	text-align: center;
+	font-weight: bold;
+	border: 0;
+}
+.ui-datepicker td {
+	border: 0;
+	padding: 1px;
+}
+.ui-datepicker td span,
+.ui-datepicker td a {
+	display: block;
+	padding: .2em;
+	text-align: right;
+	text-decoration: none;
+}
+.ui-datepicker .ui-datepicker-buttonpane {
+	background-image: none;
+	margin: .7em 0 0 0;
+	padding: 0 .2em;
+	border-left: 0;
+	border-right: 0;
+	border-bottom: 0;
+}
+.ui-datepicker .ui-datepicker-buttonpane button {
+	float: right;
+	margin: .5em .2em .4em;
+	cursor: pointer;
+	padding: .2em .6em .3em .6em;
+	width: auto;
+	overflow: visible;
+}
+.ui-datepicker .ui-datepicker-buttonpane button.ui-datepicker-current {
+	float: left;
+}
+
+/* with multiple calendars */
+.ui-datepicker.ui-datepicker-multi {
+	width: auto;
+}
+.ui-datepicker-multi .ui-datepicker-group {
+	float: left;
+}
+.ui-datepicker-multi .ui-datepicker-group table {
+	width: 95%;
+	margin: 0 auto .4em;
+}
+.ui-datepicker-multi-2 .ui-datepicker-group {
+	width: 50%;
+}
+.ui-datepicker-multi-3 .ui-datepicker-group {
+	width: 33.3%;
+}
+.ui-datepicker-multi-4 .ui-datepicker-group {
+	width: 25%;
+}
+.ui-datepicker-multi .ui-datepicker-group-last .ui-datepicker-header,
+.ui-datepicker-multi .ui-datepicker-group-middle .ui-datepicker-header {
+	border-left-width: 0;
+}
+.ui-datepicker-multi .ui-datepicker-buttonpane {
+	clear: left;
+}
+.ui-datepicker-row-break {
+	clear: both;
+	width: 100%;
+	font-size: 0;
+}
+
+/* RTL support */
+.ui-datepicker-rtl {
+	direction: rtl;
+}
+.ui-datepicker-rtl .ui-datepicker-prev {
+	right: 2px;
+	left: auto;
+}
+.ui-datepicker-rtl .ui-datepicker-next {
+	left: 2px;
+	right: auto;
+}
+.ui-datepicker-rtl .ui-datepicker-prev:hover {
+	right: 1px;
+	left: auto;
+}
+.ui-datepicker-rtl .ui-datepicker-next:hover {
+	left: 1px;
+	right: auto;
+}
+.ui-datepicker-rtl .ui-datepicker-buttonpane {
+	clear: right;
+}
+.ui-datepicker-rtl .ui-datepicker-buttonpane button {
+	float: left;
+}
+.ui-datepicker-rtl .ui-datepicker-buttonpane button.ui-datepicker-current,
+.ui-datepicker-rtl .ui-datepicker-group {
+	float: right;
+}
+.ui-datepicker-rtl .ui-datepicker-group-last .ui-datepicker-header,
+.ui-datepicker-rtl .ui-datepicker-group-middle .ui-datepicker-header {
+	border-right-width: 0;
+	border-left-width: 1px;
+}
+.ui-dialog {
+	overflow: hidden;
+	position: absolute;
+	top: 0;
+	left: 0;
+	padding: .2em;
+	outline: 0;
+}
+.ui-dialog .ui-dialog-titlebar {
+	padding: .4em 1em;
+	position: relative;
+}
+.ui-dialog .ui-dialog-title {
+	float: left;
+	margin: .1em 0;
+	white-space: nowrap;
+	width: 90%;
+	overflow: hidden;
+	text-overflow: ellipsis;
+}
+.ui-dialog .ui-dialog-titlebar-close {
+	position: absolute;
+	right: .3em;
+	top: 50%;
+	width: 20px;
+	margin: -10px 0 0 0;
+	padding: 1px;
+	height: 20px;
+}
+.ui-dialog .ui-dialog-content {
+	position: relative;
+	border: 0;
+	padding: .5em 1em;
+	background: none;
+	overflow: auto;
+}
+.ui-dialog .ui-dialog-buttonpane {
+	text-align: left;
+	border-width: 1px 0 0 0;
+	background-image: none;
+	margin-top: .5em;
+	padding: .3em 1em .5em .4em;
+}
+.ui-dialog .ui-dialog-buttonpane .ui-dialog-buttonset {
+	float: right;
+}
+.ui-dialog .ui-dialog-buttonpane button {
+	margin: .5em .4em .5em 0;
+	cursor: pointer;
+}
+.ui-dialog .ui-resizable-se {
+	width: 12px;
+	height: 12px;
+	right: -5px;
+	bottom: -5px;
+	background-position: 16px 16px;
+}
+.ui-draggable .ui-dialog-titlebar {
+	cursor: move;
+}
+.ui-menu {
+	list-style: none;
+	padding: 2px;
+	margin: 0;
+	display: block;
+	outline: none;
+}
+.ui-menu .ui-menu {
+	margin-top: -3px;
+	position: absolute;
+}
+.ui-menu .ui-menu-item {
+	margin: 0;
+	padding: 0;
+	width: 100%;
+	/* support: IE10, see #8844 */
+	list-style-image: url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);
+}
+.ui-menu .ui-menu-divider {
+	margin: 5px -2px 5px -2px;
+	height: 0;
+	font-size: 0;
+	line-height: 0;
+	border-width: 1px 0 0 0;
+}
+.ui-menu .ui-menu-item a {
+	text-decoration: none;
+	display: block;
+	padding: 2px .4em;
+	line-height: 1.5;
+	min-height: 0; /* support: IE7 */
+	font-weight: normal;
+}
+.ui-menu .ui-menu-item a.ui-state-focus,
+.ui-menu .ui-menu-item a.ui-state-active {
+	font-weight: normal;
+	margin: -1px;
+}
+
+.ui-menu .ui-state-disabled {
+	font-weight: normal;
+	margin: .4em 0 .2em;
+	line-height: 1.5;
+}
+.ui-menu .ui-state-disabled a {
+	cursor: default;
+}
+
+/* icon support */
+.ui-menu-icons {
+	position: relative;
+}
+.ui-menu-icons .ui-menu-item a {
+	position: relative;
+	padding-left: 2em;
+}
+
+/* left-aligned */
+.ui-menu .ui-icon {
+	position: absolute;
+	top: .2em;
+	left: .2em;
+}
+
+/* right-aligned */
+.ui-menu .ui-menu-icon {
+	position: static;
+	float: right;
+}
+.ui-progressbar {
+	height: 2em;
+	text-align: left;
+	overflow: hidden;
+}
+.ui-progressbar .ui-progressbar-value {
+	margin: -1px;
+	height: 100%;
+}
+.ui-progressbar .ui-progressbar-overlay {
+	background: url("images/animated-overlay.gif");
+	height: 100%;
+	filter: alpha(opacity=25);
+	opacity: 0.25;
+}
+.ui-progressbar-indeterminate .ui-progressbar-value {
+	background-image: none;
+}
+.ui-resizable {
+	position: relative;
+}
+.ui-resizable-handle {
+	position: absolute;
+	font-size: 0.1px;
+	display: block;
+}
+.ui-resizable-disabled .ui-resizable-handle,
+.ui-resizable-autohide .ui-resizable-handle {
+	display: none;
+}
+.ui-resizable-n {
+	cursor: n-resize;
+	height: 7px;
+	width: 100%;
+	top: -5px;
+	left: 0;
+}
+.ui-resizable-s {
+	cursor: s-resize;
+	height: 7px;
+	width: 100%;
+	bottom: -5px;
+	left: 0;
+}
+.ui-resizable-e {
+	cursor: e-resize;
+	width: 7px;
+	right: -5px;
+	top: 0;
+	height: 100%;
+}
+.ui-resizable-w {
+	cursor: w-resize;
+	width: 7px;
+	left: -5px;
+	top: 0;
+	height: 100%;
+}
+.ui-resizable-se {
+	cursor: se-resize;
+	width: 12px;
+	height: 12px;
+	right: 1px;
+	bottom: 1px;
+}
+.ui-resizable-sw {
+	cursor: sw-resize;
+	width: 9px;
+	height: 9px;
+	left: -5px;
+	bottom: -5px;
+}
+.ui-resizable-nw {
+	cursor: nw-resize;
+	width: 9px;
+	height: 9px;
+	left: -5px;
+	top: -5px;
+}
+.ui-resizable-ne {
+	cursor: ne-resize;
+	width: 9px;
+	height: 9px;
+	right: -5px;
+	top: -5px;
+}
+.ui-selectable-helper {
+	position: absolute;
+	z-index: 100;
+	border: 1px dotted black;
+}
+.ui-slider {
+	position: relative;
+	text-align: left;
+}
+.ui-slider .ui-slider-handle {
+	position: absolute;
+	z-index: 2;
+	width: 1.2em;
+	height: 1.2em;
+	cursor: default;
+}
+.ui-slider .ui-slider-range {
+	position: absolute;
+	z-index: 1;
+	font-size: .7em;
+	display: block;
+	border: 0;
+	background-position: 0 0;
+}
+
+/* For IE8 - See #6727 */
+.ui-slider.ui-state-disabled .ui-slider-handle,
+.ui-slider.ui-state-disabled .ui-slider-range {
+	filter: inherit;
+}
+
+.ui-slider-horizontal {
+	height: .8em;
+}
+.ui-slider-horizontal .ui-slider-handle {
+	top: -.3em;
+	margin-left: -.6em;
+}
+.ui-slider-horizontal .ui-slider-range {
+	top: 0;
+	height: 100%;
+}
+.ui-slider-horizontal .ui-slider-range-min {
+	left: 0;
+}
+.ui-slider-horizontal .ui-slider-range-max {
+	right: 0;
+}
+
+.ui-slider-vertical {
+	width: .8em;
+	height: 100px;
+}
+.ui-slider-vertical .ui-slider-handle {
+	left: -.3em;
+	margin-left: 0;
+	margin-bottom: -.6em;
+}
+.ui-slider-vertical .ui-slider-range {
+	left: 0;
+	width: 100%;
+}
+.ui-slider-vertical .ui-slider-range-min {
+	bottom: 0;
+}
+.ui-slider-vertical .ui-slider-range-max {
+	top: 0;
+}
+.ui-spinner {
+	position: relative;
+	display: inline-block;
+	overflow: hidden;
+	padding: 0;
+	vertical-align: middle;
+}
+.ui-spinner-input {
+	border: none;
+	background: none;
+	color: inherit;
+	padding: 0;
+	margin: .2em 0;
+	vertical-align: middle;
+	margin-left: .4em;
+	margin-right: 22px;
+}
+.ui-spinner-button {
+	width: 16px;
+	height: 50%;
+	font-size: .5em;
+	padding: 0;
+	margin: 0;
+	text-align: center;
+	position: absolute;
+	cursor: default;
+	display: block;
+	overflow: hidden;
+	right: 0;
+}
+/* more specificity required here to override default borders */
+.ui-spinner a.ui-spinner-button {
+	border-top: none;
+	border-bottom: none;
+	border-right: none;
+}
+/* vertically center icon */
+.ui-spinner .ui-icon {
+	position: absolute;
+	margin-top: -8px;
+	top: 50%;
+	left: 0;
+}
+.ui-spinner-up {
+	top: 0;
+}
+.ui-spinner-down {
+	bottom: 0;
+}
+
+/* TR overrides */
+.ui-spinner .ui-icon-triangle-1-s {
+	/* need to fix icons sprite */
+	background-position: -65px -16px;
+}
+.ui-tabs {
+	position: relative;/* position: relative prevents IE scroll bug (element with position: relative inside container with overflow: auto appear as "fixed") */
+	padding: .2em;
+}
+.ui-tabs .ui-tabs-nav {
+	margin: 0;
+	padding: .2em .2em 0;
+}
+.ui-tabs .ui-tabs-nav li {
+	list-style: none;
+	float: left;
+	position: relative;
+	top: 0;
+	margin: 1px .2em 0 0;
+	border-bottom-width: 0;
+	padding: 0;
+	white-space: nowrap;
+}
+.ui-tabs .ui-tabs-nav .ui-tabs-anchor {
+	float: left;
+	padding: .5em 1em;
+	text-decoration: none;
+}
+.ui-tabs .ui-tabs-nav li.ui-tabs-active {
+	margin-bottom: -1px;
+	padding-bottom: 1px;
+}
+.ui-tabs .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor,
+.ui-tabs .ui-tabs-nav li.ui-state-disabled .ui-tabs-anchor,
+.ui-tabs .ui-tabs-nav li.ui-tabs-loading .ui-tabs-anchor {
+	cursor: text;
+}
+.ui-tabs-collapsible .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor {
+	cursor: pointer;
+}
+.ui-tabs .ui-tabs-panel {
+	display: block;
+	border-width: 0;
+	padding: 1em 1.4em;
+	background: none;
+}
+.ui-tooltip {
+	padding: 8px;
+	position: absolute;
+	z-index: 9999;
+	max-width: 300px;
+	-webkit-box-shadow: 0 0 5px #aaa;
+	box-shadow: 0 0 5px #aaa;
+}
+body .ui-tooltip {
+	border-width: 2px;
+}
+
+/* Component containers
+----------------------------------*/
+.ui-widget {
+	font-family: Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;
+	font-size: 1.1em;
+}
+.ui-widget .ui-widget {
+	font-size: 1em;
+}
+.ui-widget input,
+.ui-widget select,
+.ui-widget textarea,
+.ui-widget button {
+	font-family: Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;
+	font-size: 1em;
+}
+.ui-widget-content {
+	border: 1px solid #dddddd;
+	background: #eeeeee url("images/ui-bg_highlight-soft_100_eeeeee_1x100.png") 50% top repeat-x;
+	color: #333333;
+}
+.ui-widget-content a {
+	color: #333333;
+}
+.ui-widget-header {
+	border: 1px solid #e78f08;
+	background: #f6a828 url("images/ui-bg_gloss-wave_35_f6a828_500x100.png") 50% 50% repeat-x;
+	color: #ffffff;
+	font-weight: bold;
+}
+.ui-widget-header a {
+	color: #ffffff;
+}
+
+/* Interaction states
+----------------------------------*/
+.ui-state-default,
+.ui-widget-content .ui-state-default,
+.ui-widget-header .ui-state-default {
+	border: 1px solid #cccccc;
+	background: #f6f6f6 url("images/ui-bg_glass_100_f6f6f6_1x400.png") 50% 50% repeat-x;
+	font-weight: bold;
+	color: #1c94c4;
+}
+.ui-state-default a,
+.ui-state-default a:link,
+.ui-state-default a:visited {
+	color: #1c94c4;
+	text-decoration: none;
+}
+.ui-state-hover,
+.ui-widget-content .ui-state-hover,
+.ui-widget-header .ui-state-hover,
+.ui-state-focus,
+.ui-widget-content .ui-state-focus,
+.ui-widget-header .ui-state-focus {
+	border: 1px solid #fbcb09;
+	background: #fdf5ce url("images/ui-bg_glass_100_fdf5ce_1x400.png") 50% 50% repeat-x;
+	font-weight: bold;
+	color: #c77405;
+}
+.ui-state-hover a,
+.ui-state-hover a:hover,
+.ui-state-hover a:link,
+.ui-state-hover a:visited,
+.ui-state-focus a,
+.ui-state-focus a:hover,
+.ui-state-focus a:link,
+.ui-state-focus a:visited {
+	color: #c77405;
+	text-decoration: none;
+}
+.ui-state-active,
+.ui-widget-content .ui-state-active,
+.ui-widget-header .ui-state-active {
+	border: 1px solid #fbd850;
+	background: #ffffff url("images/ui-bg_glass_65_ffffff_1x400.png") 50% 50% repeat-x;
+	font-weight: bold;
+	color: #eb8f00;
+}
+.ui-state-active a,
+.ui-state-active a:link,
+.ui-state-active a:visited {
+	color: #eb8f00;
+	text-decoration: none;
+}
+
+/* Interaction Cues
+----------------------------------*/
+.ui-state-highlight,
+.ui-widget-content .ui-state-highlight,
+.ui-widget-header .ui-state-highlight {
+	border: 1px solid #fed22f;
+	background: #ffe45c url("images/ui-bg_highlight-soft_75_ffe45c_1x100.png") 50% top repeat-x;
+	color: #363636;
+}
+.ui-state-highlight a,
+.ui-widget-content .ui-state-highlight a,
+.ui-widget-header .ui-state-highlight a {
+	color: #363636;
+}
+.ui-state-error,
+.ui-widget-content .ui-state-error,
+.ui-widget-header .ui-state-error {
+	border: 1px solid #cd0a0a;
+	background: #b81900 url("images/ui-bg_diagonals-thick_18_b81900_40x40.png") 50% 50% repeat;
+	color: #ffffff;
+}
+.ui-state-error a,
+.ui-widget-content .ui-state-error a,
+.ui-widget-header .ui-state-error a {
+	color: #ffffff;
+}
+.ui-state-error-text,
+.ui-widget-content .ui-state-error-text,
+.ui-widget-header .ui-state-error-text {
+	color: #ffffff;
+}
+.ui-priority-primary,
+.ui-widget-content .ui-priority-primary,
+.ui-widget-header .ui-priority-primary {
+	font-weight: bold;
+}
+.ui-priority-secondary,
+.ui-widget-content .ui-priority-secondary,
+.ui-widget-header .ui-priority-secondary {
+	opacity: .7;
+	filter:Alpha(Opacity=70);
+	font-weight: normal;
+}
+.ui-state-disabled,
+.ui-widget-content .ui-state-disabled,
+.ui-widget-header .ui-state-disabled {
+	opacity: .35;
+	filter:Alpha(Opacity=35);
+	background-image: none;
+}
+.ui-state-disabled .ui-icon {
+	filter:Alpha(Opacity=35); /* For IE8 - See #6059 */
+}
+
+/* Icons
+----------------------------------*/
+
+/* states and images */
+.ui-icon {
+	width: 16px;
+	height: 16px;
+}
+.ui-icon,
+.ui-widget-content .ui-icon {
+	background-image: url("images/ui-icons_222222_256x240.png");
+}
+.ui-widget-header .ui-icon {
+	background-image: url("images/ui-icons_ffffff_256x240.png");
+}
+.ui-state-default .ui-icon {
+	background-image: url("images/ui-icons_ef8c08_256x240.png");
+}
+.ui-state-hover .ui-icon,
+.ui-state-focus .ui-icon {
+	background-image: url("images/ui-icons_ef8c08_256x240.png");
+}
+.ui-state-active .ui-icon {
+	background-image: url("images/ui-icons_ef8c08_256x240.png");
+}
+.ui-state-highlight .ui-icon {
+	background-image: url("images/ui-icons_228ef1_256x240.png");
+}
+.ui-state-error .ui-icon,
+.ui-state-error-text .ui-icon {
+	background-image: url("images/ui-icons_ffd27a_256x240.png");
+}
+
+/* positioning */
+.ui-icon-blank { background-position: 16px 16px; }
+.ui-icon-carat-1-n { background-position: 0 0; }
+.ui-icon-carat-1-ne { background-position: -16px 0; }
+.ui-icon-carat-1-e { background-position: -32px 0; }
+.ui-icon-carat-1-se { background-position: -48px 0; }
+.ui-icon-carat-1-s { background-position: -64px 0; }
+.ui-icon-carat-1-sw { background-position: -80px 0; }
+.ui-icon-carat-1-w { background-position: -96px 0; }
+.ui-icon-carat-1-nw { background-position: -112px 0; }
+.ui-icon-carat-2-n-s { background-position: -128px 0; }
+.ui-icon-carat-2-e-w { background-position: -144px 0; }
+.ui-icon-triangle-1-n { background-position: 0 -16px; }
+.ui-icon-triangle-1-ne { background-position: -16px -16px; }
+.ui-icon-triangle-1-e { background-position: -32px -16px; }
+.ui-icon-triangle-1-se { background-position: -48px -16px; }
+.ui-icon-triangle-1-s { background-position: -64px -16px; }
+.ui-icon-triangle-1-sw { background-position: -80px -16px; }
+.ui-icon-triangle-1-w { background-position: -96px -16px; }
+.ui-icon-triangle-1-nw { background-position: -112px -16px; }
+.ui-icon-triangle-2-n-s { background-position: -128px -16px; }
+.ui-icon-triangle-2-e-w { background-position: -144px -16px; }
+.ui-icon-arrow-1-n { background-position: 0 -32px; }
+.ui-icon-arrow-1-ne { background-position: -16px -32px; }
+.ui-icon-arrow-1-e { background-position: -32px -32px; }
+.ui-icon-arrow-1-se { background-position: -48px -32px; }
+.ui-icon-arrow-1-s { background-position: -64px -32px; }
+.ui-icon-arrow-1-sw { background-position: -80px -32px; }
+.ui-icon-arrow-1-w { background-position: -96px -32px; }
+.ui-icon-arrow-1-nw { background-position: -112px -32px; }
+.ui-icon-arrow-2-n-s { background-position: -128px -32px; }
+.ui-icon-arrow-2-ne-sw { background-position: -144px -32px; }
+.ui-icon-arrow-2-e-w { background-position: -160px -32px; }
+.ui-icon-arrow-2-se-nw { background-position: -176px -32px; }
+.ui-icon-arrowstop-1-n { background-position: -192px -32px; }
+.ui-icon-arrowstop-1-e { background-position: -208px -32px; }
+.ui-icon-arrowstop-1-s { background-position: -224px -32px; }
+.ui-icon-arrowstop-1-w { background-position: -240px -32px; }
+.ui-icon-arrowthick-1-n { background-position: 0 -48px; }
+.ui-icon-arrowthick-1-ne { background-position: -16px -48px; }
+.ui-icon-arrowthick-1-e { background-position: -32px -48px; }
+.ui-icon-arrowthick-1-se { background-position: -48px -48px; }
+.ui-icon-arrowthick-1-s { background-position: -64px -48px; }
+.ui-icon-arrowthick-1-sw { background-position: -80px -48px; }
+.ui-icon-arrowthick-1-w { background-position: -96px -48px; }
+.ui-icon-arrowthick-1-nw { background-position: -112px -48px; }
+.ui-icon-arrowthick-2-n-s { background-position: -128px -48px; }
+.ui-icon-arrowthick-2-ne-sw { background-position: -144px -48px; }
+.ui-icon-arrowthick-2-e-w { background-position: -160px -48px; }
+.ui-icon-arrowthick-2-se-nw { background-position: -176px -48px; }
+.ui-icon-arrowthickstop-1-n { background-position: -192px -48px; }
+.ui-icon-arrowthickstop-1-e { background-position: -208px -48px; }
+.ui-icon-arrowthickstop-1-s { background-position: -224px -48px; }
+.ui-icon-arrowthickstop-1-w { background-position: -240px -48px; }
+.ui-icon-arrowreturnthick-1-w { background-position: 0 -64px; }
+.ui-icon-arrowreturnthick-1-n { background-position: -16px -64px; }
+.ui-icon-arrowreturnthick-1-e { background-position: -32px -64px; }
+.ui-icon-arrowreturnthick-1-s { background-position: -48px -64px; }
+.ui-icon-arrowreturn-1-w { background-position: -64px -64px; }
+.ui-icon-arrowreturn-1-n { background-position: -80px -64px; }
+.ui-icon-arrowreturn-1-e { background-position: -96px -64px; }
+.ui-icon-arrowreturn-1-s { background-position: -112px -64px; }
+.ui-icon-arrowrefresh-1-w { background-position: -128px -64px; }
+.ui-icon-arrowrefresh-1-n { background-position: -144px -64px; }
+.ui-icon-arrowrefresh-1-e { background-position: -160px -64px; }
+.ui-icon-arrowrefresh-1-s { background-position: -176px -64px; }
+.ui-icon-arrow-4 { background-position: 0 -80px; }
+.ui-icon-arrow-4-diag { background-position: -16px -80px; }
+.ui-icon-extlink { background-position: -32px -80px; }
+.ui-icon-newwin { background-position: -48px -80px; }
+.ui-icon-refresh { background-position: -64px -80px; }
+.ui-icon-shuffle { background-position: -80px -80px; }
+.ui-icon-transfer-e-w { background-position: -96px -80px; }
+.ui-icon-transferthick-e-w { background-position: -112px -80px; }
+.ui-icon-folder-collapsed { background-position: 0 -96px; }
+.ui-icon-folder-open { background-position: -16px -96px; }
+.ui-icon-document { background-position: -32px -96px; }
+.ui-icon-document-b { background-position: -48px -96px; }
+.ui-icon-note { background-position: -64px -96px; }
+.ui-icon-mail-closed { background-position: -80px -96px; }
+.ui-icon-mail-open { background-position: -96px -96px; }
+.ui-icon-suitcase { background-position: -112px -96px; }
+.ui-icon-comment { background-position: -128px -96px; }
+.ui-icon-person { background-position: -144px -96px; }
+.ui-icon-print { background-position: -160px -96px; }
+.ui-icon-trash { background-position: -176px -96px; }
+.ui-icon-locked { background-position: -192px -96px; }
+.ui-icon-unlocked { background-position: -208px -96px; }
+.ui-icon-bookmark { background-position: -224px -96px; }
+.ui-icon-tag { background-position: -240px -96px; }
+.ui-icon-home { background-position: 0 -112px; }
+.ui-icon-flag { background-position: -16px -112px; }
+.ui-icon-calendar { background-position: -32px -112px; }
+.ui-icon-cart { background-position: -48px -112px; }
+.ui-icon-pencil { background-position: -64px -112px; }
+.ui-icon-clock { background-position: -80px -112px; }
+.ui-icon-disk { background-position: -96px -112px; }
+.ui-icon-calculator { background-position: -112px -112px; }
+.ui-icon-zoomin { background-position: -128px -112px; }
+.ui-icon-zoomout { background-position: -144px -112px; }
+.ui-icon-search { background-position: -160px -112px; }
+.ui-icon-wrench { background-position: -176px -112px; }
+.ui-icon-gear { background-position: -192px -112px; }
+.ui-icon-heart { background-position: -208px -112px; }
+.ui-icon-star { background-position: -224px -112px; }
+.ui-icon-link { background-position: -240px -112px; }
+.ui-icon-cancel { background-position: 0 -128px; }
+.ui-icon-plus { background-position: -16px -128px; }
+.ui-icon-plusthick { background-position: -32px -128px; }
+.ui-icon-minus { background-position: -48px -128px; }
+.ui-icon-minusthick { background-position: -64px -128px; }
+.ui-icon-close { background-position: -80px -128px; }
+.ui-icon-closethick { background-position: -96px -128px; }
+.ui-icon-key { background-position: -112px -128px; }
+.ui-icon-lightbulb { background-position: -128px -128px; }
+.ui-icon-scissors { background-position: -144px -128px; }
+.ui-icon-clipboard { background-position: -160px -128px; }
+.ui-icon-copy { background-position: -176px -128px; }
+.ui-icon-contact { background-position: -192px -128px; }
+.ui-icon-image { background-position: -208px -128px; }
+.ui-icon-video { background-position: -224px -128px; }
+.ui-icon-script { background-position: -240px -128px; }
+.ui-icon-alert { background-position: 0 -144px; }
+.ui-icon-info { background-position: -16px -144px; }
+.ui-icon-notice { background-position: -32px -144px; }
+.ui-icon-help { background-position: -48px -144px; }
+.ui-icon-check { background-position: -64px -144px; }
+.ui-icon-bullet { background-position: -80px -144px; }
+.ui-icon-radio-on { background-position: -96px -144px; }
+.ui-icon-radio-off { background-position: -112px -144px; }
+.ui-icon-pin-w { background-position: -128px -144px; }
+.ui-icon-pin-s { background-position: -144px -144px; }
+.ui-icon-play { background-position: 0 -160px; }
+.ui-icon-pause { background-position: -16px -160px; }
+.ui-icon-seek-next { background-position: -32px -160px; }
+.ui-icon-seek-prev { background-position: -48px -160px; }
+.ui-icon-seek-end { background-position: -64px -160px; }
+.ui-icon-seek-start { background-position: -80px -160px; }
+/* ui-icon-seek-first is deprecated, use ui-icon-seek-start instead */
+.ui-icon-seek-first { background-position: -80px -160px; }
+.ui-icon-stop { background-position: -96px -160px; }
+.ui-icon-eject { background-position: -112px -160px; }
+.ui-icon-volume-off { background-position: -128px -160px; }
+.ui-icon-volume-on { background-position: -144px -160px; }
+.ui-icon-power { background-position: 0 -176px; }
+.ui-icon-signal-diag { background-position: -16px -176px; }
+.ui-icon-signal { background-position: -32px -176px; }
+.ui-icon-battery-0 { background-position: -48px -176px; }
+.ui-icon-battery-1 { background-position: -64px -176px; }
+.ui-icon-battery-2 { background-position: -80px -176px; }
+.ui-icon-battery-3 { background-position: -96px -176px; }
+.ui-icon-circle-plus { background-position: 0 -192px; }
+.ui-icon-circle-minus { background-position: -16px -192px; }
+.ui-icon-circle-close { background-position: -32px -192px; }
+.ui-icon-circle-triangle-e { background-position: -48px -192px; }
+.ui-icon-circle-triangle-s { background-position: -64px -192px; }
+.ui-icon-circle-triangle-w { background-position: -80px -192px; }
+.ui-icon-circle-triangle-n { background-position: -96px -192px; }
+.ui-icon-circle-arrow-e { background-position: -112px -192px; }
+.ui-icon-circle-arrow-s { background-position: -128px -192px; }
+.ui-icon-circle-arrow-w { background-position: -144px -192px; }
+.ui-icon-circle-arrow-n { background-position: -160px -192px; }
+.ui-icon-circle-zoomin { background-position: -176px -192px; }
+.ui-icon-circle-zoomout { background-position: -192px -192px; }
+.ui-icon-circle-check { background-position: -208px -192px; }
+.ui-icon-circlesmall-plus { background-position: 0 -208px; }
+.ui-icon-circlesmall-minus { background-position: -16px -208px; }
+.ui-icon-circlesmall-close { background-position: -32px -208px; }
+.ui-icon-squaresmall-plus { background-position: -48px -208px; }
+.ui-icon-squaresmall-minus { background-position: -64px -208px; }
+.ui-icon-squaresmall-close { background-position: -80px -208px; }
+.ui-icon-grip-dotted-vertical { background-position: 0 -224px; }
+.ui-icon-grip-dotted-horizontal { background-position: -16px -224px; }
+.ui-icon-grip-solid-vertical { background-position: -32px -224px; }
+.ui-icon-grip-solid-horizontal { background-position: -48px -224px; }
+.ui-icon-gripsmall-diagonal-se { background-position: -64px -224px; }
+.ui-icon-grip-diagonal-se { background-position: -80px -224px; }
+
+
+/* Misc visuals
+----------------------------------*/
+
+/* Corner radius */
+.ui-corner-all,
+.ui-corner-top,
+.ui-corner-left,
+.ui-corner-tl {
+	border-top-left-radius: 4px;
+}
+.ui-corner-all,
+.ui-corner-top,
+.ui-corner-right,
+.ui-corner-tr {
+	border-top-right-radius: 4px;
+}
+.ui-corner-all,
+.ui-corner-bottom,
+.ui-corner-left,
+.ui-corner-bl {
+	border-bottom-left-radius: 4px;
+}
+.ui-corner-all,
+.ui-corner-bottom,
+.ui-corner-right,
+.ui-corner-br {
+	border-bottom-right-radius: 4px;
+}
+
+/* Overlays */
+.ui-widget-overlay {
+	background: #666666 url("images/ui-bg_diagonals-thick_20_666666_40x40.png") 50% 50% repeat;
+	opacity: .5;
+	filter: Alpha(Opacity=50);
+}
+.ui-widget-shadow {
+	margin: -5px 0 0 -5px;
+	padding: 5px;
+	background: #000000 url("images/ui-bg_flat_10_000000_40x100.png") 50% 50% repeat-x;
+	opacity: .2;
+	filter: Alpha(Opacity=20);
+	border-radius: 5px;
+}
diff --git a/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.min.css b/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.min.css
new file mode 100644
index 0000000000..3c6d34c0bf
--- /dev/null
+++ b/web/src/main/webapp/css/ui-lightness/jquery-ui-1.10.4.min.css
@@ -0,0 +1,7 @@
+/*! jQuery UI - v1.10.4 - 2014-04-02
+* http://jqueryui.com
+* Includes: jquery.ui.core.css, jquery.ui.accordion.css, jquery.ui.autocomplete.css, jquery.ui.button.css, jquery.ui.datepicker.css, jquery.ui.dialog.css, jquery.ui.menu.css, jquery.ui.progressbar.css, jquery.ui.resizable.css, jquery.ui.selectable.css, jquery.ui.slider.css, jquery.ui.spinner.css, jquery.ui.tabs.css, jquery.ui.tooltip.css, jquery.ui.theme.css
+* To view and modify this theme, visit http://jqueryui.com/themeroller/?ffDefault=Trebuchet%20MS%2CTahoma%2CVerdana%2CArial%2Csans-serif&fwDefault=bold&fsDefault=1.1em&cornerRadius=4px&bgColorHeader=f6a828&bgTextureHeader=gloss_wave&bgImgOpacityHeader=35&borderColorHeader=e78f08&fcHeader=ffffff&iconColorHeader=ffffff&bgColorContent=eeeeee&bgTextureContent=highlight_soft&bgImgOpacityContent=100&borderColorContent=dddddd&fcContent=333333&iconColorContent=222222&bgColorDefault=f6f6f6&bgTextureDefault=glass&bgImgOpacityDefault=100&borderColorDefault=cccccc&fcDefault=1c94c4&iconColorDefault=ef8c08&bgColorHover=fdf5ce&bgTextureHover=glass&bgImgOpacityHover=100&borderColorHover=fbcb09&fcHover=c77405&iconColorHover=ef8c08&bgColorActive=ffffff&bgTextureActive=glass&bgImgOpacityActive=65&borderColorActive=fbd850&fcActive=eb8f00&iconColorActive=ef8c08&bgColorHighlight=ffe45c&bgTextureHighlight=highlight_soft&bgImgOpacityHighlight=75&borderColorHighlight=fed22f&fcHighlight=363636&iconColorHighlight=228ef1&bgColorError=b81900&bgTextureError=diagonals_thick&bgImgOpacityError=18&borderColorError=cd0a0a&fcError=ffffff&iconColorError=ffd27a&bgColorOverlay=666666&bgTextureOverlay=diagonals_thick&bgImgOpacityOverlay=20&opacityOverlay=50&bgColorShadow=000000&bgTextureShadow=flat&bgImgOpacityShadow=10&opacityShadow=20&thicknessShadow=5px&offsetTopShadow=-5px&offsetLeftShadow=-5px&cornerRadiusShadow=5px
+* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
+
+.ui-helper-hidden{display:none}.ui-helper-hidden-accessible{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.ui-helper-reset{margin:0;padding:0;border:0;outline:0;line-height:1.3;text-decoration:none;font-size:100%;list-style:none}.ui-helper-clearfix:before,.ui-helper-clearfix:after{content:"";display:table;border-collapse:collapse}.ui-helper-clearfix:after{clear:both}.ui-helper-clearfix{min-height:0}.ui-helper-zfix{width:100%;height:100%;top:0;left:0;position:absolute;opacity:0;filter:Alpha(Opacity=0)}.ui-front{z-index:100}.ui-state-disabled{cursor:default!important}.ui-icon{display:block;text-indent:-99999px;overflow:hidden;background-repeat:no-repeat}.ui-widget-overlay{position:fixed;top:0;left:0;width:100%;height:100%}.ui-accordion .ui-accordion-header{display:block;cursor:pointer;position:relative;margin-top:2px;padding:.5em .5em .5em .7em;min-height:0}.ui-accordion .ui-accordion-icons{padding-left:2.2em}.ui-accordion .ui-accordion-noicons{padding-left:.7em}.ui-accordion .ui-accordion-icons .ui-accordion-icons{padding-left:2.2em}.ui-accordion .ui-accordion-header .ui-accordion-header-icon{position:absolute;left:.5em;top:50%;margin-top:-8px}.ui-accordion .ui-accordion-content{padding:1em 2.2em;border-top:0;overflow:auto}.ui-autocomplete{position:absolute;top:0;left:0;cursor:default}.ui-button{display:inline-block;position:relative;padding:0;line-height:normal;margin-right:.1em;cursor:pointer;vertical-align:middle;text-align:center;overflow:visible}.ui-button,.ui-button:link,.ui-button:visited,.ui-button:hover,.ui-button:active{text-decoration:none}.ui-button-icon-only{width:2.2em}button.ui-button-icon-only{width:2.4em}.ui-button-icons-only{width:3.4em}button.ui-button-icons-only{width:3.7em}.ui-button .ui-button-text{display:block;line-height:normal}.ui-button-text-only .ui-button-text{padding:.4em 1em}.ui-button-icon-only .ui-button-text,.ui-button-icons-only .ui-button-text{padding:.4em;text-indent:-9999999px}.ui-button-text-icon-primary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 1em .4em 2.1em}.ui-button-text-icon-secondary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 2.1em .4em 1em}.ui-button-text-icons .ui-button-text{padding-left:2.1em;padding-right:2.1em}input.ui-button{padding:.4em 1em}.ui-button-icon-only .ui-icon,.ui-button-text-icon-primary .ui-icon,.ui-button-text-icon-secondary .ui-icon,.ui-button-text-icons .ui-icon,.ui-button-icons-only .ui-icon{position:absolute;top:50%;margin-top:-8px}.ui-button-icon-only .ui-icon{left:50%;margin-left:-8px}.ui-button-text-icon-primary .ui-button-icon-primary,.ui-button-text-icons .ui-button-icon-primary,.ui-button-icons-only .ui-button-icon-primary{left:.5em}.ui-button-text-icon-secondary .ui-button-icon-secondary,.ui-button-text-icons .ui-button-icon-secondary,.ui-button-icons-only .ui-button-icon-secondary{right:.5em}.ui-buttonset{margin-right:7px}.ui-buttonset .ui-button{margin-left:0;margin-right:-.3em}input.ui-button::-moz-focus-inner,button.ui-button::-moz-focus-inner{border:0;padding:0}.ui-datepicker{width:17em;padding:.2em .2em 0;display:none}.ui-datepicker .ui-datepicker-header{position:relative;padding:.2em 0}.ui-datepicker .ui-datepicker-prev,.ui-datepicker .ui-datepicker-next{position:absolute;top:2px;width:1.8em;height:1.8em}.ui-datepicker .ui-datepicker-prev-hover,.ui-datepicker .ui-datepicker-next-hover{top:1px}.ui-datepicker .ui-datepicker-prev{left:2px}.ui-datepicker .ui-datepicker-next{right:2px}.ui-datepicker .ui-datepicker-prev-hover{left:1px}.ui-datepicker .ui-datepicker-next-hover{right:1px}.ui-datepicker .ui-datepicker-prev span,.ui-datepicker .ui-datepicker-next span{display:block;position:absolute;left:50%;margin-left:-8px;top:50%;margin-top:-8px}.ui-datepicker .ui-datepicker-title{margin:0 2.3em;line-height:1.8em;text-align:center}.ui-datepicker .ui-datepicker-title select{font-size:1em;margin:1px 0}.ui-datepicker select.ui-datepicker-month,.ui-datepicker select.ui-datepicker-year{width:49%}.ui-datepicker table{width:100%;font-size:.9em;border-collapse:collapse;margin:0 0 .4em}.ui-datepicker th{padding:.7em .3em;text-align:center;font-weight:bold;border:0}.ui-datepicker td{border:0;padding:1px}.ui-datepicker td span,.ui-datepicker td a{display:block;padding:.2em;text-align:right;text-decoration:none}.ui-datepicker .ui-datepicker-buttonpane{background-image:none;margin:.7em 0 0 0;padding:0 .2em;border-left:0;border-right:0;border-bottom:0}.ui-datepicker .ui-datepicker-buttonpane button{float:right;margin:.5em .2em .4em;cursor:pointer;padding:.2em .6em .3em .6em;width:auto;overflow:visible}.ui-datepicker .ui-datepicker-buttonpane button.ui-datepicker-current{float:left}.ui-datepicker.ui-datepicker-multi{width:auto}.ui-datepicker-multi .ui-datepicker-group{float:left}.ui-datepicker-multi .ui-datepicker-group table{width:95%;margin:0 auto .4em}.ui-datepicker-multi-2 .ui-datepicker-group{width:50%}.ui-datepicker-multi-3 .ui-datepicker-group{width:33.3%}.ui-datepicker-multi-4 .ui-datepicker-group{width:25%}.ui-datepicker-multi .ui-datepicker-group-last .ui-datepicker-header,.ui-datepicker-multi .ui-datepicker-group-middle .ui-datepicker-header{border-left-width:0}.ui-datepicker-multi .ui-datepicker-buttonpane{clear:left}.ui-datepicker-row-break{clear:both;width:100%;font-size:0}.ui-datepicker-rtl{direction:rtl}.ui-datepicker-rtl .ui-datepicker-prev{right:2px;left:auto}.ui-datepicker-rtl .ui-datepicker-next{left:2px;right:auto}.ui-datepicker-rtl .ui-datepicker-prev:hover{right:1px;left:auto}.ui-datepicker-rtl .ui-datepicker-next:hover{left:1px;right:auto}.ui-datepicker-rtl .ui-datepicker-buttonpane{clear:right}.ui-datepicker-rtl .ui-datepicker-buttonpane button{float:left}.ui-datepicker-rtl .ui-datepicker-buttonpane button.ui-datepicker-current,.ui-datepicker-rtl .ui-datepicker-group{float:right}.ui-datepicker-rtl .ui-datepicker-group-last .ui-datepicker-header,.ui-datepicker-rtl .ui-datepicker-group-middle .ui-datepicker-header{border-right-width:0;border-left-width:1px}.ui-dialog{overflow:hidden;position:absolute;top:0;left:0;padding:.2em;outline:0}.ui-dialog .ui-dialog-titlebar{padding:.4em 1em;position:relative}.ui-dialog .ui-dialog-title{float:left;margin:.1em 0;white-space:nowrap;width:90%;overflow:hidden;text-overflow:ellipsis}.ui-dialog .ui-dialog-titlebar-close{position:absolute;right:.3em;top:50%;width:20px;margin:-10px 0 0 0;padding:1px;height:20px}.ui-dialog .ui-dialog-content{position:relative;border:0;padding:.5em 1em;background:none;overflow:auto}.ui-dialog .ui-dialog-buttonpane{text-align:left;border-width:1px 0 0 0;background-image:none;margin-top:.5em;padding:.3em 1em .5em .4em}.ui-dialog .ui-dialog-buttonpane .ui-dialog-buttonset{float:right}.ui-dialog .ui-dialog-buttonpane button{margin:.5em .4em .5em 0;cursor:pointer}.ui-dialog .ui-resizable-se{width:12px;height:12px;right:-5px;bottom:-5px;background-position:16px 16px}.ui-draggable .ui-dialog-titlebar{cursor:move}.ui-menu{list-style:none;padding:2px;margin:0;display:block;outline:none}.ui-menu .ui-menu{margin-top:-3px;position:absolute}.ui-menu .ui-menu-item{margin:0;padding:0;width:100%;list-style-image:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)}.ui-menu .ui-menu-divider{margin:5px -2px 5px -2px;height:0;font-size:0;line-height:0;border-width:1px 0 0 0}.ui-menu .ui-menu-item a{text-decoration:none;display:block;padding:2px .4em;line-height:1.5;min-height:0;font-weight:normal}.ui-menu .ui-menu-item a.ui-state-focus,.ui-menu .ui-menu-item a.ui-state-active{font-weight:normal;margin:-1px}.ui-menu .ui-state-disabled{font-weight:normal;margin:.4em 0 .2em;line-height:1.5}.ui-menu .ui-state-disabled a{cursor:default}.ui-menu-icons{position:relative}.ui-menu-icons .ui-menu-item a{position:relative;padding-left:2em}.ui-menu .ui-icon{position:absolute;top:.2em;left:.2em}.ui-menu .ui-menu-icon{position:static;float:right}.ui-progressbar{height:2em;text-align:left;overflow:hidden}.ui-progressbar .ui-progressbar-value{margin:-1px;height:100%}.ui-progressbar .ui-progressbar-overlay{background:url("images/animated-overlay.gif");height:100%;filter:alpha(opacity=25);opacity:0.25}.ui-progressbar-indeterminate .ui-progressbar-value{background-image:none}.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:0.1px;display:block}.ui-resizable-disabled .ui-resizable-handle,.ui-resizable-autohide .ui-resizable-handle{display:none}.ui-resizable-n{cursor:n-resize;height:7px;width:100%;top:-5px;left:0}.ui-resizable-s{cursor:s-resize;height:7px;width:100%;bottom:-5px;left:0}.ui-resizable-e{cursor:e-resize;width:7px;right:-5px;top:0;height:100%}.ui-resizable-w{cursor:w-resize;width:7px;left:-5px;top:0;height:100%}.ui-resizable-se{cursor:se-resize;width:12px;height:12px;right:1px;bottom:1px}.ui-resizable-sw{cursor:sw-resize;width:9px;height:9px;left:-5px;bottom:-5px}.ui-resizable-nw{cursor:nw-resize;width:9px;height:9px;left:-5px;top:-5px}.ui-resizable-ne{cursor:ne-resize;width:9px;height:9px;right:-5px;top:-5px}.ui-selectable-helper{position:absolute;z-index:100;border:1px dotted black}.ui-slider{position:relative;text-align:left}.ui-slider .ui-slider-handle{position:absolute;z-index:2;width:1.2em;height:1.2em;cursor:default}.ui-slider .ui-slider-range{position:absolute;z-index:1;font-size:.7em;display:block;border:0;background-position:0 0}.ui-slider.ui-state-disabled .ui-slider-handle,.ui-slider.ui-state-disabled .ui-slider-range{filter:inherit}.ui-slider-horizontal{height:.8em}.ui-slider-horizontal .ui-slider-handle{top:-.3em;margin-left:-.6em}.ui-slider-horizontal .ui-slider-range{top:0;height:100%}.ui-slider-horizontal .ui-slider-range-min{left:0}.ui-slider-horizontal .ui-slider-range-max{right:0}.ui-slider-vertical{width:.8em;height:100px}.ui-slider-vertical .ui-slider-handle{left:-.3em;margin-left:0;margin-bottom:-.6em}.ui-slider-vertical .ui-slider-range{left:0;width:100%}.ui-slider-vertical .ui-slider-range-min{bottom:0}.ui-slider-vertical .ui-slider-range-max{top:0}.ui-spinner{position:relative;display:inline-block;overflow:hidden;padding:0;vertical-align:middle}.ui-spinner-input{border:none;background:none;color:inherit;padding:0;margin:.2em 0;vertical-align:middle;margin-left:.4em;margin-right:22px}.ui-spinner-button{width:16px;height:50%;font-size:.5em;padding:0;margin:0;text-align:center;position:absolute;cursor:default;display:block;overflow:hidden;right:0}.ui-spinner a.ui-spinner-button{border-top:none;border-bottom:none;border-right:none}.ui-spinner .ui-icon{position:absolute;margin-top:-8px;top:50%;left:0}.ui-spinner-up{top:0}.ui-spinner-down{bottom:0}.ui-spinner .ui-icon-triangle-1-s{background-position:-65px -16px}.ui-tabs{position:relative;padding:.2em}.ui-tabs .ui-tabs-nav{margin:0;padding:.2em .2em 0}.ui-tabs .ui-tabs-nav li{list-style:none;float:left;position:relative;top:0;margin:1px .2em 0 0;border-bottom-width:0;padding:0;white-space:nowrap}.ui-tabs .ui-tabs-nav .ui-tabs-anchor{float:left;padding:.5em 1em;text-decoration:none}.ui-tabs .ui-tabs-nav li.ui-tabs-active{margin-bottom:-1px;padding-bottom:1px}.ui-tabs .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor,.ui-tabs .ui-tabs-nav li.ui-state-disabled .ui-tabs-anchor,.ui-tabs .ui-tabs-nav li.ui-tabs-loading .ui-tabs-anchor{cursor:text}.ui-tabs-collapsible .ui-tabs-nav li.ui-tabs-active .ui-tabs-anchor{cursor:pointer}.ui-tabs .ui-tabs-panel{display:block;border-width:0;padding:1em 1.4em;background:none}.ui-tooltip{padding:8px;position:absolute;z-index:9999;max-width:300px;-webkit-box-shadow:0 0 5px #aaa;box-shadow:0 0 5px #aaa}body .ui-tooltip{border-width:2px}.ui-widget{font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;font-size:1.1em}.ui-widget .ui-widget{font-size:1em}.ui-widget input,.ui-widget select,.ui-widget textarea,.ui-widget button{font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;font-size:1em}.ui-widget-content{border:1px solid #ddd;background:#eee url("images/ui-bg_highlight-soft_100_eeeeee_1x100.png") 50% top repeat-x;color:#333}.ui-widget-content a{color:#333}.ui-widget-header{border:1px solid #e78f08;background:#f6a828 url("images/ui-bg_gloss-wave_35_f6a828_500x100.png") 50% 50% repeat-x;color:#fff;font-weight:bold}.ui-widget-header a{color:#fff}.ui-state-default,.ui-widget-content .ui-state-default,.ui-widget-header .ui-state-default{border:1px solid #ccc;background:#f6f6f6 url("images/ui-bg_glass_100_f6f6f6_1x400.png") 50% 50% repeat-x;font-weight:bold;color:#1c94c4}.ui-state-default a,.ui-state-default a:link,.ui-state-default a:visited{color:#1c94c4;text-decoration:none}.ui-state-hover,.ui-widget-content .ui-state-hover,.ui-widget-header .ui-state-hover,.ui-state-focus,.ui-widget-content .ui-state-focus,.ui-widget-header .ui-state-focus{border:1px solid #fbcb09;background:#fdf5ce url("images/ui-bg_glass_100_fdf5ce_1x400.png") 50% 50% repeat-x;font-weight:bold;color:#c77405}.ui-state-hover a,.ui-state-hover a:hover,.ui-state-hover a:link,.ui-state-hover a:visited,.ui-state-focus a,.ui-state-focus a:hover,.ui-state-focus a:link,.ui-state-focus a:visited{color:#c77405;text-decoration:none}.ui-state-active,.ui-widget-content .ui-state-active,.ui-widget-header .ui-state-active{border:1px solid #fbd850;background:#fff url("images/ui-bg_glass_65_ffffff_1x400.png") 50% 50% repeat-x;font-weight:bold;color:#eb8f00}.ui-state-active a,.ui-state-active a:link,.ui-state-active a:visited{color:#eb8f00;text-decoration:none}.ui-state-highlight,.ui-widget-content .ui-state-highlight,.ui-widget-header .ui-state-highlight{border:1px solid #fed22f;background:#ffe45c url("images/ui-bg_highlight-soft_75_ffe45c_1x100.png") 50% top repeat-x;color:#363636}.ui-state-highlight a,.ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a{color:#363636}.ui-state-error,.ui-widget-content .ui-state-error,.ui-widget-header .ui-state-error{border:1px solid #cd0a0a;background:#b81900 url("images/ui-bg_diagonals-thick_18_b81900_40x40.png") 50% 50% repeat;color:#fff}.ui-state-error a,.ui-widget-content .ui-state-error a,.ui-widget-header .ui-state-error a{color:#fff}.ui-state-error-text,.ui-widget-content .ui-state-error-text,.ui-widget-header .ui-state-error-text{color:#fff}.ui-priority-primary,.ui-widget-content .ui-priority-primary,.ui-widget-header .ui-priority-primary{font-weight:bold}.ui-priority-secondary,.ui-widget-content .ui-priority-secondary,.ui-widget-header .ui-priority-secondary{opacity:.7;filter:Alpha(Opacity=70);font-weight:normal}.ui-state-disabled,.ui-widget-content .ui-state-disabled,.ui-widget-header .ui-state-disabled{opacity:.35;filter:Alpha(Opacity=35);background-image:none}.ui-state-disabled .ui-icon{filter:Alpha(Opacity=35)}.ui-icon{width:16px;height:16px}.ui-icon,.ui-widget-content .ui-icon{background-image:url("images/ui-icons_222222_256x240.png")}.ui-widget-header .ui-icon{background-image:url("images/ui-icons_ffffff_256x240.png")}.ui-state-default .ui-icon{background-image:url("images/ui-icons_ef8c08_256x240.png")}.ui-state-hover .ui-icon,.ui-state-focus .ui-icon{background-image:url("images/ui-icons_ef8c08_256x240.png")}.ui-state-active .ui-icon{background-image:url("images/ui-icons_ef8c08_256x240.png")}.ui-state-highlight .ui-icon{background-image:url("images/ui-icons_228ef1_256x240.png")}.ui-state-error .ui-icon,.ui-state-error-text .ui-icon{background-image:url("images/ui-icons_ffd27a_256x240.png")}.ui-icon-blank{background-position:16px 16px}.ui-icon-carat-1-n{background-position:0 0}.ui-icon-carat-1-ne{background-position:-16px 0}.ui-icon-carat-1-e{background-position:-32px 0}.ui-icon-carat-1-se{background-position:-48px 0}.ui-icon-carat-1-s{background-position:-64px 0}.ui-icon-carat-1-sw{background-position:-80px 0}.ui-icon-carat-1-w{background-position:-96px 0}.ui-icon-carat-1-nw{background-position:-112px 0}.ui-icon-carat-2-n-s{background-position:-128px 0}.ui-icon-carat-2-e-w{background-position:-144px 0}.ui-icon-triangle-1-n{background-position:0 -16px}.ui-icon-triangle-1-ne{background-position:-16px -16px}.ui-icon-triangle-1-e{background-position:-32px -16px}.ui-icon-triangle-1-se{background-position:-48px -16px}.ui-icon-triangle-1-s{background-position:-64px -16px}.ui-icon-triangle-1-sw{background-position:-80px -16px}.ui-icon-triangle-1-w{background-position:-96px -16px}.ui-icon-triangle-1-nw{background-position:-112px -16px}.ui-icon-triangle-2-n-s{background-position:-128px -16px}.ui-icon-triangle-2-e-w{background-position:-144px -16px}.ui-icon-arrow-1-n{background-position:0 -32px}.ui-icon-arrow-1-ne{background-position:-16px -32px}.ui-icon-arrow-1-e{background-position:-32px -32px}.ui-icon-arrow-1-se{background-position:-48px -32px}.ui-icon-arrow-1-s{background-position:-64px -32px}.ui-icon-arrow-1-sw{background-position:-80px -32px}.ui-icon-arrow-1-w{background-position:-96px -32px}.ui-icon-arrow-1-nw{background-position:-112px -32px}.ui-icon-arrow-2-n-s{background-position:-128px -32px}.ui-icon-arrow-2-ne-sw{background-position:-144px -32px}.ui-icon-arrow-2-e-w{background-position:-160px -32px}.ui-icon-arrow-2-se-nw{background-position:-176px -32px}.ui-icon-arrowstop-1-n{background-position:-192px -32px}.ui-icon-arrowstop-1-e{background-position:-208px -32px}.ui-icon-arrowstop-1-s{background-position:-224px -32px}.ui-icon-arrowstop-1-w{background-position:-240px -32px}.ui-icon-arrowthick-1-n{background-position:0 -48px}.ui-icon-arrowthick-1-ne{background-position:-16px -48px}.ui-icon-arrowthick-1-e{background-position:-32px -48px}.ui-icon-arrowthick-1-se{background-position:-48px -48px}.ui-icon-arrowthick-1-s{background-position:-64px -48px}.ui-icon-arrowthick-1-sw{background-position:-80px -48px}.ui-icon-arrowthick-1-w{background-position:-96px -48px}.ui-icon-arrowthick-1-nw{background-position:-112px -48px}.ui-icon-arrowthick-2-n-s{background-position:-128px -48px}.ui-icon-arrowthick-2-ne-sw{background-position:-144px -48px}.ui-icon-arrowthick-2-e-w{background-position:-160px -48px}.ui-icon-arrowthick-2-se-nw{background-position:-176px -48px}.ui-icon-arrowthickstop-1-n{background-position:-192px -48px}.ui-icon-arrowthickstop-1-e{background-position:-208px -48px}.ui-icon-arrowthickstop-1-s{background-position:-224px -48px}.ui-icon-arrowthickstop-1-w{background-position:-240px -48px}.ui-icon-arrowreturnthick-1-w{background-position:0 -64px}.ui-icon-arrowreturnthick-1-n{background-position:-16px -64px}.ui-icon-arrowreturnthick-1-e{background-position:-32px -64px}.ui-icon-arrowreturnthick-1-s{background-position:-48px -64px}.ui-icon-arrowreturn-1-w{background-position:-64px -64px}.ui-icon-arrowreturn-1-n{background-position:-80px -64px}.ui-icon-arrowreturn-1-e{background-position:-96px -64px}.ui-icon-arrowreturn-1-s{background-position:-112px -64px}.ui-icon-arrowrefresh-1-w{background-position:-128px -64px}.ui-icon-arrowrefresh-1-n{background-position:-144px -64px}.ui-icon-arrowrefresh-1-e{background-position:-160px -64px}.ui-icon-arrowrefresh-1-s{background-position:-176px -64px}.ui-icon-arrow-4{background-position:0 -80px}.ui-icon-arrow-4-diag{background-position:-16px -80px}.ui-icon-extlink{background-position:-32px -80px}.ui-icon-newwin{background-position:-48px -80px}.ui-icon-refresh{background-position:-64px -80px}.ui-icon-shuffle{background-position:-80px -80px}.ui-icon-transfer-e-w{background-position:-96px -80px}.ui-icon-transferthick-e-w{background-position:-112px -80px}.ui-icon-folder-collapsed{background-position:0 -96px}.ui-icon-folder-open{background-position:-16px -96px}.ui-icon-document{background-position:-32px -96px}.ui-icon-document-b{background-position:-48px -96px}.ui-icon-note{background-position:-64px -96px}.ui-icon-mail-closed{background-position:-80px -96px}.ui-icon-mail-open{background-position:-96px -96px}.ui-icon-suitcase{background-position:-112px -96px}.ui-icon-comment{background-position:-128px -96px}.ui-icon-person{background-position:-144px -96px}.ui-icon-print{background-position:-160px -96px}.ui-icon-trash{background-position:-176px -96px}.ui-icon-locked{background-position:-192px -96px}.ui-icon-unlocked{background-position:-208px -96px}.ui-icon-bookmark{background-position:-224px -96px}.ui-icon-tag{background-position:-240px -96px}.ui-icon-home{background-position:0 -112px}.ui-icon-flag{background-position:-16px -112px}.ui-icon-calendar{background-position:-32px -112px}.ui-icon-cart{background-position:-48px -112px}.ui-icon-pencil{background-position:-64px -112px}.ui-icon-clock{background-position:-80px -112px}.ui-icon-disk{background-position:-96px -112px}.ui-icon-calculator{background-position:-112px -112px}.ui-icon-zoomin{background-position:-128px -112px}.ui-icon-zoomout{background-position:-144px -112px}.ui-icon-search{background-position:-160px -112px}.ui-icon-wrench{background-position:-176px -112px}.ui-icon-gear{background-position:-192px -112px}.ui-icon-heart{background-position:-208px -112px}.ui-icon-star{background-position:-224px -112px}.ui-icon-link{background-position:-240px -112px}.ui-icon-cancel{background-position:0 -128px}.ui-icon-plus{background-position:-16px -128px}.ui-icon-plusthick{background-position:-32px -128px}.ui-icon-minus{background-position:-48px -128px}.ui-icon-minusthick{background-position:-64px -128px}.ui-icon-close{background-position:-80px -128px}.ui-icon-closethick{background-position:-96px -128px}.ui-icon-key{background-position:-112px -128px}.ui-icon-lightbulb{background-position:-128px -128px}.ui-icon-scissors{background-position:-144px -128px}.ui-icon-clipboard{background-position:-160px -128px}.ui-icon-copy{background-position:-176px -128px}.ui-icon-contact{background-position:-192px -128px}.ui-icon-image{background-position:-208px -128px}.ui-icon-video{background-position:-224px -128px}.ui-icon-script{background-position:-240px -128px}.ui-icon-alert{background-position:0 -144px}.ui-icon-info{background-position:-16px -144px}.ui-icon-notice{background-position:-32px -144px}.ui-icon-help{background-position:-48px -144px}.ui-icon-check{background-position:-64px -144px}.ui-icon-bullet{background-position:-80px -144px}.ui-icon-radio-on{background-position:-96px -144px}.ui-icon-radio-off{background-position:-112px -144px}.ui-icon-pin-w{background-position:-128px -144px}.ui-icon-pin-s{background-position:-144px -144px}.ui-icon-play{background-position:0 -160px}.ui-icon-pause{background-position:-16px -160px}.ui-icon-seek-next{background-position:-32px -160px}.ui-icon-seek-prev{background-position:-48px -160px}.ui-icon-seek-end{background-position:-64px -160px}.ui-icon-seek-start{background-position:-80px -160px}.ui-icon-seek-first{background-position:-80px -160px}.ui-icon-stop{background-position:-96px -160px}.ui-icon-eject{background-position:-112px -160px}.ui-icon-volume-off{background-position:-128px -160px}.ui-icon-volume-on{background-position:-144px -160px}.ui-icon-power{background-position:0 -176px}.ui-icon-signal-diag{background-position:-16px -176px}.ui-icon-signal{background-position:-32px -176px}.ui-icon-battery-0{background-position:-48px -176px}.ui-icon-battery-1{background-position:-64px -176px}.ui-icon-battery-2{background-position:-80px -176px}.ui-icon-battery-3{background-position:-96px -176px}.ui-icon-circle-plus{background-position:0 -192px}.ui-icon-circle-minus{background-position:-16px -192px}.ui-icon-circle-close{background-position:-32px -192px}.ui-icon-circle-triangle-e{background-position:-48px -192px}.ui-icon-circle-triangle-s{background-position:-64px -192px}.ui-icon-circle-triangle-w{background-position:-80px -192px}.ui-icon-circle-triangle-n{background-position:-96px -192px}.ui-icon-circle-arrow-e{background-position:-112px -192px}.ui-icon-circle-arrow-s{background-position:-128px -192px}.ui-icon-circle-arrow-w{background-position:-144px -192px}.ui-icon-circle-arrow-n{background-position:-160px -192px}.ui-icon-circle-zoomin{background-position:-176px -192px}.ui-icon-circle-zoomout{background-position:-192px -192px}.ui-icon-circle-check{background-position:-208px -192px}.ui-icon-circlesmall-plus{background-position:0 -208px}.ui-icon-circlesmall-minus{background-position:-16px -208px}.ui-icon-circlesmall-close{background-position:-32px -208px}.ui-icon-squaresmall-plus{background-position:-48px -208px}.ui-icon-squaresmall-minus{background-position:-64px -208px}.ui-icon-squaresmall-close{background-position:-80px -208px}.ui-icon-grip-dotted-vertical{background-position:0 -224px}.ui-icon-grip-dotted-horizontal{background-position:-16px -224px}.ui-icon-grip-solid-vertical{background-position:-32px -224px}.ui-icon-grip-solid-horizontal{background-position:-48px -224px}.ui-icon-gripsmall-diagonal-se{background-position:-64px -224px}.ui-icon-grip-diagonal-se{background-position:-80px -224px}.ui-corner-all,.ui-corner-top,.ui-corner-left,.ui-corner-tl{border-top-left-radius:4px}.ui-corner-all,.ui-corner-top,.ui-corner-right,.ui-corner-tr{border-top-right-radius:4px}.ui-corner-all,.ui-corner-bottom,.ui-corner-left,.ui-corner-bl{border-bottom-left-radius:4px}.ui-corner-all,.ui-corner-bottom,.ui-corner-right,.ui-corner-br{border-bottom-right-radius:4px}.ui-widget-overlay{background:#666 url("images/ui-bg_diagonals-thick_20_666666_40x40.png") 50% 50% repeat;opacity:.5;filter:Alpha(Opacity=50)}.ui-widget-shadow{margin:-5px 0 0 -5px;padding:5px;background:#000 url("images/ui-bg_flat_10_000000_40x100.png") 50% 50% repeat-x;opacity:.2;filter:Alpha(Opacity=20);border-radius:5px}
\ No newline at end of file
diff --git a/web/src/main/webapp/img/bike2.png b/web/src/main/webapp/img/bike2.png
new file mode 100644
index 0000000000..54a802bb12
Binary files /dev/null and b/web/src/main/webapp/img/bike2.png differ
diff --git a/web/src/main/webapp/img/delete.png b/web/src/main/webapp/img/delete.png
new file mode 100644
index 0000000000..4b7ad6f739
Binary files /dev/null and b/web/src/main/webapp/img/delete.png differ
diff --git a/web/src/main/webapp/img/header.png b/web/src/main/webapp/img/header.png
new file mode 100644
index 0000000000..e89b782da1
Binary files /dev/null and b/web/src/main/webapp/img/header.png differ
diff --git a/web/src/main/webapp/img/icon.png b/web/src/main/webapp/img/icon.png
index 3c36288213..2101141930 100644
Binary files a/web/src/main/webapp/img/icon.png and b/web/src/main/webapp/img/icon.png differ
diff --git a/web/src/main/webapp/img/loading.gif b/web/src/main/webapp/img/loading.gif
new file mode 100644
index 0000000000..ed65b705af
Binary files /dev/null and b/web/src/main/webapp/img/loading.gif differ
diff --git a/web/src/main/webapp/img/marker-icon-blue.png b/web/src/main/webapp/img/marker-icon-blue.png
new file mode 100644
index 0000000000..d0a81621aa
Binary files /dev/null and b/web/src/main/webapp/img/marker-icon-blue.png differ
diff --git a/web/src/main/webapp/img/marker-small-blue.png b/web/src/main/webapp/img/marker-small-blue.png
new file mode 100644
index 0000000000..73b0845b40
Binary files /dev/null and b/web/src/main/webapp/img/marker-small-blue.png differ
diff --git a/web/src/main/webapp/img/marker-small-green.png b/web/src/main/webapp/img/marker-small-green.png
index 201c284c7f..d4b959ebe1 100644
Binary files a/web/src/main/webapp/img/marker-small-green.png and b/web/src/main/webapp/img/marker-small-green.png differ
diff --git a/web/src/main/webapp/img/marker-small-red.png b/web/src/main/webapp/img/marker-small-red.png
index 2591eba024..ea5f6ef162 100644
Binary files a/web/src/main/webapp/img/marker-small-red.png and b/web/src/main/webapp/img/marker-small-red.png differ
diff --git a/web/src/main/webapp/img/motorcycle.png b/web/src/main/webapp/img/motorcycle.png
new file mode 100644
index 0000000000..552a98a587
Binary files /dev/null and b/web/src/main/webapp/img/motorcycle.png differ
diff --git a/web/src/main/webapp/img/motorcycle.svg b/web/src/main/webapp/img/motorcycle.svg
new file mode 100644
index 0000000000..cdfe16e184
--- /dev/null
+++ b/web/src/main/webapp/img/motorcycle.svg
@@ -0,0 +1,149 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="24"
+   height="24"
+   id="svg4460"
+   version="1.1"
+   inkscape:version="0.48.4 r9939"
+   sodipodi:docname="motorcycle.svg"
+   inkscape:export-filename="/home/peterk/Dokumente/quell/graphhopper/web/src/main/webapp/img/motorcycle.png"
+   inkscape:export-xdpi="180"
+   inkscape:export-ydpi="180">
+  <defs
+     id="defs4462" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="22.627416"
+     inkscape:cx="11.038288"
+     inkscape:cy="15.468485"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     showguides="true"
+     inkscape:guide-bbox="true"
+     inkscape:window-width="1220"
+     inkscape:window-height="833"
+     inkscape:window-x="56"
+     inkscape:window-y="20"
+     inkscape:window-maximized="0"
+     inkscape:snap-global="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4468"
+       empspacing="5"
+       visible="true"
+       enabled="true"
+       snapvisiblegridlinesonly="true" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="0,20"
+       id="guide4470" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="4,24"
+       id="guide4472" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="24,13"
+       id="guide4474" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="15,0"
+       id="guide4476" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="23,20"
+       id="guide4478" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="20,23"
+       id="guide4480" />
+    <sodipodi:guide
+       orientation="1,0"
+       position="2,5"
+       id="guide4482" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="7,2"
+       id="guide4484" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata4465">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-1028.3622)">
+    <path
+       style="fill:#474747;fill-opacity:1;stroke:none"
+       d="m 5.5817124,1045.2742 c -0.3707456,-0.1255 -0.5945126,-0.347 -0.7457974,-0.7394 -0.1516823,-0.3932 -0.1770529,-0.6892 -0.088482,-1.0324 0.082921,-0.3212 0.2200926,-0.5065 0.4467092,-0.6031 0.1431593,-0.061 0.729899,0 2.1462326,0.2047 0.3836523,0.057 1.0095616,0.096 1.6087456,0.098 l 0.9807671,0 0.2633805,-0.1904 c 2.201779,-2.0387 5.224231,-4.2928 6.687617,-5.3185 0.05478,-0.2562 -0.184514,-1.0406 -0.394684,-1.4309 -0.106364,-0.1976 -0.185787,-0.3682 -0.176497,-0.3791 0.03469,-0.042 0.660756,0.2251 0.913104,0.3881 0.816153,0.5273 1.638487,1.8371 1.709855,2.7235 0.0311,0.3862 0.0088,0.4083 -0.668791,0.6615 -0.73483,0.2745 -1.449842,0.8289 -2.310729,1.7918 -0.707156,0.7908 -1.192179,1.7324 -1.584625,3.0759 l -0.220867,0.7561 -0.30143,-0.035 c -0.736677,-0.085 -3.214402,-0.103 -5.5010819,-0.04 -1.3677354,0.038 -2.520702,0.078 -2.5621485,0.089 -0.041446,0.013 -0.1320216,-1e-4 -0.2012779,-0.024 l 0,0 z"
+       id="path3936"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="csscccccccccsccsccccccc" />
+    <path
+       sodipodi:type="arc"
+       style="fill:none;stroke:#474747;stroke-width:1.9586767;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
+       id="path3037"
+       sodipodi:cx="-10.915961"
+       sodipodi:cy="15.558912"
+       sodipodi:rx="4.6403885"
+       sodipodi:ry="4.6403885"
+       d="m -6.2755728,15.558912 a 4.6403885,4.6403885 0 1 1 -9.2807772,0 4.6403885,4.6403885 0 1 1 9.2807772,0 z"
+       transform="matrix(0.67343727,0,0,0.67343727,26.251218,1033.6233)" />
+    <path
+       style="fill:none;stroke:#474747;stroke-width:1.58841085;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
+       d="m 16.762928,1040.327 2.071883,3.714"
+       id="path3847"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       sodipodi:type="arc"
+       style="fill:none;stroke:#474747;stroke-width:1.9586767;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
+       id="path3037-4"
+       sodipodi:cx="-10.915961"
+       sodipodi:cy="15.558912"
+       sodipodi:rx="4.6403885"
+       sodipodi:ry="4.6403885"
+       d="m -6.2755728,15.558912 a 4.6403885,4.6403885 0 1 1 -9.2807772,0 4.6403885,4.6403885 0 1 1 9.2807772,0 z"
+       transform="matrix(0.67343727,0,0,0.67343727,13.245847,1033.5599)" />
+    <rect
+       style="opacity:0.98999999;fill:#474747;fill-opacity:1;stroke:none"
+       id="rect3908"
+       width="6.7141528"
+       height="1.0771544"
+       x="235.49338"
+       y="1003.391"
+       transform="matrix(0.96338557,0.26811982,-0.22085123,0.97530751,0,0)"
+       ry="0" />
+    <path
+       style="fill:#474747;fill-opacity:1;stroke:none"
+       d="m 5.3594489,1039.4518 c -1.3832608,-0.7953 -1.5267081,-1.3337 -1.1944296,-1.7131 0.026329,-0.03 2.600895,-0.024 3.3742271,0.1991 1.1573295,0.3344 1.3778264,0.4569 2.7889386,1.5513 0.324467,0.2516 0.6842,0.3995 0.972399,0.3997 0.157152,0 0.927646,-0.2302 2.28237,-0.6825 1.124822,-0.3755 2.055889,-0.6705 2.06904,-0.6557 0.01315,0.015 -0.432145,0.4129 -0.989543,0.8846 -1.634219,1.3827 -3.403891,3.067 -3.685785,3.0667 -1.1624689,-1.7137 -3.7863209,-2.5155 -5.6172171,-3.0501 z"
+       id="path3930"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cccccccccc" />
+  </g>
+</svg>
diff --git a/web/src/main/webapp/img/point_add.png b/web/src/main/webapp/img/point_add.png
new file mode 100644
index 0000000000..a7424380d6
Binary files /dev/null and b/web/src/main/webapp/img/point_add.png differ
diff --git a/web/src/main/webapp/img/point_delete.png b/web/src/main/webapp/img/point_delete.png
new file mode 100644
index 0000000000..d1898cd4ef
Binary files /dev/null and b/web/src/main/webapp/img/point_delete.png differ
diff --git a/web/src/main/webapp/img/race-bicycle.svg b/web/src/main/webapp/img/racingbike.svg
similarity index 100%
rename from web/src/main/webapp/img/race-bicycle.svg
rename to web/src/main/webapp/img/racingbike.svg
diff --git a/web/src/main/webapp/img/roundabout.png b/web/src/main/webapp/img/roundabout.png
new file mode 100644
index 0000000000..1a02efd5b9
Binary files /dev/null and b/web/src/main/webapp/img/roundabout.png differ
diff --git a/web/src/main/webapp/index.html b/web/src/main/webapp/index.html
index e97fa0974d..0cf58995bd 100644
--- a/web/src/main/webapp/index.html
+++ b/web/src/main/webapp/index.html
@@ -4,65 +4,81 @@
         <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
         <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
         <meta name="keywords" content="road routing,shortest path,maps,openstreetmap,android,navigation,routenplaner,gis"/>
-        <link type="image/png" rel="icon" href="/favicon.ico"/>        
+        <link type="image/png" rel="icon" href="/favicon.ico"/>
         <link rel="search" type="application/opensearchdescription+xml" title="GraphHopper Maps" href="opensearch.xml"/>
-        <title>GraphHopper Maps</title>
+        <title>Driving Directions - GraphHopper Maps</title>
+        <meta name="description" content="A fast route planner for biking, hiking and more! Based on OpenStreetMap including elevation data. Try out for free!"/>
+        <link rel="stylesheet" href="css/leaflet.css?v=0.7.3" />
+        <script type="text/javascript" src="js/leaflet.js?v=0.7.3"></script>
+        <link rel="stylesheet" href="css/Leaflet.Elevation-0.0.2.css" />
+        <script type="text/javascript" src="js/d3.min.js"></script>
+        <script type="text/javascript" src="js/Leaflet.Elevation-0.0.2.min.js"></script>        
 
-        <link rel="stylesheet" href="css/leaflet.css" />
-        <!--[if lte IE 8]>
-            <link rel="stylesheet" href="css/leaflet.ie.css" />
-        <![endif]-->
-        <script type="text/javascript" src="js/leaflet.js?v=0.6.4"></script>
-        <script type="text/javascript" src="js/jquery-1.10.2.min.js"></script>
+        <link rel="stylesheet" href="css/leaflet.contextmenu.css" />
+        <link rel="stylesheet" href="css/leaflet.loading.css" />
+        <link rel="stylesheet" href="css/ui-lightness/jquery-ui-1.10.4.css" />
+        <script type="text/javascript" src="js/leaflet.contextmenu.js"></script>
+        <script type="text/javascript" src="js/leaflet.loading.js"></script>
+        <script type="text/javascript" src="js/jquery-2.1.0.min.js"></script>        
+        <script type="text/javascript" src="js/jquery-ui-1.10.4.custom.min.js"></script>      
         <script type="text/javascript" src="js/jquery.history.js"></script>
-        <!--        <script type="text/javascript" src="js/jquery.autocomplete.min.js"></script>-->
+        <!--
+        <script type="text/javascript" src="js/jquery.autocomplete.min.js"></script>
+        -->
         <script type="text/javascript" src="js/jquery.autocomplete.js"></script>
-        <script type="text/javascript" src="js/ghrequest.js?v=3"></script>
-        <script type="text/javascript" src="js/main.js?v=14"></script>
+        <script type="text/javascript" src="js/ghrequest.js?v=0.4.4"></script>
+        <script type="text/javascript" src="js/main.js?v=0.4.4"></script>
         <link rel="stylesheet" type="text/css" href="css/style.css" />
     </head>
     <body>
         <div id="input">
-            <div id="header_img">
-                <a class="no_link" href="http://graphhopper.com">
-                    <img alt="GraphHopper" src="http://graphhopper.com/img/header.png"/>                    
-                </a>
-            </div>
-            <div id="options">
-                <span id="vehicles">
+            <div id="input_header">
+                <div id="header_img">
+                    <a class="no_link" href="https://graphhopper.com">
+                        <img alt="GraphHopper" src="./img/header.png"/>                    
+                    </a>
+                </div>
+                <div id="options">
+                    <span id="vehicles">
 
-                </span>
-            </div>
-            <form id="locationform">
-                <div id="locationpoints">
-                    <div id="fromDiv">
-                        <img id="fromIndicator" class="hidden" src="img/indicator.gif"/>
-                        <img id="fromFlag" src="img/marker-small-green.png"/>
-                        <input id="fromInput" type="text" placeholder="From"/>
-                        <div class="clear"> </div>
-                        <div id="fromResolveFound"></div>
-                        <div id="fromResolveError"></div>
-                    </div>
-                    <div class="clear"> </div>
-                    <div id="toDiv">
-                        <img id="toIndicator" class="hidden" src="img/indicator.gif"/>
-                        <img id="toFlag" src="img/marker-small-red.png"/>                    
-                        <input id="toInput" type="text" placeholder="To"/>
-                        <div class="clear"> </div>
-                        <div id="toResolveFound"></div>
-                        <div id="toResolveError"></div>
-                    </div>
+                    </span>
                 </div>
-                <div class="clear"> </div>
-                <div id="exportLink" title="Static Link" class="left"><a href="/maps"><img src='img/link.png'></a></div>
-                <input id="searchButton" type="submit" value="Search">
-            </form>      
-            <div id="gpxExportButton" title="GPX Download"><a href=""><img alt="gpx" src='img/gpx.png'></a></div>
+                <form id="locationform">
+                    <div id="locationpoints">
+                        <div id="x_pointAdd" class="pointAdd"><img src="./img/point_add.png"/></div>
+                    </div>
+                    <div class="clear"> </div>                
+                    <input id="searchButton" type="submit" value="Search">                
+                </form>      
+                <div id="export-link" title="Static Link" class="left"><a href="/maps"><img src='img/link.png'></a></div>
+                <div id="gpxExportButton" title="GPX Download"><a href=""><img alt="gpx" src='img/gpx.png'></a></div>
+                <div id="hosting">Powered by <a href='https://graphhopper.com/#directions-api'>GraphHopper API</a></div>                
+            </div>
             <div class="clear"> </div>
             <div id="info" class="small_text">
             </div>
             <div id="error" class="error">
             </div>
+
+            <div id="footer">
+                <div id="link_line">
+                    <a class="footer-link" href='https://graphhopper.com/#contact'>Contact</a>
+                    <a class="footer-link" href='https://graphhopper.com/terms.html'>Terms</a>
+                    <a class="footer-link" href='https://graphhopper.com/privacy.html'>Privacy</a>
+                </div>
+            </div>  
+
+            <div id="pointTemplate" class="hidden">
+                <div id="{id}_Div" class="pointDiv">
+                    <img id="{id}_Indicator" class="hidden pointIndicator" src="img/loading.gif"/>
+                    <img id="{id}_Flag" class="pointFlag" src="img/marker-small-green.png"/>
+                    <input id="{id}_Input" class="pointInput" type="text" placeholder=""/>
+                    <div class="pointDelete"><img src="./img/point_delete.png"></div>
+                    <div class="clear"> </div>
+                    <div id="{id}_ResolveFound" class="pointResolveFound"></div>
+                    <div id="{id}_ResolveError" class="pointResolveError"></div>
+                </div>
+            </div>   
         </div>
 
         <div id="map">
@@ -71,20 +87,23 @@
         <script type="text/javascript">
             PIWIK = false;
             if (PIWIK) {
-                var pkBaseURL = (("https:" == document.location.protocol) ? "https://www.pannous.info/piwik/" : "http://www.pannous.info/piwik/");
-                document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
+                var _paq = _paq || [];
+                _paq.push(['trackPageView']);
+                _paq.push(['enableLinkTracking']);
+                (function () {
+                    var u = (("https:" == document.location.protocol) ? "https" : "http") + "://graphhopper.com/piwik/";
+                    _paq.push(['setTrackerUrl', u + 'piwik.php']);
+                    _paq.push(['setSiteId', 1]);
+                    var d = document, g = d.createElement('script'), s = d.getElementsByTagName('script')[0];
+                    g.type = 'text/javascript';
+                    g.defer = true;
+                    g.async = true;
+                    g.src = u + 'piwik.js';
+                    s.parentNode.insertBefore(g, s);
+                })();
             }
         </script>
-        <script type="text/javascript">
-            if (PIWIK)
-                try {
-                    var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 7);
-                    piwikTracker.trackPageView();
-                    piwikTracker.enableLinkTracking();
-                } catch (err) {
-                }
-        </script>
-        <noscript><p><img src="http://www.pannous.info/piwik/piwik.php?idsite=7" style="border:0" alt="" /></p></noscript>
-        <!-- End Piwik Tracking Code -->
+        <noscript><p><img src="https://graphhopper.com/piwik/piwik.php?idsite=1" style="border:0;" alt="" /></p></noscript>
+        <!-- End Piwik Code -->
     </body>
 </html>
diff --git a/web/src/main/webapp/js/Leaflet.Elevation-0.0.2.min.js b/web/src/main/webapp/js/Leaflet.Elevation-0.0.2.min.js
new file mode 100644
index 0000000000..198bd29237
--- /dev/null
+++ b/web/src/main/webapp/js/Leaflet.Elevation-0.0.2.min.js
@@ -0,0 +1,2 @@
+/*! Leaflet.Elevation 05-03-2014 */
+L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1},onRemove:function(){this._container=null},onAdd:function(a){this._map=a;var b=this.options,c=b.margins;b.xTicks=b.xTicks||Math.round(this._width()/75),b.yTicks=b.yTicks||Math.round(this._height()/30),b.hoverNumber.formatter=b.hoverNumber.formatter||this._formatter,d3.select("body").classed(b.theme,!0);var d=this._x=d3.scale.linear().range([0,this._width()]),e=this._y=d3.scale.linear().range([this._height(),0]),f=(this._area=d3.svg.area().interpolate(b.interpolation).x(function(a){return d(a.dist)}).y0(this._height()).y1(function(a){return e(a.altitude)}),this._container=L.DomUtil.create("div","elevation"));this._initToggle();var g=d3.select(f);g.attr("width",b.width);var h=g.append("svg");h.attr("width",b.width).attr("class","background").attr("height",b.height).append("g").attr("transform","translate("+c.left+","+c.top+")");var i=d3.svg.line();i=i.x(function(){return d3.mouse(h.select("g"))[0]}).y(function(){return this._height()});var j=d3.select(this._container).select("svg").select("g");this._areapath=j.append("path").attr("class","area");var k=this._background=j.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.touch?(k.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(k.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=j.append("g"),this._yaxisgraphicnode=j.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var l=this._focusG=j.append("g");return this._mousefocus=l.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),f},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var a=this._dragCurrentCoords=d3.mouse(this._background.node()),b=Math.min(this._dragStartCoords[0],a[0]),c=Math.max(this._dragStartCoords[0],a[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",c-b).attr("x",b);else{var d=d3.select(this._container).select("svg").select("g");this._dragRectangleG=d.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",c-b).attr("height",this._height()).attr("x",b).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var a=this._findItemForX(this._dragStartCoords[0]),b=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(a,b),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(a){var b=d3.bisector(function(a){return a.dist}).left,c=this._x.invert(a);return b(this._data,c)},_fitSection:function(a,b){var c=Math.min(a,b),d=Math.max(a,b),e=this._calculateFullExtent(this._data.slice(c,d));this._map.fitBounds(e)},_initToggle:function(){var a=this._container;if(a.setAttribute("aria-haspopup",!0),L.Browser.touch?L.DomEvent.on(a,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(a),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(a,"mouseover",this._expand,this).on(a,"mouseout",this._collapse,this);var b=this._button=L.DomUtil.create("a","elevation-toggle",a);b.href="#",b.title="Elevation",L.Browser.touch?L.DomEvent.on(b,"click",L.DomEvent.stop).on(b,"click",this._expand,this):L.DomEvent.on(b,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var a=this.options;return a.width-a.margins.left-a.margins.right},_height:function(){var a=this.options;return a.height-a.margins.top-a.margins.bottom},_formatter:function(a,b,c){var d;d=0===b?Math.round(a)+"":L.Util.formatNum(a,b)+"";var e=d.split(".");if(e[1]){for(var f=b-e[1].length;f>0;f--)e[1]+="0";d=e.join(c||".")}return d},_appendYaxis:function(a){a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-36).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(a){a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(){if(this._data&&0!==this._data.length){var a=d3.mouse(this._background.node()),b=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",a[0]).attr("y1",0).attr("x2",a[0]).attr("y2",this._height()).classed("hidden",!1);var c=(d3.bisector(function(a){return a.dist}).left,this._data[this._findItemForX(a[0])]),d=c.altitude,e=c.dist,f=c.latlng,g=b.hoverNumber.formatter(d,b.hoverNumber.decimalsY),h=b.hoverNumber.formatter(e,b.hoverNumber.decimalsX);this._focuslabelX.attr("x",a[0]).text(g+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",a[0]).text(h+" km");var i=this._map.latLngToLayerPoint(f);if(b.useHeightIndicator){if(!this._mouseHeightFocus){var j=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=j.append("svg:line").attr("class","height-focus line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0");var k=this._pointG=j.append("g");k.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class","height-focus circle-lower"),this._mouseHeightFocusLabel=j.append("svg:text").attr("class","height-focus-label").style("pointer-events","none")}var l=this._height()/this._maxElevation*d,m=i.y-l;this._mouseHeightFocus.attr("x1",i.x).attr("x2",i.x).attr("y1",i.y).attr("y2",m).style("visibility","visible"),this._pointG.attr("transform","translate("+i.x+","+i.y+")").style("visibility","visible"),this._mouseHeightFocusLabel.attr("x",i.x).attr("y",m).text(d+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(f):this._marker=new L.Marker(f).addTo(this._map)}},_addGeoJSONData:function(a){if(a){for(var b=this._data||[],c=this._dist||0,d=this._maxElevation||0,e=0;e<a.length;e++){var f=new L.LatLng(a[e][1],a[e][0]),g=new L.LatLng(a[e?e-1:0][1],a[e?e-1:0][0]),h=f.distanceTo(g);c+=Math.round(h/1e3*1e5)/1e5,d=d<a[e][2]?a[e][2]:d,b.push({dist:c,altitude:a[e][2],x:a[e][0],y:a[e][1],latlng:f})}this._dist=c,this._data=b,this._maxElevation=d}},_addGPXdata:function(a){if(a){for(var b=this._data||[],c=this._dist||0,d=this._maxElevation||0,e=0;e<a.length;e++){var f=a[e],g=a[e?e-1:0],h=f.distanceTo(g);c+=Math.round(h/1e3*1e5)/1e5,d=d<f.meta.ele?f.meta.ele:d,b.push({dist:c,altitude:f.meta.ele,x:f.lng,y:f.lat,latlng:f})}this._dist=c,this._data=b,this._maxElevation=d}},_addData:function(a){var b,c=a&&a.geometry&&a.geometry;if(c)switch(c.type){case"LineString":this._addGeoJSONData(c.coordinates);break;case"MultiLineString":for(b=0;b<c.coordinates.length;b++)this._addGeoJSONData(c.coordinates[b]);break;default:throw new Error("Invalid GeoJSON object.")}var d=a&&"FeatureCollection"===a.type;if(d)for(b=0;b<a.features.length;b++)this._addData(a.features[b]);a&&a._latlngs&&this._addGPXdata(a._latlngs)},_calculateFullExtent:function(a){if(!a||a.length<1)throw new Error("no data in parameters");var b=new L.latLngBounds(a[0].latlng,a[0].latlng);return a.forEach(function(a){b.extend(a.latlng)}),b},addData:function(a){this._addData(a),this._container&&this._applyData()},_applyData:function(){var a=d3.extent(this._data,function(a){return a.dist}),b=d3.extent(this._data,function(a){return a.altitude}),c=this.options;void 0!==c.yAxisMin&&(c.yAxisMin<b[0]||c.forceAxisBounds)&&(b[0]=c.yAxisMin),void 0!==c.yAxisMax&&(c.yAxisMax>b[1]||c.forceAxisBounds)&&(b[1]=c.yAxisMax),this._x.domain(a),this._y.domain(b),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())}}),L.control.elevation=function(a){return new L.Control.Elevation(a)};
\ No newline at end of file
diff --git a/web/src/main/webapp/js/d3.min.js b/web/src/main/webapp/js/d3.min.js
new file mode 100644
index 0000000000..eed58e6a57
--- /dev/null
+++ b/web/src/main/webapp/js/d3.min.js
@@ -0,0 +1,5 @@
+!function(){function n(n){return null!=n&&!isNaN(n)}function t(n){return n.length}function e(n){for(var t=1;n*t%1;)t*=10;return t}function r(n,t){try{for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}catch(r){n.prototype=t}}function u(){}function i(n){return aa+n in this}function o(n){return n=aa+n,n in this&&delete this[n]}function a(){var n=[];return this.forEach(function(t){n.push(t)}),n}function c(){var n=0;for(var t in this)t.charCodeAt(0)===ca&&++n;return n}function s(){for(var n in this)if(n.charCodeAt(0)===ca)return!1;return!0}function l(){}function f(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function h(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.substring(1);for(var e=0,r=sa.length;r>e;++e){var u=sa[e]+t;if(u in n)return u}}function g(){}function p(){}function v(n){function t(){for(var t,r=e,u=-1,i=r.length;++u<i;)(t=r[u].on)&&t.apply(this,arguments);return n}var e=[],r=new u;return t.on=function(t,u){var i,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,i=e.indexOf(o)).concat(e.slice(i+1)),r.remove(t)),u&&e.push(r.set(t,{on:u})),n)},t}function d(){Xo.event.preventDefault()}function m(){for(var n,t=Xo.event;n=t.sourceEvent;)t=n;return t}function y(n){for(var t=new p,e=0,r=arguments.length;++e<r;)t[arguments[e]]=v(t);return t.of=function(e,r){return function(u){try{var i=u.sourceEvent=Xo.event;u.target=n,Xo.event=u,t[u.type].apply(e,r)}finally{Xo.event=i}}},t}function x(n){return fa(n,da),n}function M(n){return"function"==typeof n?n:function(){return ha(n,this)}}function _(n){return"function"==typeof n?n:function(){return ga(n,this)}}function b(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function u(){this.setAttribute(n,t)}function i(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=Xo.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?i:u}function w(n){return n.trim().replace(/\s+/g," ")}function S(n){return new RegExp("(?:^|\\s+)"+Xo.requote(n)+"(?:\\s+|$)","g")}function k(n){return n.trim().split(/^|\s+/)}function E(n,t){function e(){for(var e=-1;++e<u;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<u;)n[e](this,r)}n=k(n).map(A);var u=n.length;return"function"==typeof t?r:e}function A(n){var t=S(n);return function(e,r){if(u=e.classList)return r?u.add(n):u.remove(n);var u=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(u)||e.setAttribute("class",w(u+" "+n))):e.setAttribute("class",w(u.replace(t," ")))}}function C(n,t,e){function r(){this.style.removeProperty(n)}function u(){this.style.setProperty(n,t,e)}function i(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?i:u}function N(n,t){function e(){delete this[n]}function r(){this[n]=t}function u(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?u:r}function L(n){return"function"==typeof n?n:(n=Xo.ns.qualify(n)).local?function(){return this.ownerDocument.createElementNS(n.space,n.local)}:function(){return this.ownerDocument.createElementNS(this.namespaceURI,n)}}function z(n){return{__data__:n}}function q(n){return function(){return va(this,n)}}function T(n){return arguments.length||(n=Xo.ascending),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function R(n,t){for(var e=0,r=n.length;r>e;e++)for(var u,i=n[e],o=0,a=i.length;a>o;o++)(u=i[o])&&t(u,o,e);return n}function D(n){return fa(n,ya),n}function P(n){var t,e;return function(r,u,i){var o,a=n[i].update,c=a.length;for(i!=e&&(e=i,t=0),u>=t&&(t=u+1);!(o=a[t])&&++t<c;);return o}}function U(){var n=this.__transition__;n&&++n.active}function j(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function u(){var u=c(t,Bo(arguments));r.call(this),this.addEventListener(n,this[o]=u,u.$=e),u._=t}function i(){var t,e=new RegExp("^__on([^.]+)"+Xo.requote(n)+"$");for(var r in this)if(t=r.match(e)){var u=this[r];this.removeEventListener(t[1],u,u.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),c=H;a>0&&(n=n.substring(0,a));var s=Ma.get(n);return s&&(n=s,c=F),a?t?u:r:t?g:i}function H(n,t){return function(e){var r=Xo.event;Xo.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{Xo.event=r}}}function F(n,t){var e=H(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function O(){var n=".dragsuppress-"+ ++ba,t="click"+n,e=Xo.select(Go).on("touchmove"+n,d).on("dragstart"+n,d).on("selectstart"+n,d);if(_a){var r=Jo.style,u=r[_a];r[_a]="none"}return function(i){function o(){e.on(t,null)}e.on(n,null),_a&&(r[_a]=u),i&&(e.on(t,function(){d(),o()},!0),setTimeout(o,0))}}function Y(n,t){t.changedTouches&&(t=t.changedTouches[0]);var e=n.ownerSVGElement||n;if(e.createSVGPoint){var r=e.createSVGPoint();if(0>wa&&(Go.scrollX||Go.scrollY)){e=Xo.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var u=e[0][0].getScreenCTM();wa=!(u.f||u.e),e.remove()}return wa?(r.x=t.pageX,r.y=t.pageY):(r.x=t.clientX,r.y=t.clientY),r=r.matrixTransform(n.getScreenCTM().inverse()),[r.x,r.y]}var i=n.getBoundingClientRect();return[t.clientX-i.left-n.clientLeft,t.clientY-i.top-n.clientTop]}function I(n){return n>0?1:0>n?-1:0}function Z(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function V(n){return n>1?0:-1>n?Sa:Math.acos(n)}function X(n){return n>1?Ea:-1>n?-Ea:Math.asin(n)}function $(n){return((n=Math.exp(n))-1/n)/2}function B(n){return((n=Math.exp(n))+1/n)/2}function W(n){return((n=Math.exp(2*n))-1)/(n+1)}function J(n){return(n=Math.sin(n/2))*n}function G(){}function K(n,t,e){return new Q(n,t,e)}function Q(n,t,e){this.h=n,this.s=t,this.l=e}function nt(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?i+(o-i)*n/60:180>n?o:240>n?i+(o-i)*(240-n)/60:i}function u(n){return Math.round(255*r(n))}var i,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,i=2*e-o,gt(u(n+120),u(n),u(n-120))}function tt(n,t,e){return new et(n,t,e)}function et(n,t,e){this.h=n,this.c=t,this.l=e}function rt(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),ut(e,Math.cos(n*=Na)*t,Math.sin(n)*t)}function ut(n,t,e){return new it(n,t,e)}function it(n,t,e){this.l=n,this.a=t,this.b=e}function ot(n,t,e){var r=(n+16)/116,u=r+t/500,i=r-e/200;return u=ct(u)*Fa,r=ct(r)*Oa,i=ct(i)*Ya,gt(lt(3.2404542*u-1.5371385*r-.4985314*i),lt(-.969266*u+1.8760108*r+.041556*i),lt(.0556434*u-.2040259*r+1.0572252*i))}function at(n,t,e){return n>0?tt(Math.atan2(e,t)*La,Math.sqrt(t*t+e*e),n):tt(0/0,0/0,n)}function ct(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function st(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function lt(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function ft(n){return gt(n>>16,255&n>>8,255&n)}function ht(n){return ft(n)+""}function gt(n,t,e){return new pt(n,t,e)}function pt(n,t,e){this.r=n,this.g=t,this.b=e}function vt(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function dt(n,t,e){var r,u,i,o=0,a=0,c=0;if(r=/([a-z]+)\((.*)\)/i.exec(n))switch(u=r[2].split(","),r[1]){case"hsl":return e(parseFloat(u[0]),parseFloat(u[1])/100,parseFloat(u[2])/100);case"rgb":return t(Mt(u[0]),Mt(u[1]),Mt(u[2]))}return(i=Va.get(n))?t(i.r,i.g,i.b):(null!=n&&"#"===n.charAt(0)&&(4===n.length?(o=n.charAt(1),o+=o,a=n.charAt(2),a+=a,c=n.charAt(3),c+=c):7===n.length&&(o=n.substring(1,3),a=n.substring(3,5),c=n.substring(5,7)),o=parseInt(o,16),a=parseInt(a,16),c=parseInt(c,16)),t(o,a,c))}function mt(n,t,e){var r,u,i=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-i,c=(o+i)/2;return a?(u=.5>c?a/(o+i):a/(2-o-i),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=0/0,u=c>0&&1>c?0:r),K(r,u,c)}function yt(n,t,e){n=xt(n),t=xt(t),e=xt(e);var r=st((.4124564*n+.3575761*t+.1804375*e)/Fa),u=st((.2126729*n+.7151522*t+.072175*e)/Oa),i=st((.0193339*n+.119192*t+.9503041*e)/Ya);return ut(116*u-16,500*(r-u),200*(u-i))}function xt(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Mt(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function _t(n){return"function"==typeof n?n:function(){return n}}function bt(n){return n}function wt(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),St(t,e,n,r)}}function St(n,t,e,r){function u(){var n,t=c.status;if(!t&&c.responseText||t>=200&&300>t||304===t){try{n=e.call(i,c)}catch(r){return o.error.call(i,r),void 0}o.load.call(i,n)}else o.error.call(i,c)}var i={},o=Xo.dispatch("beforesend","progress","load","error"),a={},c=new XMLHttpRequest,s=null;return!Go.XDomainRequest||"withCredentials"in c||!/^(http(s)?:)?\/\//.test(n)||(c=new XDomainRequest),"onload"in c?c.onload=c.onerror=u:c.onreadystatechange=function(){c.readyState>3&&u()},c.onprogress=function(n){var t=Xo.event;Xo.event=n;try{o.progress.call(i,c)}finally{Xo.event=t}},i.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",i)},i.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",i):t},i.responseType=function(n){return arguments.length?(s=n,i):s},i.response=function(n){return e=n,i},["get","post"].forEach(function(n){i[n]=function(){return i.send.apply(i,[n].concat(Bo(arguments)))}}),i.send=function(e,r,u){if(2===arguments.length&&"function"==typeof r&&(u=r,r=null),c.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),c.setRequestHeader)for(var l in a)c.setRequestHeader(l,a[l]);return null!=t&&c.overrideMimeType&&c.overrideMimeType(t),null!=s&&(c.responseType=s),null!=u&&i.on("error",u).on("load",function(n){u(null,n)}),o.beforesend.call(i,c),c.send(null==r?null:r),i},i.abort=function(){return c.abort(),i},Xo.rebind(i,o,"on"),null==r?i:i.get(kt(r))}function kt(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Et(){var n=At(),t=Ct()-n;t>24?(isFinite(t)&&(clearTimeout(Wa),Wa=setTimeout(Et,t)),Ba=0):(Ba=1,Ga(Et))}function At(){var n=Date.now();for(Ja=Xa;Ja;)n>=Ja.t&&(Ja.f=Ja.c(n-Ja.t)),Ja=Ja.n;return n}function Ct(){for(var n,t=Xa,e=1/0;t;)t.f?t=n?n.n=t.n:Xa=t.n:(t.t<e&&(e=t.t),t=(n=t).n);return $a=n,e}function Nt(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Lt(n,t){var e=Math.pow(10,3*oa(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function zt(n){var t=n.decimal,e=n.thousands,r=n.grouping,u=n.currency,i=r?function(n){for(var t=n.length,u=[],i=0,o=r[0];t>0&&o>0;)u.push(n.substring(t-=o,t+o)),o=r[i=(i+1)%r.length];return u.reverse().join(e)}:bt;return function(n){var e=Qa.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"",c=e[4]||"",s=e[5],l=+e[6],f=e[7],h=e[8],g=e[9],p=1,v="",d="",m=!1;switch(h&&(h=+h.substring(1)),(s||"0"===r&&"="===o)&&(s=r="0",o="=",f&&(l-=Math.floor((l-1)/4))),g){case"n":f=!0,g="g";break;case"%":p=100,d="%",g="f";break;case"p":p=100,d="%",g="r";break;case"b":case"o":case"x":case"X":"#"===c&&(v="0"+g.toLowerCase());case"c":case"d":m=!0,h=0;break;case"s":p=-1,g="r"}"$"===c&&(v=u[0],d=u[1]),"r"!=g||h||(g="g"),null!=h&&("g"==g?h=Math.max(1,Math.min(21,h)):("e"==g||"f"==g)&&(h=Math.max(0,Math.min(20,h)))),g=nc.get(g)||qt;var y=s&&f;return function(n){var e=d;if(m&&n%1)return"";var u=0>n||0===n&&0>1/n?(n=-n,"-"):a;if(0>p){var c=Xo.formatPrefix(n,h);n=c.scale(n),e=c.symbol+d}else n*=p;n=g(n,h);var x=n.lastIndexOf("."),M=0>x?n:n.substring(0,x),_=0>x?"":t+n.substring(x+1);!s&&f&&(M=i(M));var b=v.length+M.length+_.length+(y?0:u.length),w=l>b?new Array(b=l-b+1).join(r):"";return y&&(M=i(w+M)),u+=v,n=M+_,("<"===o?u+n+w:">"===o?w+u+n:"^"===o?w.substring(0,b>>=1)+u+n+w.substring(b):u+(y?n:w+n))+e}}}function qt(n){return n+""}function Tt(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function Rt(n,t,e){function r(t){var e=n(t),r=i(e,1);return r-t>t-e?e:r}function u(e){return t(e=n(new ec(e-1)),1),e}function i(n,e){return t(n=new ec(+n),e),n}function o(n,r,i){var o=u(n),a=[];if(i>1)for(;r>o;)e(o)%i||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{ec=Tt;var r=new Tt;return r._=n,o(r,t,e)}finally{ec=Date}}n.floor=n,n.round=r,n.ceil=u,n.offset=i,n.range=o;var c=n.utc=Dt(n);return c.floor=c,c.round=Dt(r),c.ceil=Dt(u),c.offset=Dt(i),c.range=a,n}function Dt(n){return function(t,e){try{ec=Tt;var r=new Tt;return r._=t,n(r,e)._}finally{ec=Date}}}function Pt(n){function t(n){function t(t){for(var e,u,i,o=[],a=-1,c=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.substring(c,a)),null!=(u=uc[e=n.charAt(++a)])&&(e=n.charAt(++a)),(i=C[e])&&(e=i(t,null==u?"e"===e?" ":"0":u)),o.push(e),c=a+1);return o.push(n.substring(c,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},u=e(r,n,t,0);if(u!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var i=null!=r.Z&&ec!==Tt,o=new(i?Tt:ec);return"j"in r?o.setFullYear(r.y,0,r.j):"w"in r&&("W"in r||"U"in r)?(o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+Math.floor(r.Z/100),r.M+r.Z%100,r.S,r.L),i?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var u,i,o,a=0,c=t.length,s=e.length;c>a;){if(r>=s)return-1;if(u=t.charCodeAt(a++),37===u){if(o=t.charAt(a++),i=N[o in uc?t.charAt(a++):o],!i||(r=i(n,e,r))<0)return-1}else if(u!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){b.lastIndex=0;var r=b.exec(t.substring(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){M.lastIndex=0;var r=M.exec(t.substring(e));return r?(n.w=_.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){E.lastIndex=0;var r=E.exec(t.substring(e));return r?(n.m=A.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.substring(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,C.c.toString(),t,r)}function c(n,t,r){return e(n,C.x.toString(),t,r)}function s(n,t,r){return e(n,C.X.toString(),t,r)}function l(n,t,e){var r=x.get(t.substring(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var f=n.dateTime,h=n.date,g=n.time,p=n.periods,v=n.days,d=n.shortDays,m=n.months,y=n.shortMonths;t.utc=function(n){function e(n){try{ec=Tt;var t=new ec;return t._=n,r(t)}finally{ec=Date}}var r=t(n);return e.parse=function(n){try{ec=Tt;var t=r.parse(n);return t&&t._}finally{ec=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ee;var x=Xo.map(),M=jt(v),_=Ht(v),b=jt(d),w=Ht(d),S=jt(m),k=Ht(m),E=jt(y),A=Ht(y);p.forEach(function(n,t){x.set(n.toLowerCase(),t)});var C={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return y[n.getMonth()]},B:function(n){return m[n.getMonth()]},c:t(f),d:function(n,t){return Ut(n.getDate(),t,2)},e:function(n,t){return Ut(n.getDate(),t,2)},H:function(n,t){return Ut(n.getHours(),t,2)},I:function(n,t){return Ut(n.getHours()%12||12,t,2)},j:function(n,t){return Ut(1+tc.dayOfYear(n),t,3)},L:function(n,t){return Ut(n.getMilliseconds(),t,3)},m:function(n,t){return Ut(n.getMonth()+1,t,2)},M:function(n,t){return Ut(n.getMinutes(),t,2)},p:function(n){return p[+(n.getHours()>=12)]},S:function(n,t){return Ut(n.getSeconds(),t,2)},U:function(n,t){return Ut(tc.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Ut(tc.mondayOfYear(n),t,2)},x:t(h),X:t(g),y:function(n,t){return Ut(n.getFullYear()%100,t,2)},Y:function(n,t){return Ut(n.getFullYear()%1e4,t,4)},Z:ne,"%":function(){return"%"}},N={a:r,A:u,b:i,B:o,c:a,d:Bt,e:Bt,H:Jt,I:Jt,j:Wt,L:Qt,m:$t,M:Gt,p:l,S:Kt,U:Ot,w:Ft,W:Yt,x:c,X:s,y:Zt,Y:It,Z:Vt,"%":te};return t}function Ut(n,t,e){var r=0>n?"-":"",u=(r?-n:n)+"",i=u.length;return r+(e>i?new Array(e-i+1).join(t)+u:u)}function jt(n){return new RegExp("^(?:"+n.map(Xo.requote).join("|")+")","i")}function Ht(n){for(var t=new u,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function Ft(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Ot(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e));return r?(n.U=+r[0],e+r[0].length):-1}function Yt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e));return r?(n.W=+r[0],e+r[0].length):-1}function It(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Zt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.y=Xt(+r[0]),e+r[0].length):-1}function Vt(n,t,e){return/^[+-]\d{4}$/.test(t=t.substring(e,e+5))?(n.Z=+t,e+5):-1}function Xt(n){return n+(n>68?1900:2e3)}function $t(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function Bt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function Wt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function Jt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function Gt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function Kt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function Qt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function ne(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=~~(oa(t)/60),u=oa(t)%60;return e+Ut(r,"0",2)+Ut(u,"0",2)}function te(n,t,e){oc.lastIndex=0;var r=oc.exec(t.substring(e,e+1));return r?e+r[0].length:-1}function ee(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function re(){}function ue(n,t,e){var r=e.s=n+t,u=r-n,i=r-u;e.t=n-i+(t-u)}function ie(n,t){n&&lc.hasOwnProperty(n.type)&&lc[n.type](n,t)}function oe(n,t,e){var r,u=-1,i=n.length-e;for(t.lineStart();++u<i;)r=n[u],t.point(r[0],r[1],r[2]);t.lineEnd()}function ae(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)oe(n[e],t,1);t.polygonEnd()}function ce(){function n(n,t){n*=Na,t=t*Na/2+Sa/4;var e=n-r,o=Math.cos(t),a=Math.sin(t),c=i*a,s=u*o+c*Math.cos(e),l=c*Math.sin(e);hc.add(Math.atan2(l,s)),r=n,u=o,i=a}var t,e,r,u,i;gc.point=function(o,a){gc.point=n,r=(t=o)*Na,u=Math.cos(a=(e=a)*Na/2+Sa/4),i=Math.sin(a)},gc.lineEnd=function(){n(t,e)}}function se(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function le(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function fe(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function he(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function ge(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function pe(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function ve(n){return[Math.atan2(n[1],n[0]),X(n[2])]}function de(n,t){return oa(n[0]-t[0])<Aa&&oa(n[1]-t[1])<Aa}function me(n,t){n*=Na;var e=Math.cos(t*=Na);ye(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function ye(n,t,e){++pc,dc+=(n-dc)/pc,mc+=(t-mc)/pc,yc+=(e-yc)/pc}function xe(){function n(n,u){n*=Na;var i=Math.cos(u*=Na),o=i*Math.cos(n),a=i*Math.sin(n),c=Math.sin(u),s=Math.atan2(Math.sqrt((s=e*c-r*a)*s+(s=r*o-t*c)*s+(s=t*a-e*o)*s),t*o+e*a+r*c);vc+=s,xc+=s*(t+(t=o)),Mc+=s*(e+(e=a)),_c+=s*(r+(r=c)),ye(t,e,r)}var t,e,r;kc.point=function(u,i){u*=Na;var o=Math.cos(i*=Na);t=o*Math.cos(u),e=o*Math.sin(u),r=Math.sin(i),kc.point=n,ye(t,e,r)}}function Me(){kc.point=me}function _e(){function n(n,t){n*=Na;var e=Math.cos(t*=Na),o=e*Math.cos(n),a=e*Math.sin(n),c=Math.sin(t),s=u*c-i*a,l=i*o-r*c,f=r*a-u*o,h=Math.sqrt(s*s+l*l+f*f),g=r*o+u*a+i*c,p=h&&-V(g)/h,v=Math.atan2(h,g);bc+=p*s,wc+=p*l,Sc+=p*f,vc+=v,xc+=v*(r+(r=o)),Mc+=v*(u+(u=a)),_c+=v*(i+(i=c)),ye(r,u,i)}var t,e,r,u,i;kc.point=function(o,a){t=o,e=a,kc.point=n,o*=Na;var c=Math.cos(a*=Na);r=c*Math.cos(o),u=c*Math.sin(o),i=Math.sin(a),ye(r,u,i)},kc.lineEnd=function(){n(t,e),kc.lineEnd=Me,kc.point=me}}function be(){return!0}function we(n,t,e,r,u){var i=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(de(e,r)){u.lineStart();for(var a=0;t>a;++a)u.point((e=n[a])[0],e[1]);return u.lineEnd(),void 0}var c=new ke(e,n,null,!0),s=new ke(e,null,c,!1);c.o=s,i.push(c),o.push(s),c=new ke(r,n,null,!1),s=new ke(r,null,c,!0),c.o=s,i.push(c),o.push(s)}}),o.sort(t),Se(i),Se(o),i.length){for(var a=0,c=e,s=o.length;s>a;++a)o[a].e=c=!c;for(var l,f,h=i[0];;){for(var g=h,p=!0;g.v;)if((g=g.n)===h)return;l=g.z,u.lineStart();do{if(g.v=g.o.v=!0,g.e){if(p)for(var a=0,s=l.length;s>a;++a)u.point((f=l[a])[0],f[1]);else r(g.x,g.n.x,1,u);g=g.n}else{if(p){l=g.p.z;for(var a=l.length-1;a>=0;--a)u.point((f=l[a])[0],f[1])}else r(g.x,g.p.x,-1,u);g=g.p}g=g.o,l=g.z,p=!p}while(!g.v);u.lineEnd()}}}function Se(n){if(t=n.length){for(var t,e,r=0,u=n[0];++r<t;)u.n=e=n[r],e.p=u,u=e;u.n=e=n[0],e.p=u}}function ke(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Ee(n,t,e,r){return function(u,i){function o(t,e){var r=u(t,e);n(t=r[0],e=r[1])&&i.point(t,e)}function a(n,t){var e=u(n,t);d.point(e[0],e[1])}function c(){y.point=a,d.lineStart()}function s(){y.point=o,d.lineEnd()}function l(n,t){v.push([n,t]);var e=u(n,t);M.point(e[0],e[1])}function f(){M.lineStart(),v=[]}function h(){l(v[0][0],v[0][1]),M.lineEnd();var n,t=M.clean(),e=x.buffer(),r=e.length;if(v.pop(),p.push(v),v=null,r){if(1&t){n=e[0];var u,r=n.length-1,o=-1;for(i.lineStart();++o<r;)i.point((u=n[o])[0],u[1]);return i.lineEnd(),void 0}r>1&&2&t&&e.push(e.pop().concat(e.shift())),g.push(e.filter(Ae))}}var g,p,v,d=t(i),m=u.invert(r[0],r[1]),y={point:o,lineStart:c,lineEnd:s,polygonStart:function(){y.point=l,y.lineStart=f,y.lineEnd=h,g=[],p=[],i.polygonStart()},polygonEnd:function(){y.point=o,y.lineStart=c,y.lineEnd=s,g=Xo.merge(g);var n=Le(m,p);g.length?we(g,Ne,n,e,i):n&&(i.lineStart(),e(null,null,1,i),i.lineEnd()),i.polygonEnd(),g=p=null},sphere:function(){i.polygonStart(),i.lineStart(),e(null,null,1,i),i.lineEnd(),i.polygonEnd()}},x=Ce(),M=t(x);return y}}function Ae(n){return n.length>1}function Ce(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:g,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ne(n,t){return((n=n.x)[0]<0?n[1]-Ea-Aa:Ea-n[1])-((t=t.x)[0]<0?t[1]-Ea-Aa:Ea-t[1])}function Le(n,t){var e=n[0],r=n[1],u=[Math.sin(e),-Math.cos(e),0],i=0,o=0;hc.reset();for(var a=0,c=t.length;c>a;++a){var s=t[a],l=s.length;if(l)for(var f=s[0],h=f[0],g=f[1]/2+Sa/4,p=Math.sin(g),v=Math.cos(g),d=1;;){d===l&&(d=0),n=s[d];var m=n[0],y=n[1]/2+Sa/4,x=Math.sin(y),M=Math.cos(y),_=m-h,b=oa(_)>Sa,w=p*x;if(hc.add(Math.atan2(w*Math.sin(_),v*M+w*Math.cos(_))),i+=b?_+(_>=0?ka:-ka):_,b^h>=e^m>=e){var S=fe(se(f),se(n));pe(S);var k=fe(u,S);pe(k);var E=(b^_>=0?-1:1)*X(k[2]);(r>E||r===E&&(S[0]||S[1]))&&(o+=b^_>=0?1:-1)}if(!d++)break;h=m,p=x,v=M,f=n}}return(-Aa>i||Aa>i&&0>hc)^1&o}function ze(n){var t,e=0/0,r=0/0,u=0/0;return{lineStart:function(){n.lineStart(),t=1},point:function(i,o){var a=i>0?Sa:-Sa,c=oa(i-e);oa(c-Sa)<Aa?(n.point(e,r=(r+o)/2>0?Ea:-Ea),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(i,r),t=0):u!==a&&c>=Sa&&(oa(e-u)<Aa&&(e-=u*Aa),oa(i-a)<Aa&&(i-=a*Aa),r=qe(e,r,i,o),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=i,r=o),u=a},lineEnd:function(){n.lineEnd(),e=r=0/0},clean:function(){return 2-t}}}function qe(n,t,e,r){var u,i,o=Math.sin(n-e);return oa(o)>Aa?Math.atan((Math.sin(t)*(i=Math.cos(r))*Math.sin(e)-Math.sin(r)*(u=Math.cos(t))*Math.sin(n))/(u*i*o)):(t+r)/2}function Te(n,t,e,r){var u;if(null==n)u=e*Ea,r.point(-Sa,u),r.point(0,u),r.point(Sa,u),r.point(Sa,0),r.point(Sa,-u),r.point(0,-u),r.point(-Sa,-u),r.point(-Sa,0),r.point(-Sa,u);else if(oa(n[0]-t[0])>Aa){var i=n[0]<t[0]?Sa:-Sa;u=e*i/2,r.point(-i,u),r.point(0,u),r.point(i,u)}else r.point(t[0],t[1])}function Re(n){function t(n,t){return Math.cos(n)*Math.cos(t)>i}function e(n){var e,i,c,s,l;return{lineStart:function(){s=c=!1,l=1},point:function(f,h){var g,p=[f,h],v=t(f,h),d=o?v?0:u(f,h):v?u(f+(0>f?Sa:-Sa),h):0;if(!e&&(s=c=v)&&n.lineStart(),v!==c&&(g=r(e,p),(de(e,g)||de(p,g))&&(p[0]+=Aa,p[1]+=Aa,v=t(p[0],p[1]))),v!==c)l=0,v?(n.lineStart(),g=r(p,e),n.point(g[0],g[1])):(g=r(e,p),n.point(g[0],g[1]),n.lineEnd()),e=g;else if(a&&e&&o^v){var m;d&i||!(m=r(p,e,!0))||(l=0,o?(n.lineStart(),n.point(m[0][0],m[0][1]),n.point(m[1][0],m[1][1]),n.lineEnd()):(n.point(m[1][0],m[1][1]),n.lineEnd(),n.lineStart(),n.point(m[0][0],m[0][1])))}!v||e&&de(e,p)||n.point(p[0],p[1]),e=p,c=v,i=d},lineEnd:function(){c&&n.lineEnd(),e=null},clean:function(){return l|(s&&c)<<1}}}function r(n,t,e){var r=se(n),u=se(t),o=[1,0,0],a=fe(r,u),c=le(a,a),s=a[0],l=c-s*s;if(!l)return!e&&n;var f=i*c/l,h=-i*s/l,g=fe(o,a),p=ge(o,f),v=ge(a,h);he(p,v);var d=g,m=le(p,d),y=le(d,d),x=m*m-y*(le(p,p)-1);if(!(0>x)){var M=Math.sqrt(x),_=ge(d,(-m-M)/y);if(he(_,p),_=ve(_),!e)return _;var b,w=n[0],S=t[0],k=n[1],E=t[1];w>S&&(b=w,w=S,S=b);var A=S-w,C=oa(A-Sa)<Aa,N=C||Aa>A;if(!C&&k>E&&(b=k,k=E,E=b),N?C?k+E>0^_[1]<(oa(_[0]-w)<Aa?k:E):k<=_[1]&&_[1]<=E:A>Sa^(w<=_[0]&&_[0]<=S)){var L=ge(d,(-m+M)/y);return he(L,p),[_,ve(L)]}}}function u(t,e){var r=o?n:Sa-n,u=0;return-r>t?u|=1:t>r&&(u|=2),-r>e?u|=4:e>r&&(u|=8),u}var i=Math.cos(n),o=i>0,a=oa(i)>Aa,c=cr(n,6*Na);return Ee(t,e,c,o?[0,-n]:[-Sa,n-Sa])}function De(n,t,e,r){return function(u){var i,o=u.a,a=u.b,c=o.x,s=o.y,l=a.x,f=a.y,h=0,g=1,p=l-c,v=f-s;if(i=n-c,p||!(i>0)){if(i/=p,0>p){if(h>i)return;g>i&&(g=i)}else if(p>0){if(i>g)return;i>h&&(h=i)}if(i=e-c,p||!(0>i)){if(i/=p,0>p){if(i>g)return;i>h&&(h=i)}else if(p>0){if(h>i)return;g>i&&(g=i)}if(i=t-s,v||!(i>0)){if(i/=v,0>v){if(h>i)return;g>i&&(g=i)}else if(v>0){if(i>g)return;i>h&&(h=i)}if(i=r-s,v||!(0>i)){if(i/=v,0>v){if(i>g)return;i>h&&(h=i)}else if(v>0){if(h>i)return;g>i&&(g=i)}return h>0&&(u.a={x:c+h*p,y:s+h*v}),1>g&&(u.b={x:c+g*p,y:s+g*v}),u}}}}}}function Pe(n,t,e,r){function u(r,u){return oa(r[0]-n)<Aa?u>0?0:3:oa(r[0]-e)<Aa?u>0?2:1:oa(r[1]-t)<Aa?u>0?1:0:u>0?3:2}function i(n,t){return o(n.x,t.x)}function o(n,t){var e=u(n,1),r=u(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function c(n){for(var t=0,e=d.length,r=n[1],u=0;e>u;++u)for(var i,o=1,a=d[u],c=a.length,s=a[0];c>o;++o)i=a[o],s[1]<=r?i[1]>r&&Z(s,i,n)>0&&++t:i[1]<=r&&Z(s,i,n)<0&&--t,s=i;return 0!==t}function s(i,a,c,s){var l=0,f=0;if(null==i||(l=u(i,c))!==(f=u(a,c))||o(i,a)<0^c>0){do s.point(0===l||3===l?n:e,l>1?r:t);while((l=(l+c+4)%4)!==f)}else s.point(a[0],a[1])}function l(u,i){return u>=n&&e>=u&&i>=t&&r>=i}function f(n,t){l(n,t)&&a.point(n,t)}function h(){N.point=p,d&&d.push(m=[]),S=!0,w=!1,_=b=0/0}function g(){v&&(p(y,x),M&&w&&A.rejoin(),v.push(A.buffer())),N.point=f,w&&a.lineEnd()}function p(n,t){n=Math.max(-Ac,Math.min(Ac,n)),t=Math.max(-Ac,Math.min(Ac,t));var e=l(n,t);if(d&&m.push([n,t]),S)y=n,x=t,M=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:_,y:b},b:{x:n,y:t}};C(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}_=n,b=t,w=e}var v,d,m,y,x,M,_,b,w,S,k,E=a,A=Ce(),C=De(n,t,e,r),N={point:f,lineStart:h,lineEnd:g,polygonStart:function(){a=A,v=[],d=[],k=!0},polygonEnd:function(){a=E,v=Xo.merge(v);var t=c([n,r]),e=k&&t,u=v.length;(e||u)&&(a.polygonStart(),e&&(a.lineStart(),s(null,null,1,a),a.lineEnd()),u&&we(v,i,t,s,a),a.polygonEnd()),v=d=m=null}};return N}}function Ue(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function je(n){var t=0,e=Sa/3,r=nr(n),u=r(t,e);return u.parallels=function(n){return arguments.length?r(t=n[0]*Sa/180,e=n[1]*Sa/180):[180*(t/Sa),180*(e/Sa)]},u}function He(n,t){function e(n,t){var e=Math.sqrt(i-2*u*Math.sin(t))/u;return[e*Math.sin(n*=u),o-e*Math.cos(n)]}var r=Math.sin(n),u=(r+Math.sin(t))/2,i=1+r*(2*u-r),o=Math.sqrt(i)/u;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/u,X((i-(n*n+e*e)*u*u)/(2*u))]},e}function Fe(){function n(n,t){Nc+=u*n-r*t,r=n,u=t}var t,e,r,u;Rc.point=function(i,o){Rc.point=n,t=r=i,e=u=o},Rc.lineEnd=function(){n(t,e)}}function Oe(n,t){Lc>n&&(Lc=n),n>qc&&(qc=n),zc>t&&(zc=t),t>Tc&&(Tc=t)}function Ye(){function n(n,t){o.push("M",n,",",t,i)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function u(){o.push("Z")}var i=Ie(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return i=Ie(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Ie(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Ze(n,t){dc+=n,mc+=t,++yc}function Ve(){function n(n,r){var u=n-t,i=r-e,o=Math.sqrt(u*u+i*i);xc+=o*(t+n)/2,Mc+=o*(e+r)/2,_c+=o,Ze(t=n,e=r)}var t,e;Pc.point=function(r,u){Pc.point=n,Ze(t=r,e=u)}}function Xe(){Pc.point=Ze}function $e(){function n(n,t){var e=n-r,i=t-u,o=Math.sqrt(e*e+i*i);xc+=o*(r+n)/2,Mc+=o*(u+t)/2,_c+=o,o=u*n-r*t,bc+=o*(r+n),wc+=o*(u+t),Sc+=3*o,Ze(r=n,u=t)}var t,e,r,u;Pc.point=function(i,o){Pc.point=n,Ze(t=r=i,e=u=o)},Pc.lineEnd=function(){n(t,e)}}function Be(n){function t(t,e){n.moveTo(t,e),n.arc(t,e,o,0,ka)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function u(){a.point=t}function i(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:u,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=u,a.point=t},pointRadius:function(n){return o=n,a},result:g};return a}function We(n){function t(n){return(a?r:e)(n)}function e(t){return Ke(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){x=0/0,S.point=i,t.lineStart()}function i(e,r){var i=se([e,r]),o=n(e,r);u(x,M,y,_,b,w,x=o[0],M=o[1],y=e,_=i[0],b=i[1],w=i[2],a,t),t.point(x,M)}function o(){S.point=e,t.lineEnd()}function c(){r(),S.point=s,S.lineEnd=l}function s(n,t){i(f=n,h=t),g=x,p=M,v=_,d=b,m=w,S.point=i}function l(){u(x,M,y,_,b,w,g,p,f,v,d,m,a,t),S.lineEnd=o,o()}var f,h,g,p,v,d,m,y,x,M,_,b,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=c},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function u(t,e,r,a,c,s,l,f,h,g,p,v,d,m){var y=l-t,x=f-e,M=y*y+x*x;if(M>4*i&&d--){var _=a+g,b=c+p,w=s+v,S=Math.sqrt(_*_+b*b+w*w),k=Math.asin(w/=S),E=oa(oa(w)-1)<Aa||oa(r-h)<Aa?(r+h)/2:Math.atan2(b,_),A=n(E,k),C=A[0],N=A[1],L=C-t,z=N-e,q=x*L-y*z;(q*q/M>i||oa((y*L+x*z)/M-.5)>.3||o>a*g+c*p+s*v)&&(u(t,e,r,a,c,s,C,N,E,_/=S,b/=S,w,d,m),m.point(C,N),u(C,N,E,_,b,w,l,f,h,g,p,v,d,m))}}var i=.5,o=Math.cos(30*Na),a=16;return t.precision=function(n){return arguments.length?(a=(i=n*n)>0&&16,t):Math.sqrt(i)},t}function Je(n){var t=We(function(t,e){return n([t*La,e*La])});return function(n){return tr(t(n))}}function Ge(n){this.stream=n}function Ke(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function Qe(n){return nr(function(){return n})()}function nr(n){function t(n){return n=a(n[0]*Na,n[1]*Na),[n[0]*h+c,s-n[1]*h]}function e(n){return n=a.invert((n[0]-c)/h,(s-n[1])/h),n&&[n[0]*La,n[1]*La]}function r(){a=Ue(o=ur(m,y,x),i);var n=i(v,d);return c=g-n[0]*h,s=p+n[1]*h,u()}function u(){return l&&(l.valid=!1,l=null),t}var i,o,a,c,s,l,f=We(function(n,t){return n=i(n,t),[n[0]*h+c,s-n[1]*h]}),h=150,g=480,p=250,v=0,d=0,m=0,y=0,x=0,M=Ec,_=bt,b=null,w=null;return t.stream=function(n){return l&&(l.valid=!1),l=tr(M(o,f(_(n)))),l.valid=!0,l},t.clipAngle=function(n){return arguments.length?(M=null==n?(b=n,Ec):Re((b=+n)*Na),u()):b
+},t.clipExtent=function(n){return arguments.length?(w=n,_=n?Pe(n[0][0],n[0][1],n[1][0],n[1][1]):bt,u()):w},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(g=+n[0],p=+n[1],r()):[g,p]},t.center=function(n){return arguments.length?(v=n[0]%360*Na,d=n[1]%360*Na,r()):[v*La,d*La]},t.rotate=function(n){return arguments.length?(m=n[0]%360*Na,y=n[1]%360*Na,x=n.length>2?n[2]%360*Na:0,r()):[m*La,y*La,x*La]},Xo.rebind(t,f,"precision"),function(){return i=n.apply(this,arguments),t.invert=i.invert&&e,r()}}function tr(n){return Ke(n,function(t,e){n.point(t*Na,e*Na)})}function er(n,t){return[n,t]}function rr(n,t){return[n>Sa?n-ka:-Sa>n?n+ka:n,t]}function ur(n,t,e){return n?t||e?Ue(or(n),ar(t,e)):or(n):t||e?ar(t,e):rr}function ir(n){return function(t,e){return t+=n,[t>Sa?t-ka:-Sa>t?t+ka:t,e]}}function or(n){var t=ir(n);return t.invert=ir(-n),t}function ar(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,s=Math.sin(t),l=s*r+a*u;return[Math.atan2(c*i-l*o,a*r-s*u),X(l*i+c*o)]}var r=Math.cos(n),u=Math.sin(n),i=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,s=Math.sin(t),l=s*i-c*o;return[Math.atan2(c*i+s*o,a*r+l*u),X(l*r-a*u)]},e}function cr(n,t){var e=Math.cos(n),r=Math.sin(n);return function(u,i,o,a){var c=o*t;null!=u?(u=sr(e,u),i=sr(e,i),(o>0?i>u:u>i)&&(u+=o*ka)):(u=n+o*ka,i=n-.5*c);for(var s,l=u;o>0?l>i:i>l;l-=c)a.point((s=ve([e,-r*Math.cos(l),-r*Math.sin(l)]))[0],s[1])}}function sr(n,t){var e=se(t);e[0]-=n,pe(e);var r=V(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Aa)%(2*Math.PI)}function lr(n,t,e){var r=Xo.range(n,t-Aa,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function fr(n,t,e){var r=Xo.range(n,t-Aa,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function hr(n){return n.source}function gr(n){return n.target}function pr(n,t,e,r){var u=Math.cos(t),i=Math.sin(t),o=Math.cos(r),a=Math.sin(r),c=u*Math.cos(n),s=u*Math.sin(n),l=o*Math.cos(e),f=o*Math.sin(e),h=2*Math.asin(Math.sqrt(J(r-t)+u*o*J(e-n))),g=1/Math.sin(h),p=h?function(n){var t=Math.sin(n*=h)*g,e=Math.sin(h-n)*g,r=e*c+t*l,u=e*s+t*f,o=e*i+t*a;return[Math.atan2(u,r)*La,Math.atan2(o,Math.sqrt(r*r+u*u))*La]}:function(){return[n*La,t*La]};return p.distance=h,p}function vr(){function n(n,u){var i=Math.sin(u*=Na),o=Math.cos(u),a=oa((n*=Na)-t),c=Math.cos(a);Uc+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*i-e*o*c)*a),e*i+r*o*c),t=n,e=i,r=o}var t,e,r;jc.point=function(u,i){t=u*Na,e=Math.sin(i*=Na),r=Math.cos(i),jc.point=n},jc.lineEnd=function(){jc.point=jc.lineEnd=g}}function dr(n,t){function e(t,e){var r=Math.cos(t),u=Math.cos(e),i=n(r*u);return[i*u*Math.sin(t),i*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),u=t(r),i=Math.sin(u),o=Math.cos(u);return[Math.atan2(n*i,r*o),Math.asin(r&&e*i/r)]},e}function mr(n,t){function e(n,t){var e=oa(oa(t)-Ea)<Aa?0:o/Math.pow(u(t),i);return[e*Math.sin(i*n),o-e*Math.cos(i*n)]}var r=Math.cos(n),u=function(n){return Math.tan(Sa/4+n/2)},i=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(u(t)/u(n)),o=r*Math.pow(u(n),i)/i;return i?(e.invert=function(n,t){var e=o-t,r=I(i)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/i,2*Math.atan(Math.pow(o/r,1/i))-Ea]},e):xr}function yr(n,t){function e(n,t){var e=i-t;return[e*Math.sin(u*n),i-e*Math.cos(u*n)]}var r=Math.cos(n),u=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),i=r/u+n;return oa(u)<Aa?er:(e.invert=function(n,t){var e=i-t;return[Math.atan2(n,e)/u,i-I(u)*Math.sqrt(n*n+e*e)]},e)}function xr(n,t){return[n,Math.log(Math.tan(Sa/4+t/2))]}function Mr(n){var t,e=Qe(n),r=e.scale,u=e.translate,i=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=u.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=i.apply(e,arguments);if(o===e){if(t=null==n){var a=Sa*r(),c=u();i([[c[0]-a,c[1]-a],[c[0]+a,c[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function _r(n,t){return[Math.log(Math.tan(Sa/4+t/2)),-n]}function br(n){return n[0]}function wr(n){return n[1]}function Sr(n){for(var t=n.length,e=[0,1],r=2,u=2;t>u;u++){for(;r>1&&Z(n[e[r-2]],n[e[r-1]],n[u])<=0;)--r;e[r++]=u}return e.slice(0,r)}function kr(n,t){return n[0]-t[0]||n[1]-t[1]}function Er(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Ar(n,t,e,r){var u=n[0],i=e[0],o=t[0]-u,a=r[0]-i,c=n[1],s=e[1],l=t[1]-c,f=r[1]-s,h=(a*(c-s)-f*(u-i))/(f*o-a*l);return[u+h*o,c+h*l]}function Cr(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Nr(){Jr(this),this.edge=this.site=this.circle=null}function Lr(n){var t=Jc.pop()||new Nr;return t.site=n,t}function zr(n){Or(n),$c.remove(n),Jc.push(n),Jr(n)}function qr(n){var t=n.circle,e=t.x,r=t.cy,u={x:e,y:r},i=n.P,o=n.N,a=[n];zr(n);for(var c=i;c.circle&&oa(e-c.circle.x)<Aa&&oa(r-c.circle.cy)<Aa;)i=c.P,a.unshift(c),zr(c),c=i;a.unshift(c),Or(c);for(var s=o;s.circle&&oa(e-s.circle.x)<Aa&&oa(r-s.circle.cy)<Aa;)o=s.N,a.push(s),zr(s),s=o;a.push(s),Or(s);var l,f=a.length;for(l=1;f>l;++l)s=a[l],c=a[l-1],$r(s.edge,c.site,s.site,u);c=a[0],s=a[f-1],s.edge=Vr(c.site,s.site,null,u),Fr(c),Fr(s)}function Tr(n){for(var t,e,r,u,i=n.x,o=n.y,a=$c._;a;)if(r=Rr(a,o)-i,r>Aa)a=a.L;else{if(u=i-Dr(a,o),!(u>Aa)){r>-Aa?(t=a.P,e=a):u>-Aa?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var c=Lr(n);if($c.insert(t,c),t||e){if(t===e)return Or(t),e=Lr(t.site),$c.insert(c,e),c.edge=e.edge=Vr(t.site,c.site),Fr(t),Fr(e),void 0;if(!e)return c.edge=Vr(t.site,c.site),void 0;Or(t),Or(e);var s=t.site,l=s.x,f=s.y,h=n.x-l,g=n.y-f,p=e.site,v=p.x-l,d=p.y-f,m=2*(h*d-g*v),y=h*h+g*g,x=v*v+d*d,M={x:(d*y-g*x)/m+l,y:(h*x-v*y)/m+f};$r(e.edge,s,p,M),c.edge=Vr(s,n,null,M),e.edge=Vr(n,p,null,M),Fr(t),Fr(e)}}function Rr(n,t){var e=n.site,r=e.x,u=e.y,i=u-t;if(!i)return r;var o=n.P;if(!o)return-1/0;e=o.site;var a=e.x,c=e.y,s=c-t;if(!s)return a;var l=a-r,f=1/i-1/s,h=l/s;return f?(-h+Math.sqrt(h*h-2*f*(l*l/(-2*s)-c+s/2+u-i/2)))/f+r:(r+a)/2}function Dr(n,t){var e=n.N;if(e)return Rr(e,t);var r=n.site;return r.y===t?r.x:1/0}function Pr(n){this.site=n,this.edges=[]}function Ur(n){for(var t,e,r,u,i,o,a,c,s,l,f=n[0][0],h=n[1][0],g=n[0][1],p=n[1][1],v=Xc,d=v.length;d--;)if(i=v[d],i&&i.prepare())for(a=i.edges,c=a.length,o=0;c>o;)l=a[o].end(),r=l.x,u=l.y,s=a[++o%c].start(),t=s.x,e=s.y,(oa(r-t)>Aa||oa(u-e)>Aa)&&(a.splice(o,0,new Br(Xr(i.site,l,oa(r-f)<Aa&&p-u>Aa?{x:f,y:oa(t-f)<Aa?e:p}:oa(u-p)<Aa&&h-r>Aa?{x:oa(e-p)<Aa?t:h,y:p}:oa(r-h)<Aa&&u-g>Aa?{x:h,y:oa(t-h)<Aa?e:g}:oa(u-g)<Aa&&r-f>Aa?{x:oa(e-g)<Aa?t:f,y:g}:null),i.site,null)),++c)}function jr(n,t){return t.angle-n.angle}function Hr(){Jr(this),this.x=this.y=this.arc=this.site=this.cy=null}function Fr(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,u=n.site,i=e.site;if(r!==i){var o=u.x,a=u.y,c=r.x-o,s=r.y-a,l=i.x-o,f=i.y-a,h=2*(c*f-s*l);if(!(h>=-Ca)){var g=c*c+s*s,p=l*l+f*f,v=(f*g-s*p)/h,d=(c*p-l*g)/h,f=d+a,m=Gc.pop()||new Hr;m.arc=n,m.site=u,m.x=v+o,m.y=f+Math.sqrt(v*v+d*d),m.cy=f,n.circle=m;for(var y=null,x=Wc._;x;)if(m.y<x.y||m.y===x.y&&m.x<=x.x){if(!x.L){y=x.P;break}x=x.L}else{if(!x.R){y=x;break}x=x.R}Wc.insert(y,m),y||(Bc=m)}}}}function Or(n){var t=n.circle;t&&(t.P||(Bc=t.N),Wc.remove(t),Gc.push(t),Jr(t),n.circle=null)}function Yr(n){for(var t,e=Vc,r=De(n[0][0],n[0][1],n[1][0],n[1][1]),u=e.length;u--;)t=e[u],(!Ir(t,n)||!r(t)||oa(t.a.x-t.b.x)<Aa&&oa(t.a.y-t.b.y)<Aa)&&(t.a=t.b=null,e.splice(u,1))}function Ir(n,t){var e=n.b;if(e)return!0;var r,u,i=n.a,o=t[0][0],a=t[1][0],c=t[0][1],s=t[1][1],l=n.l,f=n.r,h=l.x,g=l.y,p=f.x,v=f.y,d=(h+p)/2,m=(g+v)/2;if(v===g){if(o>d||d>=a)return;if(h>p){if(i){if(i.y>=s)return}else i={x:d,y:c};e={x:d,y:s}}else{if(i){if(i.y<c)return}else i={x:d,y:s};e={x:d,y:c}}}else if(r=(h-p)/(v-g),u=m-r*d,-1>r||r>1)if(h>p){if(i){if(i.y>=s)return}else i={x:(c-u)/r,y:c};e={x:(s-u)/r,y:s}}else{if(i){if(i.y<c)return}else i={x:(s-u)/r,y:s};e={x:(c-u)/r,y:c}}else if(v>g){if(i){if(i.x>=a)return}else i={x:o,y:r*o+u};e={x:a,y:r*a+u}}else{if(i){if(i.x<o)return}else i={x:a,y:r*a+u};e={x:o,y:r*o+u}}return n.a=i,n.b=e,!0}function Zr(n,t){this.l=n,this.r=t,this.a=this.b=null}function Vr(n,t,e,r){var u=new Zr(n,t);return Vc.push(u),e&&$r(u,n,t,e),r&&$r(u,t,n,r),Xc[n.i].edges.push(new Br(u,n,t)),Xc[t.i].edges.push(new Br(u,t,n)),u}function Xr(n,t,e){var r=new Zr(n,null);return r.a=t,r.b=e,Vc.push(r),r}function $r(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function Br(n,t,e){var r=n.a,u=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(u.x-r.x,r.y-u.y):Math.atan2(r.x-u.x,u.y-r.y)}function Wr(){this._=null}function Jr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function Gr(n,t){var e=t,r=t.R,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function Kr(n,t){var e=t,r=t.L,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function Qr(n){for(;n.L;)n=n.L;return n}function nu(n,t){var e,r,u,i=n.sort(tu).pop();for(Vc=[],Xc=new Array(n.length),$c=new Wr,Wc=new Wr;;)if(u=Bc,i&&(!u||i.y<u.y||i.y===u.y&&i.x<u.x))(i.x!==e||i.y!==r)&&(Xc[i.i]=new Pr(i),Tr(i),e=i.x,r=i.y),i=n.pop();else{if(!u)break;qr(u.arc)}t&&(Yr(t),Ur(t));var o={cells:Xc,edges:Vc};return $c=Wc=Vc=Xc=null,o}function tu(n,t){return t.y-n.y||t.x-n.x}function eu(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function ru(n){return n.x}function uu(n){return n.y}function iu(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function ou(n,t,e,r,u,i){if(!n(t,e,r,u,i)){var o=.5*(e+u),a=.5*(r+i),c=t.nodes;c[0]&&ou(n,c[0],e,r,o,a),c[1]&&ou(n,c[1],o,r,u,a),c[2]&&ou(n,c[2],e,a,o,i),c[3]&&ou(n,c[3],o,a,u,i)}}function au(n,t){n=Xo.rgb(n),t=Xo.rgb(t);var e=n.r,r=n.g,u=n.b,i=t.r-e,o=t.g-r,a=t.b-u;return function(n){return"#"+vt(Math.round(e+i*n))+vt(Math.round(r+o*n))+vt(Math.round(u+a*n))}}function cu(n,t){var e,r={},u={};for(e in n)e in t?r[e]=fu(n[e],t[e]):u[e]=n[e];for(e in t)e in n||(u[e]=t[e]);return function(n){for(e in r)u[e]=r[e](n);return u}}function su(n,t){return t-=n=+n,function(e){return n+t*e}}function lu(n,t){var e,r,u,i,o,a=0,c=0,s=[],l=[];for(n+="",t+="",Qc.lastIndex=0,r=0;e=Qc.exec(t);++r)e.index&&s.push(t.substring(a,c=e.index)),l.push({i:s.length,x:e[0]}),s.push(null),a=Qc.lastIndex;for(a<t.length&&s.push(t.substring(a)),r=0,i=l.length;(e=Qc.exec(n))&&i>r;++r)if(o=l[r],o.x==e[0]){if(o.i)if(null==s[o.i+1])for(s[o.i-1]+=o.x,s.splice(o.i,1),u=r+1;i>u;++u)l[u].i--;else for(s[o.i-1]+=o.x+s[o.i+1],s.splice(o.i,2),u=r+1;i>u;++u)l[u].i-=2;else if(null==s[o.i+1])s[o.i]=o.x;else for(s[o.i]=o.x+s[o.i+1],s.splice(o.i+1,1),u=r+1;i>u;++u)l[u].i--;l.splice(r,1),i--,r--}else o.x=su(parseFloat(e[0]),parseFloat(o.x));for(;i>r;)o=l.pop(),null==s[o.i+1]?s[o.i]=o.x:(s[o.i]=o.x+s[o.i+1],s.splice(o.i+1,1)),i--;return 1===s.length?null==s[0]?(o=l[0].x,function(n){return o(n)+""}):function(){return t}:function(n){for(r=0;i>r;++r)s[(o=l[r]).i]=o.x(n);return s.join("")}}function fu(n,t){for(var e,r=Xo.interpolators.length;--r>=0&&!(e=Xo.interpolators[r](n,t)););return e}function hu(n,t){var e,r=[],u=[],i=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(fu(n[e],t[e]));for(;i>e;++e)u[e]=n[e];for(;o>e;++e)u[e]=t[e];return function(n){for(e=0;a>e;++e)u[e]=r[e](n);return u}}function gu(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function pu(n){return function(t){return 1-n(1-t)}}function vu(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function du(n){return n*n}function mu(n){return n*n*n}function yu(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function xu(n){return function(t){return Math.pow(t,n)}}function Mu(n){return 1-Math.cos(n*Ea)}function _u(n){return Math.pow(2,10*(n-1))}function bu(n){return 1-Math.sqrt(1-n*n)}function wu(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/ka*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*ka/t)}}function Su(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function ku(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Eu(n,t){n=Xo.hcl(n),t=Xo.hcl(t);var e=n.h,r=n.c,u=n.l,i=t.h-e,o=t.c-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return rt(e+i*n,r+o*n,u+a*n)+""}}function Au(n,t){n=Xo.hsl(n),t=Xo.hsl(t);var e=n.h,r=n.s,u=n.l,i=t.h-e,o=t.s-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return nt(e+i*n,r+o*n,u+a*n)+""}}function Cu(n,t){n=Xo.lab(n),t=Xo.lab(t);var e=n.l,r=n.a,u=n.b,i=t.l-e,o=t.a-r,a=t.b-u;return function(n){return ot(e+i*n,r+o*n,u+a*n)+""}}function Nu(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function Lu(n){var t=[n.a,n.b],e=[n.c,n.d],r=qu(t),u=zu(t,e),i=qu(Tu(e,t,-u))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,u*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*La,this.translate=[n.e,n.f],this.scale=[r,i],this.skew=i?Math.atan2(u,i)*La:0}function zu(n,t){return n[0]*t[0]+n[1]*t[1]}function qu(n){var t=Math.sqrt(zu(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Tu(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ru(n,t){var e,r=[],u=[],i=Xo.transform(n),o=Xo.transform(t),a=i.translate,c=o.translate,s=i.rotate,l=o.rotate,f=i.skew,h=o.skew,g=i.scale,p=o.scale;return a[0]!=c[0]||a[1]!=c[1]?(r.push("translate(",null,",",null,")"),u.push({i:1,x:su(a[0],c[0])},{i:3,x:su(a[1],c[1])})):c[0]||c[1]?r.push("translate("+c+")"):r.push(""),s!=l?(s-l>180?l+=360:l-s>180&&(s+=360),u.push({i:r.push(r.pop()+"rotate(",null,")")-2,x:su(s,l)})):l&&r.push(r.pop()+"rotate("+l+")"),f!=h?u.push({i:r.push(r.pop()+"skewX(",null,")")-2,x:su(f,h)}):h&&r.push(r.pop()+"skewX("+h+")"),g[0]!=p[0]||g[1]!=p[1]?(e=r.push(r.pop()+"scale(",null,",",null,")"),u.push({i:e-4,x:su(g[0],p[0])},{i:e-2,x:su(g[1],p[1])})):(1!=p[0]||1!=p[1])&&r.push(r.pop()+"scale("+p+")"),e=u.length,function(n){for(var t,i=-1;++i<e;)r[(t=u[i]).i]=t.x(n);return r.join("")}}function Du(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return(e-n)*t}}function Pu(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return Math.max(0,Math.min(1,(e-n)*t))}}function Uu(n){for(var t=n.source,e=n.target,r=Hu(t,e),u=[t];t!==r;)t=t.parent,u.push(t);for(var i=u.length;e!==r;)u.splice(i,0,e),e=e.parent;return u}function ju(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Hu(n,t){if(n===t)return n;for(var e=ju(n),r=ju(t),u=e.pop(),i=r.pop(),o=null;u===i;)o=u,u=e.pop(),i=r.pop();return o}function Fu(n){n.fixed|=2}function Ou(n){n.fixed&=-7}function Yu(n){n.fixed|=4,n.px=n.x,n.py=n.y}function Iu(n){n.fixed&=-5}function Zu(n,t,e){var r=0,u=0;if(n.charge=0,!n.leaf)for(var i,o=n.nodes,a=o.length,c=-1;++c<a;)i=o[c],null!=i&&(Zu(i,t,e),n.charge+=i.charge,r+=i.charge*i.cx,u+=i.charge*i.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var s=t*e[n.point.index];n.charge+=n.pointCharge=s,r+=s*n.point.x,u+=s*n.point.y}n.cx=r/n.charge,n.cy=u/n.charge}function Vu(n,t){return Xo.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=Wu,n}function Xu(n){return n.children}function $u(n){return n.value}function Bu(n,t){return t.value-n.value}function Wu(n){return Xo.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function Ju(n){return n.x}function Gu(n){return n.y}function Ku(n,t,e){n.y0=t,n.y=e}function Qu(n){return Xo.range(n.length)}function ni(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function ti(n){for(var t,e=1,r=0,u=n[0][1],i=n.length;i>e;++e)(t=n[e][1])>u&&(r=e,u=t);return r}function ei(n){return n.reduce(ri,0)}function ri(n,t){return n+t[1]}function ui(n,t){return ii(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function ii(n,t){for(var e=-1,r=+n[0],u=(n[1]-r)/t,i=[];++e<=t;)i[e]=u*e+r;return i}function oi(n){return[Xo.min(n),Xo.max(n)]}function ai(n,t){return n.parent==t.parent?1:2}function ci(n){var t=n.children;return t&&t.length?t[0]:n._tree.thread}function si(n){var t,e=n.children;return e&&(t=e.length)?e[t-1]:n._tree.thread}function li(n,t){var e=n.children;if(e&&(u=e.length))for(var r,u,i=-1;++i<u;)t(r=li(e[i],t),n)>0&&(n=r);return n}function fi(n,t){return n.x-t.x}function hi(n,t){return t.x-n.x}function gi(n,t){return n.depth-t.depth}function pi(n,t){function e(n,r){var u=n.children;if(u&&(o=u.length))for(var i,o,a=null,c=-1;++c<o;)i=u[c],e(i,a),a=i;t(n,r)}e(n,null)}function vi(n){for(var t,e=0,r=0,u=n.children,i=u.length;--i>=0;)t=u[i]._tree,t.prelim+=e,t.mod+=e,e+=t.shift+(r+=t.change)}function di(n,t,e){n=n._tree,t=t._tree;var r=e/(t.number-n.number);n.change+=r,t.change-=r,t.shift+=e,t.prelim+=e,t.mod+=e}function mi(n,t,e){return n._tree.ancestor.parent==t.parent?n._tree.ancestor:e}function yi(n,t){return n.value-t.value}function xi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Mi(n,t){n._pack_next=t,t._pack_prev=n}function _i(n,t){var e=t.x-n.x,r=t.y-n.y,u=n.r+t.r;return.999*u*u>e*e+r*r}function bi(n){function t(n){l=Math.min(n.x-n.r,l),f=Math.max(n.x+n.r,f),h=Math.min(n.y-n.r,h),g=Math.max(n.y+n.r,g)}if((e=n.children)&&(s=e.length)){var e,r,u,i,o,a,c,s,l=1/0,f=-1/0,h=1/0,g=-1/0;if(e.forEach(wi),r=e[0],r.x=-r.r,r.y=0,t(r),s>1&&(u=e[1],u.x=u.r,u.y=0,t(u),s>2))for(i=e[2],Ei(r,u,i),t(i),xi(r,i),r._pack_prev=i,xi(i,u),u=r._pack_next,o=3;s>o;o++){Ei(r,u,i=e[o]);var p=0,v=1,d=1;for(a=u._pack_next;a!==u;a=a._pack_next,v++)if(_i(a,i)){p=1;break}if(1==p)for(c=r._pack_prev;c!==a._pack_prev&&!_i(c,i);c=c._pack_prev,d++);p?(d>v||v==d&&u.r<r.r?Mi(r,u=a):Mi(r=c,u),o--):(xi(r,i),u=i,t(i))}var m=(l+f)/2,y=(h+g)/2,x=0;for(o=0;s>o;o++)i=e[o],i.x-=m,i.y-=y,x=Math.max(x,i.r+Math.sqrt(i.x*i.x+i.y*i.y));n.r=x,e.forEach(Si)}}function wi(n){n._pack_next=n._pack_prev=n}function Si(n){delete n._pack_next,delete n._pack_prev}function ki(n,t,e,r){var u=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,u)for(var i=-1,o=u.length;++i<o;)ki(u[i],t,e,r)}function Ei(n,t,e){var r=n.r+e.r,u=t.x-n.x,i=t.y-n.y;if(r&&(u||i)){var o=t.r+e.r,a=u*u+i*i;o*=o,r*=r;var c=.5+(r-o)/(2*a),s=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+c*u+s*i,e.y=n.y+c*i-s*u}else e.x=n.x+r,e.y=n.y}function Ai(n){return 1+Xo.max(n,function(n){return n.y})}function Ci(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Ni(n){var t=n.children;return t&&t.length?Ni(t[0]):n}function Li(n){var t,e=n.children;return e&&(t=e.length)?Li(e[t-1]):n}function zi(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function qi(n,t){var e=n.x+t[3],r=n.y+t[0],u=n.dx-t[1]-t[3],i=n.dy-t[0]-t[2];return 0>u&&(e+=u/2,u=0),0>i&&(r+=i/2,i=0),{x:e,y:r,dx:u,dy:i}}function Ti(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Ri(n){return n.rangeExtent?n.rangeExtent():Ti(n.range())}function Di(n,t,e,r){var u=e(n[0],n[1]),i=r(t[0],t[1]);return function(n){return i(u(n))}}function Pi(n,t){var e,r=0,u=n.length-1,i=n[r],o=n[u];return i>o&&(e=r,r=u,u=e,e=i,i=o,o=e),n[r]=t.floor(i),n[u]=t.ceil(o),n}function Ui(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:ls}function ji(n,t,e,r){var u=[],i=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)u.push(e(n[o-1],n[o])),i.push(r(t[o-1],t[o]));return function(t){var e=Xo.bisect(n,t,1,a)-1;return i[e](u[e](t))}}function Hi(n,t,e,r){function u(){var u=Math.min(n.length,t.length)>2?ji:Di,c=r?Pu:Du;return o=u(n,t,c,e),a=u(t,n,c,fu),i}function i(n){return o(n)}var o,a;return i.invert=function(n){return a(n)},i.domain=function(t){return arguments.length?(n=t.map(Number),u()):n},i.range=function(n){return arguments.length?(t=n,u()):t},i.rangeRound=function(n){return i.range(n).interpolate(Nu)},i.clamp=function(n){return arguments.length?(r=n,u()):r},i.interpolate=function(n){return arguments.length?(e=n,u()):e},i.ticks=function(t){return Ii(n,t)},i.tickFormat=function(t,e){return Zi(n,t,e)},i.nice=function(t){return Oi(n,t),u()},i.copy=function(){return Hi(n,t,e,r)},u()}function Fi(n,t){return Xo.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Oi(n,t){return Pi(n,Ui(Yi(n,t)[2]))}function Yi(n,t){null==t&&(t=10);var e=Ti(n),r=e[1]-e[0],u=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),i=t/r*u;return.15>=i?u*=10:.35>=i?u*=5:.75>=i&&(u*=2),e[0]=Math.ceil(e[0]/u)*u,e[1]=Math.floor(e[1]/u)*u+.5*u,e[2]=u,e}function Ii(n,t){return Xo.range.apply(Xo,Yi(n,t))}function Zi(n,t,e){var r=Yi(n,t);return Xo.format(e?e.replace(Qa,function(n,t,e,u,i,o,a,c,s,l){return[t,e,u,i,o,a,c,s||"."+Xi(l,r),l].join("")}):",."+Vi(r[2])+"f")}function Vi(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function Xi(n,t){var e=Vi(t[2]);return n in fs?Math.abs(e-Vi(Math.max(Math.abs(t[0]),Math.abs(t[1]))))+ +("e"!==n):e-2*("%"===n)}function $i(n,t,e,r){function u(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function i(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(u(t))}return o.invert=function(t){return i(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(u)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(u)),o):t},o.nice=function(){var t=Pi(r.map(u),e?Math:gs);return n.domain(t),r=t.map(i),o},o.ticks=function(){var n=Ti(r),o=[],a=n[0],c=n[1],s=Math.floor(u(a)),l=Math.ceil(u(c)),f=t%1?2:t;if(isFinite(l-s)){if(e){for(;l>s;s++)for(var h=1;f>h;h++)o.push(i(s)*h);o.push(i(s))}else for(o.push(i(s));s++<l;)for(var h=f-1;h>0;h--)o.push(i(s)*h);for(s=0;o[s]<a;s++);for(l=o.length;o[l-1]>c;l--);o=o.slice(s,l)}return o},o.tickFormat=function(n,t){if(!arguments.length)return hs;arguments.length<2?t=hs:"function"!=typeof t&&(t=Xo.format(t));var r,a=Math.max(.1,n/o.ticks().length),c=e?(r=1e-12,Math.ceil):(r=-1e-12,Math.floor);return function(n){return n/i(c(u(n)+r))<=a?t(n):""}},o.copy=function(){return $i(n.copy(),t,e,r)},Fi(o,n)}function Bi(n,t,e){function r(t){return n(u(t))}var u=Wi(t),i=Wi(1/t);return r.invert=function(t){return i(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(u)),r):e},r.ticks=function(n){return Ii(e,n)},r.tickFormat=function(n,t){return Zi(e,n,t)},r.nice=function(n){return r.domain(Oi(e,n))},r.exponent=function(o){return arguments.length?(u=Wi(t=o),i=Wi(1/t),n.domain(e.map(u)),r):t},r.copy=function(){return Bi(n.copy(),t,e)},Fi(r,n)}function Wi(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function Ji(n,t){function e(e){return o[((i.get(e)||"range"===t.t&&i.set(e,n.push(e)))-1)%o.length]}function r(t,e){return Xo.range(n.length).map(function(n){return t+e*n})}var i,o,a;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new u;for(var o,a=-1,c=r.length;++a<c;)i.has(o=r[a])||i.set(o,n.push(o));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(o=n,a=0,t={t:"range",a:arguments},e):o},e.rangePoints=function(u,i){arguments.length<2&&(i=0);var c=u[0],s=u[1],l=(s-c)/(Math.max(1,n.length-1)+i);return o=r(n.length<2?(c+s)/2:c+l*i/2,l),a=0,t={t:"rangePoints",a:arguments},e},e.rangeBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var s=u[1]<u[0],l=u[s-0],f=u[1-s],h=(f-l)/(n.length-i+2*c);return o=r(l+h*c,h),s&&o.reverse(),a=h*(1-i),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var s=u[1]<u[0],l=u[s-0],f=u[1-s],h=Math.floor((f-l)/(n.length-i+2*c)),g=f-l-(n.length-i)*h;return o=r(l+Math.round(g/2),h),s&&o.reverse(),a=Math.round(h*(1-i)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return a},e.rangeExtent=function(){return Ti(t.a[0])},e.copy=function(){return Ji(n,t)},e.domain(n)}function Gi(n,t){function e(){var e=0,i=t.length;for(u=[];++e<i;)u[e-1]=Xo.quantile(n,e/i);return r}function r(n){return isNaN(n=+n)?void 0:t[Xo.bisect(u,n)]}var u;return r.domain=function(t){return arguments.length?(n=t.filter(function(n){return!isNaN(n)}).sort(Xo.ascending),e()):n},r.range=function(n){return arguments.length?(t=n,e()):t},r.quantiles=function(){return u},r.invertExtent=function(e){return e=t.indexOf(e),0>e?[0/0,0/0]:[e>0?u[e-1]:n[0],e<u.length?u[e]:n[n.length-1]]},r.copy=function(){return Gi(n,t)},e()}function Ki(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(i*(t-n))))]}function u(){return i=e.length/(t-n),o=e.length-1,r}var i,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],u()):[n,t]},r.range=function(n){return arguments.length?(e=n,u()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?0/0:t/i+n,[t,t+1/i]},r.copy=function(){return Ki(n,t,e)},u()}function Qi(n,t){function e(e){return e>=e?t[Xo.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return Qi(n,t)},e}function no(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Ii(n,t)},t.tickFormat=function(t,e){return Zi(n,t,e)},t.copy=function(){return no(n)},t}function to(n){return n.innerRadius}function eo(n){return n.outerRadius}function ro(n){return n.startAngle}function uo(n){return n.endAngle}function io(n){function t(t){function o(){s.push("M",i(n(l),a))}for(var c,s=[],l=[],f=-1,h=t.length,g=_t(e),p=_t(r);++f<h;)u.call(this,c=t[f],f)?l.push([+g.call(this,c,f),+p.call(this,c,f)]):l.length&&(o(),l=[]);return l.length&&o(),s.length?s.join(""):null}var e=br,r=wr,u=be,i=oo,o=i.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(u=n,t):u},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?i=n:(i=Ms.get(n)||oo).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function oo(n){return n.join("L")}function ao(n){return oo(n)+"Z"}function co(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&u.push("H",r[0]),u.join("")}function so(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("V",(r=n[t])[1],"H",r[0]);return u.join("")}function lo(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r=n[t])[0],"V",r[1]);return u.join("")}function fo(n,t){return n.length<4?oo(n):n[1]+po(n.slice(1,n.length-1),vo(n,t))}function ho(n,t){return n.length<3?oo(n):n[0]+po((n.push(n[0]),n),vo([n[n.length-2]].concat(n,[n[1]]),t))}function go(n,t){return n.length<3?oo(n):n[0]+po(n,vo(n,t))}function po(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return oo(n);var e=n.length!=t.length,r="",u=n[0],i=n[1],o=t[0],a=o,c=1;if(e&&(r+="Q"+(i[0]-2*o[0]/3)+","+(i[1]-2*o[1]/3)+","+i[0]+","+i[1],u=n[1],c=2),t.length>1){a=t[1],i=n[c],c++,r+="C"+(u[0]+o[0])+","+(u[1]+o[1])+","+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1];for(var s=2;s<t.length;s++,c++)i=n[c],a=t[s],r+="S"+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1]}if(e){var l=n[c];r+="Q"+(i[0]+2*a[0]/3)+","+(i[1]+2*a[1]/3)+","+l[0]+","+l[1]}return r}function vo(n,t){for(var e,r=[],u=(1-t)/2,i=n[0],o=n[1],a=1,c=n.length;++a<c;)e=i,i=o,o=n[a],r.push([u*(o[0]-e[0]),u*(o[1]-e[1])]);return r}function mo(n){if(n.length<3)return oo(n);var t=1,e=n.length,r=n[0],u=r[0],i=r[1],o=[u,u,u,(r=n[1])[0]],a=[i,i,i,r[1]],c=[u,",",i,"L",_o(ws,o),",",_o(ws,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),bo(c,o,a);return n.pop(),c.push("L",r),c.join("")}function yo(n){if(n.length<4)return oo(n);for(var t,e=[],r=-1,u=n.length,i=[0],o=[0];++r<3;)t=n[r],i.push(t[0]),o.push(t[1]);for(e.push(_o(ws,i)+","+_o(ws,o)),--r;++r<u;)t=n[r],i.shift(),i.push(t[0]),o.shift(),o.push(t[1]),bo(e,i,o);return e.join("")}function xo(n){for(var t,e,r=-1,u=n.length,i=u+4,o=[],a=[];++r<4;)e=n[r%u],o.push(e[0]),a.push(e[1]);for(t=[_o(ws,o),",",_o(ws,a)],--r;++r<i;)e=n[r%u],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),bo(t,o,a);return t.join("")}function Mo(n,t){var e=n.length-1;if(e)for(var r,u,i=n[0][0],o=n[0][1],a=n[e][0]-i,c=n[e][1]-o,s=-1;++s<=e;)r=n[s],u=s/e,r[0]=t*r[0]+(1-t)*(i+u*a),r[1]=t*r[1]+(1-t)*(o+u*c);return mo(n)}function _o(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function bo(n,t,e){n.push("C",_o(_s,t),",",_o(_s,e),",",_o(bs,t),",",_o(bs,e),",",_o(ws,t),",",_o(ws,e))}function wo(n,t){return(t[1]-n[1])/(t[0]-n[0])}function So(n){for(var t=0,e=n.length-1,r=[],u=n[0],i=n[1],o=r[0]=wo(u,i);++t<e;)r[t]=(o+(o=wo(u=i,i=n[t+1])))/2;return r[t]=o,r}function ko(n){for(var t,e,r,u,i=[],o=So(n),a=-1,c=n.length-1;++a<c;)t=wo(n[a],n[a+1]),oa(t)<Aa?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,u=e*e+r*r,u>9&&(u=3*t/Math.sqrt(u),o[a]=u*e,o[a+1]=u*r));for(a=-1;++a<=c;)u=(n[Math.min(c,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),i.push([u||0,o[a]*u||0]);return i}function Eo(n){return n.length<3?oo(n):n[0]+po(n,ko(n))}function Ao(n){for(var t,e,r,u=-1,i=n.length;++u<i;)t=n[u],e=t[0],r=t[1]+ys,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Co(n){function t(t){function c(){v.push("M",a(n(m),f),l,s(n(d.reverse()),f),"Z")}for(var h,g,p,v=[],d=[],m=[],y=-1,x=t.length,M=_t(e),_=_t(u),b=e===r?function(){return g}:_t(r),w=u===i?function(){return p}:_t(i);++y<x;)o.call(this,h=t[y],y)?(d.push([g=+M.call(this,h,y),p=+_.call(this,h,y)]),m.push([+b.call(this,h,y),+w.call(this,h,y)])):d.length&&(c(),d=[],m=[]);return d.length&&c(),v.length?v.join(""):null}var e=br,r=br,u=0,i=wr,o=be,a=oo,c=a.key,s=a,l="L",f=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(u=i=n,t):i},t.y0=function(n){return arguments.length?(u=n,t):u},t.y1=function(n){return arguments.length?(i=n,t):i},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(c="function"==typeof n?a=n:(a=Ms.get(n)||oo).key,s=a.reverse||a,l=a.closed?"M":"L",t):c},t.tension=function(n){return arguments.length?(f=n,t):f},t}function No(n){return n.radius}function Lo(n){return[n.x,n.y]}function zo(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]+ys;return[e*Math.cos(r),e*Math.sin(r)]}}function qo(){return 64}function To(){return"circle"}function Ro(n){var t=Math.sqrt(n/Sa);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Do(n,t){return fa(n,Ns),n.id=t,n}function Po(n,t,e,r){var u=n.id;return R(n,"function"==typeof e?function(n,i,o){n.__transition__[u].tween.set(t,r(e.call(n,n.__data__,i,o)))}:(e=r(e),function(n){n.__transition__[u].tween.set(t,e)}))}function Uo(n){return null==n&&(n=""),function(){this.textContent=n}}function jo(n,t,e,r){var i=n.__transition__||(n.__transition__={active:0,count:0}),o=i[e];if(!o){var a=r.time;o=i[e]={tween:new u,time:a,ease:r.ease,delay:r.delay,duration:r.duration},++i.count,Xo.timer(function(r){function u(r){return i.active>e?s():(i.active=e,o.event&&o.event.start.call(n,l,t),o.tween.forEach(function(e,r){(r=r.call(n,l,t))&&v.push(r)}),Xo.timer(function(){return p.c=c(r||1)?be:c,1},0,a),void 0)}function c(r){if(i.active!==e)return s();for(var u=r/g,a=f(u),c=v.length;c>0;)v[--c].call(n,a);return u>=1?(o.event&&o.event.end.call(n,l,t),s()):void 0}function s(){return--i.count?delete i[e]:delete n.__transition__,1}var l=n.__data__,f=o.ease,h=o.delay,g=o.duration,p=Ja,v=[];return p.t=h+a,r>=h?u(r-h):(p.c=u,void 0)},0,a)}}function Ho(n,t){n.attr("transform",function(n){return"translate("+t(n)+",0)"})}function Fo(n,t){n.attr("transform",function(n){return"translate(0,"+t(n)+")"})}function Oo(n){return n.toISOString()}function Yo(n,t,e){function r(t){return n(t)}function u(n,e){var r=n[1]-n[0],u=r/e,i=Xo.bisect(js,u);return i==js.length?[t.year,Yi(n.map(function(n){return n/31536e6}),e)[2]]:i?t[u/js[i-1]<js[i]/u?i-1:i]:[Os,Yi(n,e)[2]]
+}return r.invert=function(t){return Io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(Io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,Io(+e+1),t).length}var i=r.domain(),o=Ti(i),a=null==n?u(o,10):"number"==typeof n&&u(o,n);return a&&(n=a[0],t=a[1]),r.domain(Pi(i,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=Io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=Io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Ti(r.domain()),i=null==n?u(e,10):"number"==typeof n?u(e,n):!n.range&&[{range:n},t];return i&&(n=i[0],t=i[1]),n.range(e[0],Io(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return Yo(n.copy(),t,e)},Fi(r,n)}function Io(n){return new Date(n)}function Zo(n){return JSON.parse(n.responseText)}function Vo(n){var t=Wo.createRange();return t.selectNode(Wo.body),t.createContextualFragment(n.responseText)}var Xo={version:"3.4.2"};Date.now||(Date.now=function(){return+new Date});var $o=[].slice,Bo=function(n){return $o.call(n)},Wo=document,Jo=Wo.documentElement,Go=window;try{Bo(Jo.childNodes)[0].nodeType}catch(Ko){Bo=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}try{Wo.createElement("div").style.setProperty("opacity",0,"")}catch(Qo){var na=Go.Element.prototype,ta=na.setAttribute,ea=na.setAttributeNS,ra=Go.CSSStyleDeclaration.prototype,ua=ra.setProperty;na.setAttribute=function(n,t){ta.call(this,n,t+"")},na.setAttributeNS=function(n,t,e){ea.call(this,n,t,e+"")},ra.setProperty=function(n,t,e){ua.call(this,n,t+"",e)}}Xo.ascending=function(n,t){return t>n?-1:n>t?1:n>=t?0:0/0},Xo.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:0/0},Xo.min=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i&&!(null!=(e=n[u])&&e>=e);)e=void 0;for(;++u<i;)null!=(r=n[u])&&e>r&&(e=r)}else{for(;++u<i&&!(null!=(e=t.call(n,n[u],u))&&e>=e);)e=void 0;for(;++u<i;)null!=(r=t.call(n,n[u],u))&&e>r&&(e=r)}return e},Xo.max=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i&&!(null!=(e=n[u])&&e>=e);)e=void 0;for(;++u<i;)null!=(r=n[u])&&r>e&&(e=r)}else{for(;++u<i&&!(null!=(e=t.call(n,n[u],u))&&e>=e);)e=void 0;for(;++u<i;)null!=(r=t.call(n,n[u],u))&&r>e&&(e=r)}return e},Xo.extent=function(n,t){var e,r,u,i=-1,o=n.length;if(1===arguments.length){for(;++i<o&&!(null!=(e=u=n[i])&&e>=e);)e=u=void 0;for(;++i<o;)null!=(r=n[i])&&(e>r&&(e=r),r>u&&(u=r))}else{for(;++i<o&&!(null!=(e=u=t.call(n,n[i],i))&&e>=e);)e=void 0;for(;++i<o;)null!=(r=t.call(n,n[i],i))&&(e>r&&(e=r),r>u&&(u=r))}return[e,u]},Xo.sum=function(n,t){var e,r=0,u=n.length,i=-1;if(1===arguments.length)for(;++i<u;)isNaN(e=+n[i])||(r+=e);else for(;++i<u;)isNaN(e=+t.call(n,n[i],i))||(r+=e);return r},Xo.mean=function(t,e){var r,u=t.length,i=0,o=-1,a=0;if(1===arguments.length)for(;++o<u;)n(r=t[o])&&(i+=(r-i)/++a);else for(;++o<u;)n(r=e.call(t,t[o],o))&&(i+=(r-i)/++a);return a?i:void 0},Xo.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),u=+n[r-1],i=e-r;return i?u+i*(n[r]-u):u},Xo.median=function(t,e){return arguments.length>1&&(t=t.map(e)),t=t.filter(n),t.length?Xo.quantile(t.sort(Xo.ascending),.5):void 0},Xo.bisector=function(n){return{left:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;n.call(t,t[i],i)<e?r=i+1:u=i}return r},right:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;e<n.call(t,t[i],i)?u=i:r=i+1}return r}}};var ia=Xo.bisector(function(n){return n});Xo.bisectLeft=ia.left,Xo.bisect=Xo.bisectRight=ia.right,Xo.shuffle=function(n){for(var t,e,r=n.length;r;)e=0|Math.random()*r--,t=n[r],n[r]=n[e],n[e]=t;return n},Xo.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},Xo.pairs=function(n){for(var t,e=0,r=n.length-1,u=n[0],i=new Array(0>r?0:r);r>e;)i[e]=[t=u,u=n[++e]];return i},Xo.zip=function(){if(!(u=arguments.length))return[];for(var n=-1,e=Xo.min(arguments,t),r=new Array(e);++n<e;)for(var u,i=-1,o=r[n]=new Array(u);++i<u;)o[i]=arguments[i][n];return r},Xo.transpose=function(n){return Xo.zip.apply(Xo,n)},Xo.keys=function(n){var t=[];for(var e in n)t.push(e);return t},Xo.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},Xo.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},Xo.merge=function(n){for(var t,e,r,u=n.length,i=-1,o=0;++i<u;)o+=n[i].length;for(e=new Array(o);--u>=0;)for(r=n[u],t=r.length;--t>=0;)e[--o]=r[t];return e};var oa=Math.abs;Xo.range=function(n,t,r){if(arguments.length<3&&(r=1,arguments.length<2&&(t=n,n=0)),1/0===(t-n)/r)throw new Error("infinite range");var u,i=[],o=e(oa(r)),a=-1;if(n*=o,t*=o,r*=o,0>r)for(;(u=n+r*++a)>t;)i.push(u/o);else for(;(u=n+r*++a)<t;)i.push(u/o);return i},Xo.map=function(n){var t=new u;if(n instanceof u)n.forEach(function(n,e){t.set(n,e)});else for(var e in n)t.set(e,n[e]);return t},r(u,{has:i,get:function(n){return this[aa+n]},set:function(n,t){return this[aa+n]=t},remove:o,keys:a,values:function(){var n=[];return this.forEach(function(t,e){n.push(e)}),n},entries:function(){var n=[];return this.forEach(function(t,e){n.push({key:t,value:e})}),n},size:c,empty:s,forEach:function(n){for(var t in this)t.charCodeAt(0)===ca&&n.call(this,t.substring(1),this[t])}});var aa="\x00",ca=aa.charCodeAt(0);Xo.nest=function(){function n(t,a,c){if(c>=o.length)return r?r.call(i,a):e?a.sort(e):a;for(var s,l,f,h,g=-1,p=a.length,v=o[c++],d=new u;++g<p;)(h=d.get(s=v(l=a[g])))?h.push(l):d.set(s,[l]);return t?(l=t(),f=function(e,r){l.set(e,n(t,r,c))}):(l={},f=function(e,r){l[e]=n(t,r,c)}),d.forEach(f),l}function t(n,e){if(e>=o.length)return n;var r=[],u=a[e++];return n.forEach(function(n,u){r.push({key:n,values:t(u,e)})}),u?r.sort(function(n,t){return u(n.key,t.key)}):r}var e,r,i={},o=[],a=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(Xo.map,e,0),0)},i.key=function(n){return o.push(n),i},i.sortKeys=function(n){return a[o.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},Xo.set=function(n){var t=new l;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},r(l,{has:i,add:function(n){return this[aa+n]=!0,n},remove:function(n){return n=aa+n,n in this&&delete this[n]},values:a,size:c,empty:s,forEach:function(n){for(var t in this)t.charCodeAt(0)===ca&&n.call(this,t.substring(1))}}),Xo.behavior={},Xo.rebind=function(n,t){for(var e,r=1,u=arguments.length;++r<u;)n[e=arguments[r]]=f(n,t,t[e]);return n};var sa=["webkit","ms","moz","Moz","o","O"];Xo.dispatch=function(){for(var n=new p,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=v(n);return n},p.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.substring(e+1),n=n.substring(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},Xo.event=null,Xo.requote=function(n){return n.replace(la,"\\$&")};var la=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,fa={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},ha=function(n,t){return t.querySelector(n)},ga=function(n,t){return t.querySelectorAll(n)},pa=Jo[h(Jo,"matchesSelector")],va=function(n,t){return pa.call(n,t)};"function"==typeof Sizzle&&(ha=function(n,t){return Sizzle(n,t)[0]||null},ga=function(n,t){return Sizzle.uniqueSort(Sizzle(n,t))},va=Sizzle.matchesSelector),Xo.selection=function(){return xa};var da=Xo.selection.prototype=[];da.select=function(n){var t,e,r,u,i=[];n=M(n);for(var o=-1,a=this.length;++o<a;){i.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var c=-1,s=r.length;++c<s;)(u=r[c])?(t.push(e=n.call(u,u.__data__,c,o)),e&&"__data__"in u&&(e.__data__=u.__data__)):t.push(null)}return x(i)},da.selectAll=function(n){var t,e,r=[];n=_(n);for(var u=-1,i=this.length;++u<i;)for(var o=this[u],a=-1,c=o.length;++a<c;)(e=o[a])&&(r.push(t=Bo(n.call(e,e.__data__,a,u))),t.parentNode=e);return x(r)};var ma={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};Xo.ns={prefix:ma,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&(e=n.substring(0,t),n=n.substring(t+1)),ma.hasOwnProperty(e)?{space:ma[e],local:n}:n}},da.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=Xo.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(b(t,n[t]));return this}return this.each(b(n,t))},da.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=k(n)).length,u=-1;if(t=e.classList){for(;++u<r;)if(!t.contains(n[u]))return!1}else for(t=e.getAttribute("class");++u<r;)if(!S(n[u]).test(t))return!1;return!0}for(t in n)this.each(E(t,n[t]));return this}return this.each(E(n,t))},da.style=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t="");for(e in n)this.each(C(e,n[e],t));return this}if(2>r)return Go.getComputedStyle(this.node(),null).getPropertyValue(n);e=""}return this.each(C(n,t,e))},da.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(N(t,n[t]));return this}return this.each(N(n,t))},da.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},da.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},da.append=function(n){return n=L(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},da.insert=function(n,t){return n=L(n),t=M(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},da.remove=function(){return this.each(function(){var n=this.parentNode;n&&n.removeChild(this)})},da.data=function(n,t){function e(n,e){var r,i,o,a=n.length,f=e.length,h=Math.min(a,f),g=new Array(f),p=new Array(f),v=new Array(a);if(t){var d,m=new u,y=new u,x=[];for(r=-1;++r<a;)d=t.call(i=n[r],i.__data__,r),m.has(d)?v[r]=i:m.set(d,i),x.push(d);for(r=-1;++r<f;)d=t.call(e,o=e[r],r),(i=m.get(d))?(g[r]=i,i.__data__=o):y.has(d)||(p[r]=z(o)),y.set(d,o),m.remove(d);for(r=-1;++r<a;)m.has(x[r])&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],o=e[r],i?(i.__data__=o,g[r]=i):p[r]=z(o);for(;f>r;++r)p[r]=z(e[r]);for(;a>r;++r)v[r]=n[r]}p.update=g,p.parentNode=g.parentNode=v.parentNode=n.parentNode,c.push(p),s.push(g),l.push(v)}var r,i,o=-1,a=this.length;if(!arguments.length){for(n=new Array(a=(r=this[0]).length);++o<a;)(i=r[o])&&(n[o]=i.__data__);return n}var c=D([]),s=x([]),l=x([]);if("function"==typeof n)for(;++o<a;)e(r=this[o],n.call(r,r.parentNode.__data__,o));else for(;++o<a;)e(r=this[o],n);return s.enter=function(){return c},s.exit=function(){return l},s},da.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},da.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=q(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]),t.parentNode=(e=this[i]).parentNode;for(var a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return x(u)},da.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],u=r.length-1,i=r[u];--u>=0;)(e=r[u])&&(i&&i!==e.nextSibling&&i.parentNode.insertBefore(e,i),i=e);return this},da.sort=function(n){n=T.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},da.each=function(n){return R(this,function(t,e,r){n.call(t,t.__data__,e,r)})},da.call=function(n){var t=Bo(arguments);return n.apply(t[0]=this,t),this},da.empty=function(){return!this.node()},da.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,u=e.length;u>r;r++){var i=e[r];if(i)return i}return null},da.size=function(){var n=0;return this.each(function(){++n}),n};var ya=[];Xo.selection.enter=D,Xo.selection.enter.prototype=ya,ya.append=da.append,ya.empty=da.empty,ya.node=da.node,ya.call=da.call,ya.size=da.size,ya.select=function(n){for(var t,e,r,u,i,o=[],a=-1,c=this.length;++a<c;){r=(u=this[a]).update,o.push(t=[]),t.parentNode=u.parentNode;for(var s=-1,l=u.length;++s<l;)(i=u[s])?(t.push(r[s]=e=n.call(u.parentNode,i.__data__,s,a)),e.__data__=i.__data__):t.push(null)}return x(o)},ya.insert=function(n,t){return arguments.length<2&&(t=P(this)),da.insert.call(this,n,t)},da.transition=function(){for(var n,t,e=ks||++Ls,r=[],u=Es||{time:Date.now(),ease:yu,delay:0,duration:250},i=-1,o=this.length;++i<o;){r.push(n=[]);for(var a=this[i],c=-1,s=a.length;++c<s;)(t=a[c])&&jo(t,c,e,u),n.push(t)}return Do(r,e)},da.interrupt=function(){return this.each(U)},Xo.select=function(n){var t=["string"==typeof n?ha(n,Wo):n];return t.parentNode=Jo,x([t])},Xo.selectAll=function(n){var t=Bo("string"==typeof n?ga(n,Wo):n);return t.parentNode=Jo,x([t])};var xa=Xo.select(Jo);da.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(j(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(j(n,t,e))};var Ma=Xo.map({mouseenter:"mouseover",mouseleave:"mouseout"});Ma.forEach(function(n){"on"+n in Wo&&Ma.remove(n)});var _a="onselectstart"in Wo?null:h(Jo.style,"userSelect"),ba=0;Xo.mouse=function(n){return Y(n,m())};var wa=/WebKit/.test(Go.navigator.userAgent)?-1:0;Xo.touches=function(n,t){return arguments.length<2&&(t=m().touches),t?Bo(t).map(function(t){var e=Y(n,t);return e.identifier=t.identifier,e}):[]},Xo.behavior.drag=function(){function n(){this.on("mousedown.drag",o).on("touchstart.drag",a)}function t(){return Xo.event.changedTouches[0].identifier}function e(n,t){return Xo.touches(n).filter(function(n){return n.identifier===t})[0]}function r(n,t,e,r){return function(){function o(){var n=t(l,g),e=n[0]-v[0],r=n[1]-v[1];d|=e|r,v=n,f({type:"drag",x:n[0]+c[0],y:n[1]+c[1],dx:e,dy:r})}function a(){m.on(e+"."+p,null).on(r+"."+p,null),y(d&&Xo.event.target===h),f({type:"dragend"})}var c,s=this,l=s.parentNode,f=u.of(s,arguments),h=Xo.event.target,g=n(),p=null==g?"drag":"drag-"+g,v=t(l,g),d=0,m=Xo.select(Go).on(e+"."+p,o).on(r+"."+p,a),y=O();i?(c=i.apply(s,arguments),c=[c.x-v[0],c.y-v[1]]):c=[0,0],f({type:"dragstart"})}}var u=y(n,"drag","dragstart","dragend"),i=null,o=r(g,Xo.mouse,"mousemove","mouseup"),a=r(t,e,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},Xo.rebind(n,u,"on")};var Sa=Math.PI,ka=2*Sa,Ea=Sa/2,Aa=1e-6,Ca=Aa*Aa,Na=Sa/180,La=180/Sa,za=Math.SQRT2,qa=2,Ta=4;Xo.interpolateZoom=function(n,t){function e(n){var t=n*y;if(m){var e=B(v),o=i/(qa*h)*(e*W(za*t+v)-$(v));return[r+o*s,u+o*l,i*e/B(za*t+v)]}return[r+n*s,u+n*l,i*Math.exp(za*t)]}var r=n[0],u=n[1],i=n[2],o=t[0],a=t[1],c=t[2],s=o-r,l=a-u,f=s*s+l*l,h=Math.sqrt(f),g=(c*c-i*i+Ta*f)/(2*i*qa*h),p=(c*c-i*i-Ta*f)/(2*c*qa*h),v=Math.log(Math.sqrt(g*g+1)-g),d=Math.log(Math.sqrt(p*p+1)-p),m=d-v,y=(m||Math.log(c/i))/za;return e.duration=1e3*y,e},Xo.behavior.zoom=function(){function n(n){n.on(A,s).on(Pa+".zoom",f).on(C,h).on("dblclick.zoom",g).on(L,l)}function t(n){return[(n[0]-S.x)/S.k,(n[1]-S.y)/S.k]}function e(n){return[n[0]*S.k+S.x,n[1]*S.k+S.y]}function r(n){S.k=Math.max(E[0],Math.min(E[1],n))}function u(n,t){t=e(t),S.x+=n[0]-t[0],S.y+=n[1]-t[1]}function i(){_&&_.domain(M.range().map(function(n){return(n-S.x)/S.k}).map(M.invert)),w&&w.domain(b.range().map(function(n){return(n-S.y)/S.k}).map(b.invert))}function o(n){n({type:"zoomstart"})}function a(n){i(),n({type:"zoom",scale:S.k,translate:[S.x,S.y]})}function c(n){n({type:"zoomend"})}function s(){function n(){l=1,u(Xo.mouse(r),g),a(i)}function e(){f.on(C,Go===r?h:null).on(N,null),p(l&&Xo.event.target===s),c(i)}var r=this,i=z.of(r,arguments),s=Xo.event.target,l=0,f=Xo.select(Go).on(C,n).on(N,e),g=t(Xo.mouse(r)),p=O();U.call(r),o(i)}function l(){function n(){var n=Xo.touches(g);return h=S.k,n.forEach(function(n){n.identifier in v&&(v[n.identifier]=t(n))}),n}function e(){for(var t=Xo.event.changedTouches,e=0,i=t.length;i>e;++e)v[t[e].identifier]=null;var o=n(),c=Date.now();if(1===o.length){if(500>c-x){var s=o[0],l=v[s.identifier];r(2*S.k),u(s,l),d(),a(p)}x=c}else if(o.length>1){var s=o[0],f=o[1],h=s[0]-f[0],g=s[1]-f[1];m=h*h+g*g}}function i(){for(var n,t,e,i,o=Xo.touches(g),c=0,s=o.length;s>c;++c,i=null)if(e=o[c],i=v[e.identifier]){if(t)break;n=e,t=i}if(i){var l=(l=e[0]-n[0])*l+(l=e[1]-n[1])*l,f=m&&Math.sqrt(l/m);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+i[0])/2,(t[1]+i[1])/2],r(f*h)}x=null,u(n,t),a(p)}function f(){if(Xo.event.touches.length){for(var t=Xo.event.changedTouches,e=0,r=t.length;r>e;++e)delete v[t[e].identifier];for(var u in v)return void n()}b.on(M,null).on(_,null),w.on(A,s).on(L,l),k(),c(p)}var h,g=this,p=z.of(g,arguments),v={},m=0,y=Xo.event.changedTouches[0].identifier,M="touchmove.zoom-"+y,_="touchend.zoom-"+y,b=Xo.select(Go).on(M,i).on(_,f),w=Xo.select(g).on(A,null).on(L,e),k=O();U.call(g),e(),o(p)}function f(){var n=z.of(this,arguments);m?clearTimeout(m):(U.call(this),o(n)),m=setTimeout(function(){m=null,c(n)},50),d();var e=v||Xo.mouse(this);p||(p=t(e)),r(Math.pow(2,.002*Ra())*S.k),u(e,p),a(n)}function h(){p=null}function g(){var n=z.of(this,arguments),e=Xo.mouse(this),i=t(e),s=Math.log(S.k)/Math.LN2;o(n),r(Math.pow(2,Xo.event.shiftKey?Math.ceil(s)-1:Math.floor(s)+1)),u(e,i),a(n),c(n)}var p,v,m,x,M,_,b,w,S={x:0,y:0,k:1},k=[960,500],E=Da,A="mousedown.zoom",C="mousemove.zoom",N="mouseup.zoom",L="touchstart.zoom",z=y(n,"zoomstart","zoom","zoomend");return n.event=function(n){n.each(function(){var n=z.of(this,arguments),t=S;ks?Xo.select(this).transition().each("start.zoom",function(){S=this.__chart__||{x:0,y:0,k:1},o(n)}).tween("zoom:zoom",function(){var e=k[0],r=k[1],u=e/2,i=r/2,o=Xo.interpolateZoom([(u-S.x)/S.k,(i-S.y)/S.k,e/S.k],[(u-t.x)/t.k,(i-t.y)/t.k,e/t.k]);return function(t){var r=o(t),c=e/r[2];this.__chart__=S={x:u-r[0]*c,y:i-r[1]*c,k:c},a(n)}}).each("end.zoom",function(){c(n)}):(this.__chart__=S,o(n),a(n),c(n))})},n.translate=function(t){return arguments.length?(S={x:+t[0],y:+t[1],k:S.k},i(),n):[S.x,S.y]},n.scale=function(t){return arguments.length?(S={x:S.x,y:S.y,k:+t},i(),n):S.k},n.scaleExtent=function(t){return arguments.length?(E=null==t?Da:[+t[0],+t[1]],n):E},n.center=function(t){return arguments.length?(v=t&&[+t[0],+t[1]],n):v},n.size=function(t){return arguments.length?(k=t&&[+t[0],+t[1]],n):k},n.x=function(t){return arguments.length?(_=t,M=t.copy(),S={x:0,y:0,k:1},n):_},n.y=function(t){return arguments.length?(w=t,b=t.copy(),S={x:0,y:0,k:1},n):w},Xo.rebind(n,z,"on")};var Ra,Da=[0,1/0],Pa="onwheel"in Wo?(Ra=function(){return-Xo.event.deltaY*(Xo.event.deltaMode?120:1)},"wheel"):"onmousewheel"in Wo?(Ra=function(){return Xo.event.wheelDelta},"mousewheel"):(Ra=function(){return-Xo.event.detail},"MozMousePixelScroll");G.prototype.toString=function(){return this.rgb()+""},Xo.hsl=function(n,t,e){return 1===arguments.length?n instanceof Q?K(n.h,n.s,n.l):dt(""+n,mt,K):K(+n,+t,+e)};var Ua=Q.prototype=new G;Ua.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),K(this.h,this.s,this.l/n)},Ua.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),K(this.h,this.s,n*this.l)},Ua.rgb=function(){return nt(this.h,this.s,this.l)},Xo.hcl=function(n,t,e){return 1===arguments.length?n instanceof et?tt(n.h,n.c,n.l):n instanceof it?at(n.l,n.a,n.b):at((n=yt((n=Xo.rgb(n)).r,n.g,n.b)).l,n.a,n.b):tt(+n,+t,+e)};var ja=et.prototype=new G;ja.brighter=function(n){return tt(this.h,this.c,Math.min(100,this.l+Ha*(arguments.length?n:1)))},ja.darker=function(n){return tt(this.h,this.c,Math.max(0,this.l-Ha*(arguments.length?n:1)))},ja.rgb=function(){return rt(this.h,this.c,this.l).rgb()},Xo.lab=function(n,t,e){return 1===arguments.length?n instanceof it?ut(n.l,n.a,n.b):n instanceof et?rt(n.l,n.c,n.h):yt((n=Xo.rgb(n)).r,n.g,n.b):ut(+n,+t,+e)};var Ha=18,Fa=.95047,Oa=1,Ya=1.08883,Ia=it.prototype=new G;Ia.brighter=function(n){return ut(Math.min(100,this.l+Ha*(arguments.length?n:1)),this.a,this.b)},Ia.darker=function(n){return ut(Math.max(0,this.l-Ha*(arguments.length?n:1)),this.a,this.b)},Ia.rgb=function(){return ot(this.l,this.a,this.b)},Xo.rgb=function(n,t,e){return 1===arguments.length?n instanceof pt?gt(n.r,n.g,n.b):dt(""+n,gt,nt):gt(~~n,~~t,~~e)};var Za=pt.prototype=new G;Za.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,u=30;return t||e||r?(t&&u>t&&(t=u),e&&u>e&&(e=u),r&&u>r&&(r=u),gt(Math.min(255,~~(t/n)),Math.min(255,~~(e/n)),Math.min(255,~~(r/n)))):gt(u,u,u)},Za.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),gt(~~(n*this.r),~~(n*this.g),~~(n*this.b))},Za.hsl=function(){return mt(this.r,this.g,this.b)},Za.toString=function(){return"#"+vt(this.r)+vt(this.g)+vt(this.b)};var Va=Xo.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});Va.forEach(function(n,t){Va.set(n,ft(t))}),Xo.functor=_t,Xo.xhr=wt(bt),Xo.dsv=function(n,t){function e(n,e,i){arguments.length<3&&(i=e,e=null);var o=St(n,t,null==e?r:u(e),i);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:u(n)):e},o}function r(n){return e.parse(n.responseText)}function u(n){return function(t){return e.parse(t.responseText,n)}}function i(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),c=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var u=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(u(n),e)}:u})},e.parseRows=function(n,t){function e(){if(l>=s)return o;if(u)return u=!1,i;var t=l;if(34===n.charCodeAt(t)){for(var e=t;e++<s;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}l=e+2;var r=n.charCodeAt(e+1);return 13===r?(u=!0,10===n.charCodeAt(e+2)&&++l):10===r&&(u=!0),n.substring(t+1,e).replace(/""/g,'"')}for(;s>l;){var r=n.charCodeAt(l++),a=1;if(10===r)u=!0;else if(13===r)u=!0,10===n.charCodeAt(l)&&(++l,++a);else if(r!==c)continue;return n.substring(t,l-a)}return n.substring(t)}for(var r,u,i={},o={},a=[],s=n.length,l=0,f=0;(r=e())!==o;){for(var h=[];r!==i&&r!==o;)h.push(r),r=e();(!t||(h=t(h,f++)))&&a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new l,u=[];return t.forEach(function(n){for(var t in n)r.has(t)||u.push(r.add(t))}),[u.map(o).join(n)].concat(t.map(function(t){return u.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(i).join("\n")},e},Xo.csv=Xo.dsv(",","text/csv"),Xo.tsv=Xo.dsv("	","text/tab-separated-values");var Xa,$a,Ba,Wa,Ja,Ga=Go[h(Go,"requestAnimationFrame")]||function(n){setTimeout(n,17)};Xo.timer=function(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var u=e+t,i={c:n,t:u,f:!1,n:null};$a?$a.n=i:Xa=i,$a=i,Ba||(Wa=clearTimeout(Wa),Ba=1,Ga(Et))},Xo.timer.flush=function(){At(),Ct()},Xo.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var Ka=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Lt);Xo.formatPrefix=function(n,t){var e=0;return n&&(0>n&&(n*=-1),t&&(n=Xo.round(n,Nt(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((0>=e?e+1:e-1)/3)))),Ka[8+e/3]};var Qa=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,nc=Xo.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=Xo.round(n,Nt(n,t))).toFixed(Math.max(0,Math.min(20,Nt(n*(1+1e-15),t))))}}),tc=Xo.time={},ec=Date;Tt.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){rc.setUTCDate.apply(this._,arguments)},setDay:function(){rc.setUTCDay.apply(this._,arguments)},setFullYear:function(){rc.setUTCFullYear.apply(this._,arguments)},setHours:function(){rc.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){rc.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){rc.setUTCMinutes.apply(this._,arguments)},setMonth:function(){rc.setUTCMonth.apply(this._,arguments)},setSeconds:function(){rc.setUTCSeconds.apply(this._,arguments)},setTime:function(){rc.setTime.apply(this._,arguments)}};var rc=Date.prototype;tc.year=Rt(function(n){return n=tc.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),tc.years=tc.year.range,tc.years.utc=tc.year.utc.range,tc.day=Rt(function(n){var t=new ec(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),tc.days=tc.day.range,tc.days.utc=tc.day.utc.range,tc.dayOfYear=function(n){var t=tc.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=tc[n]=Rt(function(n){return(n=tc.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=tc.year(n).getDay();return Math.floor((tc.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});tc[n+"s"]=e.range,tc[n+"s"].utc=e.utc.range,tc[n+"OfYear"]=function(n){var e=tc.year(n).getDay();return Math.floor((tc.dayOfYear(n)+(e+t)%7)/7)}}),tc.week=tc.sunday,tc.weeks=tc.sunday.range,tc.weeks.utc=tc.sunday.utc.range,tc.weekOfYear=tc.sundayOfYear;var uc={"-":"",_:" ",0:"0"},ic=/^\s*\d+/,oc=/^%/;Xo.locale=function(n){return{numberFormat:zt(n),timeFormat:Pt(n)}};var ac=Xo.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});Xo.format=ac.numberFormat,Xo.geo={},re.prototype={s:0,t:0,add:function(n){ue(n,this.t,cc),ue(cc.s,this.s,this),this.s?this.t+=cc.t:this.s=cc.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var cc=new re;Xo.geo.stream=function(n,t){n&&sc.hasOwnProperty(n.type)?sc[n.type](n,t):ie(n,t)};var sc={Feature:function(n,t){ie(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,u=e.length;++r<u;)ie(e[r].geometry,t)}},lc={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){oe(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)oe(e[r],t,0)},Polygon:function(n,t){ae(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)ae(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,u=e.length;++r<u;)ie(e[r],t)}};Xo.geo.area=function(n){return fc=0,Xo.geo.stream(n,gc),fc};var fc,hc=new re,gc={sphere:function(){fc+=4*Sa},point:g,lineStart:g,lineEnd:g,polygonStart:function(){hc.reset(),gc.lineStart=ce},polygonEnd:function(){var n=2*hc;fc+=0>n?4*Sa+n:n,gc.lineStart=gc.lineEnd=gc.point=g}};Xo.geo.bounds=function(){function n(n,t){x.push(M=[l=n,h=n]),f>t&&(f=t),t>g&&(g=t)}function t(t,e){var r=se([t*Na,e*Na]);if(m){var u=fe(m,r),i=[u[1],-u[0],0],o=fe(i,u);pe(o),o=ve(o);var c=t-p,s=c>0?1:-1,v=o[0]*La*s,d=oa(c)>180;if(d^(v>s*p&&s*t>v)){var y=o[1]*La;y>g&&(g=y)}else if(v=(v+360)%360-180,d^(v>s*p&&s*t>v)){var y=-o[1]*La;f>y&&(f=y)}else f>e&&(f=e),e>g&&(g=e);d?p>t?a(l,t)>a(l,h)&&(h=t):a(t,h)>a(l,h)&&(l=t):h>=l?(l>t&&(l=t),t>h&&(h=t)):t>p?a(l,t)>a(l,h)&&(h=t):a(t,h)>a(l,h)&&(l=t)}else n(t,e);m=r,p=t}function e(){_.point=t}function r(){M[0]=l,M[1]=h,_.point=n,m=null}function u(n,e){if(m){var r=n-p;y+=oa(r)>180?r+(r>0?360:-360):r}else v=n,d=e;gc.point(n,e),t(n,e)}function i(){gc.lineStart()}function o(){u(v,d),gc.lineEnd(),oa(y)>Aa&&(l=-(h=180)),M[0]=l,M[1]=h,m=null}function a(n,t){return(t-=n)<0?t+360:t}function c(n,t){return n[0]-t[0]}function s(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var l,f,h,g,p,v,d,m,y,x,M,_={point:n,lineStart:e,lineEnd:r,polygonStart:function(){_.point=u,_.lineStart=i,_.lineEnd=o,y=0,gc.polygonStart()},polygonEnd:function(){gc.polygonEnd(),_.point=n,_.lineStart=e,_.lineEnd=r,0>hc?(l=-(h=180),f=-(g=90)):y>Aa?g=90:-Aa>y&&(f=-90),M[0]=l,M[1]=h
+}};return function(n){g=h=-(l=f=1/0),x=[],Xo.geo.stream(n,_);var t=x.length;if(t){x.sort(c);for(var e,r=1,u=x[0],i=[u];t>r;++r)e=x[r],s(e[0],u)||s(e[1],u)?(a(u[0],e[1])>a(u[0],u[1])&&(u[1]=e[1]),a(e[0],u[1])>a(u[0],u[1])&&(u[0]=e[0])):i.push(u=e);for(var o,e,p=-1/0,t=i.length-1,r=0,u=i[t];t>=r;u=e,++r)e=i[r],(o=a(u[1],e[0]))>p&&(p=o,l=e[0],h=u[1])}return x=M=null,1/0===l||1/0===f?[[0/0,0/0],[0/0,0/0]]:[[l,f],[h,g]]}}(),Xo.geo.centroid=function(n){pc=vc=dc=mc=yc=xc=Mc=_c=bc=wc=Sc=0,Xo.geo.stream(n,kc);var t=bc,e=wc,r=Sc,u=t*t+e*e+r*r;return Ca>u&&(t=xc,e=Mc,r=_c,Aa>vc&&(t=dc,e=mc,r=yc),u=t*t+e*e+r*r,Ca>u)?[0/0,0/0]:[Math.atan2(e,t)*La,X(r/Math.sqrt(u))*La]};var pc,vc,dc,mc,yc,xc,Mc,_c,bc,wc,Sc,kc={sphere:g,point:me,lineStart:xe,lineEnd:Me,polygonStart:function(){kc.lineStart=_e},polygonEnd:function(){kc.lineStart=xe}},Ec=Ee(be,ze,Te,[-Sa,-Sa/2]),Ac=1e9;Xo.geo.clipExtent=function(){var n,t,e,r,u,i,o={stream:function(n){return u&&(u.valid=!1),u=i(n),u.valid=!0,u},extent:function(a){return arguments.length?(i=Pe(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),u&&(u.valid=!1,u=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(Xo.geo.conicEqualArea=function(){return je(He)}).raw=He,Xo.geo.albers=function(){return Xo.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},Xo.geo.albersUsa=function(){function n(n){var i=n[0],o=n[1];return t=null,e(i,o),t||(r(i,o),t)||u(i,o),t}var t,e,r,u,i=Xo.geo.albers(),o=Xo.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=Xo.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),c={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=i.scale(),e=i.translate(),r=(n[0]-e[0])/t,u=(n[1]-e[1])/t;return(u>=.12&&.234>u&&r>=-.425&&-.214>r?o:u>=.166&&.234>u&&r>=-.214&&-.115>r?a:i).invert(n)},n.stream=function(n){var t=i.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,u){t.point(n,u),e.point(n,u),r.point(n,u)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(i.precision(t),o.precision(t),a.precision(t),n):i.precision()},n.scale=function(t){return arguments.length?(i.scale(t),o.scale(.35*t),a.scale(t),n.translate(i.translate())):i.scale()},n.translate=function(t){if(!arguments.length)return i.translate();var s=i.scale(),l=+t[0],f=+t[1];return e=i.translate(t).clipExtent([[l-.455*s,f-.238*s],[l+.455*s,f+.238*s]]).stream(c).point,r=o.translate([l-.307*s,f+.201*s]).clipExtent([[l-.425*s+Aa,f+.12*s+Aa],[l-.214*s-Aa,f+.234*s-Aa]]).stream(c).point,u=a.translate([l-.205*s,f+.212*s]).clipExtent([[l-.214*s+Aa,f+.166*s+Aa],[l-.115*s-Aa,f+.234*s-Aa]]).stream(c).point,n},n.scale(1070)};var Cc,Nc,Lc,zc,qc,Tc,Rc={point:g,lineStart:g,lineEnd:g,polygonStart:function(){Nc=0,Rc.lineStart=Fe},polygonEnd:function(){Rc.lineStart=Rc.lineEnd=Rc.point=g,Cc+=oa(Nc/2)}},Dc={point:Oe,lineStart:g,lineEnd:g,polygonStart:g,polygonEnd:g},Pc={point:Ze,lineStart:Ve,lineEnd:Xe,polygonStart:function(){Pc.lineStart=$e},polygonEnd:function(){Pc.point=Ze,Pc.lineStart=Ve,Pc.lineEnd=Xe}};Xo.geo.path=function(){function n(n){return n&&("function"==typeof a&&i.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=u(i)),Xo.geo.stream(n,o)),i.result()}function t(){return o=null,n}var e,r,u,i,o,a=4.5;return n.area=function(n){return Cc=0,Xo.geo.stream(n,u(Rc)),Cc},n.centroid=function(n){return dc=mc=yc=xc=Mc=_c=bc=wc=Sc=0,Xo.geo.stream(n,u(Pc)),Sc?[bc/Sc,wc/Sc]:_c?[xc/_c,Mc/_c]:yc?[dc/yc,mc/yc]:[0/0,0/0]},n.bounds=function(n){return qc=Tc=-(Lc=zc=1/0),Xo.geo.stream(n,u(Dc)),[[Lc,zc],[qc,Tc]]},n.projection=function(n){return arguments.length?(u=(e=n)?n.stream||Je(n):bt,t()):e},n.context=function(n){return arguments.length?(i=null==(r=n)?new Ye:new Be(n),"function"!=typeof a&&i.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(i.pointRadius(+t),+t),n):a},n.projection(Xo.geo.albersUsa()).context(null)},Xo.geo.transform=function(n){return{stream:function(t){var e=new Ge(t);for(var r in n)e[r]=n[r];return e}}},Ge.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},Xo.geo.projection=Qe,Xo.geo.projectionMutator=nr,(Xo.geo.equirectangular=function(){return Qe(er)}).raw=er.invert=er,Xo.geo.rotation=function(n){function t(t){return t=n(t[0]*Na,t[1]*Na),t[0]*=La,t[1]*=La,t}return n=ur(n[0]%360*Na,n[1]*Na,n.length>2?n[2]*Na:0),t.invert=function(t){return t=n.invert(t[0]*Na,t[1]*Na),t[0]*=La,t[1]*=La,t},t},rr.invert=er,Xo.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=ur(-n[0]*Na,-n[1]*Na,0).invert,u=[];return e(null,null,1,{point:function(n,e){u.push(n=t(n,e)),n[0]*=La,n[1]*=La}}),{type:"Polygon",coordinates:[u]}}var t,e,r=[0,0],u=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=cr((t=+r)*Na,u*Na),n):t},n.precision=function(r){return arguments.length?(e=cr(t*Na,(u=+r)*Na),n):u},n.angle(90)},Xo.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Na,u=n[1]*Na,i=t[1]*Na,o=Math.sin(r),a=Math.cos(r),c=Math.sin(u),s=Math.cos(u),l=Math.sin(i),f=Math.cos(i);return Math.atan2(Math.sqrt((e=f*o)*e+(e=s*l-c*f*a)*e),c*l+s*f*a)},Xo.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return Xo.range(Math.ceil(i/d)*d,u,d).map(h).concat(Xo.range(Math.ceil(s/m)*m,c,m).map(g)).concat(Xo.range(Math.ceil(r/p)*p,e,p).filter(function(n){return oa(n%d)>Aa}).map(l)).concat(Xo.range(Math.ceil(a/v)*v,o,v).filter(function(n){return oa(n%m)>Aa}).map(f))}var e,r,u,i,o,a,c,s,l,f,h,g,p=10,v=p,d=90,m=360,y=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(i).concat(g(c).slice(1),h(u).reverse().slice(1),g(s).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(i=+t[0][0],u=+t[1][0],s=+t[0][1],c=+t[1][1],i>u&&(t=i,i=u,u=t),s>c&&(t=s,s=c,c=t),n.precision(y)):[[i,s],[u,c]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(y)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],m=+t[1],n):[d,m]},n.minorStep=function(t){return arguments.length?(p=+t[0],v=+t[1],n):[p,v]},n.precision=function(t){return arguments.length?(y=+t,l=lr(a,o,90),f=fr(r,e,y),h=lr(s,c,90),g=fr(i,u,y),n):y},n.majorExtent([[-180,-90+Aa],[180,90-Aa]]).minorExtent([[-180,-80-Aa],[180,80+Aa]])},Xo.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||u.apply(this,arguments)]}}var t,e,r=hr,u=gr;return n.distance=function(){return Xo.geo.distance(t||r.apply(this,arguments),e||u.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(u=t,e="function"==typeof t?null:t,n):u},n.precision=function(){return arguments.length?n:0},n},Xo.geo.interpolate=function(n,t){return pr(n[0]*Na,n[1]*Na,t[0]*Na,t[1]*Na)},Xo.geo.length=function(n){return Uc=0,Xo.geo.stream(n,jc),Uc};var Uc,jc={sphere:g,point:g,lineStart:vr,lineEnd:g,polygonStart:g,polygonEnd:g},Hc=dr(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(Xo.geo.azimuthalEqualArea=function(){return Qe(Hc)}).raw=Hc;var Fc=dr(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},bt);(Xo.geo.azimuthalEquidistant=function(){return Qe(Fc)}).raw=Fc,(Xo.geo.conicConformal=function(){return je(mr)}).raw=mr,(Xo.geo.conicEquidistant=function(){return je(yr)}).raw=yr;var Oc=dr(function(n){return 1/n},Math.atan);(Xo.geo.gnomonic=function(){return Qe(Oc)}).raw=Oc,xr.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Ea]},(Xo.geo.mercator=function(){return Mr(xr)}).raw=xr;var Yc=dr(function(){return 1},Math.asin);(Xo.geo.orthographic=function(){return Qe(Yc)}).raw=Yc;var Ic=dr(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(Xo.geo.stereographic=function(){return Qe(Ic)}).raw=Ic,_r.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Ea]},(Xo.geo.transverseMercator=function(){var n=Mr(_r),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[-n[1],n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},n.rotate([0,0])}).raw=_r,Xo.geom={},Xo.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,u=_t(e),i=_t(r),o=n.length,a=[],c=[];for(t=0;o>t;t++)a.push([+u.call(this,n[t],t),+i.call(this,n[t],t),t]);for(a.sort(kr),t=0;o>t;t++)c.push([a[t][0],-a[t][1]]);var s=Sr(a),l=Sr(c),f=l[0]===s[0],h=l[l.length-1]===s[s.length-1],g=[];for(t=s.length-1;t>=0;--t)g.push(n[a[s[t]][2]]);for(t=+f;t<l.length-h;++t)g.push(n[a[l[t]][2]]);return g}var e=br,r=wr;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},Xo.geom.polygon=function(n){return fa(n,Zc),n};var Zc=Xo.geom.polygon.prototype=[];Zc.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],u=0;++t<e;)n=r,r=this[t],u+=n[1]*r[0]-n[0]*r[1];return.5*u},Zc.centroid=function(n){var t,e,r=-1,u=this.length,i=0,o=0,a=this[u-1];for(arguments.length||(n=-1/(6*this.area()));++r<u;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],i+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[i*n,o*n]},Zc.clip=function(n){for(var t,e,r,u,i,o,a=Cr(n),c=-1,s=this.length-Cr(this),l=this[s-1];++c<s;){for(t=n.slice(),n.length=0,u=this[c],i=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Er(o,l,u)?(Er(i,l,u)||n.push(Ar(i,o,l,u)),n.push(o)):Er(i,l,u)&&n.push(Ar(i,o,l,u)),i=o;a&&n.push(n[0]),l=u}return n};var Vc,Xc,$c,Bc,Wc,Jc=[],Gc=[];Pr.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(jr),t.length},Br.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},Wr.prototype={insert:function(n,t){var e,r,u;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=Qr(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(u=r.R,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.R&&(Gr(this,e),n=e,e=n.U),e.C=!1,r.C=!0,Kr(this,r))):(u=r.L,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.L&&(Kr(this,e),n=e,e=n.U),e.C=!1,r.C=!0,Gr(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,u=n.U,i=n.L,o=n.R;if(e=i?o?Qr(o):i:o,u?u.L===n?u.L=e:u.R=e:this._=e,i&&o?(r=e.C,e.C=n.C,e.L=i,i.U=e,e!==o?(u=e.U,e.U=n.U,n=e.R,u.L=n,e.R=o,o.U=e):(e.U=u,u=e,n=e.R)):(r=n.C,n=e),n&&(n.U=u),!r){if(n&&n.C)return n.C=!1,void 0;do{if(n===this._)break;if(n===u.L){if(t=u.R,t.C&&(t.C=!1,u.C=!0,Gr(this,u),t=u.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,Kr(this,t),t=u.R),t.C=u.C,u.C=t.R.C=!1,Gr(this,u),n=this._;break}}else if(t=u.L,t.C&&(t.C=!1,u.C=!0,Kr(this,u),t=u.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,Gr(this,t),t=u.L),t.C=u.C,u.C=t.L.C=!1,Kr(this,u),n=this._;break}t.C=!0,n=u,u=u.U}while(!n.C);n&&(n.C=!1)}}},Xo.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],u=a[0][1],i=a[1][0],o=a[1][1];return nu(e(n),a).cells.forEach(function(e,a){var c=e.edges,s=e.site,l=t[a]=c.length?c.map(function(n){var t=n.start();return[t.x,t.y]}):s.x>=r&&s.x<=i&&s.y>=u&&s.y<=o?[[r,o],[i,o],[i,u],[r,u]]:[];l.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(i(n,t)/Aa)*Aa,y:Math.round(o(n,t)/Aa)*Aa,i:t}})}var r=br,u=wr,i=r,o=u,a=Kc;return n?t(n):(t.links=function(n){return nu(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return nu(e(n)).cells.forEach(function(e,r){for(var u,i,o=e.site,a=e.edges.sort(jr),c=-1,s=a.length,l=a[s-1].edge,f=l.l===o?l.r:l.l;++c<s;)u=l,i=f,l=a[c].edge,f=l.l===o?l.r:l.l,r<i.i&&r<f.i&&eu(o,i,f)<0&&t.push([n[r],n[i.i],n[f.i]])}),t},t.x=function(n){return arguments.length?(i=_t(r=n),t):r},t.y=function(n){return arguments.length?(o=_t(u=n),t):u},t.clipExtent=function(n){return arguments.length?(a=null==n?Kc:n,t):a===Kc?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===Kc?null:a&&a[1]},t)};var Kc=[[-1e6,-1e6],[1e6,1e6]];Xo.geom.delaunay=function(n){return Xo.geom.voronoi().triangles(n)},Xo.geom.quadtree=function(n,t,e,r,u){function i(n){function i(n,t,e,r,u,i,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var c=n.x,l=n.y;if(null!=c)if(oa(c-e)+oa(l-r)<.01)s(n,t,e,r,u,i,o,a);else{var f=n.point;n.x=n.y=n.point=null,s(n,f,c,l,u,i,o,a),s(n,t,e,r,u,i,o,a)}else n.x=e,n.y=r,n.point=t}else s(n,t,e,r,u,i,o,a)}function s(n,t,e,r,u,o,a,c){var s=.5*(u+a),l=.5*(o+c),f=e>=s,h=r>=l,g=(h<<1)+f;n.leaf=!1,n=n.nodes[g]||(n.nodes[g]=iu()),f?u=s:a=s,h?o=l:c=l,i(n,t,e,r,u,o,a,c)}var l,f,h,g,p,v,d,m,y,x=_t(a),M=_t(c);if(null!=t)v=t,d=e,m=r,y=u;else if(m=y=-(v=d=1/0),f=[],h=[],p=n.length,o)for(g=0;p>g;++g)l=n[g],l.x<v&&(v=l.x),l.y<d&&(d=l.y),l.x>m&&(m=l.x),l.y>y&&(y=l.y),f.push(l.x),h.push(l.y);else for(g=0;p>g;++g){var _=+x(l=n[g],g),b=+M(l,g);v>_&&(v=_),d>b&&(d=b),_>m&&(m=_),b>y&&(y=b),f.push(_),h.push(b)}var w=m-v,S=y-d;w>S?y=d+w:m=v+S;var k=iu();if(k.add=function(n){i(k,n,+x(n,++g),+M(n,g),v,d,m,y)},k.visit=function(n){ou(n,k,v,d,m,y)},g=-1,null==t){for(;++g<p;)i(k,n[g],f[g],h[g],v,d,m,y);--g}else n.forEach(k.add);return f=h=n=l=null,k}var o,a=br,c=wr;return(o=arguments.length)?(a=ru,c=uu,3===o&&(u=e,r=t,e=t=0),i(n)):(i.x=function(n){return arguments.length?(a=n,i):a},i.y=function(n){return arguments.length?(c=n,i):c},i.extent=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],u=+n[1][1]),i):null==t?null:[[t,e],[r,u]]},i.size=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=e=0,r=+n[0],u=+n[1]),i):null==t?null:[r-t,u-e]},i)},Xo.interpolateRgb=au,Xo.interpolateObject=cu,Xo.interpolateNumber=su,Xo.interpolateString=lu;var Qc=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;Xo.interpolate=fu,Xo.interpolators=[function(n,t){var e=typeof t;return("string"===e?Va.has(t)||/^(#|rgb\(|hsl\()/.test(t)?au:lu:t instanceof G?au:"object"===e?Array.isArray(t)?hu:cu:su)(n,t)}],Xo.interpolateArray=hu;var ns=function(){return bt},ts=Xo.map({linear:ns,poly:xu,quad:function(){return du},cubic:function(){return mu},sin:function(){return Mu},exp:function(){return _u},circle:function(){return bu},elastic:wu,back:Su,bounce:function(){return ku}}),es=Xo.map({"in":bt,out:pu,"in-out":vu,"out-in":function(n){return vu(pu(n))}});Xo.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.substring(0,t):n,r=t>=0?n.substring(t+1):"in";return e=ts.get(e)||ns,r=es.get(r)||bt,gu(r(e.apply(null,$o.call(arguments,1))))},Xo.interpolateHcl=Eu,Xo.interpolateHsl=Au,Xo.interpolateLab=Cu,Xo.interpolateRound=Nu,Xo.transform=function(n){var t=Wo.createElementNS(Xo.ns.prefix.svg,"g");return(Xo.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new Lu(e?e.matrix:rs)})(n)},Lu.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var rs={a:1,b:0,c:0,d:1,e:0,f:0};Xo.interpolateTransform=Ru,Xo.layout={},Xo.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Uu(n[e]));return t}},Xo.layout.chord=function(){function n(){var n,s,f,h,g,p={},v=[],d=Xo.range(i),m=[];for(e=[],r=[],n=0,h=-1;++h<i;){for(s=0,g=-1;++g<i;)s+=u[h][g];v.push(s),m.push(Xo.range(i)),n+=s}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&m.forEach(function(n,t){n.sort(function(n,e){return a(u[t][n],u[t][e])})}),n=(ka-l*i)/n,s=0,h=-1;++h<i;){for(f=s,g=-1;++g<i;){var y=d[h],x=m[y][g],M=u[y][x],_=s,b=s+=M*n;p[y+"-"+x]={index:y,subindex:x,startAngle:_,endAngle:b,value:M}}r[y]={index:y,startAngle:f,endAngle:s,value:(s-f)/n},s+=l}for(h=-1;++h<i;)for(g=h-1;++g<i;){var w=p[h+"-"+g],S=p[g+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}c&&t()}function t(){e.sort(function(n,t){return c((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,u,i,o,a,c,s={},l=0;return s.matrix=function(n){return arguments.length?(i=(u=n)&&u.length,e=r=null,s):u},s.padding=function(n){return arguments.length?(l=n,e=r=null,s):l},s.sortGroups=function(n){return arguments.length?(o=n,e=r=null,s):o},s.sortSubgroups=function(n){return arguments.length?(a=n,e=null,s):a},s.sortChords=function(n){return arguments.length?(c=n,e&&t(),s):c},s.chords=function(){return e||n(),e},s.groups=function(){return r||n(),r},s},Xo.layout.force=function(){function n(n){return function(t,e,r,u){if(t.point!==n){var i=t.cx-n.x,o=t.cy-n.y,a=u-e,c=i*i+o*o;if(c>a*a/d){if(p>c){var s=t.charge/c;n.px-=i*s,n.py-=o*s}return!0}if(t.point&&c&&p>c){var s=t.pointCharge/c;n.px-=i*s,n.py-=o*s}}return!t.charge}}function t(n){n.px=Xo.event.x,n.py=Xo.event.y,a.resume()}var e,r,u,i,o,a={},c=Xo.dispatch("start","tick","end"),s=[1,1],l=.9,f=us,h=is,g=-30,p=os,v=.1,d=.64,m=[],y=[];return a.tick=function(){if((r*=.99)<.005)return c.end({type:"end",alpha:r=0}),!0;var t,e,a,f,h,p,d,x,M,_=m.length,b=y.length;for(e=0;b>e;++e)a=y[e],f=a.source,h=a.target,x=h.x-f.x,M=h.y-f.y,(p=x*x+M*M)&&(p=r*i[e]*((p=Math.sqrt(p))-u[e])/p,x*=p,M*=p,h.x-=x*(d=f.weight/(h.weight+f.weight)),h.y-=M*d,f.x+=x*(d=1-d),f.y+=M*d);if((d=r*v)&&(x=s[0]/2,M=s[1]/2,e=-1,d))for(;++e<_;)a=m[e],a.x+=(x-a.x)*d,a.y+=(M-a.y)*d;if(g)for(Zu(t=Xo.geom.quadtree(m),r,o),e=-1;++e<_;)(a=m[e]).fixed||t.visit(n(a));for(e=-1;++e<_;)a=m[e],a.fixed?(a.x=a.px,a.y=a.py):(a.x-=(a.px-(a.px=a.x))*l,a.y-=(a.py-(a.py=a.y))*l);c.tick({type:"tick",alpha:r})},a.nodes=function(n){return arguments.length?(m=n,a):m},a.links=function(n){return arguments.length?(y=n,a):y},a.size=function(n){return arguments.length?(s=n,a):s},a.linkDistance=function(n){return arguments.length?(f="function"==typeof n?n:+n,a):f},a.distance=a.linkDistance,a.linkStrength=function(n){return arguments.length?(h="function"==typeof n?n:+n,a):h},a.friction=function(n){return arguments.length?(l=+n,a):l},a.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,a):g},a.chargeDistance=function(n){return arguments.length?(p=n*n,a):Math.sqrt(p)},a.gravity=function(n){return arguments.length?(v=+n,a):v},a.theta=function(n){return arguments.length?(d=n*n,a):Math.sqrt(d)},a.alpha=function(n){return arguments.length?(n=+n,r?r=n>0?n:0:n>0&&(c.start({type:"start",alpha:r=n}),Xo.timer(a.tick)),a):r},a.start=function(){function n(n,r){if(!e){for(e=new Array(c),a=0;c>a;++a)e[a]=[];for(a=0;s>a;++a){var u=y[a];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var i,o=e[t],a=-1,s=o.length;++a<s;)if(!isNaN(i=o[a][n]))return i;return Math.random()*r}var t,e,r,c=m.length,l=y.length,p=s[0],v=s[1];for(t=0;c>t;++t)(r=m[t]).index=t,r.weight=0;for(t=0;l>t;++t)r=y[t],"number"==typeof r.source&&(r.source=m[r.source]),"number"==typeof r.target&&(r.target=m[r.target]),++r.source.weight,++r.target.weight;for(t=0;c>t;++t)r=m[t],isNaN(r.x)&&(r.x=n("x",p)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof f)for(t=0;l>t;++t)u[t]=+f.call(this,y[t],t);else for(t=0;l>t;++t)u[t]=f;if(i=[],"function"==typeof h)for(t=0;l>t;++t)i[t]=+h.call(this,y[t],t);else for(t=0;l>t;++t)i[t]=h;if(o=[],"function"==typeof g)for(t=0;c>t;++t)o[t]=+g.call(this,m[t],t);else for(t=0;c>t;++t)o[t]=g;return a.resume()},a.resume=function(){return a.alpha(.1)},a.stop=function(){return a.alpha(0)},a.drag=function(){return e||(e=Xo.behavior.drag().origin(bt).on("dragstart.force",Fu).on("drag.force",t).on("dragend.force",Ou)),arguments.length?(this.on("mouseover.force",Yu).on("mouseout.force",Iu).call(e),void 0):e},Xo.rebind(a,c,"on")};var us=20,is=1,os=1/0;Xo.layout.hierarchy=function(){function n(t,o,a){var c=u.call(e,t,o);if(t.depth=o,a.push(t),c&&(s=c.length)){for(var s,l,f=-1,h=t.children=new Array(s),g=0,p=o+1;++f<s;)l=h[f]=n(c[f],p,a),l.parent=t,g+=l.value;r&&h.sort(r),i&&(t.value=g)}else delete t.children,i&&(t.value=+i.call(e,t,o)||0);return t}function t(n,r){var u=n.children,o=0;if(u&&(a=u.length))for(var a,c=-1,s=r+1;++c<a;)o+=t(u[c],s);else i&&(o=+i.call(e,n,r)||0);return i&&(n.value=o),o}function e(t){var e=[];return n(t,0,e),e}var r=Bu,u=Xu,i=$u;return e.sort=function(n){return arguments.length?(r=n,e):r},e.children=function(n){return arguments.length?(u=n,e):u},e.value=function(n){return arguments.length?(i=n,e):i},e.revalue=function(n){return t(n,0),n},e},Xo.layout.partition=function(){function n(t,e,r,u){var i=t.children;if(t.x=e,t.y=t.depth*u,t.dx=r,t.dy=u,i&&(o=i.length)){var o,a,c,s=-1;for(r=t.value?r/t.value:0;++s<o;)n(a=i[s],e,c=a.value*r,u),e+=c}}function t(n){var e=n.children,r=0;if(e&&(u=e.length))for(var u,i=-1;++i<u;)r=Math.max(r,t(e[i]));return 1+r}function e(e,i){var o=r.call(this,e,i);return n(o[0],0,u[0],u[1]/t(o[0])),o}var r=Xo.layout.hierarchy(),u=[1,1];return e.size=function(n){return arguments.length?(u=n,e):u},Vu(e,r)},Xo.layout.pie=function(){function n(i){var o=i.map(function(e,r){return+t.call(n,e,r)}),a=+("function"==typeof r?r.apply(this,arguments):r),c=(("function"==typeof u?u.apply(this,arguments):u)-a)/Xo.sum(o),s=Xo.range(i.length);null!=e&&s.sort(e===as?function(n,t){return o[t]-o[n]}:function(n,t){return e(i[n],i[t])});var l=[];return s.forEach(function(n){var t;l[n]={data:i[n],value:t=o[n],startAngle:a,endAngle:a+=t*c}}),l}var t=Number,e=as,r=0,u=ka;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(u=t,n):u},n};var as={};Xo.layout.stack=function(){function n(a,c){var s=a.map(function(e,r){return t.call(n,e,r)}),l=s.map(function(t){return t.map(function(t,e){return[i.call(n,t,e),o.call(n,t,e)]})}),f=e.call(n,l,c);s=Xo.permute(s,f),l=Xo.permute(l,f);var h,g,p,v=r.call(n,l,c),d=s.length,m=s[0].length;for(g=0;m>g;++g)for(u.call(n,s[0][g],p=v[g],l[0][g][1]),h=1;d>h;++h)u.call(n,s[h][g],p+=l[h-1][g][1],l[h][g][1]);return a}var t=bt,e=Qu,r=ni,u=Ku,i=Ju,o=Gu;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:cs.get(t)||Qu,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:ss.get(t)||ni,n):r},n.x=function(t){return arguments.length?(i=t,n):i},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(u=t,n):u},n};var cs=Xo.map({"inside-out":function(n){var t,e,r=n.length,u=n.map(ti),i=n.map(ei),o=Xo.range(r).sort(function(n,t){return u[n]-u[t]}),a=0,c=0,s=[],l=[];for(t=0;r>t;++t)e=o[t],c>a?(a+=i[e],s.push(e)):(c+=i[e],l.push(e));return l.reverse().concat(s)},reverse:function(n){return Xo.range(n.length).reverse()},"default":Qu}),ss=Xo.map({silhouette:function(n){var t,e,r,u=n.length,i=n[0].length,o=[],a=0,c=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;i>e;++e)c[e]=(a-o[e])/2;return c},wiggle:function(n){var t,e,r,u,i,o,a,c,s,l=n.length,f=n[0],h=f.length,g=[];for(g[0]=c=s=0,e=1;h>e;++e){for(t=0,u=0;l>t;++t)u+=n[t][e][1];for(t=0,i=0,a=f[e][0]-f[e-1][0];l>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;i+=o*n[t][e][1]}g[e]=c-=u?i/u*a:0,s>c&&(s=c)}for(e=0;h>e;++e)g[e]-=s;return g},expand:function(n){var t,e,r,u=n.length,i=n[0].length,o=1/u,a=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];if(r)for(t=0;u>t;t++)n[t][e][1]/=r;else for(t=0;u>t;t++)n[t][e][1]=o}for(e=0;i>e;++e)a[e]=0;return a},zero:ni});Xo.layout.histogram=function(){function n(n,i){for(var o,a,c=[],s=n.map(e,this),l=r.call(this,s,i),f=u.call(this,l,s,i),i=-1,h=s.length,g=f.length-1,p=t?1:1/h;++i<g;)o=c[i]=[],o.dx=f[i+1]-(o.x=f[i]),o.y=0;if(g>0)for(i=-1;++i<h;)a=s[i],a>=l[0]&&a<=l[1]&&(o=c[Xo.bisect(f,a,1,g)-1],o.y+=p,o.push(n[i]));return c}var t=!0,e=Number,r=oi,u=ui;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=_t(t),n):r},n.bins=function(t){return arguments.length?(u="number"==typeof t?function(n){return ii(n,t)}:_t(t),n):u},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},Xo.layout.tree=function(){function n(n,i){function o(n,t){var r=n.children,u=n._tree;if(r&&(i=r.length)){for(var i,a,s,l=r[0],f=l,h=-1;++h<i;)s=r[h],o(s,a),f=c(s,a,f),a=s;vi(n);var g=.5*(l._tree.prelim+s._tree.prelim);t?(u.prelim=t._tree.prelim+e(n,t),u.mod=u.prelim-g):u.prelim=g}else t&&(u.prelim=t._tree.prelim+e(n,t))}function a(n,t){n.x=n._tree.prelim+t;var e=n.children;if(e&&(r=e.length)){var r,u=-1;for(t+=n._tree.mod;++u<r;)a(e[u],t)}}function c(n,t,r){if(t){for(var u,i=n,o=n,a=t,c=n.parent.children[0],s=i._tree.mod,l=o._tree.mod,f=a._tree.mod,h=c._tree.mod;a=si(a),i=ci(i),a&&i;)c=ci(c),o=si(o),o._tree.ancestor=n,u=a._tree.prelim+f-i._tree.prelim-s+e(a,i),u>0&&(di(mi(a,n,r),n,u),s+=u,l+=u),f+=a._tree.mod,s+=i._tree.mod,h+=c._tree.mod,l+=o._tree.mod;a&&!si(o)&&(o._tree.thread=a,o._tree.mod+=f-l),i&&!ci(c)&&(c._tree.thread=i,c._tree.mod+=s-h,r=n)}return r}var s=t.call(this,n,i),l=s[0];pi(l,function(n,t){n._tree={ancestor:n,prelim:0,mod:0,change:0,shift:0,number:t?t._tree.number+1:0}}),o(l),a(l,-l._tree.prelim);var f=li(l,hi),h=li(l,fi),g=li(l,gi),p=f.x-e(f,h)/2,v=h.x+e(h,f)/2,d=g.depth||1;return pi(l,u?function(n){n.x*=r[0],n.y=n.depth*r[1],delete n._tree}:function(n){n.x=(n.x-p)/(v-p)*r[0],n.y=n.depth/d*r[1],delete n._tree}),s}var t=Xo.layout.hierarchy().sort(null).value(null),e=ai,r=[1,1],u=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(u=null==(r=t),n):u?null:r},n.nodeSize=function(t){return arguments.length?(u=null!=(r=t),n):u?r:null},Vu(n,t)},Xo.layout.pack=function(){function n(n,i){var o=e.call(this,n,i),a=o[0],c=u[0],s=u[1],l=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,pi(a,function(n){n.r=+l(n.value)}),pi(a,bi),r){var f=r*(t?1:Math.max(2*a.r/c,2*a.r/s))/2;pi(a,function(n){n.r+=f}),pi(a,bi),pi(a,function(n){n.r-=f})}return ki(a,c/2,s/2,t?1:1/Math.max(2*a.r/c,2*a.r/s)),o}var t,e=Xo.layout.hierarchy().sort(yi),r=0,u=[1,1];return n.size=function(t){return arguments.length?(u=t,n):u},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},Vu(n,e)},Xo.layout.cluster=function(){function n(n,i){var o,a=t.call(this,n,i),c=a[0],s=0;pi(c,function(n){var t=n.children;t&&t.length?(n.x=Ci(t),n.y=Ai(t)):(n.x=o?s+=e(n,o):0,n.y=0,o=n)});var l=Ni(c),f=Li(c),h=l.x-e(l,f)/2,g=f.x+e(f,l)/2;return pi(c,u?function(n){n.x=(n.x-c.x)*r[0],n.y=(c.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(g-h)*r[0],n.y=(1-(c.y?n.y/c.y:1))*r[1]}),a}var t=Xo.layout.hierarchy().sort(null).value(null),e=ai,r=[1,1],u=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(u=null==(r=t),n):u?null:r},n.nodeSize=function(t){return arguments.length?(u=null!=(r=t),n):u?r:null},Vu(n,t)},Xo.layout.treemap=function(){function n(n,t){for(var e,r,u=-1,i=n.length;++u<i;)r=(e=n[u]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var i=e.children;if(i&&i.length){var o,a,c,s=f(e),l=[],h=i.slice(),p=1/0,v="slice"===g?s.dx:"dice"===g?s.dy:"slice-dice"===g?1&e.depth?s.dy:s.dx:Math.min(s.dx,s.dy);for(n(h,s.dx*s.dy/e.value),l.area=0;(c=h.length)>0;)l.push(o=h[c-1]),l.area+=o.area,"squarify"!==g||(a=r(l,v))<=p?(h.pop(),p=a):(l.area-=l.pop().area,u(l,v,s,!1),v=Math.min(s.dx,s.dy),l.length=l.area=0,p=1/0);l.length&&(u(l,v,s,!0),l.length=l.area=0),i.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var i,o=f(t),a=r.slice(),c=[];for(n(a,o.dx*o.dy/t.value),c.area=0;i=a.pop();)c.push(i),c.area+=i.area,null!=i.z&&(u(c,i.z?o.dx:o.dy,o,!a.length),c.length=c.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,u=0,i=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(i>e&&(i=e),e>u&&(u=e));return r*=r,t*=t,r?Math.max(t*u*p/r,r/(t*i*p)):1/0}function u(n,t,e,r){var u,i=-1,o=n.length,a=e.x,s=e.y,l=t?c(n.area/t):0;if(t==e.dx){for((r||l>e.dy)&&(l=e.dy);++i<o;)u=n[i],u.x=a,u.y=s,u.dy=l,a+=u.dx=Math.min(e.x+e.dx-a,l?c(u.area/l):0);u.z=!0,u.dx+=e.x+e.dx-a,e.y+=l,e.dy-=l}else{for((r||l>e.dx)&&(l=e.dx);++i<o;)u=n[i],u.x=a,u.y=s,u.dx=l,s+=u.dy=Math.min(e.y+e.dy-s,l?c(u.area/l):0);u.z=!1,u.dy+=e.y+e.dy-s,e.x+=l,e.dx-=l}}function i(r){var u=o||a(r),i=u[0];return i.x=0,i.y=0,i.dx=s[0],i.dy=s[1],o&&a.revalue(i),n([i],i.dx*i.dy/i.value),(o?e:t)(i),h&&(o=u),u}var o,a=Xo.layout.hierarchy(),c=Math.round,s=[1,1],l=null,f=zi,h=!1,g="squarify",p=.5*(1+Math.sqrt(5));return i.size=function(n){return arguments.length?(s=n,i):s},i.padding=function(n){function t(t){var e=n.call(i,t,t.depth);return null==e?zi(t):qi(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return qi(t,n)}if(!arguments.length)return l;var r;return f=null==(l=n)?zi:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,i},i.round=function(n){return arguments.length?(c=n?Math.round:Number,i):c!=Number},i.sticky=function(n){return arguments.length?(h=n,o=null,i):h},i.ratio=function(n){return arguments.length?(p=n,i):p},i.mode=function(n){return arguments.length?(g=n+"",i):g},Vu(i,a)},Xo.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,u;do e=2*Math.random()-1,r=2*Math.random()-1,u=e*e+r*r;while(!u||u>1);return n+t*e*Math.sqrt(-2*Math.log(u)/u)}},logNormal:function(){var n=Xo.random.normal.apply(Xo,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=Xo.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},Xo.scale={};var ls={floor:bt,ceil:bt};Xo.scale.linear=function(){return Hi([0,1],[0,1],fu,!1)};var fs={s:1,g:1,p:1,r:1,e:1};Xo.scale.log=function(){return $i(Xo.scale.linear().domain([0,1]),10,!0,[1,10])};var hs=Xo.format(".0e"),gs={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};Xo.scale.pow=function(){return Bi(Xo.scale.linear(),1,[0,1])},Xo.scale.sqrt=function(){return Xo.scale.pow().exponent(.5)},Xo.scale.ordinal=function(){return Ji([],{t:"range",a:[[]]})},Xo.scale.category10=function(){return Xo.scale.ordinal().range(ps)},Xo.scale.category20=function(){return Xo.scale.ordinal().range(vs)},Xo.scale.category20b=function(){return Xo.scale.ordinal().range(ds)},Xo.scale.category20c=function(){return Xo.scale.ordinal().range(ms)};var ps=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(ht),vs=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(ht),ds=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(ht),ms=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(ht);Xo.scale.quantile=function(){return Gi([],[])
+},Xo.scale.quantize=function(){return Ki(0,1,[0,1])},Xo.scale.threshold=function(){return Qi([.5],[0,1])},Xo.scale.identity=function(){return no([0,1])},Xo.svg={},Xo.svg.arc=function(){function n(){var n=t.apply(this,arguments),i=e.apply(this,arguments),o=r.apply(this,arguments)+ys,a=u.apply(this,arguments)+ys,c=(o>a&&(c=o,o=a,a=c),a-o),s=Sa>c?"0":"1",l=Math.cos(o),f=Math.sin(o),h=Math.cos(a),g=Math.sin(a);return c>=xs?n?"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"M0,"+n+"A"+n+","+n+" 0 1,0 0,"+-n+"A"+n+","+n+" 0 1,0 0,"+n+"Z":"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"Z":n?"M"+i*l+","+i*f+"A"+i+","+i+" 0 "+s+",1 "+i*h+","+i*g+"L"+n*h+","+n*g+"A"+n+","+n+" 0 "+s+",0 "+n*l+","+n*f+"Z":"M"+i*l+","+i*f+"A"+i+","+i+" 0 "+s+",1 "+i*h+","+i*g+"L0,0"+"Z"}var t=to,e=eo,r=ro,u=uo;return n.innerRadius=function(e){return arguments.length?(t=_t(e),n):t},n.outerRadius=function(t){return arguments.length?(e=_t(t),n):e},n.startAngle=function(t){return arguments.length?(r=_t(t),n):r},n.endAngle=function(t){return arguments.length?(u=_t(t),n):u},n.centroid=function(){var n=(t.apply(this,arguments)+e.apply(this,arguments))/2,i=(r.apply(this,arguments)+u.apply(this,arguments))/2+ys;return[Math.cos(i)*n,Math.sin(i)*n]},n};var ys=-Ea,xs=ka-Aa;Xo.svg.line=function(){return io(bt)};var Ms=Xo.map({linear:oo,"linear-closed":ao,step:co,"step-before":so,"step-after":lo,basis:mo,"basis-open":yo,"basis-closed":xo,bundle:Mo,cardinal:go,"cardinal-open":fo,"cardinal-closed":ho,monotone:Eo});Ms.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var _s=[0,2/3,1/3,0],bs=[0,1/3,2/3,0],ws=[0,1/6,2/3,1/6];Xo.svg.line.radial=function(){var n=io(Ao);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},so.reverse=lo,lo.reverse=so,Xo.svg.area=function(){return Co(bt)},Xo.svg.area.radial=function(){var n=Co(Ao);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},Xo.svg.chord=function(){function n(n,a){var c=t(this,i,n,a),s=t(this,o,n,a);return"M"+c.p0+r(c.r,c.p1,c.a1-c.a0)+(e(c,s)?u(c.r,c.p1,c.r,c.p0):u(c.r,c.p1,s.r,s.p0)+r(s.r,s.p1,s.a1-s.a0)+u(s.r,s.p1,c.r,c.p0))+"Z"}function t(n,t,e,r){var u=t.call(n,e,r),i=a.call(n,u,r),o=c.call(n,u,r)+ys,l=s.call(n,u,r)+ys;return{r:i,a0:o,a1:l,p0:[i*Math.cos(o),i*Math.sin(o)],p1:[i*Math.cos(l),i*Math.sin(l)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Sa)+",1 "+t}function u(n,t,e,r){return"Q 0,0 "+r}var i=hr,o=gr,a=No,c=ro,s=uo;return n.radius=function(t){return arguments.length?(a=_t(t),n):a},n.source=function(t){return arguments.length?(i=_t(t),n):i},n.target=function(t){return arguments.length?(o=_t(t),n):o},n.startAngle=function(t){return arguments.length?(c=_t(t),n):c},n.endAngle=function(t){return arguments.length?(s=_t(t),n):s},n},Xo.svg.diagonal=function(){function n(n,u){var i=t.call(this,n,u),o=e.call(this,n,u),a=(i.y+o.y)/2,c=[i,{x:i.x,y:a},{x:o.x,y:a},o];return c=c.map(r),"M"+c[0]+"C"+c[1]+" "+c[2]+" "+c[3]}var t=hr,e=gr,r=Lo;return n.source=function(e){return arguments.length?(t=_t(e),n):t},n.target=function(t){return arguments.length?(e=_t(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},Xo.svg.diagonal.radial=function(){var n=Xo.svg.diagonal(),t=Lo,e=n.projection;return n.projection=function(n){return arguments.length?e(zo(t=n)):t},n},Xo.svg.symbol=function(){function n(n,r){return(Ss.get(t.call(this,n,r))||Ro)(e.call(this,n,r))}var t=To,e=qo;return n.type=function(e){return arguments.length?(t=_t(e),n):t},n.size=function(t){return arguments.length?(e=_t(t),n):e},n};var Ss=Xo.map({circle:Ro,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Cs)),e=t*Cs;return"M0,"+-t+"L"+e+",0"+" 0,"+t+" "+-e+",0"+"Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/As),e=t*As/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/As),e=t*As/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});Xo.svg.symbolTypes=Ss.keys();var ks,Es,As=Math.sqrt(3),Cs=Math.tan(30*Na),Ns=[],Ls=0;Ns.call=da.call,Ns.empty=da.empty,Ns.node=da.node,Ns.size=da.size,Xo.transition=function(n){return arguments.length?ks?n.transition():n:xa.transition()},Xo.transition.prototype=Ns,Ns.select=function(n){var t,e,r,u=this.id,i=[];n=M(n);for(var o=-1,a=this.length;++o<a;){i.push(t=[]);for(var c=this[o],s=-1,l=c.length;++s<l;)(r=c[s])&&(e=n.call(r,r.__data__,s,o))?("__data__"in r&&(e.__data__=r.__data__),jo(e,s,u,r.__transition__[u]),t.push(e)):t.push(null)}return Do(i,u)},Ns.selectAll=function(n){var t,e,r,u,i,o=this.id,a=[];n=_(n);for(var c=-1,s=this.length;++c<s;)for(var l=this[c],f=-1,h=l.length;++f<h;)if(r=l[f]){i=r.__transition__[o],e=n.call(r,r.__data__,f,c),a.push(t=[]);for(var g=-1,p=e.length;++g<p;)(u=e[g])&&jo(u,g,o,i),t.push(u)}return Do(a,o)},Ns.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=q(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]);for(var e=this[i],a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return Do(u,this.id)},Ns.tween=function(n,t){var e=this.id;return arguments.length<2?this.node().__transition__[e].tween.get(n):R(this,null==t?function(t){t.__transition__[e].tween.remove(n)}:function(r){r.__transition__[e].tween.set(n,t)})},Ns.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function u(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function i(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?Ru:fu,a=Xo.ns.qualify(n);return Po(this,"attr."+n,t,a.local?i:u)},Ns.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(u));return r&&function(n){this.setAttribute(u,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(u.space,u.local));return r&&function(n){this.setAttributeNS(u.space,u.local,r(n))}}var u=Xo.ns.qualify(n);return this.tween("attr."+n,u.local?r:e)},Ns.style=function(n,t,e){function r(){this.style.removeProperty(n)}function u(t){return null==t?r:(t+="",function(){var r,u=Go.getComputedStyle(this,null).getPropertyValue(n);return u!==t&&(r=fu(u,t),function(t){this.style.setProperty(n,r(t),e)})})}var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(t="");for(e in n)this.style(e,n[e],t);return this}e=""}return Po(this,"style."+n,t,u)},Ns.styleTween=function(n,t,e){function r(r,u){var i=t.call(this,r,u,Go.getComputedStyle(this,null).getPropertyValue(n));return i&&function(t){this.style.setProperty(n,i(t),e)}}return arguments.length<3&&(e=""),this.tween("style."+n,r)},Ns.text=function(n){return Po(this,"text",n,Uo)},Ns.remove=function(){return this.each("end.transition",function(){var n;this.__transition__.count<2&&(n=this.parentNode)&&n.removeChild(this)})},Ns.ease=function(n){var t=this.id;return arguments.length<1?this.node().__transition__[t].ease:("function"!=typeof n&&(n=Xo.ease.apply(Xo,arguments)),R(this,function(e){e.__transition__[t].ease=n}))},Ns.delay=function(n){var t=this.id;return R(this,"function"==typeof n?function(e,r,u){e.__transition__[t].delay=+n.call(e,e.__data__,r,u)}:(n=+n,function(e){e.__transition__[t].delay=n}))},Ns.duration=function(n){var t=this.id;return R(this,"function"==typeof n?function(e,r,u){e.__transition__[t].duration=Math.max(1,n.call(e,e.__data__,r,u))}:(n=Math.max(1,n),function(e){e.__transition__[t].duration=n}))},Ns.each=function(n,t){var e=this.id;if(arguments.length<2){var r=Es,u=ks;ks=e,R(this,function(t,r,u){Es=t.__transition__[e],n.call(t,t.__data__,r,u)}),Es=r,ks=u}else R(this,function(r){var u=r.__transition__[e];(u.event||(u.event=Xo.dispatch("start","end"))).on(n,t)});return this},Ns.transition=function(){for(var n,t,e,r,u=this.id,i=++Ls,o=[],a=0,c=this.length;c>a;a++){o.push(n=[]);for(var t=this[a],s=0,l=t.length;l>s;s++)(e=t[s])&&(r=Object.create(e.__transition__[u]),r.delay+=r.duration,jo(e,s,i,r)),n.push(e)}return Do(o,i)},Xo.svg.axis=function(){function n(n){n.each(function(){var n,s=Xo.select(this),l=this.__chart__||e,f=this.__chart__=e.copy(),h=null==c?f.ticks?f.ticks.apply(f,a):f.domain():c,g=null==t?f.tickFormat?f.tickFormat.apply(f,a):bt:t,p=s.selectAll(".tick").data(h,f),v=p.enter().insert("g",".domain").attr("class","tick").style("opacity",Aa),d=Xo.transition(p.exit()).style("opacity",Aa).remove(),m=Xo.transition(p).style("opacity",1),y=Ri(f),x=s.selectAll(".domain").data([0]),M=(x.enter().append("path").attr("class","domain"),Xo.transition(x));v.append("line"),v.append("text");var _=v.select("line"),b=m.select("line"),w=p.select("text").text(g),S=v.select("text"),k=m.select("text");switch(r){case"bottom":n=Ho,_.attr("y2",u),S.attr("y",Math.max(u,0)+o),b.attr("x2",0).attr("y2",u),k.attr("x",0).attr("y",Math.max(u,0)+o),w.attr("dy",".71em").style("text-anchor","middle"),M.attr("d","M"+y[0]+","+i+"V0H"+y[1]+"V"+i);break;case"top":n=Ho,_.attr("y2",-u),S.attr("y",-(Math.max(u,0)+o)),b.attr("x2",0).attr("y2",-u),k.attr("x",0).attr("y",-(Math.max(u,0)+o)),w.attr("dy","0em").style("text-anchor","middle"),M.attr("d","M"+y[0]+","+-i+"V0H"+y[1]+"V"+-i);break;case"left":n=Fo,_.attr("x2",-u),S.attr("x",-(Math.max(u,0)+o)),b.attr("x2",-u).attr("y2",0),k.attr("x",-(Math.max(u,0)+o)).attr("y",0),w.attr("dy",".32em").style("text-anchor","end"),M.attr("d","M"+-i+","+y[0]+"H0V"+y[1]+"H"+-i);break;case"right":n=Fo,_.attr("x2",u),S.attr("x",Math.max(u,0)+o),b.attr("x2",u).attr("y2",0),k.attr("x",Math.max(u,0)+o).attr("y",0),w.attr("dy",".32em").style("text-anchor","start"),M.attr("d","M"+i+","+y[0]+"H0V"+y[1]+"H"+i)}if(f.rangeBand){var E=f,A=E.rangeBand()/2;l=f=function(n){return E(n)+A}}else l.rangeBand?l=f:d.call(n,f);v.call(n,l),m.call(n,f)})}var t,e=Xo.scale.linear(),r=zs,u=6,i=6,o=3,a=[10],c=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in qs?t+"":zs,n):r},n.ticks=function(){return arguments.length?(a=arguments,n):a},n.tickValues=function(t){return arguments.length?(c=t,n):c},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(u=+t,i=+arguments[e-1],n):u},n.innerTickSize=function(t){return arguments.length?(u=+t,n):u},n.outerTickSize=function(t){return arguments.length?(i=+t,n):i},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var zs="bottom",qs={top:1,right:1,bottom:1,left:1};Xo.svg.brush=function(){function n(i){i.each(function(){var i=Xo.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=i.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),i.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=i.selectAll(".resize").data(p,bt);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return Ts[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,f=Xo.transition(i),h=Xo.transition(o);c&&(l=Ri(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),e(f)),s&&(l=Ri(s),h.attr("y",l[0]).attr("height",l[1]-l[0]),r(f)),t(f)})}function t(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+l[+/e$/.test(n)]+","+f[+/^s/.test(n)]+")"})}function e(n){n.select(".extent").attr("x",l[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",l[1]-l[0])}function r(n){n.select(".extent").attr("y",f[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",f[1]-f[0])}function u(){function u(){32==Xo.event.keyCode&&(C||(x=null,L[0]-=l[1],L[1]-=f[1],C=2),d())}function p(){32==Xo.event.keyCode&&2==C&&(L[0]+=l[1],L[1]+=f[1],C=0,d())}function v(){var n=Xo.mouse(_),u=!1;M&&(n[0]+=M[0],n[1]+=M[1]),C||(Xo.event.altKey?(x||(x=[(l[0]+l[1])/2,(f[0]+f[1])/2]),L[0]=l[+(n[0]<x[0])],L[1]=f[+(n[1]<x[1])]):x=null),E&&m(n,c,0)&&(e(S),u=!0),A&&m(n,s,1)&&(r(S),u=!0),u&&(t(S),w({type:"brush",mode:C?"move":"resize"}))}function m(n,t,e){var r,u,a=Ri(t),c=a[0],s=a[1],p=L[e],v=e?f:l,d=v[1]-v[0];return C&&(c-=p,s-=d+p),r=(e?g:h)?Math.max(c,Math.min(s,n[e])):n[e],C?u=(r+=p)+d:(x&&(p=Math.max(c,Math.min(s,2*x[e]-r))),r>p?(u=r,r=p):u=p),v[0]!=r||v[1]!=u?(e?o=null:i=null,v[0]=r,v[1]=u,!0):void 0}function y(){v(),S.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),Xo.select("body").style("cursor",null),z.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),N(),w({type:"brushend"})}var x,M,_=this,b=Xo.select(Xo.event.target),w=a.of(_,arguments),S=Xo.select(_),k=b.datum(),E=!/^(n|s)$/.test(k)&&c,A=!/^(e|w)$/.test(k)&&s,C=b.classed("extent"),N=O(),L=Xo.mouse(_),z=Xo.select(Go).on("keydown.brush",u).on("keyup.brush",p);if(Xo.event.changedTouches?z.on("touchmove.brush",v).on("touchend.brush",y):z.on("mousemove.brush",v).on("mouseup.brush",y),S.interrupt().selectAll("*").interrupt(),C)L[0]=l[0]-L[0],L[1]=f[0]-L[1];else if(k){var q=+/w$/.test(k),T=+/^n/.test(k);M=[l[1-q]-L[0],f[1-T]-L[1]],L[0]=l[q],L[1]=f[T]}else Xo.event.altKey&&(x=L.slice());S.style("pointer-events","none").selectAll(".resize").style("display",null),Xo.select("body").style("cursor",b.style("cursor")),w({type:"brushstart"}),v()}var i,o,a=y(n,"brushstart","brush","brushend"),c=null,s=null,l=[0,0],f=[0,0],h=!0,g=!0,p=Rs[0];return n.event=function(n){n.each(function(){var n=a.of(this,arguments),t={x:l,y:f,i:i,j:o},e=this.__chart__||t;this.__chart__=t,ks?Xo.select(this).transition().each("start.brush",function(){i=e.i,o=e.j,l=e.x,f=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=hu(l,t.x),r=hu(f,t.y);return i=o=null,function(u){l=t.x=e(u),f=t.y=r(u),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){i=t.i,o=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,p=Rs[!c<<1|!s],n):c},n.y=function(t){return arguments.length?(s=t,p=Rs[!c<<1|!s],n):s},n.clamp=function(t){return arguments.length?(c&&s?(h=!!t[0],g=!!t[1]):c?h=!!t:s&&(g=!!t),n):c&&s?[h,g]:c?h:s?g:null},n.extent=function(t){var e,r,u,a,h;return arguments.length?(c&&(e=t[0],r=t[1],s&&(e=e[0],r=r[0]),i=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(h=e,e=r,r=h),(e!=l[0]||r!=l[1])&&(l=[e,r])),s&&(u=t[0],a=t[1],c&&(u=u[1],a=a[1]),o=[u,a],s.invert&&(u=s(u),a=s(a)),u>a&&(h=u,u=a,a=h),(u!=f[0]||a!=f[1])&&(f=[u,a])),n):(c&&(i?(e=i[0],r=i[1]):(e=l[0],r=l[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(h=e,e=r,r=h))),s&&(o?(u=o[0],a=o[1]):(u=f[0],a=f[1],s.invert&&(u=s.invert(u),a=s.invert(a)),u>a&&(h=u,u=a,a=h))),c&&s?[[e,u],[r,a]]:c?[e,r]:s&&[u,a])},n.clear=function(){return n.empty()||(l=[0,0],f=[0,0],i=o=null),n},n.empty=function(){return!!c&&l[0]==l[1]||!!s&&f[0]==f[1]},Xo.rebind(n,a,"on")};var Ts={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Rs=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Ds=tc.format=ac.timeFormat,Ps=Ds.utc,Us=Ps("%Y-%m-%dT%H:%M:%S.%LZ");Ds.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?Oo:Us,Oo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},Oo.toString=Us.toString,tc.second=Rt(function(n){return new ec(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),tc.seconds=tc.second.range,tc.seconds.utc=tc.second.utc.range,tc.minute=Rt(function(n){return new ec(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),tc.minutes=tc.minute.range,tc.minutes.utc=tc.minute.utc.range,tc.hour=Rt(function(n){var t=n.getTimezoneOffset()/60;return new ec(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),tc.hours=tc.hour.range,tc.hours.utc=tc.hour.utc.range,tc.month=Rt(function(n){return n=tc.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),tc.months=tc.month.range,tc.months.utc=tc.month.utc.range;var js=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Hs=[[tc.second,1],[tc.second,5],[tc.second,15],[tc.second,30],[tc.minute,1],[tc.minute,5],[tc.minute,15],[tc.minute,30],[tc.hour,1],[tc.hour,3],[tc.hour,6],[tc.hour,12],[tc.day,1],[tc.day,2],[tc.week,1],[tc.month,1],[tc.month,3],[tc.year,1]],Fs=Ds.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",be]]),Os={range:function(n,t,e){return Xo.range(+n,+t,e).map(Io)},floor:bt,ceil:bt};Hs.year=tc.year,tc.scale=function(){return Yo(Xo.scale.linear(),Hs,Fs)};var Ys=Hs.map(function(n){return[n[0].utc,n[1]]}),Is=Ps.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",be]]);Ys.year=tc.year.utc,tc.scale.utc=function(){return Yo(Xo.scale.linear(),Ys,Is)},Xo.text=wt(function(n){return n.responseText}),Xo.json=function(n,t){return St(n,"application/json",Zo,t)},Xo.html=function(n,t){return St(n,"text/html",Vo,t)},Xo.xml=wt(function(n){return n.responseXML}),"function"==typeof define&&define.amd?define(Xo):"object"==typeof module&&module.exports?module.exports=Xo:this.d3=Xo}();
\ No newline at end of file
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index cfee31d616..294f52f9a5 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -1,60 +1,356 @@
-// IE fix
-if (!window.console) {
-    var console = {
-        log: function() {},
-        warn: function() {},
-        error: function() {},
-        time: function() {},
-        timeEnd: function() {}
+// usage: log('inside coolFunc',this,arguments);
+// http://paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/
+var debug = false;
+window.log = function () {
+    log.history = log.history || [];   // store logs to an array for reference
+    log.history.push(arguments);
+    if (this.console && debug) {
+        console.log(Array.prototype.slice.call(arguments));
+    }
+};
+
+// compatiblity script taken from http://stackoverflow.com/a/11054570/194609
+if (!Function.prototype.bind) {
+    Function.prototype.bind = function (oThis) {
+        if (typeof this !== 'function') {
+            // closest thing possible to the ECMAScript 5
+            // internal IsCallable function
+            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
+        }
+
+        var aArgs = Array.prototype.slice.call(arguments, 1),
+                fToBind = this,
+                fNOP = function () {
+                },
+                fBound = function () {
+                    return fToBind.apply(this instanceof fNOP && oThis
+                            ? this
+                            : oThis,
+                            aArgs.concat(Array.prototype.slice.call(arguments)));
+                };
+
+        fNOP.prototype = this.prototype;
+        fBound.prototype = new fNOP();
+
+        return fBound;
     };
 }
 
-GHRequest = function(host) {
-    this.minPathPrecision = 1;
+GHRequest = function (host) {
+    this.way_point_max_distance = 1;
     this.host = host;
-    this.from = new GHInput("");
-    this.to = new GHInput("");
+    this.route = new GHroute(new GHInput(), new GHInput());
+    this.from = this.route.first();
+    this.to = this.route.last();
     this.vehicle = "car";
     this.weighting = "fastest";
-    this.encodedPolyline = true;
+    this.points_encoded = true;
     this.instructions = true;
+    this.elevation = false;
+    this.features = {};
     this.debug = false;
     this.locale = "en";
-    this.doZoom = true;
-    // if your server allows CORS you can use json here
-    this.dataType = "jsonp";
+    this.do_zoom = true;
+    // use jsonp here if host allows CORS
+    this.dataType = "json";
+    // all URL parameters starting with "api." will be forwarded to GraphHopper directly    
+    this.api_params = [];
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    // We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
+    // Our routing service is also free for certain applications or smaller volume. Be fair, grab an API key and support us:
+    // https://graphhopper.com/#directions-api Misuse of API keys that you don't own is prohibited and you'll be blocked.                    
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    this.key = "Cmmtvx01R56rdHcQQo7VjI6rgPgxuFLvqI8cR31u";
+
+    // register events
+    this.route.addListener('route.add', function (evt) {
+        this.to = this.route.last();
+        log("Foo just added.");
+    }.bind(this));
+    this.route.addListener('route.remove', function (evt) {
+        this.from = this.route.first();
+        this.to = this.route.last();
+        log("Foo just removed.");
+    }.bind(this));
+    this.route.addListener('route.move', function (evt) {
+        this.from = this.route.first();
+        this.to = this.route.last();
+        log("Foo just moved.");
+    }.bind(this));
+//    this.route.addListener('route.set', function (evt) {
+//        this.from = this.route.first();
+//        this.to = this.route.last();
+//        log("Foo just moved.");
+//    }.bind(this));
+    this.route.addListener('route.reverse', function (evt) {
+        this.from = this.route.first();
+        this.to = this.route.last();
+        log("Foo just reversed.");
+    }.bind(this));
+};
+
+GHroute = function () {
+    var route = Object.create(Array.prototype);
+    route = (Array.apply(route, arguments) || route);
+    GHroute.injectClassMethods(route);
+    route._listeners = {};
+    return (route);
+};
+
+GHroute.injectClassMethods = function (route) {
+    for (var method in GHroute.prototype) {
+        if (GHroute.prototype.hasOwnProperty(method)) {
+            route[method] = GHroute.prototype[method];
+        }
+    }
+    return (route);
+};
+
+GHroute.fromArray = function (array) {
+    var route = GHroute.apply(null, array);
+    return (route);
+};
+
+GHroute.isArray = function (value) {
+    var stringValue = Object.prototype.toString.call(value);
+    return (stringValue.toLowerCase() === "[object array]");
+};
+
+GHroute.prototype = {
+    first: function () {
+        return this.getIndex(0);
+    },
+    last: function () {
+        return this.getIndex((this.length - 1));
+    },
+    getIndex: function (index) {
+        var index = (isNaN(index)) ? 0 : index;
+        if (this[index] instanceof GHInput) {
+            return this[index];
+        } else
+            return false;
+    },
+    getIndexByCoord: function (value) {
+        var point,
+                index = false,
+                coord = new GHInput(value),
+                i,
+                l;
+
+        for (i = 0, l = this.length; i < l; i++) {
+            point = this[i];
+            if (point.toString() === coord.toString()) {
+                index = i;
+                break;
+            }
+        }
+        return index;
+    },
+    getIndexFromCoord: function (value) {
+        return this.getIndex(this.getIndexByCoord(value));
+    },
+    size: function () {
+        return this.length;
+    },
+    add: function (value, to) {
+        if (GHroute.isArray(value)) {
+            for (var i = 0; i < value.length; i++) {
+                Array.prototype.push.call(this, (value[i] instanceof GHInput) ? value[i] : new GHInput(value[i]));
+                if (to !== undefined) {
+                    this.move(-1, to, true);
+                    to++;
+                } else
+                    to = this.lenght - 1;
+                this.fire('route.add', {
+                    point: this[to],
+                    to: to
+                });
+            }
+            return (this);
+        } else {
+            Array.prototype.push.call(this, (value instanceof GHInput) ? value : new GHInput(value));
+            if (to !== undefined)
+                this.move(-1, to, true);
+            else
+                to = this.lenght - 1;
+            this.fire('route.add', {
+                point: this[to],
+                to: to
+            });
+        }
+        return (this[to]);
+    },
+    removeSingle: function (value) {
+        var index = false;
+        if (!(isNaN(value) || value >= this.length) && this[value] !== undefined) {
+            index = value;
+        } else {
+            if (value instanceof GHInput) {
+                value = value.toString();
+            }
+            index = this.getIndexByCoord(value);
+        }
+        if (index !== false) {
+            this.remove(index);
+        }
+        return (this);
+    },
+    remove: function (from, to) {
+        var tmpTo = to || 1;
+        Array.prototype.splice.call(this, from, tmpTo);
+        if (this.length === 1)
+            Array.prototype.push.call(this, new GHInput());
+        this.fire('route.remove', {
+            from: from,
+            to: tmpTo
+        });
+        return (this);
+    },
+    addAll: function () {
+        for (var i = 0; i < arguments.length; i++) {
+            this.add(arguments[i]);
+        }
+        return (this);
+    },
+    set: function (value, to, create) {
+        if (value instanceof GHInput)
+            this[to] = value;
+        else if (this[to] instanceof GHInput) {
+            this[to].set(value);
+        } else if (create)
+            return this.add(value, to);
+        else
+            return false;
+        this.fire('route.set', {
+            point: this[to],
+            to: to
+        });
+        return (this[to]);
+    },
+    move: function (old_index, new_index, supress_event) {
+        while (old_index < 0) {
+            old_index += this.length;
+        }
+        while (new_index < 0) {
+            new_index += this.length;
+        }
+        if (new_index >= this.length) {
+            var k = new_index - this.length;
+            while ((k--) + 1) {
+                Array.prototype.push.call(this, undefined);
+            }
+        }
+        Array.prototype.splice.call(this, new_index, 0, Array.prototype.splice.call(this, old_index, 1)[0]);
+        if (!supress_event)
+            this.fire('route.move', {
+                old_index: old_index,
+                new_index: new_index
+            });
+        return (this);
+    },
+    reverse: function () {
+        Array.prototype.reverse.call(this);
+        this.fire('route.reverse', {});
+        return (this);
+    },
+    isResolved: function () {
+        for (var i = 0, l = this.length; i < l; i++) {
+            var point = this[i];
+            if (!point.isResolved()) {
+                return false;
+            }
+        }
+        return true;
+    },
+    addListener: function (type, listener) {
+        if (typeof this._listeners[type] === "undefined") {
+            this._listeners[type] = [];
+        }
+        this._listeners[type].push(listener);
+        return this;
+    },
+    fire: function (event, options) {
+        if (typeof event === "string") {
+            event = {type: event};
+        }
+        if (typeof options === "object") {
+            for (var attrname in options) {
+                event[attrname] = options[attrname];
+            }
+        }
+        if (!event.route) {
+            event.route = this;
+        }
+        if (!event.type) {  //falsy
+            throw new Error("Event object missing 'type' property.");
+        }
+        if (this._listeners[event.type] instanceof Array) {
+            var listeners = this._listeners[event.type];
+            for (var i = 0, len = listeners.length; i < len; i++) {
+                listeners[i].call(this, event);
+            }
+        }
+    },
+    removeListener: function (type, listener) {
+        if (this._listeners[type] instanceof Array) {
+            var listeners = this._listeners[type];
+            for (var i = 0, len = listeners.length; i < len; i++) {
+                if (listeners[i] === listener) {
+                    listeners.splice(i, 1);
+                    break;
+                }
+            }
+        }
+    }
 };
 
-GHRequest.prototype.init = function(params) {
-    //    for(var key in params) {
-    //        var val = params[key];
-    //        if(val === "false")
-    //            val = false;
-    //        else if(val === "true")
-    //            val = true;
-    //        else {            
-    //            if(parseFloat(val) != NaN)
-    //                val = parseFloat(val)
-    //        }
-    //        this[key] = val;
-    //    } 
+GHRequest.prototype.init = function (params) {
+    for (var key in params) {
+        var val = params[key];
+        if (val === "false")
+            val = false;
+        else if (val === "true")
+            val = true;
+        else {
+            if (parseFloat(val) != NaN)
+                val = parseFloat(val)
+        }
+
+        // todo
+        // this[key] = val;
+
+        if (key.indexOf('api.') === 0) {
+            this.api_params[key.substring(4)] = val;
+        }
+    }
+
     if (params.minPathPrecision)
         this.minPathPrecision = params.minPathPrecision;
     if (params.vehicle)
         this.vehicle = params.vehicle;
     if (params.weighting)
         this.weighting = params.weighting;
-    // REMOVE_IN 0.3
-    if (params.algoType)
-        this.weighting = params.algoType;
     if (params.algorithm)
         this.algorithm = params.algorithm;
     if (params.locale)
         this.locale = params.locale;
 
-    this.handleBoolean("doZoom", params);
-    this.handleBoolean("instructions", params);
-    this.handleBoolean("encodedPolyline", params);
+    if ('do_zoom' in params)
+        this.do_zoom = params.do_zoom;
+    if ('instructions' in params)
+        this.instructions = params.instructions;
+    if ('points_encoded' in params)
+        this.points_encoded = params.points_encoded;
+
+    this.elevation = false;
+    var featureSet = this.features[this.vehicle];
+    if (featureSet && featureSet.elevation) {
+        if ('elevation' in params)
+            this.elevation = params.elevation;
+        else
+            this.elevation = true;
+    }
 
     if (params.q) {
         var qStr = params.q;
@@ -75,7 +371,7 @@ GHRequest.prototype.init = function(params) {
             var points = qStr.split("p:");
             for (var i = 0; i < points.length; i++) {
                 var str = points[i].trim();
-                if (str.length == 0)
+                if (str.length === 0)
                     continue;
 
                 params.point.push(str);
@@ -84,55 +380,96 @@ GHRequest.prototype.init = function(params) {
     }
 };
 
-GHRequest.prototype.handleBoolean = function(key, params) {
-    if (key in params)
-        this.doZoom = params[key] == "true" || params[key] == true;
+GHRequest.prototype.initVehicle = function (vehicle) {
+    this.vehicle = vehicle;
+    var featureSet = this.features[this.vehicle];
+    if (featureSet && featureSet.elevation)
+        this.elevation = true;
+    else
+        this.elevation = false;
+};
+
+GHRequest.prototype.hasElevation = function () {
+    return this.elevation;
+};
+
+GHRequest.prototype.createGeocodeURL = function (host, prevIndex) {
+    var tmpHost = this.host;
+    if (host)
+        tmpHost = host;
+
+    var path = this.createPath(tmpHost + "/geocode?limit=6&type=" + this.dataType + "&key=" + this.key);
+    if (prevIndex >= 0 && prevIndex < this.route.size()) {
+        var point = this.route.getIndex(prevIndex);
+        path += "&lat=" + point.lat + "&lon=" + point.lng;
+    }
+    return path;
+};
+
+GHRequest.prototype.createURL = function () {
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=" + this.dataType + "&key=" + this.key);
 };
 
-GHRequest.prototype.createURL = function(demoUrl) {
-    return this.createPath(this.host + "/api/route?" + demoUrl + "&type=" + this.dataType);
+GHRequest.prototype.createGPXURL = function () {
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=gpx&key=" + this.key);
 };
 
-GHRequest.prototype.createGPXURL = function() {
-    // use points instead of strings
-    var str = "point=" + encodeURIComponent(this.from.toString()) + "&point=" + encodeURIComponent(this.to.toString());
-    return this.createPath(this.host + "/api/route?" + str + "&type=gpx");
+GHRequest.prototype.createHistoryURL = function () {
+    return this.createPath("?" + this.createPointParams(true));
 };
 
-GHRequest.prototype.createFullURL = function() {
-    var str = "?point=" + encodeURIComponent(this.from.input) + "&point=" + encodeURIComponent(this.to.input);
-    return this.createPath(str);
+GHRequest.prototype.createPointParams = function (useRawInput) {
+    var str = "", point, i, l;
+
+    for (i = 0, l = this.route.size(); i < l; i++) {
+        point = this.route.getIndex(i);
+        if (i > 0)
+            str += "&";
+        if (useRawInput)
+            str += "point=" + encodeURIComponent(point.input);
+        else
+            str += "point=" + encodeURIComponent(point.toString());
+    }
+    return (str);
 };
 
-GHRequest.prototype.createPath = function(url) {
-    if (this.vehicle && this.vehicle != "car")
+GHRequest.prototype.createPath = function (url) {
+    if (this.vehicle && this.vehicle !== "car")
         url += "&vehicle=" + this.vehicle;
     // fastest or shortest
-    if (this.weighting && this.weighting != "fastest")
+    if (this.weighting && this.weighting !== "fastest")
         url += "&weighting=" + this.weighting;
-    if (this.locale && this.locale != "en")
+    if (this.locale && this.locale !== "en")
         url += "&locale=" + this.locale;
     // dijkstra, dijkstrabi, astar, astarbi
-    if (this.algorithm && this.algorithm != "dijkstrabi")
+    if (this.algorithm && this.algorithm !== "dijkstrabi")
         url += "&algorithm=" + this.algorithm;
+    if (this.way_point_max_distance !== 1)
+        url += "&way_point_max_distance=" + this.way_point_max_distance;
     if (!this.instructions)
         url += "&instructions=false";
-    if (!this.encodedPolyline)
-        url += "&encodedPolyline=false";
-    if (this.minPathPrecision != 1)
-        url += "&minPathPrecision=" + this.minPathPrecision;
+    if (!this.points_encoded)
+        url += "&points_encoded=false";
+
+    if (this.elevation)
+        url += "&elevation=true";
     if (this.debug)
         url += "&debug=true";
+
+    for (var key in this.api_params) {
+        url += "&" + key + "=" + this.api_params[key];
+    }
     return url;
-}
+};
 
-function decodePath(encoded, geoJson) {
-    var start = new Date().getTime();
+function decodePath(encoded, is3D) {
+    // var start = new Date().getTime();
     var len = encoded.length;
     var index = 0;
     var array = [];
     var lat = 0;
     var lng = 0;
+    var ele = 0;
 
     while (index < len) {
         var b;
@@ -156,42 +493,59 @@ function decodePath(encoded, geoJson) {
         var deltaLon = ((result & 1) ? ~(result >> 1) : (result >> 1));
         lng += deltaLon;
 
-        if (geoJson)
+        if (is3D) {
+            // elevation
+            shift = 0;
+            result = 0;
+            do
+            {
+                b = encoded.charCodeAt(index++) - 63;
+                result |= (b & 0x1f) << shift;
+                shift += 5;
+            } while (b >= 0x20);
+            var deltaEle = ((result & 1) ? ~(result >> 1) : (result >> 1));
+            ele += deltaEle;
+            array.push([lng * 1e-5, lat * 1e-5, ele / 100]);
+        } else
             array.push([lng * 1e-5, lat * 1e-5]);
-        else
-            array.push([lat * 1e-5, lng * 1e-5]);
     }
-    var end = new Date().getTime();
-    console.log("decoded " + len + " coordinates in " + ((end - start) / 1000) + "s");
+    // var end = new Date().getTime();
+    // console.log("decoded " + len + " coordinates in " + ((end - start) / 1000) + "s");
     return array;
 }
 
-GHRequest.prototype.doRequest = function(url, callback) {
-    var tmpEncodedPolyline = this.encodedPolyline;
+GHRequest.prototype.doRequest = function (url, callback) {
+    var that = this;
     $.ajax({
-        "timeout": 30000,
-        "url": url,
-        "success": function(json) {
-            if (tmpEncodedPolyline && json.route) {
-                // convert encoded polyline stuff to normal json
-                if (json.route.coordinates) {
-                    var tmpArray = decodePath(json.route.coordinates, true);
-                    json.route.coordinates = null;
-                    json.route.data = {
-                        "type": "LineString",
-                        "coordinates": tmpArray
-                    };
-                } else
-                    console.log("something wrong on server? wrong server version? as we have encodedPolyline=" + tmpEncodedPolyline + " but no encoded data was return?");
+        timeout: 30000,
+        url: url,
+        success: function (json) {
+            if (json.paths) {
+                for (var i = 0; i < json.paths.length; i++) {
+                    var path = json.paths[i];
+                    // convert encoded polyline to geo json
+                    if (path.points_encoded) {
+                        var tmpArray = decodePath(path.points, that.hasElevation());
+                        path.points = {
+                            "type": "LineString",
+                            "coordinates": tmpArray
+                        };
+                    }
+                }
             }
             callback(json);
         },
-        "error": function(err) {
+        error: function (err) {
+            // problematic: this callback is not invoked when using JSONP!
+            // http://stackoverflow.com/questions/19035557/jsonp-request-error-handling
             var msg = "API did not respond! ";
-            if (err && err.statusText && err.statusText != "OK")
+            if (err && err.responseText && err.responseText.indexOf('{') >= 0) {
+                var jsonError = JSON.parse(err.responseText);
+                msg += jsonError.message;
+            } else if (err && err.statusText && err.statusText !== "OK")
                 msg += err.statusText;
 
-            console.log(msg + " " + JSON.stringify(err));
+            log(msg + " " + JSON.stringify(err));
             var details = "Error for " + url;
             var json = {
                 "info": {
@@ -203,72 +557,100 @@ GHRequest.prototype.doRequest = function(url, callback) {
             };
             callback(json);
         },
-        "type": "GET",
-        "dataType": this.dataType
+        type: "GET",
+        dataType: this.dataType,
+        crossDomain: true
     });
 };
 
-GHRequest.prototype.getInfo = function() {
-    var url = this.host + "/api/info?type=" + this.dataType;
-    console.log(url);
+GHRequest.prototype.getInfo = function () {
+    var url = this.host + "/info?type=" + this.dataType + "&key=" + this.key;
+    log(url);
     return $.ajax({
-        "url": url,
-        "timeout": 3000,
-        "type": "GET",
-        "dataType": this.dataType
+        url: url,
+        timeout: 3000,
+        type: "GET",
+        dataType: this.dataType,
+        crossDomain: true
     });
 };
 
-GHInput = function(str) {
-    // either text or coordinates
-    this.input = str;
-    try {
-        var index = str.indexOf(",");
-        if (index >= 0) {
-            this.lat = round(parseFloat(str.substr(0, index)));
-            this.lng = round(parseFloat(str.substr(index + 1)));
-            if (!isNaN(this.lat) && !isNaN(this.lng)) {
-                this.input = this.toString();
-            } else {
-                this.lat = false;
-                this.lng = false;
-            }
-        }
-    } catch (ex) {
-    }
+GHInput = function (input) {
+    this.set(input);
+};
+
+GHInput.isObject = function (value) {
+    var stringValue = Object.prototype.toString.call(value);
+    return (stringValue.toLowerCase() === "[object object]");
 };
 
-GHInput.prototype.isResolved = function() {
-    return this.lat && this.lng;
+GHInput.isString = function (value) {
+    var stringValue = Object.prototype.toString.call(value);
+    return (stringValue.toLowerCase() === "[object string]");
 };
 
-GHInput.prototype.setCoord = function(lat, lng) {
+GHInput.prototype.isResolved = function () {
+    return !isNaN(this.lat) && !isNaN(this.lng);
+};
+
+GHInput.prototype.setCoord = function (lat, lng) {
     this.lat = round(lat);
     this.lng = round(lng);
-    this.input = this.lat + "," + this.lng;
+    this.input = this.toString();
+};
+
+GHInput.prototype.setUnresolved = function () {
+    this.lat = undefined;
+    this.lng = undefined;
+};
+
+GHInput.prototype.set = function (strOrObject) {
+    // either text or coordinates or object
+    this.input = strOrObject;
+    // reset to unresolved
+
+
+    if (GHInput.isObject(strOrObject)) {
+        this.setCoord(strOrObject.lat, strOrObject.lng);
+    } else if (GHInput.isString(strOrObject)) {
+        var index = strOrObject.indexOf(",");
+        if (index >= 0) {
+            this.lat = round(parseFloat(strOrObject.substr(0, index)));
+            this.lng = round(parseFloat(strOrObject.substr(index + 1)));
+
+            if (this.isResolved()) {
+                this.input = this.toString();
+            } else {
+                this.setUnresolved();
+            }
+        } else {
+            this.setUnresolved();
+        }
+    }
 };
 
-GHInput.prototype.toString = function() {
-    if (this.lat && this.lng)
+GHInput.prototype.toString = function () {
+    if (this.lat !== undefined && this.lng !== undefined)
         return this.lat + "," + this.lng;
     return undefined;
 };
 
-GHRequest.prototype.setLocale = function(locale) {
+GHRequest.prototype.setLocale = function (locale) {
     if (locale)
         this.locale = locale;
 };
 
-GHRequest.prototype.fetchTranslationMap = function(urlLocaleParam) {
+GHRequest.prototype.fetchTranslationMap = function (urlLocaleParam) {
     if (!urlLocaleParam)
         // let servlet figure out the locale from the Accept-Language header
         urlLocaleParam = "";
-    var url = this.host + "/api/i18n/" + urlLocaleParam + "?type=" + this.dataType;
-    console.log(url);
+    var url = this.host + "/i18n/" + urlLocaleParam + "?type=" + this.dataType + "&key=" + this.key;
+    log(url);
     return $.ajax({
-        "url": url,
-        "timeout": 3000,
-        "type": "GET",
-        "dataType": this.dataType
+        url: url,
+        timeout: 3000,
+        type: "GET",
+        dataType: this.dataType,
+        crossDomain: true
     });
 };
\ No newline at end of file
diff --git a/web/src/main/webapp/js/jquery-1.10.2.min.js b/web/src/main/webapp/js/jquery-1.10.2.min.js
deleted file mode 100644
index da4170647d..0000000000
--- a/web/src/main/webapp/js/jquery-1.10.2.min.js
+++ /dev/null
@@ -1,6 +0,0 @@
-/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
-//@ sourceMappingURL=jquery-1.10.2.min.map
-*/
-(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f="1.10.2",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=/\S+/g,C=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,E=/^[\],:{}\s]*$/,S=/(?:^|:|,)(?:\s*\[)+/g,A=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,j=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,D=/^-ms-/,L=/-([\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||"load"===e.type||"complete"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener("DOMContentLoaded",q,!1),e.removeEventListener("load",q,!1)):(a.detachEvent("onreadystatechange",q),e.detachEvent("onload",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray||function(e){return"array"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?c[y.call(e)]||"object":typeof e},isPlainObject:function(e){var n;if(!e||"object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,"constructor")&&!v.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,"@").replace(j,"]").replace(S,"")))?Function("return "+n)():(x.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||x.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,"ms-").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call("\ufeff\u00a0")?function(e){return null==e?"":b.call(e)}:function(e){return null==e?"":(e+"").replace(C,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if("object"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),"complete"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener("DOMContentLoaded",q,!1),e.addEventListener("load",q,!1);else{a.attachEvent("onreadystatechange",q),e.attachEvent("onload",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){c["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b="sizzle"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",P="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=R.replace("w","w#"),$="\\["+P+"*("+R+")"+P+"*(?:([*^$|!~]?=)"+P+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+P+"*\\]",I=":("+R+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+P+"+|((?:^|[^\\\\])(?:\\\\.)*)"+P+"+$","g"),X=RegExp("^"+P+"*,"+P+"*"),U=RegExp("^"+P+"*([>+~]|"+P+")"+P+"*"),V=RegExp(P+"*[+~]"),Y=RegExp("="+P+"*([^\\]'\"]*)"+P+"*\\]","g"),J=RegExp(I),G=RegExp("^"+W+"$"),Q={ID:RegExp("^#("+R+")"),CLASS:RegExp("^\\.("+R+")"),TAG:RegExp("^("+R.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+P+"*(even|odd|(([+-]|)(\\d*)n|)"+P+"*(?:([+-]|)"+P+"*(\\d+)|))"+P+"*\\)|)","i"),bool:RegExp("^(?:"+B+")$","i"),needsContext:RegExp("^"+P+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+P+"*((?:-\\d)?\\d*)"+P+"*\\)|)(?=[^-]|$)","i")},K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\d$/i,nt=/'|\\/g,rt=RegExp("\\\\([\\da-f]{1,6}"+P+"?|("+P+")|.)","ig"),it=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||"string"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&"object"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute("id"))?m=d.replace(nt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(",")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split("|"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent("onbeforeunload",function(){p()}),r.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute("id")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||g.push("\\["+P+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||g.push(":checked")}),ut(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&g.push("[*^$]="+P+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||g.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),g.push(",.*:")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,"div"),y.call(e,"[s!='']:x"),m.push("!=",I)}),g=g.length&&RegExp(g.join("|")),m=m.length&&RegExp(m.join("|")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,"='$1']"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||"").replace(rt,it),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+" "];return t||(t=RegExp("(^|"+P+")"+e+"("+P+"|$)"))&&N(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[b]?r(t):r.length>1?(n=[e,e,"",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,"$1"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z," ")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&"parentNode"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+" "+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[" "],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG("*",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+" "];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&"ID"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split("").sort(A).join("")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||ct("type|href|height|width",function(e,n,r){return r?t:e.getAttribute(n,"type"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||ct("value",function(e,n,r){return r||"input"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[":"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*")||[],r=d.getElementsByTagName("a")[0],!r||!r.style||!n.length)return t;s=a.createElement("select"),u=s.appendChild(a.createElement("option")),o=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t.getSetAttribute="t"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName("tbody").length,t.htmlSerialize=!!d.getElementsByTagName("link").length,t.style=/top/.test(r.getAttribute("style")),t.hrefNormalized="/a"===r.getAttribute("href"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement("form").enctype,t.html5Clone="<:nav></:nav>"!==a.createElement("nav").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement("input"),o.setAttribute("value",""),t.input=""===o.getAttribute("value"),o.value="t",o.setAttribute("type","radio"),t.radioValue="t"===o.value,o.setAttribute("checked","t"),o.setAttribute("name","t"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast="0"!==f,x(function(){var n,r,o,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",l=a.getElementsByTagName("body")[0];l&&(n=a.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",l.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=d.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(a.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t
-}({});var B=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||"string"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),("object"==typeof n||"function"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),"string"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(" ")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,"parsedAttrs"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf("data-")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,"parsedAttrs",!0)}return o}return"object"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(P,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if(("data"!==t||!x.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks("once memory").add(function(){x._removeData(e,t+"queue"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=x._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\t\r\n\f]/g,V=/\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||"boolean"===n)&&(this.className&&x._data(this,"__className__",this.className),this.className=this.className||e===!1?"":x._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(U," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o="":"number"==typeof o?o+="":x.isArray(o)&&(o=x.map(o,function(e){return null==e?"":e+""})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(V,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,"value");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&"get"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&"set"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+""),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase("default-"+n)]=e[r]=!1:x.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,"tabindex");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase("default-"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase("default-"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,"input")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&""!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,""===t?!1:t,n)}},x.each(["width","height"],function(e,n){x.attrHooks[n]={set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}}})),x.support.hrefNormalized||x.each(["href","src"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype="encoding"),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(T)||[""],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||"").match(T)||[""],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,"events"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,"type")?n.type:n,m=v.call(n,"namespace")?n.namespace.split("."):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),l=0>g.indexOf(":")&&"on"+g,n=n[x.expando]?n:new x.Event(g,"object"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,"events")||{})[n.type]&&x._data(u,"handle"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,"events")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},click:{trigger:function(){return x.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,"form")?!1:(x.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=x.nodeName(n,"input")||x.nodeName(n,"button")?n.form:t;r&&!x._data(r,"submitBubbles")&&(x.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),x._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,"form")?!1:(x.event.remove(this,"._submit"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(x.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate("change",this,e,!0)})),!1):(x.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,"changeBubbles")&&(x.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate("change",this.parentNode,e,!0)}),x._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,"._change"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\[\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,"string"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:x.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(a),Dt=jt.appendChild(a.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||"string"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,"script"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,"script"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||"")&&!x._data(i,"globalEval")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||"").replace(St,"")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function Ht(e){return e.type=(null!==x.find.attr(e,"type"))+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,"globalEval",!t||x._data(t[r],"globalEval"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,"script"),r.length>0&&_t(r,!l&&Ft(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),l=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o="table"!==l||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],"tbody")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),"script"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);
-u[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+w+")(.*)$","i"),Yt=RegExp("^("+w+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+w+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=x._data(r,"olddisplay",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&x._data(r,"olddisplay",i?n:x.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":x.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||x.cssNumber[l]||(r+="px"),x.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(u[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(""!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left="fontSize"===n?"1em":l,l=u.pixelLeft+"px",u.left=i,a&&(o.left=a)),""===l?"auto":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=x.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=x.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=x.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=x.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),"none"!==n&&n||(Pt=(Pt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,"display"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===x.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+"px":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||x.css(e,"display"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var mn,yn,vn=x.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=o.href}catch(Ln){yn=a.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return"string"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o["*"]&&s("*")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(" ");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&x.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?x("<div>").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks("once memory"),m=p.statusCode||{},y={},v={},b=0,w="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||"*").toLowerCase().match(T)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?"80":"443"))===(mn[3]||("http:"===mn[1]?"80":"443")))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader("If-Modified-Since",x.lastModified[o]),x.etag[o]&&C.setRequestHeader("If-None-Match",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",p.contentType),C.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w="abort";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger("ajaxSend",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort("timeout")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||"",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader("Last-Modified"),T&&(x.lastModified[o]=T),T=C.getResponseHeader("etag"),T&&(x.etag[o]=T)),204===e||"HEAD"===p.type?N="nocontent":304===e?N="notmodified":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+"",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?"ajaxSuccess":"ajaxError",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger("ajaxComplete",[C,p]),--x.active||x.event.trigger("ajaxStop")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,n){return x.get(e,t,n,"script")}}),x.each(["get","post"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+" "+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(a=u[l+" "+o]||u["* "+o],!a)for(i in u)if(s=i.split(" "),s[1]===o&&(a=u[l+" "+s[0]]||u["* "+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(p){return{state:"parsererror",error:a?p:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),x.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=a.head||x("head")[0]||a.documentElement;return{send:function(t,i){n=a.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Fn.pop()||x.expando+"_"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return l||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||x.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&"withCredentials"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),"string"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),a=(x.cssNumber[e]||"px"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||".5",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn["*"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,"fxshow");n.queue||(s=x._queueHooks(e,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,"fx").length||s.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(x.support.inlineBlockNeedsLayout&&"inline"!==ln(e.nodeName)?p.zoom=1:p.display="inline-block")),n.overflow&&(p.overflow="hidden",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?"hidden"in d&&(f=d.hidden):d=x._data(e,"fxshow",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=x._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,"position");"static"===r&&(e.style.position="relative");var i=x(e),o=i.offset(),a=x.css(e,"top"),s=x.css(e,"left"),l=("absolute"===r||"fixed"===r)&&x.inArray("auto",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),"using"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===x.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(n=e.offset()),n.top+=x.css(e[0],"borderTopWidth",!0),n.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-x.css(r,"marginTop",!0),left:t.left-n.left-x.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:"height",Width:"width"},function(e,n){x.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}))})(window);
diff --git a/web/src/main/webapp/js/jquery-2.1.0.min.js b/web/src/main/webapp/js/jquery-2.1.0.min.js
new file mode 100644
index 0000000000..cbe6abe59a
--- /dev/null
+++ b/web/src/main/webapp/js/jquery-2.1.0.min.js
@@ -0,0 +1,4 @@
+/*! jQuery v2.1.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
+!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k="".trim,l={},m=a.document,n="2.1.0",o=function(a,b){return new o.fn.init(a,b)},p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};o.fn=o.prototype={jquery:n,constructor:o,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=o.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return o.each(this,a,b)},map:function(a){return this.pushStack(o.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},o.extend=o.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||o.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(o.isPlainObject(d)||(e=o.isArray(d)))?(e?(e=!1,f=c&&o.isArray(c)?c:[]):f=c&&o.isPlainObject(c)?c:{},g[b]=o.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},o.extend({expando:"jQuery"+(n+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===o.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return a-parseFloat(a)>=0},isPlainObject:function(a){if("object"!==o.type(a)||a.nodeType||o.isWindow(a))return!1;try{if(a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(b){return!1}return!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=o.trim(a),a&&(1===a.indexOf("use strict")?(b=m.createElement("script"),b.text=a,m.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":k.call(a)},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?o.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),o.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||o.guid++,f):void 0},now:Date.now,support:l}),o.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=o.type(a);return"function"===c||o.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s="sizzle"+-new Date,t=a.document,u=0,v=0,w=eb(),x=eb(),y=eb(),z=function(a,b){return a===b&&(j=!0),0},A="undefined",B=1<<31,C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=D.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",M=L.replace("w","w#"),N="\\["+K+"*("+L+")"+K+"*(?:([*^$|!~]?=)"+K+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+M+")|)|)"+K+"*\\]",O=":("+L+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+N.replace(3,8)+")*)|.*)\\)|)",P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(O),U=new RegExp("^"+M+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L.replace("w","w*")+")"),ATTR:new RegExp("^"+N),PSEUDO:new RegExp("^"+O),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=/'|\\/g,ab=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),bb=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)};try{G.apply(D=H.call(t.childNodes),t.childNodes),D[t.childNodes.length].nodeType}catch(cb){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function db(a,b,d,e){var f,g,h,i,j,m,p,q,u,v;if((b?b.ownerDocument||b:t)!==l&&k(b),b=b||l,d=d||[],!a||"string"!=typeof a)return d;if(1!==(i=b.nodeType)&&9!==i)return[];if(n&&!e){if(f=Z.exec(a))if(h=f[1]){if(9===i){if(g=b.getElementById(h),!g||!g.parentNode)return d;if(g.id===h)return d.push(g),d}else if(b.ownerDocument&&(g=b.ownerDocument.getElementById(h))&&r(b,g)&&g.id===h)return d.push(g),d}else{if(f[2])return G.apply(d,b.getElementsByTagName(a)),d;if((h=f[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(h)),d}if(c.qsa&&(!o||!o.test(a))){if(q=p=s,u=b,v=9===i&&a,1===i&&"object"!==b.nodeName.toLowerCase()){m=ob(a),(p=b.getAttribute("id"))?q=p.replace(_,"\\$&"):b.setAttribute("id",q),q="[id='"+q+"'] ",j=m.length;while(j--)m[j]=q+pb(m[j]);u=$.test(a)&&mb(b.parentNode)||b,v=m.join(",")}if(v)try{return G.apply(d,u.querySelectorAll(v)),d}catch(w){}finally{p||b.removeAttribute("id")}}}return xb(a.replace(P,"$1"),b,d,e)}function eb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function fb(a){return a[s]=!0,a}function gb(a){var b=l.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function hb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function ib(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||B)-(~a.sourceIndex||B);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function jb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function kb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function lb(a){return fb(function(b){return b=+b,fb(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function mb(a){return a&&typeof a.getElementsByTagName!==A&&a}c=db.support={},f=db.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},k=db.setDocument=function(a){var b,e=a?a.ownerDocument||a:t,g=e.defaultView;return e!==l&&9===e.nodeType&&e.documentElement?(l=e,m=e.documentElement,n=!f(e),g&&g!==g.top&&(g.addEventListener?g.addEventListener("unload",function(){k()},!1):g.attachEvent&&g.attachEvent("onunload",function(){k()})),c.attributes=gb(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=gb(function(a){return a.appendChild(e.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(e.getElementsByClassName)&&gb(function(a){return a.innerHTML="<div class='a'></div><div class='a i'></div>",a.firstChild.className="i",2===a.getElementsByClassName("i").length}),c.getById=gb(function(a){return m.appendChild(a).id=s,!e.getElementsByName||!e.getElementsByName(s).length}),c.getById?(d.find.ID=function(a,b){if(typeof b.getElementById!==A&&n){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ab,bb);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ab,bb);return function(a){var c=typeof a.getAttributeNode!==A&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return typeof b.getElementsByTagName!==A?b.getElementsByTagName(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return typeof b.getElementsByClassName!==A&&n?b.getElementsByClassName(a):void 0},p=[],o=[],(c.qsa=Y.test(e.querySelectorAll))&&(gb(function(a){a.innerHTML="<select t=''><option selected=''></option></select>",a.querySelectorAll("[t^='']").length&&o.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||o.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll(":checked").length||o.push(":checked")}),gb(function(a){var b=e.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&o.push("name"+K+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||o.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),o.push(",.*:")})),(c.matchesSelector=Y.test(q=m.webkitMatchesSelector||m.mozMatchesSelector||m.oMatchesSelector||m.msMatchesSelector))&&gb(function(a){c.disconnectedMatch=q.call(a,"div"),q.call(a,"[s!='']:x"),p.push("!=",O)}),o=o.length&&new RegExp(o.join("|")),p=p.length&&new RegExp(p.join("|")),b=Y.test(m.compareDocumentPosition),r=b||Y.test(m.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},z=b?function(a,b){if(a===b)return j=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===e||a.ownerDocument===t&&r(t,a)?-1:b===e||b.ownerDocument===t&&r(t,b)?1:i?I.call(i,a)-I.call(i,b):0:4&d?-1:1)}:function(a,b){if(a===b)return j=!0,0;var c,d=0,f=a.parentNode,g=b.parentNode,h=[a],k=[b];if(!f||!g)return a===e?-1:b===e?1:f?-1:g?1:i?I.call(i,a)-I.call(i,b):0;if(f===g)return ib(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)k.unshift(c);while(h[d]===k[d])d++;return d?ib(h[d],k[d]):h[d]===t?-1:k[d]===t?1:0},e):l},db.matches=function(a,b){return db(a,null,null,b)},db.matchesSelector=function(a,b){if((a.ownerDocument||a)!==l&&k(a),b=b.replace(S,"='$1']"),!(!c.matchesSelector||!n||p&&p.test(b)||o&&o.test(b)))try{var d=q.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return db(b,l,null,[a]).length>0},db.contains=function(a,b){return(a.ownerDocument||a)!==l&&k(a),r(a,b)},db.attr=function(a,b){(a.ownerDocument||a)!==l&&k(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!n):void 0;return void 0!==f?f:c.attributes||!n?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},db.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},db.uniqueSort=function(a){var b,d=[],e=0,f=0;if(j=!c.detectDuplicates,i=!c.sortStable&&a.slice(0),a.sort(z),j){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return i=null,a},e=db.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=db.selectors={cacheLength:50,createPseudo:fb,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ab,bb),a[3]=(a[4]||a[5]||"").replace(ab,bb),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||db.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&db.error(a[0]),a},PSEUDO:function(a){var b,c=!a[5]&&a[2];return V.CHILD.test(a[0])?null:(a[3]&&void 0!==a[4]?a[2]=a[4]:c&&T.test(c)&&(b=ob(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ab,bb).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=w[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&w(a,function(a){return b.test("string"==typeof a.className&&a.className||typeof a.getAttribute!==A&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=db.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),t=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&t){k=q[s]||(q[s]={}),j=k[a]||[],n=j[0]===u&&j[1],m=j[0]===u&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[u,n,m];break}}else if(t&&(j=(b[s]||(b[s]={}))[a])&&j[0]===u)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(t&&((l[s]||(l[s]={}))[a]=[u,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||db.error("unsupported pseudo: "+a);return e[s]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?fb(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I.call(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:fb(function(a){var b=[],c=[],d=g(a.replace(P,"$1"));return d[s]?fb(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:fb(function(a){return function(b){return db(a,b).length>0}}),contains:fb(function(a){return function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:fb(function(a){return U.test(a||"")||db.error("unsupported lang: "+a),a=a.replace(ab,bb).toLowerCase(),function(b){var c;do if(c=n?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===m},focus:function(a){return a===l.activeElement&&(!l.hasFocus||l.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:lb(function(){return[0]}),last:lb(function(a,b){return[b-1]}),eq:lb(function(a,b,c){return[0>c?c+b:c]}),even:lb(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:lb(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:lb(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:lb(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=jb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=kb(b);function nb(){}nb.prototype=d.filters=d.pseudos,d.setFilters=new nb;function ob(a,b){var c,e,f,g,h,i,j,k=x[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=Q.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?db.error(a):x(a,i).slice(0)}function pb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function qb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=v++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[u,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[s]||(b[s]={}),(h=i[d])&&h[0]===u&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function rb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function sb(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function tb(a,b,c,d,e,f){return d&&!d[s]&&(d=tb(d)),e&&!e[s]&&(e=tb(e,f)),fb(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||wb(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:sb(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=sb(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I.call(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=sb(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ub(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],i=g||d.relative[" "],j=g?1:0,k=qb(function(a){return a===b},i,!0),l=qb(function(a){return I.call(b,a)>-1},i,!0),m=[function(a,c,d){return!g&&(d||c!==h)||((b=c).nodeType?k(a,c,d):l(a,c,d))}];f>j;j++)if(c=d.relative[a[j].type])m=[qb(rb(m),c)];else{if(c=d.filter[a[j].type].apply(null,a[j].matches),c[s]){for(e=++j;f>e;e++)if(d.relative[a[e].type])break;return tb(j>1&&rb(m),j>1&&pb(a.slice(0,j-1).concat({value:" "===a[j-2].type?"*":""})).replace(P,"$1"),c,e>j&&ub(a.slice(j,e)),f>e&&ub(a=a.slice(e)),f>e&&pb(a))}m.push(c)}return rb(m)}function vb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,i,j,k){var m,n,o,p=0,q="0",r=f&&[],s=[],t=h,v=f||e&&d.find.TAG("*",k),w=u+=null==t?1:Math.random()||.1,x=v.length;for(k&&(h=g!==l&&g);q!==x&&null!=(m=v[q]);q++){if(e&&m){n=0;while(o=a[n++])if(o(m,g,i)){j.push(m);break}k&&(u=w)}c&&((m=!o&&m)&&p--,f&&r.push(m))}if(p+=q,c&&q!==p){n=0;while(o=b[n++])o(r,s,g,i);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=E.call(j));s=sb(s)}G.apply(j,s),k&&!f&&s.length>0&&p+b.length>1&&db.uniqueSort(j)}return k&&(u=w,h=t),r};return c?fb(f):f}g=db.compile=function(a,b){var c,d=[],e=[],f=y[a+" "];if(!f){b||(b=ob(a)),c=b.length;while(c--)f=ub(b[c]),f[s]?d.push(f):e.push(f);f=y(a,vb(e,d))}return f};function wb(a,b,c){for(var d=0,e=b.length;e>d;d++)db(a,b[d],c);return c}function xb(a,b,e,f){var h,i,j,k,l,m=ob(a);if(!f&&1===m.length){if(i=m[0]=m[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&c.getById&&9===b.nodeType&&n&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(ab,bb),b)||[])[0],!b)return e;a=a.slice(i.shift().value.length)}h=V.needsContext.test(a)?0:i.length;while(h--){if(j=i[h],d.relative[k=j.type])break;if((l=d.find[k])&&(f=l(j.matches[0].replace(ab,bb),$.test(i[0].type)&&mb(b.parentNode)||b))){if(i.splice(h,1),a=f.length&&pb(i),!a)return G.apply(e,f),e;break}}}return g(a,m)(f,b,!n,e,$.test(a)&&mb(b.parentNode)||b),e}return c.sortStable=s.split("").sort(z).join("")===s,c.detectDuplicates=!!j,k(),c.sortDetached=gb(function(a){return 1&a.compareDocumentPosition(l.createElement("div"))}),gb(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||hb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&gb(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||hb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),gb(function(a){return null==a.getAttribute("disabled")})||hb(J,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),db}(a);o.find=t,o.expr=t.selectors,o.expr[":"]=o.expr.pseudos,o.unique=t.uniqueSort,o.text=t.getText,o.isXMLDoc=t.isXML,o.contains=t.contains;var u=o.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(o.isFunction(b))return o.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return o.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return o.filter(b,a,c);b=o.filter(b,a)}return o.grep(a,function(a){return g.call(b,a)>=0!==c})}o.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?o.find.matchesSelector(d,a)?[d]:[]:o.find.matches(a,o.grep(b,function(a){return 1===a.nodeType}))},o.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(o(a).filter(function(){for(b=0;c>b;b++)if(o.contains(e[b],this))return!0}));for(b=0;c>b;b++)o.find(a,e[b],d);return d=this.pushStack(c>1?o.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?o(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=o.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof o?b[0]:b,o.merge(this,o.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:m,!0)),v.test(c[1])&&o.isPlainObject(b))for(c in b)o.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=m.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=m,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):o.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(o):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),o.makeArray(a,this))};A.prototype=o.fn,y=o(m);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};o.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&o(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),o.fn.extend({has:function(a){var b=o(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(o.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?o(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&o.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?o.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(o(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(o.unique(o.merge(this.get(),o(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}o.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return o.dir(a,"parentNode")},parentsUntil:function(a,b,c){return o.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return o.dir(a,"nextSibling")},prevAll:function(a){return o.dir(a,"previousSibling")},nextUntil:function(a,b,c){return o.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return o.dir(a,"previousSibling",c)},siblings:function(a){return o.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return o.sibling(a.firstChild)},contents:function(a){return a.contentDocument||o.merge([],a.childNodes)}},function(a,b){o.fn[a]=function(c,d){var e=o.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=o.filter(d,e)),this.length>1&&(C[a]||o.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return o.each(a.match(E)||[],function(a,c){b[c]=!0}),b}o.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):o.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){o.each(b,function(b,c){var d=o.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&o.each(arguments,function(a,b){var c;while((c=o.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?o.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},o.extend({Deferred:function(a){var b=[["resolve","done",o.Callbacks("once memory"),"resolved"],["reject","fail",o.Callbacks("once memory"),"rejected"],["notify","progress",o.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return o.Deferred(function(c){o.each(b,function(b,f){var g=o.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&o.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?o.extend(a,d):d}},e={};return d.pipe=d.then,o.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&o.isFunction(a.promise)?e:0,g=1===f?a:o.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&o.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;o.fn.ready=function(a){return o.ready.promise().done(a),this},o.extend({isReady:!1,readyWait:1,holdReady:function(a){a?o.readyWait++:o.ready(!0)},ready:function(a){(a===!0?--o.readyWait:o.isReady)||(o.isReady=!0,a!==!0&&--o.readyWait>0||(H.resolveWith(m,[o]),o.fn.trigger&&o(m).trigger("ready").off("ready")))}});function I(){m.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),o.ready()}o.ready.promise=function(b){return H||(H=o.Deferred(),"complete"===m.readyState?setTimeout(o.ready):(m.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},o.ready.promise();var J=o.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===o.type(c)){e=!0;for(h in c)o.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,o.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(o(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};o.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=o.expando+Math.random()}K.uid=1,K.accepts=o.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,o.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(o.isEmptyObject(f))o.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,o.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{o.isArray(b)?d=b.concat(b.map(o.camelCase)):(e=o.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!o.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?o.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}o.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),o.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;
+while(c--)d=g[c].name,0===d.indexOf("data-")&&(d=o.camelCase(d.slice(5)),P(f,d,e[d]));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=o.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),o.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||o.isArray(c)?d=L.access(a,b,o.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=o.queue(a,b),d=c.length,e=c.shift(),f=o._queueHooks(a,b),g=function(){o.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:o.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),o.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?o.queue(this[0],a):void 0===b?this:this.each(function(){var c=o.queue(this,a,b);o._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&o.dequeue(this,a)})},dequeue:function(a){return this.each(function(){o.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=o.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===o.css(a,"display")||!o.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=m.createDocumentFragment(),b=a.appendChild(m.createElement("div"));b.innerHTML="<input type='radio' checked='checked' name='t'/>",l.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",l.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";l.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return m.activeElement}catch(a){}}o.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=o.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof o!==U&&o.event.triggered!==b.type?o.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],n=q=h[1],p=(h[2]||"").split(".").sort(),n&&(l=o.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=o.event.special[n]||{},k=o.extend({type:n,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&o.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(n,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),o.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],n=q=h[1],p=(h[2]||"").split(".").sort(),n){l=o.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||o.removeEvent(a,n,r.handle),delete i[n])}else for(n in i)o.event.remove(a,n+b[j],c,d,!0);o.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,p=[d||m],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||m,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+o.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[o.expando]?b:new o.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:o.makeArray(c,[b]),n=o.event.special[q]||{},e||!n.trigger||n.trigger.apply(d,c)!==!1)){if(!e&&!n.noBubble&&!o.isWindow(d)){for(i=n.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||m)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:n.bindType||q,l=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),l&&l.apply(g,c),l=k&&g[k],l&&l.apply&&o.acceptData(g)&&(b.result=l.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||n._default&&n._default.apply(p.pop(),c)!==!1||!o.acceptData(d)||k&&o.isFunction(d[q])&&!o.isWindow(d)&&(h=d[k],h&&(d[k]=null),o.event.triggered=q,d[q](),o.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=o.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=o.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=o.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((o.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?o(e,this).index(i)>=0:o.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||m,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[o.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new o.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=m),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&o.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return o.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=o.extend(new o.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?o.event.trigger(e,null,b):o.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},o.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},o.Event=function(a,b){return this instanceof o.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.getPreventDefault&&a.getPreventDefault()?Z:$):this.type=a,b&&o.extend(this,b),this.timeStamp=a&&a.timeStamp||o.now(),void(this[o.expando]=!0)):new o.Event(a,b)},o.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z,this.stopPropagation()}},o.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){o.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!o.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),l.focusinBubbles||o.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){o.event.simulate(b,a.target,o.event.fix(a),!0)};o.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),o.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return o().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=o.guid++)),this.each(function(){o.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,o(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){o.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){o.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?o.event.trigger(a,b,c,!0):void 0}});var ab=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bb=/<([\w:]+)/,cb=/<|&#?\w+;/,db=/<(?:script|style|link)/i,eb=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/^$|\/(?:java|ecma)script/i,gb=/^true\/(.*)/,hb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ib={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ib.optgroup=ib.option,ib.tbody=ib.tfoot=ib.colgroup=ib.caption=ib.thead,ib.th=ib.td;function jb(a,b){return o.nodeName(a,"table")&&o.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function kb(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function lb(a){var b=gb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function mb(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function nb(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)o.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=o.extend({},h),M.set(b,i))}}function ob(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&o.nodeName(a,b)?o.merge([a],c):c}function pb(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}o.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=o.contains(a.ownerDocument,a);if(!(l.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||o.isXMLDoc(a)))for(g=ob(h),f=ob(a),d=0,e=f.length;e>d;d++)pb(f[d],g[d]);if(b)if(c)for(f=f||ob(a),g=g||ob(h),d=0,e=f.length;e>d;d++)nb(f[d],g[d]);else nb(a,h);return g=ob(h,"script"),g.length>0&&mb(g,!i&&ob(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,n=a.length;n>m;m++)if(e=a[m],e||0===e)if("object"===o.type(e))o.merge(l,e.nodeType?[e]:e);else if(cb.test(e)){f=f||k.appendChild(b.createElement("div")),g=(bb.exec(e)||["",""])[1].toLowerCase(),h=ib[g]||ib._default,f.innerHTML=h[1]+e.replace(ab,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;o.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===o.inArray(e,d))&&(i=o.contains(e.ownerDocument,e),f=ob(k.appendChild(e),"script"),i&&mb(f),c)){j=0;while(e=f[j++])fb.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f,g,h=o.event.special,i=0;void 0!==(c=a[i]);i++){if(o.acceptData(c)&&(f=c[L.expando],f&&(b=L.cache[f]))){if(d=Object.keys(b.events||{}),d.length)for(g=0;void 0!==(e=d[g]);g++)h[e]?o.event.remove(c,e):o.removeEvent(c,e,b.handle);L.cache[f]&&delete L.cache[f]}delete M.cache[c[M.expando]]}}}),o.fn.extend({text:function(a){return J(this,function(a){return void 0===a?o.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?o.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||o.cleanData(ob(c)),c.parentNode&&(b&&o.contains(c.ownerDocument,c)&&mb(ob(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(o.cleanData(ob(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return o.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!db.test(a)&&!ib[(bb.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(ab,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(o.cleanData(ob(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,o.cleanData(ob(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,k=this.length,m=this,n=k-1,p=a[0],q=o.isFunction(p);if(q||k>1&&"string"==typeof p&&!l.checkClone&&eb.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(k&&(c=o.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=o.map(ob(c,"script"),kb),g=f.length;k>j;j++)h=c,j!==n&&(h=o.clone(h,!0,!0),g&&o.merge(f,ob(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,o.map(f,lb),j=0;g>j;j++)h=f[j],fb.test(h.type||"")&&!L.access(h,"globalEval")&&o.contains(i,h)&&(h.src?o._evalUrl&&o._evalUrl(h.src):o.globalEval(h.textContent.replace(hb,"")))}return this}}),o.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){o.fn[a]=function(a){for(var c,d=[],e=o(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),o(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qb,rb={};function sb(b,c){var d=o(c.createElement(b)).appendTo(c.body),e=a.getDefaultComputedStyle?a.getDefaultComputedStyle(d[0]).display:o.css(d[0],"display");return d.detach(),e}function tb(a){var b=m,c=rb[a];return c||(c=sb(a,b),"none"!==c&&c||(qb=(qb||o("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qb[0].contentDocument,b.write(),b.close(),c=sb(a,b),qb.detach()),rb[a]=c),c}var ub=/^margin/,vb=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wb=function(a){return a.ownerDocument.defaultView.getComputedStyle(a,null)};function xb(a,b,c){var d,e,f,g,h=a.style;return c=c||wb(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||o.contains(a.ownerDocument,a)||(g=o.style(a,b)),vb.test(g)&&ub.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function yb(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d="padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",e=m.documentElement,f=m.createElement("div"),g=m.createElement("div");g.style.backgroundClip="content-box",g.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===g.style.backgroundClip,f.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",f.appendChild(g);function h(){g.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%",e.appendChild(f);var d=a.getComputedStyle(g,null);b="1%"!==d.top,c="4px"===d.width,e.removeChild(f)}a.getComputedStyle&&o.extend(l,{pixelPosition:function(){return h(),b},boxSizingReliable:function(){return null==c&&h(),c},reliableMarginRight:function(){var b,c=g.appendChild(m.createElement("div"));return c.style.cssText=g.style.cssText=d,c.style.marginRight=c.style.width="0",g.style.width="1px",e.appendChild(f),b=!parseFloat(a.getComputedStyle(c,null).marginRight),e.removeChild(f),g.innerHTML="",b}})}(),o.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var zb=/^(none|table(?!-c[ea]).+)/,Ab=new RegExp("^("+Q+")(.*)$","i"),Bb=new RegExp("^([+-])=("+Q+")","i"),Cb={position:"absolute",visibility:"hidden",display:"block"},Db={letterSpacing:0,fontWeight:400},Eb=["Webkit","O","Moz","ms"];function Fb(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Eb.length;while(e--)if(b=Eb[e]+c,b in a)return b;return d}function Gb(a,b,c){var d=Ab.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Hb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=o.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=o.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=o.css(a,"border"+R[f]+"Width",!0,e))):(g+=o.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=o.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ib(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wb(a),g="border-box"===o.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xb(a,b,f),(0>e||null==e)&&(e=a.style[b]),vb.test(e))return e;d=g&&(l.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Hb(a,b,c||(g?"border":"content"),d,f)+"px"}function Jb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",tb(d.nodeName)))):f[g]||(e=S(d),(c&&"none"!==c||!e)&&L.set(d,"olddisplay",e?c:o.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}o.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=o.camelCase(b),i=a.style;return b=o.cssProps[h]||(o.cssProps[h]=Fb(i,h)),g=o.cssHooks[b]||o.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Bb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(o.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||o.cssNumber[h]||(c+="px"),l.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]="",i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=o.camelCase(b);return b=o.cssProps[h]||(o.cssProps[h]=Fb(a.style,h)),g=o.cssHooks[b]||o.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xb(a,b,d)),"normal"===e&&b in Db&&(e=Db[b]),""===c||c?(f=parseFloat(e),c===!0||o.isNumeric(f)?f||0:e):e}}),o.each(["height","width"],function(a,b){o.cssHooks[b]={get:function(a,c,d){return c?0===a.offsetWidth&&zb.test(o.css(a,"display"))?o.swap(a,Cb,function(){return Ib(a,b,d)}):Ib(a,b,d):void 0},set:function(a,c,d){var e=d&&wb(a);return Gb(a,c,d?Hb(a,b,d,"border-box"===o.css(a,"boxSizing",!1,e),e):0)}}}),o.cssHooks.marginRight=yb(l.reliableMarginRight,function(a,b){return b?o.swap(a,{display:"inline-block"},xb,[a,"marginRight"]):void 0}),o.each({margin:"",padding:"",border:"Width"},function(a,b){o.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ub.test(a)||(o.cssHooks[a+b].set=Gb)}),o.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(o.isArray(b)){for(d=wb(a),e=b.length;e>g;g++)f[b[g]]=o.css(a,b[g],!1,d);return f}return void 0!==c?o.style(a,b,c):o.css(a,b)},a,b,arguments.length>1)},show:function(){return Jb(this,!0)},hide:function(){return Jb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?o(this).show():o(this).hide()})}});function Kb(a,b,c,d,e){return new Kb.prototype.init(a,b,c,d,e)}o.Tween=Kb,Kb.prototype={constructor:Kb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(o.cssNumber[c]?"":"px")},cur:function(){var a=Kb.propHooks[this.prop];return a&&a.get?a.get(this):Kb.propHooks._default.get(this)},run:function(a){var b,c=Kb.propHooks[this.prop];return this.pos=b=this.options.duration?o.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Kb.propHooks._default.set(this),this}},Kb.prototype.init.prototype=Kb.prototype,Kb.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=o.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){o.fx.step[a.prop]?o.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[o.cssProps[a.prop]]||o.cssHooks[a.prop])?o.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Kb.propHooks.scrollTop=Kb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},o.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},o.fx=Kb.prototype.init,o.fx.step={};var Lb,Mb,Nb=/^(?:toggle|show|hide)$/,Ob=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pb=/queueHooks$/,Qb=[Vb],Rb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Ob.exec(b),f=e&&e[3]||(o.cssNumber[a]?"":"px"),g=(o.cssNumber[a]||"px"!==f&&+d)&&Ob.exec(o.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,o.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sb(){return setTimeout(function(){Lb=void 0}),Lb=o.now()}function Tb(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ub(a,b,c){for(var d,e=(Rb[b]||[]).concat(Rb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Vb(a,b,c){var d,e,f,g,h,i,j,k=this,l={},m=a.style,n=a.nodeType&&S(a),p=L.get(a,"fxshow");c.queue||(h=o._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,k.always(function(){k.always(function(){h.unqueued--,o.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[m.overflow,m.overflowX,m.overflowY],j=o.css(a,"display"),"none"===j&&(j=tb(a.nodeName)),"inline"===j&&"none"===o.css(a,"float")&&(m.display="inline-block")),c.overflow&&(m.overflow="hidden",k.always(function(){m.overflow=c.overflow[0],m.overflowX=c.overflow[1],m.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Nb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(n?"hide":"show")){if("show"!==e||!p||void 0===p[d])continue;n=!0}l[d]=p&&p[d]||o.style(a,d)}if(!o.isEmptyObject(l)){p?"hidden"in p&&(n=p.hidden):p=L.access(a,"fxshow",{}),f&&(p.hidden=!n),n?o(a).show():k.done(function(){o(a).hide()}),k.done(function(){var b;L.remove(a,"fxshow");for(b in l)o.style(a,b,l[b])});for(d in l)g=Ub(n?p[d]:0,d,k),d in p||(p[d]=g.start,n&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wb(a,b){var c,d,e,f,g;for(c in a)if(d=o.camelCase(c),e=b[d],f=a[c],o.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=o.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xb(a,b,c){var d,e,f=0,g=Qb.length,h=o.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Lb||Sb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:o.extend({},b),opts:o.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:Lb||Sb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=o.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wb(k,j.opts.specialEasing);g>f;f++)if(d=Qb[f].call(j,a,k,j.opts))return d;return o.map(k,Ub,j),o.isFunction(j.opts.start)&&j.opts.start.call(a,j),o.fx.timer(o.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}o.Animation=o.extend(Xb,{tweener:function(a,b){o.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Rb[c]=Rb[c]||[],Rb[c].unshift(b)},prefilter:function(a,b){b?Qb.unshift(a):Qb.push(a)}}),o.speed=function(a,b,c){var d=a&&"object"==typeof a?o.extend({},a):{complete:c||!c&&b||o.isFunction(a)&&a,duration:a,easing:c&&b||b&&!o.isFunction(b)&&b};return d.duration=o.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in o.fx.speeds?o.fx.speeds[d.duration]:o.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){o.isFunction(d.old)&&d.old.call(this),d.queue&&o.dequeue(this,d.queue)},d},o.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=o.isEmptyObject(a),f=o.speed(b,c,d),g=function(){var b=Xb(this,o.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=o.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&o.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=o.timers,g=d?d.length:0;for(c.finish=!0,o.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),o.each(["toggle","show","hide"],function(a,b){var c=o.fn[b];o.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Tb(b,!0),a,d,e)}}),o.each({slideDown:Tb("show"),slideUp:Tb("hide"),slideToggle:Tb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){o.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),o.timers=[],o.fx.tick=function(){var a,b=0,c=o.timers;for(Lb=o.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||o.fx.stop(),Lb=void 0},o.fx.timer=function(a){o.timers.push(a),a()?o.fx.start():o.timers.pop()},o.fx.interval=13,o.fx.start=function(){Mb||(Mb=setInterval(o.fx.tick,o.fx.interval))},o.fx.stop=function(){clearInterval(Mb),Mb=null},o.fx.speeds={slow:600,fast:200,_default:400},o.fn.delay=function(a,b){return a=o.fx?o.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=m.createElement("input"),b=m.createElement("select"),c=b.appendChild(m.createElement("option"));a.type="checkbox",l.checkOn=""!==a.value,l.optSelected=c.selected,b.disabled=!0,l.optDisabled=!c.disabled,a=m.createElement("input"),a.value="t",a.type="radio",l.radioValue="t"===a.value}();var Yb,Zb,$b=o.expr.attrHandle;o.fn.extend({attr:function(a,b){return J(this,o.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){o.removeAttr(this,a)})}}),o.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?o.prop(a,b,c):(1===f&&o.isXMLDoc(a)||(b=b.toLowerCase(),d=o.attrHooks[b]||(o.expr.match.bool.test(b)?Zb:Yb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=o.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void o.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=o.propFix[c]||c,o.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!l.radioValue&&"radio"===b&&o.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Zb={set:function(a,b,c){return b===!1?o.removeAttr(a,c):a.setAttribute(c,c),c}},o.each(o.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$b[b]||o.find.attr;$b[b]=function(a,b,d){var e,f;
+return d||(f=$b[b],$b[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$b[b]=f),e}});var _b=/^(?:input|select|textarea|button)$/i;o.fn.extend({prop:function(a,b){return J(this,o.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[o.propFix[a]||a]})}}),o.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!o.isXMLDoc(a),f&&(b=o.propFix[b]||b,e=o.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_b.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),l.optSelected||(o.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),o.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){o.propFix[this.toLowerCase()]=this});var ac=/[\t\r\n\f]/g;o.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(o.isFunction(a))return this.each(function(b){o(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=o.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(o.isFunction(a))return this.each(function(b){o(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?o.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(o.isFunction(a)?function(c){o(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=o(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ac," ").indexOf(b)>=0)return!0;return!1}});var bc=/\r/g;o.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=o.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,o(this).val()):a,null==e?e="":"number"==typeof e?e+="":o.isArray(e)&&(e=o.map(e,function(a){return null==a?"":a+""})),b=o.valHooks[this.type]||o.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=o.valHooks[e.type]||o.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bc,""):null==c?"":c)}}}),o.extend({valHooks:{select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(l.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&o.nodeName(c.parentNode,"optgroup"))){if(b=o(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=o.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=o.inArray(o(d).val(),f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),o.each(["radio","checkbox"],function(){o.valHooks[this]={set:function(a,b){return o.isArray(b)?a.checked=o.inArray(o(a).val(),b)>=0:void 0}},l.checkOn||(o.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),o.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){o.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),o.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cc=o.now(),dc=/\?/;o.parseJSON=function(a){return JSON.parse(a+"")},o.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&o.error("Invalid XML: "+a),b};var ec,fc,gc=/#.*$/,hc=/([?&])_=[^&]*/,ic=/^(.*?):[ \t]*([^\r\n]*)$/gm,jc=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,kc=/^(?:GET|HEAD)$/,lc=/^\/\//,mc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,nc={},oc={},pc="*/".concat("*");try{fc=location.href}catch(qc){fc=m.createElement("a"),fc.href="",fc=fc.href}ec=mc.exec(fc.toLowerCase())||[];function rc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(o.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function sc(a,b,c,d){var e={},f=a===oc;function g(h){var i;return e[h]=!0,o.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function tc(a,b){var c,d,e=o.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&o.extend(!0,a,d),a}function uc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function vc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}o.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:fc,type:"GET",isLocal:jc.test(ec[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":pc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":o.parseJSON,"text xml":o.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?tc(tc(a,o.ajaxSettings),b):tc(o.ajaxSettings,a)},ajaxPrefilter:rc(nc),ajaxTransport:rc(oc),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=o.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?o(l):o.event,n=o.Deferred(),p=o.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=ic.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(n.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||fc)+"").replace(gc,"").replace(lc,ec[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=o.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=mc.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===ec[1]&&h[2]===ec[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(ec[3]||("http:"===ec[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=o.param(k.data,k.traditional)),sc(nc,k,b,v),2===t)return v;i=k.global,i&&0===o.active++&&o.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!kc.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(dc.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=hc.test(d)?d.replace(hc,"$1_="+cc++):d+(dc.test(d)?"&":"?")+"_="+cc++)),k.ifModified&&(o.lastModified[d]&&v.setRequestHeader("If-Modified-Since",o.lastModified[d]),o.etag[d]&&v.setRequestHeader("If-None-Match",o.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+pc+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=sc(oc,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=uc(k,v,f)),u=vc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(o.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(o.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?n.resolveWith(l,[r,x,v]):n.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--o.active||o.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return o.get(a,b,c,"json")},getScript:function(a,b){return o.get(a,void 0,b,"script")}}),o.each(["get","post"],function(a,b){o[b]=function(a,c,d,e){return o.isFunction(c)&&(e=e||d,d=c,c=void 0),o.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),o.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){o.fn[b]=function(a){return this.on(b,a)}}),o._evalUrl=function(a){return o.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},o.fn.extend({wrapAll:function(a){var b;return o.isFunction(a)?this.each(function(b){o(this).wrapAll(a.call(this,b))}):(this[0]&&(b=o(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(o.isFunction(a)?function(b){o(this).wrapInner(a.call(this,b))}:function(){var b=o(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=o.isFunction(a);return this.each(function(c){o(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){o.nodeName(this,"body")||o(this).replaceWith(this.childNodes)}).end()}}),o.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},o.expr.filters.visible=function(a){return!o.expr.filters.hidden(a)};var wc=/%20/g,xc=/\[\]$/,yc=/\r?\n/g,zc=/^(?:submit|button|image|reset|file)$/i,Ac=/^(?:input|select|textarea|keygen)/i;function Bc(a,b,c,d){var e;if(o.isArray(b))o.each(b,function(b,e){c||xc.test(a)?d(a,e):Bc(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==o.type(b))d(a,b);else for(e in b)Bc(a+"["+e+"]",b[e],c,d)}o.param=function(a,b){var c,d=[],e=function(a,b){b=o.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=o.ajaxSettings&&o.ajaxSettings.traditional),o.isArray(a)||a.jquery&&!o.isPlainObject(a))o.each(a,function(){e(this.name,this.value)});else for(c in a)Bc(c,a[c],b,e);return d.join("&").replace(wc,"+")},o.fn.extend({serialize:function(){return o.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=o.prop(this,"elements");return a?o.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!o(this).is(":disabled")&&Ac.test(this.nodeName)&&!zc.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=o(this).val();return null==c?null:o.isArray(c)?o.map(c,function(a){return{name:b.name,value:a.replace(yc,"\r\n")}}):{name:b.name,value:c.replace(yc,"\r\n")}}).get()}}),o.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Cc=0,Dc={},Ec={0:200,1223:204},Fc=o.ajaxSettings.xhr();a.ActiveXObject&&o(a).on("unload",function(){for(var a in Dc)Dc[a]()}),l.cors=!!Fc&&"withCredentials"in Fc,l.ajax=Fc=!!Fc,o.ajaxTransport(function(a){var b;return l.cors||Fc&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Cc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Dc[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Ec[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Dc[g]=b("abort"),f.send(a.hasContent&&a.data||null)},abort:function(){b&&b()}}:void 0}),o.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return o.globalEval(a),a}}}),o.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),o.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=o("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),m.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Gc=[],Hc=/(=)\?(?=&|$)|\?\?/;o.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Gc.pop()||o.expando+"_"+cc++;return this[a]=!0,a}}),o.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Hc.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Hc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=o.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Hc,"$1"+e):b.jsonp!==!1&&(b.url+=(dc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||o.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Gc.push(e)),g&&o.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),o.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||m;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=o.buildFragment([a],b,e),e&&e.length&&o(e).remove(),o.merge([],d.childNodes))};var Ic=o.fn.load;o.fn.load=function(a,b,c){if("string"!=typeof a&&Ic)return Ic.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=a.slice(h),a=a.slice(0,h)),o.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&o.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?o("<div>").append(o.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},o.expr.filters.animated=function(a){return o.grep(o.timers,function(b){return a===b.elem}).length};var Jc=a.document.documentElement;function Kc(a){return o.isWindow(a)?a:9===a.nodeType&&a.defaultView}o.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=o.css(a,"position"),l=o(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=o.css(a,"top"),i=o.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),o.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},o.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){o.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,o.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Kc(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===o.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),o.nodeName(a[0],"html")||(d=a.offset()),d.top+=o.css(a[0],"borderTopWidth",!0),d.left+=o.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-o.css(c,"marginTop",!0),left:b.left-d.left-o.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Jc;while(a&&!o.nodeName(a,"html")&&"static"===o.css(a,"position"))a=a.offsetParent;return a||Jc})}}),o.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;o.fn[b]=function(e){return J(this,function(b,e,f){var g=Kc(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),o.each(["top","left"],function(a,b){o.cssHooks[b]=yb(l.pixelPosition,function(a,c){return c?(c=xb(a,b),vb.test(c)?o(a).position()[b]+"px":c):void 0})}),o.each({Height:"height",Width:"width"},function(a,b){o.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){o.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return o.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?o.css(b,c,g):o.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),o.fn.size=function(){return this.length},o.fn.andSelf=o.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return o});var Lc=a.jQuery,Mc=a.$;return o.noConflict=function(b){return a.$===o&&(a.$=Mc),b&&a.jQuery===o&&(a.jQuery=Lc),o},typeof b===U&&(a.jQuery=a.$=o),o});
diff --git a/web/src/main/webapp/js/jquery-ui-1.10.4.custom.js b/web/src/main/webapp/js/jquery-ui-1.10.4.custom.js
new file mode 100644
index 0000000000..c005b73831
--- /dev/null
+++ b/web/src/main/webapp/js/jquery-ui-1.10.4.custom.js
@@ -0,0 +1,2747 @@
+/*! jQuery UI - v1.10.4 - 2014-06-27
+* http://jqueryui.com
+* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.sortable.js
+* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
+
+(function( $, undefined ) {
+
+var uuid = 0,
+	runiqueId = /^ui-id-\d+$/;
+
+// $.ui might exist from components with no dependencies, e.g., $.ui.position
+$.ui = $.ui || {};
+
+$.extend( $.ui, {
+	version: "1.10.4",
+
+	keyCode: {
+		BACKSPACE: 8,
+		COMMA: 188,
+		DELETE: 46,
+		DOWN: 40,
+		END: 35,
+		ENTER: 13,
+		ESCAPE: 27,
+		HOME: 36,
+		LEFT: 37,
+		NUMPAD_ADD: 107,
+		NUMPAD_DECIMAL: 110,
+		NUMPAD_DIVIDE: 111,
+		NUMPAD_ENTER: 108,
+		NUMPAD_MULTIPLY: 106,
+		NUMPAD_SUBTRACT: 109,
+		PAGE_DOWN: 34,
+		PAGE_UP: 33,
+		PERIOD: 190,
+		RIGHT: 39,
+		SPACE: 32,
+		TAB: 9,
+		UP: 38
+	}
+});
+
+// plugins
+$.fn.extend({
+	focus: (function( orig ) {
+		return function( delay, fn ) {
+			return typeof delay === "number" ?
+				this.each(function() {
+					var elem = this;
+					setTimeout(function() {
+						$( elem ).focus();
+						if ( fn ) {
+							fn.call( elem );
+						}
+					}, delay );
+				}) :
+				orig.apply( this, arguments );
+		};
+	})( $.fn.focus ),
+
+	scrollParent: function() {
+		var scrollParent;
+		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
+			scrollParent = this.parents().filter(function() {
+				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
+			}).eq(0);
+		} else {
+			scrollParent = this.parents().filter(function() {
+				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
+			}).eq(0);
+		}
+
+		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
+	},
+
+	zIndex: function( zIndex ) {
+		if ( zIndex !== undefined ) {
+			return this.css( "zIndex", zIndex );
+		}
+
+		if ( this.length ) {
+			var elem = $( this[ 0 ] ), position, value;
+			while ( elem.length && elem[ 0 ] !== document ) {
+				// Ignore z-index if position is set to a value where z-index is ignored by the browser
+				// This makes behavior of this function consistent across browsers
+				// WebKit always returns auto if the element is positioned
+				position = elem.css( "position" );
+				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
+					// IE returns 0 when zIndex is not specified
+					// other browsers return a string
+					// we ignore the case of nested elements with an explicit value of 0
+					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
+					value = parseInt( elem.css( "zIndex" ), 10 );
+					if ( !isNaN( value ) && value !== 0 ) {
+						return value;
+					}
+				}
+				elem = elem.parent();
+			}
+		}
+
+		return 0;
+	},
+
+	uniqueId: function() {
+		return this.each(function() {
+			if ( !this.id ) {
+				this.id = "ui-id-" + (++uuid);
+			}
+		});
+	},
+
+	removeUniqueId: function() {
+		return this.each(function() {
+			if ( runiqueId.test( this.id ) ) {
+				$( this ).removeAttr( "id" );
+			}
+		});
+	}
+});
+
+// selectors
+function focusable( element, isTabIndexNotNaN ) {
+	var map, mapName, img,
+		nodeName = element.nodeName.toLowerCase();
+	if ( "area" === nodeName ) {
+		map = element.parentNode;
+		mapName = map.name;
+		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
+			return false;
+		}
+		img = $( "img[usemap=#" + mapName + "]" )[0];
+		return !!img && visible( img );
+	}
+	return ( /input|select|textarea|button|object/.test( nodeName ) ?
+		!element.disabled :
+		"a" === nodeName ?
+			element.href || isTabIndexNotNaN :
+			isTabIndexNotNaN) &&
+		// the element and all of its ancestors must be visible
+		visible( element );
+}
+
+function visible( element ) {
+	return $.expr.filters.visible( element ) &&
+		!$( element ).parents().addBack().filter(function() {
+			return $.css( this, "visibility" ) === "hidden";
+		}).length;
+}
+
+$.extend( $.expr[ ":" ], {
+	data: $.expr.createPseudo ?
+		$.expr.createPseudo(function( dataName ) {
+			return function( elem ) {
+				return !!$.data( elem, dataName );
+			};
+		}) :
+		// support: jQuery <1.8
+		function( elem, i, match ) {
+			return !!$.data( elem, match[ 3 ] );
+		},
+
+	focusable: function( element ) {
+		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
+	},
+
+	tabbable: function( element ) {
+		var tabIndex = $.attr( element, "tabindex" ),
+			isTabIndexNaN = isNaN( tabIndex );
+		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
+	}
+});
+
+// support: jQuery <1.8
+if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
+	$.each( [ "Width", "Height" ], function( i, name ) {
+		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
+			type = name.toLowerCase(),
+			orig = {
+				innerWidth: $.fn.innerWidth,
+				innerHeight: $.fn.innerHeight,
+				outerWidth: $.fn.outerWidth,
+				outerHeight: $.fn.outerHeight
+			};
+
+		function reduce( elem, size, border, margin ) {
+			$.each( side, function() {
+				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
+				if ( border ) {
+					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
+				}
+				if ( margin ) {
+					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
+				}
+			});
+			return size;
+		}
+
+		$.fn[ "inner" + name ] = function( size ) {
+			if ( size === undefined ) {
+				return orig[ "inner" + name ].call( this );
+			}
+
+			return this.each(function() {
+				$( this ).css( type, reduce( this, size ) + "px" );
+			});
+		};
+
+		$.fn[ "outer" + name] = function( size, margin ) {
+			if ( typeof size !== "number" ) {
+				return orig[ "outer" + name ].call( this, size );
+			}
+
+			return this.each(function() {
+				$( this).css( type, reduce( this, size, true, margin ) + "px" );
+			});
+		};
+	});
+}
+
+// support: jQuery <1.8
+if ( !$.fn.addBack ) {
+	$.fn.addBack = function( selector ) {
+		return this.add( selector == null ?
+			this.prevObject : this.prevObject.filter( selector )
+		);
+	};
+}
+
+// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
+if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
+	$.fn.removeData = (function( removeData ) {
+		return function( key ) {
+			if ( arguments.length ) {
+				return removeData.call( this, $.camelCase( key ) );
+			} else {
+				return removeData.call( this );
+			}
+		};
+	})( $.fn.removeData );
+}
+
+
+
+
+
+// deprecated
+$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
+
+$.support.selectstart = "onselectstart" in document.createElement( "div" );
+$.fn.extend({
+	disableSelection: function() {
+		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
+			".ui-disableSelection", function( event ) {
+				event.preventDefault();
+			});
+	},
+
+	enableSelection: function() {
+		return this.unbind( ".ui-disableSelection" );
+	}
+});
+
+$.extend( $.ui, {
+	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
+	plugin: {
+		add: function( module, option, set ) {
+			var i,
+				proto = $.ui[ module ].prototype;
+			for ( i in set ) {
+				proto.plugins[ i ] = proto.plugins[ i ] || [];
+				proto.plugins[ i ].push( [ option, set[ i ] ] );
+			}
+		},
+		call: function( instance, name, args ) {
+			var i,
+				set = instance.plugins[ name ];
+			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
+				return;
+			}
+
+			for ( i = 0; i < set.length; i++ ) {
+				if ( instance.options[ set[ i ][ 0 ] ] ) {
+					set[ i ][ 1 ].apply( instance.element, args );
+				}
+			}
+		}
+	},
+
+	// only used by resizable
+	hasScroll: function( el, a ) {
+
+		//If overflow is hidden, the element might have extra content, but the user wants to hide it
+		if ( $( el ).css( "overflow" ) === "hidden") {
+			return false;
+		}
+
+		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
+			has = false;
+
+		if ( el[ scroll ] > 0 ) {
+			return true;
+		}
+
+		// TODO: determine which cases actually cause this to happen
+		// if the element doesn't have the scroll set, see if it's possible to
+		// set the scroll
+		el[ scroll ] = 1;
+		has = ( el[ scroll ] > 0 );
+		el[ scroll ] = 0;
+		return has;
+	}
+});
+
+})( jQuery );
+(function( $, undefined ) {
+
+var uuid = 0,
+	slice = Array.prototype.slice,
+	_cleanData = $.cleanData;
+$.cleanData = function( elems ) {
+	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
+		try {
+			$( elem ).triggerHandler( "remove" );
+		// http://bugs.jquery.com/ticket/8235
+		} catch( e ) {}
+	}
+	_cleanData( elems );
+};
+
+$.widget = function( name, base, prototype ) {
+	var fullName, existingConstructor, constructor, basePrototype,
+		// proxiedPrototype allows the provided prototype to remain unmodified
+		// so that it can be used as a mixin for multiple widgets (#8876)
+		proxiedPrototype = {},
+		namespace = name.split( "." )[ 0 ];
+
+	name = name.split( "." )[ 1 ];
+	fullName = namespace + "-" + name;
+
+	if ( !prototype ) {
+		prototype = base;
+		base = $.Widget;
+	}
+
+	// create selector for plugin
+	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
+		return !!$.data( elem, fullName );
+	};
+
+	$[ namespace ] = $[ namespace ] || {};
+	existingConstructor = $[ namespace ][ name ];
+	constructor = $[ namespace ][ name ] = function( options, element ) {
+		// allow instantiation without "new" keyword
+		if ( !this._createWidget ) {
+			return new constructor( options, element );
+		}
+
+		// allow instantiation without initializing for simple inheritance
+		// must use "new" keyword (the code above always passes args)
+		if ( arguments.length ) {
+			this._createWidget( options, element );
+		}
+	};
+	// extend with the existing constructor to carry over any static properties
+	$.extend( constructor, existingConstructor, {
+		version: prototype.version,
+		// copy the object used to create the prototype in case we need to
+		// redefine the widget later
+		_proto: $.extend( {}, prototype ),
+		// track widgets that inherit from this widget in case this widget is
+		// redefined after a widget inherits from it
+		_childConstructors: []
+	});
+
+	basePrototype = new base();
+	// we need to make the options hash a property directly on the new instance
+	// otherwise we'll modify the options hash on the prototype that we're
+	// inheriting from
+	basePrototype.options = $.widget.extend( {}, basePrototype.options );
+	$.each( prototype, function( prop, value ) {
+		if ( !$.isFunction( value ) ) {
+			proxiedPrototype[ prop ] = value;
+			return;
+		}
+		proxiedPrototype[ prop ] = (function() {
+			var _super = function() {
+					return base.prototype[ prop ].apply( this, arguments );
+				},
+				_superApply = function( args ) {
+					return base.prototype[ prop ].apply( this, args );
+				};
+			return function() {
+				var __super = this._super,
+					__superApply = this._superApply,
+					returnValue;
+
+				this._super = _super;
+				this._superApply = _superApply;
+
+				returnValue = value.apply( this, arguments );
+
+				this._super = __super;
+				this._superApply = __superApply;
+
+				return returnValue;
+			};
+		})();
+	});
+	constructor.prototype = $.widget.extend( basePrototype, {
+		// TODO: remove support for widgetEventPrefix
+		// always use the name + a colon as the prefix, e.g., draggable:start
+		// don't prefix for widgets that aren't DOM-based
+		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
+	}, proxiedPrototype, {
+		constructor: constructor,
+		namespace: namespace,
+		widgetName: name,
+		widgetFullName: fullName
+	});
+
+	// If this widget is being redefined then we need to find all widgets that
+	// are inheriting from it and redefine all of them so that they inherit from
+	// the new version of this widget. We're essentially trying to replace one
+	// level in the prototype chain.
+	if ( existingConstructor ) {
+		$.each( existingConstructor._childConstructors, function( i, child ) {
+			var childPrototype = child.prototype;
+
+			// redefine the child widget using the same prototype that was
+			// originally used, but inherit from the new version of the base
+			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
+		});
+		// remove the list of existing child constructors from the old constructor
+		// so the old child constructors can be garbage collected
+		delete existingConstructor._childConstructors;
+	} else {
+		base._childConstructors.push( constructor );
+	}
+
+	$.widget.bridge( name, constructor );
+};
+
+$.widget.extend = function( target ) {
+	var input = slice.call( arguments, 1 ),
+		inputIndex = 0,
+		inputLength = input.length,
+		key,
+		value;
+	for ( ; inputIndex < inputLength; inputIndex++ ) {
+		for ( key in input[ inputIndex ] ) {
+			value = input[ inputIndex ][ key ];
+			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
+				// Clone objects
+				if ( $.isPlainObject( value ) ) {
+					target[ key ] = $.isPlainObject( target[ key ] ) ?
+						$.widget.extend( {}, target[ key ], value ) :
+						// Don't extend strings, arrays, etc. with objects
+						$.widget.extend( {}, value );
+				// Copy everything else by reference
+				} else {
+					target[ key ] = value;
+				}
+			}
+		}
+	}
+	return target;
+};
+
+$.widget.bridge = function( name, object ) {
+	var fullName = object.prototype.widgetFullName || name;
+	$.fn[ name ] = function( options ) {
+		var isMethodCall = typeof options === "string",
+			args = slice.call( arguments, 1 ),
+			returnValue = this;
+
+		// allow multiple hashes to be passed on init
+		options = !isMethodCall && args.length ?
+			$.widget.extend.apply( null, [ options ].concat(args) ) :
+			options;
+
+		if ( isMethodCall ) {
+			this.each(function() {
+				var methodValue,
+					instance = $.data( this, fullName );
+				if ( !instance ) {
+					return $.error( "cannot call methods on " + name + " prior to initialization; " +
+						"attempted to call method '" + options + "'" );
+				}
+				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
+					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
+				}
+				methodValue = instance[ options ].apply( instance, args );
+				if ( methodValue !== instance && methodValue !== undefined ) {
+					returnValue = methodValue && methodValue.jquery ?
+						returnValue.pushStack( methodValue.get() ) :
+						methodValue;
+					return false;
+				}
+			});
+		} else {
+			this.each(function() {
+				var instance = $.data( this, fullName );
+				if ( instance ) {
+					instance.option( options || {} )._init();
+				} else {
+					$.data( this, fullName, new object( options, this ) );
+				}
+			});
+		}
+
+		return returnValue;
+	};
+};
+
+$.Widget = function( /* options, element */ ) {};
+$.Widget._childConstructors = [];
+
+$.Widget.prototype = {
+	widgetName: "widget",
+	widgetEventPrefix: "",
+	defaultElement: "<div>",
+	options: {
+		disabled: false,
+
+		// callbacks
+		create: null
+	},
+	_createWidget: function( options, element ) {
+		element = $( element || this.defaultElement || this )[ 0 ];
+		this.element = $( element );
+		this.uuid = uuid++;
+		this.eventNamespace = "." + this.widgetName + this.uuid;
+		this.options = $.widget.extend( {},
+			this.options,
+			this._getCreateOptions(),
+			options );
+
+		this.bindings = $();
+		this.hoverable = $();
+		this.focusable = $();
+
+		if ( element !== this ) {
+			$.data( element, this.widgetFullName, this );
+			this._on( true, this.element, {
+				remove: function( event ) {
+					if ( event.target === element ) {
+						this.destroy();
+					}
+				}
+			});
+			this.document = $( element.style ?
+				// element within the document
+				element.ownerDocument :
+				// element is window or document
+				element.document || element );
+			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
+		}
+
+		this._create();
+		this._trigger( "create", null, this._getCreateEventData() );
+		this._init();
+	},
+	_getCreateOptions: $.noop,
+	_getCreateEventData: $.noop,
+	_create: $.noop,
+	_init: $.noop,
+
+	destroy: function() {
+		this._destroy();
+		// we can probably remove the unbind calls in 2.0
+		// all event bindings should go through this._on()
+		this.element
+			.unbind( this.eventNamespace )
+			// 1.9 BC for #7810
+			// TODO remove dual storage
+			.removeData( this.widgetName )
+			.removeData( this.widgetFullName )
+			// support: jquery <1.6.3
+			// http://bugs.jquery.com/ticket/9413
+			.removeData( $.camelCase( this.widgetFullName ) );
+		this.widget()
+			.unbind( this.eventNamespace )
+			.removeAttr( "aria-disabled" )
+			.removeClass(
+				this.widgetFullName + "-disabled " +
+				"ui-state-disabled" );
+
+		// clean up events and states
+		this.bindings.unbind( this.eventNamespace );
+		this.hoverable.removeClass( "ui-state-hover" );
+		this.focusable.removeClass( "ui-state-focus" );
+	},
+	_destroy: $.noop,
+
+	widget: function() {
+		return this.element;
+	},
+
+	option: function( key, value ) {
+		var options = key,
+			parts,
+			curOption,
+			i;
+
+		if ( arguments.length === 0 ) {
+			// don't return a reference to the internal hash
+			return $.widget.extend( {}, this.options );
+		}
+
+		if ( typeof key === "string" ) {
+			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
+			options = {};
+			parts = key.split( "." );
+			key = parts.shift();
+			if ( parts.length ) {
+				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
+				for ( i = 0; i < parts.length - 1; i++ ) {
+					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
+					curOption = curOption[ parts[ i ] ];
+				}
+				key = parts.pop();
+				if ( arguments.length === 1 ) {
+					return curOption[ key ] === undefined ? null : curOption[ key ];
+				}
+				curOption[ key ] = value;
+			} else {
+				if ( arguments.length === 1 ) {
+					return this.options[ key ] === undefined ? null : this.options[ key ];
+				}
+				options[ key ] = value;
+			}
+		}
+
+		this._setOptions( options );
+
+		return this;
+	},
+	_setOptions: function( options ) {
+		var key;
+
+		for ( key in options ) {
+			this._setOption( key, options[ key ] );
+		}
+
+		return this;
+	},
+	_setOption: function( key, value ) {
+		this.options[ key ] = value;
+
+		if ( key === "disabled" ) {
+			this.widget()
+				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
+				.attr( "aria-disabled", value );
+			this.hoverable.removeClass( "ui-state-hover" );
+			this.focusable.removeClass( "ui-state-focus" );
+		}
+
+		return this;
+	},
+
+	enable: function() {
+		return this._setOption( "disabled", false );
+	},
+	disable: function() {
+		return this._setOption( "disabled", true );
+	},
+
+	_on: function( suppressDisabledCheck, element, handlers ) {
+		var delegateElement,
+			instance = this;
+
+		// no suppressDisabledCheck flag, shuffle arguments
+		if ( typeof suppressDisabledCheck !== "boolean" ) {
+			handlers = element;
+			element = suppressDisabledCheck;
+			suppressDisabledCheck = false;
+		}
+
+		// no element argument, shuffle and use this.element
+		if ( !handlers ) {
+			handlers = element;
+			element = this.element;
+			delegateElement = this.widget();
+		} else {
+			// accept selectors, DOM elements
+			element = delegateElement = $( element );
+			this.bindings = this.bindings.add( element );
+		}
+
+		$.each( handlers, function( event, handler ) {
+			function handlerProxy() {
+				// allow widgets to customize the disabled handling
+				// - disabled as an array instead of boolean
+				// - disabled class as method for disabling individual parts
+				if ( !suppressDisabledCheck &&
+						( instance.options.disabled === true ||
+							$( this ).hasClass( "ui-state-disabled" ) ) ) {
+					return;
+				}
+				return ( typeof handler === "string" ? instance[ handler ] : handler )
+					.apply( instance, arguments );
+			}
+
+			// copy the guid so direct unbinding works
+			if ( typeof handler !== "string" ) {
+				handlerProxy.guid = handler.guid =
+					handler.guid || handlerProxy.guid || $.guid++;
+			}
+
+			var match = event.match( /^(\w+)\s*(.*)$/ ),
+				eventName = match[1] + instance.eventNamespace,
+				selector = match[2];
+			if ( selector ) {
+				delegateElement.delegate( selector, eventName, handlerProxy );
+			} else {
+				element.bind( eventName, handlerProxy );
+			}
+		});
+	},
+
+	_off: function( element, eventName ) {
+		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
+		element.unbind( eventName ).undelegate( eventName );
+	},
+
+	_delay: function( handler, delay ) {
+		function handlerProxy() {
+			return ( typeof handler === "string" ? instance[ handler ] : handler )
+				.apply( instance, arguments );
+		}
+		var instance = this;
+		return setTimeout( handlerProxy, delay || 0 );
+	},
+
+	_hoverable: function( element ) {
+		this.hoverable = this.hoverable.add( element );
+		this._on( element, {
+			mouseenter: function( event ) {
+				$( event.currentTarget ).addClass( "ui-state-hover" );
+			},
+			mouseleave: function( event ) {
+				$( event.currentTarget ).removeClass( "ui-state-hover" );
+			}
+		});
+	},
+
+	_focusable: function( element ) {
+		this.focusable = this.focusable.add( element );
+		this._on( element, {
+			focusin: function( event ) {
+				$( event.currentTarget ).addClass( "ui-state-focus" );
+			},
+			focusout: function( event ) {
+				$( event.currentTarget ).removeClass( "ui-state-focus" );
+			}
+		});
+	},
+
+	_trigger: function( type, event, data ) {
+		var prop, orig,
+			callback = this.options[ type ];
+
+		data = data || {};
+		event = $.Event( event );
+		event.type = ( type === this.widgetEventPrefix ?
+			type :
+			this.widgetEventPrefix + type ).toLowerCase();
+		// the original event may come from any element
+		// so we need to reset the target on the new event
+		event.target = this.element[ 0 ];
+
+		// copy original event properties over to the new event
+		orig = event.originalEvent;
+		if ( orig ) {
+			for ( prop in orig ) {
+				if ( !( prop in event ) ) {
+					event[ prop ] = orig[ prop ];
+				}
+			}
+		}
+
+		this.element.trigger( event, data );
+		return !( $.isFunction( callback ) &&
+			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
+			event.isDefaultPrevented() );
+	}
+};
+
+$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
+	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
+		if ( typeof options === "string" ) {
+			options = { effect: options };
+		}
+		var hasOptions,
+			effectName = !options ?
+				method :
+				options === true || typeof options === "number" ?
+					defaultEffect :
+					options.effect || defaultEffect;
+		options = options || {};
+		if ( typeof options === "number" ) {
+			options = { duration: options };
+		}
+		hasOptions = !$.isEmptyObject( options );
+		options.complete = callback;
+		if ( options.delay ) {
+			element.delay( options.delay );
+		}
+		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
+			element[ method ]( options );
+		} else if ( effectName !== method && element[ effectName ] ) {
+			element[ effectName ]( options.duration, options.easing, callback );
+		} else {
+			element.queue(function( next ) {
+				$( this )[ method ]();
+				if ( callback ) {
+					callback.call( element[ 0 ] );
+				}
+				next();
+			});
+		}
+	};
+});
+
+})( jQuery );
+(function( $, undefined ) {
+
+var mouseHandled = false;
+$( document ).mouseup( function() {
+	mouseHandled = false;
+});
+
+$.widget("ui.mouse", {
+	version: "1.10.4",
+	options: {
+		cancel: "input,textarea,button,select,option",
+		distance: 1,
+		delay: 0
+	},
+	_mouseInit: function() {
+		var that = this;
+
+		this.element
+			.bind("mousedown."+this.widgetName, function(event) {
+				return that._mouseDown(event);
+			})
+			.bind("click."+this.widgetName, function(event) {
+				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
+					$.removeData(event.target, that.widgetName + ".preventClickEvent");
+					event.stopImmediatePropagation();
+					return false;
+				}
+			});
+
+		this.started = false;
+	},
+
+	// TODO: make sure destroying one instance of mouse doesn't mess with
+	// other instances of mouse
+	_mouseDestroy: function() {
+		this.element.unbind("."+this.widgetName);
+		if ( this._mouseMoveDelegate ) {
+			$(document)
+				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
+				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
+		}
+	},
+
+	_mouseDown: function(event) {
+		// don't let more than one widget handle mouseStart
+		if( mouseHandled ) { return; }
+
+		// we may have missed mouseup (out of window)
+		(this._mouseStarted && this._mouseUp(event));
+
+		this._mouseDownEvent = event;
+
+		var that = this,
+			btnIsLeft = (event.which === 1),
+			// event.target.nodeName works around a bug in IE 8 with
+			// disabled inputs (#7620)
+			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
+		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
+			return true;
+		}
+
+		this.mouseDelayMet = !this.options.delay;
+		if (!this.mouseDelayMet) {
+			this._mouseDelayTimer = setTimeout(function() {
+				that.mouseDelayMet = true;
+			}, this.options.delay);
+		}
+
+		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
+			this._mouseStarted = (this._mouseStart(event) !== false);
+			if (!this._mouseStarted) {
+				event.preventDefault();
+				return true;
+			}
+		}
+
+		// Click event may never have fired (Gecko & Opera)
+		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
+			$.removeData(event.target, this.widgetName + ".preventClickEvent");
+		}
+
+		// these delegates are required to keep context
+		this._mouseMoveDelegate = function(event) {
+			return that._mouseMove(event);
+		};
+		this._mouseUpDelegate = function(event) {
+			return that._mouseUp(event);
+		};
+		$(document)
+			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
+			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);
+
+		event.preventDefault();
+
+		mouseHandled = true;
+		return true;
+	},
+
+	_mouseMove: function(event) {
+		// IE mouseup check - mouseup happened when mouse was out of window
+		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
+			return this._mouseUp(event);
+		}
+
+		if (this._mouseStarted) {
+			this._mouseDrag(event);
+			return event.preventDefault();
+		}
+
+		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
+			this._mouseStarted =
+				(this._mouseStart(this._mouseDownEvent, event) !== false);
+			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
+		}
+
+		return !this._mouseStarted;
+	},
+
+	_mouseUp: function(event) {
+		$(document)
+			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
+			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
+
+		if (this._mouseStarted) {
+			this._mouseStarted = false;
+
+			if (event.target === this._mouseDownEvent.target) {
+				$.data(event.target, this.widgetName + ".preventClickEvent", true);
+			}
+
+			this._mouseStop(event);
+		}
+
+		return false;
+	},
+
+	_mouseDistanceMet: function(event) {
+		return (Math.max(
+				Math.abs(this._mouseDownEvent.pageX - event.pageX),
+				Math.abs(this._mouseDownEvent.pageY - event.pageY)
+			) >= this.options.distance
+		);
+	},
+
+	_mouseDelayMet: function(/* event */) {
+		return this.mouseDelayMet;
+	},
+
+	// These are placeholder methods, to be overriden by extending plugin
+	_mouseStart: function(/* event */) {},
+	_mouseDrag: function(/* event */) {},
+	_mouseStop: function(/* event */) {},
+	_mouseCapture: function(/* event */) { return true; }
+});
+
+})(jQuery);
+(function( $, undefined ) {
+
+$.ui = $.ui || {};
+
+var cachedScrollbarWidth,
+	max = Math.max,
+	abs = Math.abs,
+	round = Math.round,
+	rhorizontal = /left|center|right/,
+	rvertical = /top|center|bottom/,
+	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
+	rposition = /^\w+/,
+	rpercent = /%$/,
+	_position = $.fn.position;
+
+function getOffsets( offsets, width, height ) {
+	return [
+		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
+		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
+	];
+}
+
+function parseCss( element, property ) {
+	return parseInt( $.css( element, property ), 10 ) || 0;
+}
+
+function getDimensions( elem ) {
+	var raw = elem[0];
+	if ( raw.nodeType === 9 ) {
+		return {
+			width: elem.width(),
+			height: elem.height(),
+			offset: { top: 0, left: 0 }
+		};
+	}
+	if ( $.isWindow( raw ) ) {
+		return {
+			width: elem.width(),
+			height: elem.height(),
+			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
+		};
+	}
+	if ( raw.preventDefault ) {
+		return {
+			width: 0,
+			height: 0,
+			offset: { top: raw.pageY, left: raw.pageX }
+		};
+	}
+	return {
+		width: elem.outerWidth(),
+		height: elem.outerHeight(),
+		offset: elem.offset()
+	};
+}
+
+$.position = {
+	scrollbarWidth: function() {
+		if ( cachedScrollbarWidth !== undefined ) {
+			return cachedScrollbarWidth;
+		}
+		var w1, w2,
+			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
+			innerDiv = div.children()[0];
+
+		$( "body" ).append( div );
+		w1 = innerDiv.offsetWidth;
+		div.css( "overflow", "scroll" );
+
+		w2 = innerDiv.offsetWidth;
+
+		if ( w1 === w2 ) {
+			w2 = div[0].clientWidth;
+		}
+
+		div.remove();
+
+		return (cachedScrollbarWidth = w1 - w2);
+	},
+	getScrollInfo: function( within ) {
+		var overflowX = within.isWindow || within.isDocument ? "" :
+				within.element.css( "overflow-x" ),
+			overflowY = within.isWindow || within.isDocument ? "" :
+				within.element.css( "overflow-y" ),
+			hasOverflowX = overflowX === "scroll" ||
+				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
+			hasOverflowY = overflowY === "scroll" ||
+				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
+		return {
+			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
+			height: hasOverflowX ? $.position.scrollbarWidth() : 0
+		};
+	},
+	getWithinInfo: function( element ) {
+		var withinElement = $( element || window ),
+			isWindow = $.isWindow( withinElement[0] ),
+			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
+		return {
+			element: withinElement,
+			isWindow: isWindow,
+			isDocument: isDocument,
+			offset: withinElement.offset() || { left: 0, top: 0 },
+			scrollLeft: withinElement.scrollLeft(),
+			scrollTop: withinElement.scrollTop(),
+			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
+			height: isWindow ? withinElement.height() : withinElement.outerHeight()
+		};
+	}
+};
+
+$.fn.position = function( options ) {
+	if ( !options || !options.of ) {
+		return _position.apply( this, arguments );
+	}
+
+	// make a copy, we don't want to modify arguments
+	options = $.extend( {}, options );
+
+	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
+		target = $( options.of ),
+		within = $.position.getWithinInfo( options.within ),
+		scrollInfo = $.position.getScrollInfo( within ),
+		collision = ( options.collision || "flip" ).split( " " ),
+		offsets = {};
+
+	dimensions = getDimensions( target );
+	if ( target[0].preventDefault ) {
+		// force left top to allow flipping
+		options.at = "left top";
+	}
+	targetWidth = dimensions.width;
+	targetHeight = dimensions.height;
+	targetOffset = dimensions.offset;
+	// clone to reuse original targetOffset later
+	basePosition = $.extend( {}, targetOffset );
+
+	// force my and at to have valid horizontal and vertical positions
+	// if a value is missing or invalid, it will be converted to center
+	$.each( [ "my", "at" ], function() {
+		var pos = ( options[ this ] || "" ).split( " " ),
+			horizontalOffset,
+			verticalOffset;
+
+		if ( pos.length === 1) {
+			pos = rhorizontal.test( pos[ 0 ] ) ?
+				pos.concat( [ "center" ] ) :
+				rvertical.test( pos[ 0 ] ) ?
+					[ "center" ].concat( pos ) :
+					[ "center", "center" ];
+		}
+		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
+		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
+
+		// calculate offsets
+		horizontalOffset = roffset.exec( pos[ 0 ] );
+		verticalOffset = roffset.exec( pos[ 1 ] );
+		offsets[ this ] = [
+			horizontalOffset ? horizontalOffset[ 0 ] : 0,
+			verticalOffset ? verticalOffset[ 0 ] : 0
+		];
+
+		// reduce to just the positions without the offsets
+		options[ this ] = [
+			rposition.exec( pos[ 0 ] )[ 0 ],
+			rposition.exec( pos[ 1 ] )[ 0 ]
+		];
+	});
+
+	// normalize collision option
+	if ( collision.length === 1 ) {
+		collision[ 1 ] = collision[ 0 ];
+	}
+
+	if ( options.at[ 0 ] === "right" ) {
+		basePosition.left += targetWidth;
+	} else if ( options.at[ 0 ] === "center" ) {
+		basePosition.left += targetWidth / 2;
+	}
+
+	if ( options.at[ 1 ] === "bottom" ) {
+		basePosition.top += targetHeight;
+	} else if ( options.at[ 1 ] === "center" ) {
+		basePosition.top += targetHeight / 2;
+	}
+
+	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
+	basePosition.left += atOffset[ 0 ];
+	basePosition.top += atOffset[ 1 ];
+
+	return this.each(function() {
+		var collisionPosition, using,
+			elem = $( this ),
+			elemWidth = elem.outerWidth(),
+			elemHeight = elem.outerHeight(),
+			marginLeft = parseCss( this, "marginLeft" ),
+			marginTop = parseCss( this, "marginTop" ),
+			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
+			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
+			position = $.extend( {}, basePosition ),
+			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
+
+		if ( options.my[ 0 ] === "right" ) {
+			position.left -= elemWidth;
+		} else if ( options.my[ 0 ] === "center" ) {
+			position.left -= elemWidth / 2;
+		}
+
+		if ( options.my[ 1 ] === "bottom" ) {
+			position.top -= elemHeight;
+		} else if ( options.my[ 1 ] === "center" ) {
+			position.top -= elemHeight / 2;
+		}
+
+		position.left += myOffset[ 0 ];
+		position.top += myOffset[ 1 ];
+
+		// if the browser doesn't support fractions, then round for consistent results
+		if ( !$.support.offsetFractions ) {
+			position.left = round( position.left );
+			position.top = round( position.top );
+		}
+
+		collisionPosition = {
+			marginLeft: marginLeft,
+			marginTop: marginTop
+		};
+
+		$.each( [ "left", "top" ], function( i, dir ) {
+			if ( $.ui.position[ collision[ i ] ] ) {
+				$.ui.position[ collision[ i ] ][ dir ]( position, {
+					targetWidth: targetWidth,
+					targetHeight: targetHeight,
+					elemWidth: elemWidth,
+					elemHeight: elemHeight,
+					collisionPosition: collisionPosition,
+					collisionWidth: collisionWidth,
+					collisionHeight: collisionHeight,
+					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
+					my: options.my,
+					at: options.at,
+					within: within,
+					elem : elem
+				});
+			}
+		});
+
+		if ( options.using ) {
+			// adds feedback as second argument to using callback, if present
+			using = function( props ) {
+				var left = targetOffset.left - position.left,
+					right = left + targetWidth - elemWidth,
+					top = targetOffset.top - position.top,
+					bottom = top + targetHeight - elemHeight,
+					feedback = {
+						target: {
+							element: target,
+							left: targetOffset.left,
+							top: targetOffset.top,
+							width: targetWidth,
+							height: targetHeight
+						},
+						element: {
+							element: elem,
+							left: position.left,
+							top: position.top,
+							width: elemWidth,
+							height: elemHeight
+						},
+						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
+						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
+					};
+				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
+					feedback.horizontal = "center";
+				}
+				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
+					feedback.vertical = "middle";
+				}
+				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
+					feedback.important = "horizontal";
+				} else {
+					feedback.important = "vertical";
+				}
+				options.using.call( this, props, feedback );
+			};
+		}
+
+		elem.offset( $.extend( position, { using: using } ) );
+	});
+};
+
+$.ui.position = {
+	fit: {
+		left: function( position, data ) {
+			var within = data.within,
+				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
+				outerWidth = within.width,
+				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
+				overLeft = withinOffset - collisionPosLeft,
+				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
+				newOverRight;
+
+			// element is wider than within
+			if ( data.collisionWidth > outerWidth ) {
+				// element is initially over the left side of within
+				if ( overLeft > 0 && overRight <= 0 ) {
+					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
+					position.left += overLeft - newOverRight;
+				// element is initially over right side of within
+				} else if ( overRight > 0 && overLeft <= 0 ) {
+					position.left = withinOffset;
+				// element is initially over both left and right sides of within
+				} else {
+					if ( overLeft > overRight ) {
+						position.left = withinOffset + outerWidth - data.collisionWidth;
+					} else {
+						position.left = withinOffset;
+					}
+				}
+			// too far left -> align with left edge
+			} else if ( overLeft > 0 ) {
+				position.left += overLeft;
+			// too far right -> align with right edge
+			} else if ( overRight > 0 ) {
+				position.left -= overRight;
+			// adjust based on position and margin
+			} else {
+				position.left = max( position.left - collisionPosLeft, position.left );
+			}
+		},
+		top: function( position, data ) {
+			var within = data.within,
+				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
+				outerHeight = data.within.height,
+				collisionPosTop = position.top - data.collisionPosition.marginTop,
+				overTop = withinOffset - collisionPosTop,
+				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
+				newOverBottom;
+
+			// element is taller than within
+			if ( data.collisionHeight > outerHeight ) {
+				// element is initially over the top of within
+				if ( overTop > 0 && overBottom <= 0 ) {
+					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
+					position.top += overTop - newOverBottom;
+				// element is initially over bottom of within
+				} else if ( overBottom > 0 && overTop <= 0 ) {
+					position.top = withinOffset;
+				// element is initially over both top and bottom of within
+				} else {
+					if ( overTop > overBottom ) {
+						position.top = withinOffset + outerHeight - data.collisionHeight;
+					} else {
+						position.top = withinOffset;
+					}
+				}
+			// too far up -> align with top
+			} else if ( overTop > 0 ) {
+				position.top += overTop;
+			// too far down -> align with bottom edge
+			} else if ( overBottom > 0 ) {
+				position.top -= overBottom;
+			// adjust based on position and margin
+			} else {
+				position.top = max( position.top - collisionPosTop, position.top );
+			}
+		}
+	},
+	flip: {
+		left: function( position, data ) {
+			var within = data.within,
+				withinOffset = within.offset.left + within.scrollLeft,
+				outerWidth = within.width,
+				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
+				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
+				overLeft = collisionPosLeft - offsetLeft,
+				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
+				myOffset = data.my[ 0 ] === "left" ?
+					-data.elemWidth :
+					data.my[ 0 ] === "right" ?
+						data.elemWidth :
+						0,
+				atOffset = data.at[ 0 ] === "left" ?
+					data.targetWidth :
+					data.at[ 0 ] === "right" ?
+						-data.targetWidth :
+						0,
+				offset = -2 * data.offset[ 0 ],
+				newOverRight,
+				newOverLeft;
+
+			if ( overLeft < 0 ) {
+				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
+				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
+					position.left += myOffset + atOffset + offset;
+				}
+			}
+			else if ( overRight > 0 ) {
+				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
+				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
+					position.left += myOffset + atOffset + offset;
+				}
+			}
+		},
+		top: function( position, data ) {
+			var within = data.within,
+				withinOffset = within.offset.top + within.scrollTop,
+				outerHeight = within.height,
+				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
+				collisionPosTop = position.top - data.collisionPosition.marginTop,
+				overTop = collisionPosTop - offsetTop,
+				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
+				top = data.my[ 1 ] === "top",
+				myOffset = top ?
+					-data.elemHeight :
+					data.my[ 1 ] === "bottom" ?
+						data.elemHeight :
+						0,
+				atOffset = data.at[ 1 ] === "top" ?
+					data.targetHeight :
+					data.at[ 1 ] === "bottom" ?
+						-data.targetHeight :
+						0,
+				offset = -2 * data.offset[ 1 ],
+				newOverTop,
+				newOverBottom;
+			if ( overTop < 0 ) {
+				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
+				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
+					position.top += myOffset + atOffset + offset;
+				}
+			}
+			else if ( overBottom > 0 ) {
+				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
+				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
+					position.top += myOffset + atOffset + offset;
+				}
+			}
+		}
+	},
+	flipfit: {
+		left: function() {
+			$.ui.position.flip.left.apply( this, arguments );
+			$.ui.position.fit.left.apply( this, arguments );
+		},
+		top: function() {
+			$.ui.position.flip.top.apply( this, arguments );
+			$.ui.position.fit.top.apply( this, arguments );
+		}
+	}
+};
+
+// fraction support test
+(function () {
+	var testElement, testElementParent, testElementStyle, offsetLeft, i,
+		body = document.getElementsByTagName( "body" )[ 0 ],
+		div = document.createElement( "div" );
+
+	//Create a "fake body" for testing based on method used in jQuery.support
+	testElement = document.createElement( body ? "div" : "body" );
+	testElementStyle = {
+		visibility: "hidden",
+		width: 0,
+		height: 0,
+		border: 0,
+		margin: 0,
+		background: "none"
+	};
+	if ( body ) {
+		$.extend( testElementStyle, {
+			position: "absolute",
+			left: "-1000px",
+			top: "-1000px"
+		});
+	}
+	for ( i in testElementStyle ) {
+		testElement.style[ i ] = testElementStyle[ i ];
+	}
+	testElement.appendChild( div );
+	testElementParent = body || document.documentElement;
+	testElementParent.insertBefore( testElement, testElementParent.firstChild );
+
+	div.style.cssText = "position: absolute; left: 10.7432222px;";
+
+	offsetLeft = $( div ).offset().left;
+	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;
+
+	testElement.innerHTML = "";
+	testElementParent.removeChild( testElement );
+})();
+
+}( jQuery ) );
+(function( $, undefined ) {
+
+function isOverAxis( x, reference, size ) {
+	return ( x > reference ) && ( x < ( reference + size ) );
+}
+
+function isFloating(item) {
+	return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
+}
+
+$.widget("ui.sortable", $.ui.mouse, {
+	version: "1.10.4",
+	widgetEventPrefix: "sort",
+	ready: false,
+	options: {
+		appendTo: "parent",
+		axis: false,
+		connectWith: false,
+		containment: false,
+		cursor: "auto",
+		cursorAt: false,
+		dropOnEmpty: true,
+		forcePlaceholderSize: false,
+		forceHelperSize: false,
+		grid: false,
+		handle: false,
+		helper: "original",
+		items: "> *",
+		opacity: false,
+		placeholder: false,
+		revert: false,
+		scroll: true,
+		scrollSensitivity: 20,
+		scrollSpeed: 20,
+		scope: "default",
+		tolerance: "intersect",
+		zIndex: 1000,
+
+		// callbacks
+		activate: null,
+		beforeStop: null,
+		change: null,
+		deactivate: null,
+		out: null,
+		over: null,
+		receive: null,
+		remove: null,
+		sort: null,
+		start: null,
+		stop: null,
+		update: null
+	},
+	_create: function() {
+
+		var o = this.options;
+		this.containerCache = {};
+		this.element.addClass("ui-sortable");
+
+		//Get the items
+		this.refresh();
+
+		//Let's determine if the items are being displayed horizontally
+		this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;
+
+		//Let's determine the parent's offset
+		this.offset = this.element.offset();
+
+		//Initialize mouse events for interaction
+		this._mouseInit();
+
+		//We're ready to go
+		this.ready = true;
+
+	},
+
+	_destroy: function() {
+		this.element
+			.removeClass("ui-sortable ui-sortable-disabled");
+		this._mouseDestroy();
+
+		for ( var i = this.items.length - 1; i >= 0; i-- ) {
+			this.items[i].item.removeData(this.widgetName + "-item");
+		}
+
+		return this;
+	},
+
+	_setOption: function(key, value){
+		if ( key === "disabled" ) {
+			this.options[ key ] = value;
+
+			this.widget().toggleClass( "ui-sortable-disabled", !!value );
+		} else {
+			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
+			$.Widget.prototype._setOption.apply(this, arguments);
+		}
+	},
+
+	_mouseCapture: function(event, overrideHandle) {
+		var currentItem = null,
+			validHandle = false,
+			that = this;
+
+		if (this.reverting) {
+			return false;
+		}
+
+		if(this.options.disabled || this.options.type === "static") {
+			return false;
+		}
+
+		//We have to refresh the items data once first
+		this._refreshItems(event);
+
+		//Find out if the clicked node (or one of its parents) is a actual item in this.items
+		$(event.target).parents().each(function() {
+			if($.data(this, that.widgetName + "-item") === that) {
+				currentItem = $(this);
+				return false;
+			}
+		});
+		if($.data(event.target, that.widgetName + "-item") === that) {
+			currentItem = $(event.target);
+		}
+
+		if(!currentItem) {
+			return false;
+		}
+		if(this.options.handle && !overrideHandle) {
+			$(this.options.handle, currentItem).find("*").addBack().each(function() {
+				if(this === event.target) {
+					validHandle = true;
+				}
+			});
+			if(!validHandle) {
+				return false;
+			}
+		}
+
+		this.currentItem = currentItem;
+		this._removeCurrentsFromItems();
+		return true;
+
+	},
+
+	_mouseStart: function(event, overrideHandle, noActivation) {
+
+		var i, body,
+			o = this.options;
+
+		this.currentContainer = this;
+
+		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
+		this.refreshPositions();
+
+		//Create and append the visible helper
+		this.helper = this._createHelper(event);
+
+		//Cache the helper size
+		this._cacheHelperProportions();
+
+		/*
+		 * - Position generation -
+		 * This block generates everything position related - it's the core of draggables.
+		 */
+
+		//Cache the margins of the original element
+		this._cacheMargins();
+
+		//Get the next scrolling parent
+		this.scrollParent = this.helper.scrollParent();
+
+		//The element's absolute position on the page minus margins
+		this.offset = this.currentItem.offset();
+		this.offset = {
+			top: this.offset.top - this.margins.top,
+			left: this.offset.left - this.margins.left
+		};
+
+		$.extend(this.offset, {
+			click: { //Where the click happened, relative to the element
+				left: event.pageX - this.offset.left,
+				top: event.pageY - this.offset.top
+			},
+			parent: this._getParentOffset(),
+			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
+		});
+
+		// Only after we got the offset, we can change the helper's position to absolute
+		// TODO: Still need to figure out a way to make relative sorting possible
+		this.helper.css("position", "absolute");
+		this.cssPosition = this.helper.css("position");
+
+		//Generate the original position
+		this.originalPosition = this._generatePosition(event);
+		this.originalPageX = event.pageX;
+		this.originalPageY = event.pageY;
+
+		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
+		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
+
+		//Cache the former DOM position
+		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };
+
+		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
+		if(this.helper[0] !== this.currentItem[0]) {
+			this.currentItem.hide();
+		}
+
+		//Create the placeholder
+		this._createPlaceholder();
+
+		//Set a containment if given in the options
+		if(o.containment) {
+			this._setContainment();
+		}
+
+		if( o.cursor && o.cursor !== "auto" ) { // cursor option
+			body = this.document.find( "body" );
+
+			// support: IE
+			this.storedCursor = body.css( "cursor" );
+			body.css( "cursor", o.cursor );
+
+			this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
+		}
+
+		if(o.opacity) { // opacity option
+			if (this.helper.css("opacity")) {
+				this._storedOpacity = this.helper.css("opacity");
+			}
+			this.helper.css("opacity", o.opacity);
+		}
+
+		if(o.zIndex) { // zIndex option
+			if (this.helper.css("zIndex")) {
+				this._storedZIndex = this.helper.css("zIndex");
+			}
+			this.helper.css("zIndex", o.zIndex);
+		}
+
+		//Prepare scrolling
+		if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
+			this.overflowOffset = this.scrollParent.offset();
+		}
+
+		//Call callbacks
+		this._trigger("start", event, this._uiHash());
+
+		//Recache the helper size
+		if(!this._preserveHelperProportions) {
+			this._cacheHelperProportions();
+		}
+
+
+		//Post "activate" events to possible containers
+		if( !noActivation ) {
+			for ( i = this.containers.length - 1; i >= 0; i-- ) {
+				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
+			}
+		}
+
+		//Prepare possible droppables
+		if($.ui.ddmanager) {
+			$.ui.ddmanager.current = this;
+		}
+
+		if ($.ui.ddmanager && !o.dropBehaviour) {
+			$.ui.ddmanager.prepareOffsets(this, event);
+		}
+
+		this.dragging = true;
+
+		this.helper.addClass("ui-sortable-helper");
+		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
+		return true;
+
+	},
+
+	_mouseDrag: function(event) {
+		var i, item, itemElement, intersection,
+			o = this.options,
+			scrolled = false;
+
+		//Compute the helpers position
+		this.position = this._generatePosition(event);
+		this.positionAbs = this._convertPositionTo("absolute");
+
+		if (!this.lastPositionAbs) {
+			this.lastPositionAbs = this.positionAbs;
+		}
+
+		//Do scrolling
+		if(this.options.scroll) {
+			if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
+
+				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
+					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
+				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
+					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
+				}
+
+				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
+					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
+				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
+					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
+				}
+
+			} else {
+
+				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
+					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
+				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
+					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
+				}
+
+				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
+					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
+				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
+					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
+				}
+
+			}
+
+			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
+				$.ui.ddmanager.prepareOffsets(this, event);
+			}
+		}
+
+		//Regenerate the absolute position used for position checks
+		this.positionAbs = this._convertPositionTo("absolute");
+
+		//Set the helper position
+		if(!this.options.axis || this.options.axis !== "y") {
+			this.helper[0].style.left = this.position.left+"px";
+		}
+		if(!this.options.axis || this.options.axis !== "x") {
+			this.helper[0].style.top = this.position.top+"px";
+		}
+
+		//Rearrange
+		for (i = this.items.length - 1; i >= 0; i--) {
+
+			//Cache variables and intersection, continue if no intersection
+			item = this.items[i];
+			itemElement = item.item[0];
+			intersection = this._intersectsWithPointer(item);
+			if (!intersection) {
+				continue;
+			}
+
+			// Only put the placeholder inside the current Container, skip all
+			// items from other containers. This works because when moving
+			// an item from one container to another the
+			// currentContainer is switched before the placeholder is moved.
+			//
+			// Without this, moving items in "sub-sortables" can cause
+			// the placeholder to jitter beetween the outer and inner container.
+			if (item.instance !== this.currentContainer) {
+				continue;
+			}
+
+			// cannot intersect with itself
+			// no useless actions that have been done before
+			// no action if the item moved is the parent of the item checked
+			if (itemElement !== this.currentItem[0] &&
+				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
+				!$.contains(this.placeholder[0], itemElement) &&
+				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
+			) {
+
+				this.direction = intersection === 1 ? "down" : "up";
+
+				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
+					this._rearrange(event, item);
+				} else {
+					break;
+				}
+
+				this._trigger("change", event, this._uiHash());
+				break;
+			}
+		}
+
+		//Post events to containers
+		this._contactContainers(event);
+
+		//Interconnect with droppables
+		if($.ui.ddmanager) {
+			$.ui.ddmanager.drag(this, event);
+		}
+
+		//Call callbacks
+		this._trigger("sort", event, this._uiHash());
+
+		this.lastPositionAbs = this.positionAbs;
+		return false;
+
+	},
+
+	_mouseStop: function(event, noPropagation) {
+
+		if(!event) {
+			return;
+		}
+
+		//If we are using droppables, inform the manager about the drop
+		if ($.ui.ddmanager && !this.options.dropBehaviour) {
+			$.ui.ddmanager.drop(this, event);
+		}
+
+		if(this.options.revert) {
+			var that = this,
+				cur = this.placeholder.offset(),
+				axis = this.options.axis,
+				animation = {};
+
+			if ( !axis || axis === "x" ) {
+				animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
+			}
+			if ( !axis || axis === "y" ) {
+				animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
+			}
+			this.reverting = true;
+			$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
+				that._clear(event);
+			});
+		} else {
+			this._clear(event, noPropagation);
+		}
+
+		return false;
+
+	},
+
+	cancel: function() {
+
+		if(this.dragging) {
+
+			this._mouseUp({ target: null });
+
+			if(this.options.helper === "original") {
+				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
+			} else {
+				this.currentItem.show();
+			}
+
+			//Post deactivating events to containers
+			for (var i = this.containers.length - 1; i >= 0; i--){
+				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
+				if(this.containers[i].containerCache.over) {
+					this.containers[i]._trigger("out", null, this._uiHash(this));
+					this.containers[i].containerCache.over = 0;
+				}
+			}
+
+		}
+
+		if (this.placeholder) {
+			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
+			if(this.placeholder[0].parentNode) {
+				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
+			}
+			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
+				this.helper.remove();
+			}
+
+			$.extend(this, {
+				helper: null,
+				dragging: false,
+				reverting: false,
+				_noFinalSort: null
+			});
+
+			if(this.domPosition.prev) {
+				$(this.domPosition.prev).after(this.currentItem);
+			} else {
+				$(this.domPosition.parent).prepend(this.currentItem);
+			}
+		}
+
+		return this;
+
+	},
+
+	serialize: function(o) {
+
+		var items = this._getItemsAsjQuery(o && o.connected),
+			str = [];
+		o = o || {};
+
+		$(items).each(function() {
+			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
+			if (res) {
+				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
+			}
+		});
+
+		if(!str.length && o.key) {
+			str.push(o.key + "=");
+		}
+
+		return str.join("&");
+
+	},
+
+	toArray: function(o) {
+
+		var items = this._getItemsAsjQuery(o && o.connected),
+			ret = [];
+
+		o = o || {};
+
+		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
+		return ret;
+
+	},
+
+	/* Be careful with the following core functions */
+	_intersectsWith: function(item) {
+
+		var x1 = this.positionAbs.left,
+			x2 = x1 + this.helperProportions.width,
+			y1 = this.positionAbs.top,
+			y2 = y1 + this.helperProportions.height,
+			l = item.left,
+			r = l + item.width,
+			t = item.top,
+			b = t + item.height,
+			dyClick = this.offset.click.top,
+			dxClick = this.offset.click.left,
+			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
+			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
+			isOverElement = isOverElementHeight && isOverElementWidth;
+
+		if ( this.options.tolerance === "pointer" ||
+			this.options.forcePointerForContainers ||
+			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
+		) {
+			return isOverElement;
+		} else {
+
+			return (l < x1 + (this.helperProportions.width / 2) && // Right Half
+				x2 - (this.helperProportions.width / 2) < r && // Left Half
+				t < y1 + (this.helperProportions.height / 2) && // Bottom Half
+				y2 - (this.helperProportions.height / 2) < b ); // Top Half
+
+		}
+	},
+
+	_intersectsWithPointer: function(item) {
+
+		var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
+			isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
+			isOverElement = isOverElementHeight && isOverElementWidth,
+			verticalDirection = this._getDragVerticalDirection(),
+			horizontalDirection = this._getDragHorizontalDirection();
+
+		if (!isOverElement) {
+			return false;
+		}
+
+		return this.floating ?
+			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
+			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );
+
+	},
+
+	_intersectsWithSides: function(item) {
+
+		var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
+			isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
+			verticalDirection = this._getDragVerticalDirection(),
+			horizontalDirection = this._getDragHorizontalDirection();
+
+		if (this.floating && horizontalDirection) {
+			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
+		} else {
+			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
+		}
+
+	},
+
+	_getDragVerticalDirection: function() {
+		var delta = this.positionAbs.top - this.lastPositionAbs.top;
+		return delta !== 0 && (delta > 0 ? "down" : "up");
+	},
+
+	_getDragHorizontalDirection: function() {
+		var delta = this.positionAbs.left - this.lastPositionAbs.left;
+		return delta !== 0 && (delta > 0 ? "right" : "left");
+	},
+
+	refresh: function(event) {
+		this._refreshItems(event);
+		this.refreshPositions();
+		return this;
+	},
+
+	_connectWith: function() {
+		var options = this.options;
+		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
+	},
+
+	_getItemsAsjQuery: function(connected) {
+
+		var i, j, cur, inst,
+			items = [],
+			queries = [],
+			connectWith = this._connectWith();
+
+		if(connectWith && connected) {
+			for (i = connectWith.length - 1; i >= 0; i--){
+				cur = $(connectWith[i]);
+				for ( j = cur.length - 1; j >= 0; j--){
+					inst = $.data(cur[j], this.widgetFullName);
+					if(inst && inst !== this && !inst.options.disabled) {
+						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
+					}
+				}
+			}
+		}
+
+		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
+
+		function addItems() {
+			items.push( this );
+		}
+		for (i = queries.length - 1; i >= 0; i--){
+			queries[i][0].each( addItems );
+		}
+
+		return $(items);
+
+	},
+
+	_removeCurrentsFromItems: function() {
+
+		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
+
+		this.items = $.grep(this.items, function (item) {
+			for (var j=0; j < list.length; j++) {
+				if(list[j] === item.item[0]) {
+					return false;
+				}
+			}
+			return true;
+		});
+
+	},
+
+	_refreshItems: function(event) {
+
+		this.items = [];
+		this.containers = [this];
+
+		var i, j, cur, inst, targetData, _queries, item, queriesLength,
+			items = this.items,
+			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
+			connectWith = this._connectWith();
+
+		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
+			for (i = connectWith.length - 1; i >= 0; i--){
+				cur = $(connectWith[i]);
+				for (j = cur.length - 1; j >= 0; j--){
+					inst = $.data(cur[j], this.widgetFullName);
+					if(inst && inst !== this && !inst.options.disabled) {
+						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
+						this.containers.push(inst);
+					}
+				}
+			}
+		}
+
+		for (i = queries.length - 1; i >= 0; i--) {
+			targetData = queries[i][1];
+			_queries = queries[i][0];
+
+			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
+				item = $(_queries[j]);
+
+				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)
+
+				items.push({
+					item: item,
+					instance: targetData,
+					width: 0, height: 0,
+					left: 0, top: 0
+				});
+			}
+		}
+
+	},
+
+	refreshPositions: function(fast) {
+
+		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
+		if(this.offsetParent && this.helper) {
+			this.offset.parent = this._getParentOffset();
+		}
+
+		var i, item, t, p;
+
+		for (i = this.items.length - 1; i >= 0; i--){
+			item = this.items[i];
+
+			//We ignore calculating positions of all connected containers when we're not over them
+			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
+				continue;
+			}
+
+			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
+
+			if (!fast) {
+				item.width = t.outerWidth();
+				item.height = t.outerHeight();
+			}
+
+			p = t.offset();
+			item.left = p.left;
+			item.top = p.top;
+		}
+
+		if(this.options.custom && this.options.custom.refreshContainers) {
+			this.options.custom.refreshContainers.call(this);
+		} else {
+			for (i = this.containers.length - 1; i >= 0; i--){
+				p = this.containers[i].element.offset();
+				this.containers[i].containerCache.left = p.left;
+				this.containers[i].containerCache.top = p.top;
+				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
+				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
+			}
+		}
+
+		return this;
+	},
+
+	_createPlaceholder: function(that) {
+		that = that || this;
+		var className,
+			o = that.options;
+
+		if(!o.placeholder || o.placeholder.constructor === String) {
+			className = o.placeholder;
+			o.placeholder = {
+				element: function() {
+
+					var nodeName = that.currentItem[0].nodeName.toLowerCase(),
+						element = $( "<" + nodeName + ">", that.document[0] )
+							.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
+							.removeClass("ui-sortable-helper");
+
+					if ( nodeName === "tr" ) {
+						that.currentItem.children().each(function() {
+							$( "<td>&#160;</td>", that.document[0] )
+								.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
+								.appendTo( element );
+						});
+					} else if ( nodeName === "img" ) {
+						element.attr( "src", that.currentItem.attr( "src" ) );
+					}
+
+					if ( !className ) {
+						element.css( "visibility", "hidden" );
+					}
+
+					return element;
+				},
+				update: function(container, p) {
+
+					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
+					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
+					if(className && !o.forcePlaceholderSize) {
+						return;
+					}
+
+					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
+					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
+					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
+				}
+			};
+		}
+
+		//Create the placeholder
+		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
+
+		//Append it after the actual current item
+		that.currentItem.after(that.placeholder);
+
+		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
+		o.placeholder.update(that, that.placeholder);
+
+	},
+
+	_contactContainers: function(event) {
+		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,
+			innermostContainer = null,
+			innermostIndex = null;
+
+		// get innermost container that intersects with item
+		for (i = this.containers.length - 1; i >= 0; i--) {
+
+			// never consider a container that's located within the item itself
+			if($.contains(this.currentItem[0], this.containers[i].element[0])) {
+				continue;
+			}
+
+			if(this._intersectsWith(this.containers[i].containerCache)) {
+
+				// if we've already found a container and it's more "inner" than this, then continue
+				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
+					continue;
+				}
+
+				innermostContainer = this.containers[i];
+				innermostIndex = i;
+
+			} else {
+				// container doesn't intersect. trigger "out" event if necessary
+				if(this.containers[i].containerCache.over) {
+					this.containers[i]._trigger("out", event, this._uiHash(this));
+					this.containers[i].containerCache.over = 0;
+				}
+			}
+
+		}
+
+		// if no intersecting containers found, return
+		if(!innermostContainer) {
+			return;
+		}
+
+		// move the item into the container if it's not there already
+		if(this.containers.length === 1) {
+			if (!this.containers[innermostIndex].containerCache.over) {
+				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
+				this.containers[innermostIndex].containerCache.over = 1;
+			}
+		} else {
+
+			//When entering a new container, we will find the item with the least distance and append our item near it
+			dist = 10000;
+			itemWithLeastDistance = null;
+			floating = innermostContainer.floating || isFloating(this.currentItem);
+			posProperty = floating ? "left" : "top";
+			sizeProperty = floating ? "width" : "height";
+			base = this.positionAbs[posProperty] + this.offset.click[posProperty];
+			for (j = this.items.length - 1; j >= 0; j--) {
+				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
+					continue;
+				}
+				if(this.items[j].item[0] === this.currentItem[0]) {
+					continue;
+				}
+				if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
+					continue;
+				}
+				cur = this.items[j].item.offset()[posProperty];
+				nearBottom = false;
+				if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
+					nearBottom = true;
+					cur += this.items[j][sizeProperty];
+				}
+
+				if(Math.abs(cur - base) < dist) {
+					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
+					this.direction = nearBottom ? "up": "down";
+				}
+			}
+
+			//Check if dropOnEmpty is enabled
+			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
+				return;
+			}
+
+			if(this.currentContainer === this.containers[innermostIndex]) {
+				return;
+			}
+
+			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
+			this._trigger("change", event, this._uiHash());
+			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
+			this.currentContainer = this.containers[innermostIndex];
+
+			//Update the placeholder
+			this.options.placeholder.update(this.currentContainer, this.placeholder);
+
+			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
+			this.containers[innermostIndex].containerCache.over = 1;
+		}
+
+
+	},
+
+	_createHelper: function(event) {
+
+		var o = this.options,
+			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
+
+		//Add the helper to the DOM if that didn't happen already
+		if(!helper.parents("body").length) {
+			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
+		}
+
+		if(helper[0] === this.currentItem[0]) {
+			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
+		}
+
+		if(!helper[0].style.width || o.forceHelperSize) {
+			helper.width(this.currentItem.width());
+		}
+		if(!helper[0].style.height || o.forceHelperSize) {
+			helper.height(this.currentItem.height());
+		}
+
+		return helper;
+
+	},
+
+	_adjustOffsetFromHelper: function(obj) {
+		if (typeof obj === "string") {
+			obj = obj.split(" ");
+		}
+		if ($.isArray(obj)) {
+			obj = {left: +obj[0], top: +obj[1] || 0};
+		}
+		if ("left" in obj) {
+			this.offset.click.left = obj.left + this.margins.left;
+		}
+		if ("right" in obj) {
+			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
+		}
+		if ("top" in obj) {
+			this.offset.click.top = obj.top + this.margins.top;
+		}
+		if ("bottom" in obj) {
+			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
+		}
+	},
+
+	_getParentOffset: function() {
+
+
+		//Get the offsetParent and cache its position
+		this.offsetParent = this.helper.offsetParent();
+		var po = this.offsetParent.offset();
+
+		// This is a special case where we need to modify a offset calculated on start, since the following happened:
+		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
+		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
+		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
+		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
+			po.left += this.scrollParent.scrollLeft();
+			po.top += this.scrollParent.scrollTop();
+		}
+
+		// This needs to be actually done for all browsers, since pageX/pageY includes this information
+		// with an ugly IE fix
+		if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
+			po = { top: 0, left: 0 };
+		}
+
+		return {
+			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
+			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
+		};
+
+	},
+
+	_getRelativeOffset: function() {
+
+		if(this.cssPosition === "relative") {
+			var p = this.currentItem.position();
+			return {
+				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
+				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
+			};
+		} else {
+			return { top: 0, left: 0 };
+		}
+
+	},
+
+	_cacheMargins: function() {
+		this.margins = {
+			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
+			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
+		};
+	},
+
+	_cacheHelperProportions: function() {
+		this.helperProportions = {
+			width: this.helper.outerWidth(),
+			height: this.helper.outerHeight()
+		};
+	},
+
+	_setContainment: function() {
+
+		var ce, co, over,
+			o = this.options;
+		if(o.containment === "parent") {
+			o.containment = this.helper[0].parentNode;
+		}
+		if(o.containment === "document" || o.containment === "window") {
+			this.containment = [
+				0 - this.offset.relative.left - this.offset.parent.left,
+				0 - this.offset.relative.top - this.offset.parent.top,
+				$(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
+				($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
+			];
+		}
+
+		if(!(/^(document|window|parent)$/).test(o.containment)) {
+			ce = $(o.containment)[0];
+			co = $(o.containment).offset();
+			over = ($(ce).css("overflow") !== "hidden");
+
+			this.containment = [
+				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
+				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
+				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
+				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
+			];
+		}
+
+	},
+
+	_convertPositionTo: function(d, pos) {
+
+		if(!pos) {
+			pos = this.position;
+		}
+		var mod = d === "absolute" ? 1 : -1,
+			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
+			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
+
+		return {
+			top: (
+				pos.top	+																// The absolute mouse position
+				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
+				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
+				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
+			),
+			left: (
+				pos.left +																// The absolute mouse position
+				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
+				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
+				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
+			)
+		};
+
+	},
+
+	_generatePosition: function(event) {
+
+		var top, left,
+			o = this.options,
+			pageX = event.pageX,
+			pageY = event.pageY,
+			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
+
+		// This is another very weird special case that only happens for relative elements:
+		// 1. If the css position is relative
+		// 2. and the scroll parent is the document or similar to the offset parent
+		// we have to refresh the relative offset during the scroll so there are no jumps
+		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
+			this.offset.relative = this._getRelativeOffset();
+		}
+
+		/*
+		 * - Position constraining -
+		 * Constrain the position to a mix of grid, containment.
+		 */
+
+		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
+
+			if(this.containment) {
+				if(event.pageX - this.offset.click.left < this.containment[0]) {
+					pageX = this.containment[0] + this.offset.click.left;
+				}
+				if(event.pageY - this.offset.click.top < this.containment[1]) {
+					pageY = this.containment[1] + this.offset.click.top;
+				}
+				if(event.pageX - this.offset.click.left > this.containment[2]) {
+					pageX = this.containment[2] + this.offset.click.left;
+				}
+				if(event.pageY - this.offset.click.top > this.containment[3]) {
+					pageY = this.containment[3] + this.offset.click.top;
+				}
+			}
+
+			if(o.grid) {
+				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
+				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
+
+				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
+				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
+			}
+
+		}
+
+		return {
+			top: (
+				pageY -																// The absolute mouse position
+				this.offset.click.top -													// Click offset (relative to the element)
+				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
+				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
+				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
+			),
+			left: (
+				pageX -																// The absolute mouse position
+				this.offset.click.left -												// Click offset (relative to the element)
+				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
+				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
+				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
+			)
+		};
+
+	},
+
+	_rearrange: function(event, i, a, hardRefresh) {
+
+		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
+
+		//Various things done here to improve the performance:
+		// 1. we create a setTimeout, that calls refreshPositions
+		// 2. on the instance, we have a counter variable, that get's higher after every append
+		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
+		// 4. this lets only the last addition to the timeout stack through
+		this.counter = this.counter ? ++this.counter : 1;
+		var counter = this.counter;
+
+		this._delay(function() {
+			if(counter === this.counter) {
+				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
+			}
+		});
+
+	},
+
+	_clear: function(event, noPropagation) {
+
+		this.reverting = false;
+		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
+		// everything else normalized again
+		var i,
+			delayedTriggers = [];
+
+		// We first have to update the dom position of the actual currentItem
+		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
+		if(!this._noFinalSort && this.currentItem.parent().length) {
+			this.placeholder.before(this.currentItem);
+		}
+		this._noFinalSort = null;
+
+		if(this.helper[0] === this.currentItem[0]) {
+			for(i in this._storedCSS) {
+				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
+					this._storedCSS[i] = "";
+				}
+			}
+			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
+		} else {
+			this.currentItem.show();
+		}
+
+		if(this.fromOutside && !noPropagation) {
+			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
+		}
+		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
+			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
+		}
+
+		// Check if the items Container has Changed and trigger appropriate
+		// events.
+		if (this !== this.currentContainer) {
+			if(!noPropagation) {
+				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
+				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
+				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
+			}
+		}
+
+
+		//Post events to containers
+		function delayEvent( type, instance, container ) {
+			return function( event ) {
+				container._trigger( type, event, instance._uiHash( instance ) );
+			};
+		}
+		for (i = this.containers.length - 1; i >= 0; i--){
+			if (!noPropagation) {
+				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
+			}
+			if(this.containers[i].containerCache.over) {
+				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
+				this.containers[i].containerCache.over = 0;
+			}
+		}
+
+		//Do what was originally in plugins
+		if ( this.storedCursor ) {
+			this.document.find( "body" ).css( "cursor", this.storedCursor );
+			this.storedStylesheet.remove();
+		}
+		if(this._storedOpacity) {
+			this.helper.css("opacity", this._storedOpacity);
+		}
+		if(this._storedZIndex) {
+			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
+		}
+
+		this.dragging = false;
+		if(this.cancelHelperRemoval) {
+			if(!noPropagation) {
+				this._trigger("beforeStop", event, this._uiHash());
+				for (i=0; i < delayedTriggers.length; i++) {
+					delayedTriggers[i].call(this, event);
+				} //Trigger all delayed events
+				this._trigger("stop", event, this._uiHash());
+			}
+
+			this.fromOutside = false;
+			return false;
+		}
+
+		if(!noPropagation) {
+			this._trigger("beforeStop", event, this._uiHash());
+		}
+
+		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
+		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
+
+		if(this.helper[0] !== this.currentItem[0]) {
+			this.helper.remove();
+		}
+		this.helper = null;
+
+		if(!noPropagation) {
+			for (i=0; i < delayedTriggers.length; i++) {
+				delayedTriggers[i].call(this, event);
+			} //Trigger all delayed events
+			this._trigger("stop", event, this._uiHash());
+		}
+
+		this.fromOutside = false;
+		return true;
+
+	},
+
+	_trigger: function() {
+		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
+			this.cancel();
+		}
+	},
+
+	_uiHash: function(_inst) {
+		var inst = _inst || this;
+		return {
+			helper: inst.helper,
+			placeholder: inst.placeholder || $([]),
+			position: inst.position,
+			originalPosition: inst.originalPosition,
+			offset: inst.positionAbs,
+			item: inst.currentItem,
+			sender: _inst ? _inst.element : null
+		};
+	}
+
+});
+
+})(jQuery);
diff --git a/web/src/main/webapp/js/jquery-ui-1.10.4.custom.min.js b/web/src/main/webapp/js/jquery-ui-1.10.4.custom.min.js
new file mode 100644
index 0000000000..1f86518b67
--- /dev/null
+++ b/web/src/main/webapp/js/jquery-ui-1.10.4.custom.min.js
@@ -0,0 +1,6 @@
+/*! jQuery UI - v1.10.4 - 2014-06-27
+* http://jqueryui.com
+* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.sortable.js
+* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
+
+(function(e,t){function i(t,i){var a,n,o,r=t.nodeName.toLowerCase();return"area"===r?(a=t.parentNode,n=a.name,t.href&&n&&"map"===a.nodeName.toLowerCase()?(o=e("img[usemap=#"+n+"]")[0],!!o&&s(o)):!1):(/input|select|textarea|button|object/.test(r)?!t.disabled:"a"===r?t.href||i:i)&&s(t)}function s(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}var a=0,n=/^ui-id-\d+$/;e.ui=e.ui||{},e.extend(e.ui,{version:"1.10.4",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),scrollParent:function(){var t;return t=e.ui.ie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(e.css(this,"position"))&&/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0),/fixed/.test(this.css("position"))||!t.length?e(document):t},zIndex:function(i){if(i!==t)return this.css("zIndex",i);if(this.length)for(var s,a,n=e(this[0]);n.length&&n[0]!==document;){if(s=n.css("position"),("absolute"===s||"relative"===s||"fixed"===s)&&(a=parseInt(n.css("zIndex"),10),!isNaN(a)&&0!==a))return a;n=n.parent()}return 0},uniqueId:function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++a)})},removeUniqueId:function(){return this.each(function(){n.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(t){return i(t,!isNaN(e.attr(t,"tabindex")))},tabbable:function(t){var s=e.attr(t,"tabindex"),a=isNaN(s);return(a||s>=0)&&i(t,!a)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(i,s){function a(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===s?["Left","Right"]:["Top","Bottom"],o=s.toLowerCase(),r={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+s]=function(i){return i===t?r["inner"+s].call(this):this.each(function(){e(this).css(o,a(this,i)+"px")})},e.fn["outer"+s]=function(t,i){return"number"!=typeof t?r["outer"+s].call(this,t):this.each(function(){e(this).css(o,a(this,t,!0,i)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.support.selectstart="onselectstart"in document.createElement("div"),e.fn.extend({disableSelection:function(){return this.bind((e.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(e){e.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),e.extend(e.ui,{plugin:{add:function(t,i,s){var a,n=e.ui[t].prototype;for(a in s)n.plugins[a]=n.plugins[a]||[],n.plugins[a].push([i,s[a]])},call:function(e,t,i){var s,a=e.plugins[t];if(a&&e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType)for(s=0;a.length>s;s++)e.options[a[s][0]]&&a[s][1].apply(e.element,i)}},hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",a=!1;return t[s]>0?!0:(t[s]=1,a=t[s]>0,t[s]=0,a)}})})(jQuery);(function(e,t){var i=0,s=Array.prototype.slice,a=e.cleanData;e.cleanData=function(t){for(var i,s=0;null!=(i=t[s]);s++)try{e(i).triggerHandler("remove")}catch(n){}a(t)},e.widget=function(i,s,a){var n,r,o,h,l={},u=i.split(".")[0];i=i.split(".")[1],n=u+"-"+i,a||(a=s,s=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[u]=e[u]||{},r=e[u][i],o=e[u][i]=function(e,i){return this._createWidget?(arguments.length&&this._createWidget(e,i),t):new o(e,i)},e.extend(o,r,{version:a.version,_proto:e.extend({},a),_childConstructors:[]}),h=new s,h.options=e.widget.extend({},h.options),e.each(a,function(i,a){return e.isFunction(a)?(l[i]=function(){var e=function(){return s.prototype[i].apply(this,arguments)},t=function(e){return s.prototype[i].apply(this,e)};return function(){var i,s=this._super,n=this._superApply;return this._super=e,this._superApply=t,i=a.apply(this,arguments),this._super=s,this._superApply=n,i}}(),t):(l[i]=a,t)}),o.prototype=e.widget.extend(h,{widgetEventPrefix:r?h.widgetEventPrefix||i:i},l,{constructor:o,namespace:u,widgetName:i,widgetFullName:n}),r?(e.each(r._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete r._childConstructors):s._childConstructors.push(o),e.widget.bridge(i,o)},e.widget.extend=function(i){for(var a,n,r=s.call(arguments,1),o=0,h=r.length;h>o;o++)for(a in r[o])n=r[o][a],r[o].hasOwnProperty(a)&&n!==t&&(i[a]=e.isPlainObject(n)?e.isPlainObject(i[a])?e.widget.extend({},i[a],n):e.widget.extend({},n):n);return i},e.widget.bridge=function(i,a){var n=a.prototype.widgetFullName||i;e.fn[i]=function(r){var o="string"==typeof r,h=s.call(arguments,1),l=this;return r=!o&&h.length?e.widget.extend.apply(null,[r].concat(h)):r,o?this.each(function(){var s,a=e.data(this,n);return a?e.isFunction(a[r])&&"_"!==r.charAt(0)?(s=a[r].apply(a,h),s!==a&&s!==t?(l=s&&s.jquery?l.pushStack(s.get()):s,!1):t):e.error("no such method '"+r+"' for "+i+" widget instance"):e.error("cannot call methods on "+i+" prior to initialization; "+"attempted to call method '"+r+"'")}):this.each(function(){var t=e.data(this,n);t?t.option(r||{})._init():e.data(this,n,new a(r,this))}),l}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,s){s=e(s||this.defaultElement||this)[0],this.element=e(s),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this.bindings=e(),this.hoverable=e(),this.focusable=e(),s!==this&&(e.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===s&&this.destroy()}}),this.document=e(s.style?s.ownerDocument:s.document||s),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(i,s){var a,n,r,o=i;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof i)if(o={},a=i.split("."),i=a.shift(),a.length){for(n=o[i]=e.widget.extend({},this.options[i]),r=0;a.length-1>r;r++)n[a[r]]=n[a[r]]||{},n=n[a[r]];if(i=a.pop(),1===arguments.length)return n[i]===t?null:n[i];n[i]=s}else{if(1===arguments.length)return this.options[i]===t?null:this.options[i];o[i]=s}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled ui-state-disabled",!!t).attr("aria-disabled",t),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_on:function(i,s,a){var n,r=this;"boolean"!=typeof i&&(a=s,s=i,i=!1),a?(s=n=e(s),this.bindings=this.bindings.add(s)):(a=s,s=this.element,n=this.widget()),e.each(a,function(a,o){function h(){return i||r.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?r[o]:o).apply(r,arguments):t}"string"!=typeof o&&(h.guid=o.guid=o.guid||h.guid||e.guid++);var l=a.match(/^(\w+)\s*(.*)$/),u=l[1]+r.eventNamespace,d=l[2];d?n.delegate(d,u,h):s.bind(u,h)})},_off:function(e,t){t=(t||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.unbind(t).undelegate(t)},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var a,n,r=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],n=i.originalEvent)for(a in n)a in i||(i[a]=n[a]);return this.element.trigger(i,s),!(e.isFunction(r)&&r.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,a,n){"string"==typeof a&&(a={effect:a});var r,o=a?a===!0||"number"==typeof a?i:a.effect||i:t;a=a||{},"number"==typeof a&&(a={duration:a}),r=!e.isEmptyObject(a),a.complete=n,a.delay&&s.delay(a.delay),r&&e.effects&&e.effects.effect[o]?s[t](a):o!==t&&s[o]?s[o](a.duration,a.easing,n):s.queue(function(i){e(this)[t](),n&&n.call(s[0]),i()})}})})(jQuery);(function(e){var t=!1;e(document).mouseup(function(){t=!1}),e.widget("ui.mouse",{version:"1.10.4",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):undefined}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(i){if(!t){this._mouseStarted&&this._mouseUp(i),this._mouseDownEvent=i;var s=this,a=1===i.which,n="string"==typeof this.options.cancel&&i.target.nodeName?e(i.target).closest(this.options.cancel).length:!1;return a&&!n&&this._mouseCapture(i)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){s.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(i)&&this._mouseDelayMet(i)&&(this._mouseStarted=this._mouseStart(i)!==!1,!this._mouseStarted)?(i.preventDefault(),!0):(!0===e.data(i.target,this.widgetName+".preventClickEvent")&&e.removeData(i.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return s._mouseMove(e)},this._mouseUpDelegate=function(e){return s._mouseUp(e)},e(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),i.preventDefault(),t=!0,!0)):!0}},_mouseMove:function(t){return e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button?this._mouseUp(t):this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){return e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}})})(jQuery);(function(e,t){function i(e,t,i){return[parseFloat(e[0])*(p.test(e[0])?t/100:1),parseFloat(e[1])*(p.test(e[1])?i/100:1)]}function s(t,i){return parseInt(e.css(t,i),10)||0}function a(t){var i=t[0];return 9===i.nodeType?{width:t.width(),height:t.height(),offset:{top:0,left:0}}:e.isWindow(i)?{width:t.width(),height:t.height(),offset:{top:t.scrollTop(),left:t.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:t.outerWidth(),height:t.outerHeight(),offset:t.offset()}}e.ui=e.ui||{};var n,r=Math.max,o=Math.abs,h=Math.round,l=/left|center|right/,u=/top|center|bottom/,d=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,p=/%$/,m=e.fn.position;e.position={scrollbarWidth:function(){if(n!==t)return n;var i,s,a=e("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),r=a.children()[0];return e("body").append(a),i=r.offsetWidth,a.css("overflow","scroll"),s=r.offsetWidth,i===s&&(s=a[0].clientWidth),a.remove(),n=i-s},getScrollInfo:function(t){var i=t.isWindow||t.isDocument?"":t.element.css("overflow-x"),s=t.isWindow||t.isDocument?"":t.element.css("overflow-y"),a="scroll"===i||"auto"===i&&t.width<t.element[0].scrollWidth,n="scroll"===s||"auto"===s&&t.height<t.element[0].scrollHeight;return{width:n?e.position.scrollbarWidth():0,height:a?e.position.scrollbarWidth():0}},getWithinInfo:function(t){var i=e(t||window),s=e.isWindow(i[0]),a=!!i[0]&&9===i[0].nodeType;return{element:i,isWindow:s,isDocument:a,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s?i.width():i.outerWidth(),height:s?i.height():i.outerHeight()}}},e.fn.position=function(t){if(!t||!t.of)return m.apply(this,arguments);t=e.extend({},t);var n,p,f,g,v,y,b=e(t.of),_=e.position.getWithinInfo(t.within),x=e.position.getScrollInfo(_),k=(t.collision||"flip").split(" "),w={};return y=a(b),b[0].preventDefault&&(t.at="left top"),p=y.width,f=y.height,g=y.offset,v=e.extend({},g),e.each(["my","at"],function(){var e,i,s=(t[this]||"").split(" ");1===s.length&&(s=l.test(s[0])?s.concat(["center"]):u.test(s[0])?["center"].concat(s):["center","center"]),s[0]=l.test(s[0])?s[0]:"center",s[1]=u.test(s[1])?s[1]:"center",e=d.exec(s[0]),i=d.exec(s[1]),w[this]=[e?e[0]:0,i?i[0]:0],t[this]=[c.exec(s[0])[0],c.exec(s[1])[0]]}),1===k.length&&(k[1]=k[0]),"right"===t.at[0]?v.left+=p:"center"===t.at[0]&&(v.left+=p/2),"bottom"===t.at[1]?v.top+=f:"center"===t.at[1]&&(v.top+=f/2),n=i(w.at,p,f),v.left+=n[0],v.top+=n[1],this.each(function(){var a,l,u=e(this),d=u.outerWidth(),c=u.outerHeight(),m=s(this,"marginLeft"),y=s(this,"marginTop"),T=d+m+s(this,"marginRight")+x.width,D=c+y+s(this,"marginBottom")+x.height,S=e.extend({},v),N=i(w.my,u.outerWidth(),u.outerHeight());"right"===t.my[0]?S.left-=d:"center"===t.my[0]&&(S.left-=d/2),"bottom"===t.my[1]?S.top-=c:"center"===t.my[1]&&(S.top-=c/2),S.left+=N[0],S.top+=N[1],e.support.offsetFractions||(S.left=h(S.left),S.top=h(S.top)),a={marginLeft:m,marginTop:y},e.each(["left","top"],function(i,s){e.ui.position[k[i]]&&e.ui.position[k[i]][s](S,{targetWidth:p,targetHeight:f,elemWidth:d,elemHeight:c,collisionPosition:a,collisionWidth:T,collisionHeight:D,offset:[n[0]+N[0],n[1]+N[1]],my:t.my,at:t.at,within:_,elem:u})}),t.using&&(l=function(e){var i=g.left-S.left,s=i+p-d,a=g.top-S.top,n=a+f-c,h={target:{element:b,left:g.left,top:g.top,width:p,height:f},element:{element:u,left:S.left,top:S.top,width:d,height:c},horizontal:0>s?"left":i>0?"right":"center",vertical:0>n?"top":a>0?"bottom":"middle"};d>p&&p>o(i+s)&&(h.horizontal="center"),c>f&&f>o(a+n)&&(h.vertical="middle"),h.important=r(o(i),o(s))>r(o(a),o(n))?"horizontal":"vertical",t.using.call(this,e,h)}),u.offset(e.extend(S,{using:l}))})},e.ui.position={fit:{left:function(e,t){var i,s=t.within,a=s.isWindow?s.scrollLeft:s.offset.left,n=s.width,o=e.left-t.collisionPosition.marginLeft,h=a-o,l=o+t.collisionWidth-n-a;t.collisionWidth>n?h>0&&0>=l?(i=e.left+h+t.collisionWidth-n-a,e.left+=h-i):e.left=l>0&&0>=h?a:h>l?a+n-t.collisionWidth:a:h>0?e.left+=h:l>0?e.left-=l:e.left=r(e.left-o,e.left)},top:function(e,t){var i,s=t.within,a=s.isWindow?s.scrollTop:s.offset.top,n=t.within.height,o=e.top-t.collisionPosition.marginTop,h=a-o,l=o+t.collisionHeight-n-a;t.collisionHeight>n?h>0&&0>=l?(i=e.top+h+t.collisionHeight-n-a,e.top+=h-i):e.top=l>0&&0>=h?a:h>l?a+n-t.collisionHeight:a:h>0?e.top+=h:l>0?e.top-=l:e.top=r(e.top-o,e.top)}},flip:{left:function(e,t){var i,s,a=t.within,n=a.offset.left+a.scrollLeft,r=a.width,h=a.isWindow?a.scrollLeft:a.offset.left,l=e.left-t.collisionPosition.marginLeft,u=l-h,d=l+t.collisionWidth-r-h,c="left"===t.my[0]?-t.elemWidth:"right"===t.my[0]?t.elemWidth:0,p="left"===t.at[0]?t.targetWidth:"right"===t.at[0]?-t.targetWidth:0,m=-2*t.offset[0];0>u?(i=e.left+c+p+m+t.collisionWidth-r-n,(0>i||o(u)>i)&&(e.left+=c+p+m)):d>0&&(s=e.left-t.collisionPosition.marginLeft+c+p+m-h,(s>0||d>o(s))&&(e.left+=c+p+m))},top:function(e,t){var i,s,a=t.within,n=a.offset.top+a.scrollTop,r=a.height,h=a.isWindow?a.scrollTop:a.offset.top,l=e.top-t.collisionPosition.marginTop,u=l-h,d=l+t.collisionHeight-r-h,c="top"===t.my[1],p=c?-t.elemHeight:"bottom"===t.my[1]?t.elemHeight:0,m="top"===t.at[1]?t.targetHeight:"bottom"===t.at[1]?-t.targetHeight:0,f=-2*t.offset[1];0>u?(s=e.top+p+m+f+t.collisionHeight-r-n,e.top+p+m+f>u&&(0>s||o(u)>s)&&(e.top+=p+m+f)):d>0&&(i=e.top-t.collisionPosition.marginTop+p+m+f-h,e.top+p+m+f>d&&(i>0||d>o(i))&&(e.top+=p+m+f))}},flipfit:{left:function(){e.ui.position.flip.left.apply(this,arguments),e.ui.position.fit.left.apply(this,arguments)},top:function(){e.ui.position.flip.top.apply(this,arguments),e.ui.position.fit.top.apply(this,arguments)}}},function(){var t,i,s,a,n,r=document.getElementsByTagName("body")[0],o=document.createElement("div");t=document.createElement(r?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},r&&e.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(n in s)t.style[n]=s[n];t.appendChild(o),i=r||document.documentElement,i.insertBefore(t,i.firstChild),o.style.cssText="position: absolute; left: 10.7432222px;",a=e(o).offset().left,e.support.offsetFractions=a>10&&11>a,t.innerHTML="",i.removeChild(t)}()})(jQuery);(function(e){function t(e,t,i){return e>t&&t+i>e}function i(e){return/left|right/.test(e.css("float"))||/inline|table-cell/.test(e.css("display"))}e.widget("ui.sortable",e.ui.mouse,{version:"1.10.4",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_create:function(){var e=this.options;this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.floating=this.items.length?"x"===e.axis||i(this.items[0].item):!1,this.offset=this.element.offset(),this._mouseInit(),this.ready=!0},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled"),this._mouseDestroy();for(var e=this.items.length-1;e>=0;e--)this.items[e].item.removeData(this.widgetName+"-item");return this},_setOption:function(t,i){"disabled"===t?(this.options[t]=i,this.widget().toggleClass("ui-sortable-disabled",!!i)):e.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(t,i){var s=null,a=!1,n=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(t),e(t.target).parents().each(function(){return e.data(this,n.widgetName+"-item")===n?(s=e(this),!1):undefined}),e.data(t.target,n.widgetName+"-item")===n&&(s=e(t.target)),s?!this.options.handle||i||(e(this.options.handle,s).find("*").addBack().each(function(){this===t.target&&(a=!0)}),a)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(t,i,s){var a,n,r=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,r.cursorAt&&this._adjustOffsetFromHelper(r.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),r.containment&&this._setContainment(),r.cursor&&"auto"!==r.cursor&&(n=this.document.find("body"),this.storedCursor=n.css("cursor"),n.css("cursor",r.cursor),this.storedStylesheet=e("<style>*{ cursor: "+r.cursor+" !important; }</style>").appendTo(n)),r.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",r.opacity)),r.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",r.zIndex)),this.scrollParent[0]!==document&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(a=this.containers.length-1;a>=0;a--)this.containers[a]._trigger("activate",t,this._uiHash(this));return e.ui.ddmanager&&(e.ui.ddmanager.current=this),e.ui.ddmanager&&!r.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(t),!0},_mouseDrag:function(t){var i,s,a,n,r=this.options,o=!1;for(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==document&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<r.scrollSensitivity?this.scrollParent[0].scrollTop=o=this.scrollParent[0].scrollTop+r.scrollSpeed:t.pageY-this.overflowOffset.top<r.scrollSensitivity&&(this.scrollParent[0].scrollTop=o=this.scrollParent[0].scrollTop-r.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<r.scrollSensitivity?this.scrollParent[0].scrollLeft=o=this.scrollParent[0].scrollLeft+r.scrollSpeed:t.pageX-this.overflowOffset.left<r.scrollSensitivity&&(this.scrollParent[0].scrollLeft=o=this.scrollParent[0].scrollLeft-r.scrollSpeed)):(t.pageY-e(document).scrollTop()<r.scrollSensitivity?o=e(document).scrollTop(e(document).scrollTop()-r.scrollSpeed):e(window).height()-(t.pageY-e(document).scrollTop())<r.scrollSensitivity&&(o=e(document).scrollTop(e(document).scrollTop()+r.scrollSpeed)),t.pageX-e(document).scrollLeft()<r.scrollSensitivity?o=e(document).scrollLeft(e(document).scrollLeft()-r.scrollSpeed):e(window).width()-(t.pageX-e(document).scrollLeft())<r.scrollSensitivity&&(o=e(document).scrollLeft(e(document).scrollLeft()+r.scrollSpeed))),o!==!1&&e.ui.ddmanager&&!r.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],a=s.item[0],n=this._intersectsWithPointer(s),n&&s.instance===this.currentContainer&&a!==this.currentItem[0]&&this.placeholder[1===n?"next":"prev"]()[0]!==a&&!e.contains(this.placeholder[0],a)&&("semi-dynamic"===this.options.type?!e.contains(this.element[0],a):!0)){if(this.direction=1===n?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(t,s),this._trigger("change",t,this._uiHash());break}return this._contactContainers(t),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,i){if(t){if(e.ui.ddmanager&&!this.options.dropBehaviour&&e.ui.ddmanager.drop(this,t),this.options.revert){var s=this,a=this.placeholder.offset(),n=this.options.axis,r={};n&&"x"!==n||(r.left=a.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===document.body?0:this.offsetParent[0].scrollLeft)),n&&"y"!==n||(r.top=a.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===document.body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,e(this.helper).animate(r,parseInt(this.options.revert,10)||500,function(){s._clear(t)})}else this._clear(t,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var t=this.containers.length-1;t>=0;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),e.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?e(this.domPosition.prev).after(this.currentItem):e(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},e(i).each(function(){var i=(e(t.item||this).attr(t.attribute||"id")||"").match(t.expression||/(.+)[\-=_](.+)/);i&&s.push((t.key||i[1]+"[]")+"="+(t.key&&t.expression?i[1]:i[2]))}),!s.length&&t.key&&s.push(t.key+"="),s.join("&")},toArray:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},i.each(function(){s.push(e(t.item||this).attr(t.attribute||"id")||"")}),s},_intersectsWith:function(e){var t=this.positionAbs.left,i=t+this.helperProportions.width,s=this.positionAbs.top,a=s+this.helperProportions.height,n=e.left,r=n+e.width,o=e.top,h=o+e.height,l=this.offset.click.top,u=this.offset.click.left,d="x"===this.options.axis||s+l>o&&h>s+l,c="y"===this.options.axis||t+u>n&&r>t+u,p=d&&c;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>e[this.floating?"width":"height"]?p:t+this.helperProportions.width/2>n&&r>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>o&&h>a-this.helperProportions.height/2},_intersectsWithPointer:function(e){var i="x"===this.options.axis||t(this.positionAbs.top+this.offset.click.top,e.top,e.height),s="y"===this.options.axis||t(this.positionAbs.left+this.offset.click.left,e.left,e.width),a=i&&s,n=this._getDragVerticalDirection(),r=this._getDragHorizontalDirection();return a?this.floating?r&&"right"===r||"down"===n?2:1:n&&("down"===n?2:1):!1},_intersectsWithSides:function(e){var i=t(this.positionAbs.top+this.offset.click.top,e.top+e.height/2,e.height),s=t(this.positionAbs.left+this.offset.click.left,e.left+e.width/2,e.width),a=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&s||"left"===n&&!s:a&&("down"===a&&i||"up"===a&&!i)},_getDragVerticalDirection:function(){var e=this.positionAbs.top-this.lastPositionAbs.top;return 0!==e&&(e>0?"down":"up")},_getDragHorizontalDirection:function(){var e=this.positionAbs.left-this.lastPositionAbs.left;return 0!==e&&(e>0?"right":"left")},refresh:function(e){return this._refreshItems(e),this.refreshPositions(),this},_connectWith:function(){var e=this.options;return e.connectWith.constructor===String?[e.connectWith]:e.connectWith},_getItemsAsjQuery:function(t){function i(){o.push(this)}var s,a,n,r,o=[],h=[],l=this._connectWith();if(l&&t)for(s=l.length-1;s>=0;s--)for(n=e(l[s]),a=n.length-1;a>=0;a--)r=e.data(n[a],this.widgetFullName),r&&r!==this&&!r.options.disabled&&h.push([e.isFunction(r.options.items)?r.options.items.call(r.element):e(r.options.items,r.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),r]);for(h.push([e.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):e(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return e(o)},_removeCurrentsFromItems:function(){var t=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=e.grep(this.items,function(e){for(var i=0;t.length>i;i++)if(t[i]===e.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var i,s,a,n,r,o,h,l,u=this.items,d=[[e.isFunction(this.options.items)?this.options.items.call(this.element[0],t,{item:this.currentItem}):e(this.options.items,this.element),this]],c=this._connectWith();if(c&&this.ready)for(i=c.length-1;i>=0;i--)for(a=e(c[i]),s=a.length-1;s>=0;s--)n=e.data(a[s],this.widgetFullName),n&&n!==this&&!n.options.disabled&&(d.push([e.isFunction(n.options.items)?n.options.items.call(n.element[0],t,{item:this.currentItem}):e(n.options.items,n.element),n]),this.containers.push(n));for(i=d.length-1;i>=0;i--)for(r=d[i][1],o=d[i][0],s=0,l=o.length;l>s;s++)h=e(o[s]),h.data(this.widgetName+"-item",r),u.push({item:h,instance:r,width:0,height:0,left:0,top:0})},refreshPositions:function(t){this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,a,n;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(a=this.options.toleranceElement?e(this.options.toleranceElement,s.item):s.item,t||(s.width=a.outerWidth(),s.height=a.outerHeight()),n=a.offset(),s.left=n.left,s.top=n.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)n=this.containers[i].element.offset(),this.containers[i].containerCache.left=n.left,this.containers[i].containerCache.top=n.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(t){t=t||this;var i,s=t.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=t.currentItem[0].nodeName.toLowerCase(),a=e("<"+s+">",t.document[0]).addClass(i||t.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper");return"tr"===s?t.currentItem.children().each(function(){e("<td>&#160;</td>",t.document[0]).attr("colspan",e(this).attr("colspan")||1).appendTo(a)}):"img"===s&&a.attr("src",t.currentItem.attr("src")),i||a.css("visibility","hidden"),a},update:function(e,a){(!i||s.forcePlaceholderSize)&&(a.height()||a.height(t.currentItem.innerHeight()-parseInt(t.currentItem.css("paddingTop")||0,10)-parseInt(t.currentItem.css("paddingBottom")||0,10)),a.width()||a.width(t.currentItem.innerWidth()-parseInt(t.currentItem.css("paddingLeft")||0,10)-parseInt(t.currentItem.css("paddingRight")||0,10)))}}),t.placeholder=e(s.placeholder.element.call(t.element,t.currentItem)),t.currentItem.after(t.placeholder),s.placeholder.update(t,t.placeholder)},_contactContainers:function(s){var a,n,r,o,h,l,u,d,c,p,m=null,f=null;for(a=this.containers.length-1;a>=0;a--)if(!e.contains(this.currentItem[0],this.containers[a].element[0]))if(this._intersectsWith(this.containers[a].containerCache)){if(m&&e.contains(this.containers[a].element[0],m.element[0]))continue;m=this.containers[a],f=a}else this.containers[a].containerCache.over&&(this.containers[a]._trigger("out",s,this._uiHash(this)),this.containers[a].containerCache.over=0);if(m)if(1===this.containers.length)this.containers[f].containerCache.over||(this.containers[f]._trigger("over",s,this._uiHash(this)),this.containers[f].containerCache.over=1);else{for(r=1e4,o=null,p=m.floating||i(this.currentItem),h=p?"left":"top",l=p?"width":"height",u=this.positionAbs[h]+this.offset.click[h],n=this.items.length-1;n>=0;n--)e.contains(this.containers[f].element[0],this.items[n].item[0])&&this.items[n].item[0]!==this.currentItem[0]&&(!p||t(this.positionAbs.top+this.offset.click.top,this.items[n].top,this.items[n].height))&&(d=this.items[n].item.offset()[h],c=!1,Math.abs(d-u)>Math.abs(d+this.items[n][l]-u)&&(c=!0,d+=this.items[n][l]),r>Math.abs(d-u)&&(r=Math.abs(d-u),o=this.items[n],this.direction=c?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[f])return;o?this._rearrange(s,o,null,!0):this._rearrange(s,null,this.containers[f].element,!0),this._trigger("change",s,this._uiHash()),this.containers[f]._trigger("change",s,this._uiHash(this)),this.currentContainer=this.containers[f],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[f]._trigger("over",s,this._uiHash(this)),this.containers[f].containerCache.over=1}},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||e("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===document.body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var e=this.currentItem.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,a=this.options;"parent"===a.containment&&(a.containment=this.helper[0].parentNode),("document"===a.containment||"window"===a.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,e("document"===a.containment?document:window).width()-this.helperProportions.width-this.margins.left,(e("document"===a.containment?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(a.containment)||(t=e(a.containment)[0],i=e(a.containment).offset(),s="hidden"!==e(t).css("overflow"),this.containment=[i.left+(parseInt(e(t).css("borderLeftWidth"),10)||0)+(parseInt(e(t).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(e(t).css("borderTopWidth"),10)||0)+(parseInt(e(t).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(t.scrollWidth,t.offsetWidth):t.offsetWidth)-(parseInt(e(t).css("borderLeftWidth"),10)||0)-(parseInt(e(t).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(t.scrollHeight,t.offsetHeight):t.offsetHeight)-(parseInt(e(t).css("borderTopWidth"),10)||0)-(parseInt(e(t).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"===t?1:-1,a="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,n=/(html|body)/i.test(a[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():n?0:a.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():n?0:a.scrollLeft())*s}},_generatePosition:function(t){var i,s,a=this.options,n=t.pageX,r=t.pageY,o="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(o[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==document&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(n=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(r=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(n=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(r=this.containment[3]+this.offset.click.top)),a.grid&&(i=this.originalPageY+Math.round((r-this.originalPageY)/a.grid[1])*a.grid[1],r=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-a.grid[1]:i+a.grid[1]:i,s=this.originalPageX+Math.round((n-this.originalPageX)/a.grid[0])*a.grid[0],n=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-a.grid[0]:s+a.grid[0]:s)),{top:r-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:o.scrollTop()),left:n-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:o.scrollLeft())}},_rearrange:function(e,t,i,s){i?i[0].appendChild(this.placeholder[0]):t.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?t.item[0]:t.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var a=this.counter;this._delay(function(){a===this.counter&&this.refreshPositions(!s)})},_clear:function(e,t){function i(e,t,i){return function(s){i._trigger(e,s,t._uiHash(t))}}this.reverting=!1;var s,a=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!t&&a.push(function(e){this._trigger("receive",e,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||t||a.push(function(e){this._trigger("update",e,this._uiHash())}),this!==this.currentContainer&&(t||(a.push(function(e){this._trigger("remove",e,this._uiHash())}),a.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),a.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)t||a.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(a.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,this.cancelHelperRemoval){if(!t){for(this._trigger("beforeStop",e,this._uiHash()),s=0;a.length>s;s++)a[s].call(this,e);this._trigger("stop",e,this._uiHash())}return this.fromOutside=!1,!1}if(t||this._trigger("beforeStop",e,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null,!t){for(s=0;a.length>s;s++)a[s].call(this,e);this._trigger("stop",e,this._uiHash())}return this.fromOutside=!1,!0},_trigger:function(){e.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(t){var i=t||this;return{helper:i.helper,placeholder:i.placeholder||e([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:t?t.element:null}}})})(jQuery);
\ No newline at end of file
diff --git a/web/src/main/webapp/js/jquery.autocomplete.js b/web/src/main/webapp/js/jquery.autocomplete.js
index 908634f8c2..bbacf00c11 100644
--- a/web/src/main/webapp/js/jquery.autocomplete.js
+++ b/web/src/main/webapp/js/jquery.autocomplete.js
@@ -34,6 +34,7 @@
                     div.className = containerClass;
                     div.style.position = 'absolute';
                     div.style.display = 'none';
+					div.style.cursor = 'pointer';
                     return div;
                 }
             };
@@ -65,9 +66,6 @@
                 params: {},
                 formatResult: Autocomplete.formatResult,
                 onPreSelect: noop,
-                interceptData: function(params) {return params},
-                customDiv: '',
-                addDivToItem: function(suggestion) {return ''},
                 delimiter: null,
                 zIndex: 9999,
                 type: 'GET',
@@ -157,19 +155,19 @@
             if (options.width !== 'auto') {
                 container.width(options.width);
             }
-            
+
             // special on() plugin code for 'autocomplete'
             // http://api.jquery.com/on/#on-events-selector-data
             // Listen for mouse over event on suggestions list:
-            container.on('mouseenter.autocomplete', suggestionSelector, function () {
-                that.activate($(this).data('index'));
-            });
-
-            // Deselect active element when mouse leaves suggestions container:
-            container.on('mouseleave.autocomplete', suggestionSelector, function () {                
-                that.selectedIndex = -1;
-                container.children('.' + selected).removeClass(selected);
-            });
+//            container.on('mouseenter.autocomplete', suggestionSelector, function () {
+//                that.activate($(this).data('index'));
+//            });
+//
+//            // Deselect active element when mouse leaves suggestions container:
+//            container.on('mouseleave.autocomplete', suggestionSelector, function () {                
+//                that.selectedIndex = -1;
+//                container.children('.' + selected).removeClass(selected);
+//            });
 
             // Listen for click event on suggestions list:
             container.on('click.autocomplete', suggestionSelector, function () {
@@ -197,7 +195,7 @@
             var that = this;
             that.fixPosition();
             if (that.options.minChars <= that.el.val().length) {
-                that.onValueChange();
+                // that.onValueChange();
             }
         },
 
@@ -224,11 +222,7 @@
                 'z-index': options.zIndex
             });
         },
-        forceSuggest: function (val) {
-            var that = this;
-            that.currentValue=val;
-            that.getSuggestions(val);
-        },
+
         clearCache: function () {
             this.cachedResponse = {};
             this.badQueries = [];
@@ -483,12 +477,11 @@
                 that = this,
                 options = that.options,
                 serviceUrl = options.serviceUrl,
-                data = null,
+                data,
                 cacheKey;
 
             options.params[options.paramName] = q;
-            if(!options.ignoreParams)
-                data = options.interceptData(options.params);
+            data = options.ignoreParams ? null : options.params;
 
             if (that.isLocal) {
                 response = that.getSuggestionsLocal(q);
@@ -574,12 +567,8 @@
 
             // Build suggestions inner HTML:
             $.each(that.suggestions, function (i, suggestion) {
-                html += '<div class="' + className + '" data-index="' + i + '">' + formatResult(suggestion, value);
-                html += that.options.addDivToItem(suggestion);
-                html += '</div>';
+                html += '<div class="' + className + '" data-index="' + i + '">' + formatResult(suggestion, value) + '</div>';
             });
-            
-            html += that.options.customDiv;
 
             // If width is auto, adjust width before displaying suggestions,
             // because if instance was created before input had width, it will be zero.
@@ -686,10 +675,10 @@
             if(that.selectedIndex === index)
                 return null;
             
-            container.children('.' + selected).removeClass(selected);            
-            
+            container.children('.' + selected).removeClass(selected);
+
             that.selectedIndex = index;
-            
+
             if (that.selectedIndex !== -1 && children.length > that.selectedIndex) {
                 activeItem = children.get(that.selectedIndex);
                 $(activeItem).addClass(selected);
diff --git a/web/src/main/webapp/js/jquery.history.js b/web/src/main/webapp/js/jquery.history.js
index caeb7aa4b5..d16813e34f 100644
--- a/web/src/main/webapp/js/jquery.history.js
+++ b/web/src/main/webapp/js/jquery.history.js
@@ -1 +1 @@
-(function(e,t){"use strict";var n=e.History=e.History||{},r=e.jQuery;if(typeof n.Adapter!="undefined")throw new Error("History.js Adapter has already been loaded...");n.Adapter={bind:function(e,t,n){r(e).bind(t,n)},trigger:function(e,t,n){r(e).trigger(t,n)},extractEventData:function(e,n,r){var i=n&&n.originalEvent&&n.originalEvent[e]||r&&r[e]||t;return i},onDomLoad:function(e){r(e)}},typeof n.init!="undefined"&&n.init()})(window),function(e,t){"use strict";var n=e.console||t,r=e.document,i=e.navigator,s=e.sessionStorage||!1,o=e.setTimeout,u=e.clearTimeout,a=e.setInterval,f=e.clearInterval,l=e.JSON,c=e.alert,h=e.History=e.History||{},p=e.history;try{s.setItem("TEST","1"),s.removeItem("TEST")}catch(d){s=!1}l.stringify=l.stringify||l.encode,l.parse=l.parse||l.decode;if(typeof h.init!="undefined")throw new Error("History.js Core has already been loaded...");h.init=function(e){return typeof h.Adapter=="undefined"?!1:(typeof h.initCore!="undefined"&&h.initCore(),typeof h.initHtml4!="undefined"&&h.initHtml4(),!0)},h.initCore=function(d){if(typeof h.initCore.initialized!="undefined")return!1;h.initCore.initialized=!0,h.options=h.options||{},h.options.hashChangeInterval=h.options.hashChangeInterval||100,h.options.safariPollInterval=h.options.safariPollInterval||500,h.options.doubleCheckInterval=h.options.doubleCheckInterval||500,h.options.disableSuid=h.options.disableSuid||!1,h.options.storeInterval=h.options.storeInterval||1e3,h.options.busyDelay=h.options.busyDelay||250,h.options.debug=h.options.debug||!1,h.options.initialTitle=h.options.initialTitle||r.title,h.options.html4Mode=h.options.html4Mode||!1,h.options.delayInit=h.options.delayInit||!1,h.intervalList=[],h.clearAllIntervals=function(){var e,t=h.intervalList;if(typeof t!="undefined"&&t!==null){for(e=0;e<t.length;e++)f(t[e]);h.intervalList=null}},h.debug=function(){(h.options.debug||!1)&&h.log.apply(h,arguments)},h.log=function(){var e=typeof n!="undefined"&&typeof n.log!="undefined"&&typeof n.log.apply!="undefined",t=r.getElementById("log"),i,s,o,u,a;e?(u=Array.prototype.slice.call(arguments),i=u.shift(),typeof n.debug!="undefined"?n.debug.apply(n,[i,u]):n.log.apply(n,[i,u])):i="\n"+arguments[0]+"\n";for(s=1,o=arguments.length;s<o;++s){a=arguments[s];if(typeof a=="object"&&typeof l!="undefined")try{a=l.stringify(a)}catch(f){}i+="\n"+a+"\n"}return t?(t.value+=i+"\n-----\n",t.scrollTop=t.scrollHeight-t.clientHeight):e||c(i),!0},h.getInternetExplorerMajorVersion=function(){var e=h.getInternetExplorerMajorVersion.cached=typeof h.getInternetExplorerMajorVersion.cached!="undefined"?h.getInternetExplorerMajorVersion.cached:function(){var e=3,t=r.createElement("div"),n=t.getElementsByTagName("i");while((t.innerHTML="<!--[if gt IE "+ ++e+"]><i></i><![endif]-->")&&n[0]);return e>4?e:!1}();return e},h.isInternetExplorer=function(){var e=h.isInternetExplorer.cached=typeof h.isInternetExplorer.cached!="undefined"?h.isInternetExplorer.cached:Boolean(h.getInternetExplorerMajorVersion());return e},h.options.html4Mode?h.emulated={pushState:!0,hashChange:!0}:h.emulated={pushState:!Boolean(e.history&&e.history.pushState&&e.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(i.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(i.userAgent)),hashChange:Boolean(!("onhashchange"in e||"onhashchange"in r)||h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8)},h.enabled=!h.emulated.pushState,h.bugs={setHash:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),safariPoll:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),ieDoubleCheck:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<7)},h.isEmptyObject=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},h.cloneObject=function(e){var t,n;return e?(t=l.stringify(e),n=l.parse(t)):n={},n},h.getRootUrl=function(){var e=r.location.protocol+"//"+(r.location.hostname||r.location.host);if(r.location.port||!1)e+=":"+r.location.port;return e+="/",e},h.getBaseHref=function(){var e=r.getElementsByTagName("base"),t=null,n="";return e.length===1&&(t=e[0],n=t.href.replace(/[^\/]+$/,"")),n=n.replace(/\/+$/,""),n&&(n+="/"),n},h.getBaseUrl=function(){var e=h.getBaseHref()||h.getBasePageUrl()||h.getRootUrl();return e},h.getPageUrl=function(){var e=h.getState(!1,!1),t=(e||{}).url||h.getLocationHref(),n;return n=t.replace(/\/+$/,"").replace(/[^\/]+$/,function(e,t,n){return/\./.test(e)?e:e+"/"}),n},h.getBasePageUrl=function(){var e=h.getLocationHref().replace(/[#\?].*/,"").replace(/[^\/]+$/,function(e,t,n){return/[^\/]$/.test(e)?"":e}).replace(/\/+$/,"")+"/";return e},h.getFullUrl=function(e,t){var n=e,r=e.substring(0,1);return t=typeof t=="undefined"?!0:t,/[a-z]+\:\/\//.test(e)||(r==="/"?n=h.getRootUrl()+e.replace(/^\/+/,""):r==="#"?n=h.getPageUrl().replace(/#.*/,"")+e:r==="?"?n=h.getPageUrl().replace(/[\?#].*/,"")+e:t?n=h.getBaseUrl()+e.replace(/^(\.\/)+/,""):n=h.getBasePageUrl()+e.replace(/^(\.\/)+/,"")),n.replace(/\#$/,"")},h.getShortUrl=function(e){var t=e,n=h.getBaseUrl(),r=h.getRootUrl();return h.emulated.pushState&&(t=t.replace(n,"")),t=t.replace(r,"/"),h.isTraditionalAnchor(t)&&(t="./"+t),t=t.replace(/^(\.\/)+/g,"./").replace(/\#$/,""),t},h.getLocationHref=function(e){return e=e||r,e.URL===e.location.href?e.location.href:e.location.href===decodeURIComponent(e.URL)?e.URL:e.location.hash&&decodeURIComponent(e.location.href.replace(/^[^#]+/,""))===e.location.hash?e.location.href:e.URL.indexOf("#")==-1&&e.location.href.indexOf("#")!=-1?e.location.href:e.URL||e.location.href},h.store={},h.idToState=h.idToState||{},h.stateToId=h.stateToId||{},h.urlToId=h.urlToId||{},h.storedStates=h.storedStates||[],h.savedStates=h.savedStates||[],h.normalizeStore=function(){h.store.idToState=h.store.idToState||{},h.store.urlToId=h.store.urlToId||{},h.store.stateToId=h.store.stateToId||{}},h.getState=function(e,t){typeof e=="undefined"&&(e=!0),typeof t=="undefined"&&(t=!0);var n=h.getLastSavedState();return!n&&t&&(n=h.createStateObject()),e&&(n=h.cloneObject(n),n.url=n.cleanUrl||n.url),n},h.getIdByState=function(e){var t=h.extractId(e.url),n;if(!t){n=h.getStateString(e);if(typeof h.stateToId[n]!="undefined")t=h.stateToId[n];else if(typeof h.store.stateToId[n]!="undefined")t=h.store.stateToId[n];else{for(;;){t=(new Date).getTime()+String(Math.random()).replace(/\D/g,"");if(typeof h.idToState[t]=="undefined"&&typeof h.store.idToState[t]=="undefined")break}h.stateToId[n]=t,h.idToState[t]=e}}return t},h.normalizeState=function(e){var t,n;if(!e||typeof e!="object")e={};if(typeof e.normalized!="undefined")return e;if(!e.data||typeof e.data!="object")e.data={};return t={},t.normalized=!0,t.title=e.title||"",t.url=h.getFullUrl(e.url?e.url:h.getLocationHref()),t.hash=h.getShortUrl(t.url),t.data=h.cloneObject(e.data),t.id=h.getIdByState(t),t.cleanUrl=t.url.replace(/\??\&_suid.*/,""),t.url=t.cleanUrl,n=!h.isEmptyObject(t.data),(t.title||n)&&h.options.disableSuid!==!0&&(t.hash=h.getShortUrl(t.url).replace(/\??\&_suid.*/,""),/\?/.test(t.hash)||(t.hash+="?"),t.hash+="&_suid="+t.id),t.hashedUrl=h.getFullUrl(t.hash),(h.emulated.pushState||h.bugs.safariPoll)&&h.hasUrlDuplicate(t)&&(t.url=t.hashedUrl),t},h.createStateObject=function(e,t,n){var r={data:e,title:t,url:n};return r=h.normalizeState(r),r},h.getStateById=function(e){e=String(e);var n=h.idToState[e]||h.store.idToState[e]||t;return n},h.getStateString=function(e){var t,n,r;return t=h.normalizeState(e),n={data:t.data,title:e.title,url:e.url},r=l.stringify(n),r},h.getStateId=function(e){var t,n;return t=h.normalizeState(e),n=t.id,n},h.getHashByState=function(e){var t,n;return t=h.normalizeState(e),n=t.hash,n},h.extractId=function(e){var t,n,r,i;return e.indexOf("#")!=-1?i=e.split("#")[0]:i=e,n=/(.*)\&_suid=([0-9]+)$/.exec(i),r=n?n[1]||e:e,t=n?String(n[2]||""):"",t||!1},h.isTraditionalAnchor=function(e){var t=!/[\/\?\.]/.test(e);return t},h.extractState=function(e,t){var n=null,r,i;return t=t||!1,r=h.extractId(e),r&&(n=h.getStateById(r)),n||(i=h.getFullUrl(e),r=h.getIdByUrl(i)||!1,r&&(n=h.getStateById(r)),!n&&t&&!h.isTraditionalAnchor(e)&&(n=h.createStateObject(null,null,i))),n},h.getIdByUrl=function(e){var n=h.urlToId[e]||h.store.urlToId[e]||t;return n},h.getLastSavedState=function(){return h.savedStates[h.savedStates.length-1]||t},h.getLastStoredState=function(){return h.storedStates[h.storedStates.length-1]||t},h.hasUrlDuplicate=function(e){var t=!1,n;return n=h.extractState(e.url),t=n&&n.id!==e.id,t},h.storeState=function(e){return h.urlToId[e.url]=e.id,h.storedStates.push(h.cloneObject(e)),e},h.isLastSavedState=function(e){var t=!1,n,r,i;return h.savedStates.length&&(n=e.id,r=h.getLastSavedState(),i=r.id,t=n===i),t},h.saveState=function(e){return h.isLastSavedState(e)?!1:(h.savedStates.push(h.cloneObject(e)),!0)},h.getStateByIndex=function(e){var t=null;return typeof e=="undefined"?t=h.savedStates[h.savedStates.length-1]:e<0?t=h.savedStates[h.savedStates.length+e]:t=h.savedStates[e],t},h.getCurrentIndex=function(){var e=null;return h.savedStates.length<1?e=0:e=h.savedStates.length-1,e},h.getHash=function(e){var t=h.getLocationHref(e),n;return n=h.getHashByUrl(t),n},h.unescapeHash=function(e){var t=h.normalizeHash(e);return t=decodeURIComponent(t),t},h.normalizeHash=function(e){var t=e.replace(/[^#]*#/,"").replace(/#.*/,"");return t},h.setHash=function(e,t){var n,i;return t!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.setHash,args:arguments,queue:t}),!1):(h.busy(!0),n=h.extractState(e,!0),n&&!h.emulated.pushState?h.pushState(n.data,n.title,n.url,!1):h.getHash()!==e&&(h.bugs.setHash?(i=h.getPageUrl(),h.pushState(null,null,i+"#"+e,!1)):r.location.hash=e),h)},h.escapeHash=function(t){var n=h.normalizeHash(t);return n=e.encodeURIComponent(n),h.bugs.hashEscape||(n=n.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),n},h.getHashByUrl=function(e){var t=String(e).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return t=h.unescapeHash(t),t},h.setTitle=function(e){var t=e.title,n;t||(n=h.getStateByIndex(0),n&&n.url===e.url&&(t=n.title||h.options.initialTitle));try{r.getElementsByTagName("title")[0].innerHTML=t.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(i){}return r.title=t,h},h.queues=[],h.busy=function(e){typeof e!="undefined"?h.busy.flag=e:typeof h.busy.flag=="undefined"&&(h.busy.flag=!1);if(!h.busy.flag){u(h.busy.timeout);var t=function(){var e,n,r;if(h.busy.flag)return;for(e=h.queues.length-1;e>=0;--e){n=h.queues[e];if(n.length===0)continue;r=n.shift(),h.fireQueueItem(r),h.busy.timeout=o(t,h.options.busyDelay)}};h.busy.timeout=o(t,h.options.busyDelay)}return h.busy.flag},h.busy.flag=!1,h.fireQueueItem=function(e){return e.callback.apply(e.scope||h,e.args||[])},h.pushQueue=function(e){return h.queues[e.queue||0]=h.queues[e.queue||0]||[],h.queues[e.queue||0].push(e),h},h.queue=function(e,t){return typeof e=="function"&&(e={callback:e}),typeof t!="undefined"&&(e.queue=t),h.busy()?h.pushQueue(e):h.fireQueueItem(e),h},h.clearQueue=function(){return h.busy.flag=!1,h.queues=[],h},h.stateChanged=!1,h.doubleChecker=!1,h.doubleCheckComplete=function(){return h.stateChanged=!0,h.doubleCheckClear(),h},h.doubleCheckClear=function(){return h.doubleChecker&&(u(h.doubleChecker),h.doubleChecker=!1),h},h.doubleCheck=function(e){return h.stateChanged=!1,h.doubleCheckClear(),h.bugs.ieDoubleCheck&&(h.doubleChecker=o(function(){return h.doubleCheckClear(),h.stateChanged||e(),!0},h.options.doubleCheckInterval)),h},h.safariStatePoll=function(){var t=h.extractState(h.getLocationHref()),n;if(!h.isLastSavedState(t))return n=t,n||(n=h.createStateObject()),h.Adapter.trigger(e,"popstate"),h;return},h.back=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.back,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.back(!1)}),p.go(-1),!0)},h.forward=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.forward,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.forward(!1)}),p.go(1),!0)},h.go=function(e,t){var n;if(e>0)for(n=1;n<=e;++n)h.forward(t);else{if(!(e<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(n=-1;n>=e;--n)h.back(t)}return h};if(h.emulated.pushState){var v=function(){};h.pushState=h.pushState||v,h.replaceState=h.replaceState||v}else h.onPopState=function(t,n){var r=!1,i=!1,s,o;return h.doubleCheckComplete(),s=h.getHash(),s?(o=h.extractState(s||h.getLocationHref(),!0),o?h.replaceState(o.data,o.title,o.url,!1):(h.Adapter.trigger(e,"anchorchange"),h.busy(!1)),h.expectedStateId=!1,!1):(r=h.Adapter.extractEventData("state",t,n)||!1,r?i=h.getStateById(r):h.expectedStateId?i=h.getStateById(h.expectedStateId):i=h.extractState(h.getLocationHref()),i||(i=h.createStateObject(null,null,h.getLocationHref())),h.expectedStateId=!1,h.isLastSavedState(i)?(h.busy(!1),!1):(h.storeState(i),h.saveState(i),h.setTitle(i),h.Adapter.trigger(e,"statechange"),h.busy(!1),!0))},h.Adapter.bind(e,"popstate",h.onPopState),h.pushState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.pushState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.pushState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0},h.replaceState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.replaceState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.replaceState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0};if(s){try{h.store=l.parse(s.getItem("History.store"))||{}}catch(m){h.store={}}h.normalizeStore()}else h.store={},h.normalizeStore();h.Adapter.bind(e,"unload",h.clearAllIntervals),h.saveState(h.storeState(h.extractState(h.getLocationHref(),!0))),s&&(h.onUnload=function(){var e,t,n;try{e=l.parse(s.getItem("History.store"))||{}}catch(r){e={}}e.idToState=e.idToState||{},e.urlToId=e.urlToId||{},e.stateToId=e.stateToId||{};for(t in h.idToState){if(!h.idToState.hasOwnProperty(t))continue;e.idToState[t]=h.idToState[t]}for(t in h.urlToId){if(!h.urlToId.hasOwnProperty(t))continue;e.urlToId[t]=h.urlToId[t]}for(t in h.stateToId){if(!h.stateToId.hasOwnProperty(t))continue;e.stateToId[t]=h.stateToId[t]}h.store=e,h.normalizeStore(),n=l.stringify(e);try{s.setItem("History.store",n)}catch(i){if(i.code!==DOMException.QUOTA_EXCEEDED_ERR)throw i;s.length&&(s.removeItem("History.store"),s.setItem("History.store",n))}},h.intervalList.push(a(h.onUnload,h.options.storeInterval)),h.Adapter.bind(e,"beforeunload",h.onUnload),h.Adapter.bind(e,"unload",h.onUnload));if(!h.emulated.pushState){h.bugs.safariPoll&&h.intervalList.push(a(h.safariStatePoll,h.options.safariPollInterval));if(i.vendor==="Apple Computer, Inc."||(i.appCodeName||"")==="Mozilla")h.Adapter.bind(e,"hashchange",function(){h.Adapter.trigger(e,"popstate")}),h.getHash()&&h.Adapter.onDomLoad(function(){h.Adapter.trigger(e,"hashchange")})}},(!h.options||!h.options.delayInit)&&h.init()}(window)
\ No newline at end of file
+(function(e,t){"use strict";var n=e.History=e.History||{},r=e.jQuery;if(typeof n.Adapter!="undefined")throw new Error("History.js Adapter has already been loaded...");n.Adapter={bind:function(e,t,n){r(e).bind(t,n)},trigger:function(e,t,n){r(e).trigger(t,n)},extractEventData:function(e,n,r){var i=n&&n.originalEvent&&n.originalEvent[e]||r&&r[e]||t;return i},onDomLoad:function(e){r(e)}},typeof n.init!="undefined"&&n.init()})(window),function(e,t){"use strict";var n=e.console||t,r=e.document,i=e.navigator,s=!1,o=e.setTimeout,u=e.clearTimeout,a=e.setInterval,f=e.clearInterval,l=e.JSON,c=e.alert,h=e.History=e.History||{},p=e.history;try{s=e.sessionStorage,s.setItem("TEST","1"),s.removeItem("TEST")}catch(d){s=!1}l.stringify=l.stringify||l.encode,l.parse=l.parse||l.decode;if(typeof h.init!="undefined")throw new Error("History.js Core has already been loaded...");h.init=function(e){return typeof h.Adapter=="undefined"?!1:(typeof h.initCore!="undefined"&&h.initCore(),typeof h.initHtml4!="undefined"&&h.initHtml4(),!0)},h.initCore=function(d){if(typeof h.initCore.initialized!="undefined")return!1;h.initCore.initialized=!0,h.options=h.options||{},h.options.hashChangeInterval=h.options.hashChangeInterval||100,h.options.safariPollInterval=h.options.safariPollInterval||500,h.options.doubleCheckInterval=h.options.doubleCheckInterval||500,h.options.disableSuid=h.options.disableSuid||!1,h.options.storeInterval=h.options.storeInterval||1e3,h.options.busyDelay=h.options.busyDelay||250,h.options.debug=h.options.debug||!1,h.options.initialTitle=h.options.initialTitle||r.title,h.options.html4Mode=h.options.html4Mode||!1,h.options.delayInit=h.options.delayInit||!1,h.intervalList=[],h.clearAllIntervals=function(){var e,t=h.intervalList;if(typeof t!="undefined"&&t!==null){for(e=0;e<t.length;e++)f(t[e]);h.intervalList=null}},h.debug=function(){(h.options.debug||!1)&&h.log.apply(h,arguments)},h.log=function(){var e=typeof n!="undefined"&&typeof n.log!="undefined"&&typeof n.log.apply!="undefined",t=r.getElementById("log"),i,s,o,u,a;e?(u=Array.prototype.slice.call(arguments),i=u.shift(),typeof n.debug!="undefined"?n.debug.apply(n,[i,u]):n.log.apply(n,[i,u])):i="\n"+arguments[0]+"\n";for(s=1,o=arguments.length;s<o;++s){a=arguments[s];if(typeof a=="object"&&typeof l!="undefined")try{a=l.stringify(a)}catch(f){}i+="\n"+a+"\n"}return t?(t.value+=i+"\n-----\n",t.scrollTop=t.scrollHeight-t.clientHeight):e||c(i),!0},h.getInternetExplorerMajorVersion=function(){var e=h.getInternetExplorerMajorVersion.cached=typeof h.getInternetExplorerMajorVersion.cached!="undefined"?h.getInternetExplorerMajorVersion.cached:function(){var e=3,t=r.createElement("div"),n=t.getElementsByTagName("i");while((t.innerHTML="<!--[if gt IE "+ ++e+"]><i></i><![endif]-->")&&n[0]);return e>4?e:!1}();return e},h.isInternetExplorer=function(){var e=h.isInternetExplorer.cached=typeof h.isInternetExplorer.cached!="undefined"?h.isInternetExplorer.cached:Boolean(h.getInternetExplorerMajorVersion());return e},h.options.html4Mode?h.emulated={pushState:!0,hashChange:!0}:h.emulated={pushState:!Boolean(e.history&&e.history.pushState&&e.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(i.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(i.userAgent)),hashChange:Boolean(!("onhashchange"in e||"onhashchange"in r)||h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8)},h.enabled=!h.emulated.pushState,h.bugs={setHash:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),safariPoll:Boolean(!h.emulated.pushState&&i.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(i.userAgent)),ieDoubleCheck:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(h.isInternetExplorer()&&h.getInternetExplorerMajorVersion()<7)},h.isEmptyObject=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},h.cloneObject=function(e){var t,n;return e?(t=l.stringify(e),n=l.parse(t)):n={},n},h.getRootUrl=function(){var e=r.location.protocol+"//"+(r.location.hostname||r.location.host);if(r.location.port||!1)e+=":"+r.location.port;return e+="/",e},h.getBaseHref=function(){var e=r.getElementsByTagName("base"),t=null,n="";return e.length===1&&(t=e[0],n=t.href.replace(/[^\/]+$/,"")),n=n.replace(/\/+$/,""),n&&(n+="/"),n},h.getBaseUrl=function(){var e=h.getBaseHref()||h.getBasePageUrl()||h.getRootUrl();return e},h.getPageUrl=function(){var e=h.getState(!1,!1),t=(e||{}).url||h.getLocationHref(),n;return n=t.replace(/\/+$/,"").replace(/[^\/]+$/,function(e,t,n){return/\./.test(e)?e:e+"/"}),n},h.getBasePageUrl=function(){var e=h.getLocationHref().replace(/[#\?].*/,"").replace(/[^\/]+$/,function(e,t,n){return/[^\/]$/.test(e)?"":e}).replace(/\/+$/,"")+"/";return e},h.getFullUrl=function(e,t){var n=e,r=e.substring(0,1);return t=typeof t=="undefined"?!0:t,/[a-z]+\:\/\//.test(e)||(r==="/"?n=h.getRootUrl()+e.replace(/^\/+/,""):r==="#"?n=h.getPageUrl().replace(/#.*/,"")+e:r==="?"?n=h.getPageUrl().replace(/[\?#].*/,"")+e:t?n=h.getBaseUrl()+e.replace(/^(\.\/)+/,""):n=h.getBasePageUrl()+e.replace(/^(\.\/)+/,"")),n.replace(/\#$/,"")},h.getShortUrl=function(e){var t=e,n=h.getBaseUrl(),r=h.getRootUrl();return h.emulated.pushState&&(t=t.replace(n,"")),t=t.replace(r,"/"),h.isTraditionalAnchor(t)&&(t="./"+t),t=t.replace(/^(\.\/)+/g,"./").replace(/\#$/,""),t},h.getLocationHref=function(e){return e=e||r,e.URL===e.location.href?e.location.href:e.location.href===decodeURIComponent(e.URL)?e.URL:e.location.hash&&decodeURIComponent(e.location.href.replace(/^[^#]+/,""))===e.location.hash?e.location.href:e.URL.indexOf("#")==-1&&e.location.href.indexOf("#")!=-1?e.location.href:e.URL||e.location.href},h.store={},h.idToState=h.idToState||{},h.stateToId=h.stateToId||{},h.urlToId=h.urlToId||{},h.storedStates=h.storedStates||[],h.savedStates=h.savedStates||[],h.normalizeStore=function(){h.store.idToState=h.store.idToState||{},h.store.urlToId=h.store.urlToId||{},h.store.stateToId=h.store.stateToId||{}},h.getState=function(e,t){typeof e=="undefined"&&(e=!0),typeof t=="undefined"&&(t=!0);var n=h.getLastSavedState();return!n&&t&&(n=h.createStateObject()),e&&(n=h.cloneObject(n),n.url=n.cleanUrl||n.url),n},h.getIdByState=function(e){var t=h.extractId(e.url),n;if(!t){n=h.getStateString(e);if(typeof h.stateToId[n]!="undefined")t=h.stateToId[n];else if(typeof h.store.stateToId[n]!="undefined")t=h.store.stateToId[n];else{for(;;){t=(new Date).getTime()+String(Math.random()).replace(/\D/g,"");if(typeof h.idToState[t]=="undefined"&&typeof h.store.idToState[t]=="undefined")break}h.stateToId[n]=t,h.idToState[t]=e}}return t},h.normalizeState=function(e){var t,n;if(!e||typeof e!="object")e={};if(typeof e.normalized!="undefined")return e;if(!e.data||typeof e.data!="object")e.data={};return t={},t.normalized=!0,t.title=e.title||"",t.url=h.getFullUrl(e.url?e.url:h.getLocationHref()),t.hash=h.getShortUrl(t.url),t.data=h.cloneObject(e.data),t.id=h.getIdByState(t),t.cleanUrl=t.url.replace(/\??\&_suid.*/,""),t.url=t.cleanUrl,n=!h.isEmptyObject(t.data),(t.title||n)&&h.options.disableSuid!==!0&&(t.hash=h.getShortUrl(t.url).replace(/\??\&_suid.*/,""),/\?/.test(t.hash)||(t.hash+="?"),t.hash+="&_suid="+t.id),t.hashedUrl=h.getFullUrl(t.hash),(h.emulated.pushState||h.bugs.safariPoll)&&h.hasUrlDuplicate(t)&&(t.url=t.hashedUrl),t},h.createStateObject=function(e,t,n){var r={data:e,title:t,url:n};return r=h.normalizeState(r),r},h.getStateById=function(e){e=String(e);var n=h.idToState[e]||h.store.idToState[e]||t;return n},h.getStateString=function(e){var t,n,r;return t=h.normalizeState(e),n={data:t.data,title:e.title,url:e.url},r=l.stringify(n),r},h.getStateId=function(e){var t,n;return t=h.normalizeState(e),n=t.id,n},h.getHashByState=function(e){var t,n;return t=h.normalizeState(e),n=t.hash,n},h.extractId=function(e){var t,n,r,i;return e.indexOf("#")!=-1?i=e.split("#")[0]:i=e,n=/(.*)\&_suid=([0-9]+)$/.exec(i),r=n?n[1]||e:e,t=n?String(n[2]||""):"",t||!1},h.isTraditionalAnchor=function(e){var t=!/[\/\?\.]/.test(e);return t},h.extractState=function(e,t){var n=null,r,i;return t=t||!1,r=h.extractId(e),r&&(n=h.getStateById(r)),n||(i=h.getFullUrl(e),r=h.getIdByUrl(i)||!1,r&&(n=h.getStateById(r)),!n&&t&&!h.isTraditionalAnchor(e)&&(n=h.createStateObject(null,null,i))),n},h.getIdByUrl=function(e){var n=h.urlToId[e]||h.store.urlToId[e]||t;return n},h.getLastSavedState=function(){return h.savedStates[h.savedStates.length-1]||t},h.getLastStoredState=function(){return h.storedStates[h.storedStates.length-1]||t},h.hasUrlDuplicate=function(e){var t=!1,n;return n=h.extractState(e.url),t=n&&n.id!==e.id,t},h.storeState=function(e){return h.urlToId[e.url]=e.id,h.storedStates.push(h.cloneObject(e)),e},h.isLastSavedState=function(e){var t=!1,n,r,i;return h.savedStates.length&&(n=e.id,r=h.getLastSavedState(),i=r.id,t=n===i),t},h.saveState=function(e){return h.isLastSavedState(e)?!1:(h.savedStates.push(h.cloneObject(e)),!0)},h.getStateByIndex=function(e){var t=null;return typeof e=="undefined"?t=h.savedStates[h.savedStates.length-1]:e<0?t=h.savedStates[h.savedStates.length+e]:t=h.savedStates[e],t},h.getCurrentIndex=function(){var e=null;return h.savedStates.length<1?e=0:e=h.savedStates.length-1,e},h.getHash=function(e){var t=h.getLocationHref(e),n;return n=h.getHashByUrl(t),n},h.unescapeHash=function(e){var t=h.normalizeHash(e);return t=decodeURIComponent(t),t},h.normalizeHash=function(e){var t=e.replace(/[^#]*#/,"").replace(/#.*/,"");return t},h.setHash=function(e,t){var n,i;return t!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.setHash,args:arguments,queue:t}),!1):(h.busy(!0),n=h.extractState(e,!0),n&&!h.emulated.pushState?h.pushState(n.data,n.title,n.url,!1):h.getHash()!==e&&(h.bugs.setHash?(i=h.getPageUrl(),h.pushState(null,null,i+"#"+e,!1)):r.location.hash=e),h)},h.escapeHash=function(t){var n=h.normalizeHash(t);return n=e.encodeURIComponent(n),h.bugs.hashEscape||(n=n.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),n},h.getHashByUrl=function(e){var t=String(e).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return t=h.unescapeHash(t),t},h.setTitle=function(e){var t=e.title,n;t||(n=h.getStateByIndex(0),n&&n.url===e.url&&(t=n.title||h.options.initialTitle));try{r.getElementsByTagName("title")[0].innerHTML=t.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(i){}return r.title=t,h},h.queues=[],h.busy=function(e){typeof e!="undefined"?h.busy.flag=e:typeof h.busy.flag=="undefined"&&(h.busy.flag=!1);if(!h.busy.flag){u(h.busy.timeout);var t=function(){var e,n,r;if(h.busy.flag)return;for(e=h.queues.length-1;e>=0;--e){n=h.queues[e];if(n.length===0)continue;r=n.shift(),h.fireQueueItem(r),h.busy.timeout=o(t,h.options.busyDelay)}};h.busy.timeout=o(t,h.options.busyDelay)}return h.busy.flag},h.busy.flag=!1,h.fireQueueItem=function(e){return e.callback.apply(e.scope||h,e.args||[])},h.pushQueue=function(e){return h.queues[e.queue||0]=h.queues[e.queue||0]||[],h.queues[e.queue||0].push(e),h},h.queue=function(e,t){return typeof e=="function"&&(e={callback:e}),typeof t!="undefined"&&(e.queue=t),h.busy()?h.pushQueue(e):h.fireQueueItem(e),h},h.clearQueue=function(){return h.busy.flag=!1,h.queues=[],h},h.stateChanged=!1,h.doubleChecker=!1,h.doubleCheckComplete=function(){return h.stateChanged=!0,h.doubleCheckClear(),h},h.doubleCheckClear=function(){return h.doubleChecker&&(u(h.doubleChecker),h.doubleChecker=!1),h},h.doubleCheck=function(e){return h.stateChanged=!1,h.doubleCheckClear(),h.bugs.ieDoubleCheck&&(h.doubleChecker=o(function(){return h.doubleCheckClear(),h.stateChanged||e(),!0},h.options.doubleCheckInterval)),h},h.safariStatePoll=function(){var t=h.extractState(h.getLocationHref()),n;if(!h.isLastSavedState(t))return n=t,n||(n=h.createStateObject()),h.Adapter.trigger(e,"popstate"),h;return},h.back=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.back,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.back(!1)}),p.go(-1),!0)},h.forward=function(e){return e!==!1&&h.busy()?(h.pushQueue({scope:h,callback:h.forward,args:arguments,queue:e}),!1):(h.busy(!0),h.doubleCheck(function(){h.forward(!1)}),p.go(1),!0)},h.go=function(e,t){var n;if(e>0)for(n=1;n<=e;++n)h.forward(t);else{if(!(e<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(n=-1;n>=e;--n)h.back(t)}return h};if(h.emulated.pushState){var v=function(){};h.pushState=h.pushState||v,h.replaceState=h.replaceState||v}else h.onPopState=function(t,n){var r=!1,i=!1,s,o;return h.doubleCheckComplete(),s=h.getHash(),s?(o=h.extractState(s||h.getLocationHref(),!0),o?h.replaceState(o.data,o.title,o.url,!1):(h.Adapter.trigger(e,"anchorchange"),h.busy(!1)),h.expectedStateId=!1,!1):(r=h.Adapter.extractEventData("state",t,n)||!1,r?i=h.getStateById(r):h.expectedStateId?i=h.getStateById(h.expectedStateId):i=h.extractState(h.getLocationHref()),i||(i=h.createStateObject(null,null,h.getLocationHref())),h.expectedStateId=!1,h.isLastSavedState(i)?(h.busy(!1),!1):(h.storeState(i),h.saveState(i),h.setTitle(i),h.Adapter.trigger(e,"statechange"),h.busy(!1),!0))},h.Adapter.bind(e,"popstate",h.onPopState),h.pushState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.pushState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.pushState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0},h.replaceState=function(t,n,r,i){if(h.getHashByUrl(r)&&h.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(i!==!1&&h.busy())return h.pushQueue({scope:h,callback:h.replaceState,args:arguments,queue:i}),!1;h.busy(!0);var s=h.createStateObject(t,n,r);return h.isLastSavedState(s)?h.busy(!1):(h.storeState(s),h.expectedStateId=s.id,p.replaceState(s.id,s.title,s.url),h.Adapter.trigger(e,"popstate")),!0};if(s){try{h.store=l.parse(s.getItem("History.store"))||{}}catch(m){h.store={}}h.normalizeStore()}else h.store={},h.normalizeStore();h.Adapter.bind(e,"unload",h.clearAllIntervals),h.saveState(h.storeState(h.extractState(h.getLocationHref(),!0))),s&&(h.onUnload=function(){var e,t,n;try{e=l.parse(s.getItem("History.store"))||{}}catch(r){e={}}e.idToState=e.idToState||{},e.urlToId=e.urlToId||{},e.stateToId=e.stateToId||{};for(t in h.idToState){if(!h.idToState.hasOwnProperty(t))continue;e.idToState[t]=h.idToState[t]}for(t in h.urlToId){if(!h.urlToId.hasOwnProperty(t))continue;e.urlToId[t]=h.urlToId[t]}for(t in h.stateToId){if(!h.stateToId.hasOwnProperty(t))continue;e.stateToId[t]=h.stateToId[t]}h.store=e,h.normalizeStore(),n=l.stringify(e);try{s.setItem("History.store",n)}catch(i){if(i.code!==DOMException.QUOTA_EXCEEDED_ERR)throw i;s.length&&(s.removeItem("History.store"),s.setItem("History.store",n))}},h.intervalList.push(a(h.onUnload,h.options.storeInterval)),h.Adapter.bind(e,"beforeunload",h.onUnload),h.Adapter.bind(e,"unload",h.onUnload));if(!h.emulated.pushState){h.bugs.safariPoll&&h.intervalList.push(a(h.safariStatePoll,h.options.safariPollInterval));if(i.vendor==="Apple Computer, Inc."||(i.appCodeName||"")==="Mozilla")h.Adapter.bind(e,"hashchange",function(){h.Adapter.trigger(e,"popstate")}),h.getHash()&&h.Adapter.onDomLoad(function(){h.Adapter.trigger(e,"hashchange")})}},(!h.options||!h.options.delayInit)&&h.init()}(window)
\ No newline at end of file
diff --git a/web/src/main/webapp/js/leaflet.contextmenu.js b/web/src/main/webapp/js/leaflet.contextmenu.js
new file mode 100644
index 0000000000..4cae713af9
--- /dev/null
+++ b/web/src/main/webapp/js/leaflet.contextmenu.js
@@ -0,0 +1,618 @@
+/*
+Leaflet.contextmenu, a context menu for Leaflet.
+(c) 2014, Adam Ratcliffe, GeoSmart Maps Limited
+contribute 2014, Roland Braband, NRC
+ */
+L.Map.mergeOptions({
+    contextmenuItems : []
+});
+
+L.Map.ContextMenu = L.Handler.extend({
+
+        statics : {
+            BASE_CLS : 'leaflet-contextmenu'
+        },
+
+        initialize : function (map) {
+            L.Handler.prototype.initialize.call(this, map);
+
+            this._items = [];
+            this._sets = [];
+            this._state = 0;
+            this._defaultState = map.options.contextmenuDefaultState || 1;
+            this._activeState = map.options.contextmenuAtiveState || 1;
+            this._visible = false;
+
+            var container = this._container = L.DomUtil.create('div', L.Map.ContextMenu.BASE_CLS, map._container);
+            container.style.zIndex = 1e4;
+            container.style.position = 'absolute';
+
+            if (map.options.contextmenuWidth) {
+                container.style.width = map.options.contextmenuWidth + 'px';
+            }
+            if (map.options.contextmenuSets === undefined || map.options.contextmenuSets.length === 0) {
+                map.options.contextmenuSets = [{
+                        name : 'set_default',
+                        state : this._defaultState
+                    }
+                ];
+            }
+
+            this._createItems();
+            this._createSets();
+            this._changeState();
+            L.DomEvent
+            .on(container, 'click', L.DomEvent.stop)
+            .on(container, 'mousedown', L.DomEvent.stop)
+            .on(container, 'dblclick', L.DomEvent.stop)
+            .on(container, 'contextmenu', L.DomEvent.stop);
+        },
+
+        addHooks : function () {
+            L.DomEvent
+            .on(document, ((L.Browser.touch) ? 'touchstart' : 'mousedown'), this._onMouseDown, this)
+            .on(document, 'keydown', this._onKeyDown, this);
+
+            this._map.on({
+                contextmenu : this._show,
+                mouseout : this._hide,
+                mousedown : this._hide,
+                movestart : this._hide,
+                zoomstart : this._hide
+            }, this);
+        },
+
+        removeHooks : function () {
+            L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
+
+            this._map.off({
+                contextmenu : this._show,
+                mouseout : this._hide,
+                mousedown : this._hide,
+                movestart : this._hide,
+                zoomstart : this._hide
+            }, this);
+
+        },
+
+        showAt : function (point, data, state) {
+            if (point instanceof L.LatLng) {
+                point = this._map.latLngToContainerPoint(point);
+            }
+            this._showAtPoint(point, data, state);
+        },
+
+        hide : function () {
+            this._hide();
+        },
+
+        setState : function (state) {
+            return this._changeState(state);
+        },
+
+        setActiveState : function (state) {
+            var set,
+            state = (state !== undefined) ? state : this._activeState,
+            el,
+            i,
+            l;
+
+            for (i = 0, l = this._sets.length; i < l; i++) {
+                set = this._sets[i];
+                if (set.state === state) {
+                    this._activeState = state;
+                    break;
+                }
+            }
+            return set;
+        },
+
+        getState : function () {
+            return this._state;
+        },
+
+        addSet : function (options) {
+            return this.insertSet(options);
+        },
+
+        insertSet : function (options, id) {
+            var id = (id !== undefined) ? id : this._sets.length,
+            set = this._createSet(options, id);
+
+            this._sets.push(set);
+            return set;
+        },
+
+        addItem : function (options) {
+            return this.insertItem(options);
+        },
+
+        insertItem : function (options, index) {
+            var index = (index !== undefined) ? index : this._items.length,
+            item = this._createItem(this._container, options, index);
+
+            this._items.push(item);
+            this._sizeChanged = true;
+            this._map.fire('contextmenu.additem', {
+                contextmenu : this,
+                el : item.el,
+                index : index
+            });
+
+            return item.el;
+        },
+
+        removeItem : function (item) {
+            var container = this._container;
+
+            if (!isNaN(item)) {
+                item = container.children[item];
+            }
+
+            if (item !== undefined) {
+                this._removeItem(L.Util.stamp(item));
+
+                this._sizeChanged = true;
+
+                this._map.fire('contextmenu.removeitem', {
+                    contextmenu : this,
+                    el : item
+                });
+
+            }
+        },
+
+        removeAllItems : function () {
+            var item;
+            
+            while (this._container.children.length) {
+                item = this._container.children[0];
+                this._removeItem(L.Util.stamp(item));
+            }
+        },
+
+        setDisabled : function (item, disabled) {
+            var container = this._container,
+            itemCls = L.Map.ContextMenu.BASE_CLS + '-item';
+
+            if (!isNaN(item)) {
+                item = container.children[item];
+            }
+
+            if (item !== undefined && L.DomUtil.hasClass(item, itemCls)) {
+                if (disabled) {
+                    L.DomUtil.addClass(item, itemCls + '-disabled');
+                    this._map.fire('contextmenu.disableitem', {
+                        contextmenu : this,
+                        el : item
+                    });
+                } else {
+                    L.DomUtil.removeClass(item, itemCls + '-disabled');
+                    this._map.fire('contextmenu.enableitem', {
+                        contextmenu : this,
+                        el : item
+                    });
+                }
+            }
+        },
+
+        setHidden : function (item, hidden) {
+            var container = this._container,
+            itemCls = L.Map.ContextMenu.BASE_CLS + '-item',
+            separatorCls = L.Map.ContextMenu.BASE_CLS + '-separator';
+
+            if (!isNaN(item)) {
+                item = container.children[item];
+            }
+            if (item !== undefined && L.DomUtil.hasClass(item, itemCls)) {
+                if (hidden) {
+                    L.DomUtil.addClass(item, itemCls + '-hidden');
+                    this._map.fire('contextmenu.hideitem', {
+                        contextmenu : this,
+                        el : item
+                    });
+
+                } else {
+                    L.DomUtil.removeClass(item, itemCls + '-hidden');
+                    this._map.fire('contextmenu.showitem', {
+                        contextmenu : this,
+                        el : item
+                    });
+                }
+            } else if (item !== undefined && L.DomUtil.hasClass(item, separatorCls)) {
+                if (hidden) {
+                    L.DomUtil.addClass(item, separatorCls + '-hidden');
+                } else {
+                    L.DomUtil.removeClass(item, separatorCls + '-hidden');
+                }
+            }
+        },
+
+        isVisible : function () {
+            return this._visible;
+        },
+
+        // private methods
+        _changeState : function (state) {
+            var set,
+            state = (state !== undefined) ? state : this._defaultState,
+            item,
+            el,
+            i,
+            l;
+            
+            if (state !== this._state) {
+                for (i = 0, l = this._sets.length; i < l; i++) {
+                    set = this._sets[i];
+                    if (set.state === state || (set.name === state && set.state !== this._state)) {
+                        this._map.fire('contextmenu.changestate', {
+                            contextmenu : this,
+                            set : set,
+                            state : state
+                        });
+                        for (i = 0, l = this._items.length; i < l; i++) {
+                            item = this._items[i];
+                            this.setHidden(this._items[i].el, (item.state.indexOf(set.state) === -1 && item.state.indexOf(set.name) === -1));
+                        }
+                        this._sizeChanged = true;
+                        this._state = state;
+                        break;
+                    }
+                }
+            }
+            return set;
+        },
+
+        _createSets : function () {
+            var setOptions = this._map.options.contextmenuSets,
+            set,
+            i,
+            l;
+
+            for (i = 0, l = setOptions.length; i < l; i++) {
+                this._sets.push(this._createSet(setOptions[i], this._sets.length));
+            }
+        },
+
+        _createSet : function (options, id) {
+            var name = (options.name !== undefined) ? options.name : 'set_' + id;
+            return {
+                id : id,
+                name : options.name,
+                state : options.state
+            };
+        },
+
+        _createItems : function () {
+            var itemOptions = this._map.options.contextmenuItems,
+            item,
+            i,
+            l;
+
+            for (i = 0, l = itemOptions.length; i < l; i++) {
+                this._items.push(this._createItem(this._container, itemOptions[i]));
+            }
+        },
+
+        _createItem : function (container, options, index) {
+            if (options.separator || options === '-') {
+                return this._createSeparator(container, index, options.state);
+            }
+
+            var itemCls = L.Map.ContextMenu.BASE_CLS + '-item',
+            state = (options.state !== undefined) ? ((Array.isArray(options.state)) ? options.state : [options.state]) : [this._defaultState],
+            cls = (options.disabled) ? (itemCls + ' ' + itemCls + '-disabled') : ((options.hidden) ? (itemCls + ' ' + itemCls + '-hidden') : itemCls),
+            el = this._insertElementAt('a', cls, container, index),
+            callback = this._createEventHandler(el, options.callback, options.context, options.hideOnSelect),
+            html = '';
+
+            if (options.icon) {
+                html = '<img class="' + L.Map.ContextMenu.BASE_CLS + '-icon" src="' + options.icon + '"/>';
+            } else if (options.iconCls) {
+                html = '<span class="' + L.Map.ContextMenu.BASE_CLS + '- icon ' + options.iconCls + '"></span>';
+            }
+
+            el.innerHTML = html + options.text;
+            el.href = '#';
+            L.DomEvent
+            .on(el, 'mouseover', this._onItemMouseOver, this)
+            .on(el, 'mouseout', this._onItemMouseOut, this)
+            .on(el, 'mousedown', L.DomEvent.stopPropagation)
+            .on(el, 'click', callback);
+
+            return {
+                id : L.Util.stamp(el),
+                el : el,
+                callback : callback,
+                state : state
+            };
+        },
+
+        _removeItem : function (id) {
+            var item,
+            callback,
+            el,
+            i,
+            l;
+
+            for (i = 0, l = this._items.length; i < l; i++) {
+                item = this._items[i];
+
+                if (item.id === id) {
+                    el = item.el;
+                    callback = item.callback;
+
+                    if (callback) {
+                        L.DomEvent
+                        .off(el, 'mouseover', this._onItemMouseOver, this)
+                        .off(el, 'mouseover', this._onItemMouseOut, this)
+                        .off(el, 'mousedown', L.DomEvent.stopPropagation)
+                        .off(el, 'click', item.callback);
+
+                    }
+
+                    this._container.removeChild(el);
+                    this._items.splice(i, 1);
+                    return item;
+
+                }
+            }
+            return null;
+        },
+
+        _createSeparator : function (container, index, state) {
+            var el = this._insertElementAt('div', L.Map.ContextMenu.BASE_CLS + '-separator', container, index),
+            state = (state !== undefined) ? ((Array.isArray(state)) ? state : [state]) : [this._defaultState];
+
+            return {
+                id : L.Util.stamp(el),
+                el : el,
+                state : state
+            };
+        },
+
+        _createEventHandler : function (el, func, context, hideOnSelect) {
+            var me = this,
+            map = this._map,
+            disabledCls = L.Map.ContextMenu.BASE_CLS + '-item-disabled',
+            hideOnSelect = (hideOnSelect !== undefined) ? hideOnSelect : true;
+
+            return function (e) {
+                if (L.DomUtil.hasClass(el, disabledCls)) {
+                    return;
+
+                }
+
+                if (hideOnSelect) {
+                    me._hide();
+
+                }
+
+                if (func) {
+                    func.call(context || map, me._showLocation);
+                }
+
+                me._map.fire('contextmenu:select', {
+                    contextmenu : me,
+                    el : el
+                });
+            };
+        },
+
+        _insertElementAt : function (tagName, className, container, index) {
+            var refEl,
+            el = document.createElement(tagName);
+
+            el.className = className;
+
+            if (index !== undefined) {
+                refEl = container.children[index];
+            }
+
+            if (refEl) {
+                container.insertBefore(el, refEl);
+            } else {
+                container.appendChild(el);
+            }
+
+            return el;
+        },
+
+        _show : function (e) {
+            this._showAtPoint(e.containerPoint);
+        },
+
+        _showAtPoint : function (pt, data, state) {
+            if (this._items.length) {
+                var map = this._map,
+                layerPoint = map.containerPointToLayerPoint(pt),
+                latlng = map.layerPointToLatLng(layerPoint),
+                event = {
+                    contextmenu : this,
+                    state : state
+                },
+                state = (state !== undefined) ? state : this._activeState;
+
+                if (data) {
+                    event = L.extend(data, event);
+                }
+
+                this._showLocation = {
+                    state : state,
+                    target : (data) ? data.relatedTarget : null,
+                    latlng : latlng,
+                    layerPoint : layerPoint,
+                    containerPoint : pt
+                };
+
+                this._setPosition(pt);
+                this._changeState(state);
+                
+                if (!this._visible) {
+                    this._container.style.display = 'block';
+                    this._visible = true;
+                } else {
+                    this._setPosition(pt);
+                }
+                
+
+                this._map.fire('contextmenu.show', event);
+            }
+        },
+
+        _hide : function () {
+            if (this._visible) {
+                this.setState(this._defaultState);
+                this._visible = false;
+                this._container.style.display = 'none';
+                this._map.fire('contextmenu.hide', {
+                    contextmenu : this
+                });
+            }
+        },
+
+        _setPosition : function (pt) {
+            var mapSize = this._map.getSize(),
+            container = this._container,
+            containerSize = this._getElementSize(container),
+            anchor;
+
+            if (this._map.options.contextmenuAnchor) {
+                anchor = L.point(this._map.options.contextmenuAnchor);
+                pt = pt.add(anchor);
+            }
+
+            container._leaflet_pos = pt;
+
+            if (pt.x + containerSize.x > mapSize.x) {
+                container.style.left = 'auto';
+                container.style.right = Math.max(mapSize.x - pt.x, 0) + 'px';
+            } else {
+                container.style.left = Math.max(pt.x, 0) + 'px';
+                container.style.right = 'auto';
+            }
+
+            if (pt.y + containerSize.y > mapSize.y) {
+                container.style.top = 'auto';
+                container.style.bottom = Math.max(mapSize.y - pt.y, 0) + 'px';
+            } else {
+                container.style.top = Math.max(pt.y, 0) + 'px';
+                container.style.bottom = 'auto';
+            }
+        },
+
+        _getElementSize : function (el) {
+            var size = this._size,
+            initialDisplay = el.style.display;
+
+            if (!size || this._sizeChanged) {
+                size = {};
+
+                el.style.left = '-999999px';
+                el.style.right = 'auto';
+                el.style.display = 'block';
+
+                size.x = el.offsetWidth;
+                size.y = el.offsetHeight;
+
+                el.style.left = 'auto';
+                el.style.display = initialDisplay;
+
+                this._sizeChanged = false;
+            }
+
+            return size;
+        },
+
+        _onMouseDown : function (e) {
+            //console.log('_onMouseDown');
+            this._hide();
+        },
+
+        _onKeyDown : function (e) {
+            var key = e.keyCode;
+
+            // If ESC pressed and context menu is visible hide it
+            if (key === 27) {
+                this._hide();
+            }
+        },
+
+        _onItemMouseOver : function (e) {
+            L.DomUtil.addClass(e.target, 'over');
+        },
+
+        _onItemMouseOut : function (e) {
+            L.DomUtil.removeClass(e.target, 'over');
+        }
+    });
+
+L.Map.addInitHook('addHandler', 'contextmenu', L.Map.ContextMenu);
+L.Mixin.ContextMenu = {
+
+    // private methods
+    _initContextMenu : function () {
+        this._items = [];
+
+        this.on('contextmenu', this._showContextMenu, this);
+    },
+
+    _showContextMenu : function (e) {
+        var itemOptions,
+        pt,
+        i,
+        l;
+
+        if (this._map.contextmenu) {
+            pt = this._map.mouseEventToContainerPoint(e.originalEvent);
+
+            for (i = 0, l = this.options.contextmenuItems.length; i < l; i++) {
+                itemOptions = this.options.contextmenuItems[i];
+                this._items.push(this._map.contextmenu.insertItem(itemOptions, itemOptions.index));
+            }
+
+            this._map.once('contextmenu.hide', this._hideContextMenu, this);
+
+            this._map.contextmenu.showAt(pt, {
+                relatedTarget : this
+            },
+            this.options.contextmenuAtiveState);
+        }
+    },
+
+    _hideContextMenu : function () {
+        var i,
+        l;
+
+        for (i = 0, l = this._items.length; i < l; i++) {
+            this._map.contextmenu.removeItem(this._items[i]);
+        }
+        this._items.length = 0;
+    }
+};
+
+L.Marker.mergeOptions({
+    contextmenu : false,
+    contextmenuItems : []
+});
+
+L.Marker.addInitHook(function () {
+    if (this.options.contextmenu) {
+        this._initContextMenu();
+    }
+});
+
+L.Marker.include(L.Mixin.ContextMenu);
+
+L.Path.mergeOptions({
+    contextmenu : false,
+    contextmenuItems : []
+});
+
+L.Path.addInitHook(function () {
+    if (this.options.contextmenu) {
+        this._initContextMenu();
+    }
+});
+
+L.Path.include(L.Mixin.ContextMenu);
\ No newline at end of file
diff --git a/web/src/main/webapp/js/leaflet.js b/web/src/main/webapp/js/leaflet.js
index 1d4c6e5450..03434b77db 100644
--- a/web/src/main/webapp/js/leaflet.js
+++ b/web/src/main/webapp/js/leaflet.js
@@ -3,7 +3,7 @@
  (c) 2010-2013, Vladimir Agafonkin
  (c) 2010-2011, CloudMade
 */
-!function(t,e,i){var n=t.L,o={};o.version="0.6.4","object"==typeof module&&"object"==typeof module.exports?module.exports=o:"function"==typeof define&&define.amd&&define(o),o.noConflict=function(){return t.L=n,this},t.L=o,o.Util={extend:function(t){var e,i,n,o,s=Array.prototype.slice.call(arguments,1);for(i=0,n=s.length;n>i;i++){o=s[i]||{};for(e in o)o.hasOwnProperty(e)&&(t[e]=o[e])}return t},bind:function(t,e){var i=arguments.length>2?Array.prototype.slice.call(arguments,2):null;return function(){return t.apply(e,i||arguments)}},stamp:function(){var t=0,e="_leaflet_id";return function(i){return i[e]=i[e]||++t,i[e]}}(),invokeEach:function(t,e,i){var n,o;if("object"==typeof t){o=Array.prototype.slice.call(arguments,3);for(n in t)e.apply(i,[n,t[n]].concat(o));return!0}return!1},limitExecByInterval:function(t,e,i){var n,o;return function s(){var a=arguments;return n?(o=!0,void 0):(n=!0,setTimeout(function(){n=!1,o&&(s.apply(i,a),o=!1)},e),t.apply(i,a),void 0)}},falseFn:function(){return!1},formatNum:function(t,e){var i=Math.pow(10,e||5);return Math.round(t*i)/i},trim:function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")},splitWords:function(t){return o.Util.trim(t).split(/\s+/)},setOptions:function(t,e){return t.options=o.extend({},t.options,e),t.options},getParamString:function(t,e,i){var n=[];for(var o in t)n.push(encodeURIComponent(i?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(e&&-1!==e.indexOf("?")?"&":"?")+n.join("&")},template:function(t,e){return t.replace(/\{ *([\w_]+) *\}/g,function(t,n){var o=e[n];if(o===i)throw new Error("No value provided for variable "+t);return"function"==typeof o&&(o=o(e)),o})},isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)},emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="},function(){function e(e){var i,n,o=["webkit","moz","o","ms"];for(i=0;i<o.length&&!n;i++)n=t[o[i]+e];return n}function i(e){var i=+new Date,o=Math.max(0,16-(i-n));return n=i+o,t.setTimeout(e,o)}var n=0,s=t.requestAnimationFrame||e("RequestAnimationFrame")||i,a=t.cancelAnimationFrame||e("CancelAnimationFrame")||e("CancelRequestAnimationFrame")||function(e){t.clearTimeout(e)};o.Util.requestAnimFrame=function(e,n,a,r){return e=o.bind(e,n),a&&s===i?(e(),void 0):s.call(t,e,r)},o.Util.cancelAnimFrame=function(e){e&&a.call(t,e)}}(),o.extend=o.Util.extend,o.bind=o.Util.bind,o.stamp=o.Util.stamp,o.setOptions=o.Util.setOptions,o.Class=function(){},o.Class.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this._initHooks&&this.callInitHooks()},i=function(){};i.prototype=this.prototype;var n=new i;n.constructor=e,e.prototype=n;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&(e[s]=this[s]);t.statics&&(o.extend(e,t.statics),delete t.statics),t.includes&&(o.Util.extend.apply(null,[n].concat(t.includes)),delete t.includes),t.options&&n.options&&(t.options=o.extend({},n.options,t.options)),o.extend(n,t),n._initHooks=[];var a=this;return e.__super__=a.prototype,n.callInitHooks=function(){if(!this._initHooksCalled){a.prototype.callInitHooks&&a.prototype.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=n._initHooks.length;e>t;t++)n._initHooks[t].call(this)}},e},o.Class.include=function(t){o.extend(this.prototype,t)},o.Class.mergeOptions=function(t){o.extend(this.prototype.options,t)},o.Class.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i)};var s="_leaflet_events";o.Mixin={},o.Mixin.Events={addEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d=this[s]=this[s]||{},p=i&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)r={action:e,context:i||this},h=t[n],i?(l=h+"_idx",u=l+"_len",c=d[l]=d[l]||{},c[p]||(c[p]=[],d[u]=(d[u]||0)+1),c[p].push(r)):(d[h]=d[h]||[],d[h].push(r));return this},hasEventListeners:function(t){var e=this[s];return!!e&&(t in e&&e[t].length>0||t+"_idx"in e&&e[t+"_idx_len"]>0)},removeEventListener:function(t,e,i){if(!this[s])return this;if(!t)return this.clearAllEventListeners();if(o.Util.invokeEach(t,this.removeEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d,p,_=this[s],m=i&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)if(r=t[n],u=r+"_idx",c=u+"_len",d=_[u],e){if(h=i&&d?d[m]:_[r]){for(l=h.length-1;l>=0;l--)h[l].action!==e||i&&h[l].context!==i||(p=h.splice(l,1),p[0].action=o.Util.falseFn);i&&d&&0===h.length&&(delete d[m],_[c]--)}}else delete _[r],delete _[u];return this},clearAllEventListeners:function(){return delete this[s],this},fireEvent:function(t,e){if(!this.hasEventListeners(t))return this;var i,n,a,r,h,l=o.Util.extend({},e,{type:t,target:this}),u=this[s];if(u[t])for(i=u[t].slice(),n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context||this,l);r=u[t+"_idx"];for(h in r)if(i=r[h].slice())for(n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context||this,l);return this},addOneTimeEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addOneTimeEventListener,this,e,i))return this;var n=o.bind(function(){this.removeEventListener(t,e,i).removeEventListener(t,n,i)},this);return this.addEventListener(t,e,i).addEventListener(t,n,i)}},o.Mixin.Events.on=o.Mixin.Events.addEventListener,o.Mixin.Events.off=o.Mixin.Events.removeEventListener,o.Mixin.Events.once=o.Mixin.Events.addOneTimeEventListener,o.Mixin.Events.fire=o.Mixin.Events.fireEvent,function(){var n=!!t.ActiveXObject,s=n&&!t.XMLHttpRequest,a=n&&!e.querySelector,r=n&&!e.addEventListener,h=navigator.userAgent.toLowerCase(),l=-1!==h.indexOf("webkit"),u=-1!==h.indexOf("chrome"),c=-1!==h.indexOf("phantom"),d=-1!==h.indexOf("android"),p=-1!==h.search("android [23]"),_=typeof orientation!=i+"",m=t.navigator&&t.navigator.msPointerEnabled&&t.navigator.msMaxTouchPoints,f="devicePixelRatio"in t&&t.devicePixelRatio>1||"matchMedia"in t&&t.matchMedia("(min-resolution:144dpi)")&&t.matchMedia("(min-resolution:144dpi)").matches,g=e.documentElement,v=n&&"transition"in g.style,y="WebKitCSSMatrix"in t&&"m11"in new t.WebKitCSSMatrix,L="MozPerspective"in g.style,P="OTransition"in g.style,x=!t.L_DISABLE_3D&&(v||y||L||P)&&!c,w=!t.L_NO_TOUCH&&!c&&function(){var t="ontouchstart";if(m||t in g)return!0;var i=e.createElement("div"),n=!1;return i.setAttribute?(i.setAttribute(t,"return;"),"function"==typeof i[t]&&(n=!0),i.removeAttribute(t),i=null,n):!1}();o.Browser={ie:n,ie6:s,ie7:a,ielt9:r,webkit:l,android:d,android23:p,chrome:u,ie3d:v,webkit3d:y,gecko3d:L,opera3d:P,any3d:x,mobile:_,mobileWebkit:_&&l,mobileWebkit3d:_&&y,mobileOpera:_&&t.opera,touch:w,msTouch:m,retina:f}}(),o.Point=function(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e},o.Point.prototype={clone:function(){return new o.Point(this.x,this.y)},add:function(t){return this.clone()._add(o.point(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(o.point(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},distanceTo:function(t){t=o.point(t);var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},equals:function(t){return t=o.point(t),t.x===this.x&&t.y===this.y},contains:function(t){return t=o.point(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+o.Util.formatNum(this.x)+", "+o.Util.formatNum(this.y)+")"}},o.point=function(t,e,n){return t instanceof o.Point?t:o.Util.isArray(t)?new o.Point(t[0],t[1]):t===i||null===t?t:new o.Point(t,e,n)},o.Bounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.Bounds.prototype={extend:function(t){return t=o.point(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new o.Point((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new o.Point(this.min.x,this.max.y)},getTopRight:function(){return new o.Point(this.max.x,this.min.y)},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return t="number"==typeof t[0]||t instanceof o.Point?o.point(t):o.bounds(t),t instanceof o.Bounds?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,a=s.x>=e.x&&n.x<=i.x,r=s.y>=e.y&&n.y<=i.y;return a&&r},isValid:function(){return!(!this.min||!this.max)}},o.bounds=function(t,e){return!t||t instanceof o.Bounds?t:new o.Bounds(t,e)},o.Transformation=function(t,e,i,n){this._a=t,this._b=e,this._c=i,this._d=n},o.Transformation.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return e=e||1,t.x=e*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return e=e||1,new o.Point((t.x/e-this._b)/this._a,(t.y/e-this._d)/this._c)}},o.DomUtil={get:function(t){return"string"==typeof t?e.getElementById(t):t},getStyle:function(t,i){var n=t.style[i];if(!n&&t.currentStyle&&(n=t.currentStyle[i]),(!n||"auto"===n)&&e.defaultView){var o=e.defaultView.getComputedStyle(t,null);n=o?o[i]:null}return"auto"===n?null:n},getViewportOffset:function(t){var i,n=0,s=0,a=t,r=e.body,h=e.documentElement,l=o.Browser.ie7;do{if(n+=a.offsetTop||0,s+=a.offsetLeft||0,n+=parseInt(o.DomUtil.getStyle(a,"borderTopWidth"),10)||0,s+=parseInt(o.DomUtil.getStyle(a,"borderLeftWidth"),10)||0,i=o.DomUtil.getStyle(a,"position"),a.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}if("relative"===i&&!a.offsetLeft){var u=o.DomUtil.getStyle(a,"width"),c=o.DomUtil.getStyle(a,"max-width"),d=a.getBoundingClientRect();("none"!==u||"none"!==c)&&(s+=d.left+a.clientLeft),n+=d.top+(r.scrollTop||h.scrollTop||0);break}a=a.offsetParent}while(a);a=t;do{if(a===r)break;n-=a.scrollTop||0,s-=a.scrollLeft||0,o.DomUtil.documentIsLtr()||!o.Browser.webkit&&!l||(s+=a.scrollWidth-a.clientWidth,l&&"hidden"!==o.DomUtil.getStyle(a,"overflow-y")&&"hidden"!==o.DomUtil.getStyle(a,"overflow")&&(s+=17)),a=a.parentNode}while(a);return new o.Point(s,n)},documentIsLtr:function(){return o.DomUtil._docIsLtrCached||(o.DomUtil._docIsLtrCached=!0,o.DomUtil._docIsLtr="ltr"===o.DomUtil.getStyle(e.body,"direction")),o.DomUtil._docIsLtr},create:function(t,i,n){var o=e.createElement(t);return o.className=i,n&&n.appendChild(o),o},hasClass:function(t,e){return t.className.length>0&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(t.className)},addClass:function(t,e){o.DomUtil.hasClass(t,e)||(t.className+=(t.className?" ":"")+e)},removeClass:function(t,e){t.className=o.Util.trim((" "+t.className+" ").replace(" "+e+" "," "))},setOpacity:function(t,e){if("opacity"in t.style)t.style.opacity=e;else if("filter"in t.style){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(o){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"}},testProp:function(t){for(var i=e.documentElement.style,n=0;n<t.length;n++)if(t[n]in i)return t[n];return!1},getTranslateString:function(t){var e=o.Browser.webkit3d,i="translate"+(e?"3d":"")+"(",n=(e?",0":"")+")";return i+t.x+"px,"+t.y+"px"+n},getScaleString:function(t,e){var i=o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1*t))),n=" scale("+t+") ";return i+n},setPosition:function(t,e,i){t._leaflet_pos=e,!i&&o.Browser.any3d?(t.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(e),o.Browser.mobileWebkit3d&&(t.style.WebkitBackfaceVisibility="hidden")):(t.style.left=e.x+"px",t.style.top=e.y+"px")},getPosition:function(t){return t._leaflet_pos}},o.DomUtil.TRANSFORM=o.DomUtil.testProp(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),o.DomUtil.TRANSITION=o.DomUtil.testProp(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),o.DomUtil.TRANSITION_END="webkitTransition"===o.DomUtil.TRANSITION||"OTransition"===o.DomUtil.TRANSITION?o.DomUtil.TRANSITION+"End":"transitionend",function(){var i=o.DomUtil.testProp(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);o.extend(o.DomUtil,{disableTextSelection:function(){if(o.DomEvent.on(t,"selectstart",o.DomEvent.preventDefault),i){var n=e.documentElement.style;this._userSelect=n[i],n[i]="none"}},enableTextSelection:function(){o.DomEvent.off(t,"selectstart",o.DomEvent.preventDefault),i&&(e.documentElement.style[i]=this._userSelect,delete this._userSelect)},disableImageDrag:function(){o.DomEvent.on(t,"dragstart",o.DomEvent.preventDefault)},enableImageDrag:function(){o.DomEvent.off(t,"dragstart",o.DomEvent.preventDefault)}})}(),o.LatLng=function(t,e){var i=parseFloat(t),n=parseFloat(e);if(isNaN(i)||isNaN(n))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=i,this.lng=n},o.extend(o.LatLng,{DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,MAX_MARGIN:1e-9}),o.LatLng.prototype={equals:function(t){if(!t)return!1;t=o.latLng(t);var e=Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng));return e<=o.LatLng.MAX_MARGIN},toString:function(t){return"LatLng("+o.Util.formatNum(this.lat,t)+", "+o.Util.formatNum(this.lng,t)+")"},distanceTo:function(t){t=o.latLng(t);var e=6378137,i=o.LatLng.DEG_TO_RAD,n=(t.lat-this.lat)*i,s=(t.lng-this.lng)*i,a=this.lat*i,r=t.lat*i,h=Math.sin(n/2),l=Math.sin(s/2),u=h*h+l*l*Math.cos(a)*Math.cos(r);return 2*e*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))},wrap:function(t,e){var i=this.lng;return t=t||-180,e=e||180,i=(i+e)%(e-t)+(t>i||i===e?e:t),new o.LatLng(this.lat,i)}},o.latLng=function(t,e){return t instanceof o.LatLng?t:o.Util.isArray(t)?new o.LatLng(t[0],t[1]):t===i||null===t?t:"object"==typeof t&&"lat"in t?new o.LatLng(t.lat,"lng"in t?t.lng:t.lon):new o.LatLng(t,e)},o.LatLngBounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.LatLngBounds.prototype={extend:function(t){return t?(t="number"==typeof t[0]||"string"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t),t instanceof o.LatLng?this._southWest||this._northEast?(this._southWest.lat=Math.min(t.lat,this._southWest.lat),this._southWest.lng=Math.min(t.lng,this._southWest.lng),this._northEast.lat=Math.max(t.lat,this._northEast.lat),this._northEast.lng=Math.max(t.lng,this._northEast.lng)):(this._southWest=new o.LatLng(t.lat,t.lng),this._northEast=new o.LatLng(t.lat,t.lng)):t instanceof o.LatLngBounds&&(this.extend(t._southWest),this.extend(t._northEast)),this):this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,s=Math.abs(e.lng-i.lng)*t;return new o.LatLngBounds(new o.LatLng(e.lat-n,e.lng-s),new o.LatLng(i.lat+n,i.lng+s))},getCenter:function(){return new o.LatLng((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new o.LatLng(this.getNorth(),this.getWest())},getSouthEast:function(){return new o.LatLng(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t);var e,i,n=this._southWest,s=this._northEast;return t instanceof o.LatLngBounds?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=s.lat&&e.lng>=n.lng&&i.lng<=s.lng},intersects:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),a=s.lat>=e.lat&&n.lat<=i.lat,r=s.lng>=e.lng&&n.lng<=i.lng;return a&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t){return t?(t=o.latLngBounds(t),this._southWest.equals(t.getSouthWest())&&this._northEast.equals(t.getNorthEast())):!1},isValid:function(){return!(!this._southWest||!this._northEast)}},o.latLngBounds=function(t,e){return!t||t instanceof o.LatLngBounds?t:new o.LatLngBounds(t,e)},o.Projection={},o.Projection.SphericalMercator={MAX_LATITUDE:85.0511287798,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=t.lng*e,a=n*e;return a=Math.log(Math.tan(Math.PI/4+a/2)),new o.Point(s,a)},unproject:function(t){var e=o.LatLng.RAD_TO_DEG,i=t.x*e,n=(2*Math.atan(Math.exp(t.y))-Math.PI/2)*e;return new o.LatLng(n,i)}},o.Projection.LonLat={project:function(t){return new o.Point(t.lng,t.lat)},unproject:function(t){return new o.LatLng(t.y,t.x)}},o.CRS={latLngToPoint:function(t,e){var i=this.projection.project(t),n=this.scale(e);return this.transformation._transform(i,n)},pointToLatLng:function(t,e){var i=this.scale(e),n=this.transformation.untransform(t,i);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},scale:function(t){return 256*Math.pow(2,t)}},o.CRS.Simple=o.extend({},o.CRS,{projection:o.Projection.LonLat,transformation:new o.Transformation(1,0,-1,0),scale:function(t){return Math.pow(2,t)}}),o.CRS.EPSG3857=o.extend({},o.CRS,{code:"EPSG:3857",projection:o.Projection.SphericalMercator,transformation:new o.Transformation(.5/Math.PI,.5,-.5/Math.PI,.5),project:function(t){var e=this.projection.project(t),i=6378137;return e.multiplyBy(i)}}),o.CRS.EPSG900913=o.extend({},o.CRS.EPSG3857,{code:"EPSG:900913"}),o.CRS.EPSG4326=o.extend({},o.CRS,{code:"EPSG:4326",projection:o.Projection.LonLat,transformation:new o.Transformation(1/360,.5,-1/360,.5)}),o.Map=o.Class.extend({includes:o.Mixin.Events,options:{crs:o.CRS.EPSG3857,fadeAnimation:o.DomUtil.TRANSITION&&!o.Browser.android23,trackResize:!0,markerZoomAnimation:o.DomUtil.TRANSITION&&o.Browser.any3d},initialize:function(t,e){e=o.setOptions(this,e),this._initContainer(t),this._initLayout(),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),e.center&&e.zoom!==i&&this.setView(o.latLng(e.center),e.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._tileLayersNum=0,this.callInitHooks(),this._addLayers(e.layers)},setView:function(t,e){return this._resetView(o.latLng(t),this._limitZoom(e)),this},setZoom:function(t,e){return this.setView(this.getCenter(),t,{zoom:e})},zoomIn:function(t,e){return this.setZoom(this._zoom+(t||1),e)},zoomOut:function(t,e){return this.setZoom(this._zoom-(t||1),e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),s=this.getSize().divideBy(2),a=t instanceof o.Point?t:this.latLngToContainerPoint(t),r=a.subtract(s).multiplyBy(1-1/n),h=this.containerPointToLatLng(s.add(r));return this.setView(h,e,{zoom:i})},fitBounds:function(t,e){e=e||{},t=t.getBounds?t.getBounds():o.latLngBounds(t);var i=o.point(e.paddingTopLeft||e.padding||[0,0]),n=o.point(e.paddingBottomRight||e.padding||[0,0]),s=this.getBoundsZoom(t,!1,i.add(n)),a=n.subtract(i).divideBy(2),r=this.project(t.getSouthWest(),s),h=this.project(t.getNorthEast(),s),l=this.unproject(r.add(h).divideBy(2).add(a),s);return this.setView(l,s,e)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t){return this.fire("movestart"),this._rawPanBy(o.point(t)),this.fire("move"),this.fire("moveend")},setMaxBounds:function(t,e){if(t=o.latLngBounds(t),this.options.maxBounds=t,!t)return this._boundsMinZoom=null,this.off("moveend",this._panInsideMaxBounds,this),this;var i=this.getBoundsZoom(t,!0);return this._boundsMinZoom=i,this._loaded&&(this._zoom<i?this.setView(t.getCenter(),i,e):this.panInsideBounds(t)),this.on("moveend",this._panInsideMaxBounds,this),this},panInsideBounds:function(t){t=o.latLngBounds(t);var e=this.getPixelBounds(),i=e.getBottomLeft(),n=e.getTopRight(),s=this.project(t.getSouthWest()),a=this.project(t.getNorthEast()),r=0,h=0;return n.y<a.y&&(h=Math.ceil(a.y-n.y)),n.x>a.x&&(r=Math.floor(a.x-n.x)),i.y>s.y&&(h=Math.floor(s.y-i.y)),i.x<s.x&&(r=Math.ceil(s.x-i.x)),r||h?this.panBy([r,h]):this},addLayer:function(t){var e=o.stamp(t);return this._layers[e]?this:(this._layers[e]=t,!t.options||isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[e]=t,this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum++,this._tileLayersToLoad++,t.on("load",this._onTileLayerLoad,this)),this._loaded&&this._layerAdd(t),this)},removeLayer:function(t){var e=o.stamp(t);if(this._layers[e])return this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&this.fire("layerremove",{layer:t}),this._zoomBoundLayers[e]&&(delete this._zoomBoundLayers[e],this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum--,this._tileLayersToLoad--,t.off("load",this._onTileLayerLoad,this)),this},hasLayer:function(t){return t?o.stamp(t)in this._layers:!1},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},invalidateSize:function(t){t=o.extend({animate:!1,pan:!0},t===!0?{animate:!0}:t);var e=this.getSize();if(this._sizeChanged=!0,this.options.maxBounds&&this.setMaxBounds(this.options.maxBounds),!this._loaded)return this;var i=this.getSize(),n=e.subtract(i).divideBy(2).round();return n.x||n.y?(t.animate&&t.pan?this.panBy(n):(t.pan&&this._rawPanBy(n),this.fire("move"),clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o.bind(this.fire,this,"moveend"),200)),this.fire("resize",{oldSize:e,newSize:i})):this},addHandler:function(t,e){if(e){var i=this[t]=new e(this);return this._handlers.push(i),this.options[t]&&i.enable(),this}},remove:function(){return this._loaded&&this.fire("unload"),this._initEvents("off"),delete this._container._leaflet,this._clearPanes(),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this},getCenter:function(){return this._checkIfLoaded(),this._moved()?this.layerPointToLatLng(this._getCenterLayerPoint()):this._initialCenter},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds(),e=this.unproject(t.getBottomLeft()),i=this.unproject(t.getTopRight());return new o.LatLngBounds(e,i)},getMinZoom:function(){var t=this._layersMinZoom===i?0:this._layersMinZoom,e=this._boundsMinZoom===i?0:this._boundsMinZoom;return this.options.minZoom===i?Math.max(t,e):this.options.minZoom},getMaxZoom:function(){return this.options.maxZoom===i?this._layersMaxZoom===i?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=o.latLngBounds(t);var n,s=this.getMinZoom()-(e?1:0),a=this.getMaxZoom(),r=this.getSize(),h=t.getNorthWest(),l=t.getSouthEast(),u=!0;i=o.point(i||[0,0]);do s++,n=this.project(l,s).subtract(this.project(h,s)).add(i),u=e?n.x<r.x||n.y<r.y:r.contains(n);while(u&&a>=s);return u&&e?null:e?s:s-1},getSize:function(){return(!this._size||this._sizeChanged)&&(this._size=new o.Point(this._container.clientWidth,this._container.clientHeight),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(){var t=this._getTopLeftPoint();return new o.Bounds(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._initialTopLeftPoint},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t){var e=this.options.crs;return e.scale(t)/e.scale(this._zoom)},getScaleZoom:function(t){return this._zoom+Math.log(t)/Math.LN2},project:function(t,e){return e=e===i?this._zoom:e,this.options.crs.latLngToPoint(o.latLng(t),e)},unproject:function(t,e){return e=e===i?this._zoom:e,this.options.crs.pointToLatLng(o.point(t),e)},layerPointToLatLng:function(t){var e=o.point(t).add(this.getPixelOrigin());return this.unproject(e)},latLngToLayerPoint:function(t){var e=this.project(o.latLng(t))._round();return e._subtract(this.getPixelOrigin())},containerPointToLayerPoint:function(t){return o.point(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return o.point(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var e=this.containerPointToLayerPoint(o.point(t));return this.layerPointToLatLng(e)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))},mouseEventToContainerPoint:function(t){return o.DomEvent.getMousePosition(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var e=this._container=o.DomUtil.get(t);if(!e)throw new Error("Map container not found.");if(e._leaflet)throw new Error("Map container is already initialized.");e._leaflet=!0},_initLayout:function(){var t=this._container;o.DomUtil.addClass(t,"leaflet-container"+(o.Browser.touch?" leaflet-touch":"")+(o.Browser.retina?" leaflet-retina":"")+(this.options.fadeAnimation?" leaflet-fade-anim":""));var e=o.DomUtil.getStyle(t,"position");"absolute"!==e&&"relative"!==e&&"fixed"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._mapPane=t.mapPane=this._createPane("leaflet-map-pane",this._container),this._tilePane=t.tilePane=this._createPane("leaflet-tile-pane",this._mapPane),t.objectsPane=this._createPane("leaflet-objects-pane",this._mapPane),t.shadowPane=this._createPane("leaflet-shadow-pane"),t.overlayPane=this._createPane("leaflet-overlay-pane"),t.markerPane=this._createPane("leaflet-marker-pane"),t.popupPane=this._createPane("leaflet-popup-pane");var e=" leaflet-zoom-hide";this.options.markerZoomAnimation||(o.DomUtil.addClass(t.markerPane,e),o.DomUtil.addClass(t.shadowPane,e),o.DomUtil.addClass(t.popupPane,e))},_createPane:function(t,e){return o.DomUtil.create("div",t,e||this._panes.objectsPane)},_clearPanes:function(){this._container.removeChild(this._mapPane)},_addLayers:function(t){t=t?o.Util.isArray(t)?t:[t]:[];for(var e=0,i=t.length;i>e;e++)this.addLayer(t[e])},_resetView:function(t,e,i,n){var s=this._zoom!==e;n||(this.fire("movestart"),s&&this.fire("zoomstart")),this._zoom=e,this._initialCenter=t,this._initialTopLeftPoint=this._getNewTopLeftPoint(t),i?this._initialTopLeftPoint._add(this._getMapPanePos()):o.DomUtil.setPosition(this._mapPane,new o.Point(0,0)),this._tileLayersToLoad=this._tileLayersNum;var a=!this._loaded;this._loaded=!0,a&&(this.fire("load"),this.eachLayer(this._layerAdd,this)),this.fire("viewreset",{hard:!i}),this.fire("move"),(s||n)&&this.fire("zoomend"),this.fire("moveend",{hard:!i})},_rawPanBy:function(t){o.DomUtil.setPosition(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_updateZoomLevels:function(){var t,e=1/0,n=-1/0,o=this._getZoomSpan();for(t in this._zoomBoundLayers){var s=this._zoomBoundLayers[t];isNaN(s.options.minZoom)||(e=Math.min(e,s.options.minZoom)),isNaN(s.options.maxZoom)||(n=Math.max(n,s.options.maxZoom))}t===i?this._layersMaxZoom=this._layersMinZoom=i:(this._layersMaxZoom=n,this._layersMinZoom=e),o!==this._getZoomSpan()&&this.fire("zoomlevelschange")},_panInsideMaxBounds:function(){this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(e){if(o.DomEvent){e=e||"on",o.DomEvent[e](this._container,"click",this._onMouseClick,this);var i,n,s=["dblclick","mousedown","mouseup","mouseenter","mouseleave","mousemove","contextmenu"];for(i=0,n=s.length;n>i;i++)o.DomEvent[e](this._container,s[i],this._fireMouseEvent,this);this.options.trackResize&&o.DomEvent[e](t,"resize",this._onResize,this)}},_onResize:function(){o.Util.cancelAnimFrame(this._resizeRequest),this._resizeRequest=o.Util.requestAnimFrame(this.invalidateSize,this,!1,this._container)},_onMouseClick:function(t){!this._loaded||!t._simulated&&this.dragging&&this.dragging.moved()||o.DomEvent._skipped(t)||(this.fire("preclick"),this._fireMouseEvent(t))},_fireMouseEvent:function(t){if(this._loaded&&!o.DomEvent._skipped(t)){var e=t.type;if(e="mouseenter"===e?"mouseover":"mouseleave"===e?"mouseout":e,this.hasEventListeners(e)){"contextmenu"===e&&o.DomEvent.preventDefault(t);var i=this.mouseEventToContainerPoint(t),n=this.containerPointToLayerPoint(i),s=this.layerPointToLatLng(n);this.fire(e,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t})}}},_onTileLayerLoad:function(){this._tileLayersToLoad--,this._tileLayersNum&&!this._tileLayersToLoad&&this.fire("tilelayersload")},_clearHandlers:function(){for(var t=0,e=this._handlers.length;e>t;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,this):this.on("load",t,e),this},_layerAdd:function(t){t.onAdd(this),this.fire("layeradd",{layer:t})},_getMapPanePos:function(){return o.DomUtil.getPosition(this._mapPane)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(){return this.getPixelOrigin().subtract(this._getMapPanePos())},_getNewTopLeftPoint:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._round()},_latLngToNewLayerPoint:function(t,e,i){var n=this._getNewTopLeftPoint(i,e).add(this._getMapPanePos());return this.project(t,e)._subtract(n)},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom();return Math.max(e,Math.min(i,t))}}),o.map=function(t,e){return new o.Map(t,e)},o.Projection.Mercator={MAX_LATITUDE:85.0840591556,R_MINOR:6356752.314245179,R_MAJOR:6378137,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=this.R_MAJOR,a=this.R_MINOR,r=t.lng*e*s,h=n*e,l=a/s,u=Math.sqrt(1-l*l),c=u*Math.sin(h);c=Math.pow((1-c)/(1+c),.5*u);var d=Math.tan(.5*(.5*Math.PI-h))/c;return h=-s*Math.log(d),new o.Point(r,h)},unproject:function(t){for(var e,i=o.LatLng.RAD_TO_DEG,n=this.R_MAJOR,s=this.R_MINOR,a=t.x*i/n,r=s/n,h=Math.sqrt(1-r*r),l=Math.exp(-t.y/n),u=Math.PI/2-2*Math.atan(l),c=15,d=1e-7,p=c,_=.1;Math.abs(_)>d&&--p>0;)e=h*Math.sin(u),_=Math.PI/2-2*Math.atan(l*Math.pow((1-e)/(1+e),.5*h))-u,u+=_;return new o.LatLng(u*i,a)}},o.CRS.EPSG3395=o.extend({},o.CRS,{code:"EPSG:3395",projection:o.Projection.Mercator,transformation:function(){var t=o.Projection.Mercator,e=t.R_MAJOR,i=t.R_MINOR;return new o.Transformation(.5/(Math.PI*e),.5,-.5/(Math.PI*i),.5)}()}),o.TileLayer=o.Class.extend({includes:o.Mixin.Events,options:{minZoom:0,maxZoom:18,tileSize:256,subdomains:"abc",errorTileUrl:"",attribution:"",zoomOffset:0,opacity:1,unloadInvisibleTiles:o.Browser.mobile,updateWhenIdle:o.Browser.mobile},initialize:function(t,e){e=o.setOptions(this,e),e.detectRetina&&o.Browser.retina&&e.maxZoom>0&&(e.tileSize=Math.floor(e.tileSize/2),e.zoomOffset++,e.minZoom>0&&e.minZoom--,this.options.maxZoom--),e.bounds&&(e.bounds=o.latLngBounds(e.bounds)),this._url=t;var i=this.options.subdomains;"string"==typeof i&&(this.options.subdomains=i.split(""))},onAdd:function(t){this._map=t,this._animated=t._zoomAnimated,this._initContainer(),this._createTileProto(),t.on({viewreset:this._reset,moveend:this._update},this),this._animated&&t.on({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||(this._limitedUpdate=o.Util.limitExecByInterval(this._update,150,this),t.on("move",this._limitedUpdate,this)),this._reset(),this._update()
-},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this._container.parentNode.removeChild(this._container),t.off({viewreset:this._reset,moveend:this._update},this),this._animated&&t.off({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||t.off("move",this._limitedUpdate,this),this._container=null,this._map=null},bringToFront:function(){var t=this._map._panes.tilePane;return this._container&&(t.appendChild(this._container),this._setAutoZIndex(t,Math.max)),this},bringToBack:function(){var t=this._map._panes.tilePane;return this._container&&(t.insertBefore(this._container,t.firstChild),this._setAutoZIndex(t,Math.min)),this},getAttribution:function(){return this.options.attribution},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},setUrl:function(t,e){return this._url=t,e||this.redraw(),this},redraw:function(){return this._map&&(this._reset({hard:!0}),this._update()),this},_updateZIndex:function(){this._container&&this.options.zIndex!==i&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t,e){var i,n,o,s=t.children,a=-e(1/0,-1/0);for(n=0,o=s.length;o>n;n++)s[n]!==this._container&&(i=parseInt(s[n].style.zIndex,10),isNaN(i)||(a=e(a,i)));this.options.zIndex=this._container.style.zIndex=(isFinite(a)?a:0)+e(1,-1)},_updateOpacity:function(){var t,e=this._tiles;if(o.Browser.ielt9)for(t in e)o.DomUtil.setOpacity(e[t],this.options.opacity);else o.DomUtil.setOpacity(this._container,this.options.opacity)},_initContainer:function(){var t=this._map._panes.tilePane;if(!this._container){if(this._container=o.DomUtil.create("div","leaflet-layer"),this._updateZIndex(),this._animated){var e="leaflet-tile-container leaflet-zoom-animated";this._bgBuffer=o.DomUtil.create("div",e,this._container),this._tileContainer=o.DomUtil.create("div",e,this._container)}else this._tileContainer=this._container;t.appendChild(this._container),this.options.opacity<1&&this._updateOpacity()}},_reset:function(t){for(var e in this._tiles)this.fire("tileunload",{tile:this._tiles[e]});this._tiles={},this._tilesToLoad=0,this.options.reuseTiles&&(this._unusedTiles=[]),this._tileContainer.innerHTML="",this._animated&&t&&t.hard&&this._clearBgBuffer(),this._initContainer()},_update:function(){if(this._map){var t=this._map.getPixelBounds(),e=this._map.getZoom(),i=this.options.tileSize;if(!(e>this.options.maxZoom||e<this.options.minZoom)){var n=o.bounds(t.min.divideBy(i)._floor(),t.max.divideBy(i)._floor());this._addTilesFromCenterOut(n),(this.options.unloadInvisibleTiles||this.options.reuseTiles)&&this._removeOtherTiles(n)}}},_addTilesFromCenterOut:function(t){var i,n,s,a=[],r=t.getCenter();for(i=t.min.y;i<=t.max.y;i++)for(n=t.min.x;n<=t.max.x;n++)s=new o.Point(n,i),this._tileShouldBeLoaded(s)&&a.push(s);var h=a.length;if(0!==h){a.sort(function(t,e){return t.distanceTo(r)-e.distanceTo(r)});var l=e.createDocumentFragment();for(this._tilesToLoad||this.fire("loading"),this._tilesToLoad+=h,n=0;h>n;n++)this._addTile(a[n],l);this._tileContainer.appendChild(l)}},_tileShouldBeLoaded:function(t){if(t.x+":"+t.y in this._tiles)return!1;var e=this.options;if(!e.continuousWorld){var i=this._getWrapTileNum();if(e.noWrap&&(t.x<0||t.x>=i)||t.y<0||t.y>=i)return!1}if(e.bounds){var n=e.tileSize,o=t.multiplyBy(n),s=o.add([n,n]),a=this._map.unproject(o),r=this._map.unproject(s);if(e.continuousWorld||e.noWrap||(a=a.wrap(),r=r.wrap()),!e.bounds.intersects([a,r]))return!1}return!0},_removeOtherTiles:function(t){var e,i,n,o;for(o in this._tiles)e=o.split(":"),i=parseInt(e[0],10),n=parseInt(e[1],10),(i<t.min.x||i>t.max.x||n<t.min.y||n>t.max.y)&&this._removeTile(o)},_removeTile:function(t){var e=this._tiles[t];this.fire("tileunload",{tile:e,url:e.src}),this.options.reuseTiles?(o.DomUtil.removeClass(e,"leaflet-tile-loaded"),this._unusedTiles.push(e)):e.parentNode===this._tileContainer&&this._tileContainer.removeChild(e),o.Browser.android||(e.onload=null,e.src=o.Util.emptyImageUrl),delete this._tiles[t]},_addTile:function(t,e){var i=this._getTilePos(t),n=this._getTile();o.DomUtil.setPosition(n,i,o.Browser.chrome||o.Browser.android23),this._tiles[t.x+":"+t.y]=n,this._loadTile(n,t),n.parentNode!==this._tileContainer&&e.appendChild(n)},_getZoomForUrl:function(){var t=this.options,e=this._map.getZoom();return t.zoomReverse&&(e=t.maxZoom-e),e+t.zoomOffset},_getTilePos:function(t){var e=this._map.getPixelOrigin(),i=this.options.tileSize;return t.multiplyBy(i).subtract(e)},getTileUrl:function(t){return o.Util.template(this._url,o.extend({s:this._getSubdomain(t),z:t.z,x:t.x,y:t.y},this.options))},_getWrapTileNum:function(){return Math.pow(2,this._getZoomForUrl())},_adjustTilePoint:function(t){var e=this._getWrapTileNum();this.options.continuousWorld||this.options.noWrap||(t.x=(t.x%e+e)%e),this.options.tms&&(t.y=e-t.y-1),t.z=this._getZoomForUrl()},_getSubdomain:function(t){var e=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[e]},_createTileProto:function(){var t=this._tileImg=o.DomUtil.create("img","leaflet-tile");t.style.width=t.style.height=this.options.tileSize+"px",t.galleryimg="no"},_getTile:function(){if(this.options.reuseTiles&&this._unusedTiles.length>0){var t=this._unusedTiles.pop();return this._resetTile(t),t}return this._createTile()},_resetTile:function(){},_createTile:function(){var t=this._tileImg.cloneNode(!1);return t.onselectstart=t.onmousemove=o.Util.falseFn,o.Browser.ielt9&&this.options.opacity!==i&&o.DomUtil.setOpacity(t,this.options.opacity),t},_loadTile:function(t,e){t._layer=this,t.onload=this._tileOnLoad,t.onerror=this._tileOnError,this._adjustTilePoint(e),t.src=this.getTileUrl(e)},_tileLoaded:function(){this._tilesToLoad--,this._tilesToLoad||(this.fire("load"),this._animated&&(clearTimeout(this._clearBgBufferTimer),this._clearBgBufferTimer=setTimeout(o.bind(this._clearBgBuffer,this),500)))},_tileOnLoad:function(){var t=this._layer;this.src!==o.Util.emptyImageUrl&&(o.DomUtil.addClass(this,"leaflet-tile-loaded"),t.fire("tileload",{tile:this,url:this.src})),t._tileLoaded()},_tileOnError:function(){var t=this._layer;t.fire("tileerror",{tile:this,url:this.src});var e=t.options.errorTileUrl;e&&(this.src=e),t._tileLoaded()}}),o.tileLayer=function(t,e){return new o.TileLayer(t,e)},o.TileLayer.WMS=o.TileLayer.extend({defaultWmsParams:{service:"WMS",request:"GetMap",version:"1.1.1",layers:"",styles:"",format:"image/jpeg",transparent:!1},initialize:function(t,e){this._url=t;var i=o.extend({},this.defaultWmsParams),n=e.tileSize||this.options.tileSize;i.width=i.height=e.detectRetina&&o.Browser.retina?2*n:n;for(var s in e)this.options.hasOwnProperty(s)||"crs"===s||(i[s]=e[s]);this.wmsParams=i,o.setOptions(this,e)},onAdd:function(t){this._crs=this.options.crs||t.options.crs;var e=parseFloat(this.wmsParams.version)>=1.3?"crs":"srs";this.wmsParams[e]=this._crs.code,o.TileLayer.prototype.onAdd.call(this,t)},getTileUrl:function(t,e){var i=this._map,n=this.options.tileSize,s=t.multiplyBy(n),a=s.add([n,n]),r=this._crs.project(i.unproject(s,e)),h=this._crs.project(i.unproject(a,e)),l=[r.x,h.y,h.x,r.y].join(","),u=o.Util.template(this._url,{s:this._getSubdomain(t)});return u+o.Util.getParamString(this.wmsParams,u,!0)+"&BBOX="+l},setParams:function(t,e){return o.extend(this.wmsParams,t),e||this.redraw(),this}}),o.tileLayer.wms=function(t,e){return new o.TileLayer.WMS(t,e)},o.TileLayer.Canvas=o.TileLayer.extend({options:{async:!1},initialize:function(t){o.setOptions(this,t)},redraw:function(){this._map&&(this._reset({hard:!0}),this._update());for(var t in this._tiles)this._redrawTile(this._tiles[t]);return this},_redrawTile:function(t){this.drawTile(t,t._tilePoint,this._map._zoom)},_createTileProto:function(){var t=this._canvasProto=o.DomUtil.create("canvas","leaflet-tile");t.width=t.height=this.options.tileSize},_createTile:function(){var t=this._canvasProto.cloneNode(!1);return t.onselectstart=t.onmousemove=o.Util.falseFn,t},_loadTile:function(t,e){t._layer=this,t._tilePoint=e,this._redrawTile(t),this.options.async||this.tileDrawn(t)},drawTile:function(){},tileDrawn:function(t){this._tileOnLoad.call(t)}}),o.tileLayer.canvas=function(t){return new o.TileLayer.Canvas(t)},o.ImageOverlay=o.Class.extend({includes:o.Mixin.Events,options:{opacity:1},initialize:function(t,e,i){this._url=t,this._bounds=o.latLngBounds(e),o.setOptions(this,i)},onAdd:function(t){this._map=t,this._image||this._initImage(),t._panes.overlayPane.appendChild(this._image),t.on("viewreset",this._reset,this),t.options.zoomAnimation&&o.Browser.any3d&&t.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(t){t.getPanes().overlayPane.removeChild(this._image),t.off("viewreset",this._reset,this),t.options.zoomAnimation&&t.off("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},bringToFront:function(){return this._image&&this._map._panes.overlayPane.appendChild(this._image),this},bringToBack:function(){var t=this._map._panes.overlayPane;return this._image&&t.insertBefore(this._image,t.firstChild),this},_initImage:function(){this._image=o.DomUtil.create("img","leaflet-image-layer"),this._map.options.zoomAnimation&&o.Browser.any3d?o.DomUtil.addClass(this._image,"leaflet-zoom-animated"):o.DomUtil.addClass(this._image,"leaflet-zoom-hide"),this._updateOpacity(),o.extend(this._image,{galleryimg:"no",onselectstart:o.Util.falseFn,onmousemove:o.Util.falseFn,onload:o.bind(this._onImageLoad,this),src:this._url})},_animateZoom:function(t){var e=this._map,i=this._image,n=e.getZoomScale(t.zoom),s=this._bounds.getNorthWest(),a=this._bounds.getSouthEast(),r=e._latLngToNewLayerPoint(s,t.zoom,t.center),h=e._latLngToNewLayerPoint(a,t.zoom,t.center)._subtract(r),l=r._add(h._multiplyBy(.5*(1-1/n)));i.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(l)+" scale("+n+") "},_reset:function(){var t=this._image,e=this._map.latLngToLayerPoint(this._bounds.getNorthWest()),i=this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);o.DomUtil.setPosition(t,e),t.style.width=i.x+"px",t.style.height=i.y+"px"},_onImageLoad:function(){this.fire("load")},_updateOpacity:function(){o.DomUtil.setOpacity(this._image,this.options.opacity)}}),o.imageOverlay=function(t,e,i){return new o.ImageOverlay(t,e,i)},o.Icon=o.Class.extend({options:{className:""},initialize:function(t){o.setOptions(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(!i){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n;return n=e&&"IMG"===e.tagName?this._createImg(i,e):this._createImg(i),this._setIconStyles(n,t),n},_setIconStyles:function(t,e){var i,n=this.options,s=o.point(n[e+"Size"]);i="shadow"===e?o.point(n.shadowAnchor||n.iconAnchor):o.point(n.iconAnchor),!i&&s&&(i=s.divideBy(2,!0)),t.className="leaflet-marker-"+e+" "+n.className,i&&(t.style.marginLeft=-i.x+"px",t.style.marginTop=-i.y+"px"),s&&(t.style.width=s.x+"px",t.style.height=s.y+"px")},_createImg:function(t,i){return o.Browser.ie6?(i||(i=e.createElement("div")),i.style.filter='progid:DXImageTransform.Microsoft.AlphaImageLoader(src="'+t+'")'):(i||(i=e.createElement("img")),i.src=t),i},_getIconUrl:function(t){return o.Browser.retina&&this.options[t+"RetinaUrl"]?this.options[t+"RetinaUrl"]:this.options[t+"Url"]}}),o.icon=function(t){return new o.Icon(t)},o.Icon.Default=o.Icon.extend({options:{iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]},_getIconUrl:function(t){var e=t+"Url";if(this.options[e])return this.options[e];o.Browser.retina&&"icon"===t&&(t+="-2x");var i=o.Icon.Default.imagePath;if(!i)throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");return i+"/marker-"+t+".png"}}),o.Icon.Default.imagePath=function(){var t,i,n,o,s,a=e.getElementsByTagName("script"),r=/[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;for(t=0,i=a.length;i>t;t++)if(n=a[t].src,o=n.match(r))return s=n.split(r)[0],(s?s+"/":"")+"images"}(),o.Marker=o.Class.extend({includes:o.Mixin.Events,options:{icon:new o.Icon.Default,title:"",clickable:!0,draggable:!1,keyboard:!0,zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250},initialize:function(t,e){o.setOptions(this,e),this._latlng=o.latLng(t)},onAdd:function(t){this._map=t,t.on("viewreset",this.update,this),this._initIcon(),this.update(),t.options.zoomAnimation&&t.options.markerZoomAnimation&&t.on("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this.dragging&&this.dragging.disable(),this._removeIcon(),this._removeShadow(),this.fire("remove"),t.off({viewreset:this.update,zoomanim:this._animateZoom},this),this._map=null},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this.update(),this.fire("move",{latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update(),this},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this},update:function(){if(this._icon){var t=this._map.latLngToLayerPoint(this._latlng).round();this._setPos(t)}return this},_initIcon:function(){var t=this.options,e=this._map,i=e.options.zoomAnimation&&e.options.markerZoomAnimation,n=i?"leaflet-zoom-animated":"leaflet-zoom-hide",s=t.icon.createIcon(this._icon),a=!1;s!==this._icon&&(this._icon&&this._removeIcon(),a=!0,t.title&&(s.title=t.title)),o.DomUtil.addClass(s,n),t.keyboard&&(s.tabIndex="0"),this._icon=s,this._initInteraction(),t.riseOnHover&&o.DomEvent.on(s,"mouseover",this._bringToFront,this).on(s,"mouseout",this._resetZIndex,this);var r=t.icon.createShadow(this._shadow),h=!1;r!==this._shadow&&(this._removeShadow(),h=!0),r&&o.DomUtil.addClass(r,n),this._shadow=r,t.opacity<1&&this._updateOpacity();var l=this._map._panes;a&&l.markerPane.appendChild(this._icon),r&&h&&l.shadowPane.appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&o.DomEvent.off(this._icon,"mouseover",this._bringToFront).off(this._icon,"mouseout",this._resetZIndex),this._map._panes.markerPane.removeChild(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&this._map._panes.shadowPane.removeChild(this._shadow),this._shadow=null},_setPos:function(t){o.DomUtil.setPosition(this._icon,t),this._shadow&&o.DomUtil.setPosition(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);this._setPos(e)},_initInteraction:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu"];o.DomUtil.addClass(t,"leaflet-clickable"),o.DomEvent.on(t,"click",this._onMouseClick,this),o.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++)o.DomEvent.on(t,e[i],this._fireMouseEvent,this);o.Handler.MarkerDrag&&(this.dragging=new o.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable())}},_onMouseClick:function(t){var e=this.dragging&&this.dragging.moved();(this.hasEventListeners(t.type)||e)&&o.DomEvent.stopPropagation(t),e||(this.dragging&&this.dragging._enabled||!this._map.dragging||!this._map.dragging.moved())&&this.fire(t.type,{originalEvent:t,latlng:this._latlng})},_onKeyPress:function(t){13===t.keyCode&&this.fire("click",{originalEvent:t,latlng:this._latlng})},_fireMouseEvent:function(t){this.fire(t.type,{originalEvent:t,latlng:this._latlng}),"contextmenu"===t.type&&this.hasEventListeners(t.type)&&o.DomEvent.preventDefault(t),"mousedown"!==t.type?o.DomEvent.stopPropagation(t):o.DomEvent.preventDefault(t)},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){o.DomUtil.setOpacity(this._icon,this.options.opacity),this._shadow&&o.DomUtil.setOpacity(this._shadow,this.options.opacity)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)}}),o.marker=function(t,e){return new o.Marker(t,e)},o.DivIcon=o.Icon.extend({options:{iconSize:[12,12],className:"leaflet-div-icon",html:!1},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:e.createElement("div"),n=this.options;return i.innerHTML=n.html!==!1?n.html:"",n.bgPos&&(i.style.backgroundPosition=-n.bgPos.x+"px "+-n.bgPos.y+"px"),this._setIconStyles(i,"icon"),i},createShadow:function(){return null}}),o.divIcon=function(t){return new o.DivIcon(t)},o.Map.mergeOptions({closePopupOnClick:!0}),o.Popup=o.Class.extend({includes:o.Mixin.Events,options:{minWidth:50,maxWidth:300,maxHeight:null,autoPan:!0,closeButton:!0,offset:[0,7],autoPanPadding:[5,5],keepInView:!1,className:"",zoomAnimation:!0},initialize:function(t,e){o.setOptions(this,t),this._source=e,this._animated=o.Browser.any3d&&this.options.zoomAnimation,this._isOpen=!1},onAdd:function(t){this._map=t,this._container||this._initLayout(),this._updateContent();var e=t.options.fadeAnimation;e&&o.DomUtil.setOpacity(this._container,0),t._panes.popupPane.appendChild(this._container),t.on(this._getEvents(),this),this._update(),e&&o.DomUtil.setOpacity(this._container,1),this.fire("open"),t.fire("popupopen",{popup:this}),this._source&&this._source.fire("popupopen",{popup:this})},addTo:function(t){return t.addLayer(this),this},openOn:function(t){return t.openPopup(this),this},onRemove:function(t){t._panes.popupPane.removeChild(this._container),o.Util.falseFn(this._container.offsetWidth),t.off(this._getEvents(),this),t.options.fadeAnimation&&o.DomUtil.setOpacity(this._container,0),this._map=null,this.fire("close"),t.fire("popupclose",{popup:this}),this._source&&this._source.fire("popupclose",{popup:this})},setLatLng:function(t){return this._latlng=o.latLng(t),this._update(),this},setContent:function(t){return this._content=t,this._update(),this},_getEvents:function(){var t={viewreset:this._updatePosition};return this._animated&&(t.zoomanim=this._zoomAnimation),("closeOnClick"in this.options?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t,e="leaflet-popup",i=e+" "+this.options.className+" leaflet-zoom-"+(this._animated?"animated":"hide"),n=this._container=o.DomUtil.create("div",i);this.options.closeButton&&(t=this._closeButton=o.DomUtil.create("a",e+"-close-button",n),t.href="#close",t.innerHTML="&#215;",o.DomEvent.disableClickPropagation(t),o.DomEvent.on(t,"click",this._onCloseButtonClick,this));var s=this._wrapper=o.DomUtil.create("div",e+"-content-wrapper",n);o.DomEvent.disableClickPropagation(s),this._contentNode=o.DomUtil.create("div",e+"-content",s),o.DomEvent.on(this._contentNode,"mousewheel",o.DomEvent.stopPropagation),o.DomEvent.on(this._contentNode,"MozMousePixelScroll",o.DomEvent.stopPropagation),o.DomEvent.on(s,"contextmenu",o.DomEvent.stopPropagation),this._tipContainer=o.DomUtil.create("div",e+"-tip-container",n),this._tip=o.DomUtil.create("div",e+"-tip",this._tipContainer)},_update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},_updateContent:function(){if(this._content){if("string"==typeof this._content)this._contentNode.innerHTML=this._content;else{for(;this._contentNode.hasChildNodes();)this._contentNode.removeChild(this._contentNode.firstChild);this._contentNode.appendChild(this._content)}this.fire("contentupdate")}},_updateLayout:function(){var t=this._contentNode,e=t.style;e.width="",e.whiteSpace="nowrap";var i=t.offsetWidth;i=Math.min(i,this.options.maxWidth),i=Math.max(i,this.options.minWidth),e.width=i+1+"px",e.whiteSpace="",e.height="";var n=t.offsetHeight,s=this.options.maxHeight,a="leaflet-popup-scrolled";s&&n>s?(e.height=s+"px",o.DomUtil.addClass(t,a)):o.DomUtil.removeClass(t,a),this._containerWidth=this._container.offsetWidth},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),e=this._animated,i=o.point(this.options.offset);e&&o.DomUtil.setPosition(this._container,t),this._containerBottom=-i.y-(e?0:t.y),this._containerLeft=-Math.round(this._containerWidth/2)+i.x+(e?0:t.x),this._container.style.bottom=this._containerBottom+"px",this._container.style.left=this._containerLeft+"px"}},_zoomAnimation:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);o.DomUtil.setPosition(this._container,e)},_adjustPan:function(){if(this.options.autoPan){var t=this._map,e=this._container.offsetHeight,i=this._containerWidth,n=new o.Point(this._containerLeft,-e-this._containerBottom);this._animated&&n._add(o.DomUtil.getPosition(this._container));var s=t.layerPointToContainerPoint(n),a=o.point(this.options.autoPanPadding),r=t.getSize(),h=0,l=0;s.x+i>r.x&&(h=s.x+i-r.x+a.x),s.x-h<0&&(h=s.x-a.x),s.y+e>r.y&&(l=s.y+e-r.y+a.y),s.y-l<0&&(l=s.y-a.y),(h||l)&&t.fire("autopanstart").panBy([h,l])}},_onCloseButtonClick:function(t){this._close(),o.DomEvent.stop(t)}}),o.popup=function(t,e){return new o.Popup(t,e)},o.Map.include({openPopup:function(t,e,i){if(this.closePopup(),!(t instanceof o.Popup)){var n=t;t=new o.Popup(i).setLatLng(e).setContent(n)}return t._isOpen=!0,this._popup=t,this.addLayer(t)},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&(this.removeLayer(t),t._isOpen=!1),this}}),o.Marker.include({openPopup:function(){return this._popup&&this._map&&!this._map.hasLayer(this._popup)&&(this._popup.setLatLng(this._latlng),this._map.openPopup(this._popup)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(){return this._popup&&(this._popup._isOpen?this.closePopup():this.openPopup()),this},bindPopup:function(t,e){var i=o.point(this.options.icon.options.popupAnchor||[0,0]);return i=i.add(o.Popup.prototype.options.offset),e&&e.offset&&(i=i.add(e.offset)),e=o.extend({offset:i},e),this._popup||this.on("click",this.togglePopup,this).on("remove",this.closePopup,this).on("move",this._movePopup,this),t instanceof o.Popup?(o.setOptions(t,e),this._popup=t):this._popup=new o.Popup(e,this).setContent(t),this},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this.togglePopup).off("remove",this.closePopup).off("move",this._movePopup)),this},_movePopup:function(t){this._popup.setLatLng(t.latlng)}}),o.LayerGroup=o.Class.extend({initialize:function(t){this._layers={};var e,i;if(t)for(e=0,i=t.length;i>e;e++)this.addLayer(t[e])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var e=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[e]&&this._map.removeLayer(this._layers[e]),delete this._layers[e],this},hasLayer:function(t){return t?t in this._layers||this.getLayerId(t)in this._layers:!1},clearLayers:function(){return this.eachLayer(this.removeLayer,this),this},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)i=this._layers[e],i[t]&&i[t].apply(i,n);return this},onAdd:function(t){this._map=t,this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t),this._map=null},addTo:function(t){return t.addLayer(this),this},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];for(var e in this._layers)t.push(this._layers[e]);return t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return o.stamp(t)}}),o.layerGroup=function(t){return new o.LayerGroup(t)},o.FeatureGroup=o.LayerGroup.extend({includes:o.Mixin.Events,statics:{EVENTS:"click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"},addLayer:function(t){return this.hasLayer(t)?this:(t.on(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.addLayer.call(this,t),this._popupContent&&t.bindPopup&&t.bindPopup(this._popupContent,this._popupOptions),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),t.off(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.removeLayer.call(this,t),this._popupContent&&this.invoke("unbindPopup"),this.fire("layerremove",{layer:t})):this},bindPopup:function(t,e){return this._popupContent=t,this._popupOptions=e,this.invoke("bindPopup",t,e)},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new o.LatLngBounds;return this.eachLayer(function(e){t.extend(e instanceof o.Marker?e.getLatLng():e.getBounds())}),t},_propagateEvent:function(t){t.layer||(t.layer=t.target),t.target=this,this.fire(t.type,t)}}),o.featureGroup=function(t){return new o.FeatureGroup(t)},o.Path=o.Class.extend({includes:[o.Mixin.Events],statics:{CLIP_PADDING:function(){var e=o.Browser.mobile?1280:2e3,i=(e/Math.max(t.outerWidth,t.outerHeight)-1)/2;return Math.max(0,Math.min(.5,i))}()},options:{stroke:!0,color:"#0033ff",dashArray:null,weight:5,opacity:.5,fill:!1,fillColor:null,fillOpacity:.2,clickable:!0},initialize:function(t){o.setOptions(this,t)},onAdd:function(t){this._map=t,this._container||(this._initElements(),this._initEvents()),this.projectLatlngs(),this._updatePath(),this._container&&this._map._pathRoot.appendChild(this._container),this.fire("add"),t.on({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){t._pathRoot.removeChild(this._container),this.fire("remove"),this._map=null,o.Browser.vml&&(this._container=null,this._stroke=null,this._fill=null),t.off({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},projectLatlngs:function(){},setStyle:function(t){return o.setOptions(this,t),this._container&&this._updateStyle(),this},redraw:function(){return this._map&&(this.projectLatlngs(),this._updatePath()),this}}),o.Map.include({_updatePathViewport:function(){var t=o.Path.CLIP_PADDING,e=this.getSize(),i=o.DomUtil.getPosition(this._mapPane),n=i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),s=n.add(e.multiplyBy(1+2*t)._round());this._pathViewport=new o.Bounds(n,s)}}),o.Path.SVG_NS="http://www.w3.org/2000/svg",o.Browser.svg=!(!e.createElementNS||!e.createElementNS(o.Path.SVG_NS,"svg").createSVGRect),o.Path=o.Path.extend({statics:{SVG:o.Browser.svg},bringToFront:function(){var t=this._map._pathRoot,e=this._container;return e&&t.lastChild!==e&&t.appendChild(e),this},bringToBack:function(){var t=this._map._pathRoot,e=this._container,i=t.firstChild;return e&&i!==e&&t.insertBefore(e,i),this},getPathString:function(){},_createElement:function(t){return e.createElementNS(o.Path.SVG_NS,t)},_initElements:function(){this._map._initPathRoot(),this._initPath(),this._initStyle()},_initPath:function(){this._container=this._createElement("g"),this._path=this._createElement("path"),this._container.appendChild(this._path)},_initStyle:function(){this.options.stroke&&(this._path.setAttribute("stroke-linejoin","round"),this._path.setAttribute("stroke-linecap","round")),this.options.fill&&this._path.setAttribute("fill-rule","evenodd"),this.options.pointerEvents&&this._path.setAttribute("pointer-events",this.options.pointerEvents),this.options.clickable||this.options.pointerEvents||this._path.setAttribute("pointer-events","none"),this._updateStyle()},_updateStyle:function(){this.options.stroke?(this._path.setAttribute("stroke",this.options.color),this._path.setAttribute("stroke-opacity",this.options.opacity),this._path.setAttribute("stroke-width",this.options.weight),this.options.dashArray?this._path.setAttribute("stroke-dasharray",this.options.dashArray):this._path.removeAttribute("stroke-dasharray")):this._path.setAttribute("stroke","none"),this.options.fill?(this._path.setAttribute("fill",this.options.fillColor||this.options.color),this._path.setAttribute("fill-opacity",this.options.fillOpacity)):this._path.setAttribute("fill","none")},_updatePath:function(){var t=this.getPathString();t||(t="M0 0"),this._path.setAttribute("d",t)},_initEvents:function(){if(this.options.clickable){(o.Browser.svg||!o.Browser.vml)&&this._path.setAttribute("class","leaflet-clickable"),o.DomEvent.on(this._container,"click",this._onMouseClick,this);for(var t=["dblclick","mousedown","mouseover","mouseout","mousemove","contextmenu"],e=0;e<t.length;e++)o.DomEvent.on(this._container,t[e],this._fireMouseEvent,this)}},_onMouseClick:function(t){this._map.dragging&&this._map.dragging.moved()||this._fireMouseEvent(t)},_fireMouseEvent:function(t){if(this.hasEventListeners(t.type)){var e=this._map,i=e.mouseEventToContainerPoint(t),n=e.containerPointToLayerPoint(i),s=e.layerPointToLatLng(n);this.fire(t.type,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t}),"contextmenu"===t.type&&o.DomEvent.preventDefault(t),"mousemove"!==t.type&&o.DomEvent.stopPropagation(t)}}}),o.Map.include({_initPathRoot:function(){this._pathRoot||(this._pathRoot=o.Path.prototype._createElement("svg"),this._panes.overlayPane.appendChild(this._pathRoot),this.options.zoomAnimation&&o.Browser.any3d?(this._pathRoot.setAttribute("class"," leaflet-zoom-animated"),this.on({zoomanim:this._animatePathZoom,zoomend:this._endPathZoom})):this._pathRoot.setAttribute("class"," leaflet-zoom-hide"),this.on("moveend",this._updateSvgViewport),this._updateSvgViewport())},_animatePathZoom:function(t){var e=this.getZoomScale(t.zoom),i=this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);this._pathRoot.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(i)+" scale("+e+") ",this._pathZooming=!0},_endPathZoom:function(){this._pathZooming=!1},_updateSvgViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max,n=i.x-e.x,s=i.y-e.y,a=this._pathRoot,r=this._panes.overlayPane;o.Browser.mobileWebkit&&r.removeChild(a),o.DomUtil.setPosition(a,e),a.setAttribute("width",n),a.setAttribute("height",s),a.setAttribute("viewBox",[e.x,e.y,n,s].join(" ")),o.Browser.mobileWebkit&&r.appendChild(a)}}}),o.Path.include({bindPopup:function(t,e){return t instanceof o.Popup?this._popup=t:((!this._popup||e)&&(this._popup=new o.Popup(e,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on("click",this._openPopup,this).on("remove",this.closePopup,this),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this._openPopup).off("remove",this.closePopup),this._popupHandlersAdded=!1),this},openPopup:function(t){return this._popup&&(t=t||this._latlng||this._latlngs[Math.floor(this._latlngs.length/2)],this._openPopup({latlng:t})),this},closePopup:function(){return this._popup&&this._popup._close(),this},_openPopup:function(t){this._popup.setLatLng(t.latlng),this._map.openPopup(this._popup)}}),o.Browser.vml=!o.Browser.svg&&function(){try{var t=e.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(n){return!1}}(),o.Path=o.Browser.svg||!o.Browser.vml?o.Path:o.Path.extend({statics:{VML:!0,CLIP_PADDING:.02},_createElement:function(){try{return e.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return e.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),_initPath:function(){var t=this._container=this._createElement("shape");
-o.DomUtil.addClass(t,"leaflet-vml-shape"),this.options.clickable&&o.DomUtil.addClass(t,"leaflet-clickable"),t.coordsize="1 1",this._path=this._createElement("path"),t.appendChild(this._path),this._map._pathRoot.appendChild(t)},_initStyle:function(){this._updateStyle()},_updateStyle:function(){var t=this._stroke,e=this._fill,i=this.options,n=this._container;n.stroked=i.stroke,n.filled=i.fill,i.stroke?(t||(t=this._stroke=this._createElement("stroke"),t.endcap="round",n.appendChild(t)),t.weight=i.weight+"px",t.color=i.color,t.opacity=i.opacity,t.dashStyle=i.dashArray?i.dashArray instanceof Array?i.dashArray.join(" "):i.dashArray.replace(/( *, *)/g," "):""):t&&(n.removeChild(t),this._stroke=null),i.fill?(e||(e=this._fill=this._createElement("fill"),n.appendChild(e)),e.color=i.fillColor||i.color,e.opacity=i.fillOpacity):e&&(n.removeChild(e),this._fill=null)},_updatePath:function(){var t=this._container.style;t.display="none",this._path.v=this.getPathString()+" ",t.display=""}}),o.Map.include(o.Browser.svg||!o.Browser.vml?{}:{_initPathRoot:function(){if(!this._pathRoot){var t=this._pathRoot=e.createElement("div");t.className="leaflet-vml-container",this._panes.overlayPane.appendChild(t),this.on("moveend",this._updatePathViewport),this._updatePathViewport()}}}),o.Browser.canvas=function(){return!!e.createElement("canvas").getContext}(),o.Path=o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?o.Path:o.Path.extend({statics:{CANVAS:!0,SVG:!1},redraw:function(){return this._map&&(this.projectLatlngs(),this._requestUpdate()),this},setStyle:function(t){return o.setOptions(this,t),this._map&&(this._updateStyle(),this._requestUpdate()),this},onRemove:function(t){t.off("viewreset",this.projectLatlngs,this).off("moveend",this._updatePath,this),this.options.clickable&&(this._map.off("click",this._onClick,this),this._map.off("mousemove",this._onMouseMove,this)),this._requestUpdate(),this._map=null},_requestUpdate:function(){this._map&&!o.Path._updateRequest&&(o.Path._updateRequest=o.Util.requestAnimFrame(this._fireMapMoveEnd,this._map))},_fireMapMoveEnd:function(){o.Path._updateRequest=null,this.fire("moveend")},_initElements:function(){this._map._initPathRoot(),this._ctx=this._map._canvasCtx},_updateStyle:function(){var t=this.options;t.stroke&&(this._ctx.lineWidth=t.weight,this._ctx.strokeStyle=t.color),t.fill&&(this._ctx.fillStyle=t.fillColor||t.color)},_drawPath:function(){var t,e,i,n,s,a;for(this._ctx.beginPath(),t=0,i=this._parts.length;i>t;t++){for(e=0,n=this._parts[t].length;n>e;e++)s=this._parts[t][e],a=(0===e?"move":"line")+"To",this._ctx[a](s.x,s.y);this instanceof o.Polygon&&this._ctx.closePath()}},_checkIfEmpty:function(){return!this._parts.length},_updatePath:function(){if(!this._checkIfEmpty()){var t=this._ctx,e=this.options;this._drawPath(),t.save(),this._updateStyle(),e.fill&&(t.globalAlpha=e.fillOpacity,t.fill()),e.stroke&&(t.globalAlpha=e.opacity,t.stroke()),t.restore()}},_initEvents:function(){this.options.clickable&&(this._map.on("mousemove",this._onMouseMove,this),this._map.on("click",this._onClick,this))},_onClick:function(t){this._containsPoint(t.layerPoint)&&this.fire("click",t)},_onMouseMove:function(t){this._map&&!this._map._animatingZoom&&(this._containsPoint(t.layerPoint)?(this._ctx.canvas.style.cursor="pointer",this._mouseInside=!0,this.fire("mouseover",t)):this._mouseInside&&(this._ctx.canvas.style.cursor="",this._mouseInside=!1,this.fire("mouseout",t)))}}),o.Map.include(o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?{}:{_initPathRoot:function(){var t,i=this._pathRoot;i||(i=this._pathRoot=e.createElement("canvas"),i.style.position="absolute",t=this._canvasCtx=i.getContext("2d"),t.lineCap="round",t.lineJoin="round",this._panes.overlayPane.appendChild(i),this.options.zoomAnimation&&(this._pathRoot.className="leaflet-zoom-animated",this.on("zoomanim",this._animatePathZoom),this.on("zoomend",this._endPathZoom)),this.on("moveend",this._updateCanvasViewport),this._updateCanvasViewport())},_updateCanvasViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max.subtract(e),n=this._pathRoot;o.DomUtil.setPosition(n,e),n.width=i.x,n.height=i.y,n.getContext("2d").translate(-e.x,-e.y)}}}),o.LineUtil={simplify:function(t,e){if(!e||!t.length)return t.slice();var i=e*e;return t=this._reducePoints(t,i),t=this._simplifyDP(t,i)},pointToSegmentDistance:function(t,e,i){return Math.sqrt(this._sqClosestPointOnSegment(t,e,i,!0))},closestPointOnSegment:function(t,e,i){return this._sqClosestPointOnSegment(t,e,i)},_simplifyDP:function(t,e){var n=t.length,o=typeof Uint8Array!=i+""?Uint8Array:Array,s=new o(n);s[0]=s[n-1]=1,this._simplifyDPStep(t,s,e,0,n-1);var a,r=[];for(a=0;n>a;a++)s[a]&&r.push(t[a]);return r},_simplifyDPStep:function(t,e,i,n,o){var s,a,r,h=0;for(a=n+1;o-1>=a;a++)r=this._sqClosestPointOnSegment(t[a],t[n],t[o],!0),r>h&&(s=a,h=r);h>i&&(e[s]=1,this._simplifyDPStep(t,e,i,n,s),this._simplifyDPStep(t,e,i,s,o))},_reducePoints:function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;s>n;n++)this._sqDist(t[n],t[o])>e&&(i.push(t[n]),o=n);return s-1>o&&i.push(t[s-1]),i},clipSegment:function(t,e,i,n){var o,s,a,r=n?this._lastCode:this._getBitCode(t,i),h=this._getBitCode(e,i);for(this._lastCode=h;;){if(!(r|h))return[t,e];if(r&h)return!1;o=r||h,s=this._getEdgeIntersection(t,e,o,i),a=this._getBitCode(s,i),o===r?(t=s,r=a):(e=s,h=a)}},_getEdgeIntersection:function(t,e,i,n){var s=e.x-t.x,a=e.y-t.y,r=n.min,h=n.max;return 8&i?new o.Point(t.x+s*(h.y-t.y)/a,h.y):4&i?new o.Point(t.x+s*(r.y-t.y)/a,r.y):2&i?new o.Point(h.x,t.y+a*(h.x-t.x)/s):1&i?new o.Point(r.x,t.y+a*(r.x-t.x)/s):void 0},_getBitCode:function(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i},_sqDist:function(t,e){var i=e.x-t.x,n=e.y-t.y;return i*i+n*n},_sqClosestPointOnSegment:function(t,e,i,n){var s,a=e.x,r=e.y,h=i.x-a,l=i.y-r,u=h*h+l*l;return u>0&&(s=((t.x-a)*h+(t.y-r)*l)/u,s>1?(a=i.x,r=i.y):s>0&&(a+=h*s,r+=l*s)),h=t.x-a,l=t.y-r,n?h*h+l*l:new o.Point(a,r)}},o.Polyline=o.Path.extend({initialize:function(t,e){o.Path.prototype.initialize.call(this,e),this._latlngs=this._convertLatLngs(t)},options:{smoothFactor:1,noClip:!1},projectLatlngs:function(){this._originalPoints=[];for(var t=0,e=this._latlngs.length;e>t;t++)this._originalPoints[t]=this._map.latLngToLayerPoint(this._latlngs[t])},getPathString:function(){for(var t=0,e=this._parts.length,i="";e>t;t++)i+=this._getPathPartStr(this._parts[t]);return i},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._latlngs=this._convertLatLngs(t),this.redraw()},addLatLng:function(t){return this._latlngs.push(o.latLng(t)),this.redraw()},spliceLatLngs:function(){var t=[].splice.apply(this._latlngs,arguments);return this._convertLatLngs(this._latlngs,!0),this.redraw(),t},closestLayerPoint:function(t){for(var e,i,n=1/0,s=this._parts,a=null,r=0,h=s.length;h>r;r++)for(var l=s[r],u=1,c=l.length;c>u;u++){e=l[u-1],i=l[u];var d=o.LineUtil._sqClosestPointOnSegment(t,e,i,!0);n>d&&(n=d,a=o.LineUtil._sqClosestPointOnSegment(t,e,i))}return a&&(a.distance=Math.sqrt(n)),a},getBounds:function(){return new o.LatLngBounds(this.getLatLngs())},_convertLatLngs:function(t,e){var i,n,s=e?t:[];for(i=0,n=t.length;n>i;i++){if(o.Util.isArray(t[i])&&"number"!=typeof t[i][0])return;s[i]=o.latLng(t[i])}return s},_initEvents:function(){o.Path.prototype._initEvents.call(this)},_getPathPartStr:function(t){for(var e,i=o.Path.VML,n=0,s=t.length,a="";s>n;n++)e=t[n],i&&e._round(),a+=(n?"L":"M")+e.x+" "+e.y;return a},_clipPoints:function(){var t,e,i,n=this._originalPoints,s=n.length;if(this.options.noClip)return this._parts=[n],void 0;this._parts=[];var a=this._parts,r=this._map._pathViewport,h=o.LineUtil;for(t=0,e=0;s-1>t;t++)i=h.clipSegment(n[t],n[t+1],r,t),i&&(a[e]=a[e]||[],a[e].push(i[0]),(i[1]!==n[t+1]||t===s-2)&&(a[e].push(i[1]),e++))},_simplifyPoints:function(){for(var t=this._parts,e=o.LineUtil,i=0,n=t.length;n>i;i++)t[i]=e.simplify(t[i],this.options.smoothFactor)},_updatePath:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),o.Path.prototype._updatePath.call(this))}}),o.polyline=function(t,e){return new o.Polyline(t,e)},o.PolyUtil={},o.PolyUtil.clipPolygon=function(t,e){var i,n,s,a,r,h,l,u,c,d=[1,4,2,8],p=o.LineUtil;for(n=0,l=t.length;l>n;n++)t[n]._code=p._getBitCode(t[n],e);for(a=0;4>a;a++){for(u=d[a],i=[],n=0,l=t.length,s=l-1;l>n;s=n++)r=t[n],h=t[s],r._code&u?h._code&u||(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)):(h._code&u&&(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)),i.push(r));t=i}return t},o.Polygon=o.Polyline.extend({options:{fill:!0},initialize:function(t,e){var i,n,s;if(o.Polyline.prototype.initialize.call(this,t,e),t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0])for(this._latlngs=this._convertLatLngs(t[0]),this._holes=t.slice(1),i=0,n=this._holes.length;n>i;i++)s=this._holes[i]=this._convertLatLngs(this._holes[i]),s[0].equals(s[s.length-1])&&s.pop();t=this._latlngs,t.length>=2&&t[0].equals(t[t.length-1])&&t.pop()},projectLatlngs:function(){if(o.Polyline.prototype.projectLatlngs.call(this),this._holePoints=[],this._holes){var t,e,i,n;for(t=0,i=this._holes.length;i>t;t++)for(this._holePoints[t]=[],e=0,n=this._holes[t].length;n>e;e++)this._holePoints[t][e]=this._map.latLngToLayerPoint(this._holes[t][e])}},_clipPoints:function(){var t=this._originalPoints,e=[];if(this._parts=[t].concat(this._holePoints),!this.options.noClip){for(var i=0,n=this._parts.length;n>i;i++){var s=o.PolyUtil.clipPolygon(this._parts[i],this._map._pathViewport);s.length&&e.push(s)}this._parts=e}},_getPathPartStr:function(t){var e=o.Polyline.prototype._getPathPartStr.call(this,t);return e+(o.Browser.svg?"z":"x")}}),o.polygon=function(t,e){return new o.Polygon(t,e)},function(){function t(t){return o.FeatureGroup.extend({initialize:function(t,e){this._layers={},this._options=e,this.setLatLngs(t)},setLatLngs:function(e){var i=0,n=e.length;for(this.eachLayer(function(t){n>i?t.setLatLngs(e[i++]):this.removeLayer(t)},this);n>i;)this.addLayer(new t(e[i++],this._options));return this},getLatLngs:function(){var t=[];return this.eachLayer(function(e){t.push(e.getLatLngs())}),t}})}o.MultiPolyline=t(o.Polyline),o.MultiPolygon=t(o.Polygon),o.multiPolyline=function(t,e){return new o.MultiPolyline(t,e)},o.multiPolygon=function(t,e){return new o.MultiPolygon(t,e)}}(),o.Rectangle=o.Polygon.extend({initialize:function(t,e){o.Polygon.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=o.latLngBounds(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}}),o.rectangle=function(t,e){return new o.Rectangle(t,e)},o.Circle=o.Path.extend({initialize:function(t,e,i){o.Path.prototype.initialize.call(this,i),this._latlng=o.latLng(t),this._mRadius=e},options:{fill:!0},setLatLng:function(t){return this._latlng=o.latLng(t),this.redraw()},setRadius:function(t){return this._mRadius=t,this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,i=this._map.latLngToLayerPoint([e.lat,e.lng-t]);this._point=this._map.latLngToLayerPoint(e),this._radius=Math.max(this._point.x-i.x,1)},getBounds:function(){var t=this._getLngRadius(),e=360*(this._mRadius/40075017),i=this._latlng;return new o.LatLngBounds([i.lat-e,i.lng-t],[i.lat+e,i.lng+t])},getLatLng:function(){return this._latlng},getPathString:function(){var t=this._point,e=this._radius;return this._checkIfEmpty()?"":o.Browser.svg?"M"+t.x+","+(t.y-e)+"A"+e+","+e+",0,1,1,"+(t.x-.1)+","+(t.y-e)+" z":(t._round(),e=Math.round(e),"AL "+t.x+","+t.y+" "+e+","+e+" 0,"+23592600)},getRadius:function(){return this._mRadius},_getLatRadius:function(){return 360*(this._mRadius/40075017)},_getLngRadius:function(){return this._getLatRadius()/Math.cos(o.LatLng.DEG_TO_RAD*this._latlng.lat)},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._radius,i=this._point;return i.x-e>t.max.x||i.y-e>t.max.y||i.x+e<t.min.x||i.y+e<t.min.y}}),o.circle=function(t,e,i){return new o.Circle(t,e,i)},o.CircleMarker=o.Circle.extend({options:{radius:10,weight:2},initialize:function(t,e){o.Circle.prototype.initialize.call(this,t,null,e),this._radius=this.options.radius},projectLatlngs:function(){this._point=this._map.latLngToLayerPoint(this._latlng)},_updateStyle:function(){o.Circle.prototype._updateStyle.call(this),this.setRadius(this.options.radius)},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()}}),o.circleMarker=function(t,e){return new o.CircleMarker(t,e)},o.Polyline.include(o.Path.CANVAS?{_containsPoint:function(t,e){var i,n,s,a,r,h,l,u=this.options.weight/2;for(o.Browser.touch&&(u+=10),i=0,a=this._parts.length;a>i;i++)for(l=this._parts[i],n=0,r=l.length,s=r-1;r>n;s=n++)if((e||0!==n)&&(h=o.LineUtil.pointToSegmentDistance(t,l[s],l[n]),u>=h))return!0;return!1}}:{}),o.Polygon.include(o.Path.CANVAS?{_containsPoint:function(t){var e,i,n,s,a,r,h,l,u=!1;if(o.Polyline.prototype._containsPoint.call(this,t,!0))return!0;for(s=0,h=this._parts.length;h>s;s++)for(e=this._parts[s],a=0,l=e.length,r=l-1;l>a;r=a++)i=e[a],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(u=!u);return u}}:{}),o.Circle.include(o.Path.CANVAS?{_drawPath:function(){var t=this._point;this._ctx.beginPath(),this._ctx.arc(t.x,t.y,this._radius,0,2*Math.PI,!1)},_containsPoint:function(t){var e=this._point,i=this.options.stroke?this.options.weight/2:0;return t.distanceTo(e)<=this._radius+i}}:{}),o.CircleMarker.include(o.Path.CANVAS?{_updateStyle:function(){o.Path.prototype._updateStyle.call(this)}}:{}),o.GeoJSON=o.FeatureGroup.extend({initialize:function(t,e){o.setOptions(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,s=o.Util.isArray(t)?t:t.features;if(s){for(e=0,i=s.length;i>e;e++)n=s[e],(n.geometries||n.geometry||n.features||n.coordinates)&&this.addData(s[e]);return this}var a=this.options;if(!a.filter||a.filter(t)){var r=o.GeoJSON.geometryToLayer(t,a.pointToLayer,a.coordsToLatLng);return r.feature=o.GeoJSON.asFeature(t),r.defaultOptions=r.options,this.resetStyle(r),a.onEachFeature&&a.onEachFeature(t,r),this.addLayer(r)}},resetStyle:function(t){var e=this.options.style;e&&(o.Util.extend(t.options,t.defaultOptions),this._setLayerStyle(t,e))},setStyle:function(t){this.eachLayer(function(e){this._setLayerStyle(e,t)},this)},_setLayerStyle:function(t,e){"function"==typeof e&&(e=e(t.feature)),t.setStyle&&t.setStyle(e)}}),o.extend(o.GeoJSON,{geometryToLayer:function(t,e,i){var n,s,a,r,h,l="Feature"===t.type?t.geometry:t,u=l.coordinates,c=[];switch(i=i||this.coordsToLatLng,l.type){case"Point":return n=i(u),e?e(t,n):new o.Marker(n);case"MultiPoint":for(a=0,r=u.length;r>a;a++)n=i(u[a]),h=e?e(t,n):new o.Marker(n),c.push(h);return new o.FeatureGroup(c);case"LineString":return s=this.coordsToLatLngs(u,0,i),new o.Polyline(s);case"Polygon":return s=this.coordsToLatLngs(u,1,i),new o.Polygon(s);case"MultiLineString":return s=this.coordsToLatLngs(u,1,i),new o.MultiPolyline(s);case"MultiPolygon":return s=this.coordsToLatLngs(u,2,i),new o.MultiPolygon(s);case"GeometryCollection":for(a=0,r=l.geometries.length;r>a;a++)h=this.geometryToLayer({geometry:l.geometries[a],type:"Feature",properties:t.properties},e,i),c.push(h);return new o.FeatureGroup(c);default:throw new Error("Invalid GeoJSON object.")}},coordsToLatLng:function(t){return new o.LatLng(t[1],t[0])},coordsToLatLngs:function(t,e,i){var n,o,s,a=[];for(o=0,s=t.length;s>o;o++)n=e?this.coordsToLatLngs(t[o],e-1,i):(i||this.coordsToLatLng)(t[o]),a.push(n);return a},latLngToCoords:function(t){return[t.lng,t.lat]},latLngsToCoords:function(t){for(var e=[],i=0,n=t.length;n>i;i++)e.push(o.GeoJSON.latLngToCoords(t[i]));return e},getFeature:function(t,e){return t.feature?o.extend({},t.feature,{geometry:e}):o.GeoJSON.asFeature(e)},asFeature:function(t){return"Feature"===t.type?t:{type:"Feature",properties:{},geometry:t}}});var a={toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"Point",coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())})}};o.Marker.include(a),o.Circle.include(a),o.CircleMarker.include(a),o.Polyline.include({toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"LineString",coordinates:o.GeoJSON.latLngsToCoords(this.getLatLngs())})}}),o.Polygon.include({toGeoJSON:function(){var t,e,i,n=[o.GeoJSON.latLngsToCoords(this.getLatLngs())];if(n[0].push(n[0][0]),this._holes)for(t=0,e=this._holes.length;e>t;t++)i=o.GeoJSON.latLngsToCoords(this._holes[t]),i.push(i[0]),n.push(i);return o.GeoJSON.getFeature(this,{type:"Polygon",coordinates:n})}}),function(){function t(t,e){t.include({toGeoJSON:function(){var t=[];return this.eachLayer(function(e){t.push(e.toGeoJSON().geometry.coordinates)}),o.GeoJSON.getFeature(this,{type:e,coordinates:t})}})}t(o.MultiPolyline,"MultiLineString"),t(o.MultiPolygon,"MultiPolygon")}(),o.LayerGroup.include({toGeoJSON:function(){var t=[];return this.eachLayer(function(e){e.toGeoJSON&&t.push(o.GeoJSON.asFeature(e.toGeoJSON()))}),{type:"FeatureCollection",features:t}}}),o.geoJson=function(t,e){return new o.GeoJSON(t,e)},o.DomEvent={addListener:function(t,e,i,n){var s,a,r,h=o.stamp(i),l="_leaflet_"+e+h;return t[l]?this:(s=function(e){return i.call(n||t,e||o.DomEvent._getEvent())},o.Browser.msTouch&&0===e.indexOf("touch")?this.addMsTouchListener(t,e,s,h):(o.Browser.touch&&"dblclick"===e&&this.addDoubleTapListener&&this.addDoubleTapListener(t,s,h),"addEventListener"in t?"mousewheel"===e?(t.addEventListener("DOMMouseScroll",s,!1),t.addEventListener(e,s,!1)):"mouseenter"===e||"mouseleave"===e?(a=s,r="mouseenter"===e?"mouseover":"mouseout",s=function(e){return o.DomEvent._checkMouse(t,e)?a(e):void 0},t.addEventListener(r,s,!1)):"click"===e&&o.Browser.android?(a=s,s=function(t){return o.DomEvent._filterClick(t,a)},t.addEventListener(e,s,!1)):t.addEventListener(e,s,!1):"attachEvent"in t&&t.attachEvent("on"+e,s),t[l]=s,this))},removeListener:function(t,e,i){var n=o.stamp(i),s="_leaflet_"+e+n,a=t[s];return a?(o.Browser.msTouch&&0===e.indexOf("touch")?this.removeMsTouchListener(t,e,n):o.Browser.touch&&"dblclick"===e&&this.removeDoubleTapListener?this.removeDoubleTapListener(t,n):"removeEventListener"in t?"mousewheel"===e?(t.removeEventListener("DOMMouseScroll",a,!1),t.removeEventListener(e,a,!1)):"mouseenter"===e||"mouseleave"===e?t.removeEventListener("mouseenter"===e?"mouseover":"mouseout",a,!1):t.removeEventListener(e,a,!1):"detachEvent"in t&&t.detachEvent("on"+e,a),t[s]=null,this):this},stopPropagation:function(t){return t.stopPropagation?t.stopPropagation():t.cancelBubble=!0,this},disableClickPropagation:function(t){for(var e=o.DomEvent.stopPropagation,i=o.Draggable.START.length-1;i>=0;i--)o.DomEvent.addListener(t,o.Draggable.START[i],e);return o.DomEvent.addListener(t,"click",o.DomEvent._fakeStop).addListener(t,"dblclick",e)},preventDefault:function(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this},stop:function(t){return o.DomEvent.preventDefault(t).stopPropagation(t)},getMousePosition:function(t,i){var n=o.Browser.ie7,s=e.body,a=e.documentElement,r=t.pageX?t.pageX-s.scrollLeft-a.scrollLeft:t.clientX,h=t.pageY?t.pageY-s.scrollTop-a.scrollTop:t.clientY,l=new o.Point(r,h),u=i.getBoundingClientRect(),c=u.left-i.clientLeft,d=u.top-i.clientTop;return o.DomUtil.documentIsLtr()||!o.Browser.webkit&&!n||(c+=i.scrollWidth-i.clientWidth,n&&"hidden"!==o.DomUtil.getStyle(i,"overflow-y")&&"hidden"!==o.DomUtil.getStyle(i,"overflow")&&(c+=17)),l._subtract(new o.Point(c,d))},getWheelDelta:function(t){var e=0;return t.wheelDelta&&(e=t.wheelDelta/120),t.detail&&(e=-t.detail/3),e},_skipEvents:{},_fakeStop:function(t){o.DomEvent._skipEvents[t.type]=!0},_skipped:function(t){var e=this._skipEvents[t.type];return this._skipEvents[t.type]=!1,e},_checkMouse:function(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(n){return!1}return i!==t},_getEvent:function(){var e=t.event;if(!e)for(var i=arguments.callee.caller;i&&(e=i.arguments[0],!e||t.Event!==e.constructor);)i=i.caller;return e},_filterClick:function(t,e){var i=t.timeStamp||t.originalEvent.timeStamp,n=o.DomEvent._lastClick&&i-o.DomEvent._lastClick;return n&&n>100&&1e3>n||t.target._simulatedClick&&!t._simulated?(o.DomEvent.stop(t),void 0):(o.DomEvent._lastClick=i,e(t))}},o.DomEvent.on=o.DomEvent.addListener,o.DomEvent.off=o.DomEvent.removeListener,o.Draggable=o.Class.extend({includes:o.Mixin.Events,statics:{START:o.Browser.touch?["touchstart","mousedown"]:["mousedown"],END:{mousedown:"mouseup",touchstart:"touchend",MSPointerDown:"touchend"},MOVE:{mousedown:"mousemove",touchstart:"touchmove",MSPointerDown:"touchmove"}},initialize:function(t,e){this._element=t,this._dragStartTarget=e||t},enable:function(){if(!this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.on(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!0}},disable:function(){if(this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.off(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!1,this._moved=!1}},_onDown:function(t){if(!t.shiftKey&&(1===t.which||1===t.button||t.touches)&&(o.DomEvent.stopPropagation(t),!o.Draggable._disabled)){o.DomUtil.disableImageDrag(),o.DomUtil.disableTextSelection();var i=t.touches?t.touches[0]:t,n=i.target;o.Browser.touch&&"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._moved=!1,this._moving||(this._startPoint=new o.Point(i.clientX,i.clientY),this._startPos=this._newPos=o.DomUtil.getPosition(this._element),o.DomEvent.on(e,o.Draggable.MOVE[t.type],this._onMove,this).on(e,o.Draggable.END[t.type],this._onUp,this))}},_onMove:function(t){if(!(t.touches&&t.touches.length>1)){var i=t.touches&&1===t.touches.length?t.touches[0]:t,n=new o.Point(i.clientX,i.clientY),s=n.subtract(this._startPoint);(s.x||s.y)&&(o.DomEvent.preventDefault(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=o.DomUtil.getPosition(this._element).subtract(s),o.Browser.touch||o.DomUtil.addClass(e.body,"leaflet-dragging")),this._newPos=this._startPos.add(s),this._moving=!0,o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updatePosition,this,!0,this._dragStartTarget))}},_updatePosition:function(){this.fire("predrag"),o.DomUtil.setPosition(this._element,this._newPos),this.fire("drag")},_onUp:function(){o.Browser.touch||o.DomUtil.removeClass(e.body,"leaflet-dragging");for(var t in o.Draggable.MOVE)o.DomEvent.off(e,o.Draggable.MOVE[t],this._onMove).off(e,o.Draggable.END[t],this._onUp);o.DomUtil.enableImageDrag(),o.DomUtil.enableTextSelection(),this._moved&&(o.Util.cancelAnimFrame(this._animRequest),this.fire("dragend")),this._moving=!1}}),o.Handler=o.Class.extend({initialize:function(t){this._map=t},enable:function(){this._enabled||(this._enabled=!0,this.addHooks())},disable:function(){this._enabled&&(this._enabled=!1,this.removeHooks())},enabled:function(){return!!this._enabled}}),o.Map.mergeOptions({dragging:!0,inertia:!o.Browser.android23,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,inertiaThreshold:o.Browser.touch?32:18,easeLinearity:.25,worldCopyJump:!1}),o.Map.Drag=o.Handler.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new o.Draggable(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDrag,this),t.on("viewreset",this._onViewReset,this),this._onViewReset())}this._draggable.enable()},removeHooks:function(){this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){var t=this._map;t._panAnim&&t._panAnim.stop(),t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(){if(this._map.options.inertia){var t=this._lastTime=+new Date,e=this._lastPos=this._draggable._newPos;this._positions.push(e),this._times.push(t),t-this._times[0]>200&&(this._positions.shift(),this._times.shift())}this._map.fire("move").fire("drag")},_onViewReset:function(){var t=this._map.getSize()._divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.project([0,180]).x},_onPreDrag:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,s=(n+e+i)%t-e-i,a=Math.abs(o+i)<Math.abs(s+i)?o:s;this._draggable._newPos.x=a},_onDragEnd:function(){var t=this._map,e=t.options,i=+new Date-this._lastTime,n=!e.inertia||i>e.inertiaThreshold||!this._positions[0];if(t.fire("dragend"),n)t.fire("moveend");else{var s=this._lastPos.subtract(this._positions[0]),a=(this._lastTime+i-this._times[0])/1e3,r=e.easeLinearity,h=s.multiplyBy(r/a),l=h.distanceTo([0,0]),u=Math.min(e.inertiaMaxSpeed,l),c=h.multiplyBy(u/l),d=u/(e.inertiaDeceleration*r),p=c.multiplyBy(-d/2).round();p.x&&p.y?o.Util.requestAnimFrame(function(){t.panBy(p,{duration:d,easeLinearity:r,noMoveStart:!0})}):t.fire("moveend")}}}),o.Map.addInitHook("addHandler","dragging",o.Map.Drag),o.Map.mergeOptions({doubleClickZoom:!0}),o.Map.DoubleClickZoom=o.Handler.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick)},_onDoubleClick:function(t){this.setZoomAround(t.containerPoint,this._zoom+1)}}),o.Map.addInitHook("addHandler","doubleClickZoom",o.Map.DoubleClickZoom),o.Map.mergeOptions({scrollWheelZoom:!0}),o.Map.ScrollWheelZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"mousewheel",this._onWheelScroll,this),o.DomEvent.on(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault),this._delta=0},removeHooks:function(){o.DomEvent.off(this._map._container,"mousewheel",this._onWheelScroll),o.DomEvent.off(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault)},_onWheelScroll:function(t){var e=o.DomEvent.getWheelDelta(t);this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var i=Math.max(40-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o.bind(this._performZoom,this),i),o.DomEvent.preventDefault(t),o.DomEvent.stopPropagation(t)},_performZoom:function(){var t=this._map,e=this._delta,i=t.getZoom();e=e>0?Math.ceil(e):Math.floor(e),e=Math.max(Math.min(e,4),-4),e=t._limitZoom(i+e)-i,this._delta=0,this._startTime=null,e&&t.setZoomAround(this._lastMousePos,i+e)}}),o.Map.addInitHook("addHandler","scrollWheelZoom",o.Map.ScrollWheelZoom),o.extend(o.DomEvent,{_touchstart:o.Browser.msTouch?"MSPointerDown":"touchstart",_touchend:o.Browser.msTouch?"MSPointerUp":"touchend",addDoubleTapListener:function(t,i,n){function s(t){var e;if(o.Browser.msTouch?(_.push(t.pointerId),e=_.length):e=t.touches.length,!(e>1)){var i=Date.now(),n=i-(r||i);h=t.touches?t.touches[0]:t,l=n>0&&u>=n,r=i}}function a(t){if(o.Browser.msTouch){var e=_.indexOf(t.pointerId);if(-1===e)return;_.splice(e,1)}if(l){if(o.Browser.msTouch){var n,s={};for(var a in h)n=h[a],s[a]="function"==typeof n?n.bind(h):n;h=s}h.type="dblclick",i(h),r=null}}var r,h,l=!1,u=250,c="_leaflet_",d=this._touchstart,p=this._touchend,_=[];t[c+d+n]=s,t[c+p+n]=a;var m=o.Browser.msTouch?e.documentElement:t;return t.addEventListener(d,s,!1),m.addEventListener(p,a,!1),o.Browser.msTouch&&m.addEventListener("MSPointerCancel",a,!1),this},removeDoubleTapListener:function(t,i){var n="_leaflet_";return t.removeEventListener(this._touchstart,t[n+this._touchstart+i],!1),(o.Browser.msTouch?e.documentElement:t).removeEventListener(this._touchend,t[n+this._touchend+i],!1),o.Browser.msTouch&&e.documentElement.removeEventListener("MSPointerCancel",t[n+this._touchend+i],!1),this}}),o.extend(o.DomEvent,{_msTouches:[],_msDocumentListener:!1,addMsTouchListener:function(t,e,i,n){switch(e){case"touchstart":return this.addMsTouchListenerStart(t,e,i,n);case"touchend":return this.addMsTouchListenerEnd(t,e,i,n);case"touchmove":return this.addMsTouchListenerMove(t,e,i,n);default:throw"Unknown touch event type"}},addMsTouchListenerStart:function(t,i,n,o){var s="_leaflet_",a=this._msTouches,r=function(t){for(var e=!1,i=0;i<a.length;i++)if(a[i].pointerId===t.pointerId){e=!0;break}e||a.push(t),t.touches=a.slice(),t.changedTouches=[t],n(t)};if(t[s+"touchstart"+o]=r,t.addEventListener("MSPointerDown",r,!1),!this._msDocumentListener){var h=function(t){for(var e=0;e<a.length;e++)if(a[e].pointerId===t.pointerId){a.splice(e,1);break}};e.documentElement.addEventListener("MSPointerUp",h,!1),e.documentElement.addEventListener("MSPointerCancel",h,!1),this._msDocumentListener=!0}return this},addMsTouchListenerMove:function(t,e,i,n){function o(t){if(t.pointerType!==t.MSPOINTER_TYPE_MOUSE||0!==t.buttons){for(var e=0;e<a.length;e++)if(a[e].pointerId===t.pointerId){a[e]=t;break}t.touches=a.slice(),t.changedTouches=[t],i(t)}}var s="_leaflet_",a=this._msTouches;return t[s+"touchmove"+n]=o,t.addEventListener("MSPointerMove",o,!1),this},addMsTouchListenerEnd:function(t,e,i,n){var o="_leaflet_",s=this._msTouches,a=function(t){for(var e=0;e<s.length;e++)if(s[e].pointerId===t.pointerId){s.splice(e,1);break}t.touches=s.slice(),t.changedTouches=[t],i(t)};return t[o+"touchend"+n]=a,t.addEventListener("MSPointerUp",a,!1),t.addEventListener("MSPointerCancel",a,!1),this},removeMsTouchListener:function(t,e,i){var n="_leaflet_",o=t[n+e+i];switch(e){case"touchstart":t.removeEventListener("MSPointerDown",o,!1);break;case"touchmove":t.removeEventListener("MSPointerMove",o,!1);break;case"touchend":t.removeEventListener("MSPointerUp",o,!1),t.removeEventListener("MSPointerCancel",o,!1)}return this}}),o.Map.mergeOptions({touchZoom:o.Browser.touch&&!o.Browser.android23}),o.Map.TouchZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var n=i.mouseEventToLayerPoint(t.touches[0]),s=i.mouseEventToLayerPoint(t.touches[1]),a=i._getCenterLayerPoint();this._startCenter=n.add(s)._divideBy(2),this._startDist=n.distanceTo(s),this._moved=!1,this._zooming=!0,this._centerOffset=a.subtract(this._startCenter),i._panAnim&&i._panAnim.stop(),o.DomEvent.on(e,"touchmove",this._onTouchMove,this).on(e,"touchend",this._onTouchEnd,this),o.DomEvent.preventDefault(t)}},_onTouchMove:function(t){var e=this._map;if(t.touches&&2===t.touches.length&&this._zooming){var i=e.mouseEventToLayerPoint(t.touches[0]),n=e.mouseEventToLayerPoint(t.touches[1]);this._scale=i.distanceTo(n)/this._startDist,this._delta=i._add(n)._divideBy(2)._subtract(this._startCenter),1!==this._scale&&(this._moved||(o.DomUtil.addClass(e._mapPane,"leaflet-touching"),e.fire("movestart").fire("zoomstart"),this._moved=!0),o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updateOnMove,this,!0,this._map._container),o.DomEvent.preventDefault(t))}},_updateOnMove:function(){var t=this._map,e=this._getScaleOrigin(),i=t.layerPointToLatLng(e),n=t.getScaleZoom(this._scale);t._animateZoom(i,n,this._startCenter,this._scale,this._delta)},_onTouchEnd:function(){if(!this._moved||!this._zooming)return this._zooming=!1,void 0;var t=this._map;this._zooming=!1,o.DomUtil.removeClass(t._mapPane,"leaflet-touching"),o.Util.cancelAnimFrame(this._animRequest),o.DomEvent.off(e,"touchmove",this._onTouchMove).off(e,"touchend",this._onTouchEnd);var i=this._getScaleOrigin(),n=t.layerPointToLatLng(i),s=t.getZoom(),a=t.getScaleZoom(this._scale)-s,r=a>0?Math.ceil(a):Math.floor(a),h=t._limitZoom(s+r),l=t.getZoomScale(h)/this._scale;t._animateZoom(n,h,i,l)},_getScaleOrigin:function(){var t=this._centerOffset.subtract(this._delta).divideBy(this._scale);return this._startCenter.add(t)}}),o.Map.addInitHook("addHandler","touchZoom",o.Map.TouchZoom),o.Map.mergeOptions({tap:!0,tapTolerance:15}),o.Map.Tap=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onDown,this)
-},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(o.DomEvent.preventDefault(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,clearTimeout(this._holdTimeout),void 0;var i=t.touches[0],n=i.target;this._startPos=this._newPos=new o.Point(i.clientX,i.clientY),"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._holdTimeout=setTimeout(o.bind(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),o.DomEvent.on(e,"touchmove",this._onMove,this).on(e,"touchend",this._onUp,this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),o.DomEvent.off(e,"touchmove",this._onMove,this).off(e,"touchend",this._onUp,this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],n=i.target;"a"===n.tagName.toLowerCase()&&o.DomUtil.removeClass(n,"leaflet-active"),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var e=t.touches[0];this._newPos=new o.Point(e.clientX,e.clientY)},_simulateEvent:function(i,n){var o=e.createEvent("MouseEvents");o._simulated=!0,n.target._simulatedClick=!0,o.initMouseEvent(i,!0,!0,t,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),n.target.dispatchEvent(o)}}),o.Browser.touch&&!o.Browser.msTouch&&o.Map.addInitHook("addHandler","tap",o.Map.Tap),o.Map.mergeOptions({boxZoom:!0}),o.Map.BoxZoom=o.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane},addHooks:function(){o.DomEvent.on(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){o.DomEvent.off(this._container,"mousedown",this._onMouseDown)},_onMouseDown:function(t){return!t.shiftKey||1!==t.which&&1!==t.button?!1:(o.DomUtil.disableTextSelection(),o.DomUtil.disableImageDrag(),this._startLayerPoint=this._map.mouseEventToLayerPoint(t),this._box=o.DomUtil.create("div","leaflet-zoom-box",this._pane),o.DomUtil.setPosition(this._box,this._startLayerPoint),this._container.style.cursor="crosshair",o.DomEvent.on(e,"mousemove",this._onMouseMove,this).on(e,"mouseup",this._onMouseUp,this).on(e,"keydown",this._onKeyDown,this),this._map.fire("boxzoomstart"),void 0)},_onMouseMove:function(t){var e=this._startLayerPoint,i=this._box,n=this._map.mouseEventToLayerPoint(t),s=n.subtract(e),a=new o.Point(Math.min(n.x,e.x),Math.min(n.y,e.y));o.DomUtil.setPosition(i,a),i.style.width=Math.max(0,Math.abs(s.x)-4)+"px",i.style.height=Math.max(0,Math.abs(s.y)-4)+"px"},_finish:function(){this._pane.removeChild(this._box),this._container.style.cursor="",o.DomUtil.enableTextSelection(),o.DomUtil.enableImageDrag(),o.DomEvent.off(e,"mousemove",this._onMouseMove).off(e,"mouseup",this._onMouseUp).off(e,"keydown",this._onKeyDown)},_onMouseUp:function(t){this._finish();var e=this._map,i=e.mouseEventToLayerPoint(t);if(!this._startLayerPoint.equals(i)){var n=new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint),e.layerPointToLatLng(i));e.fitBounds(n),e.fire("boxzoomend",{boxZoomBounds:n})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}}),o.Map.addInitHook("addHandler","boxZoom",o.Map.BoxZoom),o.Map.mergeOptions({keyboard:!0,keyboardPanOffset:80,keyboardZoomOffset:1}),o.Map.Keyboard=o.Handler.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61],zoomOut:[189,109,173]},initialize:function(t){this._map=t,this._setPanOffset(t.options.keyboardPanOffset),this._setZoomOffset(t.options.keyboardZoomOffset)},addHooks:function(){var t=this._map._container;-1===t.tabIndex&&(t.tabIndex="0"),o.DomEvent.on(t,"focus",this._onFocus,this).on(t,"blur",this._onBlur,this).on(t,"mousedown",this._onMouseDown,this),this._map.on("focus",this._addHooks,this).on("blur",this._removeHooks,this)},removeHooks:function(){this._removeHooks();var t=this._map._container;o.DomEvent.off(t,"focus",this._onFocus,this).off(t,"blur",this._onBlur,this).off(t,"mousedown",this._onMouseDown,this),this._map.off("focus",this._addHooks,this).off("blur",this._removeHooks,this)},_onMouseDown:function(){if(!this._focused){var i=e.body,n=e.documentElement,o=i.scrollTop||n.scrollTop,s=i.scrollLeft||n.scrollLeft;this._map._container.focus(),t.scrollTo(s,o)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanOffset:function(t){var e,i,n=this._panKeys={},o=this.keyCodes;for(e=0,i=o.left.length;i>e;e++)n[o.left[e]]=[-1*t,0];for(e=0,i=o.right.length;i>e;e++)n[o.right[e]]=[t,0];for(e=0,i=o.down.length;i>e;e++)n[o.down[e]]=[0,t];for(e=0,i=o.up.length;i>e;e++)n[o.up[e]]=[0,-1*t]},_setZoomOffset:function(t){var e,i,n=this._zoomKeys={},o=this.keyCodes;for(e=0,i=o.zoomIn.length;i>e;e++)n[o.zoomIn[e]]=t;for(e=0,i=o.zoomOut.length;i>e;e++)n[o.zoomOut[e]]=-t},_addHooks:function(){o.DomEvent.on(e,"keydown",this._onKeyDown,this)},_removeHooks:function(){o.DomEvent.off(e,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){var e=t.keyCode,i=this._map;if(e in this._panKeys){if(i._panAnim&&i._panAnim._inProgress)return;i.panBy(this._panKeys[e]),i.options.maxBounds&&i.panInsideBounds(i.options.maxBounds)}else{if(!(e in this._zoomKeys))return;i.setZoom(i.getZoom()+this._zoomKeys[e])}o.DomEvent.stop(t)}}),o.Map.addInitHook("addHandler","keyboard",o.Map.Keyboard),o.Handler.MarkerDrag=o.Handler.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new o.Draggable(t,t)),this._draggable.on("dragstart",this._onDragStart,this).on("drag",this._onDrag,this).on("dragend",this._onDragEnd,this),this._draggable.enable()},removeHooks:function(){this._draggable.off("dragstart",this._onDragStart,this).off("drag",this._onDrag,this).off("dragend",this._onDragEnd,this),this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){this._marker.closePopup().fire("movestart").fire("dragstart")},_onDrag:function(){var t=this._marker,e=t._shadow,i=o.DomUtil.getPosition(t._icon),n=t._map.layerPointToLatLng(i);e&&o.DomUtil.setPosition(e,i),t._latlng=n,t.fire("move",{latlng:n}).fire("drag")},_onDragEnd:function(){this._marker.fire("moveend").fire("dragend")}}),o.Control=o.Class.extend({options:{position:"topright"},initialize:function(t){o.setOptions(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),n=t._controlCorners[i];return o.DomUtil.addClass(e,"leaflet-control"),-1!==i.indexOf("bottom")?n.insertBefore(e,n.firstChild):n.appendChild(e),this},removeFrom:function(t){var e=this.getPosition(),i=t._controlCorners[e];return i.removeChild(this._container),this._map=null,this.onRemove&&this.onRemove(t),this}}),o.control=function(t){return new o.Control(t)},o.Map.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.removeFrom(this),this},_initControlPos:function(){function t(t,s){var a=i+t+" "+i+s;e[t+s]=o.DomUtil.create("div",a,n)}var e=this._controlCorners={},i="leaflet-",n=this._controlContainer=o.DomUtil.create("div",i+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){this._container.removeChild(this._controlContainer)}}),o.Control.Zoom=o.Control.extend({options:{position:"topleft"},onAdd:function(t){var e="leaflet-control-zoom",i=o.DomUtil.create("div",e+" leaflet-bar");return this._map=t,this._zoomInButton=this._createButton("+","Zoom in",e+"-in",i,this._zoomIn,this),this._zoomOutButton=this._createButton("-","Zoom out",e+"-out",i,this._zoomOut,this),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},_zoomIn:function(t){this._map.zoomIn(t.shiftKey?3:1)},_zoomOut:function(t){this._map.zoomOut(t.shiftKey?3:1)},_createButton:function(t,e,i,n,s,a){var r=o.DomUtil.create("a",i,n);r.innerHTML=t,r.href="#",r.title=e;var h=o.DomEvent.stopPropagation;return o.DomEvent.on(r,"click",h).on(r,"mousedown",h).on(r,"dblclick",h).on(r,"click",o.DomEvent.preventDefault).on(r,"click",s,a),r},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";o.DomUtil.removeClass(this._zoomInButton,e),o.DomUtil.removeClass(this._zoomOutButton,e),t._zoom===t.getMinZoom()&&o.DomUtil.addClass(this._zoomOutButton,e),t._zoom===t.getMaxZoom()&&o.DomUtil.addClass(this._zoomInButton,e)}}),o.Map.mergeOptions({zoomControl:!0}),o.Map.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new o.Control.Zoom,this.addControl(this.zoomControl))}),o.control.zoom=function(t){return new o.Control.Zoom(t)},o.Control.Attribution=o.Control.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){o.setOptions(this,t),this._attributions={}},onAdd:function(t){return this._container=o.DomUtil.create("div","leaflet-control-attribution"),o.DomEvent.disableClickPropagation(this._container),t.on("layeradd",this._onLayerAdd,this).on("layerremove",this._onLayerRemove,this),this._update(),this._container},onRemove:function(t){t.off("layeradd",this._onLayerAdd).off("layerremove",this._onLayerRemove)},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):void 0},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):void 0},_update:function(){if(this._map){var t=[];for(var e in this._attributions)this._attributions[e]&&t.push(e);var i=[];this.options.prefix&&i.push(this.options.prefix),t.length&&i.push(t.join(", ")),this._container.innerHTML=i.join(" | ")}},_onLayerAdd:function(t){t.layer.getAttribution&&this.addAttribution(t.layer.getAttribution())},_onLayerRemove:function(t){t.layer.getAttribution&&this.removeAttribution(t.layer.getAttribution())}}),o.Map.mergeOptions({attributionControl:!0}),o.Map.addInitHook(function(){this.options.attributionControl&&(this.attributionControl=(new o.Control.Attribution).addTo(this))}),o.control.attribution=function(t){return new o.Control.Attribution(t)},o.Control.Scale=o.Control.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0,updateWhenIdle:!1},onAdd:function(t){this._map=t;var e="leaflet-control-scale",i=o.DomUtil.create("div",e),n=this.options;return this._addScales(n,e,i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=o.DomUtil.create("div",e+"-line",i)),t.imperial&&(this._iScale=o.DomUtil.create("div",e+"-line",i))},_update:function(){var t=this._map.getBounds(),e=t.getCenter().lat,i=6378137*Math.PI*Math.cos(e*Math.PI/180),n=i*(t.getNorthEast().lng-t.getSouthWest().lng)/180,o=this._map.getSize(),s=this.options,a=0;o.x>0&&(a=n*(s.maxWidth/o.x)),this._updateScales(s,a)},_updateScales:function(t,e){t.metric&&e&&this._updateMetric(e),t.imperial&&e&&this._updateImperial(e)},_updateMetric:function(t){var e=this._getRoundNum(t);this._mScale.style.width=this._getScaleWidth(e/t)+"px",this._mScale.innerHTML=1e3>e?e+" m":e/1e3+" km"},_updateImperial:function(t){var e,i,n,o=3.2808399*t,s=this._iScale;o>5280?(e=o/5280,i=this._getRoundNum(e),s.style.width=this._getScaleWidth(i/e)+"px",s.innerHTML=i+" mi"):(n=this._getRoundNum(o),s.style.width=this._getScaleWidth(n/o)+"px",s.innerHTML=n+" ft")},_getScaleWidth:function(t){return Math.round(this.options.maxWidth*t)-10},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),i=t/e;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:1,e*i}}),o.control.scale=function(t){return new o.Control.Scale(t)},o.Control.Layers=o.Control.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0},initialize:function(t,e,i){o.setOptions(this,i),this._layers={},this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){return this._initLayout(),this._update(),t.on("layeradd",this._onLayerChange,this).on("layerremove",this._onLayerChange,this),this._container},onRemove:function(t){t.off("layeradd",this._onLayerChange).off("layerremove",this._onLayerChange)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._update(),this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._update(),this},removeLayer:function(t){var e=o.stamp(t);return delete this._layers[e],this._update(),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=o.DomUtil.create("div",t);e.setAttribute("aria-haspopup",!0),o.Browser.touch?o.DomEvent.on(e,"click",o.DomEvent.stopPropagation):(o.DomEvent.disableClickPropagation(e),o.DomEvent.on(e,"mousewheel",o.DomEvent.stopPropagation));var i=this._form=o.DomUtil.create("form",t+"-list");if(this.options.collapsed){o.Browser.android||o.DomEvent.on(e,"mouseover",this._expand,this).on(e,"mouseout",this._collapse,this);var n=this._layersLink=o.DomUtil.create("a",t+"-toggle",e);n.href="#",n.title="Layers",o.Browser.touch?o.DomEvent.on(n,"click",o.DomEvent.stop).on(n,"click",this._expand,this):o.DomEvent.on(n,"focus",this._expand,this),this._map.on("click",this._collapse,this)}else this._expand();this._baseLayersList=o.DomUtil.create("div",t+"-base",i),this._separator=o.DomUtil.create("div",t+"-separator",i),this._overlaysList=o.DomUtil.create("div",t+"-overlays",i),e.appendChild(i)},_addLayer:function(t,e,i){var n=o.stamp(t);this._layers[n]={layer:t,name:e,overlay:i},this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex))},_update:function(){if(this._container){this._baseLayersList.innerHTML="",this._overlaysList.innerHTML="";var t,e,i=!1,n=!1;for(t in this._layers)e=this._layers[t],this._addItem(e),n=n||e.overlay,i=i||!e.overlay;this._separator.style.display=n&&i?"":"none"}},_onLayerChange:function(t){var e=this._layers[o.stamp(t.layer)];if(e){this._handlingClick||this._update();var i=e.overlay?"layeradd"===t.type?"overlayadd":"overlayremove":"layeradd"===t.type?"baselayerchange":null;i&&this._map.fire(i,e)}},_createRadioElement:function(t,i){var n='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"';i&&(n+=' checked="checked"'),n+="/>";var o=e.createElement("div");return o.innerHTML=n,o.firstChild},_addItem:function(t){var i,n=e.createElement("label"),s=this._map.hasLayer(t.layer);t.overlay?(i=e.createElement("input"),i.type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=s):i=this._createRadioElement("leaflet-base-layers",s),i.layerId=o.stamp(t.layer),o.DomEvent.on(i,"click",this._onInputClick,this);var a=e.createElement("span");a.innerHTML=" "+t.name,n.appendChild(i),n.appendChild(a);var r=t.overlay?this._overlaysList:this._baseLayersList;return r.appendChild(n),n},_onInputClick:function(){var t,e,i,n=this._form.getElementsByTagName("input"),o=n.length;for(this._handlingClick=!0,t=0;o>t;t++)e=n[t],i=this._layers[e.layerId],e.checked&&!this._map.hasLayer(i.layer)?this._map.addLayer(i.layer):!e.checked&&this._map.hasLayer(i.layer)&&this._map.removeLayer(i.layer);this._handlingClick=!1},_expand:function(){o.DomUtil.addClass(this._container,"leaflet-control-layers-expanded")},_collapse:function(){this._container.className=this._container.className.replace(" leaflet-control-layers-expanded","")}}),o.control.layers=function(t,e,i){return new o.Control.Layers(t,e,i)},o.PosAnimation=o.Class.extend({includes:o.Mixin.Events,run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._newPos=e,this.fire("start"),t.style[o.DomUtil.TRANSITION]="all "+(i||.25)+"s cubic-bezier(0,0,"+(n||.5)+",1)",o.DomEvent.on(t,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),o.DomUtil.setPosition(t,e),o.Util.falseFn(t.offsetWidth),this._stepTimer=setInterval(o.bind(this._onStep,this),50)},stop:function(){this._inProgress&&(o.DomUtil.setPosition(this._el,this._getPos()),this._onTransitionEnd(),o.Util.falseFn(this._el.offsetWidth))},_onStep:function(){var t=this._getPos();return t?(this._el._leaflet_pos=t,this.fire("step"),void 0):(this._onTransitionEnd(),void 0)},_transformRe:/([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,_getPos:function(){var e,i,n,s=this._el,a=t.getComputedStyle(s);if(o.Browser.any3d){if(n=a[o.DomUtil.TRANSFORM].match(this._transformRe),!n)return;e=parseFloat(n[1]),i=parseFloat(n[2])}else e=parseFloat(a.left),i=parseFloat(a.top);return new o.Point(e,i,!0)},_onTransitionEnd:function(){o.DomEvent.off(this._el,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),this._inProgress&&(this._inProgress=!1,this._el.style[o.DomUtil.TRANSITION]="",this._el._leaflet_pos=this._newPos,clearInterval(this._stepTimer),this.fire("step").fire("end"))}}),o.Map.include({setView:function(t,e,n){if(e=this._limitZoom(e),t=o.latLng(t),n=n||{},this._panAnim&&this._panAnim.stop(),this._loaded&&!n.reset&&n!==!0){n.animate!==i&&(n.zoom=o.extend({animate:n.animate},n.zoom),n.pan=o.extend({animate:n.animate},n.pan));var s=this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan);if(s)return clearTimeout(this._sizeTimer),this}return this._resetView(t,e),this},panBy:function(t,e){if(t=o.point(t).round(),e=e||{},!t.x&&!t.y)return this;if(this._panAnim||(this._panAnim=new o.PosAnimation,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),e.animate!==!1){o.DomUtil.addClass(this._mapPane,"leaflet-pan-anim");var i=this._getMapPanePos().subtract(t);this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){o.DomUtil.removeClass(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){var i=this._getCenterOffset(t)._floor();return(e&&e.animate)===!0||this.getSize().contains(i)?(this.panBy(i,e),!0):!1}}),o.PosAnimation=o.DomUtil.TRANSITION?o.PosAnimation:o.PosAnimation.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=o.DomUtil.getPosition(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(),this._complete())},_animate:function(){this._animId=o.Util.requestAnimFrame(this._animate,this),this._step()},_step:function(){var t=+new Date-this._startTime,e=1e3*this._duration;e>t?this._runFrame(this._easeOut(t/e)):(this._runFrame(1),this._complete())},_runFrame:function(t){var e=this._startPos.add(this._offset.multiplyBy(t));o.DomUtil.setPosition(this._el,e),this.fire("step")},_complete:function(){o.Util.cancelAnimFrame(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),o.Map.mergeOptions({zoomAnimation:!0,zoomAnimationThreshold:4}),o.DomUtil.TRANSITION&&o.Map.addInitHook(function(){this._zoomAnimated=this.options.zoomAnimation&&o.DomUtil.TRANSITION&&o.Browser.any3d&&!o.Browser.android23&&!o.Browser.mobileOpera,this._zoomAnimated&&o.DomEvent.on(this._mapPane,o.DomUtil.TRANSITION_END,this._catchTransitionEnd,this)}),o.Map.include(o.DomUtil.TRANSITION?{_catchTransitionEnd:function(){this._animatingZoom&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(this._animatingZoom)return!0;if(i=i||{},!this._zoomAnimated||i.animate===!1||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),o=this._getCenterOffset(t)._divideBy(1-1/n),s=this._getCenterLayerPoint()._add(o);return i.animate===!0||this.getSize().contains(o)?(this.fire("movestart").fire("zoomstart"),this._animateZoom(t,e,s,n,null,!0),!0):!1},_animateZoom:function(t,e,i,n,s,a){this._animatingZoom=!0,o.DomUtil.addClass(this._mapPane,"leaflet-zoom-anim"),this._animateToCenter=t,this._animateToZoom=e,o.Draggable&&(o.Draggable._disabled=!0),this.fire("zoomanim",{center:t,zoom:e,origin:i,scale:n,delta:s,backwards:a})},_onZoomTransitionEnd:function(){this._animatingZoom=!1,o.DomUtil.removeClass(this._mapPane,"leaflet-zoom-anim"),this._resetView(this._animateToCenter,this._animateToZoom,!0,!0),o.Draggable&&(o.Draggable._disabled=!1)}}:{}),o.TileLayer.include({_animateZoom:function(t){this._animating||(this._animating=!0,this._prepareBgBuffer());var e=this._bgBuffer,i=o.DomUtil.TRANSFORM,n=t.delta?o.DomUtil.getTranslateString(t.delta):e.style[i],s=o.DomUtil.getScaleString(t.scale,t.origin);e.style[i]=t.backwards?s+" "+n:n+" "+s},_endZoomAnim:function(){var t=this._tileContainer,e=this._bgBuffer;t.style.visibility="",t.parentNode.appendChild(t),o.Util.falseFn(e.offsetWidth),this._animating=!1},_clearBgBuffer:function(){var t=this._map;!t||t._animatingZoom||t.touchZoom._zooming||(this._bgBuffer.innerHTML="",this._bgBuffer.style[o.DomUtil.TRANSFORM]="")},_prepareBgBuffer:function(){var t=this._tileContainer,e=this._bgBuffer,i=this._getLoadedTilesPercentage(e),n=this._getLoadedTilesPercentage(t);return e&&i>.5&&.5>n?(t.style.visibility="hidden",this._stopLoadingImages(t),void 0):(e.style.visibility="hidden",e.style[o.DomUtil.TRANSFORM]="",this._tileContainer=e,e=this._bgBuffer=t,this._stopLoadingImages(e),clearTimeout(this._clearBgBufferTimer),void 0)},_getLoadedTilesPercentage:function(t){var e,i,n=t.getElementsByTagName("img"),o=0;for(e=0,i=n.length;i>e;e++)n[e].complete&&o++;return o/i},_stopLoadingImages:function(t){var e,i,n,s=Array.prototype.slice.call(t.getElementsByTagName("img"));for(e=0,i=s.length;i>e;e++)n=s[e],n.complete||(n.onload=o.Util.falseFn,n.onerror=o.Util.falseFn,n.src=o.Util.emptyImageUrl,n.parentNode.removeChild(n))}}),o.Map.include({_defaultLocateOptions:{watch:!1,setView:!1,maxZoom:1/0,timeout:1e4,maximumAge:0,enableHighAccuracy:!1},locate:function(t){if(t=this._locateOptions=o.extend(this._defaultLocateOptions,t),!navigator.geolocation)return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var e=o.bind(this._handleGeolocationResponse,this),i=o.bind(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e=t.code,i=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+i+"."})},_handleGeolocationResponse:function(t){var e=t.coords.latitude,i=t.coords.longitude,n=new o.LatLng(e,i),s=180*t.coords.accuracy/40075017,a=s/Math.cos(o.LatLng.DEG_TO_RAD*e),r=o.latLngBounds([e-s,i-a],[e+s,i+a]),h=this._locateOptions;if(h.setView){var l=Math.min(this.getBoundsZoom(r),h.maxZoom);this.setView(n,l)}var u={latlng:n,bounds:r};for(var c in t.coords)"number"==typeof t.coords[c]&&(u[c]=t.coords[c]);this.fire("locationfound",u)}})}(window,document);
\ No newline at end of file
+!function(t,e,i){var n=t.L,o={};o.version="0.7.3","object"==typeof module&&"object"==typeof module.exports?module.exports=o:"function"==typeof define&&define.amd&&define(o),o.noConflict=function(){return t.L=n,this},t.L=o,o.Util={extend:function(t){var e,i,n,o,s=Array.prototype.slice.call(arguments,1);for(i=0,n=s.length;n>i;i++){o=s[i]||{};for(e in o)o.hasOwnProperty(e)&&(t[e]=o[e])}return t},bind:function(t,e){var i=arguments.length>2?Array.prototype.slice.call(arguments,2):null;return function(){return t.apply(e,i||arguments)}},stamp:function(){var t=0,e="_leaflet_id";return function(i){return i[e]=i[e]||++t,i[e]}}(),invokeEach:function(t,e,i){var n,o;if("object"==typeof t){o=Array.prototype.slice.call(arguments,3);for(n in t)e.apply(i,[n,t[n]].concat(o));return!0}return!1},limitExecByInterval:function(t,e,i){var n,o;return function s(){var a=arguments;return n?void(o=!0):(n=!0,setTimeout(function(){n=!1,o&&(s.apply(i,a),o=!1)},e),void t.apply(i,a))}},falseFn:function(){return!1},formatNum:function(t,e){var i=Math.pow(10,e||5);return Math.round(t*i)/i},trim:function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")},splitWords:function(t){return o.Util.trim(t).split(/\s+/)},setOptions:function(t,e){return t.options=o.extend({},t.options,e),t.options},getParamString:function(t,e,i){var n=[];for(var o in t)n.push(encodeURIComponent(i?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(e&&-1!==e.indexOf("?")?"&":"?")+n.join("&")},template:function(t,e){return t.replace(/\{ *([\w_]+) *\}/g,function(t,n){var o=e[n];if(o===i)throw new Error("No value provided for variable "+t);return"function"==typeof o&&(o=o(e)),o})},isArray:Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="},function(){function e(e){var i,n,o=["webkit","moz","o","ms"];for(i=0;i<o.length&&!n;i++)n=t[o[i]+e];return n}function i(e){var i=+new Date,o=Math.max(0,16-(i-n));return n=i+o,t.setTimeout(e,o)}var n=0,s=t.requestAnimationFrame||e("RequestAnimationFrame")||i,a=t.cancelAnimationFrame||e("CancelAnimationFrame")||e("CancelRequestAnimationFrame")||function(e){t.clearTimeout(e)};o.Util.requestAnimFrame=function(e,n,a,r){return e=o.bind(e,n),a&&s===i?void e():s.call(t,e,r)},o.Util.cancelAnimFrame=function(e){e&&a.call(t,e)}}(),o.extend=o.Util.extend,o.bind=o.Util.bind,o.stamp=o.Util.stamp,o.setOptions=o.Util.setOptions,o.Class=function(){},o.Class.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this._initHooks&&this.callInitHooks()},i=function(){};i.prototype=this.prototype;var n=new i;n.constructor=e,e.prototype=n;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&(e[s]=this[s]);t.statics&&(o.extend(e,t.statics),delete t.statics),t.includes&&(o.Util.extend.apply(null,[n].concat(t.includes)),delete t.includes),t.options&&n.options&&(t.options=o.extend({},n.options,t.options)),o.extend(n,t),n._initHooks=[];var a=this;return e.__super__=a.prototype,n.callInitHooks=function(){if(!this._initHooksCalled){a.prototype.callInitHooks&&a.prototype.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=n._initHooks.length;e>t;t++)n._initHooks[t].call(this)}},e},o.Class.include=function(t){o.extend(this.prototype,t)},o.Class.mergeOptions=function(t){o.extend(this.prototype.options,t)},o.Class.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i)};var s="_leaflet_events";o.Mixin={},o.Mixin.Events={addEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d=this[s]=this[s]||{},p=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)r={action:e,context:i||this},h=t[n],p?(l=h+"_idx",u=l+"_len",c=d[l]=d[l]||{},c[p]||(c[p]=[],d[u]=(d[u]||0)+1),c[p].push(r)):(d[h]=d[h]||[],d[h].push(r));return this},hasEventListeners:function(t){var e=this[s];return!!e&&(t in e&&e[t].length>0||t+"_idx"in e&&e[t+"_idx_len"]>0)},removeEventListener:function(t,e,i){if(!this[s])return this;if(!t)return this.clearAllEventListeners();if(o.Util.invokeEach(t,this.removeEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d,p,_=this[s],m=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)if(r=t[n],u=r+"_idx",c=u+"_len",d=_[u],e){if(h=m&&d?d[m]:_[r]){for(l=h.length-1;l>=0;l--)h[l].action!==e||i&&h[l].context!==i||(p=h.splice(l,1),p[0].action=o.Util.falseFn);i&&d&&0===h.length&&(delete d[m],_[c]--)}}else delete _[r],delete _[u],delete _[c];return this},clearAllEventListeners:function(){return delete this[s],this},fireEvent:function(t,e){if(!this.hasEventListeners(t))return this;var i,n,a,r,h,l=o.Util.extend({},e,{type:t,target:this}),u=this[s];if(u[t])for(i=u[t].slice(),n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);r=u[t+"_idx"];for(h in r)if(i=r[h].slice())for(n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);return this},addOneTimeEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addOneTimeEventListener,this,e,i))return this;var n=o.bind(function(){this.removeEventListener(t,e,i).removeEventListener(t,n,i)},this);return this.addEventListener(t,e,i).addEventListener(t,n,i)}},o.Mixin.Events.on=o.Mixin.Events.addEventListener,o.Mixin.Events.off=o.Mixin.Events.removeEventListener,o.Mixin.Events.once=o.Mixin.Events.addOneTimeEventListener,o.Mixin.Events.fire=o.Mixin.Events.fireEvent,function(){var n="ActiveXObject"in t,s=n&&!e.addEventListener,a=navigator.userAgent.toLowerCase(),r=-1!==a.indexOf("webkit"),h=-1!==a.indexOf("chrome"),l=-1!==a.indexOf("phantom"),u=-1!==a.indexOf("android"),c=-1!==a.search("android [23]"),d=-1!==a.indexOf("gecko"),p=typeof orientation!=i+"",_=t.navigator&&t.navigator.msPointerEnabled&&t.navigator.msMaxTouchPoints&&!t.PointerEvent,m=t.PointerEvent&&t.navigator.pointerEnabled&&t.navigator.maxTouchPoints||_,f="devicePixelRatio"in t&&t.devicePixelRatio>1||"matchMedia"in t&&t.matchMedia("(min-resolution:144dpi)")&&t.matchMedia("(min-resolution:144dpi)").matches,g=e.documentElement,v=n&&"transition"in g.style,y="WebKitCSSMatrix"in t&&"m11"in new t.WebKitCSSMatrix&&!c,P="MozPerspective"in g.style,L="OTransition"in g.style,x=!t.L_DISABLE_3D&&(v||y||P||L)&&!l,w=!t.L_NO_TOUCH&&!l&&function(){var t="ontouchstart";if(m||t in g)return!0;var i=e.createElement("div"),n=!1;return i.setAttribute?(i.setAttribute(t,"return;"),"function"==typeof i[t]&&(n=!0),i.removeAttribute(t),i=null,n):!1}();o.Browser={ie:n,ielt9:s,webkit:r,gecko:d&&!r&&!t.opera&&!n,android:u,android23:c,chrome:h,ie3d:v,webkit3d:y,gecko3d:P,opera3d:L,any3d:x,mobile:p,mobileWebkit:p&&r,mobileWebkit3d:p&&y,mobileOpera:p&&t.opera,touch:w,msPointer:_,pointer:m,retina:f}}(),o.Point=function(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e},o.Point.prototype={clone:function(){return new o.Point(this.x,this.y)},add:function(t){return this.clone()._add(o.point(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(o.point(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},distanceTo:function(t){t=o.point(t);var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},equals:function(t){return t=o.point(t),t.x===this.x&&t.y===this.y},contains:function(t){return t=o.point(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+o.Util.formatNum(this.x)+", "+o.Util.formatNum(this.y)+")"}},o.point=function(t,e,n){return t instanceof o.Point?t:o.Util.isArray(t)?new o.Point(t[0],t[1]):t===i||null===t?t:new o.Point(t,e,n)},o.Bounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.Bounds.prototype={extend:function(t){return t=o.point(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new o.Point((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new o.Point(this.min.x,this.max.y)},getTopRight:function(){return new o.Point(this.max.x,this.min.y)},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return t="number"==typeof t[0]||t instanceof o.Point?o.point(t):o.bounds(t),t instanceof o.Bounds?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,a=s.x>=e.x&&n.x<=i.x,r=s.y>=e.y&&n.y<=i.y;return a&&r},isValid:function(){return!(!this.min||!this.max)}},o.bounds=function(t,e){return!t||t instanceof o.Bounds?t:new o.Bounds(t,e)},o.Transformation=function(t,e,i,n){this._a=t,this._b=e,this._c=i,this._d=n},o.Transformation.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return e=e||1,t.x=e*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return e=e||1,new o.Point((t.x/e-this._b)/this._a,(t.y/e-this._d)/this._c)}},o.DomUtil={get:function(t){return"string"==typeof t?e.getElementById(t):t},getStyle:function(t,i){var n=t.style[i];if(!n&&t.currentStyle&&(n=t.currentStyle[i]),(!n||"auto"===n)&&e.defaultView){var o=e.defaultView.getComputedStyle(t,null);n=o?o[i]:null}return"auto"===n?null:n},getViewportOffset:function(t){var i,n=0,s=0,a=t,r=e.body,h=e.documentElement;do{if(n+=a.offsetTop||0,s+=a.offsetLeft||0,n+=parseInt(o.DomUtil.getStyle(a,"borderTopWidth"),10)||0,s+=parseInt(o.DomUtil.getStyle(a,"borderLeftWidth"),10)||0,i=o.DomUtil.getStyle(a,"position"),a.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}if("relative"===i&&!a.offsetLeft){var l=o.DomUtil.getStyle(a,"width"),u=o.DomUtil.getStyle(a,"max-width"),c=a.getBoundingClientRect();("none"!==l||"none"!==u)&&(s+=c.left+a.clientLeft),n+=c.top+(r.scrollTop||h.scrollTop||0);break}a=a.offsetParent}while(a);a=t;do{if(a===r)break;n-=a.scrollTop||0,s-=a.scrollLeft||0,a=a.parentNode}while(a);return new o.Point(s,n)},documentIsLtr:function(){return o.DomUtil._docIsLtrCached||(o.DomUtil._docIsLtrCached=!0,o.DomUtil._docIsLtr="ltr"===o.DomUtil.getStyle(e.body,"direction")),o.DomUtil._docIsLtr},create:function(t,i,n){var o=e.createElement(t);return o.className=i,n&&n.appendChild(o),o},hasClass:function(t,e){if(t.classList!==i)return t.classList.contains(e);var n=o.DomUtil._getClass(t);return n.length>0&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(n)},addClass:function(t,e){if(t.classList!==i)for(var n=o.Util.splitWords(e),s=0,a=n.length;a>s;s++)t.classList.add(n[s]);else if(!o.DomUtil.hasClass(t,e)){var r=o.DomUtil._getClass(t);o.DomUtil._setClass(t,(r?r+" ":"")+e)}},removeClass:function(t,e){t.classList!==i?t.classList.remove(e):o.DomUtil._setClass(t,o.Util.trim((" "+o.DomUtil._getClass(t)+" ").replace(" "+e+" "," ")))},_setClass:function(t,e){t.className.baseVal===i?t.className=e:t.className.baseVal=e},_getClass:function(t){return t.className.baseVal===i?t.className:t.className.baseVal},setOpacity:function(t,e){if("opacity"in t.style)t.style.opacity=e;else if("filter"in t.style){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(o){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"}},testProp:function(t){for(var i=e.documentElement.style,n=0;n<t.length;n++)if(t[n]in i)return t[n];return!1},getTranslateString:function(t){var e=o.Browser.webkit3d,i="translate"+(e?"3d":"")+"(",n=(e?",0":"")+")";return i+t.x+"px,"+t.y+"px"+n},getScaleString:function(t,e){var i=o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1*t))),n=" scale("+t+") ";return i+n},setPosition:function(t,e,i){t._leaflet_pos=e,!i&&o.Browser.any3d?t.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(e):(t.style.left=e.x+"px",t.style.top=e.y+"px")},getPosition:function(t){return t._leaflet_pos}},o.DomUtil.TRANSFORM=o.DomUtil.testProp(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),o.DomUtil.TRANSITION=o.DomUtil.testProp(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),o.DomUtil.TRANSITION_END="webkitTransition"===o.DomUtil.TRANSITION||"OTransition"===o.DomUtil.TRANSITION?o.DomUtil.TRANSITION+"End":"transitionend",function(){if("onselectstart"in e)o.extend(o.DomUtil,{disableTextSelection:function(){o.DomEvent.on(t,"selectstart",o.DomEvent.preventDefault)},enableTextSelection:function(){o.DomEvent.off(t,"selectstart",o.DomEvent.preventDefault)}});else{var i=o.DomUtil.testProp(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);o.extend(o.DomUtil,{disableTextSelection:function(){if(i){var t=e.documentElement.style;this._userSelect=t[i],t[i]="none"}},enableTextSelection:function(){i&&(e.documentElement.style[i]=this._userSelect,delete this._userSelect)}})}o.extend(o.DomUtil,{disableImageDrag:function(){o.DomEvent.on(t,"dragstart",o.DomEvent.preventDefault)},enableImageDrag:function(){o.DomEvent.off(t,"dragstart",o.DomEvent.preventDefault)}})}(),o.LatLng=function(t,e,n){if(t=parseFloat(t),e=parseFloat(e),isNaN(t)||isNaN(e))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=t,this.lng=e,n!==i&&(this.alt=parseFloat(n))},o.extend(o.LatLng,{DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,MAX_MARGIN:1e-9}),o.LatLng.prototype={equals:function(t){if(!t)return!1;t=o.latLng(t);var e=Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng));return e<=o.LatLng.MAX_MARGIN},toString:function(t){return"LatLng("+o.Util.formatNum(this.lat,t)+", "+o.Util.formatNum(this.lng,t)+")"},distanceTo:function(t){t=o.latLng(t);var e=6378137,i=o.LatLng.DEG_TO_RAD,n=(t.lat-this.lat)*i,s=(t.lng-this.lng)*i,a=this.lat*i,r=t.lat*i,h=Math.sin(n/2),l=Math.sin(s/2),u=h*h+l*l*Math.cos(a)*Math.cos(r);return 2*e*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))},wrap:function(t,e){var i=this.lng;return t=t||-180,e=e||180,i=(i+e)%(e-t)+(t>i||i===e?e:t),new o.LatLng(this.lat,i)}},o.latLng=function(t,e){return t instanceof o.LatLng?t:o.Util.isArray(t)?"number"==typeof t[0]||"string"==typeof t[0]?new o.LatLng(t[0],t[1],t[2]):null:t===i||null===t?t:"object"==typeof t&&"lat"in t?new o.LatLng(t.lat,"lng"in t?t.lng:t.lon):e===i?null:new o.LatLng(t,e)},o.LatLngBounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.LatLngBounds.prototype={extend:function(t){if(!t)return this;var e=o.latLng(t);return t=null!==e?e:o.latLngBounds(t),t instanceof o.LatLng?this._southWest||this._northEast?(this._southWest.lat=Math.min(t.lat,this._southWest.lat),this._southWest.lng=Math.min(t.lng,this._southWest.lng),this._northEast.lat=Math.max(t.lat,this._northEast.lat),this._northEast.lng=Math.max(t.lng,this._northEast.lng)):(this._southWest=new o.LatLng(t.lat,t.lng),this._northEast=new o.LatLng(t.lat,t.lng)):t instanceof o.LatLngBounds&&(this.extend(t._southWest),this.extend(t._northEast)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,s=Math.abs(e.lng-i.lng)*t;return new o.LatLngBounds(new o.LatLng(e.lat-n,e.lng-s),new o.LatLng(i.lat+n,i.lng+s))},getCenter:function(){return new o.LatLng((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new o.LatLng(this.getNorth(),this.getWest())},getSouthEast:function(){return new o.LatLng(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t);var e,i,n=this._southWest,s=this._northEast;return t instanceof o.LatLngBounds?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=s.lat&&e.lng>=n.lng&&i.lng<=s.lng},intersects:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),a=s.lat>=e.lat&&n.lat<=i.lat,r=s.lng>=e.lng&&n.lng<=i.lng;return a&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t){return t?(t=o.latLngBounds(t),this._southWest.equals(t.getSouthWest())&&this._northEast.equals(t.getNorthEast())):!1},isValid:function(){return!(!this._southWest||!this._northEast)}},o.latLngBounds=function(t,e){return!t||t instanceof o.LatLngBounds?t:new o.LatLngBounds(t,e)},o.Projection={},o.Projection.SphericalMercator={MAX_LATITUDE:85.0511287798,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=t.lng*e,a=n*e;return a=Math.log(Math.tan(Math.PI/4+a/2)),new o.Point(s,a)},unproject:function(t){var e=o.LatLng.RAD_TO_DEG,i=t.x*e,n=(2*Math.atan(Math.exp(t.y))-Math.PI/2)*e;return new o.LatLng(n,i)}},o.Projection.LonLat={project:function(t){return new o.Point(t.lng,t.lat)},unproject:function(t){return new o.LatLng(t.y,t.x)}},o.CRS={latLngToPoint:function(t,e){var i=this.projection.project(t),n=this.scale(e);return this.transformation._transform(i,n)},pointToLatLng:function(t,e){var i=this.scale(e),n=this.transformation.untransform(t,i);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},scale:function(t){return 256*Math.pow(2,t)},getSize:function(t){var e=this.scale(t);return o.point(e,e)}},o.CRS.Simple=o.extend({},o.CRS,{projection:o.Projection.LonLat,transformation:new o.Transformation(1,0,-1,0),scale:function(t){return Math.pow(2,t)}}),o.CRS.EPSG3857=o.extend({},o.CRS,{code:"EPSG:3857",projection:o.Projection.SphericalMercator,transformation:new o.Transformation(.5/Math.PI,.5,-.5/Math.PI,.5),project:function(t){var e=this.projection.project(t),i=6378137;return e.multiplyBy(i)}}),o.CRS.EPSG900913=o.extend({},o.CRS.EPSG3857,{code:"EPSG:900913"}),o.CRS.EPSG4326=o.extend({},o.CRS,{code:"EPSG:4326",projection:o.Projection.LonLat,transformation:new o.Transformation(1/360,.5,-1/360,.5)}),o.Map=o.Class.extend({includes:o.Mixin.Events,options:{crs:o.CRS.EPSG3857,fadeAnimation:o.DomUtil.TRANSITION&&!o.Browser.android23,trackResize:!0,markerZoomAnimation:o.DomUtil.TRANSITION&&o.Browser.any3d},initialize:function(t,e){e=o.setOptions(this,e),this._initContainer(t),this._initLayout(),this._onResize=o.bind(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),e.center&&e.zoom!==i&&this.setView(o.latLng(e.center),e.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._tileLayersNum=0,this.callInitHooks(),this._addLayers(e.layers)},setView:function(t,e){return e=e===i?this.getZoom():e,this._resetView(o.latLng(t),this._limitZoom(e)),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=this._limitZoom(t),this)},zoomIn:function(t,e){return this.setZoom(this._zoom+(t||1),e)},zoomOut:function(t,e){return this.setZoom(this._zoom-(t||1),e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),s=this.getSize().divideBy(2),a=t instanceof o.Point?t:this.latLngToContainerPoint(t),r=a.subtract(s).multiplyBy(1-1/n),h=this.containerPointToLatLng(s.add(r));return this.setView(h,e,{zoom:i})},fitBounds:function(t,e){e=e||{},t=t.getBounds?t.getBounds():o.latLngBounds(t);var i=o.point(e.paddingTopLeft||e.padding||[0,0]),n=o.point(e.paddingBottomRight||e.padding||[0,0]),s=this.getBoundsZoom(t,!1,i.add(n)),a=n.subtract(i).divideBy(2),r=this.project(t.getSouthWest(),s),h=this.project(t.getNorthEast(),s),l=this.unproject(r.add(h).divideBy(2).add(a),s);return s=e&&e.maxZoom?Math.min(e.maxZoom,s):s,this.setView(l,s,e)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t){return this.fire("movestart"),this._rawPanBy(o.point(t)),this.fire("move"),this.fire("moveend")},setMaxBounds:function(t){return t=o.latLngBounds(t),this.options.maxBounds=t,t?(this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds,this)):this.off("moveend",this._panInsideMaxBounds,this)},panInsideBounds:function(t,e){var i=this.getCenter(),n=this._limitCenter(i,this._zoom,t);return i.equals(n)?this:this.panTo(n,e)},addLayer:function(t){var e=o.stamp(t);return this._layers[e]?this:(this._layers[e]=t,!t.options||isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[e]=t,this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum++,this._tileLayersToLoad++,t.on("load",this._onTileLayerLoad,this)),this._loaded&&this._layerAdd(t),this)},removeLayer:function(t){var e=o.stamp(t);return this._layers[e]?(this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&this.fire("layerremove",{layer:t}),this._zoomBoundLayers[e]&&(delete this._zoomBoundLayers[e],this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum--,this._tileLayersToLoad--,t.off("load",this._onTileLayerLoad,this)),this):this},hasLayer:function(t){return t?o.stamp(t)in this._layers:!1},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},invalidateSize:function(t){if(!this._loaded)return this;t=o.extend({animate:!1,pan:!0},t===!0?{animate:!0}:t);var e=this.getSize();this._sizeChanged=!0,this._initialCenter=null;var i=this.getSize(),n=e.divideBy(2).round(),s=i.divideBy(2).round(),a=n.subtract(s);return a.x||a.y?(t.animate&&t.pan?this.panBy(a):(t.pan&&this._rawPanBy(a),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o.bind(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:e,newSize:i})):this},addHandler:function(t,e){if(!e)return this;var i=this[t]=new e(this);return this._handlers.push(i),this.options[t]&&i.enable(),this},remove:function(){this._loaded&&this.fire("unload"),this._initEvents("off");try{delete this._container._leaflet}catch(t){this._container._leaflet=i}return this._clearPanes(),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this},getCenter:function(){return this._checkIfLoaded(),this._initialCenter&&!this._moved()?this._initialCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds(),e=this.unproject(t.getBottomLeft()),i=this.unproject(t.getTopRight());return new o.LatLngBounds(e,i)},getMinZoom:function(){return this.options.minZoom===i?this._layersMinZoom===i?0:this._layersMinZoom:this.options.minZoom},getMaxZoom:function(){return this.options.maxZoom===i?this._layersMaxZoom===i?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=o.latLngBounds(t);var n,s=this.getMinZoom()-(e?1:0),a=this.getMaxZoom(),r=this.getSize(),h=t.getNorthWest(),l=t.getSouthEast(),u=!0;i=o.point(i||[0,0]);do s++,n=this.project(l,s).subtract(this.project(h,s)).add(i),u=e?n.x<r.x||n.y<r.y:r.contains(n);while(u&&a>=s);return u&&e?null:e?s:s-1},getSize:function(){return(!this._size||this._sizeChanged)&&(this._size=new o.Point(this._container.clientWidth,this._container.clientHeight),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(){var t=this._getTopLeftPoint();return new o.Bounds(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._initialTopLeftPoint},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t){var e=this.options.crs;return e.scale(t)/e.scale(this._zoom)},getScaleZoom:function(t){return this._zoom+Math.log(t)/Math.LN2},project:function(t,e){return e=e===i?this._zoom:e,this.options.crs.latLngToPoint(o.latLng(t),e)},unproject:function(t,e){return e=e===i?this._zoom:e,this.options.crs.pointToLatLng(o.point(t),e)},layerPointToLatLng:function(t){var e=o.point(t).add(this.getPixelOrigin());return this.unproject(e)},latLngToLayerPoint:function(t){var e=this.project(o.latLng(t))._round();return e._subtract(this.getPixelOrigin())},containerPointToLayerPoint:function(t){return o.point(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return o.point(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var e=this.containerPointToLayerPoint(o.point(t));return this.layerPointToLatLng(e)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))},mouseEventToContainerPoint:function(t){return o.DomEvent.getMousePosition(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var e=this._container=o.DomUtil.get(t);if(!e)throw new Error("Map container not found.");if(e._leaflet)throw new Error("Map container is already initialized.");e._leaflet=!0},_initLayout:function(){var t=this._container;o.DomUtil.addClass(t,"leaflet-container"+(o.Browser.touch?" leaflet-touch":"")+(o.Browser.retina?" leaflet-retina":"")+(o.Browser.ielt9?" leaflet-oldie":"")+(this.options.fadeAnimation?" leaflet-fade-anim":""));var e=o.DomUtil.getStyle(t,"position");"absolute"!==e&&"relative"!==e&&"fixed"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._mapPane=t.mapPane=this._createPane("leaflet-map-pane",this._container),this._tilePane=t.tilePane=this._createPane("leaflet-tile-pane",this._mapPane),t.objectsPane=this._createPane("leaflet-objects-pane",this._mapPane),t.shadowPane=this._createPane("leaflet-shadow-pane"),t.overlayPane=this._createPane("leaflet-overlay-pane"),t.markerPane=this._createPane("leaflet-marker-pane"),t.popupPane=this._createPane("leaflet-popup-pane");var e=" leaflet-zoom-hide";this.options.markerZoomAnimation||(o.DomUtil.addClass(t.markerPane,e),o.DomUtil.addClass(t.shadowPane,e),o.DomUtil.addClass(t.popupPane,e))},_createPane:function(t,e){return o.DomUtil.create("div",t,e||this._panes.objectsPane)},_clearPanes:function(){this._container.removeChild(this._mapPane)},_addLayers:function(t){t=t?o.Util.isArray(t)?t:[t]:[];for(var e=0,i=t.length;i>e;e++)this.addLayer(t[e])},_resetView:function(t,e,i,n){var s=this._zoom!==e;n||(this.fire("movestart"),s&&this.fire("zoomstart")),this._zoom=e,this._initialCenter=t,this._initialTopLeftPoint=this._getNewTopLeftPoint(t),i?this._initialTopLeftPoint._add(this._getMapPanePos()):o.DomUtil.setPosition(this._mapPane,new o.Point(0,0)),this._tileLayersToLoad=this._tileLayersNum;var a=!this._loaded;this._loaded=!0,this.fire("viewreset",{hard:!i}),a&&(this.fire("load"),this.eachLayer(this._layerAdd,this)),this.fire("move"),(s||n)&&this.fire("zoomend"),this.fire("moveend",{hard:!i})},_rawPanBy:function(t){o.DomUtil.setPosition(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_updateZoomLevels:function(){var t,e=1/0,n=-1/0,o=this._getZoomSpan();for(t in this._zoomBoundLayers){var s=this._zoomBoundLayers[t];isNaN(s.options.minZoom)||(e=Math.min(e,s.options.minZoom)),isNaN(s.options.maxZoom)||(n=Math.max(n,s.options.maxZoom))}t===i?this._layersMaxZoom=this._layersMinZoom=i:(this._layersMaxZoom=n,this._layersMinZoom=e),o!==this._getZoomSpan()&&this.fire("zoomlevelschange")},_panInsideMaxBounds:function(){this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(e){if(o.DomEvent){e=e||"on",o.DomEvent[e](this._container,"click",this._onMouseClick,this);var i,n,s=["dblclick","mousedown","mouseup","mouseenter","mouseleave","mousemove","contextmenu"];for(i=0,n=s.length;n>i;i++)o.DomEvent[e](this._container,s[i],this._fireMouseEvent,this);this.options.trackResize&&o.DomEvent[e](t,"resize",this._onResize,this)}},_onResize:function(){o.Util.cancelAnimFrame(this._resizeRequest),this._resizeRequest=o.Util.requestAnimFrame(function(){this.invalidateSize({debounceMoveend:!0})},this,!1,this._container)},_onMouseClick:function(t){!this._loaded||!t._simulated&&(this.dragging&&this.dragging.moved()||this.boxZoom&&this.boxZoom.moved())||o.DomEvent._skipped(t)||(this.fire("preclick"),this._fireMouseEvent(t))},_fireMouseEvent:function(t){if(this._loaded&&!o.DomEvent._skipped(t)){var e=t.type;if(e="mouseenter"===e?"mouseover":"mouseleave"===e?"mouseout":e,this.hasEventListeners(e)){"contextmenu"===e&&o.DomEvent.preventDefault(t);var i=this.mouseEventToContainerPoint(t),n=this.containerPointToLayerPoint(i),s=this.layerPointToLatLng(n);this.fire(e,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t})}}},_onTileLayerLoad:function(){this._tileLayersToLoad--,this._tileLayersNum&&!this._tileLayersToLoad&&this.fire("tilelayersload")},_clearHandlers:function(){for(var t=0,e=this._handlers.length;e>t;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,this):this.on("load",t,e),this},_layerAdd:function(t){t.onAdd(this),this.fire("layeradd",{layer:t})},_getMapPanePos:function(){return o.DomUtil.getPosition(this._mapPane)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(){return this.getPixelOrigin().subtract(this._getMapPanePos())},_getNewTopLeftPoint:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._round()},_latLngToNewLayerPoint:function(t,e,i){var n=this._getNewTopLeftPoint(i,e).add(this._getMapPanePos());return this.project(t,e)._subtract(n)},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){if(!i)return t;var n=this.project(t,e),s=this.getSize().divideBy(2),a=new o.Bounds(n.subtract(s),n.add(s)),r=this._getBoundsOffset(a,i,e);return this.unproject(n.add(r),e)},_limitOffset:function(t,e){if(!e)return t;var i=this.getPixelBounds(),n=new o.Bounds(i.min.add(t),i.max.add(t));return t.add(this._getBoundsOffset(n,e))},_getBoundsOffset:function(t,e,i){var n=this.project(e.getNorthWest(),i).subtract(t.min),s=this.project(e.getSouthEast(),i).subtract(t.max),a=this._rebound(n.x,-s.x),r=this._rebound(n.y,-s.y);return new o.Point(a,r)},_rebound:function(t,e){return t+e>0?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom();return Math.max(e,Math.min(i,t))}}),o.map=function(t,e){return new o.Map(t,e)},o.Projection.Mercator={MAX_LATITUDE:85.0840591556,R_MINOR:6356752.314245179,R_MAJOR:6378137,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=this.R_MAJOR,a=this.R_MINOR,r=t.lng*e*s,h=n*e,l=a/s,u=Math.sqrt(1-l*l),c=u*Math.sin(h);c=Math.pow((1-c)/(1+c),.5*u);var d=Math.tan(.5*(.5*Math.PI-h))/c;return h=-s*Math.log(d),new o.Point(r,h)},unproject:function(t){for(var e,i=o.LatLng.RAD_TO_DEG,n=this.R_MAJOR,s=this.R_MINOR,a=t.x*i/n,r=s/n,h=Math.sqrt(1-r*r),l=Math.exp(-t.y/n),u=Math.PI/2-2*Math.atan(l),c=15,d=1e-7,p=c,_=.1;Math.abs(_)>d&&--p>0;)e=h*Math.sin(u),_=Math.PI/2-2*Math.atan(l*Math.pow((1-e)/(1+e),.5*h))-u,u+=_;
+return new o.LatLng(u*i,a)}},o.CRS.EPSG3395=o.extend({},o.CRS,{code:"EPSG:3395",projection:o.Projection.Mercator,transformation:function(){var t=o.Projection.Mercator,e=t.R_MAJOR,i=.5/(Math.PI*e);return new o.Transformation(i,.5,-i,.5)}()}),o.TileLayer=o.Class.extend({includes:o.Mixin.Events,options:{minZoom:0,maxZoom:18,tileSize:256,subdomains:"abc",errorTileUrl:"",attribution:"",zoomOffset:0,opacity:1,unloadInvisibleTiles:o.Browser.mobile,updateWhenIdle:o.Browser.mobile},initialize:function(t,e){e=o.setOptions(this,e),e.detectRetina&&o.Browser.retina&&e.maxZoom>0&&(e.tileSize=Math.floor(e.tileSize/2),e.zoomOffset++,e.minZoom>0&&e.minZoom--,this.options.maxZoom--),e.bounds&&(e.bounds=o.latLngBounds(e.bounds)),this._url=t;var i=this.options.subdomains;"string"==typeof i&&(this.options.subdomains=i.split(""))},onAdd:function(t){this._map=t,this._animated=t._zoomAnimated,this._initContainer(),t.on({viewreset:this._reset,moveend:this._update},this),this._animated&&t.on({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||(this._limitedUpdate=o.Util.limitExecByInterval(this._update,150,this),t.on("move",this._limitedUpdate,this)),this._reset(),this._update()},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this._container.parentNode.removeChild(this._container),t.off({viewreset:this._reset,moveend:this._update},this),this._animated&&t.off({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||t.off("move",this._limitedUpdate,this),this._container=null,this._map=null},bringToFront:function(){var t=this._map._panes.tilePane;return this._container&&(t.appendChild(this._container),this._setAutoZIndex(t,Math.max)),this},bringToBack:function(){var t=this._map._panes.tilePane;return this._container&&(t.insertBefore(this._container,t.firstChild),this._setAutoZIndex(t,Math.min)),this},getAttribution:function(){return this.options.attribution},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},setUrl:function(t,e){return this._url=t,e||this.redraw(),this},redraw:function(){return this._map&&(this._reset({hard:!0}),this._update()),this},_updateZIndex:function(){this._container&&this.options.zIndex!==i&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t,e){var i,n,o,s=t.children,a=-e(1/0,-1/0);for(n=0,o=s.length;o>n;n++)s[n]!==this._container&&(i=parseInt(s[n].style.zIndex,10),isNaN(i)||(a=e(a,i)));this.options.zIndex=this._container.style.zIndex=(isFinite(a)?a:0)+e(1,-1)},_updateOpacity:function(){var t,e=this._tiles;if(o.Browser.ielt9)for(t in e)o.DomUtil.setOpacity(e[t],this.options.opacity);else o.DomUtil.setOpacity(this._container,this.options.opacity)},_initContainer:function(){var t=this._map._panes.tilePane;if(!this._container){if(this._container=o.DomUtil.create("div","leaflet-layer"),this._updateZIndex(),this._animated){var e="leaflet-tile-container";this._bgBuffer=o.DomUtil.create("div",e,this._container),this._tileContainer=o.DomUtil.create("div",e,this._container)}else this._tileContainer=this._container;t.appendChild(this._container),this.options.opacity<1&&this._updateOpacity()}},_reset:function(t){for(var e in this._tiles)this.fire("tileunload",{tile:this._tiles[e]});this._tiles={},this._tilesToLoad=0,this.options.reuseTiles&&(this._unusedTiles=[]),this._tileContainer.innerHTML="",this._animated&&t&&t.hard&&this._clearBgBuffer(),this._initContainer()},_getTileSize:function(){var t=this._map,e=t.getZoom()+this.options.zoomOffset,i=this.options.maxNativeZoom,n=this.options.tileSize;return i&&e>i&&(n=Math.round(t.getZoomScale(e)/t.getZoomScale(i)*n)),n},_update:function(){if(this._map){var t=this._map,e=t.getPixelBounds(),i=t.getZoom(),n=this._getTileSize();if(!(i>this.options.maxZoom||i<this.options.minZoom)){var s=o.bounds(e.min.divideBy(n)._floor(),e.max.divideBy(n)._floor());this._addTilesFromCenterOut(s),(this.options.unloadInvisibleTiles||this.options.reuseTiles)&&this._removeOtherTiles(s)}}},_addTilesFromCenterOut:function(t){var i,n,s,a=[],r=t.getCenter();for(i=t.min.y;i<=t.max.y;i++)for(n=t.min.x;n<=t.max.x;n++)s=new o.Point(n,i),this._tileShouldBeLoaded(s)&&a.push(s);var h=a.length;if(0!==h){a.sort(function(t,e){return t.distanceTo(r)-e.distanceTo(r)});var l=e.createDocumentFragment();for(this._tilesToLoad||this.fire("loading"),this._tilesToLoad+=h,n=0;h>n;n++)this._addTile(a[n],l);this._tileContainer.appendChild(l)}},_tileShouldBeLoaded:function(t){if(t.x+":"+t.y in this._tiles)return!1;var e=this.options;if(!e.continuousWorld){var i=this._getWrapTileNum();if(e.noWrap&&(t.x<0||t.x>=i.x)||t.y<0||t.y>=i.y)return!1}if(e.bounds){var n=e.tileSize,o=t.multiplyBy(n),s=o.add([n,n]),a=this._map.unproject(o),r=this._map.unproject(s);if(e.continuousWorld||e.noWrap||(a=a.wrap(),r=r.wrap()),!e.bounds.intersects([a,r]))return!1}return!0},_removeOtherTiles:function(t){var e,i,n,o;for(o in this._tiles)e=o.split(":"),i=parseInt(e[0],10),n=parseInt(e[1],10),(i<t.min.x||i>t.max.x||n<t.min.y||n>t.max.y)&&this._removeTile(o)},_removeTile:function(t){var e=this._tiles[t];this.fire("tileunload",{tile:e,url:e.src}),this.options.reuseTiles?(o.DomUtil.removeClass(e,"leaflet-tile-loaded"),this._unusedTiles.push(e)):e.parentNode===this._tileContainer&&this._tileContainer.removeChild(e),o.Browser.android||(e.onload=null,e.src=o.Util.emptyImageUrl),delete this._tiles[t]},_addTile:function(t,e){var i=this._getTilePos(t),n=this._getTile();o.DomUtil.setPosition(n,i,o.Browser.chrome),this._tiles[t.x+":"+t.y]=n,this._loadTile(n,t),n.parentNode!==this._tileContainer&&e.appendChild(n)},_getZoomForUrl:function(){var t=this.options,e=this._map.getZoom();return t.zoomReverse&&(e=t.maxZoom-e),e+=t.zoomOffset,t.maxNativeZoom?Math.min(e,t.maxNativeZoom):e},_getTilePos:function(t){var e=this._map.getPixelOrigin(),i=this._getTileSize();return t.multiplyBy(i).subtract(e)},getTileUrl:function(t){return o.Util.template(this._url,o.extend({s:this._getSubdomain(t),z:t.z,x:t.x,y:t.y},this.options))},_getWrapTileNum:function(){var t=this._map.options.crs,e=t.getSize(this._map.getZoom());return e.divideBy(this._getTileSize())._floor()},_adjustTilePoint:function(t){var e=this._getWrapTileNum();this.options.continuousWorld||this.options.noWrap||(t.x=(t.x%e.x+e.x)%e.x),this.options.tms&&(t.y=e.y-t.y-1),t.z=this._getZoomForUrl()},_getSubdomain:function(t){var e=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[e]},_getTile:function(){if(this.options.reuseTiles&&this._unusedTiles.length>0){var t=this._unusedTiles.pop();return this._resetTile(t),t}return this._createTile()},_resetTile:function(){},_createTile:function(){var t=o.DomUtil.create("img","leaflet-tile");return t.style.width=t.style.height=this._getTileSize()+"px",t.galleryimg="no",t.onselectstart=t.onmousemove=o.Util.falseFn,o.Browser.ielt9&&this.options.opacity!==i&&o.DomUtil.setOpacity(t,this.options.opacity),o.Browser.mobileWebkit3d&&(t.style.WebkitBackfaceVisibility="hidden"),t},_loadTile:function(t,e){t._layer=this,t.onload=this._tileOnLoad,t.onerror=this._tileOnError,this._adjustTilePoint(e),t.src=this.getTileUrl(e),this.fire("tileloadstart",{tile:t,url:t.src})},_tileLoaded:function(){this._tilesToLoad--,this._animated&&o.DomUtil.addClass(this._tileContainer,"leaflet-zoom-animated"),this._tilesToLoad||(this.fire("load"),this._animated&&(clearTimeout(this._clearBgBufferTimer),this._clearBgBufferTimer=setTimeout(o.bind(this._clearBgBuffer,this),500)))},_tileOnLoad:function(){var t=this._layer;this.src!==o.Util.emptyImageUrl&&(o.DomUtil.addClass(this,"leaflet-tile-loaded"),t.fire("tileload",{tile:this,url:this.src})),t._tileLoaded()},_tileOnError:function(){var t=this._layer;t.fire("tileerror",{tile:this,url:this.src});var e=t.options.errorTileUrl;e&&(this.src=e),t._tileLoaded()}}),o.tileLayer=function(t,e){return new o.TileLayer(t,e)},o.TileLayer.WMS=o.TileLayer.extend({defaultWmsParams:{service:"WMS",request:"GetMap",version:"1.1.1",layers:"",styles:"",format:"image/jpeg",transparent:!1},initialize:function(t,e){this._url=t;var i=o.extend({},this.defaultWmsParams),n=e.tileSize||this.options.tileSize;i.width=i.height=e.detectRetina&&o.Browser.retina?2*n:n;for(var s in e)this.options.hasOwnProperty(s)||"crs"===s||(i[s]=e[s]);this.wmsParams=i,o.setOptions(this,e)},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var e=this._wmsVersion>=1.3?"crs":"srs";this.wmsParams[e]=this._crs.code,o.TileLayer.prototype.onAdd.call(this,t)},getTileUrl:function(t){var e=this._map,i=this.options.tileSize,n=t.multiplyBy(i),s=n.add([i,i]),a=this._crs.project(e.unproject(n,t.z)),r=this._crs.project(e.unproject(s,t.z)),h=this._wmsVersion>=1.3&&this._crs===o.CRS.EPSG4326?[r.y,a.x,a.y,r.x].join(","):[a.x,r.y,r.x,a.y].join(","),l=o.Util.template(this._url,{s:this._getSubdomain(t)});return l+o.Util.getParamString(this.wmsParams,l,!0)+"&BBOX="+h},setParams:function(t,e){return o.extend(this.wmsParams,t),e||this.redraw(),this}}),o.tileLayer.wms=function(t,e){return new o.TileLayer.WMS(t,e)},o.TileLayer.Canvas=o.TileLayer.extend({options:{async:!1},initialize:function(t){o.setOptions(this,t)},redraw:function(){this._map&&(this._reset({hard:!0}),this._update());for(var t in this._tiles)this._redrawTile(this._tiles[t]);return this},_redrawTile:function(t){this.drawTile(t,t._tilePoint,this._map._zoom)},_createTile:function(){var t=o.DomUtil.create("canvas","leaflet-tile");return t.width=t.height=this.options.tileSize,t.onselectstart=t.onmousemove=o.Util.falseFn,t},_loadTile:function(t,e){t._layer=this,t._tilePoint=e,this._redrawTile(t),this.options.async||this.tileDrawn(t)},drawTile:function(){},tileDrawn:function(t){this._tileOnLoad.call(t)}}),o.tileLayer.canvas=function(t){return new o.TileLayer.Canvas(t)},o.ImageOverlay=o.Class.extend({includes:o.Mixin.Events,options:{opacity:1},initialize:function(t,e,i){this._url=t,this._bounds=o.latLngBounds(e),o.setOptions(this,i)},onAdd:function(t){this._map=t,this._image||this._initImage(),t._panes.overlayPane.appendChild(this._image),t.on("viewreset",this._reset,this),t.options.zoomAnimation&&o.Browser.any3d&&t.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(t){t.getPanes().overlayPane.removeChild(this._image),t.off("viewreset",this._reset,this),t.options.zoomAnimation&&t.off("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},bringToFront:function(){return this._image&&this._map._panes.overlayPane.appendChild(this._image),this},bringToBack:function(){var t=this._map._panes.overlayPane;return this._image&&t.insertBefore(this._image,t.firstChild),this},setUrl:function(t){this._url=t,this._image.src=this._url},getAttribution:function(){return this.options.attribution},_initImage:function(){this._image=o.DomUtil.create("img","leaflet-image-layer"),this._map.options.zoomAnimation&&o.Browser.any3d?o.DomUtil.addClass(this._image,"leaflet-zoom-animated"):o.DomUtil.addClass(this._image,"leaflet-zoom-hide"),this._updateOpacity(),o.extend(this._image,{galleryimg:"no",onselectstart:o.Util.falseFn,onmousemove:o.Util.falseFn,onload:o.bind(this._onImageLoad,this),src:this._url})},_animateZoom:function(t){var e=this._map,i=this._image,n=e.getZoomScale(t.zoom),s=this._bounds.getNorthWest(),a=this._bounds.getSouthEast(),r=e._latLngToNewLayerPoint(s,t.zoom,t.center),h=e._latLngToNewLayerPoint(a,t.zoom,t.center)._subtract(r),l=r._add(h._multiplyBy(.5*(1-1/n)));i.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(l)+" scale("+n+") "},_reset:function(){var t=this._image,e=this._map.latLngToLayerPoint(this._bounds.getNorthWest()),i=this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);o.DomUtil.setPosition(t,e),t.style.width=i.x+"px",t.style.height=i.y+"px"},_onImageLoad:function(){this.fire("load")},_updateOpacity:function(){o.DomUtil.setOpacity(this._image,this.options.opacity)}}),o.imageOverlay=function(t,e,i){return new o.ImageOverlay(t,e,i)},o.Icon=o.Class.extend({options:{className:""},initialize:function(t){o.setOptions(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(!i){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n;return n=e&&"IMG"===e.tagName?this._createImg(i,e):this._createImg(i),this._setIconStyles(n,t),n},_setIconStyles:function(t,e){var i,n=this.options,s=o.point(n[e+"Size"]);i=o.point("shadow"===e?n.shadowAnchor||n.iconAnchor:n.iconAnchor),!i&&s&&(i=s.divideBy(2,!0)),t.className="leaflet-marker-"+e+" "+n.className,i&&(t.style.marginLeft=-i.x+"px",t.style.marginTop=-i.y+"px"),s&&(t.style.width=s.x+"px",t.style.height=s.y+"px")},_createImg:function(t,i){return i=i||e.createElement("img"),i.src=t,i},_getIconUrl:function(t){return o.Browser.retina&&this.options[t+"RetinaUrl"]?this.options[t+"RetinaUrl"]:this.options[t+"Url"]}}),o.icon=function(t){return new o.Icon(t)},o.Icon.Default=o.Icon.extend({options:{iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]},_getIconUrl:function(t){var e=t+"Url";if(this.options[e])return this.options[e];o.Browser.retina&&"icon"===t&&(t+="-2x");var i=o.Icon.Default.imagePath;if(!i)throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");return i+"/marker-"+t+".png"}}),o.Icon.Default.imagePath=function(){var t,i,n,o,s,a=e.getElementsByTagName("script"),r=/[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;for(t=0,i=a.length;i>t;t++)if(n=a[t].src,o=n.match(r))return s=n.split(r)[0],(s?s+"/":"")+"images"}(),o.Marker=o.Class.extend({includes:o.Mixin.Events,options:{icon:new o.Icon.Default,title:"",alt:"",clickable:!0,draggable:!1,keyboard:!0,zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250},initialize:function(t,e){o.setOptions(this,e),this._latlng=o.latLng(t)},onAdd:function(t){this._map=t,t.on("viewreset",this.update,this),this._initIcon(),this.update(),this.fire("add"),t.options.zoomAnimation&&t.options.markerZoomAnimation&&t.on("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this.dragging&&this.dragging.disable(),this._removeIcon(),this._removeShadow(),this.fire("remove"),t.off({viewreset:this.update,zoomanim:this._animateZoom},this),this._map=null},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this.update(),this.fire("move",{latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update(),this},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup),this},update:function(){if(this._icon){var t=this._map.latLngToLayerPoint(this._latlng).round();this._setPos(t)}return this},_initIcon:function(){var t=this.options,e=this._map,i=e.options.zoomAnimation&&e.options.markerZoomAnimation,n=i?"leaflet-zoom-animated":"leaflet-zoom-hide",s=t.icon.createIcon(this._icon),a=!1;s!==this._icon&&(this._icon&&this._removeIcon(),a=!0,t.title&&(s.title=t.title),t.alt&&(s.alt=t.alt)),o.DomUtil.addClass(s,n),t.keyboard&&(s.tabIndex="0"),this._icon=s,this._initInteraction(),t.riseOnHover&&o.DomEvent.on(s,"mouseover",this._bringToFront,this).on(s,"mouseout",this._resetZIndex,this);var r=t.icon.createShadow(this._shadow),h=!1;r!==this._shadow&&(this._removeShadow(),h=!0),r&&o.DomUtil.addClass(r,n),this._shadow=r,t.opacity<1&&this._updateOpacity();var l=this._map._panes;a&&l.markerPane.appendChild(this._icon),r&&h&&l.shadowPane.appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&o.DomEvent.off(this._icon,"mouseover",this._bringToFront).off(this._icon,"mouseout",this._resetZIndex),this._map._panes.markerPane.removeChild(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&this._map._panes.shadowPane.removeChild(this._shadow),this._shadow=null},_setPos:function(t){o.DomUtil.setPosition(this._icon,t),this._shadow&&o.DomUtil.setPosition(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(e)},_initInteraction:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu"];o.DomUtil.addClass(t,"leaflet-clickable"),o.DomEvent.on(t,"click",this._onMouseClick,this),o.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++)o.DomEvent.on(t,e[i],this._fireMouseEvent,this);o.Handler.MarkerDrag&&(this.dragging=new o.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable())}},_onMouseClick:function(t){var e=this.dragging&&this.dragging.moved();(this.hasEventListeners(t.type)||e)&&o.DomEvent.stopPropagation(t),e||(this.dragging&&this.dragging._enabled||!this._map.dragging||!this._map.dragging.moved())&&this.fire(t.type,{originalEvent:t,latlng:this._latlng})},_onKeyPress:function(t){13===t.keyCode&&this.fire("click",{originalEvent:t,latlng:this._latlng})},_fireMouseEvent:function(t){this.fire(t.type,{originalEvent:t,latlng:this._latlng}),"contextmenu"===t.type&&this.hasEventListeners(t.type)&&o.DomEvent.preventDefault(t),"mousedown"!==t.type?o.DomEvent.stopPropagation(t):o.DomEvent.preventDefault(t)},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){o.DomUtil.setOpacity(this._icon,this.options.opacity),this._shadow&&o.DomUtil.setOpacity(this._shadow,this.options.opacity)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)}}),o.marker=function(t,e){return new o.Marker(t,e)},o.DivIcon=o.Icon.extend({options:{iconSize:[12,12],className:"leaflet-div-icon",html:!1},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:e.createElement("div"),n=this.options;return i.innerHTML=n.html!==!1?n.html:"",n.bgPos&&(i.style.backgroundPosition=-n.bgPos.x+"px "+-n.bgPos.y+"px"),this._setIconStyles(i,"icon"),i},createShadow:function(){return null}}),o.divIcon=function(t){return new o.DivIcon(t)},o.Map.mergeOptions({closePopupOnClick:!0}),o.Popup=o.Class.extend({includes:o.Mixin.Events,options:{minWidth:50,maxWidth:300,autoPan:!0,closeButton:!0,offset:[0,7],autoPanPadding:[5,5],keepInView:!1,className:"",zoomAnimation:!0},initialize:function(t,e){o.setOptions(this,t),this._source=e,this._animated=o.Browser.any3d&&this.options.zoomAnimation,this._isOpen=!1},onAdd:function(t){this._map=t,this._container||this._initLayout();var e=t.options.fadeAnimation;e&&o.DomUtil.setOpacity(this._container,0),t._panes.popupPane.appendChild(this._container),t.on(this._getEvents(),this),this.update(),e&&o.DomUtil.setOpacity(this._container,1),this.fire("open"),t.fire("popupopen",{popup:this}),this._source&&this._source.fire("popupopen",{popup:this})},addTo:function(t){return t.addLayer(this),this},openOn:function(t){return t.openPopup(this),this},onRemove:function(t){t._panes.popupPane.removeChild(this._container),o.Util.falseFn(this._container.offsetWidth),t.off(this._getEvents(),this),t.options.fadeAnimation&&o.DomUtil.setOpacity(this._container,0),this._map=null,this.fire("close"),t.fire("popupclose",{popup:this}),this._source&&this._source.fire("popupclose",{popup:this})},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},_getEvents:function(){var t={viewreset:this._updatePosition};return this._animated&&(t.zoomanim=this._zoomAnimation),("closeOnClick"in this.options?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t,e="leaflet-popup",i=e+" "+this.options.className+" leaflet-zoom-"+(this._animated?"animated":"hide"),n=this._container=o.DomUtil.create("div",i);this.options.closeButton&&(t=this._closeButton=o.DomUtil.create("a",e+"-close-button",n),t.href="#close",t.innerHTML="&#215;",o.DomEvent.disableClickPropagation(t),o.DomEvent.on(t,"click",this._onCloseButtonClick,this));var s=this._wrapper=o.DomUtil.create("div",e+"-content-wrapper",n);o.DomEvent.disableClickPropagation(s),this._contentNode=o.DomUtil.create("div",e+"-content",s),o.DomEvent.disableScrollPropagation(this._contentNode),o.DomEvent.on(s,"contextmenu",o.DomEvent.stopPropagation),this._tipContainer=o.DomUtil.create("div",e+"-tip-container",n),this._tip=o.DomUtil.create("div",e+"-tip",this._tipContainer)},_updateContent:function(){if(this._content){if("string"==typeof this._content)this._contentNode.innerHTML=this._content;else{for(;this._contentNode.hasChildNodes();)this._contentNode.removeChild(this._contentNode.firstChild);this._contentNode.appendChild(this._content)}this.fire("contentupdate")}},_updateLayout:function(){var t=this._contentNode,e=t.style;e.width="",e.whiteSpace="nowrap";var i=t.offsetWidth;i=Math.min(i,this.options.maxWidth),i=Math.max(i,this.options.minWidth),e.width=i+1+"px",e.whiteSpace="",e.height="";var n=t.offsetHeight,s=this.options.maxHeight,a="leaflet-popup-scrolled";s&&n>s?(e.height=s+"px",o.DomUtil.addClass(t,a)):o.DomUtil.removeClass(t,a),this._containerWidth=this._container.offsetWidth},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),e=this._animated,i=o.point(this.options.offset);e&&o.DomUtil.setPosition(this._container,t),this._containerBottom=-i.y-(e?0:t.y),this._containerLeft=-Math.round(this._containerWidth/2)+i.x+(e?0:t.x),this._container.style.bottom=this._containerBottom+"px",this._container.style.left=this._containerLeft+"px"}},_zoomAnimation:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);o.DomUtil.setPosition(this._container,e)},_adjustPan:function(){if(this.options.autoPan){var t=this._map,e=this._container.offsetHeight,i=this._containerWidth,n=new o.Point(this._containerLeft,-e-this._containerBottom);this._animated&&n._add(o.DomUtil.getPosition(this._container));var s=t.layerPointToContainerPoint(n),a=o.point(this.options.autoPanPadding),r=o.point(this.options.autoPanPaddingTopLeft||a),h=o.point(this.options.autoPanPaddingBottomRight||a),l=t.getSize(),u=0,c=0;s.x+i+h.x>l.x&&(u=s.x+i-l.x+h.x),s.x-u-r.x<0&&(u=s.x-r.x),s.y+e+h.y>l.y&&(c=s.y+e-l.y+h.y),s.y-c-r.y<0&&(c=s.y-r.y),(u||c)&&t.fire("autopanstart").panBy([u,c])}},_onCloseButtonClick:function(t){this._close(),o.DomEvent.stop(t)}}),o.popup=function(t,e){return new o.Popup(t,e)},o.Map.include({openPopup:function(t,e,i){if(this.closePopup(),!(t instanceof o.Popup)){var n=t;t=new o.Popup(i).setLatLng(e).setContent(n)}return t._isOpen=!0,this._popup=t,this.addLayer(t)},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&(this.removeLayer(t),t._isOpen=!1),this}}),o.Marker.include({openPopup:function(){return this._popup&&this._map&&!this._map.hasLayer(this._popup)&&(this._popup.setLatLng(this._latlng),this._map.openPopup(this._popup)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(){return this._popup&&(this._popup._isOpen?this.closePopup():this.openPopup()),this},bindPopup:function(t,e){var i=o.point(this.options.icon.options.popupAnchor||[0,0]);return i=i.add(o.Popup.prototype.options.offset),e&&e.offset&&(i=i.add(e.offset)),e=o.extend({offset:i},e),this._popupHandlersAdded||(this.on("click",this.togglePopup,this).on("remove",this.closePopup,this).on("move",this._movePopup,this),this._popupHandlersAdded=!0),t instanceof o.Popup?(o.setOptions(t,e),this._popup=t):this._popup=new o.Popup(e,this).setContent(t),this},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this.togglePopup,this).off("remove",this.closePopup,this).off("move",this._movePopup,this),this._popupHandlersAdded=!1),this},getPopup:function(){return this._popup},_movePopup:function(t){this._popup.setLatLng(t.latlng)}}),o.LayerGroup=o.Class.extend({initialize:function(t){this._layers={};var e,i;if(t)for(e=0,i=t.length;i>e;e++)this.addLayer(t[e])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var e=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[e]&&this._map.removeLayer(this._layers[e]),delete this._layers[e],this},hasLayer:function(t){return t?t in this._layers||this.getLayerId(t)in this._layers:!1},clearLayers:function(){return this.eachLayer(this.removeLayer,this),this},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)i=this._layers[e],i[t]&&i[t].apply(i,n);return this},onAdd:function(t){this._map=t,this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t),this._map=null},addTo:function(t){return t.addLayer(this),this},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];for(var e in this._layers)t.push(this._layers[e]);return t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return o.stamp(t)}}),o.layerGroup=function(t){return new o.LayerGroup(t)},o.FeatureGroup=o.LayerGroup.extend({includes:o.Mixin.Events,statics:{EVENTS:"click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"},addLayer:function(t){return this.hasLayer(t)?this:("on"in t&&t.on(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.addLayer.call(this,t),this._popupContent&&t.bindPopup&&t.bindPopup(this._popupContent,this._popupOptions),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),t.off(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.removeLayer.call(this,t),this._popupContent&&this.invoke("unbindPopup"),this.fire("layerremove",{layer:t})):this},bindPopup:function(t,e){return this._popupContent=t,this._popupOptions=e,this.invoke("bindPopup",t,e)},openPopup:function(t){for(var e in this._layers){this._layers[e].openPopup(t);break}return this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new o.LatLngBounds;return this.eachLayer(function(e){t.extend(e instanceof o.Marker?e.getLatLng():e.getBounds())}),t},_propagateEvent:function(t){t=o.extend({layer:t.target,target:this},t),this.fire(t.type,t)}}),o.featureGroup=function(t){return new o.FeatureGroup(t)},o.Path=o.Class.extend({includes:[o.Mixin.Events],statics:{CLIP_PADDING:function(){var e=o.Browser.mobile?1280:2e3,i=(e/Math.max(t.outerWidth,t.outerHeight)-1)/2;return Math.max(0,Math.min(.5,i))}()},options:{stroke:!0,color:"#0033ff",dashArray:null,lineCap:null,lineJoin:null,weight:5,opacity:.5,fill:!1,fillColor:null,fillOpacity:.2,clickable:!0},initialize:function(t){o.setOptions(this,t)},onAdd:function(t){this._map=t,this._container||(this._initElements(),this._initEvents()),this.projectLatlngs(),this._updatePath(),this._container&&this._map._pathRoot.appendChild(this._container),this.fire("add"),t.on({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){t._pathRoot.removeChild(this._container),this.fire("remove"),this._map=null,o.Browser.vml&&(this._container=null,this._stroke=null,this._fill=null),t.off({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},projectLatlngs:function(){},setStyle:function(t){return o.setOptions(this,t),this._container&&this._updateStyle(),this},redraw:function(){return this._map&&(this.projectLatlngs(),this._updatePath()),this}}),o.Map.include({_updatePathViewport:function(){var t=o.Path.CLIP_PADDING,e=this.getSize(),i=o.DomUtil.getPosition(this._mapPane),n=i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),s=n.add(e.multiplyBy(1+2*t)._round());this._pathViewport=new o.Bounds(n,s)}}),o.Path.SVG_NS="http://www.w3.org/2000/svg",o.Browser.svg=!(!e.createElementNS||!e.createElementNS(o.Path.SVG_NS,"svg").createSVGRect),o.Path=o.Path.extend({statics:{SVG:o.Browser.svg},bringToFront:function(){var t=this._map._pathRoot,e=this._container;return e&&t.lastChild!==e&&t.appendChild(e),this},bringToBack:function(){var t=this._map._pathRoot,e=this._container,i=t.firstChild;return e&&i!==e&&t.insertBefore(e,i),this},getPathString:function(){},_createElement:function(t){return e.createElementNS(o.Path.SVG_NS,t)},_initElements:function(){this._map._initPathRoot(),this._initPath(),this._initStyle()},_initPath:function(){this._container=this._createElement("g"),this._path=this._createElement("path"),this.options.className&&o.DomUtil.addClass(this._path,this.options.className),this._container.appendChild(this._path)},_initStyle:function(){this.options.stroke&&(this._path.setAttribute("stroke-linejoin","round"),this._path.setAttribute("stroke-linecap","round")),this.options.fill&&this._path.setAttribute("fill-rule","evenodd"),this.options.pointerEvents&&this._path.setAttribute("pointer-events",this.options.pointerEvents),this.options.clickable||this.options.pointerEvents||this._path.setAttribute("pointer-events","none"),this._updateStyle()},_updateStyle:function(){this.options.stroke?(this._path.setAttribute("stroke",this.options.color),this._path.setAttribute("stroke-opacity",this.options.opacity),this._path.setAttribute("stroke-width",this.options.weight),this.options.dashArray?this._path.setAttribute("stroke-dasharray",this.options.dashArray):this._path.removeAttribute("stroke-dasharray"),this.options.lineCap&&this._path.setAttribute("stroke-linecap",this.options.lineCap),this.options.lineJoin&&this._path.setAttribute("stroke-linejoin",this.options.lineJoin)):this._path.setAttribute("stroke","none"),this.options.fill?(this._path.setAttribute("fill",this.options.fillColor||this.options.color),this._path.setAttribute("fill-opacity",this.options.fillOpacity)):this._path.setAttribute("fill","none")},_updatePath:function(){var t=this.getPathString();t||(t="M0 0"),this._path.setAttribute("d",t)},_initEvents:function(){if(this.options.clickable){(o.Browser.svg||!o.Browser.vml)&&o.DomUtil.addClass(this._path,"leaflet-clickable"),o.DomEvent.on(this._container,"click",this._onMouseClick,this);for(var t=["dblclick","mousedown","mouseover","mouseout","mousemove","contextmenu"],e=0;e<t.length;e++)o.DomEvent.on(this._container,t[e],this._fireMouseEvent,this)}},_onMouseClick:function(t){this._map.dragging&&this._map.dragging.moved()||this._fireMouseEvent(t)},_fireMouseEvent:function(t){if(this.hasEventListeners(t.type)){var e=this._map,i=e.mouseEventToContainerPoint(t),n=e.containerPointToLayerPoint(i),s=e.layerPointToLatLng(n);this.fire(t.type,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t}),"contextmenu"===t.type&&o.DomEvent.preventDefault(t),"mousemove"!==t.type&&o.DomEvent.stopPropagation(t)}}}),o.Map.include({_initPathRoot:function(){this._pathRoot||(this._pathRoot=o.Path.prototype._createElement("svg"),this._panes.overlayPane.appendChild(this._pathRoot),this.options.zoomAnimation&&o.Browser.any3d?(o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-animated"),this.on({zoomanim:this._animatePathZoom,zoomend:this._endPathZoom})):o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-hide"),this.on("moveend",this._updateSvgViewport),this._updateSvgViewport())
+},_animatePathZoom:function(t){var e=this.getZoomScale(t.zoom),i=this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);this._pathRoot.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(i)+" scale("+e+") ",this._pathZooming=!0},_endPathZoom:function(){this._pathZooming=!1},_updateSvgViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max,n=i.x-e.x,s=i.y-e.y,a=this._pathRoot,r=this._panes.overlayPane;o.Browser.mobileWebkit&&r.removeChild(a),o.DomUtil.setPosition(a,e),a.setAttribute("width",n),a.setAttribute("height",s),a.setAttribute("viewBox",[e.x,e.y,n,s].join(" ")),o.Browser.mobileWebkit&&r.appendChild(a)}}}),o.Path.include({bindPopup:function(t,e){return t instanceof o.Popup?this._popup=t:((!this._popup||e)&&(this._popup=new o.Popup(e,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on("click",this._openPopup,this).on("remove",this.closePopup,this),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this._openPopup).off("remove",this.closePopup),this._popupHandlersAdded=!1),this},openPopup:function(t){return this._popup&&(t=t||this._latlng||this._latlngs[Math.floor(this._latlngs.length/2)],this._openPopup({latlng:t})),this},closePopup:function(){return this._popup&&this._popup._close(),this},_openPopup:function(t){this._popup.setLatLng(t.latlng),this._map.openPopup(this._popup)}}),o.Browser.vml=!o.Browser.svg&&function(){try{var t=e.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(n){return!1}}(),o.Path=o.Browser.svg||!o.Browser.vml?o.Path:o.Path.extend({statics:{VML:!0,CLIP_PADDING:.02},_createElement:function(){try{return e.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return e.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),_initPath:function(){var t=this._container=this._createElement("shape");o.DomUtil.addClass(t,"leaflet-vml-shape"+(this.options.className?" "+this.options.className:"")),this.options.clickable&&o.DomUtil.addClass(t,"leaflet-clickable"),t.coordsize="1 1",this._path=this._createElement("path"),t.appendChild(this._path),this._map._pathRoot.appendChild(t)},_initStyle:function(){this._updateStyle()},_updateStyle:function(){var t=this._stroke,e=this._fill,i=this.options,n=this._container;n.stroked=i.stroke,n.filled=i.fill,i.stroke?(t||(t=this._stroke=this._createElement("stroke"),t.endcap="round",n.appendChild(t)),t.weight=i.weight+"px",t.color=i.color,t.opacity=i.opacity,t.dashStyle=i.dashArray?o.Util.isArray(i.dashArray)?i.dashArray.join(" "):i.dashArray.replace(/( *, *)/g," "):"",i.lineCap&&(t.endcap=i.lineCap.replace("butt","flat")),i.lineJoin&&(t.joinstyle=i.lineJoin)):t&&(n.removeChild(t),this._stroke=null),i.fill?(e||(e=this._fill=this._createElement("fill"),n.appendChild(e)),e.color=i.fillColor||i.color,e.opacity=i.fillOpacity):e&&(n.removeChild(e),this._fill=null)},_updatePath:function(){var t=this._container.style;t.display="none",this._path.v=this.getPathString()+" ",t.display=""}}),o.Map.include(o.Browser.svg||!o.Browser.vml?{}:{_initPathRoot:function(){if(!this._pathRoot){var t=this._pathRoot=e.createElement("div");t.className="leaflet-vml-container",this._panes.overlayPane.appendChild(t),this.on("moveend",this._updatePathViewport),this._updatePathViewport()}}}),o.Browser.canvas=function(){return!!e.createElement("canvas").getContext}(),o.Path=o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?o.Path:o.Path.extend({statics:{CANVAS:!0,SVG:!1},redraw:function(){return this._map&&(this.projectLatlngs(),this._requestUpdate()),this},setStyle:function(t){return o.setOptions(this,t),this._map&&(this._updateStyle(),this._requestUpdate()),this},onRemove:function(t){t.off("viewreset",this.projectLatlngs,this).off("moveend",this._updatePath,this),this.options.clickable&&(this._map.off("click",this._onClick,this),this._map.off("mousemove",this._onMouseMove,this)),this._requestUpdate(),this.fire("remove"),this._map=null},_requestUpdate:function(){this._map&&!o.Path._updateRequest&&(o.Path._updateRequest=o.Util.requestAnimFrame(this._fireMapMoveEnd,this._map))},_fireMapMoveEnd:function(){o.Path._updateRequest=null,this.fire("moveend")},_initElements:function(){this._map._initPathRoot(),this._ctx=this._map._canvasCtx},_updateStyle:function(){var t=this.options;t.stroke&&(this._ctx.lineWidth=t.weight,this._ctx.strokeStyle=t.color),t.fill&&(this._ctx.fillStyle=t.fillColor||t.color)},_drawPath:function(){var t,e,i,n,s,a;for(this._ctx.beginPath(),t=0,i=this._parts.length;i>t;t++){for(e=0,n=this._parts[t].length;n>e;e++)s=this._parts[t][e],a=(0===e?"move":"line")+"To",this._ctx[a](s.x,s.y);this instanceof o.Polygon&&this._ctx.closePath()}},_checkIfEmpty:function(){return!this._parts.length},_updatePath:function(){if(!this._checkIfEmpty()){var t=this._ctx,e=this.options;this._drawPath(),t.save(),this._updateStyle(),e.fill&&(t.globalAlpha=e.fillOpacity,t.fill()),e.stroke&&(t.globalAlpha=e.opacity,t.stroke()),t.restore()}},_initEvents:function(){this.options.clickable&&(this._map.on("mousemove",this._onMouseMove,this),this._map.on("click",this._onClick,this))},_onClick:function(t){this._containsPoint(t.layerPoint)&&this.fire("click",t)},_onMouseMove:function(t){this._map&&!this._map._animatingZoom&&(this._containsPoint(t.layerPoint)?(this._ctx.canvas.style.cursor="pointer",this._mouseInside=!0,this.fire("mouseover",t)):this._mouseInside&&(this._ctx.canvas.style.cursor="",this._mouseInside=!1,this.fire("mouseout",t)))}}),o.Map.include(o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?{}:{_initPathRoot:function(){var t,i=this._pathRoot;i||(i=this._pathRoot=e.createElement("canvas"),i.style.position="absolute",t=this._canvasCtx=i.getContext("2d"),t.lineCap="round",t.lineJoin="round",this._panes.overlayPane.appendChild(i),this.options.zoomAnimation&&(this._pathRoot.className="leaflet-zoom-animated",this.on("zoomanim",this._animatePathZoom),this.on("zoomend",this._endPathZoom)),this.on("moveend",this._updateCanvasViewport),this._updateCanvasViewport())},_updateCanvasViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max.subtract(e),n=this._pathRoot;o.DomUtil.setPosition(n,e),n.width=i.x,n.height=i.y,n.getContext("2d").translate(-e.x,-e.y)}}}),o.LineUtil={simplify:function(t,e){if(!e||!t.length)return t.slice();var i=e*e;return t=this._reducePoints(t,i),t=this._simplifyDP(t,i)},pointToSegmentDistance:function(t,e,i){return Math.sqrt(this._sqClosestPointOnSegment(t,e,i,!0))},closestPointOnSegment:function(t,e,i){return this._sqClosestPointOnSegment(t,e,i)},_simplifyDP:function(t,e){var n=t.length,o=typeof Uint8Array!=i+""?Uint8Array:Array,s=new o(n);s[0]=s[n-1]=1,this._simplifyDPStep(t,s,e,0,n-1);var a,r=[];for(a=0;n>a;a++)s[a]&&r.push(t[a]);return r},_simplifyDPStep:function(t,e,i,n,o){var s,a,r,h=0;for(a=n+1;o-1>=a;a++)r=this._sqClosestPointOnSegment(t[a],t[n],t[o],!0),r>h&&(s=a,h=r);h>i&&(e[s]=1,this._simplifyDPStep(t,e,i,n,s),this._simplifyDPStep(t,e,i,s,o))},_reducePoints:function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;s>n;n++)this._sqDist(t[n],t[o])>e&&(i.push(t[n]),o=n);return s-1>o&&i.push(t[s-1]),i},clipSegment:function(t,e,i,n){var o,s,a,r=n?this._lastCode:this._getBitCode(t,i),h=this._getBitCode(e,i);for(this._lastCode=h;;){if(!(r|h))return[t,e];if(r&h)return!1;o=r||h,s=this._getEdgeIntersection(t,e,o,i),a=this._getBitCode(s,i),o===r?(t=s,r=a):(e=s,h=a)}},_getEdgeIntersection:function(t,e,i,n){var s=e.x-t.x,a=e.y-t.y,r=n.min,h=n.max;return 8&i?new o.Point(t.x+s*(h.y-t.y)/a,h.y):4&i?new o.Point(t.x+s*(r.y-t.y)/a,r.y):2&i?new o.Point(h.x,t.y+a*(h.x-t.x)/s):1&i?new o.Point(r.x,t.y+a*(r.x-t.x)/s):void 0},_getBitCode:function(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i},_sqDist:function(t,e){var i=e.x-t.x,n=e.y-t.y;return i*i+n*n},_sqClosestPointOnSegment:function(t,e,i,n){var s,a=e.x,r=e.y,h=i.x-a,l=i.y-r,u=h*h+l*l;return u>0&&(s=((t.x-a)*h+(t.y-r)*l)/u,s>1?(a=i.x,r=i.y):s>0&&(a+=h*s,r+=l*s)),h=t.x-a,l=t.y-r,n?h*h+l*l:new o.Point(a,r)}},o.Polyline=o.Path.extend({initialize:function(t,e){o.Path.prototype.initialize.call(this,e),this._latlngs=this._convertLatLngs(t)},options:{smoothFactor:1,noClip:!1},projectLatlngs:function(){this._originalPoints=[];for(var t=0,e=this._latlngs.length;e>t;t++)this._originalPoints[t]=this._map.latLngToLayerPoint(this._latlngs[t])},getPathString:function(){for(var t=0,e=this._parts.length,i="";e>t;t++)i+=this._getPathPartStr(this._parts[t]);return i},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._latlngs=this._convertLatLngs(t),this.redraw()},addLatLng:function(t){return this._latlngs.push(o.latLng(t)),this.redraw()},spliceLatLngs:function(){var t=[].splice.apply(this._latlngs,arguments);return this._convertLatLngs(this._latlngs,!0),this.redraw(),t},closestLayerPoint:function(t){for(var e,i,n=1/0,s=this._parts,a=null,r=0,h=s.length;h>r;r++)for(var l=s[r],u=1,c=l.length;c>u;u++){e=l[u-1],i=l[u];var d=o.LineUtil._sqClosestPointOnSegment(t,e,i,!0);n>d&&(n=d,a=o.LineUtil._sqClosestPointOnSegment(t,e,i))}return a&&(a.distance=Math.sqrt(n)),a},getBounds:function(){return new o.LatLngBounds(this.getLatLngs())},_convertLatLngs:function(t,e){var i,n,s=e?t:[];for(i=0,n=t.length;n>i;i++){if(o.Util.isArray(t[i])&&"number"!=typeof t[i][0])return;s[i]=o.latLng(t[i])}return s},_initEvents:function(){o.Path.prototype._initEvents.call(this)},_getPathPartStr:function(t){for(var e,i=o.Path.VML,n=0,s=t.length,a="";s>n;n++)e=t[n],i&&e._round(),a+=(n?"L":"M")+e.x+" "+e.y;return a},_clipPoints:function(){var t,e,i,n=this._originalPoints,s=n.length;if(this.options.noClip)return void(this._parts=[n]);this._parts=[];var a=this._parts,r=this._map._pathViewport,h=o.LineUtil;for(t=0,e=0;s-1>t;t++)i=h.clipSegment(n[t],n[t+1],r,t),i&&(a[e]=a[e]||[],a[e].push(i[0]),(i[1]!==n[t+1]||t===s-2)&&(a[e].push(i[1]),e++))},_simplifyPoints:function(){for(var t=this._parts,e=o.LineUtil,i=0,n=t.length;n>i;i++)t[i]=e.simplify(t[i],this.options.smoothFactor)},_updatePath:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),o.Path.prototype._updatePath.call(this))}}),o.polyline=function(t,e){return new o.Polyline(t,e)},o.PolyUtil={},o.PolyUtil.clipPolygon=function(t,e){var i,n,s,a,r,h,l,u,c,d=[1,4,2,8],p=o.LineUtil;for(n=0,l=t.length;l>n;n++)t[n]._code=p._getBitCode(t[n],e);for(a=0;4>a;a++){for(u=d[a],i=[],n=0,l=t.length,s=l-1;l>n;s=n++)r=t[n],h=t[s],r._code&u?h._code&u||(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)):(h._code&u&&(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)),i.push(r));t=i}return t},o.Polygon=o.Polyline.extend({options:{fill:!0},initialize:function(t,e){o.Polyline.prototype.initialize.call(this,t,e),this._initWithHoles(t)},_initWithHoles:function(t){var e,i,n;if(t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0])for(this._latlngs=this._convertLatLngs(t[0]),this._holes=t.slice(1),e=0,i=this._holes.length;i>e;e++)n=this._holes[e]=this._convertLatLngs(this._holes[e]),n[0].equals(n[n.length-1])&&n.pop();t=this._latlngs,t.length>=2&&t[0].equals(t[t.length-1])&&t.pop()},projectLatlngs:function(){if(o.Polyline.prototype.projectLatlngs.call(this),this._holePoints=[],this._holes){var t,e,i,n;for(t=0,i=this._holes.length;i>t;t++)for(this._holePoints[t]=[],e=0,n=this._holes[t].length;n>e;e++)this._holePoints[t][e]=this._map.latLngToLayerPoint(this._holes[t][e])}},setLatLngs:function(t){return t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0]?(this._initWithHoles(t),this.redraw()):o.Polyline.prototype.setLatLngs.call(this,t)},_clipPoints:function(){var t=this._originalPoints,e=[];if(this._parts=[t].concat(this._holePoints),!this.options.noClip){for(var i=0,n=this._parts.length;n>i;i++){var s=o.PolyUtil.clipPolygon(this._parts[i],this._map._pathViewport);s.length&&e.push(s)}this._parts=e}},_getPathPartStr:function(t){var e=o.Polyline.prototype._getPathPartStr.call(this,t);return e+(o.Browser.svg?"z":"x")}}),o.polygon=function(t,e){return new o.Polygon(t,e)},function(){function t(t){return o.FeatureGroup.extend({initialize:function(t,e){this._layers={},this._options=e,this.setLatLngs(t)},setLatLngs:function(e){var i=0,n=e.length;for(this.eachLayer(function(t){n>i?t.setLatLngs(e[i++]):this.removeLayer(t)},this);n>i;)this.addLayer(new t(e[i++],this._options));return this},getLatLngs:function(){var t=[];return this.eachLayer(function(e){t.push(e.getLatLngs())}),t}})}o.MultiPolyline=t(o.Polyline),o.MultiPolygon=t(o.Polygon),o.multiPolyline=function(t,e){return new o.MultiPolyline(t,e)},o.multiPolygon=function(t,e){return new o.MultiPolygon(t,e)}}(),o.Rectangle=o.Polygon.extend({initialize:function(t,e){o.Polygon.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=o.latLngBounds(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}}),o.rectangle=function(t,e){return new o.Rectangle(t,e)},o.Circle=o.Path.extend({initialize:function(t,e,i){o.Path.prototype.initialize.call(this,i),this._latlng=o.latLng(t),this._mRadius=e},options:{fill:!0},setLatLng:function(t){return this._latlng=o.latLng(t),this.redraw()},setRadius:function(t){return this._mRadius=t,this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,i=this._map.latLngToLayerPoint([e.lat,e.lng-t]);this._point=this._map.latLngToLayerPoint(e),this._radius=Math.max(this._point.x-i.x,1)},getBounds:function(){var t=this._getLngRadius(),e=this._mRadius/40075017*360,i=this._latlng;return new o.LatLngBounds([i.lat-e,i.lng-t],[i.lat+e,i.lng+t])},getLatLng:function(){return this._latlng},getPathString:function(){var t=this._point,e=this._radius;return this._checkIfEmpty()?"":o.Browser.svg?"M"+t.x+","+(t.y-e)+"A"+e+","+e+",0,1,1,"+(t.x-.1)+","+(t.y-e)+" z":(t._round(),e=Math.round(e),"AL "+t.x+","+t.y+" "+e+","+e+" 0,23592600")},getRadius:function(){return this._mRadius},_getLatRadius:function(){return this._mRadius/40075017*360},_getLngRadius:function(){return this._getLatRadius()/Math.cos(o.LatLng.DEG_TO_RAD*this._latlng.lat)},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._radius,i=this._point;return i.x-e>t.max.x||i.y-e>t.max.y||i.x+e<t.min.x||i.y+e<t.min.y}}),o.circle=function(t,e,i){return new o.Circle(t,e,i)},o.CircleMarker=o.Circle.extend({options:{radius:10,weight:2},initialize:function(t,e){o.Circle.prototype.initialize.call(this,t,null,e),this._radius=this.options.radius},projectLatlngs:function(){this._point=this._map.latLngToLayerPoint(this._latlng)},_updateStyle:function(){o.Circle.prototype._updateStyle.call(this),this.setRadius(this.options.radius)},setLatLng:function(t){return o.Circle.prototype.setLatLng.call(this,t),this._popup&&this._popup._isOpen&&this._popup.setLatLng(t),this},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius}}),o.circleMarker=function(t,e){return new o.CircleMarker(t,e)},o.Polyline.include(o.Path.CANVAS?{_containsPoint:function(t,e){var i,n,s,a,r,h,l,u=this.options.weight/2;for(o.Browser.touch&&(u+=10),i=0,a=this._parts.length;a>i;i++)for(l=this._parts[i],n=0,r=l.length,s=r-1;r>n;s=n++)if((e||0!==n)&&(h=o.LineUtil.pointToSegmentDistance(t,l[s],l[n]),u>=h))return!0;return!1}}:{}),o.Polygon.include(o.Path.CANVAS?{_containsPoint:function(t){var e,i,n,s,a,r,h,l,u=!1;if(o.Polyline.prototype._containsPoint.call(this,t,!0))return!0;for(s=0,h=this._parts.length;h>s;s++)for(e=this._parts[s],a=0,l=e.length,r=l-1;l>a;r=a++)i=e[a],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(u=!u);return u}}:{}),o.Circle.include(o.Path.CANVAS?{_drawPath:function(){var t=this._point;this._ctx.beginPath(),this._ctx.arc(t.x,t.y,this._radius,0,2*Math.PI,!1)},_containsPoint:function(t){var e=this._point,i=this.options.stroke?this.options.weight/2:0;return t.distanceTo(e)<=this._radius+i}}:{}),o.CircleMarker.include(o.Path.CANVAS?{_updateStyle:function(){o.Path.prototype._updateStyle.call(this)}}:{}),o.GeoJSON=o.FeatureGroup.extend({initialize:function(t,e){o.setOptions(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,s=o.Util.isArray(t)?t:t.features;if(s){for(e=0,i=s.length;i>e;e++)n=s[e],(n.geometries||n.geometry||n.features||n.coordinates)&&this.addData(s[e]);return this}var a=this.options;if(!a.filter||a.filter(t)){var r=o.GeoJSON.geometryToLayer(t,a.pointToLayer,a.coordsToLatLng,a);return r.feature=o.GeoJSON.asFeature(t),r.defaultOptions=r.options,this.resetStyle(r),a.onEachFeature&&a.onEachFeature(t,r),this.addLayer(r)}},resetStyle:function(t){var e=this.options.style;e&&(o.Util.extend(t.options,t.defaultOptions),this._setLayerStyle(t,e))},setStyle:function(t){this.eachLayer(function(e){this._setLayerStyle(e,t)},this)},_setLayerStyle:function(t,e){"function"==typeof e&&(e=e(t.feature)),t.setStyle&&t.setStyle(e)}}),o.extend(o.GeoJSON,{geometryToLayer:function(t,e,i,n){var s,a,r,h,l="Feature"===t.type?t.geometry:t,u=l.coordinates,c=[];switch(i=i||this.coordsToLatLng,l.type){case"Point":return s=i(u),e?e(t,s):new o.Marker(s);case"MultiPoint":for(r=0,h=u.length;h>r;r++)s=i(u[r]),c.push(e?e(t,s):new o.Marker(s));return new o.FeatureGroup(c);case"LineString":return a=this.coordsToLatLngs(u,0,i),new o.Polyline(a,n);case"Polygon":if(2===u.length&&!u[1].length)throw new Error("Invalid GeoJSON object.");return a=this.coordsToLatLngs(u,1,i),new o.Polygon(a,n);case"MultiLineString":return a=this.coordsToLatLngs(u,1,i),new o.MultiPolyline(a,n);case"MultiPolygon":return a=this.coordsToLatLngs(u,2,i),new o.MultiPolygon(a,n);case"GeometryCollection":for(r=0,h=l.geometries.length;h>r;r++)c.push(this.geometryToLayer({geometry:l.geometries[r],type:"Feature",properties:t.properties},e,i,n));return new o.FeatureGroup(c);default:throw new Error("Invalid GeoJSON object.")}},coordsToLatLng:function(t){return new o.LatLng(t[1],t[0],t[2])},coordsToLatLngs:function(t,e,i){var n,o,s,a=[];for(o=0,s=t.length;s>o;o++)n=e?this.coordsToLatLngs(t[o],e-1,i):(i||this.coordsToLatLng)(t[o]),a.push(n);return a},latLngToCoords:function(t){var e=[t.lng,t.lat];return t.alt!==i&&e.push(t.alt),e},latLngsToCoords:function(t){for(var e=[],i=0,n=t.length;n>i;i++)e.push(o.GeoJSON.latLngToCoords(t[i]));return e},getFeature:function(t,e){return t.feature?o.extend({},t.feature,{geometry:e}):o.GeoJSON.asFeature(e)},asFeature:function(t){return"Feature"===t.type?t:{type:"Feature",properties:{},geometry:t}}});var a={toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"Point",coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())})}};o.Marker.include(a),o.Circle.include(a),o.CircleMarker.include(a),o.Polyline.include({toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"LineString",coordinates:o.GeoJSON.latLngsToCoords(this.getLatLngs())})}}),o.Polygon.include({toGeoJSON:function(){var t,e,i,n=[o.GeoJSON.latLngsToCoords(this.getLatLngs())];if(n[0].push(n[0][0]),this._holes)for(t=0,e=this._holes.length;e>t;t++)i=o.GeoJSON.latLngsToCoords(this._holes[t]),i.push(i[0]),n.push(i);return o.GeoJSON.getFeature(this,{type:"Polygon",coordinates:n})}}),function(){function t(t){return function(){var e=[];return this.eachLayer(function(t){e.push(t.toGeoJSON().geometry.coordinates)}),o.GeoJSON.getFeature(this,{type:t,coordinates:e})}}o.MultiPolyline.include({toGeoJSON:t("MultiLineString")}),o.MultiPolygon.include({toGeoJSON:t("MultiPolygon")}),o.LayerGroup.include({toGeoJSON:function(){var e,i=this.feature&&this.feature.geometry,n=[];if(i&&"MultiPoint"===i.type)return t("MultiPoint").call(this);var s=i&&"GeometryCollection"===i.type;return this.eachLayer(function(t){t.toGeoJSON&&(e=t.toGeoJSON(),n.push(s?e.geometry:o.GeoJSON.asFeature(e)))}),s?o.GeoJSON.getFeature(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n}}})}(),o.geoJson=function(t,e){return new o.GeoJSON(t,e)},o.DomEvent={addListener:function(t,e,i,n){var s,a,r,h=o.stamp(i),l="_leaflet_"+e+h;return t[l]?this:(s=function(e){return i.call(n||t,e||o.DomEvent._getEvent())},o.Browser.pointer&&0===e.indexOf("touch")?this.addPointerListener(t,e,s,h):(o.Browser.touch&&"dblclick"===e&&this.addDoubleTapListener&&this.addDoubleTapListener(t,s,h),"addEventListener"in t?"mousewheel"===e?(t.addEventListener("DOMMouseScroll",s,!1),t.addEventListener(e,s,!1)):"mouseenter"===e||"mouseleave"===e?(a=s,r="mouseenter"===e?"mouseover":"mouseout",s=function(e){return o.DomEvent._checkMouse(t,e)?a(e):void 0},t.addEventListener(r,s,!1)):"click"===e&&o.Browser.android?(a=s,s=function(t){return o.DomEvent._filterClick(t,a)},t.addEventListener(e,s,!1)):t.addEventListener(e,s,!1):"attachEvent"in t&&t.attachEvent("on"+e,s),t[l]=s,this))},removeListener:function(t,e,i){var n=o.stamp(i),s="_leaflet_"+e+n,a=t[s];return a?(o.Browser.pointer&&0===e.indexOf("touch")?this.removePointerListener(t,e,n):o.Browser.touch&&"dblclick"===e&&this.removeDoubleTapListener?this.removeDoubleTapListener(t,n):"removeEventListener"in t?"mousewheel"===e?(t.removeEventListener("DOMMouseScroll",a,!1),t.removeEventListener(e,a,!1)):"mouseenter"===e||"mouseleave"===e?t.removeEventListener("mouseenter"===e?"mouseover":"mouseout",a,!1):t.removeEventListener(e,a,!1):"detachEvent"in t&&t.detachEvent("on"+e,a),t[s]=null,this):this},stopPropagation:function(t){return t.stopPropagation?t.stopPropagation():t.cancelBubble=!0,o.DomEvent._skipped(t),this},disableScrollPropagation:function(t){var e=o.DomEvent.stopPropagation;return o.DomEvent.on(t,"mousewheel",e).on(t,"MozMousePixelScroll",e)},disableClickPropagation:function(t){for(var e=o.DomEvent.stopPropagation,i=o.Draggable.START.length-1;i>=0;i--)o.DomEvent.on(t,o.Draggable.START[i],e);return o.DomEvent.on(t,"click",o.DomEvent._fakeStop).on(t,"dblclick",e)},preventDefault:function(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this},stop:function(t){return o.DomEvent.preventDefault(t).stopPropagation(t)},getMousePosition:function(t,e){if(!e)return new o.Point(t.clientX,t.clientY);var i=e.getBoundingClientRect();return new o.Point(t.clientX-i.left-e.clientLeft,t.clientY-i.top-e.clientTop)},getWheelDelta:function(t){var e=0;return t.wheelDelta&&(e=t.wheelDelta/120),t.detail&&(e=-t.detail/3),e},_skipEvents:{},_fakeStop:function(t){o.DomEvent._skipEvents[t.type]=!0},_skipped:function(t){var e=this._skipEvents[t.type];return this._skipEvents[t.type]=!1,e},_checkMouse:function(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(n){return!1}return i!==t},_getEvent:function(){var e=t.event;if(!e)for(var i=arguments.callee.caller;i&&(e=i.arguments[0],!e||t.Event!==e.constructor);)i=i.caller;return e},_filterClick:function(t,e){var i=t.timeStamp||t.originalEvent.timeStamp,n=o.DomEvent._lastClick&&i-o.DomEvent._lastClick;return n&&n>100&&500>n||t.target._simulatedClick&&!t._simulated?void o.DomEvent.stop(t):(o.DomEvent._lastClick=i,e(t))}},o.DomEvent.on=o.DomEvent.addListener,o.DomEvent.off=o.DomEvent.removeListener,o.Draggable=o.Class.extend({includes:o.Mixin.Events,statics:{START:o.Browser.touch?["touchstart","mousedown"]:["mousedown"],END:{mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},MOVE:{mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"}},initialize:function(t,e){this._element=t,this._dragStartTarget=e||t},enable:function(){if(!this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.on(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!0}},disable:function(){if(this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.off(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!1,this._moved=!1}},_onDown:function(t){if(this._moved=!1,!(t.shiftKey||1!==t.which&&1!==t.button&&!t.touches||(o.DomEvent.stopPropagation(t),o.Draggable._disabled||(o.DomUtil.disableImageDrag(),o.DomUtil.disableTextSelection(),this._moving)))){var i=t.touches?t.touches[0]:t;this._startPoint=new o.Point(i.clientX,i.clientY),this._startPos=this._newPos=o.DomUtil.getPosition(this._element),o.DomEvent.on(e,o.Draggable.MOVE[t.type],this._onMove,this).on(e,o.Draggable.END[t.type],this._onUp,this)}},_onMove:function(t){if(t.touches&&t.touches.length>1)return void(this._moved=!0);var i=t.touches&&1===t.touches.length?t.touches[0]:t,n=new o.Point(i.clientX,i.clientY),s=n.subtract(this._startPoint);(s.x||s.y)&&(o.Browser.touch&&Math.abs(s.x)+Math.abs(s.y)<3||(o.DomEvent.preventDefault(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=o.DomUtil.getPosition(this._element).subtract(s),o.DomUtil.addClass(e.body,"leaflet-dragging"),this._lastTarget=t.target||t.srcElement,o.DomUtil.addClass(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(s),this._moving=!0,o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updatePosition,this,!0,this._dragStartTarget)))},_updatePosition:function(){this.fire("predrag"),o.DomUtil.setPosition(this._element,this._newPos),this.fire("drag")},_onUp:function(){o.DomUtil.removeClass(e.body,"leaflet-dragging"),this._lastTarget&&(o.DomUtil.removeClass(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null);for(var t in o.Draggable.MOVE)o.DomEvent.off(e,o.Draggable.MOVE[t],this._onMove).off(e,o.Draggable.END[t],this._onUp);o.DomUtil.enableImageDrag(),o.DomUtil.enableTextSelection(),this._moved&&this._moving&&(o.Util.cancelAnimFrame(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1}}),o.Handler=o.Class.extend({initialize:function(t){this._map=t},enable:function(){this._enabled||(this._enabled=!0,this.addHooks())},disable:function(){this._enabled&&(this._enabled=!1,this.removeHooks())},enabled:function(){return!!this._enabled}}),o.Map.mergeOptions({dragging:!0,inertia:!o.Browser.android23,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,inertiaThreshold:o.Browser.touch?32:18,easeLinearity:.25,worldCopyJump:!1}),o.Map.Drag=o.Handler.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new o.Draggable(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDrag,this),t.on("viewreset",this._onViewReset,this),t.whenReady(this._onViewReset,this))}this._draggable.enable()},removeHooks:function(){this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){var t=this._map;t._panAnim&&t._panAnim.stop(),t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(){if(this._map.options.inertia){var t=this._lastTime=+new Date,e=this._lastPos=this._draggable._newPos;this._positions.push(e),this._times.push(t),t-this._times[0]>200&&(this._positions.shift(),this._times.shift())}this._map.fire("move").fire("drag")},_onViewReset:function(){var t=this._map.getSize()._divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.project([0,180]).x},_onPreDrag:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,s=(n+e+i)%t-e-i,a=Math.abs(o+i)<Math.abs(s+i)?o:s;this._draggable._newPos.x=a},_onDragEnd:function(t){var e=this._map,i=e.options,n=+new Date-this._lastTime,s=!i.inertia||n>i.inertiaThreshold||!this._positions[0];if(e.fire("dragend",t),s)e.fire("moveend");else{var a=this._lastPos.subtract(this._positions[0]),r=(this._lastTime+n-this._times[0])/1e3,h=i.easeLinearity,l=a.multiplyBy(h/r),u=l.distanceTo([0,0]),c=Math.min(i.inertiaMaxSpeed,u),d=l.multiplyBy(c/u),p=c/(i.inertiaDeceleration*h),_=d.multiplyBy(-p/2).round();_.x&&_.y?(_=e._limitOffset(_,e.options.maxBounds),o.Util.requestAnimFrame(function(){e.panBy(_,{duration:p,easeLinearity:h,noMoveStart:!0})})):e.fire("moveend")}}}),o.Map.addInitHook("addHandler","dragging",o.Map.Drag),o.Map.mergeOptions({doubleClickZoom:!0}),o.Map.DoubleClickZoom=o.Handler.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom()+(t.originalEvent.shiftKey?-1:1);"center"===e.options.doubleClickZoom?e.setZoom(i):e.setZoomAround(t.containerPoint,i)}}),o.Map.addInitHook("addHandler","doubleClickZoom",o.Map.DoubleClickZoom),o.Map.mergeOptions({scrollWheelZoom:!0}),o.Map.ScrollWheelZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"mousewheel",this._onWheelScroll,this),o.DomEvent.on(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault),this._delta=0},removeHooks:function(){o.DomEvent.off(this._map._container,"mousewheel",this._onWheelScroll),o.DomEvent.off(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault)},_onWheelScroll:function(t){var e=o.DomEvent.getWheelDelta(t);this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var i=Math.max(40-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o.bind(this._performZoom,this),i),o.DomEvent.preventDefault(t),o.DomEvent.stopPropagation(t)},_performZoom:function(){var t=this._map,e=this._delta,i=t.getZoom();e=e>0?Math.ceil(e):Math.floor(e),e=Math.max(Math.min(e,4),-4),e=t._limitZoom(i+e)-i,this._delta=0,this._startTime=null,e&&("center"===t.options.scrollWheelZoom?t.setZoom(i+e):t.setZoomAround(this._lastMousePos,i+e))}}),o.Map.addInitHook("addHandler","scrollWheelZoom",o.Map.ScrollWheelZoom),o.extend(o.DomEvent,{_touchstart:o.Browser.msPointer?"MSPointerDown":o.Browser.pointer?"pointerdown":"touchstart",_touchend:o.Browser.msPointer?"MSPointerUp":o.Browser.pointer?"pointerup":"touchend",addDoubleTapListener:function(t,i,n){function s(t){var e;if(o.Browser.pointer?(_.push(t.pointerId),e=_.length):e=t.touches.length,!(e>1)){var i=Date.now(),n=i-(r||i);h=t.touches?t.touches[0]:t,l=n>0&&u>=n,r=i}}function a(t){if(o.Browser.pointer){var e=_.indexOf(t.pointerId);if(-1===e)return;_.splice(e,1)}if(l){if(o.Browser.pointer){var n,s={};for(var a in h)n=h[a],s[a]="function"==typeof n?n.bind(h):n;h=s}h.type="dblclick",i(h),r=null}}var r,h,l=!1,u=250,c="_leaflet_",d=this._touchstart,p=this._touchend,_=[];t[c+d+n]=s,t[c+p+n]=a;var m=o.Browser.pointer?e.documentElement:t;return t.addEventListener(d,s,!1),m.addEventListener(p,a,!1),o.Browser.pointer&&m.addEventListener(o.DomEvent.POINTER_CANCEL,a,!1),this},removeDoubleTapListener:function(t,i){var n="_leaflet_";return t.removeEventListener(this._touchstart,t[n+this._touchstart+i],!1),(o.Browser.pointer?e.documentElement:t).removeEventListener(this._touchend,t[n+this._touchend+i],!1),o.Browser.pointer&&e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL,t[n+this._touchend+i],!1),this}}),o.extend(o.DomEvent,{POINTER_DOWN:o.Browser.msPointer?"MSPointerDown":"pointerdown",POINTER_MOVE:o.Browser.msPointer?"MSPointerMove":"pointermove",POINTER_UP:o.Browser.msPointer?"MSPointerUp":"pointerup",POINTER_CANCEL:o.Browser.msPointer?"MSPointerCancel":"pointercancel",_pointers:[],_pointerDocumentListener:!1,addPointerListener:function(t,e,i,n){switch(e){case"touchstart":return this.addPointerListenerStart(t,e,i,n);case"touchend":return this.addPointerListenerEnd(t,e,i,n);case"touchmove":return this.addPointerListenerMove(t,e,i,n);default:throw"Unknown touch event type"}},addPointerListenerStart:function(t,i,n,s){var a="_leaflet_",r=this._pointers,h=function(t){o.DomEvent.preventDefault(t);for(var e=!1,i=0;i<r.length;i++)if(r[i].pointerId===t.pointerId){e=!0;
+break}e||r.push(t),t.touches=r.slice(),t.changedTouches=[t],n(t)};if(t[a+"touchstart"+s]=h,t.addEventListener(this.POINTER_DOWN,h,!1),!this._pointerDocumentListener){var l=function(t){for(var e=0;e<r.length;e++)if(r[e].pointerId===t.pointerId){r.splice(e,1);break}};e.documentElement.addEventListener(this.POINTER_UP,l,!1),e.documentElement.addEventListener(this.POINTER_CANCEL,l,!1),this._pointerDocumentListener=!0}return this},addPointerListenerMove:function(t,e,i,n){function o(t){if(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons){for(var e=0;e<a.length;e++)if(a[e].pointerId===t.pointerId){a[e]=t;break}t.touches=a.slice(),t.changedTouches=[t],i(t)}}var s="_leaflet_",a=this._pointers;return t[s+"touchmove"+n]=o,t.addEventListener(this.POINTER_MOVE,o,!1),this},addPointerListenerEnd:function(t,e,i,n){var o="_leaflet_",s=this._pointers,a=function(t){for(var e=0;e<s.length;e++)if(s[e].pointerId===t.pointerId){s.splice(e,1);break}t.touches=s.slice(),t.changedTouches=[t],i(t)};return t[o+"touchend"+n]=a,t.addEventListener(this.POINTER_UP,a,!1),t.addEventListener(this.POINTER_CANCEL,a,!1),this},removePointerListener:function(t,e,i){var n="_leaflet_",o=t[n+e+i];switch(e){case"touchstart":t.removeEventListener(this.POINTER_DOWN,o,!1);break;case"touchmove":t.removeEventListener(this.POINTER_MOVE,o,!1);break;case"touchend":t.removeEventListener(this.POINTER_UP,o,!1),t.removeEventListener(this.POINTER_CANCEL,o,!1)}return this}}),o.Map.mergeOptions({touchZoom:o.Browser.touch&&!o.Browser.android23,bounceAtZoomLimits:!0}),o.Map.TouchZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var n=i.mouseEventToLayerPoint(t.touches[0]),s=i.mouseEventToLayerPoint(t.touches[1]),a=i._getCenterLayerPoint();this._startCenter=n.add(s)._divideBy(2),this._startDist=n.distanceTo(s),this._moved=!1,this._zooming=!0,this._centerOffset=a.subtract(this._startCenter),i._panAnim&&i._panAnim.stop(),o.DomEvent.on(e,"touchmove",this._onTouchMove,this).on(e,"touchend",this._onTouchEnd,this),o.DomEvent.preventDefault(t)}},_onTouchMove:function(t){var e=this._map;if(t.touches&&2===t.touches.length&&this._zooming){var i=e.mouseEventToLayerPoint(t.touches[0]),n=e.mouseEventToLayerPoint(t.touches[1]);this._scale=i.distanceTo(n)/this._startDist,this._delta=i._add(n)._divideBy(2)._subtract(this._startCenter),1!==this._scale&&(e.options.bounceAtZoomLimits||!(e.getZoom()===e.getMinZoom()&&this._scale<1||e.getZoom()===e.getMaxZoom()&&this._scale>1))&&(this._moved||(o.DomUtil.addClass(e._mapPane,"leaflet-touching"),e.fire("movestart").fire("zoomstart"),this._moved=!0),o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updateOnMove,this,!0,this._map._container),o.DomEvent.preventDefault(t))}},_updateOnMove:function(){var t=this._map,e=this._getScaleOrigin(),i=t.layerPointToLatLng(e),n=t.getScaleZoom(this._scale);t._animateZoom(i,n,this._startCenter,this._scale,this._delta,!1,!0)},_onTouchEnd:function(){if(!this._moved||!this._zooming)return void(this._zooming=!1);var t=this._map;this._zooming=!1,o.DomUtil.removeClass(t._mapPane,"leaflet-touching"),o.Util.cancelAnimFrame(this._animRequest),o.DomEvent.off(e,"touchmove",this._onTouchMove).off(e,"touchend",this._onTouchEnd);var i=this._getScaleOrigin(),n=t.layerPointToLatLng(i),s=t.getZoom(),a=t.getScaleZoom(this._scale)-s,r=a>0?Math.ceil(a):Math.floor(a),h=t._limitZoom(s+r),l=t.getZoomScale(h)/this._scale;t._animateZoom(n,h,i,l)},_getScaleOrigin:function(){var t=this._centerOffset.subtract(this._delta).divideBy(this._scale);return this._startCenter.add(t)}}),o.Map.addInitHook("addHandler","touchZoom",o.Map.TouchZoom),o.Map.mergeOptions({tap:!0,tapTolerance:15}),o.Map.Tap=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(o.DomEvent.preventDefault(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],n=i.target;this._startPos=this._newPos=new o.Point(i.clientX,i.clientY),n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._holdTimeout=setTimeout(o.bind(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),o.DomEvent.on(e,"touchmove",this._onMove,this).on(e,"touchend",this._onUp,this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),o.DomEvent.off(e,"touchmove",this._onMove,this).off(e,"touchend",this._onUp,this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],n=i.target;n&&n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.removeClass(n,"leaflet-active"),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var e=t.touches[0];this._newPos=new o.Point(e.clientX,e.clientY)},_simulateEvent:function(i,n){var o=e.createEvent("MouseEvents");o._simulated=!0,n.target._simulatedClick=!0,o.initMouseEvent(i,!0,!0,t,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),n.target.dispatchEvent(o)}}),o.Browser.touch&&!o.Browser.pointer&&o.Map.addInitHook("addHandler","tap",o.Map.Tap),o.Map.mergeOptions({boxZoom:!0}),o.Map.BoxZoom=o.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._moved=!1},addHooks:function(){o.DomEvent.on(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){o.DomEvent.off(this._container,"mousedown",this._onMouseDown),this._moved=!1},moved:function(){return this._moved},_onMouseDown:function(t){return this._moved=!1,!t.shiftKey||1!==t.which&&1!==t.button?!1:(o.DomUtil.disableTextSelection(),o.DomUtil.disableImageDrag(),this._startLayerPoint=this._map.mouseEventToLayerPoint(t),void o.DomEvent.on(e,"mousemove",this._onMouseMove,this).on(e,"mouseup",this._onMouseUp,this).on(e,"keydown",this._onKeyDown,this))},_onMouseMove:function(t){this._moved||(this._box=o.DomUtil.create("div","leaflet-zoom-box",this._pane),o.DomUtil.setPosition(this._box,this._startLayerPoint),this._container.style.cursor="crosshair",this._map.fire("boxzoomstart"));var e=this._startLayerPoint,i=this._box,n=this._map.mouseEventToLayerPoint(t),s=n.subtract(e),a=new o.Point(Math.min(n.x,e.x),Math.min(n.y,e.y));o.DomUtil.setPosition(i,a),this._moved=!0,i.style.width=Math.max(0,Math.abs(s.x)-4)+"px",i.style.height=Math.max(0,Math.abs(s.y)-4)+"px"},_finish:function(){this._moved&&(this._pane.removeChild(this._box),this._container.style.cursor=""),o.DomUtil.enableTextSelection(),o.DomUtil.enableImageDrag(),o.DomEvent.off(e,"mousemove",this._onMouseMove).off(e,"mouseup",this._onMouseUp).off(e,"keydown",this._onKeyDown)},_onMouseUp:function(t){this._finish();var e=this._map,i=e.mouseEventToLayerPoint(t);if(!this._startLayerPoint.equals(i)){var n=new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint),e.layerPointToLatLng(i));e.fitBounds(n),e.fire("boxzoomend",{boxZoomBounds:n})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}}),o.Map.addInitHook("addHandler","boxZoom",o.Map.BoxZoom),o.Map.mergeOptions({keyboard:!0,keyboardPanOffset:80,keyboardZoomOffset:1}),o.Map.Keyboard=o.Handler.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,173]},initialize:function(t){this._map=t,this._setPanOffset(t.options.keyboardPanOffset),this._setZoomOffset(t.options.keyboardZoomOffset)},addHooks:function(){var t=this._map._container;-1===t.tabIndex&&(t.tabIndex="0"),o.DomEvent.on(t,"focus",this._onFocus,this).on(t,"blur",this._onBlur,this).on(t,"mousedown",this._onMouseDown,this),this._map.on("focus",this._addHooks,this).on("blur",this._removeHooks,this)},removeHooks:function(){this._removeHooks();var t=this._map._container;o.DomEvent.off(t,"focus",this._onFocus,this).off(t,"blur",this._onBlur,this).off(t,"mousedown",this._onMouseDown,this),this._map.off("focus",this._addHooks,this).off("blur",this._removeHooks,this)},_onMouseDown:function(){if(!this._focused){var i=e.body,n=e.documentElement,o=i.scrollTop||n.scrollTop,s=i.scrollLeft||n.scrollLeft;this._map._container.focus(),t.scrollTo(s,o)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanOffset:function(t){var e,i,n=this._panKeys={},o=this.keyCodes;for(e=0,i=o.left.length;i>e;e++)n[o.left[e]]=[-1*t,0];for(e=0,i=o.right.length;i>e;e++)n[o.right[e]]=[t,0];for(e=0,i=o.down.length;i>e;e++)n[o.down[e]]=[0,t];for(e=0,i=o.up.length;i>e;e++)n[o.up[e]]=[0,-1*t]},_setZoomOffset:function(t){var e,i,n=this._zoomKeys={},o=this.keyCodes;for(e=0,i=o.zoomIn.length;i>e;e++)n[o.zoomIn[e]]=t;for(e=0,i=o.zoomOut.length;i>e;e++)n[o.zoomOut[e]]=-t},_addHooks:function(){o.DomEvent.on(e,"keydown",this._onKeyDown,this)},_removeHooks:function(){o.DomEvent.off(e,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){var e=t.keyCode,i=this._map;if(e in this._panKeys){if(i._panAnim&&i._panAnim._inProgress)return;i.panBy(this._panKeys[e]),i.options.maxBounds&&i.panInsideBounds(i.options.maxBounds)}else{if(!(e in this._zoomKeys))return;i.setZoom(i.getZoom()+this._zoomKeys[e])}o.DomEvent.stop(t)}}),o.Map.addInitHook("addHandler","keyboard",o.Map.Keyboard),o.Handler.MarkerDrag=o.Handler.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new o.Draggable(t,t)),this._draggable.on("dragstart",this._onDragStart,this).on("drag",this._onDrag,this).on("dragend",this._onDragEnd,this),this._draggable.enable(),o.DomUtil.addClass(this._marker._icon,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off("dragstart",this._onDragStart,this).off("drag",this._onDrag,this).off("dragend",this._onDragEnd,this),this._draggable.disable(),o.DomUtil.removeClass(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){this._marker.closePopup().fire("movestart").fire("dragstart")},_onDrag:function(){var t=this._marker,e=t._shadow,i=o.DomUtil.getPosition(t._icon),n=t._map.layerPointToLatLng(i);e&&o.DomUtil.setPosition(e,i),t._latlng=n,t.fire("move",{latlng:n}).fire("drag")},_onDragEnd:function(t){this._marker.fire("moveend").fire("dragend",t)}}),o.Control=o.Class.extend({options:{position:"topright"},initialize:function(t){o.setOptions(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),n=t._controlCorners[i];return o.DomUtil.addClass(e,"leaflet-control"),-1!==i.indexOf("bottom")?n.insertBefore(e,n.firstChild):n.appendChild(e),this},removeFrom:function(t){var e=this.getPosition(),i=t._controlCorners[e];return i.removeChild(this._container),this._map=null,this.onRemove&&this.onRemove(t),this},_refocusOnMap:function(){this._map&&this._map.getContainer().focus()}}),o.control=function(t){return new o.Control(t)},o.Map.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.removeFrom(this),this},_initControlPos:function(){function t(t,s){var a=i+t+" "+i+s;e[t+s]=o.DomUtil.create("div",a,n)}var e=this._controlCorners={},i="leaflet-",n=this._controlContainer=o.DomUtil.create("div",i+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){this._container.removeChild(this._controlContainer)}}),o.Control.Zoom=o.Control.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"-",zoomOutTitle:"Zoom out"},onAdd:function(t){var e="leaflet-control-zoom",i=o.DomUtil.create("div",e+" leaflet-bar");return this._map=t,this._zoomInButton=this._createButton(this.options.zoomInText,this.options.zoomInTitle,e+"-in",i,this._zoomIn,this),this._zoomOutButton=this._createButton(this.options.zoomOutText,this.options.zoomOutTitle,e+"-out",i,this._zoomOut,this),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},_zoomIn:function(t){this._map.zoomIn(t.shiftKey?3:1)},_zoomOut:function(t){this._map.zoomOut(t.shiftKey?3:1)},_createButton:function(t,e,i,n,s,a){var r=o.DomUtil.create("a",i,n);r.innerHTML=t,r.href="#",r.title=e;var h=o.DomEvent.stopPropagation;return o.DomEvent.on(r,"click",h).on(r,"mousedown",h).on(r,"dblclick",h).on(r,"click",o.DomEvent.preventDefault).on(r,"click",s,a).on(r,"click",this._refocusOnMap,a),r},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";o.DomUtil.removeClass(this._zoomInButton,e),o.DomUtil.removeClass(this._zoomOutButton,e),t._zoom===t.getMinZoom()&&o.DomUtil.addClass(this._zoomOutButton,e),t._zoom===t.getMaxZoom()&&o.DomUtil.addClass(this._zoomInButton,e)}}),o.Map.mergeOptions({zoomControl:!0}),o.Map.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new o.Control.Zoom,this.addControl(this.zoomControl))}),o.control.zoom=function(t){return new o.Control.Zoom(t)},o.Control.Attribution=o.Control.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){o.setOptions(this,t),this._attributions={}},onAdd:function(t){this._container=o.DomUtil.create("div","leaflet-control-attribution"),o.DomEvent.disableClickPropagation(this._container);for(var e in t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());return t.on("layeradd",this._onLayerAdd,this).on("layerremove",this._onLayerRemove,this),this._update(),this._container},onRemove:function(t){t.off("layeradd",this._onLayerAdd).off("layerremove",this._onLayerRemove)},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):void 0},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):void 0},_update:function(){if(this._map){var t=[];for(var e in this._attributions)this._attributions[e]&&t.push(e);var i=[];this.options.prefix&&i.push(this.options.prefix),t.length&&i.push(t.join(", ")),this._container.innerHTML=i.join(" | ")}},_onLayerAdd:function(t){t.layer.getAttribution&&this.addAttribution(t.layer.getAttribution())},_onLayerRemove:function(t){t.layer.getAttribution&&this.removeAttribution(t.layer.getAttribution())}}),o.Map.mergeOptions({attributionControl:!0}),o.Map.addInitHook(function(){this.options.attributionControl&&(this.attributionControl=(new o.Control.Attribution).addTo(this))}),o.control.attribution=function(t){return new o.Control.Attribution(t)},o.Control.Scale=o.Control.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0,updateWhenIdle:!1},onAdd:function(t){this._map=t;var e="leaflet-control-scale",i=o.DomUtil.create("div",e),n=this.options;return this._addScales(n,e,i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=o.DomUtil.create("div",e+"-line",i)),t.imperial&&(this._iScale=o.DomUtil.create("div",e+"-line",i))},_update:function(){var t=this._map.getBounds(),e=t.getCenter().lat,i=6378137*Math.PI*Math.cos(e*Math.PI/180),n=i*(t.getNorthEast().lng-t.getSouthWest().lng)/180,o=this._map.getSize(),s=this.options,a=0;o.x>0&&(a=n*(s.maxWidth/o.x)),this._updateScales(s,a)},_updateScales:function(t,e){t.metric&&e&&this._updateMetric(e),t.imperial&&e&&this._updateImperial(e)},_updateMetric:function(t){var e=this._getRoundNum(t);this._mScale.style.width=this._getScaleWidth(e/t)+"px",this._mScale.innerHTML=1e3>e?e+" m":e/1e3+" km"},_updateImperial:function(t){var e,i,n,o=3.2808399*t,s=this._iScale;o>5280?(e=o/5280,i=this._getRoundNum(e),s.style.width=this._getScaleWidth(i/e)+"px",s.innerHTML=i+" mi"):(n=this._getRoundNum(o),s.style.width=this._getScaleWidth(n/o)+"px",s.innerHTML=n+" ft")},_getScaleWidth:function(t){return Math.round(this.options.maxWidth*t)-10},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),i=t/e;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:1,e*i}}),o.control.scale=function(t){return new o.Control.Scale(t)},o.Control.Layers=o.Control.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0},initialize:function(t,e,i){o.setOptions(this,i),this._layers={},this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){return this._initLayout(),this._update(),t.on("layeradd",this._onLayerChange,this).on("layerremove",this._onLayerChange,this),this._container},onRemove:function(t){t.off("layeradd",this._onLayerChange,this).off("layerremove",this._onLayerChange,this)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._update(),this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._update(),this},removeLayer:function(t){var e=o.stamp(t);return delete this._layers[e],this._update(),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=o.DomUtil.create("div",t);e.setAttribute("aria-haspopup",!0),o.Browser.touch?o.DomEvent.on(e,"click",o.DomEvent.stopPropagation):o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);var i=this._form=o.DomUtil.create("form",t+"-list");if(this.options.collapsed){o.Browser.android||o.DomEvent.on(e,"mouseover",this._expand,this).on(e,"mouseout",this._collapse,this);var n=this._layersLink=o.DomUtil.create("a",t+"-toggle",e);n.href="#",n.title="Layers",o.Browser.touch?o.DomEvent.on(n,"click",o.DomEvent.stop).on(n,"click",this._expand,this):o.DomEvent.on(n,"focus",this._expand,this),o.DomEvent.on(i,"click",function(){setTimeout(o.bind(this._onInputClick,this),0)},this),this._map.on("click",this._collapse,this)}else this._expand();this._baseLayersList=o.DomUtil.create("div",t+"-base",i),this._separator=o.DomUtil.create("div",t+"-separator",i),this._overlaysList=o.DomUtil.create("div",t+"-overlays",i),e.appendChild(i)},_addLayer:function(t,e,i){var n=o.stamp(t);this._layers[n]={layer:t,name:e,overlay:i},this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex))},_update:function(){if(this._container){this._baseLayersList.innerHTML="",this._overlaysList.innerHTML="";var t,e,i=!1,n=!1;for(t in this._layers)e=this._layers[t],this._addItem(e),n=n||e.overlay,i=i||!e.overlay;this._separator.style.display=n&&i?"":"none"}},_onLayerChange:function(t){var e=this._layers[o.stamp(t.layer)];if(e){this._handlingClick||this._update();var i=e.overlay?"layeradd"===t.type?"overlayadd":"overlayremove":"layeradd"===t.type?"baselayerchange":null;i&&this._map.fire(i,e)}},_createRadioElement:function(t,i){var n='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"';i&&(n+=' checked="checked"'),n+="/>";var o=e.createElement("div");return o.innerHTML=n,o.firstChild},_addItem:function(t){var i,n=e.createElement("label"),s=this._map.hasLayer(t.layer);t.overlay?(i=e.createElement("input"),i.type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=s):i=this._createRadioElement("leaflet-base-layers",s),i.layerId=o.stamp(t.layer),o.DomEvent.on(i,"click",this._onInputClick,this);var a=e.createElement("span");a.innerHTML=" "+t.name,n.appendChild(i),n.appendChild(a);var r=t.overlay?this._overlaysList:this._baseLayersList;return r.appendChild(n),n},_onInputClick:function(){var t,e,i,n=this._form.getElementsByTagName("input"),o=n.length;for(this._handlingClick=!0,t=0;o>t;t++)e=n[t],i=this._layers[e.layerId],e.checked&&!this._map.hasLayer(i.layer)?this._map.addLayer(i.layer):!e.checked&&this._map.hasLayer(i.layer)&&this._map.removeLayer(i.layer);this._handlingClick=!1,this._refocusOnMap()},_expand:function(){o.DomUtil.addClass(this._container,"leaflet-control-layers-expanded")},_collapse:function(){this._container.className=this._container.className.replace(" leaflet-control-layers-expanded","")}}),o.control.layers=function(t,e,i){return new o.Control.Layers(t,e,i)},o.PosAnimation=o.Class.extend({includes:o.Mixin.Events,run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._newPos=e,this.fire("start"),t.style[o.DomUtil.TRANSITION]="all "+(i||.25)+"s cubic-bezier(0,0,"+(n||.5)+",1)",o.DomEvent.on(t,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),o.DomUtil.setPosition(t,e),o.Util.falseFn(t.offsetWidth),this._stepTimer=setInterval(o.bind(this._onStep,this),50)},stop:function(){this._inProgress&&(o.DomUtil.setPosition(this._el,this._getPos()),this._onTransitionEnd(),o.Util.falseFn(this._el.offsetWidth))},_onStep:function(){var t=this._getPos();return t?(this._el._leaflet_pos=t,void this.fire("step")):void this._onTransitionEnd()},_transformRe:/([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,_getPos:function(){var e,i,n,s=this._el,a=t.getComputedStyle(s);if(o.Browser.any3d){if(n=a[o.DomUtil.TRANSFORM].match(this._transformRe),!n)return;e=parseFloat(n[1]),i=parseFloat(n[2])}else e=parseFloat(a.left),i=parseFloat(a.top);return new o.Point(e,i,!0)},_onTransitionEnd:function(){o.DomEvent.off(this._el,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),this._inProgress&&(this._inProgress=!1,this._el.style[o.DomUtil.TRANSITION]="",this._el._leaflet_pos=this._newPos,clearInterval(this._stepTimer),this.fire("step").fire("end"))}}),o.Map.include({setView:function(t,e,n){if(e=e===i?this._zoom:this._limitZoom(e),t=this._limitCenter(o.latLng(t),e,this.options.maxBounds),n=n||{},this._panAnim&&this._panAnim.stop(),this._loaded&&!n.reset&&n!==!0){n.animate!==i&&(n.zoom=o.extend({animate:n.animate},n.zoom),n.pan=o.extend({animate:n.animate},n.pan));var s=this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan);if(s)return clearTimeout(this._sizeTimer),this}return this._resetView(t,e),this},panBy:function(t,e){if(t=o.point(t).round(),e=e||{},!t.x&&!t.y)return this;if(this._panAnim||(this._panAnim=new o.PosAnimation,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),e.animate!==!1){o.DomUtil.addClass(this._mapPane,"leaflet-pan-anim");var i=this._getMapPanePos().subtract(t);this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){o.DomUtil.removeClass(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){var i=this._getCenterOffset(t)._floor();return(e&&e.animate)===!0||this.getSize().contains(i)?(this.panBy(i,e),!0):!1}}),o.PosAnimation=o.DomUtil.TRANSITION?o.PosAnimation:o.PosAnimation.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=o.DomUtil.getPosition(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(),this._complete())},_animate:function(){this._animId=o.Util.requestAnimFrame(this._animate,this),this._step()},_step:function(){var t=+new Date-this._startTime,e=1e3*this._duration;e>t?this._runFrame(this._easeOut(t/e)):(this._runFrame(1),this._complete())},_runFrame:function(t){var e=this._startPos.add(this._offset.multiplyBy(t));o.DomUtil.setPosition(this._el,e),this.fire("step")},_complete:function(){o.Util.cancelAnimFrame(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),o.Map.mergeOptions({zoomAnimation:!0,zoomAnimationThreshold:4}),o.DomUtil.TRANSITION&&o.Map.addInitHook(function(){this._zoomAnimated=this.options.zoomAnimation&&o.DomUtil.TRANSITION&&o.Browser.any3d&&!o.Browser.android23&&!o.Browser.mobileOpera,this._zoomAnimated&&o.DomEvent.on(this._mapPane,o.DomUtil.TRANSITION_END,this._catchTransitionEnd,this)}),o.Map.include(o.DomUtil.TRANSITION?{_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(this._animatingZoom)return!0;if(i=i||{},!this._zoomAnimated||i.animate===!1||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),o=this._getCenterOffset(t)._divideBy(1-1/n),s=this._getCenterLayerPoint()._add(o);return i.animate===!0||this.getSize().contains(o)?(this.fire("movestart").fire("zoomstart"),this._animateZoom(t,e,s,n,null,!0),!0):!1},_animateZoom:function(t,e,i,n,s,a,r){r||(this._animatingZoom=!0),o.DomUtil.addClass(this._mapPane,"leaflet-zoom-anim"),this._animateToCenter=t,this._animateToZoom=e,o.Draggable&&(o.Draggable._disabled=!0),o.Util.requestAnimFrame(function(){this.fire("zoomanim",{center:t,zoom:e,origin:i,scale:n,delta:s,backwards:a})},this)},_onZoomTransitionEnd:function(){this._animatingZoom=!1,o.DomUtil.removeClass(this._mapPane,"leaflet-zoom-anim"),this._resetView(this._animateToCenter,this._animateToZoom,!0,!0),o.Draggable&&(o.Draggable._disabled=!1)}}:{}),o.TileLayer.include({_animateZoom:function(t){this._animating||(this._animating=!0,this._prepareBgBuffer());var e=this._bgBuffer,i=o.DomUtil.TRANSFORM,n=t.delta?o.DomUtil.getTranslateString(t.delta):e.style[i],s=o.DomUtil.getScaleString(t.scale,t.origin);e.style[i]=t.backwards?s+" "+n:n+" "+s},_endZoomAnim:function(){var t=this._tileContainer,e=this._bgBuffer;t.style.visibility="",t.parentNode.appendChild(t),o.Util.falseFn(e.offsetWidth),this._animating=!1},_clearBgBuffer:function(){var t=this._map;!t||t._animatingZoom||t.touchZoom._zooming||(this._bgBuffer.innerHTML="",this._bgBuffer.style[o.DomUtil.TRANSFORM]="")},_prepareBgBuffer:function(){var t=this._tileContainer,e=this._bgBuffer,i=this._getLoadedTilesPercentage(e),n=this._getLoadedTilesPercentage(t);return e&&i>.5&&.5>n?(t.style.visibility="hidden",void this._stopLoadingImages(t)):(e.style.visibility="hidden",e.style[o.DomUtil.TRANSFORM]="",this._tileContainer=e,e=this._bgBuffer=t,this._stopLoadingImages(e),void clearTimeout(this._clearBgBufferTimer))},_getLoadedTilesPercentage:function(t){var e,i,n=t.getElementsByTagName("img"),o=0;for(e=0,i=n.length;i>e;e++)n[e].complete&&o++;return o/i},_stopLoadingImages:function(t){var e,i,n,s=Array.prototype.slice.call(t.getElementsByTagName("img"));for(e=0,i=s.length;i>e;e++)n=s[e],n.complete||(n.onload=o.Util.falseFn,n.onerror=o.Util.falseFn,n.src=o.Util.emptyImageUrl,n.parentNode.removeChild(n))}}),o.Map.include({_defaultLocateOptions:{watch:!1,setView:!1,maxZoom:1/0,timeout:1e4,maximumAge:0,enableHighAccuracy:!1},locate:function(t){if(t=this._locateOptions=o.extend(this._defaultLocateOptions,t),!navigator.geolocation)return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var e=o.bind(this._handleGeolocationResponse,this),i=o.bind(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e=t.code,i=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+i+"."})},_handleGeolocationResponse:function(t){var e=t.coords.latitude,i=t.coords.longitude,n=new o.LatLng(e,i),s=180*t.coords.accuracy/40075017,a=s/Math.cos(o.LatLng.DEG_TO_RAD*e),r=o.latLngBounds([e-s,i-a],[e+s,i+a]),h=this._locateOptions;if(h.setView){var l=Math.min(this.getBoundsZoom(r),h.maxZoom);this.setView(n,l)}var u={latlng:n,bounds:r,timestamp:t.timestamp};for(var c in t.coords)"number"==typeof t.coords[c]&&(u[c]=t.coords[c]);this.fire("locationfound",u)}})}(window,document);
\ No newline at end of file
diff --git a/web/src/main/webapp/js/leaflet.loading.js b/web/src/main/webapp/js/leaflet.loading.js
new file mode 100644
index 0000000000..16683d26ef
--- /dev/null
+++ b/web/src/main/webapp/js/leaflet.loading.js
@@ -0,0 +1,262 @@
+/*
+ * L.Control.Loading is a control that shows a loading indicator when tiles are
+ * loading or when map-related AJAX requests are taking place.
+ */
+
+(function () {
+
+    function defineLeafletLoading(L) {
+        L.Control.Loading = L.Control.extend({
+            options: {
+                position: 'topleft',
+                separate: false,
+                zoomControl: null,
+                spinjs: false,
+                spin: { 
+                  lines: 7, 
+                  length: 3, 
+                  width: 3, 
+                  radius: 5, 
+                  rotate: 13, 
+                  top: "83%"
+                }
+            },
+
+            initialize: function(options) {
+                L.setOptions(this, options);
+                this._dataLoaders = {};
+
+                // Try to set the zoom control this control is attached to from the 
+                // options
+                if (this.options.zoomControl !== null) {
+                    this.zoomControl = this.options.zoomControl;
+                }
+            },
+
+            onAdd: function(map) {
+                if (this.options.spinjs && (typeof Spinner !== 'function')) {
+                    return console.error("Leaflet.loading cannot load because you didn't load spin.js (http://fgnass.github.io/spin.js/), even though you set it in options.");
+                }
+                this._addLayerListeners(map);
+                this._addMapListeners(map);
+
+                // Try to set the zoom control this control is attached to from the map
+                // the control is being added to
+                if (!this.options.separate && !this.zoomControl) {
+                    if (map.zoomControl) {
+                        this.zoomControl = map.zoomControl;
+                    } else if (map.zoomsliderControl) {
+                        this.zoomControl = map.zoomsliderControl;
+                    }
+                }
+
+                // Create the loading indicator
+                var classes = 'leaflet-control-loading';
+                var container;
+                if (this.zoomControl && !this.options.separate) {
+                    // If there is a zoom control, hook into the bottom of it
+                    container = this.zoomControl._container;
+                    // These classes are no longer used as of Leaflet 0.6
+                    classes += ' leaflet-bar-part-bottom leaflet-bar-part last';
+                }
+                else {
+                    // Otherwise, create a container for the indicator
+                    container = L.DomUtil.create('div', 'leaflet-control-zoom leaflet-bar');
+                }
+                this._indicator = L.DomUtil.create('a', classes, container);
+                if (this.options.spinjs) {
+                  this._spinner = new Spinner(this.options.spin).spin();
+                  this._indicator.appendChild(this._spinner.el);
+                }
+                return container;
+            },
+
+            onRemove: function(map) {
+                this._removeLayerListeners(map);
+                this._removeMapListeners(map);
+            },
+
+            removeFrom: function (map) {
+                if (this.zoomControl && !this.options.separate) {
+                    // Override Control.removeFrom() to avoid clobbering the entire
+                    // _container, which is the same as zoomControl's
+                    this._container.removeChild(this._indicator);
+                    this._map = null;
+                    this.onRemove(map);
+                    return this;
+                }
+                else {
+                    // If this control is separate from the zoomControl, call the
+                    // parent method so we don't leave behind an empty container
+                    return L.Control.prototype.removeFrom.call(this, map);
+                }
+            },
+
+            addLoader: function(id) {
+                this._dataLoaders[id] = true;
+                this.updateIndicator();
+            },
+
+            removeLoader: function(id) {
+                delete this._dataLoaders[id];
+                this.updateIndicator();
+            },
+
+            updateIndicator: function() {
+                if (this.isLoading()) {
+                    this._showIndicator();
+                }
+                else {
+                    this._hideIndicator();
+                }
+            },
+
+            isLoading: function() {
+                return this._countLoaders() > 0;
+            },
+
+            _countLoaders: function() {
+                var size = 0, key;
+                for (key in this._dataLoaders) {
+                    if (this._dataLoaders.hasOwnProperty(key)) size++;
+                }
+                return size;
+            },
+
+            _showIndicator: function() {
+                // Show loading indicator
+                L.DomUtil.addClass(this._indicator, 'is-loading');
+
+                // If zoomControl exists, make the zoom-out button not last
+                if (!this.options.separate) {
+                    if (this.zoomControl instanceof L.Control.Zoom) {
+                        L.DomUtil.removeClass(this.zoomControl._zoomOutButton, 'leaflet-bar-part-bottom');
+                    }
+                    else if (typeof L.Control.Zoomslider === 'function' && this.zoomControl instanceof L.Control.Zoomslider) {
+                        L.DomUtil.removeClass(this.zoomControl._ui.zoomOut, 'leaflet-bar-part-bottom');
+                    }
+                }
+            },
+
+            _hideIndicator: function() {
+                // Hide loading indicator
+                L.DomUtil.removeClass(this._indicator, 'is-loading');
+
+                // If zoomControl exists, make the zoom-out button last
+                if (!this.options.separate) {
+                    if (this.zoomControl instanceof L.Control.Zoom) {
+                        L.DomUtil.addClass(this.zoomControl._zoomOutButton, 'leaflet-bar-part-bottom');
+                    }
+                    else if (typeof L.Control.Zoomslider === 'function' && this.zoomControl instanceof L.Control.Zoomslider) {
+                        L.DomUtil.addClass(this.zoomControl._ui.zoomOut, 'leaflet-bar-part-bottom');
+                    }
+                }
+            },
+
+            _handleLoading: function(e) {
+                this.addLoader(this.getEventId(e));
+            },
+
+            _handleLoad: function(e) {
+                this.removeLoader(this.getEventId(e));
+            },
+
+            getEventId: function(e) {
+                if (e.id) {
+                    return e.id;
+                }
+                else if (e.layer) {
+                    return e.layer._leaflet_id;
+                }
+                return e.target._leaflet_id;
+            },
+
+            _layerAdd: function(e) {
+                if (!e.layer || !e.layer.on) return
+                try {
+                    e.layer.on({
+                        loading: this._handleLoading,
+                        load: this._handleLoad
+                    }, this);
+                }
+                catch (exception) {
+                    console.warn('L.Control.Loading: Tried and failed to add ' +
+                                 ' event handlers to layer', e.layer);
+                    console.warn('L.Control.Loading: Full details', exception);
+                }
+            },
+
+            _addLayerListeners: function(map) {
+                // Add listeners for begin and end of load to any layers already on the 
+                // map
+                map.eachLayer(function(layer) {
+                    if (!layer.on) return;
+                    layer.on({
+                        loading: this._handleLoading,
+                        load: this._handleLoad
+                    }, this);
+                }, this);
+
+                // When a layer is added to the map, add listeners for begin and end
+                // of load
+                map.on('layeradd', this._layerAdd, this);
+            },
+
+            _removeLayerListeners: function(map) {
+                // Remove listeners for begin and end of load from all layers
+                map.eachLayer(function(layer) {
+                    if (!layer.off) return;
+                    layer.off({
+                        loading: this._handleLoading,
+                        load: this._handleLoad
+                    }, this);
+                }, this);
+
+                // Remove layeradd listener from map
+                map.off('layeradd', this._layerAdd, this);
+            },
+
+            _addMapListeners: function(map) {
+                // Add listeners to the map for (custom) dataloading and dataload
+                // events, eg, for AJAX calls that affect the map but will not be
+                // reflected in the above layer events.
+                map.on({
+                    dataloading: this._handleLoading,
+                    dataload: this._handleLoad,
+                    layerremove: this._handleLoad
+                }, this);
+            },
+
+            _removeMapListeners: function(map) {
+                map.off({
+                    dataloading: this._handleLoading,
+                    dataload: this._handleLoad,
+                    layerremove: this._handleLoad
+                }, this);
+            }
+        });
+
+        L.Map.addInitHook(function () {
+            if (this.options.loadingControl) {
+                this.loadingControl = new L.Control.Loading();
+                this.addControl(this.loadingControl);
+            }
+        });
+
+        L.Control.loading = function(options) {
+            return new L.Control.Loading(options);
+        };
+    }
+
+    if (typeof define === 'function' && define.amd) {
+        // Try to add leaflet.loading to Leaflet using AMD
+        define(['leaflet'], function (L) {
+            defineLeafletLoading(L);
+        });
+    }
+    else {
+        // Else use the global L
+        defineLeafletLoading(L);
+    }
+
+})();
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index c7fed9fce7..ccb560fb7c 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -1,12 +1,12 @@
-/*
- * If you want to query another API append this something like
- * &host=http://graphhopper.com/routing
- * to the URL or overwrite the 'host' variable.
- */
-var tmpArgs = parseUrlWithHisto();
-var host = tmpArgs["host"];
-//var host = "http://graphhopper.com/routing";
-if (host == null) {
+var host;
+
+// Deployment-scripts can insert host here.
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
+// Our routing service is also free for certain applications or smaller volume. Be fair, grab an API key and support us:
+// https://graphhopper.com/#directions-api Misuse of API keys that you don't own is prohibited and you'll be blocked.                    
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+if (!host) {
     if (location.port === '') {
         host = location.protocol + '//' + location.hostname;
     } else {
@@ -17,17 +17,20 @@ if (host == null) {
 var ghRequest = new GHRequest(host);
 var bounds = {};
 
-//var nominatim = "http://open.mapquestapi.com/nominatim/v1/search.php";
-//var nominatim_reverse = "http://open.mapquestapi.com/nominatim/v1/reverse.php";
-var nominatim = "http://nominatim.openstreetmap.org/search";
-var nominatim_reverse = "http://nominatim.openstreetmap.org/reverse";
+var nominatimURL = "https://nominatim.openstreetmap.org/search";
+var nominatimReverseURL = "https://nominatim.openstreetmap.org/reverse";
 var routingLayer;
 var map;
-var browserTitle = "GraphHopper Maps";
-var firstClickToRoute;
+var menuStart;
+var menuIntermediate;
+var menuEnd;
+var browserTitle = "GraphHopper Maps - Driving Directions";
 var defaultTranslationMap = null;
 var enTranslationMap = null;
 var routeSegmentPopup = null;
+var elevationControl = null;
+var activeLayer = 'Lyrk';
+var i18nIsInitialized;
 
 var iconFrom = L.icon({
     iconUrl: './img/marker-icon-green.png',
@@ -43,29 +46,40 @@ var iconTo = L.icon({
     iconAnchor: [12, 40]
 });
 
-$(document).ready(function(e) {
+var iconInt = L.icon({
+    iconUrl: './img/marker-icon-blue.png',
+    shadowSize: [50, 64],
+    shadowAnchor: [4, 62],
+    iconAnchor: [12, 40]
+});
+
+$(document).ready(function (e) {
     // fixing cross domain support e.g in Opera
     jQuery.support.cors = true;
+
+    if (isProduction())
+        $('#hosting').show();
+
     var History = window.History;
     if (History.enabled) {
-        History.Adapter.bind(window, 'statechange', function() {
+        History.Adapter.bind(window, 'statechange', function () {
             // No need for workaround?
             // Chrome and Safari always emit a popstate event on page load, but Firefox doesn’t
             // https://github.com/defunkt/jquery-pjax/issues/143#issuecomment-6194330
 
             var state = History.getState();
-            console.log(state);
+            log(state);
             initFromParams(state.data, true);
         });
     }
 
-    $('#locationform').submit(function(e) {
+    $('#locationform').submit(function (e) {
         // no page reload
         e.preventDefault();
         mySubmit();
     });
 
-    $('#gpxExportButton a').click(function(e) {
+    $('#gpxExportButton a').click(function (e) {
         // no page reload
         e.preventDefault();
         exportGPX();
@@ -73,7 +87,7 @@ $(document).ready(function(e) {
 
     var urlParams = parseUrlWithHisto();
     $.when(ghRequest.fetchTranslationMap(urlParams.locale), ghRequest.getInfo())
-            .then(function(arg1, arg2) {
+            .then(function (arg1, arg2) {
                 // init translation retrieved from first call (fetchTranslationMap)
                 var translations = arg1[0];
 
@@ -83,9 +97,10 @@ $(document).ready(function(e) {
                 ghRequest.setLocale(translations["locale"]);
                 defaultTranslationMap = translations["default"];
                 enTranslationMap = translations["en"];
-                if (defaultTranslationMap == null)
+                if (!defaultTranslationMap)
                     defaultTranslationMap = enTranslationMap;
 
+                i18nIsInitialized = true;
                 initI18N();
 
                 // init bounding box from getInfo result
@@ -98,41 +113,37 @@ $(document).ready(function(e) {
                 bounds.maxLat = tmp[3];
                 var vehiclesDiv = $("#vehicles");
                 function createButton(vehicle) {
-                    vehicle = vehicle.toLowerCase();
-                    var button = $("<button class='vehicle-btn' title='" + tr(vehicle) + "'/>")
+                    var button = $("<button class='vehicle-btn' title='" + tr(vehicle) + "'/>");
                     button.attr('id', vehicle);
                     button.html("<img src='img/" + vehicle + ".png' alt='" + tr(vehicle) + "'></img>");
-                    button.click(function() {
-                        ghRequest.vehicle = vehicle;
-                        resolveFrom();
-                        resolveTo();
+                    button.click(function () {
+                        ghRequest.initVehicle(vehicle);
+                        resolveAll()
                         routeLatLng(ghRequest);
                     });
                     return button;
                 }
 
-                if (json.supportedVehicles) {
-                    var vehicles = json.supportedVehicles.split(",");
-                    if (vehicles.length > 1)
-                        ghRequest.vehicle = vehicles[0];
-                    for (var i = 0; i < vehicles.length; i++) {
-                        vehiclesDiv.append(createButton(vehicles[i]));
+                if (json.features) {
+                    ghRequest.features = json.features;
+
+                    var vehicles = Object.keys(json.features);
+                    if (vehicles.length > 0)
+                        ghRequest.initVehicle(vehicles[0]);
+
+                    for (var key in json.features) {
+                        vehiclesDiv.append(createButton(key.toLowerCase()));
                     }
                 }
 
-                initMap();
-
-//        var data = JSON.parse("[[10.4049076,48.2802518],[10.405231,48.2801396],...]");
-//        var tempFeature = {
-//            "type": "Feature", "geometry": { "type": "LineString", "coordinates": data }
-//        };        
-//        routingLayer.addData(tempFeature);
+                initMap(urlParams.layer);
 
                 // execute query
                 initFromParams(urlParams, true);
-            }, function(err) {
-                console.log(err);
-                $('#error').html('GraphHopper API offline? ' + host);
+            }, function (err) {
+                log(err);
+                $('#error').html('GraphHopper API offline? <a href="http://graphhopper.com/maps">Refresh</a>'
+                        + '<br/>Status: ' + err.statusText + '<br/>' + host);
 
                 bounds = {
                     "minLon": -180,
@@ -142,154 +153,322 @@ $(document).ready(function(e) {
                 };
                 initMap();
             });
+
+    $(window).resize(function () {
+        adjustMapSize();
+    });
+    $("#locationpoints").sortable({
+        items: ".pointDiv",
+        cursor: "n-resize",
+        containment: "parent",
+        handle: ".pointFlag",
+        update: function (event, ui) {
+            var origin_index = $(ui.item[0]).data('index');
+            sortable_items = $("#locationpoints > div.pointDiv");
+            $(sortable_items).each(function (index) {
+                var data_index = $(this).data('index');
+                if (origin_index === data_index) {
+                    //log(data_index +'>'+ index);
+                    ghRequest.route.move(data_index, index);
+                    if (!routeIfAllResolved())
+                        checkInput();
+                    return false;
+                }
+            });
+        }
+    });
+
+    $('#locationpoints > div.pointAdd').click(function () {
+        ghRequest.route.add(new GHInput());
+        checkInput();
+    });
+
+    checkInput();
 });
 
 function initFromParams(params, doQuery) {
     ghRequest.init(params);
-    var fromAndTo = params.from && params.to;
-    var routeNow = params.point && params.point.length == 2 || fromAndTo;
+    var fromAndTo = params.from && params.to,
+            routeNow = params.point && params.point.length >= 2 || fromAndTo;
+
     if (routeNow) {
         if (fromAndTo)
-            resolveCoords(params.from, params.to, doQuery);
+            resolveCoords([params.from, params.to], doQuery);
         else
-            resolveCoords(params.point[0], params.point[1], doQuery);
+            resolveCoords(params.point, doQuery);
+    } else if (params.point && params.point.length === 1) {
+        ghRequest.from = new GHInput(params.point[0]);
+        resolve("from", ghRequest.from);
+        focus(ghRequest.from, 15, true);
     }
 }
 
-function resolveCoords(fromStr, toStr, doQuery) {
-    if (fromStr !== ghRequest.from.input || !ghRequest.from.isResolved())
-        ghRequest.from = new GHInput(fromStr);
+function resolveCoords(pointsAsStr, doQuery) {
+    for (var i = 0, l = pointsAsStr.length; i < l; i++) {
+        var pointStr = pointsAsStr[i];
+        var coords = ghRequest.route.getIndex(i);
+        if (!coords || pointStr !== coords.input || !coords.isResolved())
+            ghRequest.route.set(pointStr, i, true);
+    }
 
-    if (toStr !== ghRequest.to.input || !ghRequest.to.isResolved())
-        ghRequest.to = new GHInput(toStr);
+    checkInput();
 
-    if (ghRequest.from.lat && ghRequest.to.lat) {
-        // two mouse clicks into the map -> do not wait for resolve
-        resolveFrom();
-        resolveTo();
+    if (ghRequest.route.isResolved()) {
+        resolveAll();
         routeLatLng(ghRequest, doQuery);
     } else {
         // at least one text input from user -> wait for resolve as we need the coord for routing     
-        $.when(resolveFrom(), resolveTo()).done(function(fromArgs, toArgs) {
+        $.when.apply($, resolveAll()).done(function () {
             routeLatLng(ghRequest, doQuery);
         });
     }
 }
 
-function initMap() {
+function checkInput() {
+    var template = $('#pointTemplate').html(),
+            len = ghRequest.route.size();
+
+    // remove deleted points
+    if ($('#locationpoints > div.pointDiv').length > len) {
+        $('#locationpoints > div.pointDiv:gt(' + (len - 1) + ')').remove();
+    }
+
+    // properly unbind previously click handlers
+    $("#locationpoints .pointDelete").off();
+
+    // console.log("## new checkInput");
+    for (var i = 0; i < len; i++) {
+        var div = $('#locationpoints > div.pointDiv').eq(i);
+        // console.log(div.length + ", index:" + i + ", len:" + len);
+        if (div.length === 0) {
+            $('#locationpoints > div.pointAdd').before(nanoTemplate(template, {id: i}));
+            div = $('#locationpoints > div.pointDiv').eq(i);
+        }
+
+        var toFrom = getToFrom(i);
+        div.data("index", i);
+        div.find(".pointFlag").attr("src",
+                (toFrom === FROM) ? 'img/marker-small-green.png' :
+                ((toFrom === TO) ? 'img/marker-small-red.png' : 'img/marker-small-blue.png'));
+        if (len > 2) {
+            div.find(".pointDelete").click(function () {
+                var index = $(this).parent().data('index');
+                ghRequest.route.removeSingle(index);
+                routingLayer.clearLayers();
+                routeLatLng(ghRequest, false);
+            }).show();
+        } else {
+            div.find(".pointDelete").hide();
+        }
+
+        setAutoCompleteList(i);
+        if (i18nIsInitialized) {
+            var input = div.find(".pointInput");
+            if (i === 0)
+                $(input).attr("placeholder", tr("fromHint"));
+            else if (i === (len - 1))
+                $(input).attr("placeholder", tr("toHint"));
+            else
+                $(input).attr("placeholder", tr("viaHint"));
+        }
+    }
+
+    adjustMapSize();
+}
+
+function nanoTemplate(template, data) {
+    return template.replace(/\{([\w\.]*)\}/g, function (str, key) {
+        var keys = key.split("."), v = data[keys.shift()];
+        for (i = 0, l = keys.length; i < l; _i++)
+            v = v[this];
+        return (typeof v !== "undefined" && v !== null) ? v : "";
+    });
+}
+
+function adjustMapSize() {
     var mapDiv = $("#map");
-    var width = $(window).width() - 300;
-    if (width < 100)
-        width = $(window).width() - 5;
-    var height = $(window).height() - 5;
+    var width = $(window).width() - 295;
+    if (width < 400) {
+        width = 290;
+        mapDiv.attr("style", "position: relative; float: right;");
+    } else {
+        mapDiv.attr("style", "position: absolute; right: 0;");
+    }
+    var height = $(window).height();
     mapDiv.width(width).height(height);
-    if (height > 350)
-        height -= 265;
-    $("#info").css("max-height", height);
-    console.log("init map at " + JSON.stringify(bounds));
+    $("#input").height(height);
+    // reduce info size depending on how heigh the input_header is and reserve space for footer
+    $("#info").css("max-height", height - $("#input_header").height() - 58);
+}
+
+function initMap(selectLayer) {
+    adjustMapSize();
+    log("init map at " + JSON.stringify(bounds));
 
-    // mapquest provider
-    var moreAttr = 'Data &copy; <a href="http://www.openstreetmap.org/copyright">OSM</a>,'
-            + 'JS: <a href="http://leafletjs.com/">Leaflet</a>';
+    var osmAttr = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';
+    // provider
+    //@see http://leaflet-extras.github.io/leaflet-providers/preview/index.html
+    var osmAttr = '&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors';
 
     var tp = "ls";
     if (L.Browser.retina)
         tp = "lr";
 
-    var lyrk = L.tileLayer('http://{s}.tiles.lyrk.org/' + tp + '/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077', {
-        attribution: '<a href="http://geodienste.lyrk.de/">Lyrk</a>,' + moreAttr,
+    var lyrk = L.tileLayer('https://tiles.lyrk.org/' + tp + '/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077', {
+        attribution: osmAttr + ', <a href="https://geodienste.lyrk.de/">Lyrk</a>',
         subdomains: ['a', 'b', 'c']
     });
 
     var mapquest = L.tileLayer('http://{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png', {
-        attribution: '<a href="http://open.mapquest.co.uk">MapQuest</a>,' + moreAttr,
+        attribution: osmAttr + ', <a href="http://open.mapquest.co.uk" target="_blank">MapQuest</a>',
         subdomains: ['otile1', 'otile2', 'otile3', 'otile4']
     });
 
     var mapquestAerial = L.tileLayer('http://{s}.mqcdn.com/tiles/1.0.0/sat/{z}/{x}/{y}.png', {
-        attribution: '<a href="http://open.mapquest.co.uk">MapQuest</a>,' + moreAttr,
+        attribution: osmAttr + ', <a href="http://open.mapquest.co.uk" target="_blank">MapQuest</a>',
         subdomains: ['otile1', 'otile2', 'otile3', 'otile4']
     });
 
+    var openMapSurfer = L.tileLayer('http://openmapsurfer.uni-hd.de/tiles/roads/x={x}&y={y}&z={z}', {
+        attribution: osmAttr + ', <a href="http://openmapsurfer.uni-hd.de/contact.html">GIScience Heidelberg</a>'
+    });
+
     var thunderTransport = L.tileLayer('http://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png', {
-        attribution: '<a href="http://www.thunderforest.com/transport/">Thunderforest Transport</a>,' + moreAttr,
+        attribution: osmAttr + ', <a href="http://www.thunderforest.com/transport/" target="_blank">Thunderforest Transport</a>',
         subdomains: ['a', 'b', 'c']
     });
 
     var thunderCycle = L.tileLayer('http://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png', {
-        attribution: '<a href="http://www.thunderforest.com/opencyclemap/">Thunderforest Cycle</a>,' + moreAttr,
+        attribution: osmAttr + ', <a href="http://www.thunderforest.com/opencyclemap/" target="_blank">Thunderforest Cycle</a>',
         subdomains: ['a', 'b', 'c']
     });
 
     var thunderOutdoors = L.tileLayer('http://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png', {
-        attribution: '<a href="http://www.thunderforest.com/outdoors/">Thunderforest Outdoors</a>,' + moreAttr,
+        attribution: osmAttr + ', <a href="http://www.thunderforest.com/outdoors/" target="_blank">Thunderforest Outdoors</a>',
         subdomains: ['a', 'b', 'c']
     });
 
-    //    var mapbox = L.tileLayer('http://a.tiles.mapbox.com/v3/mapbox.world-bright/{z}/{x}/{y}.png', {
-    //        attribution: '<a href="http://www.mapbox.com">MapBox</a>,' + moreAttr, 
-    //        subdomains: ['a','b','c']
-    //    });    
-
     var wrk = L.tileLayer('http://{s}.wanderreitkarte.de/topo/{z}/{x}/{y}.png', {
-        attribution: '<a href="http://wanderreitkarte.de">WanderReitKarte</a>,' + moreAttr,
+        attribution: osmAttr + ', <a href="http://wanderreitkarte.de" target="_blank">WanderReitKarte</a>',
         subdomains: ['topo4', 'topo', 'topo2', 'topo3']
     });
 
-    var cloudmade = L.tileLayer('http://{s}.tile.cloudmade.com/{key}/{styleId}/256/{z}/{x}/{y}.png', {
-        attribution: '<a href="http://cloudmade.com">Cloudmade</a>,' + moreAttr,
-        key: '43b079df806c4e03b102055c4e1a8ba8',
-        styleId: 997
-    });
-
-    var osm = L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
-        attribution: moreAttr
+    var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
+        attribution: osmAttr
     });
 
     var osmde = L.tileLayer('http://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png', {
-        attribution: moreAttr
-    });
-
-    // only work if you zoom a bit deeper
-    var lang = "en_US";
-    var apple = L.tileLayer('http://gsp2.apple.com/tile?api=1&style=slideshow&layers=default&lang=' + lang + '&z={z}&x={x}&y={y}&v=9', {
-        maxZoom: 17,
-        attribution: 'Map data and Imagery &copy; <a href="http://www.apple.com/ios/maps/">Apple</a>,' + moreAttr
+        attribution: osmAttr,
+        subdomains: ['a', 'b', 'c']
     });
 
-    // default
-    map = L.map('map', {
-        layers: [mapquest]
+    var mapLink = '<a href="http://www.esri.com/">Esri</a>';
+    var wholink = 'i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';
+    var esriAerial = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
+        attribution: '&copy; ' + mapLink + ', ' + wholink,
+        maxZoom: 18
     });
 
     var baseMaps = {
         "Lyrk": lyrk,
         "MapQuest": mapquest,
         "MapQuest Aerial": mapquestAerial,
+        "Esri Aerial": esriAerial,
+        "OpenMapSurfer": openMapSurfer,
         "TF Transport": thunderTransport,
         "TF Cycle": thunderCycle,
         "TF Outdoors": thunderOutdoors,
-        // didn't found a usage policy for this "Apple": apple,
         "WanderReitKarte": wrk,
-        "Cloudmade": cloudmade,
         "OpenStreetMap": osm,
         "OpenStreetMap.de": osmde
     };
 
-    //    var overlays = {
-    //        "MapQuest Hybrid": mapquest
-    //    };
+    var defaultLayer = baseMaps[selectLayer];
+    if (!defaultLayer)
+        defaultLayer = lyrk;
 
-    // no layers for small browser windows
-    if ($(window).width() > 400) {
-        L.control.layers(baseMaps/*, overlays*/).addTo(map);
-    }
+    // default
+    map = L.map('map', {
+        layers: [defaultLayer],
+        contextmenu: true,
+        contextmenuWidth: 145,
+        contextmenuItems: [{
+                separator: true,
+                index: 3,
+                state: ['set_default']
+            }, {
+                text: 'Show coordinates',
+                callback: function (e) {
+                    alert(e.latlng.lat + "," + e.latlng.lng);
+                },
+                index: 4,
+                state: [1, 2, 3]
+            }, {
+                text: 'Center map here',
+                callback: function (e) {
+                    map.panTo(e.latlng);
+                },
+                index: 5,
+                state: [1, 2, 3]
+            }],
+        zoomControl: false,
+        loadingControl: false
+    });
+
+
+    var _startItem = {
+        text: 'Set as start',
+        callback: setStartCoord,
+        disabled: false,
+        index: 0
+    };
+    var _intItem = {
+        text: 'Set intermediate',
+        callback: setIntermediateCoord,
+        disabled: true,
+        index: 1
+    };
+    var _endItem = {
+        text: 'Set as end',
+        callback: setEndCoord,
+        disabled: false,
+        index: 2
+    };
+    menuStart = map.contextmenu.insertItem(_startItem, _startItem.index);
+    menuIntermediate = map.contextmenu.insertItem(_intItem, _intItem.index);
+    menuEnd = map.contextmenu.insertItem(_endItem, _endItem.index);
+
+    var zoomControl = new L.Control.Zoom({position: 'topleft'}).addTo(map);
+
+    new L.Control.loading({
+        zoomControl: zoomControl
+    }).addTo(map);
+
+    map.contextmenu.addSet({
+        name: 'markers',
+        state: 2
+    });
+
+    map.contextmenu.addSet({
+        name: 'path',
+        state: 3
+    });
+
+    L.control.layers(baseMaps/*, overlays*/).addTo(map);
+
+    map.on('baselayerchange', function (a) {
+        if (a.name)
+            activeLayer = a.name;
+    });
 
     L.control.scale().addTo(map);
 
     map.fitBounds(new L.LatLngBounds(new L.LatLng(bounds.minLat, bounds.minLon),
             new L.LatLng(bounds.maxLat, bounds.maxLon)));
 
+    if (isProduction())
+        map.setView(new L.LatLng(0, 0), 2);
+
     map.attributionControl.setPrefix('');
 
     var myStyle = {
@@ -316,27 +495,82 @@ function initMap() {
         }).addTo(map);
 
     routingLayer = L.geoJson().addTo(map);
-    firstClickToRoute = true;
-    function onMapClick(e) {
-        var latlng = e.latlng;
-        latlng.lng = makeValidLng(latlng.lng);
-        if (firstClickToRoute) {
-            // set start point
-            routingLayer.clearLayers();
-            firstClickToRoute = false;
-            ghRequest.from.setCoord(latlng.lat, latlng.lng);
-            resolveFrom();
-        } else {
-            // set end point
-            ghRequest.to.setCoord(latlng.lat, latlng.lng);
-            resolveTo();
-            // do not wait for resolving
-            routeLatLng(ghRequest);
-            firstClickToRoute = true;
-        }
-    }
+    routingLayer.options = {
+        style: {color: "#00cc33", "weight": 5, "opacity": 0.6}, // route color and style
+        contextmenu: true,
+        contextmenuItems: [{
+                text: 'Route ',
+                disabled: true,
+                index: 0,
+                state: 3
+            }, {
+                text: 'Set intermediate',
+                callback: setIntermediateCoord,
+                index: 1,
+                state: 3
+            }, {
+                separator: true,
+                index: 2,
+                state: 3
+            }],
+        contextmenuAtiveState: 3
+    };
+    /*
+     routingLayer.options = {style: {color: "#1F40C4", "weight": 5, "opacity": 0.6}, onEachFeature: function (feature, layer) {
+     layer.on('contextmenu', function (e) {
+     alert('The GeoJSON layer has been clicked');
+     });
+     }}; // route color and style
+     */
+}
+
+function setToStart(e) {
+    var latlng = e.target.getLatLng(),
+            index = ghRequest.route.getIndexByCoord(latlng);
+    ghRequest.route.move(index, 0);
+    routeIfAllResolved();
+}
+
+function setToEnd(e) {
+    var latlng = e.target.getLatLng(),
+            index = ghRequest.route.getIndexByCoord(latlng);
+    ghRequest.route.move(index, -1);
+    routeIfAllResolved();
+}
 
-    map.on('click', onMapClick);
+function setStartCoord(e) {
+    ghRequest.route.set(e.latlng, 0);
+    resolveFrom();
+    routeIfAllResolved();
+}
+
+function setIntermediateCoord(e) {
+    var index = ghRequest.route.size() - 1;
+    ghRequest.route.add(e.latlng, index);
+    resolveIndex(index);
+    routeIfAllResolved();
+}
+
+function deleteCoord(e) {
+    var latlng = e.target.getLatLng();
+    ghRequest.route.removeSingle(latlng);
+    routingLayer.clearLayers();
+    routeLatLng(ghRequest, false);
+}
+
+function setEndCoord(e) {
+    var index = ghRequest.route.size() - 1;
+    ghRequest.route.set(e.latlng, index);
+    resolveTo();
+    routeIfAllResolved();
+}
+
+function routeIfAllResolved(doQuery) {
+    if (ghRequest.route.isResolved()) {
+        routeLatLng(ghRequest, doQuery);
+        return true;
+    }
+    return false;
 }
 
 function makeValidLng(lon) {
@@ -347,67 +581,145 @@ function makeValidLng(lon) {
     return (lon - 180) % 360 + 180;
 }
 
-function setFlag(coord, isFrom) {
+var FROM = 'from', TO = 'to';
+function getToFrom(index) {
+    if (index === 0)
+        return FROM;
+    else if (index === (ghRequest.route.size() - 1))
+        return TO;
+    return -1;
+}
+
+function setFlag(coord, index) {
     if (coord.lat) {
-        var marker = L.marker([coord.lat, coord.lng], {
-            icon: (isFrom ? iconFrom : iconTo),
-            draggable: true
-        }).addTo(routingLayer).bindPopup(isFrom ? "Start" : "End");
-        marker.on('dragend', function(e) {
+        var toFrom = getToFrom(index),
+                marker = L.marker([coord.lat, coord.lng], {
+                    icon: ((toFrom === FROM) ? iconFrom : ((toFrom === TO) ? iconTo : iconInt)),
+                    draggable: true,
+                    contextmenu: true,
+                    contextmenuItems: [{
+                            text: 'Marker ' + ((toFrom === FROM) ?
+                                    'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)),
+                            disabled: true,
+                            index: 0,
+                            state: 2
+                        }, {
+                            text: 'Set as ' + ((toFrom !== TO) ? 'End' : 'Start'),
+                            callback: (toFrom !== TO) ? setToEnd : setToStart,
+                            index: 2,
+                            state: 2
+                        }, {
+                            text: 'Delete from Route',
+                            callback: deleteCoord,
+                            index: 3,
+                            state: 2,
+                            disabled: (toFrom !== -1 && ghRequest.route.size() === 2) ? true : false // prevent to and from
+                        }, {
+                            separator: true,
+                            index: 4,
+                            state: 2
+                        }],
+                    contextmenuAtiveState: 2
+                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ?
+                'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)));
+        // intercept openPopup
+        marker._openPopup = marker.openPopup;
+        marker.openPopup = function () {
+            var latlng = this.getLatLng(),
+                    locCoord = ghRequest.route.getIndexFromCoord(latlng),
+                    content;
+            if (locCoord.resolvedList && locCoord.resolvedList[0] && locCoord.resolvedList[0].locationDetails) {
+                var address = locCoord.resolvedList[0].locationDetails;
+                content =
+                        ((address.road) ? address.road + ', ' : '') +
+                        ((address.postcode) ? address.postcode + ', ' : '') +
+                        ((address.city) ? address.city + ', ' : '') +
+                        ((address.country) ? address.country : '')
+                        ;
+                // at last update the content and update
+                this._popup.setContent(content).update();
+            }
+            this._openPopup();
+        };
+        var _tempItem = {
+            text: 'Set as Start',
+            callback: setToStart,
+            index: 1,
+            state: 2
+        };
+        if (toFrom === -1)
+            marker.options.contextmenuItems.push(_tempItem);// because the Mixin.ContextMenu isn't initialized
+        marker.on('dragend', function (e) {
             routingLayer.clearLayers();
             // inconsistent leaflet API: event.target.getLatLng vs. mouseEvent.latlng?
             var latlng = e.target.getLatLng();
-            if (isFrom) {
-                ghRequest.from.setCoord(latlng.lat, latlng.lng);
-                resolveFrom();
-            } else {
-                ghRequest.to.setCoord(latlng.lat, latlng.lng);
-                resolveTo();
-            }
+            hideAutoComplete();
+            ghRequest.route.getIndex(index).setCoord(latlng.lat, latlng.lng);
+            resolveIndex(index);
             // do not wait for resolving and avoid zooming when dragging
-            ghRequest.doZoom = false;
+            ghRequest.do_zoom = false;
             routeLatLng(ghRequest, false);
         });
     }
 }
 
 function resolveFrom() {
-    setFlag(ghRequest.from, true);
-    return resolve("from", ghRequest.from);
+    return resolveIndex(0);
 }
 
 function resolveTo() {
-    setFlag(ghRequest.to, false);
-    return resolve("to", ghRequest.to);
+    return resolveIndex((ghRequest.route.size() - 1));
 }
 
-function resolve(fromOrTo, locCoord) {
-    $("#" + fromOrTo + "Flag").hide();
-    $("#" + fromOrTo + "Indicator").show();
-    $("#" + fromOrTo + "Input").val(locCoord.input);
+function resolveIndex(index) {
+    setFlag(ghRequest.route.getIndex(index), index);
+    if (index === 0) {
+        if (!ghRequest.to.isResolved())
+            map.contextmenu.setDisabled(menuStart, true);
+        else
+            map.contextmenu.setDisabled(menuStart, false);
+    } else if (index === (ghRequest.route.size() - 1)) {
+        if (!ghRequest.from.isResolved())
+            map.contextmenu.setDisabled(menuEnd, true);
+        else
+            map.contextmenu.setDisabled(menuEnd, false);
+    }
+
+    return resolve(index, ghRequest.route.getIndex(index));
+}
+
+function resolveAll() {
+    var ret = [];
+    for (var i = 0, l = ghRequest.route.size(); i < l; i++) {
+        ret[i] = resolveIndex(i);
+    }
+    return ret;
+}
 
-    return createAmbiguityList(locCoord).done(function(arg1) {
-        var errorDiv = $("#" + fromOrTo + "ResolveError");
+function flagAll() {
+    for (var i = 0, l = ghRequest.route.size(); i < l; i++) {
+        setFlag(ghRequest.route.getIndex(i), i);
+    }
+}
+
+function resolve(index, locCoord) {
+    var div = $('#locationpoints > div.pointDiv').eq(index);
+    $(div).find(".pointFlag").hide();
+    $(div).find(".pointIndicator").show();
+    $(div).find(".pointInput").val(locCoord.input);
+
+    return createAmbiguityList(locCoord).always(function () {
+        var errorDiv = $(div).find(".pointResolveError");
         errorDiv.empty();
-        var foundDiv = $("#" + fromOrTo + "ResolveFound");
-        // deinstallation of completion if there was one
-        // if (getAutoCompleteDiv(fromOrTo).autocomplete())
-        //    getAutoCompleteDiv(fromOrTo).autocomplete().dispose();
 
-        foundDiv.empty();
-        var list = locCoord.resolvedList;
         if (locCoord.error) {
-            errorDiv.text(locCoord.error);
-        } else if (list) {
-            var anchor = String.fromCharCode(0x25BC);
-            var linkPart = $("<a>" + anchor + "<small>" + list.length + "</small></a>");
-            foundDiv.append(linkPart.click(function(e) {
-                setAutoCompleteList(fromOrTo, locCoord);
-            }));
+            errorDiv.show();
+            errorDiv.text(locCoord.error).fadeOut(5000);
+            locCoord.error = '';
         }
 
-        $("#" + fromOrTo + "Indicator").hide();
-        $("#" + fromOrTo + "Flag").show();
+        $(div).find(".pointIndicator").hide();
+        $(div).find(".pointFlag").show();
         return locCoord;
     });
 }
@@ -417,99 +729,94 @@ function resolve(fromOrTo, locCoord) {
  * coordinates.
  */
 function createAmbiguityList(locCoord) {
-    // make example working even if nominatim service is down
-    if (locCoord.input.toLowerCase() === "madrid") {
-        locCoord.lat = 40.416698;
-        locCoord.lng = -3.703551;
-        locCoord.locationDetails = formatLocationEntry({city: "Madrid", country: "Spain"});
-        locCoord.resolvedList = [locCoord];
-    }
-    if (locCoord.input.toLowerCase() === "moscow") {
-        locCoord.lat = 55.751608;
-        locCoord.lng = 37.618775;
-        locCoord.locationDetails = formatLocationEntry({road: "Borowizki-Straße", city: "Moscow", country: "Russian Federation"});
-        locCoord.resolvedList = [locCoord];
-    }
+    locCoord.error = "";
+    locCoord.resolvedList = [];
+    var timeout = 3000;
 
     if (locCoord.isResolved()) {
+        // if we changed only another location no need to look this up again
         var tmpDefer = $.Deferred();
         tmpDefer.resolve([locCoord]);
         return tmpDefer;
-    }
-
-    locCoord.error = "";
-    locCoord.resolvedList = [];
-    var timeout = 3000;
-    if (locCoord.lat && locCoord.lng) {
-        var url = nominatim_reverse + "?lat=" + locCoord.lat + "&lon="
+    } else if (locCoord.lat && locCoord.lng) {
+        var url = nominatimReverseURL + "?lat=" + locCoord.lat + "&lon="
                 + locCoord.lng + "&format=json&zoom=16";
         return $.ajax({
             url: url,
             type: "GET",
             dataType: "json",
             timeout: timeout
-        }).fail(function(err) {
-            // not critical => no alert
-            locCoord.error = "Error while looking up coordinate";
-            console.log(err);
-        }).pipe(function(json) {
-            if (!json) {
-                locCoord.error = "No description found for coordinate";
-                return [locCoord];
-            }
-            var address = json.address;
-            var point = {};
-            point.lat = locCoord.lat;
-            point.lng = locCoord.lng;
-            point.bbox = json.boundingbox;
-            point.positionType = json.type;
-            point.locationDetails = formatLocationEntry(address);
-            // point.address = json.address;
-            locCoord.resolvedList.push(point);
-            return [locCoord];
-        });
+        }).then(
+                function (json) {
+                    if (!json) {
+                        locCoord.error = "No description found for coordinate";
+                        return [locCoord];
+                    }
+                    var address = json.address;
+                    var point = {};
+                    point.lat = locCoord.lat;
+                    point.lng = locCoord.lng;
+                    point.bbox = json.boundingbox;
+                    point.positionType = json.type;
+                    point.locationDetails = formatLocationEntry(address);
+                    // point.address = json.address;
+                    locCoord.resolvedList.push(point);
+                    return [locCoord];
+                },
+                function (err) {
+                    log("[nominatim_reverse] Error while looking up coordinate lat=" + locCoord.lat + "&lon=" + locCoord.lng);
+                    locCoord.error = "Problem while looking up location.";
+                    return [locCoord];
+                }
+        );
     } else {
-        return doGeoCoding(locCoord.input, 10, timeout).pipe(function(jsonArgs) {
-            if (!jsonArgs || jsonArgs.length == 0) {
-                locCoord.error = "No area description found";
-                return [locCoord];
-            }
-            var prevImportance = jsonArgs[0].importance;
-            var address;
-            for (var index in jsonArgs) {
-                var json = jsonArgs[index];
-                // if we have already some results ignore unimportant
-                if (prevImportance - json.importance > 0.4)
-                    break;
-
-                // de-duplicate via ignoring boundary stuff => not perfect as 'Freiberg' would no longer be correct
-                // if (json.type === "administrative")
-                //    continue;
-
-                // if no different properties => skip!
-                if (address && JSON.stringify(address) === JSON.stringify(json.address))
-                    continue;
-
-                address = json.address;
-                prevImportance = json.importance;
-                var point = {};
-                point.lat = round(json.lat);
-                point.lng = round(json.lon);
-                point.locationDetails = formatLocationEntry(address);
-                point.bbox = json.boundingbox;
-                point.positionType = json.type;
-                locCoord.resolvedList.push(point);
-            }
-            if (locCoord.resolvedList.length === 0) {
-                locCoord.error = "No area description found";
-                return [locCoord];
-            }
-            var list = locCoord.resolvedList;
-            locCoord.lat = list[0].lat;
-            locCoord.lng = list[0].lng;
-            // locCoord.input = dataToText(list[0]);
-            return [locCoord];
-        });
+        return doGeoCoding(locCoord.input, 10, timeout).then(
+                function (jsonArgs) {
+                    if (!jsonArgs || jsonArgs.length === 0) {
+                        locCoord.error = "No area description found";
+                        return [locCoord];
+                    }
+                    var prevImportance = jsonArgs[0].importance;
+                    var address;
+                    for (var index in jsonArgs) {
+                        var json = jsonArgs[index];
+                        // if we have already some results ignore unimportant
+                        if (prevImportance - json.importance > 0.4)
+                            break;
+
+                        // de-duplicate via ignoring boundary stuff => not perfect as 'Freiberg' would no longer be correct
+                        // if (json.type === "administrative")
+                        //    continue;
+
+                        // if no different properties => skip!
+                        if (address && JSON.stringify(address) === JSON.stringify(json.address))
+                            continue;
+
+                        address = json.address;
+                        prevImportance = json.importance;
+                        var point = {};
+                        point.lat = round(json.lat);
+                        point.lng = round(json.lon);
+                        point.locationDetails = formatLocationEntry(address);
+                        point.bbox = json.boundingbox;
+                        point.positionType = json.type;
+                        locCoord.resolvedList.push(point);
+                    }
+                    if (locCoord.resolvedList.length === 0) {
+                        locCoord.error = "No area description found";
+                        return [locCoord];
+                    }
+                    var list = locCoord.resolvedList;
+                    locCoord.lat = list[0].lat;
+                    locCoord.lng = list[0].lng;
+                    // locCoord.input = dataToText(list[0]);
+                    return [locCoord];
+                },
+                function () {
+                    locCoord.error = "Problem while looking up address";
+                    return [locCoord];
+                }
+        );
     }
 }
 
@@ -522,6 +829,8 @@ function insComma(textA, textB) {
 function formatLocationEntry(address) {
     var locationDetails = {};
     var text = "";
+    if (!address)
+        return locationDetails;
     if (address.road) {
         text = address.road;
         if (address.house_number) {
@@ -532,7 +841,8 @@ function formatLocationEntry(address) {
         locationDetails.road = text;
     }
 
-    locationDetails.postcode = address.postcode;
+    if (address.postcode)
+        locationDetails.postcode = address.postcode;
     locationDetails.country = address.country;
 
     if (address.city || address.suburb || address.town
@@ -568,7 +878,7 @@ function doGeoCoding(input, limit, timeout) {
     // see https://trac.openstreetmap.org/ticket/4683 why limit=3 and not 1
     if (!limit)
         limit = 10;
-    var url = nominatim + "?format=json&addressdetails=1&q=" + encodeURIComponent(input) + "&limit=" + limit;
+    var url = nominatimURL + "?format=json&addressdetails=1&q=" + encodeURIComponent(input) + "&limit=" + limit;
     if (bounds.initialized) {
         // minLon, minLat, maxLon, maxLat => left, top, right, bottom
         url += "&bounded=1&viewbox=" + bounds.minLon + "," + bounds.maxLat + "," + bounds.maxLon + "," + bounds.minLat;
@@ -579,45 +889,48 @@ function doGeoCoding(input, limit, timeout) {
         type: "GET",
         dataType: "json",
         timeout: timeout
-    }).fail(createCallback("[nominatim] Problem while looking up location " + input));
+    }).fail(
+            createCallback("[nominatim] Problem while looking up location " + input)
+            );
 }
 
 function createCallback(errorFallback) {
-    return function(err) {
-        console.log(errorFallback + " " + JSON.stringify(err));
+    return function (err) {
+        log(errorFallback + " " + JSON.stringify(err));
     };
 }
 
-function focusWithBounds(coord, bbox, isFrom) {
+function focusWithBounds(coord, bbox, index) {
     routingLayer.clearLayers();
     // bbox needs to be in the none-geojson format!?
     // [[lat, lng], [lat2, lng2], ...]
     map.fitBounds(new L.LatLngBounds(bbox));
-    setFlag(coord, isFrom);
+    setFlag(coord, index);
 }
 
-function focus(coord, zoom, isFrom) {
+function focus(coord, zoom, index) {
     if (coord.lat && coord.lng) {
         if (!zoom)
             zoom = 11;
         routingLayer.clearLayers();
         map.setView(new L.LatLng(coord.lat, coord.lng), zoom);
-        setFlag(coord, isFrom);
+        setFlag(coord, index);
     }
 }
 function routeLatLng(request, doQuery) {
-    // doZoom should not show up in the URL but in the request object to avoid zooming for history change
-    var doZoom = request.doZoom;
-    request.doZoom = true;
+    // do_zoom should not show up in the URL but in the request object to avoid zooming for history change
+    var doZoom = request.do_zoom;
+    request.do_zoom = true;
+
+    var urlForHistory = request.createHistoryURL() + "&layer=" + activeLayer;
 
-    var urlForHistory = request.createFullURL();
     // not enabled e.g. if no cookies allowed (?)
     // if disabled we have to do the query and cannot rely on the statechange history event    
     if (!doQuery && History.enabled) {
         // 2. important workaround for encoding problems in history.js
         var params = parseUrl(urlForHistory);
-        console.log(params);
-        params.doZoom = doZoom;
+        log(params);
+        params.do_zoom = doZoom;
         // force a new request even if we have the same parameters
         params.mathRandom = Math.random();
         History.pushState(params, browserTitle, urlForHistory);
@@ -629,149 +942,166 @@ function routeLatLng(request, doQuery) {
     var descriptionDiv = $("<div/>");
     $("#info").append(descriptionDiv);
 
-    var from = request.from.toString();
-    var to = request.to.toString();
-    if (!from || !to) {
-        descriptionDiv.html('<small>' + tr('locationsNotFound') + '</small>');
-        return;
-    }
+    if (elevationControl)
+        elevationControl.clear();
 
     routingLayer.clearLayers();
-    setFlag(request.from, true);
-    setFlag(request.to, false);
+    flagAll();
+
+    map.contextmenu.setDisabled(menuIntermediate, false);
 
     $("#vehicles button").removeClass("selectvehicle");
     $("button#" + request.vehicle.toLowerCase()).addClass("selectvehicle");
 
-    var urlForAPI = request.createURL("point=" + from + "&point=" + to);
+    var urlForAPI = request.createURL();
     descriptionDiv.html('<img src="img/indicator.gif"/> Search Route ...');
-    request.doRequest(urlForAPI, function(json) {
+    request.doRequest(urlForAPI, function (json) {
         descriptionDiv.html("");
         if (json.info.errors) {
             var tmpErrors = json.info.errors;
-            console.log(tmpErrors);
+            log(tmpErrors);
             for (var m = 0; m < tmpErrors.length; m++) {
                 descriptionDiv.append("<div class='error'>" + tmpErrors[m].message + "</div>");
             }
             return;
-        } else if (json.info.routeFound === false) {
-            descriptionDiv.html('Route not found! Disconnected areas?');
-            return;
         }
+        var path = json.paths[0];
         var geojsonFeature = {
             "type": "Feature",
             // "style": myStyle,                
-            "geometry": json.route.data
+            "geometry": path.points
         };
 
+        if (request.hasElevation()) {
+            if (elevationControl === null) {
+                elevationControl = L.control.elevation({
+                    position: "bottomright",
+                    theme: "white-theme", //default: lime-theme
+                    width: 450,
+                    height: 125,
+                    yAxisMin: 0, // set min domain y axis
+                    // yAxisMax: 550, // set max domain y axis
+                    forceAxisBounds: false,
+                    margins: {
+                        top: 10,
+                        right: 20,
+                        bottom: 30,
+                        left: 50
+                    },
+                    useHeightIndicator: true, //if false a marker is drawn at map position
+                    interpolation: "linear", //see https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-area_interpolate
+                    hoverNumber: {
+                        decimalsX: 3, //decimals on distance (always in km)
+                        decimalsY: 0, //deciamls on height (always in m)
+                        formatter: undefined //custom formatter function may be injected
+                    },
+                    xTicks: undefined, //number of ticks in x axis, calculated by default according to width
+                    yTicks: undefined, //number of ticks on y axis, calculated by default according to height
+                    collapsed: false    //collapsed mode, show chart on click or mouseover
+                });
+                elevationControl.addTo(map);
+            }
+
+            elevationControl.addData(geojsonFeature);
+        }
+
         routingLayer.addData(geojsonFeature);
-        if (json.route.bbox && doZoom) {
-            var minLon = json.route.bbox[0];
-            var minLat = json.route.bbox[1];
-            var maxLon = json.route.bbox[2];
-            var maxLat = json.route.bbox[3];
+        if (path.bbox && doZoom) {
+            var minLon = path.bbox[0];
+            var minLat = path.bbox[1];
+            var maxLon = path.bbox[2];
+            var maxLat = path.bbox[3];
             var tmpB = new L.LatLngBounds(new L.LatLng(minLat, minLon), new L.LatLng(maxLat, maxLon));
             map.fitBounds(tmpB);
         }
 
-        var tmpTime = createTimeString(json.route.time);
-        var tmpDist = createDistanceString(json.route.distance);
-        descriptionDiv.html(tr("routeInfo", [tmpDist, tmpTime]));
+        var tmpTime = createTimeString(path.time);
+        var tmpDist = createDistanceString(path.distance);
+        descriptionDiv.append(tr("routeInfo", [tmpDist, tmpTime]));
 
-        var hiddenDiv = $("<div id='routeDetails'/>");
-        hiddenDiv.hide();
-
-        var toggly = $("<button style='font-size:14px; float: right; font-weight: bold; padding: 0px'>+</button>");
-        toggly.click(function() {
-            hiddenDiv.toggle();
-        });
-        $("#info").prepend(toggly);
-        var infoStr = "took: " + round(json.info.took, 1000) + "s"
-                + ", points: " + json.route.data.coordinates.length;
-        //if (json.route.instructions)
-        //    infoStr += ", instructions: " + json.route.instructions.descriptions.length;
-        hiddenDiv.append("<span>" + infoStr + "</span>");
-        $("#info").append(hiddenDiv);
-
-        var exportLink = $("#exportLink a");
-        exportLink.attr('href', urlForHistory);
-        var startOsmLink = $("<a>start</a>");
-        startOsmLink.attr("href", "http://www.openstreetmap.org/?zoom=14&mlat=" + request.from.lat + "&mlon=" + request.from.lng);
-        var endOsmLink = $("<a>end</a>");
-        endOsmLink.attr("href", "http://www.openstreetmap.org/?zoom=14&mlat=" + request.to.lat + "&mlon=" + request.to.lng);
-        hiddenDiv.append("<br/><span>View on OSM: </span>").append(startOsmLink).append(endOsmLink);
-
-        var osrmLink = $("<a>OSRM</a>");
-        osrmLink.attr("href", "http://map.project-osrm.org/?loc=" + from + "&loc=" + to);
-        hiddenDiv.append("<br/><span>Compare with: </span>");
-        hiddenDiv.append(osrmLink);
-        var googleLink = $("<a>Google</a> ");
-        var addToGoogle = "";
-        var addToBing = "";
-        if (request.vehicle.toUpperCase() == "FOOT") {
-            addToGoogle = "&dirflg=w";
-            addToBing = "&mode=W";
-        } else if ((request.vehicle.toUpperCase() == "BIKE") ||
-                (request.vehicle.toUpperCase() == "RACINGBIKE") ||
-                (request.vehicle.toUpperCase() == "MTB")) {
-            addToGoogle = "&dirflg=b";
-            // ? addToBing = "&mode=B";
-        }
-        googleLink.attr("href", "http://maps.google.com/?q=from:" + from + "+to:" + to + addToGoogle);
-        hiddenDiv.append(googleLink);
-        var bingLink = $("<a>Bing</a> ");
-        bingLink.attr("href", "http://www.bing.com/maps/default.aspx?rtp=adr." + from + "~adr." + to + addToBing);
-        hiddenDiv.append(bingLink);
-
-        if (host.indexOf("gpsies.com") > 0)
-            hiddenDiv.append("<div id='hosting'>The routing API is hosted by <a href='http://gpsies.com'>GPSies.com</a></div>");
-
-        $('.defaulting').each(function(index, element) {
+        $('.defaulting').each(function (index, element) {
             $(element).css("color", "black");
         });
 
-        if (json.route.instructions) {
-            var instructionsElement = $("<table id='instructions'><colgroup>"
-                    + "<col width='10%'><col width='65%'><col width='25%'></colgroup>");
+        if (path.instructions) {
+            var instructionsElement = $("<table id='instructions'>");
+
+            var partialInstr = path.instructions.length > 100;
+            var len = Math.min(path.instructions.length, 100);
+            for (var m = 0; m < len; m++) {
+                var instr = path.instructions[m];
+                var lngLat = path.points.coordinates[instr.interval[0]];
+                addInstruction(instructionsElement, instr, m, lngLat);
+            }
             $("#info").append(instructionsElement);
-            var descriptions = json.route.instructions.descriptions;
-            var distances = json.route.instructions.distances;
-            var indications = json.route.instructions.indications;
-            var millis = json.route.instructions.millis;
-            var latLngs = json.route.instructions.latLngs;
-            for (var m = 0; m < descriptions.length; m++) {
-                var indi = indications[m];
-                if (m == 0)
-                    indi = "marker-from";
-                else if (indi == -3)
-                    indi = "sharp_left";
-                else if (indi == -2)
-                    indi = "left";
-                else if (indi == -1)
-                    indi = "slight_left";
-                else if (indi == 0)
-                    indi = "continue";
-                else if (indi == 1)
-                    indi = "slight_right";
-                else if (indi == 2)
-                    indi = "right";
-                else if (indi == 3)
-                    indi = "sharp_right";
-                else if (indi == 4)
-                    indi = "marker-to";
-                else
-                    throw "did not found indication " + indi;
 
-                addInstruction(instructionsElement, indi, descriptions[m], distances[m], millis[m], latLngs[m]);
+            if (partialInstr) {
+                var moreDiv = $("<button id='moreButton'>" + tr("moreButton") + "..</button>");
+                moreDiv.click(function () {
+                    moreDiv.remove();
+                    for (var m = len; m < path.instructions.length; m++) {
+                        var instr = path.instructions[m];
+                        var lngLat = path.points.coordinates[instr.interval[0]];
+                        addInstruction(instructionsElement, instr, m, lngLat);
+                    }
+                });
+                instructionsElement.append(moreDiv);
             }
+
+            var hiddenDiv = $("<div id='routeDetails'/>");
+            hiddenDiv.hide();
+
+            var toggly = $("<button id='expandDetails'>+</button>");
+            toggly.click(function () {
+                hiddenDiv.toggle();
+            });
+            $("#info").append(toggly);
+            var infoStr = "took: " + round(json.info.took / 1000, 1000) + "s"
+                    + ", points: " + path.points.coordinates.length;
+
+            hiddenDiv.append("<span>" + infoStr + "</span>");
+
+            var exportLink = $("#export-link a");
+            exportLink.attr('href', urlForHistory);
+            var osmRouteLink = $("<br/><a>view on OSM</a>");
+
+            var osmVehicle = "bicycle";
+            if (request.vehicle.toUpperCase() === "FOOT") {
+                osmVehicle = "foot";
+            }
+            osmRouteLink.attr("href", "http://www.openstreetmap.org/directions?engine=graphhopper_" + osmVehicle + "&route=" + encodeURIComponent(request.from.lat + "," + request.from.lng + ";" + request.to.lat + "," + request.to.lng));
+            hiddenDiv.append(osmRouteLink);
+
+            var osrmLink = $("<a>OSRM</a>");
+            osrmLink.attr("href", "http://map.project-osrm.org/?loc=" + request.from + "&loc=" + request.to);
+            hiddenDiv.append("<br/><span>Compare with: </span>");
+            hiddenDiv.append(osrmLink);
+            var googleLink = $("<a>Google</a> ");
+            var addToGoogle = "";
+            var addToBing = "";
+            if (request.vehicle.toUpperCase() === "FOOT") {
+                addToGoogle = "&dirflg=w";
+                addToBing = "&mode=W";
+            } else if ((request.vehicle.toUpperCase().indexOf("BIKE") >= 0) ||
+                    (request.vehicle.toUpperCase() === "MTB")) {
+                addToGoogle = "&dirflg=b";
+                // ? addToBing = "&mode=B";
+            }
+
+            googleLink.attr("href", "https://maps.google.com/?saddr=" + request.from + "&daddr=" + request.to + addToGoogle);
+            hiddenDiv.append(googleLink);
+            var bingLink = $("<a>Bing</a> ");
+            bingLink.attr("href", "https://www.bing.com/maps/default.aspx?rtp=adr." + request.from + "~adr." + request.to + addToBing);
+            hiddenDiv.append(bingLink);
+            $("#info").append(hiddenDiv);
         }
     });
 }
 
 function createDistanceString(dist) {
-    if(dist < 900)
+    if (dist < 900)
         return round(dist, 1) + tr2("mAbbr");
-    
+
     dist = round(dist / 1000, 100);
     if (dist > 100)
         dist = round(dist, 1);
@@ -798,43 +1128,70 @@ function createTimeString(time) {
     return resTimeStr;
 }
 
-function addInstruction(main, indi, title, distance, milliEntry, latLng) {
-    var indiPic = "<img class='instr_pic' style='vertical-align: middle' src='" +
-            window.location.pathname + "img/" + indi + ".png'/>";
+function addInstruction(main, instr, instrIndex, lngLat) {
+    var sign = instr.sign;
+    if (instrIndex === 0)
+        sign = "marker-icon-green";
+    else if (sign === -3)
+        sign = "sharp_left";
+    else if (sign === -2)
+        sign = "left";
+    else if (sign === -1)
+        sign = "slight_left";
+    else if (sign === 0)
+        sign = "continue";
+    else if (sign === 1)
+        sign = "slight_right";
+    else if (sign === 2)
+        sign = "right";
+    else if (sign === 3)
+        sign = "sharp_right";
+    else if (sign === 4)
+        sign = "marker-icon-red";
+    else if (sign === 5)
+        sign = "marker-icon-blue";
+    else if (sign === 6)
+        sign = "roundabout";
+    else
+        throw "did not found sign " + sign;
+    var title = instr.text;
+    if (instr.annotationText) {
+        if (!title)
+            title = instr.annotationText;
+        else
+            title = title + ", " + instr.annotationText;
+    }
+    var distance = instr.distance;
     var str = "<td class='instr_title'>" + title + "</td>";
 
     if (distance > 0) {
-        str += " <td class='instr_distance_td'><span class='instr_distance'>" + createDistanceString(distance) + "<br/>"
-                + createTimeString(milliEntry) + "</span></td>";
+        str += " <td class='instr_distance'><span>"
+                + createDistanceString(distance) + "<br/>"
+                + createTimeString(instr.time) + "</span></td>";
     }
 
-    if (indi !== "continue")
-        str = "<td>" + indiPic + "</td>" + str;
-    else
-        str = "<td/>" + str;
+    if (sign !== "continue") {
+        var indiPic = "<img class='pic' style='vertical-align: middle' src='" +
+                window.location.pathname + "img/" + sign + ".png'/>";
+        str = "<td class='instr_pic'>" + indiPic + "</td>" + str;
+    } else
+        str = "<td class='instr_pic'/>" + str;
     var instructionDiv = $("<tr class='instruction'/>");
     instructionDiv.html(str);
-    if (latLng) {
-        instructionDiv.click(function() {
-            hideRouteSegmentPopup();
-            showRouteSegmentPopup(indiPic + " " + title, latLng);
+    if (lngLat) {
+        instructionDiv.click(function () {
+            if (routeSegmentPopup)
+                map.removeLayer(routeSegmentPopup);
+
+            routeSegmentPopup = L.popup().
+                    setLatLng([lngLat[1], lngLat[0]]).
+                    setContent(title).
+                    openOn(map);
         });
     }
     main.append(instructionDiv);
 }
 
-function showRouteSegmentPopup(html, latLng) {
-    hideRouteSegmentPopup();
-    routeSegmentPopup = L.popup().setLatLng(latLng).setContent(html).openOn(map);
-}
-
-function hideRouteSegmentPopup() {
-    if (routeSegmentPopup) {
-        map.removeLayer(routeSegmentPopup);
-        routeSegmentPopup = null;
-    }
-}
-
 function getCenter(bounds) {
     var center = {
         lat: 0,
@@ -854,10 +1211,6 @@ function parseUrlWithHisto() {
     return parseUrl(window.location.search);
 }
 
-function parseUrlAndRequest() {
-    return parseUrl(window.location.search);
-}
-
 function parseUrl(query) {
     var index = query.indexOf('?');
     if (index >= 0)
@@ -872,40 +1225,81 @@ function parseUrl(query) {
         var key = vars[i].substring(0, indexPos);
         var value = vars[i].substring(indexPos + 1);
         value = decodeURIComponent(value.replace(/\+/g, ' '));
+        if (value === "")
+            continue;
 
-        if (typeof res[key] === "undefined")
-            res[key] = value;
-        else if (typeof res[key] === "string") {
+        if (key === "point" && !res[key]) {
+            res[key] = [value];
+        } else if (typeof res[key] === "string") {
             var arr = [res[key], value];
             res[key] = arr;
-        } else
+        } else if (typeof res[key] === "undefined") {
+            if (value === 'true') {
+                res[key] = true;
+            } else if (value === 'false') {
+                res[key] = false;
+            } else {
+                var tmp = Number(value);
+                if (isNaN(tmp))
+                    res[key] = value;
+                else
+                    res[key] = Number(value);
+            }
+        } else {
             res[key].push(value);
-
+        }
     }
     return res;
 }
 
 function mySubmit() {
-    var fromStr = $("#fromInput").val();
-    var toStr = $("#toInput").val();
-    if (toStr == "To" && fromStr == "From") {
+    var fromStr,
+            toStr,
+            viaStr,
+            allStr = [],
+            inputOk = true;
+    var location_points = $("#locationpoints > div.pointDiv > input.pointInput");
+    var len = location_points.size();
+    $.each(location_points, function (index) {
+        if (index === 0) {
+            fromStr = $(this).val();
+            if (fromStr !== tr("fromHint") && fromStr !== "")
+                allStr.push(fromStr);
+            else
+                inputOk = false;
+        } else if (index === (len - 1)) {
+            toStr = $(this).val();
+            if (toStr !== tr("toHint") && toStr !== "")
+                allStr.push(toStr);
+            else
+                inputOk = false;
+        } else {
+            viaStr = $(this).val();
+            if (viaStr !== tr("viaHint") && viaStr !== "")
+                allStr.push(viaStr);
+            else
+                inputOk = false;
+        }
+    });
+    if (!inputOk) {
         // TODO print warning
         return;
     }
-    if (fromStr == "From") {
+    if (fromStr === tr("fromHint")) {
         // no special function
         return;
     }
-    if (toStr == "To") {
+    if (toStr === tr("toHint")) {
         // lookup area
-        ghRequest.from = new GHInput(fromStr);
-        $.when(resolveFrom()).done(function() {
-            focus(ghRequest.from);
+        ghRequest.from.setStr(fromStr);
+        $.when(resolveFrom()).done(function () {
+            focus(ghRequest.from, null, 0);
         });
         return;
     }
     // route!
-    resolveCoords(fromStr, toStr);
+    if (inputOk)
+        resolveCoords(allStr);
 }
 
 function floor(val, precision) {
@@ -925,19 +1319,19 @@ function tr(key, args) {
 }
 
 function tr2(key, args) {
-    if (key == null) {
-        console.log("ERROR: key was null?");
+    if (key === null) {
+        log("ERROR: key was null?");
         return "";
     }
-    if (defaultTranslationMap == null) {
-        console.log("ERROR: defaultTranslationMap was not initialized?");
+    if (defaultTranslationMap === null) {
+        log("ERROR: defaultTranslationMap was not initialized?");
         return key;
     }
     key = key.toLowerCase();
     var val = defaultTranslationMap[key];
-    if (val == null && enTranslationMap)
+    if (!val && enTranslationMap)
         val = enTranslationMap[key];
-    if (val == null)
+    if (!val)
         return key;
 
     return stringFormat(val, args);
@@ -949,15 +1343,15 @@ function stringFormat(str, args) {
 
     if (str.indexOf("%1$s") >= 0) {
         // with position arguments ala %2$s
-        return str.replace(/\%(\d+)\$s/g, function(match, matchingNum) {
+        return str.replace(/\%(\d+)\$s/g, function (match, matchingNum) {
             matchingNum--;
-            return typeof args[matchingNum] != 'undefined' ? args[matchingNum] : match;
+            return typeof args[matchingNum] !== 'undefined' ? args[matchingNum] : match;
         });
     } else {
         // no position so only values ala %s
         var matchingNum = 0;
-        return str.replace(/\%s/g, function(match) {
-            var val = typeof args[matchingNum] != 'undefined' ? args[matchingNum] : match;
+        return str.replace(/\%s/g, function (match) {
+            var val = typeof args[matchingNum] !== 'undefined' ? args[matchingNum] : match;
             matchingNum++;
             return val;
         });
@@ -966,116 +1360,153 @@ function stringFormat(str, args) {
 
 function initI18N() {
     $('#searchButton').attr("value", tr("searchButton"));
-    $('#fromInput').attr("placeholder", tr("fromHint"));
-    $('#toInput').attr("placeholder", tr("toHint"));
+    location_points = $("#locationpoints > div.pointDiv > input.pointInput");
+    var l = location_points.size();
+    $(location_points).each(function (index) {
+        if (index === 0)
+            $(this).attr("placeholder", tr("fromHint"));
+        else if (index === (l - 1))
+            $(this).attr("placeholder", tr("toHint"));
+        else
+            $(this).attr("placeholder", tr("viaHint"));
+    });
+    $('#gpxExportButton').attr("title", tr("gpxExportButton"));
 }
 
 function exportGPX() {
-    if (ghRequest.from.isResolved() && ghRequest.to.isResolved())
+    if (ghRequest.route.isResolved())
         window.open(ghRequest.createGPXURL());
     return false;
 }
 
-function getAutoCompleteDiv(fromOrTo) {
-    if (fromOrTo === "from")
-        return $('#fromInput')
-    else
-        return $('#toInput');
+function getAutoCompleteDiv(index) {
+    return $('#locationpoints > div.pointDiv').eq(index).find(".pointInput");
 }
 
-function setAutoCompleteList(fromOrTo, ghRequestLoc) {
-    function formatValue(suggestionValue, currentValue) {
-        var pattern = '(' + $.Autocomplete.utils.escapeRegExChars(currentValue) + ')';
-        return suggestionValue.replace(new RegExp(pattern, 'gi'), '<strong>$1<\/strong>');
-    }
-    var isFrom = fromOrTo === "from";
-    var pointIndex = isFrom ? 1 : 2;
-    var fakeCurrentInput = ghRequestLoc.input.toLowerCase();
-    var valueDataList = [];
-    var list = ghRequestLoc.resolvedList;
-    for (var index in list) {
-        var dataItem = list[index];
-        valueDataList.push({value: dataToText(dataItem), data: dataItem});
-    }
+function hideAutoComplete() {
+    $(':input[id$="_Input"]').autocomplete().hide();
+}
+
+function formatValue(orig, query) {
+    var pattern = '(' + $.Autocomplete.utils.escapeRegExChars(query) + ')';
+    return orig.replace(new RegExp(pattern, 'gi'), '<strong>$1<\/strong>');
+}
+
+function setAutoCompleteList(index) {
+    var myAutoDiv = getAutoCompleteDiv(index);
 
     var options = {
+        containerClass: "autocomplete",
+        /* as we use can potentially use jsonp we need to set the timeout to a small value */
+        timeout: 1000,
+        /* avoid too many requests when typing quickly */
+        deferRequestBy: 5,
+        minChars: 2,
         maxHeight: 510,
+        noCache: true,
+        /* this default could be problematic: preventBadQueries: true, */
         triggerSelectOnValidInput: false,
         autoSelectFirst: false,
-        lookup: valueDataList,
-        onSearchError: function(element, q, jqXHR, textStatus, errorThrown) {
-            console.log(element + ", " + q + ", textStatus " + textStatus + ", " + errorThrown);
+        paramName: "q",
+        dataType: ghRequest.dataType,
+        onSearchStart: function (params) {
+            // query server only if not a parsable point (i.e. format lat,lon)
+            var val = new GHInput(params.q).lat;
+            return val === undefined;
+        },
+        serviceUrl: function () {
+            // see https://graphhopper.com/#directions-api
+            return ghRequest.createGeocodeURL(host, index - 1);
+        },
+        transformResult: function (response, originalQuery) {
+            response.suggestions = [];
+            if (response.hits)
+                for (var i = 0; i < response.hits.length; i++) {
+                    var hit = response.hits[i];
+                    response.suggestions.push({value: dataToText(hit), data: hit});
+                }
+            return response;
         },
-        formatResult: function(suggestion, currInput) {
+        onSearchError: function (element, q, jqXHR, textStatus, errorThrown) {
+            // too many errors if interrupted console.log(element + ", " + JSON.stringify(q) + ", textStatus " + textStatus + ", " + errorThrown);
+        },
+        formatResult: function (suggestion, currInput) {
             // avoid highlighting for now as this breaks the html sometimes
-            return dataToHtml(suggestion.data);
+            return dataToHtml(suggestion.data, currInput);
+        },
+        onSelect: function (suggestion) {
+            options.onPreSelect(suggestion);
         },
-        lookupFilter: function(suggestion, originalQuery, queryLowerCase) {
-            if (queryLowerCase === fakeCurrentInput)
-                return true;
-            return suggestion.value.toLowerCase().indexOf(queryLowerCase) !== -1;
+        onPreSelect: function (suggestion) {
+            var req = ghRequest.route.getIndex(index);
+
+            myAutoDiv.autocomplete().disable();
+
+            var point = suggestion.data.point;
+            req.setCoord(point.lat, point.lng);
+
+            req.input = suggestion.value;
+            if (!routeIfAllResolved(true))
+                focus(req, 15, index);
+
+            myAutoDiv.autocomplete().enable();
         }
     };
-    options.onSelect = function(suggestion) {
-        options.onPreSelect(suggestion);
-        if (ghRequest.from.isResolved() && ghRequest.to.isResolved())
-            routeLatLng(ghRequest);
-    };
-    options.onPreSelect = function(suggestion) {
-        var data = suggestion.data;
-        ghRequestLoc.setCoord(data.lat, data.lng);
-        ghRequestLoc.input = dataToText(suggestion.data);
-        if (suggestion.data.boundingbox) {
-            var bbox = suggestion.data.box;
-            focusWithBounds(ghRequestLoc, [[bbox[0], bbox[2]], [bbox[1], bbox[3]]], isFrom);
-        } else
-            focus(ghRequestLoc, 15, isFrom);
-    };
 
-    options.containerClass = "complete-" + pointIndex;
-    var myAutoDiv = getAutoCompleteDiv(fromOrTo);
     myAutoDiv.autocomplete(options);
-    myAutoDiv.autocomplete().forceSuggest("");
-    myAutoDiv.focus();
+
+    // with the following more stable code we cannot click on suggestions anylonger
+//    $("#" + fromOrTo + "Input").focusout(function() {
+//        myAutoDiv.autocomplete().disable();
+//        myAutoDiv.autocomplete().hide();
+//    });
+//    $("#" + fromOrTo + "Input").focusin(function() {
+//        myAutoDiv.autocomplete().enable();
+//    });
 }
 
-function dataToHtml(data) {
-    var data = data.locationDetails;
-    var text = "";
-    if (data.road)
-        text += "<div class='roadseg'>" + data.road + "</div>";
-    if (data.city) {
-        text += "<div class='cityseg'>" + insComma(data.city, data.country) + "</div>";
-    }
+function dataToHtml(data, query) {
+    var element = "";
+    if (data.name)
+        element += "<div class='nameseg'>" + formatValue(data.name, query) + "</div>";
+    var addStr = "";
+    if (data.postcode)
+        addStr = data.postcode;
+    if (data.city)
+        addStr = insComma(addStr, data.city);
     if (data.country)
-        text += "<div class='moreseg'>" + data.more + "</div>";
-    return text;
+        addStr = insComma(addStr, data.country);
+
+    if (addStr)
+        element += "<div class='cityseg'>" + formatValue(addStr, query) + "</div>";
+
+    if (data.osm_key === "highway") {
+        // ignore
+    }
+    if (data.osm_key === "place") {
+        element += "<span class='moreseg'>" + data.osm_value + "</span>";
+    } else
+        element += "<span class='moreseg'>" + data.osm_key + "</span>";
+    return element;
 }
 
-// do not print everything as nominatim slows down or doesn't properly handle if continent etc is included
 function dataToText(data) {
-    var data = data.locationDetails;
     var text = "";
-    if (data.road)
-        text += data.road;
+    if (data.name)
+        text += data.name;
 
-    if (data.city) {
-        if (text.length > 0)
-            text += ", ";
-        text += data.city;
-    }
+    if (data.postcode)
+        text = insComma(text, data.postcode);
 
-    if (data.postcode) {
-        if (text.length > 0)
-            text += ", ";
-        text += data.postcode;
-    }
+    // make sure name won't be duplicated
+    if (data.city && text.indexOf(data.city) < 0)
+        text = insComma(text, data.city);
 
-    if (data.country) {
-        if (text.length > 0)
-            text += ", ";
-        var tmp = $.trim(data.country.replace(data.city, '').replace(data.city + ", ", ''));
-        text += tmp;
-    }
+    if (data.country && text.indexOf(data.country) < 0)
+        text = insComma(text, data.country);
     return text;
 }
+
+function isProduction() {
+    return host.indexOf("graphhopper.com") > 0;
+}
\ No newline at end of file
diff --git a/web/src/test/java/com/graphhopper/http/BaseServletTest.java b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
similarity index 57%
rename from web/src/test/java/com/graphhopper/http/BaseServletTest.java
rename to web/src/test/java/com/graphhopper/http/BaseServletTester.java
index 90c6a33912..b1c47148fe 100644
--- a/web/src/test/java/com/graphhopper/http/BaseServletTest.java
+++ b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
@@ -20,16 +20,8 @@
 import com.google.inject.Guice;
 import com.google.inject.Injector;
 import com.google.inject.Module;
-import com.google.inject.servlet.GuiceFilter;
-import com.graphhopper.util.Constants;
+import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Downloader;
-import java.util.EnumSet;
-import javax.servlet.DispatcherType;
-import org.eclipse.jetty.server.Connector;
-import org.eclipse.jetty.server.Server;
-import org.eclipse.jetty.server.bio.SocketConnector;
-import org.eclipse.jetty.webapp.WebAppContext;
-import org.eclipse.jetty.webapp.WebXmlConfiguration;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -37,10 +29,10 @@
 /**
  * @author Peter Karich
  */
-public class BaseServletTest
+public class BaseServletTester
 {
-    private static Server server;
-    protected static Logger logger = LoggerFactory.getLogger(GraphHopperServletIT.class);
+    private static GHServer server;
+    protected static Logger logger = LoggerFactory.getLogger(BaseServletTester.class);
     protected static int port;
     protected Injector injector;
 
@@ -52,60 +44,32 @@ public void setUpGuice( Module... modules )
     /**
      * This method will start jetty with andorra area loaded as OSM.
      */
-    public void setUpJetty()
+    public void setUpJetty( CmdArgs args )
     {
         if (injector != null)
             throw new UnsupportedOperationException("do not call guice before");
 
-        bootJetty(3);
+        bootJetty(args, 3);
     }
 
-    private void bootJetty( int retryCount )
+    private void bootJetty( CmdArgs args, int retryCount )
     {
         if (server != null)
             return;
 
-        System.setProperty("graphhopper.config", "../config-example.properties");
-        System.setProperty("graphhopper.osmreader.osm", "../core/files/andorra.osm.pbf");
-        System.setProperty("graphhopper.graph.location", "./target/andorra-gh/");
+        server = new GHServer(args);
 
-        String webapp = "./target/graphhopper-web-" + Constants.VERSION;
-        WebAppContext app = new WebAppContext(webapp, "/");
-        // jetty 8:
-        app.addFilter(GuiceFilter.class, "/*", EnumSet.allOf(DispatcherType.class));
-        // jetty 7:
-        // app.addFilter(GuiceFilter.class, "/*", 0);
-        app.setConfigurationClasses(new String[]
-        {
-            WebXmlConfiguration.class.getName()
-        });
-
-        app.addEventListener(new GuiceServletConfig()
-        {
-            @Override
-            protected Injector getInjector()
-            {
-                if (injector == null)
-                    setUpGuice(createDefaultModule(), createServletModule());
-
-                return injector;
-            }
-        });
-        app.setParentLoaderPriority(true);
+        if (injector == null)
+            setUpGuice(new DefaultModule(args), new GHServletModule(args));
 
         for (int i = 0; i < retryCount; i++)
         {
-            // We explicitly use the SocketConnector because the SelectChannelConnector locks files
-            Connector connector = new SocketConnector();
-            connector.setPort(port = 18080 + i);
-            connector.setMaxIdleTime(10000);
-            server = new Server();
-            server.addConnector(connector);
-            server.setHandler(app);
+            port = 18080 + i;
+            args.put("jetty.port", "" + port);
             try
             {
                 logger.info("Trying to start jetty at port " + port);
-                server.start();
+                server.start(injector);
 //                server.join();
                 break;
             } catch (Exception ex)
@@ -116,7 +80,7 @@ protected Injector getInjector()
         }
     }
 
-    public void shutdownJetty( boolean force )
+    public static void shutdownJetty( boolean force )
     {
         // this is too slow so allow force == false. Then on setUpJetty a new server is created on a different port
         if (force && server != null)
@@ -128,16 +92,13 @@ public void shutdownJetty( boolean force )
                 logger.error("Cannot stop jetty", ex);
             }
 
-        if (injector != null)
-            new GuiceFilter().destroy();
-        injector = null;
         server = null;
     }
 
     protected String getTestAPIUrl()
     {
         String host = "localhost";
-        return "http://" + host + ":" + port + "/api/route";
+        return "http://" + host + ":" + port + "/route";
     }
 
     protected JSONObject query( String query ) throws Exception
@@ -156,5 +117,5 @@ protected JSONObject query( String query ) throws Exception
         String url = getTestAPIUrl() + "?" + resQuery;
         Downloader downloader = new Downloader("web integration tester");
         return new JSONObject(downloader.downloadAsString(url));
-    }
+    }    
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 3e25c77607..10a09d601d 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -20,7 +20,11 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopperAPI;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import java.io.File;
 import org.json.JSONObject;
+import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
 import static org.junit.Assert.*;
@@ -28,25 +32,59 @@
 /**
  * @author Peter Karich
  */
-public class GraphHopperServletIT extends BaseServletTest {
+public class GraphHopperServletIT extends BaseServletTester
+{
+    private static final String dir = "./target/andorra-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
 
     @Before
-    public void setUp() {
-        setUpJetty();
+    public void setUp()
+    {
+        CmdArgs args = new CmdArgs().
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/andorra.osm.pbf").
+                put("graph.location", dir);
+        setUpJetty(args);
     }
 
     @Test
-    public void testBasicQuery() throws Exception {
+    public void testBasicQuery() throws Exception
+    {
         JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128");
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
-        double distance = json.getJSONObject("route").getDouble("distance");
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
         assertTrue("distance wasn't correct:" + distance, distance > 9000);
         assertTrue("distance wasn't correct:" + distance, distance < 9500);
     }
 
     @Test
-    public void testGraphHopperWeb() throws Exception {
+    public void testJsonRounding() throws Exception
+    {
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false");
+        JSONObject cson = json.getJSONArray("paths").getJSONObject(0).getJSONObject("points");
+        assertTrue("unexpected precision!", cson.toString().indexOf("[1.536374,42.554839]") >= 0);
+    }
+
+    @Test
+    public void testFailIfElevationRequestedButNotIncluded() throws Exception
+    {
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true");
+        JSONObject infoJson = json.getJSONObject("info");
+        assertTrue(infoJson.has("errors"));
+        assertEquals("Elevation not supported!", infoJson.getJSONArray("errors").getJSONObject(0).getString("message"));
+    }
+
+    @Test
+    public void testGraphHopperWeb() throws Exception
+    {
         GraphHopperAPI hopper = new GraphHopperWeb();
         assertTrue(hopper.load(getTestAPIUrl()));
         GHResponse rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128));
@@ -54,4 +92,42 @@ public void testGraphHopperWeb() throws Exception {
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 9000);
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 9500);
     }
+
+    @Test
+    public void testGraphHopperWebRealExceptions()
+    {
+        GHResponse rsp;
+        Throwable ex;
+
+        GraphHopperAPI hopper = new GraphHopperWeb();
+        assertTrue(hopper.load(getTestAPIUrl()));
+
+        // IllegalStateException (Wrong Request)
+        rsp = hopper.route(new GHRequest());
+        assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
+
+        ex = rsp.getErrors().get(0);
+        assertTrue("Wrong Exception found: " + ex.getClass().getName()
+            + ", IllegalStateException expected.", ex instanceof IllegalStateException);
+
+        // IllegalArgumentException (Wrong Points)
+        rsp = hopper.route(new GHRequest(0.0, 0.0, 0.0, 0.0));
+        assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
+
+        ex = rsp.getErrors().get(0);
+        assertTrue("Wrong Exception found: " + ex.getClass().getName()
+                + ", IllegalArgumentException expected.", ex instanceof IllegalArgumentException);
+
+        // IllegalArgumentException (Vehicle not supported)
+        rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128).setVehicle("SPACE-SHUTTLE"));
+        assertFalse("Errors expected but not found.", rsp.getErrors().isEmpty());
+
+        ex = rsp.getErrors().get(0);
+        assertTrue("Wrong Exception found: " + ex.getClass().getName()
+                + ", IllegalArgumentException expected.", ex instanceof IllegalArgumentException);
+
+        // UnsupportedOperationException
+        // RuntimeException
+        // Exception
+    }
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
new file mode 100644
index 0000000000..a70129ef98
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -0,0 +1,97 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import java.io.File;
+import org.json.JSONObject;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperServletWithEleIT extends BaseServletTester
+{
+    private static final String dir = "./target/monaco-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
+
+    @Before
+    public void setUp()
+    {
+        CmdArgs args = new CmdArgs().
+                put("graph.elevation.provider", "srtm").
+                put("graph.elevation.cachedir", "../core/files/").
+                put("prepare.chWeighting", "no").
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/monaco.osm.gz").
+                put("graph.location", dir);
+        setUpJetty(args);
+    }
+
+    @Test
+    public void testElevation() throws Exception
+    {
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=true");
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 2500);
+        assertTrue("distance wasn't correct:" + distance, distance < 2700);
+
+        JSONObject cson = path.getJSONObject("points");
+        assertTrue("no elevation?", cson.toString().contains("[7.421392,43.7307,66]"));
+
+        // Although we include elevation DO NOT include it in the bbox as bbox.toGeoJSON messes up when reading
+        // or reading with and without elevation would be too complex for the client with no real use
+        assertEquals(4, path.getJSONArray("bbox").length());
+    }
+
+    @Test
+    public void testNoElevation() throws Exception
+    {
+        // default is elevation=false
+        JSONObject json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false");
+        JSONObject infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        JSONObject path = json.getJSONArray("paths").getJSONObject(0);
+        double distance = path.getDouble("distance");
+        assertTrue("distance wasn't correct:" + distance, distance > 2500);
+        assertTrue("distance wasn't correct:" + distance, distance < 2700);
+        JSONObject cson = path.getJSONObject("points");
+        assertTrue("Elevation should not be included!", cson.toString().indexOf("[7.421392,43.7307]") >= 0);
+
+        // disable elevation
+        json = query("point=43.730864,7.420771&point=43.727687,7.418737&points_encoded=false&elevation=false");
+        infoJson = json.getJSONObject("info");
+        assertFalse(infoJson.has("errors"));
+        path = json.getJSONArray("paths").getJSONObject(0);
+        cson = path.getJSONObject("points");
+        assertTrue("Elevation should not be included!", cson.toString().indexOf("[7.421392,43.7307]") >= 0);
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
index ce3613d35d..6b29124e4d 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
@@ -22,7 +22,6 @@
 import com.graphhopper.util.Downloader;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.HttpURLConnection;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -30,35 +29,46 @@
  *
  * @author Peter Karich
  */
-public class GraphHopperWebTest {
+public class GraphHopperWebTest
+{
 
     @Test
-    public void testReadUnencoded() throws Exception {
-        Downloader downloader = new Downloader("GraphHopper Test") {
+    public void testReadUnencoded() throws Exception
+    {
+        Downloader downloader = new Downloader("GraphHopper Test")
+        {
             @Override
-            public InputStream fetch(String url) throws IOException {
+            public InputStream fetch( String url ) throws IOException
+            {
                 return getClass().getResourceAsStream("test.json");
             }
         };
-        GraphHopperWeb instance = new GraphHopperWeb().setEncodePolyline(false);
+        GraphHopperWeb instance = new GraphHopperWeb().setPointsEncoded(false);
         instance.setDownloader(downloader);
-        GHResponse res = instance.route(new GHRequest(11.561415, 49.9516, 11.560439, 49.950357));
-        assertEquals(0.218915, res.getDistance(), 1e-5);
-        assertEquals(7, res.getPoints().getSize());
+        GHResponse res = instance.route(new GHRequest(52.47379, 13.362808, 52.4736925, 13.3904394));
+        assertEquals(2138.3, res.getDistance(), 1e-1);
+        assertEquals(17, res.getPoints().getSize());
+        assertEquals(5, res.getInstructions().getSize());
     }
 
     @Test
-    public void testReadEncoded() throws Exception {
-        Downloader downloader = new Downloader("GraphHopper Test") {
+    public void testReadEncoded() throws Exception
+    {
+        Downloader downloader = new Downloader("GraphHopper Test")
+        {
             @Override
-            public InputStream fetch(String url) throws IOException {
+            public InputStream fetch( String url ) throws IOException
+            {
                 return getClass().getResourceAsStream("test_encoded.json");
             }
         };
-        GraphHopperWeb instance = new GraphHopperWeb().setEncodePolyline(true);
+        GraphHopperWeb instance = new GraphHopperWeb().setPointsEncoded(true);
         instance.setDownloader(downloader);
-        GHResponse res = instance.route(new GHRequest(11.561415, 49.9516, 11.560439, 49.950357));
-        assertEquals(0.218915, res.getDistance(), 1e-5);
-        assertEquals(7, res.getPoints().getSize());
+        GHResponse res = instance.route(new GHRequest(52.47379, 13.362808, 52.4736925, 13.3904394));
+        assertEquals(2138.3, res.getDistance(), 1e-1);
+        assertEquals(17, res.getPoints().getSize());
+        assertEquals(5, res.getInstructions().getSize());
+        assertEquals("(0,Geradeaus auf A 100,1268.519329705091,65237)", res.getInstructions().get(0).toString());
+        assertEquals(11, res.getInstructions().get(0).getPoints().size());
     }
 }
diff --git a/web/src/test/java/com/graphhopper/http/IPFilterTest.java b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
new file mode 100644
index 0000000000..dc2470b6f2
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/IPFilterTest.java
@@ -0,0 +1,55 @@
+package com.graphhopper.http;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class IPFilterTest
+{
+    @Test
+    public void testAcceptWhite()
+    {
+        IPFilter instance = new IPFilter("1.2.3.4, 4.5.67.1", "");
+        assertTrue(instance.accept("1.2.3.4"));
+        assertTrue(instance.accept("4.5.67.1"));
+        assertFalse(instance.accept("1.2.3.5"));
+
+        instance = new IPFilter("1.2.3*, 4.5.67.1, 7.8.*.3", "");
+        assertTrue(instance.accept("1.2.3.4"));
+        assertTrue(instance.accept("4.5.67.1"));
+        assertTrue(instance.accept("1.2.3.5"));
+        assertFalse(instance.accept("1.3.5.7"));
+
+        assertTrue(instance.accept("7.8.5.3"));
+        assertFalse(instance.accept("7.88.5.3"));
+    }
+
+    @Test
+    public void testAcceptBlack()
+    {
+        IPFilter instance = new IPFilter("", "1.2.3.4, 4.5.67.1");
+
+        assertFalse(instance.accept("1.2.3.4"));
+        assertFalse(instance.accept("4.5.67.1"));
+        assertTrue(instance.accept("1.2.3.5"));
+    }
+
+    @Test
+    public void testFilterSpecialCases()
+    {
+        IPFilter instance = new IPFilter("", "");
+        assertTrue(instance.accept("1.2.3.4"));
+
+        try
+        {
+            new IPFilter("1.2.3.4, 4.5.67.1", "8.9.7.3");
+            assertFalse("black and white", true);
+        } catch (Exception ex)
+        {
+
+        }
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/WebHelperTest.java b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
index aad3f09aa4..4276ca4ed5 100644
--- a/web/src/test/java/com/graphhopper/http/WebHelperTest.java
+++ b/web/src/test/java/com/graphhopper/http/WebHelperTest.java
@@ -31,10 +31,10 @@
     @Test
     public void testDecode() throws Exception
     {
-        PointList list = WebHelper.decodePolyline("_p~iF~ps|U", 1);
+        PointList list = WebHelper.decodePolyline("_p~iF~ps|U", 1, false);
         assertEquals(Helper.createPointList(38.5, -120.2), list);
 
-        list = WebHelper.decodePolyline("_p~iF~ps|U_ulLnnqC_mqNvxq`@", 3);
+        list = WebHelper.decodePolyline("_p~iF~ps|U_ulLnnqC_mqNvxq`@", 3, false);
         assertEquals(Helper.createPointList(38.5, -120.2, 40.7, -120.95, 43.252, -126.453), list);
     }
 
@@ -54,11 +54,29 @@ public void testBoth() throws Exception
         PointList list = Helper.createPointList(38.5, -120.2, 43.252, -126.453,
                 40.7, -120.95, 50.3139, 10.61279, 50.04303, 9.49768);
         String str = WebHelper.encodePolyline(list);
-        assertEquals(list, WebHelper.decodePolyline(str, list.getSize()));
+        assertEquals(list, WebHelper.decodePolyline(str, list.getSize(), false));
 
         list = Helper.createPointList(38.5, -120.2, 43.252, -126.453,
                 40.7, -120.95, 40.70001, -120.95001);
         str = WebHelper.encodePolyline(list);
-        assertEquals(list, WebHelper.decodePolyline(str, list.getSize()));
+        assertEquals(list, WebHelper.decodePolyline(str, list.getSize(), false));
+    }
+
+    @Test
+    public void testDecode3D() throws Exception
+    {
+        PointList list = WebHelper.decodePolyline("_p~iF~ps|Uo}@", 1, true);
+        assertEquals(Helper.createPointList3D(38.5, -120.2, 10), list);
+
+        list = WebHelper.decodePolyline("_p~iF~ps|Uo}@_ulLnnqC_anF_mqNvxq`@?", 3, true);
+        assertEquals(Helper.createPointList3D(38.5, -120.2, 10, 40.7, -120.95, 1234, 43.252, -126.453, 1234), list);
+    }
+
+    @Test
+    public void testEncode3D() throws Exception
+    {
+        assertEquals("_p~iF~ps|Uo}@", WebHelper.encodePolyline(Helper.createPointList3D(38.5, -120.2, 10)));
+        assertEquals("_p~iF~ps|Uo}@_ulLnnqC_anF_mqNvxq`@?", WebHelper.encodePolyline(
+                Helper.createPointList3D(38.5, -120.2, 10, 40.7, -120.95, 1234, 43.252, -126.453, 1234)));
     }
 }
diff --git a/web/src/test/java/log4j.properties b/web/src/test/java/log4j.properties
deleted file mode 100644
index 32f66a18ad..0000000000
--- a/web/src/test/java/log4j.properties
+++ /dev/null
@@ -1,9 +0,0 @@
-# separate logging config to disable INFO
-
-log4j.appender.StdoutApp=org.apache.log4j.ConsoleAppender
-log4j.appender.StdoutApp.layout=org.apache.log4j.PatternLayout
-log4j.appender.StdoutApp.layout.conversionPattern=%d [%t] %-5p %c - %m%n
-
-log4j.rootLogger=INFO
-log4j.logger.com.graphhopper=INFO, StdoutApp
-log4j.logger.org.eclipse=INFO, StdoutApp
diff --git a/web/src/test/java/log4j.xml b/web/src/test/java/log4j.xml
new file mode 100644
index 0000000000..a226ebca8e
--- /dev/null
+++ b/web/src/test/java/log4j.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration>
+    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
+        </layout>
+    </appender>
+    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
+        <param name="BufferSize" value="500"/>
+        <appender-ref ref="stdout"/>
+    </appender>    
+    <logger name="com.graphhopper" additivity="false">
+        <level value="info" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <logger name="org.eclipse" additivity="false">
+        <level value="info" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <root>
+        <priority value="info"></priority>
+        <appender-ref ref="ASYNC"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
diff --git a/web/src/test/resources/com/graphhopper/http/test.json b/web/src/test/resources/com/graphhopper/http/test.json
index 90f154897d..734968699f 100644
--- a/web/src/test/resources/com/graphhopper/http/test.json
+++ b/web/src/test/resources/com/graphhopper/http/test.json
@@ -1,17 +1,139 @@
 {
-    "route":{
-        "data":{
-            "type":"LineString",
-            "coordinates":[[11.561414299042843,49.95161928128345],[11.561526057754294,49.95157271515368],[11.561657746769288,49.95148498456519],[11.562031020865538,49.95108730981694],[11.560899277647568,49.950499272730184],[11.56064409525642,49.950439854348595],[11.560398226091227,49.950342438005116]]
-        },
-        "to":[11.560439,49.950357],
-        "time":16,
-        "distance":0.21891499999999997,
-        "from":[11.561415,49.9516],
-        "bbox":[11.560398226091227,49.950342438005116,11.562031020865538,49.95161928128345]
+  "info": {"took": 0.004322056192904711},
+  "paths": [{
+    "bbox": [
+      13.362853824187303,
+      52.469481955531585,
+      13.385836736460217,
+      52.473849308838446
+    ],
+    "distance": 2138.3027624572337,
+    "instructions": [
+      {
+        "distance": 1268.519329705091,
+        "interval": [
+          0,
+          10
+        ],
+        "sign": 0,
+        "text": "Geradeaus auf A 100",
+        "time": 65237
+      },
+      {
+        "distance": 379.74399999999997,
+        "interval": [
+          10,
+          11
+        ],
+        "sign": 0,
+        "text": "Geradeaus auf Strasse",
+        "time": 24855
+      },
+      {
+        "distance": 16.451,
+        "interval": [
+          11,
+          11
+        ],
+        "sign": 0,
+        "text": "Geradeaus auf Tempelhofer Damm",
+        "time": 1316
+      },
+      {
+        "distance": 473.58843275214315,
+        "interval": [
+          11,
+          12
+        ],
+        "sign": -2,
+        "text": "Links abbiegen auf Tempelhofer Damm, B 96",
+        "time": 37882
+      },
+      {
+        "distance": 0,
+        "interval": [
+          12,
+          12
+        ],
+        "sign": 4,
+        "text": "Ziel erreicht!",
+        "time": 0
+      }
+    ],
+    "points": {
+      "coordinates": [
+        [
+          13.362853824187303,
+          52.473849308838446
+        ],
+        [
+          13.36361795731525,
+          52.47361367509396
+        ],
+        [
+          13.365841769408624,
+          52.47262889458155
+        ],
+        [
+          13.368347585983893,
+          52.47146995674379
+        ],
+        [
+          13.369309455960455,
+          52.47115535597106
+        ],
+        [
+          13.370299824408438,
+          52.470938171541796
+        ],
+        [
+          13.372544498127949,
+          52.47050901808982
+        ],
+        [
+          13.373925277007936,
+          52.47029332377672
+        ],
+        [
+          13.374831267628773,
+          52.470171134252205
+        ],
+        [
+          13.375656233183806,
+          52.47009346194774
+        ],
+        [
+          13.378514089700149,
+          52.46991055019
+        ],
+        [
+          13.379928396193574,
+          52.46987162090551
+        ],
+        [
+          13.384775557773759,
+          52.46952423757742
+        ],
+        [
+          13.385498264107815,
+          52.46948735720264
+        ],
+        [
+          13.385740966776185,
+          52.469481955531585
+        ],
+        [
+          13.385832236390536,
+          52.47358033374504
+        ],
+        [
+          13.385836736460217,
+          52.47374048466245
+        ]
+      ],
+      "type": "LineString"
     },
-    "info":{
-        "took":0.026191529,
-        "tookGeocoding":7.2775E-5
-    }
+    "points_encoded": false,
+    "time": 129290
+  }]
 }
\ No newline at end of file
diff --git a/web/src/test/resources/com/graphhopper/http/test_encoded.json b/web/src/test/resources/com/graphhopper/http/test_encoded.json
index bf3549e22d..7d9f329d7f 100644
--- a/web/src/test/resources/com/graphhopper/http/test_encoded.json
+++ b/web/src/test/resources/com/graphhopper/http/test_encoded.json
@@ -1,14 +1,67 @@
 {
-    "route":{
-        "to":[11.560439,49.950357],
-        "time":16,
-        "distance":0.21891499999999997,
-        "from":[11.561415,49.9516],
-        "coordinates":"qd{oHyaqeAFUPYnAkAtBbFJp@Pp@",
-        "bbox":[11.560398226091227,49.950342438005116,11.562031020865538,49.95161928128345]
-    },
-    "info":{
-        "took":1.184025,
-        "tookGeocoding":7.6336E-5
-    }
+  "info": {"took": 0.00414920412003994},
+  "paths": [{
+    "bbox": [
+      13.362853824187303,
+      52.469481955531585,
+      13.385836736460217,
+      52.473849308838446
+    ],
+    "distance": 2138.3027624572337,
+    "instructions": [
+      {
+        "distance": 1268.519329705091,
+        "interval": [
+          0,
+          10
+        ],
+        "sign": 0,
+        "text": "Geradeaus auf A 100",
+        "time": 65237
+      },
+      {
+        "distance": 379.74399999999997,
+        "interval": [
+          10,
+          11
+        ],
+        "sign": 0,
+        "text": "Geradeaus auf Strasse",
+        "time": 24855
+      },
+      {
+        "distance": 16.451,
+        "interval": [
+          11,
+          11
+        ],
+        "sign": 0,
+        "text": "Geradeaus auf Tempelhofer Damm",
+        "time": 1316
+      },
+      {
+        "distance": 473.58843275214315,
+        "interval": [
+          11,
+          12
+        ],
+        "sign": -2,
+        "text": "Links abbiegen auf Tempelhofer Damm, B 96",
+        "time": 37882
+      },
+      {
+        "distance": 0,
+        "interval": [
+          12,
+          12
+        ],
+        "sign": 4,
+        "text": "Ziel erreicht!",
+        "time": 0
+      }
+    ],
+    "points": "oxg_Iy|ppAl@wCdE}LfFsN|@_Ej@eEtAaMh@sGVuDNcDb@{PFyGdAi]FoC?q@sXQ_@?",
+    "points_encoded": true,
+    "time": 129290
+  }]
 }
\ No newline at end of file
diff --git a/web/src/test/webapp/spec/UtilsSpec.js b/web/src/test/webapp/spec/UtilsSpec.js
index 255632d2b7..5babc0a48f 100644
--- a/web/src/test/webapp/spec/UtilsSpec.js
+++ b/web/src/test/webapp/spec/UtilsSpec.js
@@ -4,18 +4,18 @@
 describe("utils", function() {
     it("should format time string correctly", function() {
         defaultTranslationMap = {};
-        defaultTranslationMap["minabbr"]='min';
-        defaultTranslationMap["hourabbr"]='h';
-        defaultTranslationMap["dayabbr"]='d';
+        defaultTranslationMap["minabbr"] = 'min';
+        defaultTranslationMap["hourabbr"] = 'h';
+        defaultTranslationMap["dayabbr"] = 'd';
         expect(createTimeString(10773331)).toBe("2h 59min");
-        
+
         expect(createTimeString(10773331 * 24)).toBe("2d 23h");
-        
+
         expect(createTimeString(260493166)).toBe("3d");
         expect(createTimeString(3642407)).toBe("1h");
         expect(createTimeString(12000)).toBe("0min");
     });
-    
+
     it("should format translation string correctly", function() {
         // toBe, toBeTruthy, toBeFalsy
         defaultTranslationMap = {};
@@ -52,4 +52,105 @@ describe("utils", function() {
         });
         expect(res).toEqual({postcode: undefined, city: "Rixdorf, Neukölln", country: "Deutschland", more: "Berlin, Europäischen Union"});
     });
+
+    it("should decode the polyline", function() {
+        var list = decodePath("_p~iF~ps|U", false);
+        expect(list).toEqual([[-120.2, 38.5]]);
+
+        list = decodePath("_p~iF~ps|U_ulLnnqC_mqNvxq`@", false);
+        expect(list).toEqual([[-120.2, 38.5], [-120.95, 40.7], [-126.45300000000002, 43.252]]);
+    });
+
+    it("should decode the 3D polyline", function() {
+        var list = decodePath("_p~iF~ps|Uo}@", true);
+        expect(list).toEqual([[-120.2, 38.5, 10]]);
+
+        list = decodePath("_p~iF~ps|Uo}@_ulLnnqC_anF_mqNvxq`@?", true);
+        expect(list).toEqual([[-120.2, 38.5, 10], [-120.95, 40.7, 1234], [-126.45300000000002, 43.252, 1234]]);
+    });
+
+    it("should parse URL correctly", function() {
+        var params = parseUrl("localhost:8989?test=pest&test2=true&test3=false&test4=2&test5=1.1");
+        expect("pest").toEqual(params.test);
+        expect(true).toEqual(params.test2);
+        expect(false).toEqual(params.test3);
+        expect(2).toEqual(params.test4);
+        expect(1.1).toEqual(params.test5);
+        
+        params = parseUrl("blup?point=49.946505%2C11.571232&point=&");        
+        expect(params.point).toEqual("49.946505,11.571232");        
+        
+        params = parseUrl("blup?point=&point=49.946505%2C11.571232");
+        expect(params.point).toEqual("49.946505,11.571232");
+    });
+
+    it("features should work", function() {
+        var ghRequest = new GHRequest("http://test.de?vehicle=car");
+        var params = {};
+        params.elevation = true;
+        ghRequest.features = {"car":{}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(false);
+        
+        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(true);
+        
+        var params = {};
+        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(true);
+        
+        var params = {};
+        params.elevation = false;
+        ghRequest.features = {"car":{ elevation: true}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(false);
+        
+        var params = {};
+        params.elevation = true;
+        ghRequest.features = {"car":{ elevation: false}};
+        ghRequest.init(params);
+        expect(ghRequest.elevation).toEqual(false);
+    });
+    
+    it("ghrequest should init correctly from params", function() {
+        var ghRequest = new GHRequest("http://test.de");
+        var params = {};
+        params.do_zoom = true;
+        ghRequest.init(params);
+        expect(ghRequest.do_zoom).toEqual(params.do_zoom);
+
+        params.do_zoom = false;
+        ghRequest.init(params);
+        expect(ghRequest.do_zoom).toEqual(params.do_zoom);
+    });
+
+    it("input should accept 0 and no addresses", function() {
+        var input = new GHInput("12,0");
+        expect(input.toString()).toEqual("12,0");
+        var input = new GHInput("bluo,0");
+        expect(input.toString()).toEqual(undefined);
+        expect(input.lat).toEqual(undefined);
+        expect(input.lng).toEqual(undefined);
+        var input = new GHInput("bluo");
+        expect(input.toString()).toEqual(undefined);
+        var input = new GHInput("");
+        expect(input.toString()).toEqual(undefined);
+    });
+    
+    it("GHInput should set to unresolved if new input string", function() {
+        var input = new GHInput("12.44, 68.44");
+        expect(input.isResolved()).toEqual(true);
+        input.set("blup");
+        expect(input.isResolved()).toEqual(false);
+    });
+
+    it("point should be parsable", function() {
+        expect(new GHInput("12.44, 68.44").lat).toEqual(12.44);
+        expect(new GHInput("12.44, 68.44").lng).toEqual(68.44);
+        expect(new GHInput("12.44,68.44").lat).toEqual(12.44);
+        expect(new GHInput("12.44,68.44").lng).toEqual(68.44);
+        expect(new GHInput("london").lon).toEqual(undefined);
+    });    
 });
\ No newline at end of file
