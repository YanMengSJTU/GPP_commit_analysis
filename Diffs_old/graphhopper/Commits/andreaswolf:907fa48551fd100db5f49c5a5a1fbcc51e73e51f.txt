diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index f41f4b66b9..44793f264f 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -568,10 +568,14 @@ private void processNode( OSMNode node )
             // analyze node tags for barriers
             if (node.hasTags())
             {
+                int nodeId = -getNodeMap().get(node.getId()) - 3;
                 if (node.hasTag("highway", "traffic_signals"))
                 {
                     // TODO WTF? get node id in a sane way hereâ€¦
-                    roadSigns.markTrafficLight(-getNodeMap().get(node.getId())-3, true);
+                    roadSigns.markTrafficLight(nodeId, true);
+                } else if (node.hasTag("highway", "stop"))
+                {
+                    roadSigns.markStopSign(nodeId, true);
                 }
                 long nodeFlags = encodingManager.handleNodeTags(node);
                 if (nodeFlags != 0)
@@ -595,7 +599,7 @@ boolean addNode( OSMNode node )
         double lat = node.getLat();
         double lon = node.getLon();
         double ele = getElevation(node);
-        if (nodeType == TOWER_NODE || node.hasTag("highway", "traffic_signals"))
+        if (nodeType == TOWER_NODE || hasRoadSign(node))
         {
             addTowerNode(node.getId(), lat, lon, ele);
         } else if (nodeType == PILLAR_NODE)
@@ -719,7 +723,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
                 
                 if (internalNodeId > -TOWER_NODE) // node is pillar node
                 {
-                    boolean convertToTowerNode = i == 0 || i == lastIndex || dataLayer.hasTrafficLight(osmNodeId);
+                    boolean convertToTowerNode = i == 0 || i == lastIndex;
                     if (!convertToTowerNode)
                     {
                         lastInBoundsPillarNode = internalNodeId;
@@ -751,10 +755,19 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
             if (exitOnlyPillarNodeException)
                 throw ex;
         }
-        logger.debug("Traffic lights: " + trafficLightCounter);
         return newEdges;
     }
 
+    /**
+     * Checks if the given node has any interesting road sign that we will need later on.
+     *
+     * This information is used to convert those nodes to tower nodes if they were pillar nodes before, so
+     * we can store more information about them.
+     */
+    protected boolean hasRoadSign(OSMNode node) {
+        return (node.hasTag("highway", "traffic_signals") || node.hasTag("highway", "stop"));
+    }
+
     EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId )
     {
         // sanity checks
diff --git a/core/src/main/java/com/graphhopper/storage/extensions/RoadSignEncoder.java b/core/src/main/java/com/graphhopper/storage/extensions/RoadSignEncoder.java
index 3c824e60a1..2a840d1961 100644
--- a/core/src/main/java/com/graphhopper/storage/extensions/RoadSignEncoder.java
+++ b/core/src/main/java/com/graphhopper/storage/extensions/RoadSignEncoder.java
@@ -10,6 +10,7 @@
      * Positions of bits for encoding various pieces of information
      */
     final byte TRAFFIC_LIGHT_BIT = 1;
+    final byte STOP_SIGN_BIT = 2;
 
     RoadSignExtension storage;
 
@@ -41,6 +42,21 @@ public int markTrafficLight(int nodeId, boolean value)
         return nodeFieldValue;
     }
 
+    public boolean hasStopSign(int nodeId) {
+        int nodeFieldValue = nodes.getAdditionalNodeField(nodeId);
+
+        return hasBitSet(nodeFieldValue, STOP_SIGN_BIT);
+    }
+
+    public int markStopSign(int nodeId, boolean value)
+    {
+        int nodeFieldValue = nodes.getAdditionalNodeField(nodeId);
+        nodeFieldValue = setBitInField(nodeFieldValue, STOP_SIGN_BIT, value);
+        nodes.setAdditionalNodeField(nodeId, nodeFieldValue);
+
+        return nodeFieldValue;
+    }
+
     private boolean hasBitSet(int value, byte bitPosition)
     {
         return ((value >>> bitPosition - 1) & 1) != 0;
