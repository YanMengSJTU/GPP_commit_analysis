diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 177d91a278..2c275cdc53 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -969,16 +969,13 @@ public GHResponse route(GHRequest request) {
         FlagEncoder encoder = encodingManager.getEncoder(vehicle);
 
         boolean disableCH = hints.getBool(CH.DISABLE, false);
-        try {
-            if (!chFactoryDecorator.isDisablingAllowed() && disableCH)
-                throw new IllegalArgumentException("Disabling CH not allowed on the server-side");
+        if (!chFactoryDecorator.isDisablingAllowed() && disableCH) {
+            return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Disabling CH not allowed on the server-side");
+        }
 
-            boolean disableLM = hints.getBool(Landmark.DISABLE, false);
-            if (!lmFactoryDecorator.isDisablingAllowed() && disableLM)
-                throw new IllegalArgumentException("Disabling LM not allowed on the server-side");
-        } catch (IllegalArgumentException ex) {
-            ghRsp.addError(ex);
-            return Collections.emptyList();
+        boolean disableLM = hints.getBool(Landmark.DISABLE, false);
+        if (!lmFactoryDecorator.isDisablingAllowed() && disableLM) {
+            return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Disabling LM not allowed on the server-side");
         }
 
         String algoStr = request.getAlgorithm();
@@ -1012,8 +1009,9 @@ public GHResponse route(GHRequest request) {
 
                 if (chFactoryDecorator.isEnabled() && !disableCH) {
                     boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);
-                    if (!forceCHHeading && request.hasFavoredHeading(0))
-                        throw new IllegalArgumentException("Heading is not (fully) supported for CHGraph. See issue #483");
+                    if (!forceCHHeading && request.hasFavoredHeading(0)) {
+                        return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Heading is not (fully) supported for CHGraph. See issue #483");
+                    }
 
                     // if LM is enabled we have the LMFactory with the CH algo!
                     RoutingAlgorithmFactory chAlgoFactory = tmpAlgoFactory;
@@ -1036,8 +1034,8 @@ public GHResponse route(GHRequest request) {
                 ghRsp.addDebugInfo("tmode:" + tMode.toString());
 
                 int maxVisitedNodesForRequest = hints.getInt(Routing.MAX_VISITED_NODES, maxVisitedNodes);
-                if (maxVisitedNodesForRequest > maxVisitedNodes)
-                    throw new IllegalArgumentException("The max_visited_nodes parameter has to be below or equal to:" + maxVisitedNodes);
+                if (failOnMaxVisitedNodesForRequestExceedsLimit(maxVisitedNodesForRequest))
+                    return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "The max_visited_nodes parameter has to be below or equal to:" + maxVisitedNodes);
 
                 weighting = createTurnWeighting(queryGraph, weighting, tMode);
 
@@ -1070,6 +1068,19 @@ public GHResponse route(GHRequest request) {
         }
     }
 
+    private boolean failOnMaxVisitedNodesForRequestExceedsLimit(int maxVisitedNodesForRequest) {
+        if (maxVisitedNodesForRequest > maxVisitedNodes) {
+            return true;
+        }
+        return false;
+    }
+
+    private List<Path> addIllegalArgumentExceptionAndReturnEmptyCollection(GHResponse ghRsp, String s) {
+        Exception ex = new IllegalArgumentException(s);
+        ghRsp.addError(ex);
+        return Collections.emptyList();
+    }
+
     private String buildVehicle(GHRequest request) {
         String vehicle = request.getVehicle();
         if (vehicle.isEmpty()) {
@@ -1091,19 +1102,19 @@ private void failOnIllegalStorageStates() {
 
     private PathMerger buildPathMerger(GHRequest request, boolean tmpEnableInstructions, boolean tmpCalcPoints, double wayPointMaxDistance, DouglasPeucker peucker) {
         return new PathMerger().
-                            setCalcPoints(tmpCalcPoints).
-                            setDouglasPeucker(peucker).
-                            setEnableInstructions(tmpEnableInstructions).
-                            setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
-                            setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
+                setCalcPoints(tmpCalcPoints).
+                setDouglasPeucker(peucker).
+                setEnableInstructions(tmpEnableInstructions).
+                setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
+                setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
     }
 
     private AlgorithmOptions buildAlgorithmOptions(HintsMap hints, TraversalMode tMode, String algoStr, Weighting weighting, int maxVisitedNodesForRequest) {
         return AlgorithmOptions.start().
-                            algorithm(algoStr).traversalMode(tMode).weighting(weighting).
-                            maxVisitedNodes(maxVisitedNodesForRequest).
-                            hints(hints).
-                            build();
+                algorithm(algoStr).traversalMode(tMode).weighting(weighting).
+                maxVisitedNodes(maxVisitedNodesForRequest).
+                hints(hints).
+                build();
     }
 
     private RoutingTemplate buildRoutingTemplate(GHRequest request, GHResponse ghRsp, String algoStr) {
