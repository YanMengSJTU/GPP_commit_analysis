diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index b59f453b7b..a4ca0d21c6 100644
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -17,15 +17,11 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.storage.NodeAccess;
-
 /**
  * @author Peter Karich
  */
 public class FinishInstruction extends Instruction
 {
-    private int count = -1;
-
     public FinishInstruction( final double lat, final double lon, final double ele )
     {
         super(FINISH, "", InstructionAnnotation.EMPTY, new PointList(2, true)
@@ -36,20 +32,18 @@ public FinishInstruction( final double lat, final double lon, final double ele )
         });
     }
 
-    public FinishInstruction( NodeAccess nodeAccess, int node )
+    public FinishInstruction( PointAccess pointAccess, int node )
     {
-        this(nodeAccess.getLatitude(node), nodeAccess.getLongitude(node),
-                nodeAccess.is3D() ? nodeAccess.getElevation(node) : 0);
+        this(pointAccess.getLatitude(node), pointAccess.getLongitude(node),
+                pointAccess.is3D() ? pointAccess.getElevation(node) : 0);
     }
 
-    void setVia( int i )
+    @Override
+    public String getTurnDescription( Translation tr )
     {
-        sign = REACHED_VIA;
-        count = i;
-    }
+        if (rawName)
+            return getName();
 
-    public int getViaPosition()
-    {
-        return count;
+        return tr.tr("finish");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index ab9bb92d6d..078a50ecd6 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -18,7 +18,6 @@
 package com.graphhopper.util;
 
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -38,6 +37,7 @@
     public static final int REACHED_VIA = 5;
     public static final int USE_ROUNDABOUT = 6;
 
+    protected boolean rawName;
     protected int sign;
     protected String name;
     protected double distance;
@@ -49,7 +49,7 @@
      * The points, distances and times have exactly the same count. The last point of this
      * instruction is not duplicated here and should be in the next one.
      */
-    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl)
+    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl )
     {
         this.sign = sign;
         this.name = name;
@@ -57,6 +57,15 @@ public Instruction( int sign, String name, InstructionAnnotation ia, PointList p
         this.annotation = ia;
     }
 
+    /**
+     * This method does not perform translation or combination with the sign - it just uses the
+     * provided name as instruction.
+     */
+    public void setUseRawName()
+    {
+        rawName = true;
+    }
+
     public InstructionAnnotation getAnnotation()
     {
         return annotation;
@@ -75,17 +84,17 @@ public String getName()
         return name;
     }
 
-    public void setName(String name)
+    public void setName( String name )
     {
         this.name = name;
     }
 
-    public Map<String,Object> getExtraInfoJSON()
+    public Map<String, Object> getExtraInfoJSON()
     {
         return Collections.<String, Object>emptyMap();
     }
 
-    public void setExtraInfo(String key, Object value)
+    public void setExtraInfo( String key, Object value )
     {
         throw new IllegalArgumentException("Key" + key + " is not a valid option");
     }
@@ -244,16 +253,13 @@ void checkOne()
 
     public String getTurnDescription( Translation tr )
     {
+        if (rawName)
+            return getName();
+
         String str;
         String streetName = getName();
         int indi = getSign();
-        if (indi == Instruction.FINISH)
-        {
-            str = tr.tr("finish");
-        } else if (indi == Instruction.REACHED_VIA)
-        {
-            str = tr.tr("stopover", ((FinishInstruction) this).getViaPosition());
-        } else if (indi == Instruction.CONTINUE_ON_STREET)
+        if (indi == Instruction.CONTINUE_ON_STREET)
         {
             str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
         } else
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 83fd7a3e6c..8a5a878492 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -46,6 +46,14 @@ public InstructionList( int cap, Translation tr )
         this.tr = tr;
     }
 
+    public void replaceLast( Instruction instr )
+    {
+        if (instructions.isEmpty())
+            throw new IllegalStateException("Cannot replace last instruction as list is empty");
+
+        instructions.set(instructions.size() - 1, instr);
+    }
+
     public void add( Instruction instr )
     {
         instructions.add(instr);
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index a8c8288634..2aa1237ab1 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -81,8 +81,9 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                     // if not yet reached finish replace with 'reached via'
                     if (pathIndex + 1 < paths.size())
                     {
-                        FinishInstruction fi = (FinishInstruction) fullInstructions.get(fullInstructions.size() - 1);
-                        fi.setVia(pathIndex + 1);
+                        ViaInstruction newInstr = new ViaInstruction(fullInstructions.get(fullInstructions.size() - 1));
+                        newInstr.setViaCount(pathIndex + 1);
+                        fullInstructions.replaceLast(newInstr);
                     }
                 }
 
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
index c7786a3cc8..78b759471a 100644
--- a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -9,7 +9,8 @@
 public class RoundaboutInstruction extends Instruction
 {
     private int exitNumber = 0;
-    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private int clockwise = 0;
     private boolean exited = false;
     private double radian = Double.NaN;
 
@@ -107,6 +108,9 @@ public RoundaboutInstruction setRadian( double radian )
     @Override
     public String getTurnDescription( Translation tr )
     {
+        if (rawName)
+            return getName();
+
         String str;
         String streetName = getName();
         int indi = getSign();
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
new file mode 100644
index 0000000000..1e96005b6b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.util;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class ViaInstruction extends Instruction
+{
+    private int viaPosition = -1;
+
+    public ViaInstruction( String name, InstructionAnnotation ia, PointList pl )
+    {
+        super(REACHED_VIA, name, ia, pl);
+    }
+
+    public ViaInstruction( Instruction instr )
+    {
+        this(instr.getName(), instr.getAnnotation(), instr.getPoints());
+        setDistance(instr.getDistance());
+        setTime(instr.getTime());
+    }
+
+    public void setViaCount( int count )
+    {
+        this.viaPosition = count;
+    }
+
+    public int getViaCount()
+    {
+        return viaPosition;
+    }
+
+    @Override
+    public String getTurnDescription( Translation tr )
+    {
+        if (rawName)
+            return getName();
+
+        return tr.tr("stopover", viaPosition);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index c1445d9616..3f5793eb6f 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -22,14 +22,14 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
-import java.util.Arrays;
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Main wrapper of the offline API for a simple and efficient usage.
+ * This class is nearly identical in usage as the offline API but connects to a remove routing
+ * service like self-hosted or the GraphHopper Directions API.
  * <p/>
  * @author Peter Karich
  */
@@ -117,6 +117,7 @@ public GHResponse route( GHRequest request )
                     + places
                     + "&type=json"
                     + "&points_encoded=" + pointsEncoded
+                    + "&instructions=" + instructions
                     + "&way_point_max_distance=" + request.getHints().getDouble("wayPointMaxDistance", 1)
                     + "&algo=" + request.getAlgorithm()
                     + "&locale=" + request.getLocale().toString()
@@ -195,6 +196,7 @@ public GHResponse route( GHRequest request )
                     JSONArray instrArr = firstPath.getJSONArray("instructions");
 
                     InstructionList il = new InstructionList(trMap.getWithFallBack(request.getLocale()));
+                    int viaCount = 1;
                     for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
                     {
                         JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
@@ -211,9 +213,35 @@ public GHResponse route( GHRequest request )
                             instPL.add(pointList, j);
                         }
 
-                        // TODO way and payment type
-                        Instruction instr = new Instruction(sign, text, InstructionAnnotation.EMPTY, instPL).
-                                setDistance(instDist).setTime(instTime);
+                        InstructionAnnotation ia = InstructionAnnotation.EMPTY;
+                        if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text"))
+                        {
+                            ia = new InstructionAnnotation(jsonObj.getInt("annotation_importance"), jsonObj.getString("annotation_text"));
+                        }
+
+                        Instruction instr;
+                        if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT)
+                        {
+                            instr = new RoundaboutInstruction(sign, text, ia, instPL);
+                        } else if (sign == Instruction.REACHED_VIA)
+                        {
+                            ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
+                            tmpInstr.setViaCount(viaCount);
+                            viaCount++;
+                            instr = tmpInstr;
+                        } else if (sign == Instruction.FINISH)
+                        {
+                            instr = new FinishInstruction(instPL, 0);
+                        } else
+                        {
+                            instr = new Instruction(sign, text, ia, instPL);
+                        }
+
+                        // The translation is done from the routing service so just use the provided string
+                        // instead of creating a combination with sign and name etc
+                        instr.setUseRawName();
+
+                        instr.setDistance(instDist).setTime(instTime);
                         il.add(instr);
                     }
                     res.setInstructions(il);
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 10a09d601d..e04c78e0f7 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -22,7 +22,10 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
 import java.io.File;
+import java.util.List;
+import java.util.Map;
 import org.json.JSONObject;
 import org.junit.AfterClass;
 import org.junit.Before;
@@ -91,6 +94,19 @@ public void testGraphHopperWeb() throws Exception
         assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 9000);
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 9500);
+
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(42.554851, 1.536198)).
+                addPoint(new GHPoint(42.531896, 1.553278)).
+                addPoint(new GHPoint(42.510071, 1.548128)));
+        assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
+        assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 20000);
+        assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 21000);
+
+        List<Map<String, Object>> instructions = rsp.getInstructions().createJson();
+        assertEquals(23, instructions.size());
+        assertEquals("Continue onto la Callisa", instructions.get(0).get("text"));
+        assertEquals("At roundabout, take exit 2", instructions.get(3).get("text"));
     }
 
     @Test
@@ -108,7 +124,7 @@ public void testGraphHopperWebRealExceptions()
 
         ex = rsp.getErrors().get(0);
         assertTrue("Wrong Exception found: " + ex.getClass().getName()
-            + ", IllegalStateException expected.", ex instanceof IllegalStateException);
+                + ", IllegalStateException expected.", ex instanceof IllegalStateException);
 
         // IllegalArgumentException (Wrong Points)
         rsp = hopper.route(new GHRequest(0.0, 0.0, 0.0, 0.0));
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
index 6b29124e4d..ceed4b9a82 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
@@ -31,7 +31,8 @@
  */
 public class GraphHopperWebTest
 {
-
+    // see also GraphHopperServletIT.testGraphHopperWeb for real routes against local jetty service
+    
     @Test
     public void testReadUnencoded() throws Exception
     {
