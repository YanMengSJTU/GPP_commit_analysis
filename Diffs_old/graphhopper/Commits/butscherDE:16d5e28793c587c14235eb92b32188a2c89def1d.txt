diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index 03447cc397..0afd0ced36 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -11,7 +11,6 @@
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Polygon;
@@ -59,6 +58,7 @@ private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFac
 
     private List<Path> routeWithPolygon() {
         this.findCandidateRoutes();
+        //this.pruneDominatedCandidateRoutes();
 
         throw new NotImplementedException();
     }
@@ -71,7 +71,6 @@ private void findCandidateRoutes() {
         for (int i = 0; i < LOTNodes.size() - 1; i++) {
             lookUpStartEndNodes(i);
             buildRouteCandidatesForCurrentPoint(LOTNodes.get(i), i);
-
         }
     }
 
@@ -120,7 +119,7 @@ private void lookUpStartEndNodes(int pointsIndex) {
     private void makeLOTNodeListForThisPoint(List<Integer> polygonEntryExitPoints, EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, QueryResult point) {
         Map<Integer, Double> distancesToPolygonEntryExit = getDistancesFromPointToEntryExitPoints(point, polygonEntryExitPoints);
         addEntryExitPointsCopyTo(polygonEntryExitPoints, LOTNodes);
-        for (final int entryExitPoint :  LOTNodes.get(LOTNodes.size() - 1)) {
+        for (final int entryExitPoint : LOTNodes.get(LOTNodes.size() - 1)) {
             checkIfThisIsAValidLOTNode(edgeExplorer, LOTNodes, distancesToPolygonEntryExit, entryExitPoint);
         }
     }
@@ -146,7 +145,8 @@ private boolean lookForNeighborsThatMakeABetterLOTNode(Map<Integer, Double> dist
         boolean foundABetterLOTNode = false;
         do {
             foundABetterLOTNode = foundABetterLOTNode(distancesToPolygonEntryExit, neighborFinder, distanceOfThisEntryExitPointFromPoint);
-        } while (neighborFinder.next() && !foundABetterLOTNode);
+        }
+        while (neighborFinder.next() && !foundABetterLOTNode);
         return foundABetterLOTNode;
     }
 
@@ -163,7 +163,7 @@ private boolean foundABetterLOTNode(Map<Integer, Double> distancesToPolygonEntry
 
     private void addEntryExitPointsCopyTo(List<Integer> polygonEntryExitPoints, List<List<Integer>> LOTNodes) {
         int index = LOTNodes.size();
-        LOTNodes.add(index, (ArrayList<Integer>)  ((ArrayList<Integer>) polygonEntryExitPoints).clone());
+        LOTNodes.add(index, (ArrayList<Integer>) ((ArrayList<Integer>) polygonEntryExitPoints).clone());
     }
 
     private Map<Integer, Double> getDistancesFromPointToEntryExitPoints(QueryResult point, List<Integer> polygonEntryExitPoints) {
@@ -191,7 +191,8 @@ private void addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoi
 
             do {
                 addToEntryExitIfNotExistentAndNotInPolygon(nodesInPolygon, entryExitPoints, edgeIterator);
-            } while (edgeIterator.next());
+            }
+            while (edgeIterator.next());
         }
     }
 
@@ -202,46 +203,12 @@ private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPol
         }
     }
 
-    // According to Prof. Storandts paper Region-Aware Route Planning Definition 2.
-    private void calculatePathSkeleton(List<Integer> subGraphNodes, final List<Integer> polygonEntryExitPoints) {
-        this.dijkstraForPathSkeleton = new DijkstraManyToMany(this.queryGraph, algoOpts.getWeighting(), this.algoOpts.getTraversalMode(), subGraphNodes,
-                                                                polygonEntryExitPoints);
-        this.dijkstraForPathSkeleton.findAllPathsBetweenEntryExitPoints();
-    }
-
-    private List<Integer> filterOutNodesNotInPolygon(final List<Integer> nodes, final Polygon polygon) {
-        final List<Integer> filterResult = new LinkedList<>();
-
-        while (!nodes.isEmpty()) {
-            filterNextNode(nodes, polygon, filterResult);
-        }
-
-        return filterResult;
-    }
-
-    private void filterNextNode(List<Integer> nodes, Polygon polygon, List<Integer> filterResult) {
-        int nodeToFilter = popNode(nodes);
-        final NodeAccess nodeAccess = this.ghStorage.getNodeAccess();
-        final double lat = nodeAccess.getLat(nodeToFilter);
-        final double lon = nodeAccess.getLon(nodeToFilter);
-
-        if (polygon.contains(lat, lon)) {
-            filterResult.add(nodeToFilter);
-        }
-    }
-
-    private int popNode(List<Integer> nodes) {
-        final int nodeToFilter = nodes.get(0);
-        nodes.remove(0);
-        return nodeToFilter;
-    }
-
     private List<Integer> getNodesInPolygon() {
         final Polygon polygon = this.getGhRequest().getPolygon();
         final NodeAccess nodeAccess = gh.getGraphHopperStorage().getNodeAccess();
 
         BBox minimumPolygonBoundingBox = BBox.createMinimalBoundingBoxFromPolygon(polygon);
-        final NodesInPolygonFindingVisitor visitor =new NodesInPolygonFindingVisitor(polygon, nodeAccess);
+        final NodesInPolygonFindingVisitor visitor = new NodesInPolygonFindingVisitor(polygon, nodeAccess);
         this.gh.getLocationIndex().query(minimumPolygonBoundingBox, visitor);
         return visitor.getNodesInPolygon();
     }
@@ -266,7 +233,9 @@ public void onNode(int nodeId) {
             }
         }
 
-        public List<Integer> getNodesInPolygon() { return this.nodesInPolygon; }
+        public List<Integer> getNodesInPolygon() {
+            return this.nodesInPolygon;
+        }
     }
 
     public RoutingAlgorithm getRoutingAlgorithm() {
@@ -298,7 +267,7 @@ public RouteCandidate(final PolygonRoutingTemplate polygonRoutingTemplate, final
             this.polygonExitToEnd = this.routingAlgorithm.calcPath(polygonExitNodeID, endNodeID);
             this.directRouteStartEnd = this.routingAlgorithm.calcPath(startNodeID, endNodeID);
 
-            this.distance = this.startToPolygonEntry.getDistance() + this.polygonEntryToPolygonExit.getDistance() + this. polygonExitToEnd.getDistance();
+            this.distance = this.startToPolygonEntry.getDistance() + this.polygonEntryToPolygonExit.getDistance() + this.polygonExitToEnd.getDistance();
         }
 
         public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
@@ -323,6 +292,7 @@ public double getDistanceInROI() {
         }
 
         public double getGain() {
+            // + 1 to avoid division by zero
             return this.polygonEntryToPolygonExit.getDistance() / (this.getDetourDistance() + 1);
         }
 
@@ -330,8 +300,19 @@ public double getDetourDistance() {
             return this.getDistance() - this.directRouteStartEnd.getDistance();
         }
 
+        /**
+         * Uses the sweepline algorithm of Michael Ian Shamos and Dan Hoey to find intersecting line segments induced by the edges of the merged path.
+         * <p>
+         * Reference:
+         * Michael Ian Shamos and Dan Hoey. Geometric intersection problems. In Proceedings
+         * of the 17th Annual IEEE Symposium on Foundations of Computer Science
+         * (FOCS '76), pages 208{215, 1976.
+         *
+         * @return true if at least one intersection occurs and false otherwise.
+         */
         public boolean isDetourSelfIntersecting() {
-            throw new NotImplementedException();
+            return false;
+            // TODO: Check with storandt what she means with intersections
         }
     }
 }
