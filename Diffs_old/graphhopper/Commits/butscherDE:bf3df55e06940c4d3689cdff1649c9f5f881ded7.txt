diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 49bf5500b1..08ae2286dc 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -104,78 +104,28 @@ public int findEndNode(int from, int to) {
 
         this.to = to;
         if (doClear) {
-            doClear = false;
-            int vn = changedNodes.size();
-            for (int i = 0; i < vn; i++) {
-                int n = changedNodes.get(i);
-                weights[n] = Double.MAX_VALUE;
-                parents[n] = EMPTY_PARENT;
-                edgeIds[n] = EdgeIterator.NO_EDGE;
-            }
-
-            heap.clear();
-
-            // changedNodes.clear();
-            changedNodes.elementsCount = 0;
-
-            currNode = from;
-            if (!traversalMode.isEdgeBased()) {
-                weights[currNode] = 0;
-                changedNodes.add(currNode);
-            }
+            resetCachedDatastructure(from);
         } else {
-            // Cached! Re-use existing data structures
-            int parentNode = parents[to];
-            if (parentNode != EMPTY_PARENT && weights[to] <= weights[currNode])
-                return to;
-
-            if (heap.isEmpty() || isMaxVisitedNodesExceeded())
-                return NOT_FOUND;
-
-            currNode = heap.poll_element();
+            Integer x = prepareDatastructureForNextSearch(to);
+            if (x != null) return x;
         }
 
         visitedNodes = 0;
 
         // we call 'finished' before heap.peek_element but this would add unnecessary overhead for this special case so we do it outside of the loop
-        if (finished()) {
-            // then we need a small workaround for special cases see #707
-            if (heap.isEmpty())
-                doClear = true;
+        if (earlyStoppingWhenSourceEqualsDestination()) {
             return currNode;
         }
 
         while (true) {
             visitedNodes++;
             EdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);
+            // TODO shouldnt this be do while because iter already has a first edge after setBaseNode called?
             while (iter.next()) {
-                int adjNode = iter.getAdjNode();
-                int prevEdgeId = edgeIds[adjNode];
-                if (!accept(iter, prevEdgeId))
-                    continue;
-
-                double tmpWeight = weighting.calcWeight(iter, false, prevEdgeId) + weights[currNode];
-                if (Double.isInfinite(tmpWeight))
-                    continue;
-
-                double w = weights[adjNode];
-                if (w == Double.MAX_VALUE) {
-                    parents[adjNode] = currNode;
-                    weights[adjNode] = tmpWeight;
-                    heap.insert_(tmpWeight, adjNode);
-                    changedNodes.add(adjNode);
-                    edgeIds[adjNode] = iter.getEdge();
-
-                } else if (w > tmpWeight) {
-                    parents[adjNode] = currNode;
-                    weights[adjNode] = tmpWeight;
-                    heap.update_(tmpWeight, adjNode);
-                    changedNodes.add(adjNode);
-                    edgeIds[adjNode] = iter.getEdge();
-                }
+                exploreNextNeighbor(iter);
             }
 
-            if (heap.isEmpty() || isMaxVisitedNodesExceeded() || isWeightLimitExceeded())
+            if (isNodeNotFound())
                 return NOT_FOUND;
 
             // calling just peek and not poll is important if the next query is cached
@@ -187,6 +137,90 @@ public int findEndNode(int from, int to) {
         }
     }
 
+    private void exploreNextNeighbor(EdgeIterator iter) {
+        int adjNode = iter.getAdjNode();
+        int prevEdgeId = edgeIds[adjNode];
+        if (!accept(iter, prevEdgeId))
+            return;
+
+        double tmpWeight = weighting.calcWeight(iter, false, prevEdgeId) + weights[currNode];
+        if (Double.isInfinite(tmpWeight))
+            return;
+
+        double w = weights[adjNode];
+        if (w == Double.MAX_VALUE) {
+            parents[adjNode] = currNode;
+            weights[adjNode] = tmpWeight;
+            heap.insert_(tmpWeight, adjNode);
+            changedNodes.add(adjNode);
+            edgeIds[adjNode] = iter.getEdge();
+
+        } else if (w > tmpWeight) {
+            parents[adjNode] = currNode;
+            weights[adjNode] = tmpWeight;
+            heap.update_(tmpWeight, adjNode);
+            changedNodes.add(adjNode);
+            edgeIds[adjNode] = iter.getEdge();
+        }
+    }
+
+    private Integer prepareDatastructureForNextSearch(int to) {
+        // Cached! Re-use existing data structures
+        int parentNode = parents[to];
+        if (parentNode != EMPTY_PARENT && weights[to] <= weights[currNode])
+            return to;
+
+        if (heap.isEmpty() || isMaxVisitedNodesExceeded())
+            return NOT_FOUND;
+
+        currNode = heap.poll_element();
+        return null;
+    }
+
+    private boolean earlyStoppingWhenSourceEqualsDestination() {
+        if (finished()) {
+            // then we need a small workaround for special cases see #707
+            if (heap.isEmpty())
+                doClear = true;
+            return true;
+        }
+        return false;
+    }
+
+    private boolean isNodeNotFound() {
+        return heap.isEmpty() || isMaxVisitedNodesExceeded() || isWeightLimitExceeded();
+    }
+
+    private void resetCachedDatastructure(int from) {
+        doClear = false;
+        int vn = changedNodes.size();
+        for (int i = 0; i < vn; i++) {
+            resetNodeCache(i);
+        }
+
+        heap.clear();
+
+        // changedNodes.clear();
+        changedNodes.elementsCount = 0;
+
+        setFirstElementWeight(from);
+    }
+
+    private void resetNodeCache(int i) {
+        int n = changedNodes.get(i);
+        weights[n] = Double.MAX_VALUE;
+        parents[n] = EMPTY_PARENT;
+        edgeIds[n] = EdgeIterator.NO_EDGE;
+    }
+
+    private void setFirstElementWeight(int from) {
+        currNode = from;
+        if (!traversalMode.isEdgeBased()) {
+            weights[currNode] = 0;
+            changedNodes.add(currNode);
+        }
+    }
+
     @Override
     public boolean finished() {
         return currNode == to;
