diff --git a/config-example.properties b/config-example.properties
index f57a1add45..7890d07015 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -1,41 +1,52 @@
-####################
 ##### Vehicles #####
+#
 # Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
-# When using two or three option together set "prepare.chWeighting=no" - see below
 # bike2 takes elevation data into account (like up-hill is slower than down-hill)
-# and requires enabling graph.elevation.provider below, e.g. see #169
+# and requires enabling graph.elevation.provider below
 graph.flagEncoders=car
 
-# to enable turn restrictions for car do
+# Enable turn restrictions for car or motorcycle. 
+# Currently you need to additionally set prepare.chWeighting=no before using this (see below and #270)
 # graph.flagEncoders=car|turnCosts=true
 
 
-
 ##### Elevation #####
+#
 # To populate your graph with elevation data use SRTM, default is noop
 # graph.elevation.provider=srtm
 #
-# default location for cache is used /tmp/srtm
+# default location for cache is /tmp/srtm
 # graph.elevation.cachedir=./srtmprovider/
 #
-# If you have a slow disk or plenty of RAM change the default MMAP to
+# If you have a slow disk or plenty of RAM change the default MMAP to:
 # graph.elevation.dataaccess=RAM_STORE
 
 
 
 ##### Storage #####
-# configure the memory access, use RAM_STORE for well equipped servers
+#
+# configure the memory access, use RAM_STORE for well equipped servers, 
 # MMAP_STORE_SYNC could be used otherwise but will be a lot slower
 graph.dataaccess=RAM_STORE
 
-# if you want to reduce storage size and you don't need instructions for a path uncomment this
+# if you want to reduce storage size and you don't need instructions for the resulting path use:
 # osmreader.instructions=false
 
-# Default: use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
-prepare.chWeighting=fastest
+#### Speed-up Mode vs. Flexibility Mode ####
+#
+# By default the speed-up mode with the 'fastest' weighting is used. Internally contraction hierarchies is 
+# used to speed routing up. This requires more RAM/disc space for holding the graph but less for every request.
+# prepare.chWeighting=fastest
+#
+# Disable the speed-up mode (contraction hierarchies, CH) via enabling the flexibility mode:
+# prepare.chWeighting=no
 
 
+# If multiple vehicles are used and prepare.chWeighting=fastest only one vehicle can be in speed-up
+# When nothing is specified the (lexicographically) first vehicle from the graph.flagEncoders list is chosen
+# algorithm.defaultVehicle=car
 
 ##### Web #####
-# if you want to support jsonp response type you need to add it explicitely here:
-#web.jsonpAllowed=true
+# if you want to support jsonp response type you need to add it explicitely here. By default it is disabled for 
+# stronger security.
+# web.jsonpAllowed=true
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 1f4804b602..ffbb943041 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -621,14 +621,6 @@ public AllEdgesIterator getAllEdges()
         throw new UnsupportedOperationException("Not supported yet.");
     }
 
-    public int getLevel( int nodeId )
-    {
-        if (isVirtualNode(nodeId))
-            throw new IllegalStateException("LevelEdgeFilter should prevent fetching level for virtual nodes: " + nodeId + ", See #288");
-
-        return ((LevelGraph) mainGraph).getLevel(nodeId);
-    }
-
     @Override
     public EdgeIteratorState edge( int a, int b )
     {
@@ -662,185 +654,4 @@ private UnsupportedOperationException exc()
     {
         return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
-
-    /**
-     * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
-     */
-    private static class VirtualEdgeIState implements EdgeIteratorState, EdgeSkipIterState
-    {
-        private final PointList pointList;
-        private final int edgeId;
-        private double distance;
-        private long flags;
-        private String name;
-        private final int baseNode;
-        private final int adjNode;
-
-        public VirtualEdgeIState( int edgeId, int baseNode, int adjNode,
-                double distance, long flags, String name, PointList pointList )
-        {
-            this.edgeId = edgeId;
-            this.baseNode = baseNode;
-            this.adjNode = adjNode;
-            this.distance = distance;
-            this.flags = flags;
-            this.name = name;
-            this.pointList = pointList;
-        }
-
-        @Override
-        public int getEdge()
-        {
-            return edgeId;
-        }
-
-        @Override
-        public int getBaseNode()
-        {
-            return baseNode;
-        }
-
-        @Override
-        public int getAdjNode()
-        {
-            return adjNode;
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            if (pointList.getSize() == 0)
-                return PointList.EMPTY;
-
-            // due to API we need to create a new instance per call!
-            if (mode == 3)
-                return pointList.clone(false);
-            else if (mode == 1)
-                return pointList.copy(0, pointList.getSize() - 1);
-            else if (mode == 2)
-                return pointList.copy(1, pointList.getSize());
-            else if (mode == 0)
-            {
-                if (pointList.getSize() == 1)
-                    return PointList.EMPTY;
-                return pointList.copy(1, pointList.getSize() - 1);
-            }
-
-            throw new UnsupportedOperationException("Illegal mode:" + mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
-            throw new UnsupportedOperationException("Not supported for virtual edge. Set when creating it.");
-        }
-
-        @Override
-        public double getDistance()
-        {
-            return distance;
-        }
-
-        @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
-            this.distance = dist;
-            return this;
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return flags;
-        }
-
-        @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
-            this.flags = flags;
-            return this;
-        }
-
-        @Override
-        public String getName()
-        {
-            return name;
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            this.name = name;
-            return this;
-        }
-
-        @Override
-        public String toString()
-        {
-            return baseNode + "->" + adjNode;
-        }
-
-        @Override
-        public boolean isShortcut()
-        {
-            return false;
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge1()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge2()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public void setSkippedEdges( int edge1, int edge2 )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverse )
-        {
-            if (!reverse)
-                return this;
-            else
-                throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeSkipIterState setWeight( double weight )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public double getWeight()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-    }
 }
diff --git a/docs/core/ch.md b/docs/core/ch.md
index 7e35ba9c5c..4d55a5c847 100644
--- a/docs/core/ch.md
+++ b/docs/core/ch.md
@@ -6,13 +6,6 @@ In GraphHopper CH is enabled by default but can be easily disabled.
 To make CH work in GraphHopper a LevelGraphStorage instead of the normal GraphStorage 
 is necessary which allows to store shortcuts too.
 
-A prepared graph can also be used for normal graph traversal IF you use the 
-graph from LevelGraph.getOriginalGraph(), see #116.
-
-Also at the moment only one vehicle can be used if CH is enabled, see issue #111.
-
-So, if you still need graph exploration for your LevelGraphStorage you can specify 
-graphHopper.doPrepare(false) before you call importOrLoad, which avoids the CH preparation.
-Then do your graph explorations or whatever and store the graph.
-If you call importOrLoad next time without doPrepare(false) the CH-preparation will be done.
+A prepared graph can also be used for normal graph traversal IF you use graph.getBaseGraph().
 
+If CH is enabled multiple vehicles will work but only one works in speed-up mode and is faster, see issue #111.
diff --git a/docs/core/location-index.md b/docs/core/location-index.md
index f98a68c3ba..69a18b839a 100644
--- a/docs/core/location-index.md
+++ b/docs/core/location-index.md
@@ -12,19 +12,12 @@ QueryResult qr = findClosest(lat, lon, EdgeFilter.ALL_EDGES );
 EdgeIteratorState edge = qr.getClosestEdge();
 ```
 
-If you don't use the GraphHopper class you have to make sure to give the index a normal graph.
-E.g. if it is a LevelGraph you need to do:
+If you don't use the GraphHopper class you have to use the low level API:
 
 ```java
-LocationIndexTree tmpIndex;
-if (graph instanceof LevelGraph)
-   tmpIndex = new LocationIndexTree(((LevelGraph) graph).getOriginalGraph(), dir);
-else
-   tmpIndex = new LocationIndexTree(graph, dir);
-
-tmpIndex.setResolution(preciseIndexResolution);
-tmpIndex.setSearchRegion(searchRegion);
-// now build the index if it cannot be loaded
-if (!tmpIndex.loadExisting())
-   tmpIndex.prepareIndex();
+LocationIndexTree index = new LocationIndexTree(graph.getBaseGraph(), dir);
+index.setResolution(preciseIndexResolution);
+index.setMaxRegionSearch(maxRegionSearch);
+if (!index.loadExisting())
+    index.prepareIndex();
 ```
\ No newline at end of file
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index 39c9c48b7b..3fb61ae58e 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -40,7 +40,7 @@ graph.flush();
 ...
 GraphStorage graph = gb.load();
 // Load index
-LocationIndex index = new LocationIndexTree(graph, new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location index cannot be loaded!");
 ```
@@ -84,7 +84,7 @@ graph.flush();
 GraphStorage graph = gb.load();
 
  // Load index
-LocationIndex index = new LocationIndexTree(((LevelGraph)graph).getOriginalGraph(), new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location2id index cannot be loaded!");
 
diff --git a/docs/core/routing.md b/docs/core/routing.md
index dcdaf693c1..5c6da786bd 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -46,9 +46,16 @@ List<String> iList = il.createDescription(tr);
 List<GPXEntry> list = il.createGPXList();
 ```
 
-If you want a more flexible routing (but slower) you can disable contraction hierarchies
-and import multiple vehicles. Then pick one vehicle and optionally the algorithm like
-astar as algorithm:
+If you want to support multiple profiles you have to specify the default vehicle in order
+to pick the vehicle where contraction hierarchies will be enabled:
+```java
+GraphHopper hopper = new GraphHopper().forServer();
+hopper.setDefaultVehicle("car");
+...
+```
+
+If you want a more flexible routing (but slower) you can disable contraction hierarchies. 
+Then pick one vehicle to route on and optionally the algorithm like 'bidirectional astar' as algorithm:
 
 ```java
 GraphHopper hopper = new GraphHopper().forServer();
@@ -60,14 +67,20 @@ hopper.setEncodingManager(new EncodingManager("car,bike"));
 
 hopper.importOrLoad();
 
-GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR);
+GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
+    setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR_BI);
 GHResponse res = hopper.route(req);
 ```
 
-In case you need the online routing API in a Java or Android application the GraphHopperWeb comes handy - see the 'web' sub module.
+In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
+ see the 'web' sub module.
 
 ```java
 GraphHopperAPI gh = new GraphHopperWeb();
 gh.load("http://your-graphhopper-service.com");
+
+// or for the GraphHopper Directions API https://graphhopper.com/#directions-api
+// gh.load("https://graphhopper.com/api/1/route");
+
 GHResponse rsp = gh.route(new GHRequest(...));
 ```
\ No newline at end of file
diff --git a/docs/core/technical.md b/docs/core/technical.md
index 5cc0ea1372..50f831d5fb 100644
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -59,7 +59,7 @@ For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teachi
 See issue [#116](https://github.com/graphhopper/graphhopper/issues/116) for the progress of this feature.
 
 In order to traverse the _LevelGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
-is done automatically for you if you call graph.getOriginalGraph(). This is necessary in a 
+is done automatically for you if you call graph.getBaseGraph(). This is necessary in a 
 _LocationIndex_ and partially in the _Path_ class in order to identify how many streets leave a junction
 or similar. See #116 for more information.
 
