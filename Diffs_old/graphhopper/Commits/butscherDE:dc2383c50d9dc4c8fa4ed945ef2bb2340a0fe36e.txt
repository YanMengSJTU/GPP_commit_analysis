diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 77c546ece9..63b9c84334 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -78,7 +78,7 @@
     private final Set<RoutingAlgorithmFactoryDecorator> algoDecorators = new LinkedHashSet<>();
     // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
-    private boolean removeZipped = true;
+    boolean removeZipped = true;
     // for graph:
     private GraphHopperStorage ghStorage;
     private EncodingManager encodingManager;
@@ -147,9 +147,8 @@ protected GraphHopper loadGraph(GraphHopperStorage g) {
      * @return the first flag encoder of the encoding manager
      */
     FlagEncoder getDefaultVehicle() {
-        if (encodingManager == null) {
+        if (encodingManager == null)
             throw new IllegalStateException("No encoding manager specified or loaded");
-        }
 
         return encodingManager.fetchEdgeEncoders().get(0);
     }
@@ -165,9 +164,8 @@ public EncodingManager getEncodingManager() {
     public GraphHopper setEncodingManager(EncodingManager em) {
         ensureNotLoaded();
         this.encodingManager = em;
-        if (em.needsTurnCostsSupport()) {
+        if (em.needsTurnCostsSupport())
             traversalMode = TraversalMode.EDGE_BASED;
-        }
 
         return this;
     }
@@ -177,11 +175,10 @@ public ElevationProvider getElevationProvider() {
     }
 
     public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
-        if (eleProvider == null || eleProvider == ElevationProvider.NOOP) {
+        if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
             setElevation(false);
-        } else {
+        else
             setElevation(true);
-        }
         this.eleProvider = eleProvider;
         return this;
     }
@@ -277,7 +274,7 @@ public GraphHopper setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSiz
     /**
      * This method call results in an in-memory graph.
      */
-    private GraphHopper setInMemory() {
+    public GraphHopper setInMemory() {
         ensureNotLoaded();
         dataAccessType = DAType.RAM_STORE;
         return this;
@@ -292,18 +289,17 @@ private GraphHopper setInMemory() {
      */
     public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
         ensureNotLoaded();
-        if (storeOnFlush) {
+        if (storeOnFlush)
             dataAccessType = DAType.RAM_STORE;
-        } else {
+        else
             dataAccessType = DAType.RAM;
-        }
         return this;
     }
 
     /**
      * Enable memory mapped configuration if not enough memory is available on the target platform.
      */
-    private GraphHopper setMemoryMapped() {
+    public GraphHopper setMemoryMapped() {
         ensureNotLoaded();
         dataAccessType = DAType.MMAP;
         return this;
@@ -393,9 +389,8 @@ public String getGraphHopperLocation() {
      */
     public GraphHopper setGraphHopperLocation(String ghLocation) {
         ensureNotLoaded();
-        if (ghLocation == null) {
+        if (ghLocation == null)
             throw new IllegalArgumentException("graphhopper location cannot be null");
-        }
 
         this.ghLocation = ghLocation;
         return this;
@@ -411,9 +406,8 @@ public String getDataReaderFile() {
      */
     public GraphHopper setDataReaderFile(String dataReaderFileStr) {
         ensureNotLoaded();
-        if (isEmpty(dataReaderFileStr)) {
+        if (isEmpty(dataReaderFileStr))
             throw new IllegalArgumentException("Data reader file cannot be empty.");
-        }
 
         dataReaderFile = dataReaderFileStr;
         return this;
@@ -425,9 +419,8 @@ public GraphHopper setDataReaderFile(String dataReaderFileStr) {
      * @throws IllegalStateException if graph is not instantiated.
      */
     public GraphHopperStorage getGraphHopperStorage() {
-        if (ghStorage == null) {
+        if (ghStorage == null)
             throw new IllegalStateException("GraphHopper storage not initialized");
-        }
 
         return ghStorage;
     }
@@ -443,9 +436,8 @@ public void setGraphHopperStorage(GraphHopperStorage ghStorage) {
      * @throws IllegalStateException if index is not initialized
      */
     public LocationIndex getLocationIndex() {
-        if (locationIndex == null) {
+        if (locationIndex == null)
             throw new IllegalStateException("Location index not initialized");
-        }
 
         return locationIndex;
     }
@@ -463,7 +455,7 @@ public GraphHopper setSortGraph(boolean sortGraph) {
         return this;
     }
 
-    private boolean isAllowWrites() {
+    public boolean isAllowWrites() {
         return allowWrites;
     }
 
@@ -509,20 +501,17 @@ public GraphHopper setTagParserFactory(TagParserFactory factory) {
      */
     public GraphHopper init(CmdArgs args) {
         args.merge(CmdArgs.readFromSystemProperties());
-        if (args.has("osmreader.osm")) {
+        if (args.has("osmreader.osm"))
             throw new IllegalArgumentException("Instead osmreader.osm use datareader.file, for other changes see core/files/changelog.txt");
-        }
 
         String tmpOsmFile = args.get("datareader.file", "");
-        if (!isEmpty(tmpOsmFile)) {
+        if (!isEmpty(tmpOsmFile))
             dataReaderFile = tmpOsmFile;
-        }
 
         String graphHopperFolder = args.get("graph.location", "");
         if (isEmpty(graphHopperFolder) && isEmpty(ghLocation)) {
-            if (isEmpty(dataReaderFile)) {
+            if (isEmpty(dataReaderFile))
                 throw new IllegalArgumentException("If no graph.location is provided you need to specify an OSM file.");
-            }
 
             graphHopperFolder = pruneFileEnd(dataReaderFile) + "-gh";
         }
@@ -541,23 +530,20 @@ public GraphHopper init(CmdArgs args) {
         String flagEncodersStr = args.get("graph.flag_encoders", "");
         String encodedValueStr = args.get("graph.encoded_values", "");
         if (!flagEncodersStr.isEmpty() || !encodedValueStr.isEmpty()) {
-            if (!encodedValueStr.isEmpty()) {
+            if (!encodedValueStr.isEmpty())
                 emBuilder.addAll(tagParserFactory, encodedValueStr);
-            }
-            if (!flagEncodersStr.isEmpty()) {
+            if (!flagEncodersStr.isEmpty())
                 emBuilder.addAll(flagEncoderFactory, flagEncodersStr);
-            }
             emBuilder.setEnableInstructions(args.getBool("datareader.instructions", true));
             emBuilder.setPreferredLanguage(args.get("datareader.preferred_language", ""));
             // overwrite EncodingManager object from configuration file
             setEncodingManager(emBuilder.build());
         }
 
-        if (args.get("graph.locktype", "native").equals("simple")) {
+        if (args.get("graph.locktype", "native").equals("simple"))
             lockFactory = new SimpleFSLockFactory();
-        } else {
+        else
             lockFactory = new NativeFSLockFactory();
-        }
 
         // elevation
         String eleProviderStr = toLowerCase(args.get("graph.elevation.provider", "noop"));
@@ -569,14 +555,12 @@ public GraphHopper init(CmdArgs args) {
                               : args.getBool("graph.elevation.calc_mean", false);
 
         String cacheDirStr = args.get("graph.elevation.cache_dir", "");
-        if (cacheDirStr.isEmpty()) {
+        if (cacheDirStr.isEmpty())
             cacheDirStr = args.get("graph.elevation.cachedir", "");
-        }
 
         String baseURL = args.get("graph.elevation.base_url", "");
-        if (baseURL.isEmpty()) {
+        if (baseURL.isEmpty())
             args.get("graph.elevation.baseurl", "");
-        }
 
         boolean removeTempElevationFiles = args.getBool("graph.elevation.cgiar.clear", true);
         removeTempElevationFiles = args.getBool("graph.elevation.clear", removeTempElevationFiles);
@@ -597,9 +581,8 @@ public GraphHopper init(CmdArgs args) {
 
         tmpProvider.setAutoRemoveTemporaryFiles(removeTempElevationFiles);
         tmpProvider.setCalcMean(eleCalcMean);
-        if (!baseURL.isEmpty()) {
+        if (!baseURL.isEmpty())
             tmpProvider.setBaseURL(baseURL);
-        }
         tmpProvider.setDAType(elevationDAType);
         setElevationProvider(tmpProvider);
 
@@ -631,9 +614,8 @@ public GraphHopper init(CmdArgs args) {
 
     private void printInfo() {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        if (ghStorage != null) {
+        if (ghStorage != null)
             logger.info("graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString());
-        }
     }
 
     /**
@@ -661,18 +643,16 @@ private GraphHopper process(String graphHopperLocation) {
             if (ghStorage.getDirectory().getDefaultType().isStoring()) {
                 lockFactory.setLockDir(new File(graphHopperLocation));
                 lock = lockFactory.create(fileLockName, true);
-                if (!lock.tryLock()) {
+                if (!lock.tryLock())
                     throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
-                }
             }
 
             try {
                 DataReader reader = importData();
                 DateFormat f = createFormatter();
                 ghStorage.getProperties().put("datareader.import.date", f.format(new Date()));
-                if (reader.getDataDate() != null) {
+                if (reader.getDataDate() != null)
                     ghStorage.getProperties().put("datareader.data.date", f.format(reader.getDataDate()));
-                }
             } catch (IOException ex) {
                 throw new RuntimeException("Cannot read file " + getDataReaderFile(), ex);
             }
@@ -680,23 +660,20 @@ private GraphHopper process(String graphHopperLocation) {
             postProcessing();
             flush();
         } finally {
-            if (lock != null) {
+            if (lock != null)
                 lock.release();
-            }
         }
         return this;
     }
 
     protected DataReader importData() throws IOException {
         ensureWriteAccess();
-        if (ghStorage == null) {
+        if (ghStorage == null)
             throw new IllegalStateException("Load graph before importing OSM data");
-        }
 
-        if (dataReaderFile == null) {
+        if (dataReaderFile == null)
             throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
                                             + " but also cannot use file for DataReader as it wasn't specified!");
-        }
 
         DataReader reader = createReader(ghStorage);
         logger.info("using " + ghStorage.toString() + ", memory:" + getMemInfo());
@@ -710,9 +687,8 @@ protected DataReader createReader(GraphHopperStorage ghStorage) {
     }
 
     protected DataReader initDataReader(DataReader reader) {
-        if (dataReaderFile == null) {
+        if (dataReaderFile == null)
             throw new IllegalArgumentException("No file for DataReader specified");
-        }
 
         logger.info("start creating graph from " + dataReaderFile);
         return reader.setFile(new File(dataReaderFile)).
@@ -730,13 +706,11 @@ protected DataReader initDataReader(DataReader reader) {
      */
     @Override
     public boolean load(String graphHopperFolder) {
-        if (isEmpty(graphHopperFolder)) {
+        if (isEmpty(graphHopperFolder))
             throw new IllegalStateException("GraphHopperLocation is not specified. Call setGraphHopperLocation or init before");
-        }
 
-        if (fullyLoaded) {
+        if (fullyLoaded)
             throw new IllegalStateException("graph is already successfully loaded");
-        }
 
         File tmpFileOrFolder = new File(graphHopperFolder);
 
@@ -756,21 +730,18 @@ public boolean load(String graphHopperFolder) {
 
         setGraphHopperLocation(graphHopperFolder);
 
-        if (encodingManager == null) {
+        if (encodingManager == null)
             setEncodingManager(EncodingManager.create(encodedValueFactory, flagEncoderFactory, ghLocation));
-        }
 
-        if (!allowWrites && dataAccessType.isMMap()) {
+        if (!allowWrites && dataAccessType.isMMap())
             dataAccessType = DAType.MMAP_RO;
-        }
 
         GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
         GraphExtension ext = encodingManager.needsTurnCostsSupport()
                              ? new TurnCostExtension() : new GraphExtension.NoOpExtension();
 
-        if (lmFactoryDecorator.isEnabled()) {
+        if (lmFactoryDecorator.isEnabled())
             initLMAlgoFactoryDecorator();
-        }
 
         if (chFactoryDecorator.isEnabled()) {
             initCHAlgoFactoryDecorator();
@@ -782,9 +753,8 @@ public boolean load(String graphHopperFolder) {
 
         ghStorage.setSegmentSize(defaultSegmentSize);
 
-        if (!new File(graphHopperFolder).exists()) {
+        if (!new File(graphHopperFolder).exists())
             return false;
-        }
 
         GHLock lock = null;
         try {
@@ -793,40 +763,35 @@ public boolean load(String graphHopperFolder) {
             if (ghStorage.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
                 lockFactory.setLockDir(new File(ghLocation));
                 lock = lockFactory.create(fileLockName, false);
-                if (!lock.tryLock()) {
+                if (!lock.tryLock())
                     throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
-                }
             }
 
-            if (!ghStorage.loadExisting()) {
+            if (!ghStorage.loadExisting())
                 return false;
-            }
 
             postProcessing();
             fullyLoaded = true;
             return true;
         } finally {
-            if (lock != null) {
+            if (lock != null)
                 lock.release();
-            }
         }
     }
 
     public RoutingAlgorithmFactory getAlgorithmFactory(HintsMap map) {
         RoutingAlgorithmFactory routingAlgorithmFactory = new RoutingAlgorithmFactorySimple();
         for (RoutingAlgorithmFactoryDecorator decorator : algoDecorators) {
-            if (decorator.isEnabled()) {
+            if (decorator.isEnabled())
                 routingAlgorithmFactory = decorator.getDecoratedAlgorithmFactory(routingAlgorithmFactory, map);
-            }
         }
 
         return routingAlgorithmFactory;
     }
 
     public GraphHopper addAlgorithmFactoryDecorator(RoutingAlgorithmFactoryDecorator algoFactoryDecorator) {
-        if (!algoDecorators.add(algoFactoryDecorator)) {
+        if (!algoDecorators.add(algoFactoryDecorator))
             throw new IllegalArgumentException("Decorator was already added " + algoFactoryDecorator.getClass());
-        }
 
         return this;
     }
@@ -857,9 +822,8 @@ public final LMAlgoFactoryDecorator getLMFactoryDecorator() {
     }
 
     private void initLMAlgoFactoryDecorator() {
-        if (lmFactoryDecorator.hasWeightings()) {
+        if (lmFactoryDecorator.hasWeightings())
             return;
-        }
 
         for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders()) {
             for (String lmWeightingStr : lmFactoryDecorator.getWeightingsAsStrings()) {
@@ -877,9 +841,8 @@ public void postProcessing() {
         // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
 
         if (sortGraph) {
-            if (ghStorage.isCHPossible() && isCHPrepared()) {
+            if (ghStorage.isCHPossible() && isCHPrepared())
                 throw new IllegalArgumentException("Sorting a prepared CHGraph is not possible yet. See #12");
-            }
 
             GraphHopperStorage newGraph = GHUtility.newStorage(ghStorage);
             GHUtility.sortDFS(ghStorage, newGraph);
@@ -893,16 +856,13 @@ public void postProcessing() {
 
         initLocationIndex();
 
-        if (chFactoryDecorator.isEnabled()) {
+        if (chFactoryDecorator.isEnabled())
             chFactoryDecorator.createPreparations(ghStorage);
-        }
-        if (!isCHPrepared()) {
+        if (!isCHPrepared())
             prepareCH();
-        }
 
-        if (lmFactoryDecorator.isEnabled()) {
+        if (lmFactoryDecorator.isEnabled())
             lmFactoryDecorator.createPreparations(ghStorage, locationIndex);
-        }
         loadOrPrepareLM();
     }
 
@@ -946,23 +906,20 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
         } else if ("shortest".equalsIgnoreCase(weightingStr)) {
             weighting = new ShortestWeighting(encoder);
         } else if ("fastest".equalsIgnoreCase(weightingStr) || weightingStr.isEmpty()) {
-            if (encoder.supports(PriorityWeighting.class)) {
+            if (encoder.supports(PriorityWeighting.class))
                 weighting = new PriorityWeighting(encoder, hintsMap);
-            } else {
+            else
                 weighting = new FastestWeighting(encoder, hintsMap);
-            }
         } else if ("curvature".equalsIgnoreCase(weightingStr)) {
-            if (encoder.supports(CurvatureWeighting.class)) {
+            if (encoder.supports(CurvatureWeighting.class))
                 weighting = new CurvatureWeighting(encoder, hintsMap);
-            }
 
         } else if ("short_fastest".equalsIgnoreCase(weightingStr)) {
             weighting = new ShortFastestWeighting(encoder, hintsMap);
         }
 
-        if (weighting == null) {
+        if (weighting == null)
             throw new IllegalArgumentException("weighting " + weightingStr + " not supported");
-        }
 
         if (hintsMap.has(Routing.BLOCK_AREA)) {
             String blockAreaStr = hintsMap.get(Parameters.Routing.BLOCK_AREA, "");
@@ -977,11 +934,10 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
     /**
      * Potentially wraps the specified weighting into a TurnWeighting instance.
      */
-    private Weighting createTurnWeighting(Graph graph, Weighting weighting, TraversalMode tMode) {
+    public Weighting createTurnWeighting(Graph graph, Weighting weighting, TraversalMode tMode) {
         FlagEncoder encoder = weighting.getFlagEncoder();
-        if (encoder.supports(TurnWeighting.class) && tMode.isEdgeBased()) {
+        if (encoder.supports(TurnWeighting.class) && tMode.isEdgeBased())
             return new TurnWeighting(weighting, (TurnCostExtension) graph.getExtension());
-        }
         return weighting;
     }
 
@@ -996,171 +952,161 @@ public GHResponse route(GHRequest request) {
      * This method calculates the alternative path list using the low level Path objects.
      */
     public List<Path> calcPaths(GHRequest request, GHResponse ghRsp) {
-        failOnIllegalStorageStates();
-
-        String vehicle = buildVehicle(request);
-
-        Lock readLock = readWriteLock.readLock();
-        readLock.lock();
-
-        HintsMap hints = request.getHints();
-        String tModeStr = hints.get("traversal_mode", traversalMode.toString());
-        TraversalMode tMode = TraversalMode.fromString(tModeStr);
-        if (hints.has(Routing.EDGE_BASED)) {
-            tMode = hints.getBool(Routing.EDGE_BASED, false) ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
-        }
-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
-
-        boolean disableCH = hints.getBool(CH.DISABLE, false);
-        if (!chFactoryDecorator.isDisablingAllowed() && disableCH) {
-            return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Disabling CH not allowed on the server-side");
-        }
+        if (ghStorage == null || !fullyLoaded)
+            throw new IllegalStateException("Do a successful call to load or importOrLoad before routing");
 
-        boolean disableLM = hints.getBool(Landmark.DISABLE, false);
-        if (!lmFactoryDecorator.isDisablingAllowed() && disableLM) {
-            return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Disabling LM not allowed on the server-side");
-        }
+        if (ghStorage.isClosed())
+            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
 
-        String algoStr = request.getAlgorithm();
-        if (algoStr.isEmpty()) {
-            algoStr = isCHUsageGranted(disableCH) ? DIJKSTRA_BI : ASTAR_BI;
+        // default handling
+        String vehicle = request.getVehicle();
+        if (vehicle.isEmpty()) {
+            vehicle = getDefaultVehicle().toString();
+            request.setVehicle(vehicle);
         }
 
-        List<GHPoint> points = request.getPoints();
-        Polygon polygon = request.getPolygon();
-        // TODO Maybe we should think about a isRequestValid method that checks all that stuff that we could do to fail fast
-        // For example see #734
-        checkIfPointsAreInBounds(points);
-        checkIfPointsAreInBounds(polygon.getCoordinatesAsGHPoints());
-
-        RoutingTemplate routingTemplate = buildRoutingTemplate(request, ghRsp, algoStr);
-
-        List<Path> altPaths = null;
-        int maxRetries = routingTemplate.getMaxRetries();
-        Locale locale = request.getLocale();
-        Translation tr = trMap.getWithFallBack(locale);
-        for (int i = 0; i < maxRetries; i++) {
-            StopWatch sw = new StopWatch().start();
-            List<QueryResult> qResults = routingTemplate.lookup(points, encoder);
-            ghRsp.addDebugInfo("idLookup:" + sw.stop().getSeconds() + "s");
-            if (ghRsp.hasErrors()) {
-                return Collections.emptyList();
-            }
-
-            RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory(hints);
-
-            Weighting weighting;
-            QueryGraph queryGraph;
-            BuilderForWeightingAndQueryGraph builderForWeightingAndQueryGraph =
-                    new BuilderForWeightingAndQueryGraph(request, ghRsp, hints, encoder, disableCH, points, qResults, tmpAlgoFactory).invoke();
-            if (builderForWeightingAndQueryGraph.is()) {
-                return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Heading is not (fully) supported for CHGraph. See issue #483");
-            }
-            weighting = builderForWeightingAndQueryGraph.getWeighting();
-            queryGraph = builderForWeightingAndQueryGraph.getQueryGraph();
-            ghRsp.addDebugInfo("tmode:" + tMode.toString());
+        Lock readLock = readWriteLock.readLock();
+        readLock.lock();
+        try {
+            if (!encodingManager.hasEncoder(vehicle))
+                throw new IllegalArgumentException("Vehicle not supported: " + vehicle + ". Supported are: " + encodingManager.toString());
+
+            HintsMap hints = request.getHints();
+            String tModeStr = hints.get("traversal_mode", traversalMode.toString());
+            TraversalMode tMode = TraversalMode.fromString(tModeStr);
+            if (hints.has(Routing.EDGE_BASED))
+                tMode = hints.getBool(Routing.EDGE_BASED, false) ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
+
+            FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+
+            boolean disableCH = hints.getBool(CH.DISABLE, false);
+            if (!chFactoryDecorator.isDisablingAllowed() && disableCH)
+                throw new IllegalArgumentException("Disabling CH not allowed on the server-side");
+
+            boolean disableLM = hints.getBool(Landmark.DISABLE, false);
+            if (!lmFactoryDecorator.isDisablingAllowed() && disableLM)
+                throw new IllegalArgumentException("Disabling LM not allowed on the server-side");
+
+            String algoStr = request.getAlgorithm();
+            if (algoStr.isEmpty())
+                algoStr = chFactoryDecorator.isEnabled() && !disableCH ? DIJKSTRA_BI : ASTAR_BI;
+
+            List<GHPoint> points = request.getPoints();
+            Polygon polygon = request.getPolygon();
+            // TODO Maybe we should think about a isRequestValid method that checks all that stuff that we could do to fail fast
+            // For example see #734
+            checkIfPointsAreInBounds(points);
+            checkIfPointsAreInBounds(polygon.getCoordinatesAsGHPoints());
+
+            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, algoStr);
+
+            List<Path> altPaths = null;
+            int maxRetries = routingTemplate.getMaxRetries();
+            Locale locale = request.getLocale();
+            Translation tr = trMap.getWithFallBack(locale);
+            for (int i = 0; i < maxRetries; i++) {
+                StopWatch sw = new StopWatch().start();
+                List<QueryResult> qResults = routingTemplate.lookup(points, encoder);
+                ghRsp.addDebugInfo("idLookup:" + sw.stop().getSeconds() + "s");
+                if (ghRsp.hasErrors())
+                    return Collections.emptyList();
+
+                RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory(hints);
+                Weighting weighting;
+                QueryGraph queryGraph;
+
+                if (chFactoryDecorator.isEnabled() && !disableCH) {
+                    boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);
+                    if (!forceCHHeading && request.hasFavoredHeading(0))
+                        throw new IllegalArgumentException("Heading is not (fully) supported for CHGraph. See issue #483");
+
+                    // if LM is enabled we have the LMFactory with the CH algo!
+                    RoutingAlgorithmFactory chAlgoFactory = tmpAlgoFactory;
+                    if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory)
+                        chAlgoFactory = ((LMAlgoFactoryDecorator.LMRAFactory) tmpAlgoFactory).getDefaultAlgoFactory();
+
+                    if (chAlgoFactory instanceof PrepareContractionHierarchies)
+                        weighting = ((PrepareContractionHierarchies) chAlgoFactory).getWeighting();
+                    else
+                        throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
+
+                    queryGraph = new QueryGraph(ghStorage.getCHGraph(weighting));
+                    queryGraph.lookup(qResults);
+                } else {
+                    checkNonChMaxWaypointDistance(points);
+                    queryGraph = new QueryGraph(ghStorage);
+                    queryGraph.lookup(qResults);
+                    weighting = createWeighting(hints, encoder, queryGraph);
+                }
+                ghRsp.addDebugInfo("tmode:" + tMode.toString());
 
-            int maxVisitedNodesForRequest = hints.getInt(Routing.MAX_VISITED_NODES, maxVisitedNodes);
-            if (failOnMaxVisitedNodesForRequestExceedsLimit(maxVisitedNodesForRequest)) {
-                return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "The max_visited_nodes parameter has to be below or equal to:" + maxVisitedNodes);
-            }
+                int maxVisitedNodesForRequest = hints.getInt(Routing.MAX_VISITED_NODES, maxVisitedNodes);
+                if (maxVisitedNodesForRequest > maxVisitedNodes)
+                    throw new IllegalArgumentException("The max_visited_nodes parameter has to be below or equal to:" + maxVisitedNodes);
 
-            weighting = createTurnWeighting(queryGraph, weighting, tMode);
+                weighting = createTurnWeighting(queryGraph, weighting, tMode);
 
-            AlgorithmOptions algoOpts = buildAlgorithmOptions(hints, tMode, algoStr, weighting, maxVisitedNodesForRequest);
+                AlgorithmOptions algoOpts = createAlgorithmOptions(hints, tMode, algoStr, weighting, maxVisitedNodesForRequest);
 
-            // do the actual route calculation !
-            altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
+                // do the actual route calculation !
+                altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
 
-            boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
-            boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
-            double wayPointMaxDistance = hints.getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);
+                boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
+                boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
+                double wayPointMaxDistance = hints.getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);
 
-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
-            PathMerger pathMerger = buildPathMerger(request, tmpEnableInstructions, tmpCalcPoints, wayPointMaxDistance, peucker);
+                DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
+                PathMerger pathMerger = createPathMerger(request, tmpEnableInstructions, tmpCalcPoints, wayPointMaxDistance, peucker);
 
-            if (request.hasFavoredHeading(0)) {
-                pathMerger.setFavoredHeading(request.getFavoredHeading(0));
-            }
+                if (request.hasFavoredHeading(0))
+                    pathMerger.setFavoredHeading(request.getFavoredHeading(0));
 
-            if (routingTemplate.isReady(pathMerger, tr)) {
-                break;
+                if (routingTemplate.isReady(pathMerger, tr))
+                    break;
             }
-        }
 
-        readLock.unlock();
-        return altPaths;
-    }
+            return altPaths;
 
-    private boolean isCHUsageGranted(boolean disableCH) {
-        return chFactoryDecorator.isEnabled() && !disableCH;
-    }
-
-    private boolean failOnMaxVisitedNodesForRequestExceedsLimit(int maxVisitedNodesForRequest) {
-        return maxVisitedNodesForRequest > maxVisitedNodes;
-    }
-
-    private List<Path> addIllegalArgumentExceptionAndReturnEmptyCollection(GHResponse ghRsp, String s) {
-        Exception ex = new IllegalArgumentException(s);
-        ghRsp.addError(ex);
-        return Collections.emptyList();
-    }
-
-    private String buildVehicle(GHRequest request) {
-        String vehicle = request.getVehicle();
-        if (vehicle.isEmpty()) {
-            vehicle = getDefaultVehicle().toString();
-            request.setVehicle(vehicle);
-        }
-        if (!encodingManager.hasEncoder(vehicle)) {
-            throw new IllegalArgumentException("Vehicle not supported: " + vehicle + ". Supported are: " + encodingManager.toString());
-        }
-        return vehicle;
-    }
-
-    private void failOnIllegalStorageStates() {
-        if (ghStorage == null || !fullyLoaded) {
-            throw new IllegalStateException("Do a successful call to load or importOrLoad before routing");
-        }
-
-        if (ghStorage.isClosed()) {
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+        } catch (IllegalArgumentException ex) {
+            ghRsp.addError(ex);
+            return Collections.emptyList();
+        } finally {
+            readLock.unlock();
         }
     }
 
-    private PathMerger buildPathMerger(GHRequest request, boolean tmpEnableInstructions, boolean tmpCalcPoints, double wayPointMaxDistance, DouglasPeucker peucker) {
+    private PathMerger createPathMerger(GHRequest request, boolean tmpEnableInstructions, boolean tmpCalcPoints, double wayPointMaxDistance, DouglasPeucker peucker) {
         return new PathMerger().
-                setCalcPoints(tmpCalcPoints).
-                setDouglasPeucker(peucker).
-                setEnableInstructions(tmpEnableInstructions).
-                setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
-                setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
+                            setCalcPoints(tmpCalcPoints).
+                            setDouglasPeucker(peucker).
+                            setEnableInstructions(tmpEnableInstructions).
+                            setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
+                            setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
     }
 
-    private AlgorithmOptions buildAlgorithmOptions(HintsMap hints, TraversalMode tMode, String algoStr, Weighting weighting, int maxVisitedNodesForRequest) {
+    private AlgorithmOptions createAlgorithmOptions(HintsMap hints, TraversalMode tMode, String algoStr, Weighting weighting, int maxVisitedNodesForRequest) {
         return AlgorithmOptions.start().
-                algorithm(algoStr).traversalMode(tMode).weighting(weighting).
-                maxVisitedNodes(maxVisitedNodesForRequest).
-                hints(hints).
-                build();
+                            algorithm(algoStr).traversalMode(tMode).weighting(weighting).
+                            maxVisitedNodes(maxVisitedNodesForRequest).
+                            hints(hints).
+                            build();
     }
 
-    private RoutingTemplate buildRoutingTemplate(GHRequest request, GHResponse ghRsp, String algoStr) {
+    private RoutingTemplate createRoutingTemplate(GHRequest request, GHResponse ghRsp, String algoStr) {
         RoutingTemplate routingTemplate;
-        if (ROUND_TRIP.equalsIgnoreCase(algoStr)) {
+        if (ROUND_TRIP.equalsIgnoreCase(algoStr))
             routingTemplate = new RoundTripRoutingTemplate(request, ghRsp, locationIndex, encodingManager, maxRoundTripRetries);
-        } else if (ALT_ROUTE.equalsIgnoreCase(algoStr)) {
+        else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
             routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
-        } else if (validPolygonInRequest(request)) {
+        else if (validPolygonInRequest(request))
             routingTemplate = new PolygonThroughRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
-        } else {
+        else
             routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
-        }
         return routingTemplate;
     }
 
     private boolean validPolygonInRequest(GHRequest request) {
-        return request.getPolygon().isRepresentingArea();
+        return request.getPolygon().size() > 2;
     }
 
     /**
@@ -1170,9 +1116,8 @@ private boolean validPolygonInRequest(GHRequest request) {
      */
     public ChangeGraphResponse changeGraph(Collection<JsonFeature> collection) {
         // TODO allow calling this method if called before CH preparation
-        if (getCHFactoryDecorator().isEnabled()) {
+        if (getCHFactoryDecorator().isEnabled())
             throw new IllegalArgumentException("To use the changeGraph API you need to turn off CH");
-        }
 
         Lock writeLock = readWriteLock.writeLock();
         writeLock.lock();
@@ -1199,6 +1144,27 @@ private void checkIfPointsAreInBounds(List<GHPoint> points) {
         }
     }
 
+    private void checkNonChMaxWaypointDistance(List<GHPoint> points) {
+        if (nonChMaxWaypointDistance == Integer.MAX_VALUE) {
+            return;
+        }
+        GHPoint lastPoint = points.get(0);
+        GHPoint point;
+        double dist;
+        DistanceCalc calc = DIST_3D;
+        for (int i = 1; i < points.size(); i++) {
+            point = points.get(i);
+            dist = calc.calcDist(lastPoint.getLat(), lastPoint.getLon(), point.getLat(), point.getLon());
+            if (dist > nonChMaxWaypointDistance) {
+                Map<String, Object> detailMap = new HashMap<>(2);
+                detailMap.put("from", i - 1);
+                detailMap.put("to", i);
+                throw new PointDistanceExceededException("Point " + i + " is too far from Point " + (i - 1) + ": " + point, detailMap);
+            }
+            lastPoint = point;
+        }
+    }
+
     protected LocationIndex createLocationIndex(Directory dir) {
         LocationIndexTree tmpIndex = new LocationIndexTree(ghStorage, dir);
         tmpIndex.setResolution(preciseIndexResolution);
@@ -1214,10 +1180,9 @@ protected LocationIndex createLocationIndex(Directory dir) {
     /**
      * Initializes the location index after the import is done.
      */
-    private void initLocationIndex() {
-        if (locationIndex != null) {
+    protected void initLocationIndex() {
+        if (locationIndex != null)
             throw new IllegalStateException("Cannot initialize locationIndex twice!");
-        }
 
         locationIndex = createLocationIndex(ghStorage.getDirectory());
     }
@@ -1251,9 +1216,8 @@ protected void loadOrPrepareLM() {
         if (tmpPrepare) {
             ensureWriteAccess();
             ghStorage.freeze();
-            if (lmFactoryDecorator.loadOrDoWork(ghStorage.getProperties())) {
+            if (lmFactoryDecorator.loadOrDoWork(ghStorage.getProperties()))
                 ghStorage.getProperties().put(Landmark.PREPARE + "done", true);
-            }
         }
     }
 
@@ -1286,13 +1250,11 @@ protected void flush() {
      * remove the files created in graphhopperLocation you have to call clean().
      */
     public void close() {
-        if (ghStorage != null) {
+        if (ghStorage != null)
             ghStorage.close();
-        }
 
-        if (locationIndex != null) {
+        if (locationIndex != null)
             locationIndex.close();
-        }
 
         try {
             lockFactory.forceRemove(fileLockName, true);
@@ -1306,194 +1268,25 @@ public void close() {
      * load
      */
     public void clean() {
-        if (getGraphHopperLocation().isEmpty()) {
+        if (getGraphHopperLocation().isEmpty())
             throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
-        }
 
         File folder = new File(getGraphHopperLocation());
         removeDir(folder);
     }
 
-    private void ensureNotLoaded() {
-        if (fullyLoaded) {
+    protected void ensureNotLoaded() {
+        if (fullyLoaded)
             throw new IllegalStateException("No configuration changes are possible after loading the graph");
-        }
     }
 
-    private void ensureWriteAccess() {
-        if (!allowWrites) {
+    protected void ensureWriteAccess() {
+        if (!allowWrites)
             throw new IllegalStateException("Writes are not allowed!");
-        }
     }
 
     public void setNonChMaxWaypointDistance(int nonChMaxWaypointDistance) {
         this.nonChMaxWaypointDistance = nonChMaxWaypointDistance;
     }
 
-    private class BuilderForQueryGraphAndWeightingWithCHEnabled {
-        private boolean myResult;
-        private final GHRequest request;
-        private final GHResponse ghRsp;
-        private final HintsMap hints;
-        private final List<QueryResult> qResults;
-        private final RoutingAlgorithmFactory tmpAlgoFactory;
-        private Weighting weighting;
-        private QueryGraph queryGraph;
-
-        BuilderForQueryGraphAndWeightingWithCHEnabled(GHRequest request, GHResponse ghRsp, HintsMap hints, List<QueryResult> qResults, RoutingAlgorithmFactory tmpAlgoFactory) {
-            this.request = request;
-            this.ghRsp = ghRsp;
-            this.hints = hints;
-            this.qResults = qResults;
-            this.tmpAlgoFactory = tmpAlgoFactory;
-        }
-
-        boolean is() {
-            return myResult;
-        }
-
-        Weighting getWeighting() {
-            return weighting;
-        }
-
-        QueryGraph getQueryGraph() {
-            return queryGraph;
-        }
-
-        BuilderForQueryGraphAndWeightingWithCHEnabled invoke() {
-            boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);
-            if (!forceCHHeading && request.hasFavoredHeading(0)) {
-                myResult = true;
-                return this;
-            }
-
-            // if LM is enabled we have the LMFactory with the CH algo!
-            RoutingAlgorithmFactory chAlgoFactory = tmpAlgoFactory;
-            if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory) {
-                chAlgoFactory = ((LMAlgoFactoryDecorator.LMRAFactory) tmpAlgoFactory).getDefaultAlgoFactory();
-            }
-
-            if (chAlgoFactory instanceof PrepareContractionHierarchies) {
-                weighting = ((PrepareContractionHierarchies) chAlgoFactory).getWeighting();
-            } else {
-                throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
-            }
-
-            queryGraph = new QueryGraph(ghStorage.getCHGraph(weighting));
-            queryGraph.lookup(qResults);
-            myResult = false;
-            return this;
-        }
-    }
-
-    private class BuilderForQueryGraphAndWeightingWithCHDisabled {
-        private final HintsMap hints;
-        private final FlagEncoder encoder;
-        private final List<GHPoint> points;
-        private final List<QueryResult> qResults;
-        private Weighting weighting;
-        private QueryGraph queryGraph;
-
-        BuilderForQueryGraphAndWeightingWithCHDisabled(HintsMap hints, FlagEncoder encoder, List<GHPoint> points, List<QueryResult> qResults) {
-            this.hints = hints;
-            this.encoder = encoder;
-            this.points = points;
-            this.qResults = qResults;
-        }
-
-        Weighting getWeighting() {
-            return weighting;
-        }
-
-        QueryGraph getQueryGraph() {
-            return queryGraph;
-        }
-
-        BuilderForQueryGraphAndWeightingWithCHDisabled invoke() {
-            checkNonChMaxWaypointDistance(points);
-            queryGraph = new QueryGraph(ghStorage);
-            queryGraph.lookup(qResults);
-            weighting = createWeighting(hints, encoder, queryGraph);
-            return this;
-        }
-
-        private void checkNonChMaxWaypointDistance(List<GHPoint> points) {
-            if (nonChMaxWaypointDistance == Integer.MAX_VALUE) {
-                return;
-            }
-            GHPoint lastPoint = points.get(0);
-            GHPoint point;
-            double dist;
-            DistanceCalc calc = DIST_3D;
-            for (int i = 1; i < points.size(); i++) {
-                point = points.get(i);
-                dist = calc.calcDist(lastPoint.getLat(), lastPoint.getLon(), point.getLat(), point.getLon());
-                if (dist > nonChMaxWaypointDistance) {
-                    Map<String, Object> detailMap = new HashMap<>(2);
-                    detailMap.put("from", i - 1);
-                    detailMap.put("to", i);
-                    throw new PointDistanceExceededException("Point " + i + " is too far from Point " + (i - 1) + ": " + point, detailMap);
-                }
-                lastPoint = point;
-            }
-        }
-    }
-
-    private class BuilderForWeightingAndQueryGraph {
-        private boolean myResult;
-        private final GHRequest request;
-        private final GHResponse ghRsp;
-        private final HintsMap hints;
-        private final FlagEncoder encoder;
-        private final boolean disableCH;
-        private final List<GHPoint> points;
-        private final List<QueryResult> qResults;
-        private final RoutingAlgorithmFactory tmpAlgoFactory;
-        private Weighting weighting;
-        private QueryGraph queryGraph;
-
-        BuilderForWeightingAndQueryGraph(GHRequest request, GHResponse ghRsp, HintsMap hints, FlagEncoder encoder, boolean disableCH, List<GHPoint> points,
-                                         List<QueryResult> qResults, RoutingAlgorithmFactory tmpAlgoFactory) {
-            this.request = request;
-            this.ghRsp = ghRsp;
-            this.hints = hints;
-            this.encoder = encoder;
-            this.disableCH = disableCH;
-            this.points = points;
-            this.qResults = qResults;
-            this.tmpAlgoFactory = tmpAlgoFactory;
-        }
-
-        boolean is() {
-            return myResult;
-        }
-
-        Weighting getWeighting() {
-            return weighting;
-        }
-
-        QueryGraph getQueryGraph() {
-            return queryGraph;
-        }
-
-        BuilderForWeightingAndQueryGraph invoke() {
-            if (isCHUsageGranted(disableCH)) {
-                BuilderForQueryGraphAndWeightingWithCHEnabled builderForQueryGraphAndWeightingWithCHEnabled =
-                        new BuilderForQueryGraphAndWeightingWithCHEnabled(request, ghRsp, hints, qResults, tmpAlgoFactory).invoke();
-                if (builderForQueryGraphAndWeightingWithCHEnabled.is()) {
-                    myResult = true;
-                    return this;
-                }
-                weighting = builderForQueryGraphAndWeightingWithCHEnabled.getWeighting();
-                queryGraph = builderForQueryGraphAndWeightingWithCHEnabled.getQueryGraph();
-            } else {
-                BuilderForQueryGraphAndWeightingWithCHDisabled builderForQueryGraphAndWeightingWithCHDisabled =
-                        new BuilderForQueryGraphAndWeightingWithCHDisabled(hints, encoder, points, qResults).invoke();
-                weighting = builderForQueryGraphAndWeightingWithCHDisabled.getWeighting();
-                queryGraph = builderForQueryGraphAndWeightingWithCHDisabled.getQueryGraph();
-            }
-            myResult = false;
-            return this;
-        }
-    }
-}
+}
\ No newline at end of file
