diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 48251c1120..91f88fbdb4 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,5 @@
 0.4.0
+    encodingManager.getSingle() is removed as one can specify an encoder explicitly. GraphHopper picks the first encoder automatically for default vehicle, can be overwritten via setDefaultVehicle
     removed LocationIndexTreeSC, use new LocationIndexTree(levelGraph.getOriginalGraph(), directory) instead
     getLevel and setLevel do no longer automatically increase node count, use getNodeAccess.ensureNode for that
     normal algorithms are now possible on prepared graph use getOriginalGraph, see #116
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 63221f4b4d..50e4364b8b 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -65,6 +65,7 @@
     // for routing
     private boolean simplifyResponse = true;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private String defaultVehicleStr;
     private RoutingAlgorithmFactory algoFactory;
     // for index
     private LocationIndex locationIndex;
@@ -76,7 +77,7 @@
     // for CH prepare    
     private boolean doPrepare = true;
     private boolean chEnabled = true;
-    private String chWeighting = "fastest";
+    private String chWeightingStr = "fastest";
     private int periodicUpdates = -1;
     private int lazyUpdates = -1;
     private int neighborUpdates = -1;
@@ -114,9 +115,15 @@ public GraphHopper setEncodingManager( EncodingManager em )
     {
         ensureNotLoaded();
         this.encodingManager = em;
+        setDefaultVehicle(getFirstVehicle().toString());
         return this;
     }
 
+    private FlagEncoder getFirstVehicle()
+    {
+        return encodingManager.fetchEdgeEncoders().get(0);
+    }
+
     public EncodingManager getEncodingManager()
     {
         return encodingManager;
@@ -262,12 +269,24 @@ private GraphHopper setUnsafeMemory()
     }
 
     /**
-     * Disables "CH-preparation". Use only if you know what you do.
+     * This method sets the default vehicle to use if no vehicle is specified in the GHRequest
+     * object.
      */
-    public GraphHopper setDoPrepare( boolean doPrepare )
+    public void setDefaultVehicle( String defaultVehicleStr )
     {
-        this.doPrepare = doPrepare;
-        return this;
+        if (!encodingManager.supports(defaultVehicleStr))
+            throw new IllegalArgumentException("Default vehicle " + defaultVehicleStr + " is not supported. "
+                    + "Include vehicle in EncodingManager or via the property graph.flagEncoders");
+        this.defaultVehicleStr = defaultVehicleStr;
+    }
+
+    public String getDefaultVehicle()
+    {
+        if (defaultVehicleStr == null)
+        {
+            throw new RuntimeException("Set default vehicle before");
+        }
+        return defaultVehicleStr;
     }
 
     /**
@@ -279,17 +298,28 @@ public GraphHopper setDoPrepare( boolean doPrepare )
     public GraphHopper setCHWeighting( String weighting )
     {
         ensureNotLoaded();
-        chWeighting = weighting;
+        chWeightingStr = weighting;
         return this;
     }
 
     public String getCHWeighting()
     {
-        return chWeighting;
+        return chWeightingStr;
+    }
+
+    /**
+     * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
+     * the full usage of CH use setCHEnable(false) instead.
+     */
+    public GraphHopper setDoPrepare( boolean doPrepare )
+    {
+        this.doPrepare = doPrepare;
+        return this;
     }
 
     /**
-     * Enables or disables contraction hierarchies. Enabled by default.
+     * Enables or disables contraction hierarchies (CH). Enabled by default, this is called speed-up
+     * mode. Without CH it is called flexibility mode.
      */
     public GraphHopper setCHEnable( boolean enable )
     {
@@ -532,13 +562,16 @@ public GraphHopper init( CmdArgs args )
 
         // osm import
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
-        String flagEncoders = args.get("graph.flagEncoders", "CAR");
+        String flagEncoders = args.get("graph.flagEncoders", "");
         if (flagEncoders.toLowerCase().contains("turncosts=true"))
             traversalMode = TraversalMode.EDGE_BASED_2DIR;
         encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
+        // default vehicle which is used if no algorithm is specified
+        setDefaultVehicle(args.get("algorithm.defaultVehicle", getFirstVehicle().toString()));
+
         // index
         preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
         maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
@@ -764,9 +797,16 @@ private boolean isPrepared()
 
     protected RoutingAlgorithmFactory createPrepare()
     {
-        FlagEncoder encoder = encodingManager.getSingle();
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph, encoder,
-                createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
+        if (!encodingManager.supports(getDefaultVehicle()))
+        {
+            throw new IllegalStateException("Should not happen: default vehicle " + getDefaultVehicle() + " not supported"
+                    + " from EncodingManager " + encodingManager.toDetailsString() + ". Cannot do CH preparation");
+        }
+
+        FlagEncoder defaultVehicle = encodingManager.getEncoder(getDefaultVehicle());
+        Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
+        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph,
+                defaultVehicle, weighting, traversalMode);
         tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
                 setLazyUpdates(lazyUpdates).
                 setNeighborUpdates(neighborUpdates).
@@ -850,7 +890,7 @@ public GHResponse route( GHRequest request )
     {
         String vehicle = request.getVehicle();
         if (vehicle.isEmpty())
-            vehicle = encodingManager.getSingle().toString();
+            vehicle = getDefaultVehicle();
 
         if (!encodingManager.supports(vehicle))
         {
@@ -992,10 +1032,6 @@ protected void prepare()
         if (tmpPrepare)
         {
             ensureWriteAccess();
-            if (encodingManager.getVehicleCount() > 1)
-                throw new IllegalArgumentException("Contraction hierarchies preparation "
-                        + "requires (at the moment) only one vehicle. But was:" + encodingManager);
-
             logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... (" + Helper.getMemInfo() + ")");
             ((PrepareContractionHierarchies) algoFactory).doWork();
             graph.getProperties().put("prepare.date", formatDateTime(new Date()));
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index e2c2d6c18e..fd51deba9c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -113,6 +113,9 @@ public int compare( FlagEncoder o1, FlagEncoder o2 )
         {
             registerEncoder((AbstractFlagEncoder) flagEncoder);
         }
+
+        if (edgeEncoders.isEmpty())
+            throw new IllegalStateException("No vehicles found");
     }
 
     public int getBytesForFlags()
@@ -272,11 +275,6 @@ public long handleWayTags( OSMWay way, long includeWay, long relationFlags )
         return flags;
     }
 
-    public int getVehicleCount()
-    {
-        return edgeEncoders.size();
-    }
-
     @Override
     public String toString()
     {
@@ -308,17 +306,6 @@ public String toDetailsString()
         return str.toString();
     }
 
-    public FlagEncoder getSingle()
-    {
-        if (getVehicleCount() > 1)
-            throw new IllegalStateException("Multiple encoders are active. cannot return one:" + toString());
-
-        if (getVehicleCount() == 0)
-            throw new IllegalStateException("No encoder is active!");
-
-        return edgeEncoders.get(0);
-    }
-
     public long flagsDefault( boolean forward, boolean backward )
     {
         long flags = 0;
@@ -415,6 +402,9 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
         }
     }
 
+    /**
+     * The returned list is never empty.
+     */
     public List<FlagEncoder> fetchEdgeEncoders()
     {
         List<FlagEncoder> list = new ArrayList<FlagEncoder>();
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index 1a2293824c..01a363bfc9 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -46,18 +46,16 @@
     private int minOnewayNetworkSize = 0;
     private int subNetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
-    private final EncodingManager encodingManager;
+    private FlagEncoder singleEncoder;
 
     public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
     {
         this.g = g;
-        if (em.getVehicleCount() == 0)
-            throw new IllegalStateException("No vehicles found");
-        else if (em.getVehicleCount() > 1)
+        List<FlagEncoder> encoders = em.fetchEdgeEncoders();
+        if (encoders.size() > 1)
             edgeFilter = EdgeFilter.ALL_EDGES;
         else
-            edgeFilter = new DefaultEdgeFilter(em.getSingle());
-        this.encodingManager = em;
+            edgeFilter = new DefaultEdgeFilter(singleEncoder = encoders.get(0));
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
@@ -78,9 +76,9 @@ public void doWork()
         Map<Integer, Integer> map = findSubnetworks();
         keepLargeNetworks(map);
 
-        int unvisitedDeadEnds = 0;
-        if ((this.minOnewayNetworkSize > 0) && (this.encodingManager.getVehicleCount() == 1))
-            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(this.encodingManager.getSingle());
+        int unvisitedDeadEnds = -1;
+        if ((this.minOnewayNetworkSize > 0) && singleEncoder != null)
+            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
 
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
                 + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
@@ -231,9 +229,9 @@ int removeZeroDegreeNodes()
 
     /**
      * Clean small networks that will be never be visited by this explorer See #86 For example,
-     * small areas like parking lots are sometimes connected to the whole network through a one-way road.
-     * This is clearly an error - but is causes the routing to fail when point get connected to this
-     * small area. This routines removed all these points from the graph.
+     * small areas like parking lots are sometimes connected to the whole network through a one-way
+     * road. This is clearly an error - but is causes the routing to fail when point get connected
+     * to this small area. This routines removed all these points from the graph.
      * <p/>
      * @return number of removed nodes;
      */
@@ -245,12 +243,15 @@ public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
 
         // remove components less than minimum size
         int removed = 0;
-        for (TIntArrayList component : components) {
+        for (TIntArrayList component : components)
+        {
 
-            if (component.size() < minOnewayNetworkSize) {
-                for (int i = 0; i < component.size(); i++) {
+            if (component.size() < minOnewayNetworkSize)
+            {
+                for (int i = 0; i < component.size(); i++)
+                {
                     g.markNodeRemoved(component.get(i));
-                    removed ++;
+                    removed++;
                 }
             }
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index 1f78ead095..66d437d1ac 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -48,7 +48,7 @@ public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryRe
             OneRun oneRun )
     {
         List<Path> viaPaths = new ArrayList<Path>();
-        QueryGraph queryGraph = new QueryGraph(algoEntry.graph);
+        QueryGraph queryGraph = new QueryGraph(algoEntry.getQueryGraph());
         queryGraph.lookup(queryList);
         AlgorithmOptions opts = algoEntry.opts;
         FlagEncoder encoder = opts.getFlagEncoder();
@@ -148,17 +148,27 @@ void printSummary()
 
     public static class AlgoHelperEntry
     {
-        private Graph graph;
+        private Graph queryGraph;
         private final LocationIndex idx;
         private AlgorithmOptions opts;
 
         public AlgoHelperEntry( Graph g, AlgorithmOptions opts, LocationIndex idx )
         {
-            this.graph = g;
+            this.queryGraph = g;
             this.opts = opts;
             this.idx = idx;
         }
 
+        public Graph getQueryGraph()
+        {
+            return queryGraph;
+        }
+
+        public void setQueryGraph( Graph queryGraph )
+        {
+            this.queryGraph = queryGraph;
+        }
+
         public void setAlgorithmOptions( AlgorithmOptions opts )
         {
             this.opts = opts;
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index 4fe2259832..0356f26421 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -499,7 +499,7 @@ public void testVia()
                 init(new CmdArgs().
                         put("osmreader.osm", testOsm3).
                         put("prepare.minNetworkSize", "1").
-                        put("graph.acceptWay", "CAR")).
+                        put("graph.flagEncoders", "CAR")).
                 setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
 
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index af51d42c94..dc8cb0fbc3 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -26,6 +26,7 @@
 import gnu.trove.list.TIntList;
 import java.util.Random;
 import static org.junit.Assert.*;
+import org.junit.Before;
 import org.junit.Test;
 
 /**
@@ -37,9 +38,18 @@
     // problem is: matrix graph is expensive to create to cache it in a static variable
     private static Graph matrixGraph;
     protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
-    protected FlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-    protected FlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
-    protected AlgorithmOptions defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new ShortestWeighting()).build();
+    protected FlagEncoder carEncoder;
+    protected FlagEncoder footEncoder;
+    protected AlgorithmOptions defaultOpts;
+
+    @Before
+    public void setUp()
+    {
+        carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
+        footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+        defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new ShortestWeighting()).build();
+    }
 
     protected Graph createGraph( EncodingManager em, boolean is3D )
     {
@@ -77,15 +87,14 @@ public void testCalcShortestPath()
     public void testCalcFastestPath()
     {
         Graph graphShortest = createGraph(false);
-        initDirectedAndDiffSpeed(graphShortest);
-        Path p1 = createAlgo(graphShortest, defaultOpts).
-                calcPath(0, 3);
+        initDirectedAndDiffSpeed(graphShortest, carEncoder);
+        Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
         assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 144823, p1.getMillis());
 
         Graph graphFastest = createGraph(false);
-        initDirectedAndDiffSpeed(graphFastest);
+        initDirectedAndDiffSpeed(graphFastest, carEncoder);
         Path p2 = createAlgo(graphFastest,
                 AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
                 calcPath(0, 3);
@@ -99,28 +108,28 @@ public void testCalcFastestPath()
     // 4-5-- |
     // |/ \--7
     // 6----/
-    void initDirectedAndDiffSpeed( Graph graph )
+    protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
     {
-        graph.edge(0, 1).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(0, 4).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
+        graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(1, 4).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setFlags(carEncoder.setProperties(10, true, true));
-        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(carEncoder.setProperties(10, true, true));
+        graph.edge(1, 4).setFlags(enc.setProperties(10, true, true));
+        graph.edge(1, 5).setFlags(enc.setProperties(10, true, true));
+        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(enc.setProperties(10, true, true));
 
-        graph.edge(5, 2).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(2, 3).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(5, 2).setFlags(enc.setProperties(10, true, false));
+        graph.edge(2, 3).setFlags(enc.setProperties(10, true, false));
 
-        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(3, 7).setFlags(carEncoder.setProperties(10, true, false));
+        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(enc.setProperties(20, true, false));
+        graph.edge(3, 7).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(4, 6).setFlags(carEncoder.setProperties(100, true, false));
-        graph.edge(5, 4).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(4, 6).setFlags(enc.setProperties(100, true, false));
+        graph.edge(5, 4).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(5, 6).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(7, 5).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(5, 6).setFlags(enc.setProperties(10, true, false));
+        graph.edge(7, 5).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(6, 7).setFlags(carEncoder.setProperties(100, true, true));
+        graph.edge(6, 7).setFlags(enc.setProperties(100, true, true));
 
         updateDistancesFor(graph, 0, 0.002, 0);
         updateDistancesFor(graph, 1, 0.002, 0.001);
@@ -140,14 +149,15 @@ public void testCalcFootPath()
     {
         Graph graphShortest = createGraph(false);
         initFootVsCar(graphShortest);
-        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).weighting(new ShortestWeighting()).build()).
+        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new ShortestWeighting()).build()).
                 calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 12240 * 1000, p1.getMillis());
         assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
     }
 
-    void initFootVsCar( Graph graph )
+    protected void initFootVsCar( Graph graph )
     {
         graph.edge(0, 1).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
         graph.edge(0, 4).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
@@ -577,7 +587,7 @@ public void testViaEdges_SpecialCases()
     public void testQueryGraphAndFastest()
     {
         Graph graph = createGraph(false);
-        initDirectedAndDiffSpeed(graph);
+        initDirectedAndDiffSpeed(graph, carEncoder);
         Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
         assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
         assertEquals(602.98, p.getDistance(), 1e-1);
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index c8607c1f5e..9d2bc3acaa 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -36,12 +36,15 @@
  */
 public class QueryGraphTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
+    private EncodingManager encodingManager;
+    private FlagEncoder carEncoder;
     private GraphStorage g;
 
     @Before
     public void setUp()
     {
+        carEncoder = new CarFlagEncoder();
+        encodingManager = new EncodingManager(carEncoder);
         g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(100);
     }
 
@@ -325,8 +328,7 @@ public void testOneWayLoop_Issue162()
         // | x
         // 0<-\
         // |
-        // 1
-        FlagEncoder carEncoder = encodingManager.getSingle();
+        // 1        
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0, 0);
         na.setNode(1, 0, -0.001);
@@ -520,13 +522,13 @@ public void testTurnCostsProperlyPropagated_Issue282()
         QueryGraph qGraph = new QueryGraph(graphWithTurnCosts);
         FastestWeighting weighting = new FastestWeighting(encoder);
         TurnWeighting turnWeighting = new TurnWeighting(weighting, encoder, (TurnCostExtension) qGraph.getExtension());
-        
+
         assertEquals(0, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
 
         // now use turn costs and QueryGraph
         turnExt.addTurnInfo(edge0.getEdge(), 1, edge1.getEdge(), encoder.getTurnFlags(false, 10));
         assertEquals(10, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
-        
+
         QueryResult res1 = createLocationResult(0.000, 0.005, edge0, 0, QueryResult.Position.EDGE);
         QueryResult res2 = createLocationResult(0.005, 0.010, edge1, 0, QueryResult.Position.EDGE);
 
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index d896d6767f..cf1ece6a4e 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -94,6 +94,57 @@ public void testMonaco()
         assertEquals(7.429758, g.getNodeAccess().getLon(201), 1e-6);
     }
 
+    @Test
+    public void testMonacoAllAlgorithmsWithBaseGraph()
+    {
+        String vehicle = "car";
+        String graphFile = "target/monaco-gh";
+        String osmFile = "files/monaco.osm.gz";
+        String importVehicles = vehicle;
+
+        Helper.removeDir(new File(graphFile));
+        GraphHopper hopper = new GraphHopper().
+                // avoid that path.getDistance is too different to path.getPoint.calcDistance
+                setWayPointMaxDistance(0).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(graphFile).
+                setEncodingManager(new EncodingManager(importVehicles));
+
+        hopper.importOrLoad();
+
+        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
+        Weighting weighting = hopper.createWeighting(new WeightingMap("shortest"), encoder);
+
+        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                encoder, true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
+        AlgoHelperEntry chPrepare = prepares.get(prepares.size() - 1);
+        if (!(chPrepare.getQueryGraph() instanceof LevelGraph))
+            throw new IllegalStateException("Last prepared queryGraph has to be a levelGraph");
+
+        // set all normal algorithms to baseGraph of already prepared to see if all algorithms still work
+        Graph baseGraphOfCHPrepared = chPrepare.getQueryGraph().getBaseGraph();
+        for (AlgoHelperEntry ahe : prepares)
+        {
+            if (!(ahe.getQueryGraph() instanceof LevelGraph))
+            {
+                ahe.setQueryGraph(baseGraphOfCHPrepared);
+            }
+        }
+
+        List<OneRun> forEveryAlgo = createMonacoCar();
+        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+        for (AlgoHelperEntry entry : prepares)
+        {
+            LocationIndex idx = entry.getIdx();
+            for (OneRun oneRun : forEveryAlgo)
+            {
+                List<QueryResult> list = oneRun.getList(idx, edgeFilter);
+                testCollector.assertDistance(entry, list, oneRun);
+            }
+        }
+    }
+
     @Test
     public void testOneWayCircleBug()
     {
@@ -609,7 +660,7 @@ public void run()
         hopper.close();
     }
 
-    public static Collection<AlgoHelperEntry> createAlgos( Graph g,
+    static List<AlgoHelperEntry> createAlgos( Graph g,
             LocationIndex idx, final FlagEncoder encoder, boolean withCh,
             final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
     {
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index 5cd0005a28..427ee36ee3 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -18,12 +18,7 @@
 package com.graphhopper.routing.ch;
 
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.LevelGraphStorage;
@@ -145,9 +140,60 @@ public long setProperties( double speed, boolean forward, boolean backward )
             }
         };
 
-        footEncoder = new EncodingManager("FOOT").getSingle();
+        footEncoder = new FootFlagEncoder();
+        new EncodingManager(footEncoder);
+        
         super.testCalcFootPath();
         footEncoder = tmpFootEncoder;
         carEncoder = tmpCarEncoder;
     }
+
+    @Test
+    public void testBaseGraph()
+    {
+        CarFlagEncoder carFE = new CarFlagEncoder();
+        Graph g = createGraph(new EncodingManager(carFE), false);
+        initDirectedAndDiffSpeed(g, carFE);
+
+        // do CH preparation for car
+        createFactory(g, defaultOpts);
+
+        // use base graph for solving normal Dijkstra
+        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(g, defaultOpts).calcPath(0, 3);
+        assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
+        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 144823, p1.getMillis());
+    }
+
+    @Test
+    public void testBaseGraphMultipleVehicles()
+    {
+        Graph g = createGraph(encodingManager, false);
+        initFootVsCar(g);
+
+        AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new FastestWeighting(footEncoder)).build();
+        AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new FastestWeighting(carEncoder)).build();
+
+        // do CH preparation for car
+        RoutingAlgorithmFactory contractedFactory = createFactory(g, carOptions);
+
+        // use contracted graph
+        Path p1 = contractedFactory.createAlgo(g, carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p1.calcNodes());
+        assertEquals(p1.toString(), 15000, p1.getDistance(), 1e-6);
+
+        // use base graph for solving normal Dijkstra via car
+        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p2.calcNodes());
+        assertEquals(p2.toString(), 15000, p2.getDistance(), 1e-6);
+        assertEquals(p2.toString(), 2700 * 1000, p2.getMillis());
+
+        // use base graph for solving normal Dijkstra via foot
+        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), footOptions).calcPath(0, 7);
+        assertEquals(p3.toString(), 17000, p3.getDistance(), 1e-6);
+        assertEquals(p3.toString(), 12240 * 1000, p3.getMillis());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index 1b45cb56ac..c6ec097254 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -22,18 +22,11 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
-import java.util.Collection;
-import java.util.Collections;
-
 import org.junit.Test;
 
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
-import java.util.*;
 
 /**
  *
@@ -198,7 +191,7 @@ public void testCompatibilityBug()
         osmWay.setTag("highway", "footway");
         osmWay.setTag("name", "test");
 
-        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getSingle();
+        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getEncoder("bike2");
         long flags = manager2.handleWayTags(osmWay, singleBikeEnc.acceptBit, 0);
         double singleSpeed = singleBikeEnc.getSpeed(flags);
         assertEquals(4, singleSpeed, 1e-3);
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index 36b2489024..cbae05663d 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -34,7 +34,7 @@
  */
 public class PrepareRoutingSubnetworksTest
 {
-    private final EncodingManager em = new EncodingManager("CAR");
+    private final EncodingManager em = new EncodingManager("car");
 
     GraphStorage createGraph( EncodingManager eman )
     {
@@ -198,7 +198,7 @@ public void testRemoveDeadEndUnvisitedNetworks()
         assertEquals(11, g.getNodes());
 
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
         assertEquals(3, removed);
 
@@ -212,7 +212,7 @@ public void testTarjan()
         GraphStorage g = createSubnetworkTestGraph();
 
         // Requires a single vehicle type, otherwise we throw.
-        final FlagEncoder flagEncoder = em.getSingle();
+        final FlagEncoder flagEncoder = em.getEncoder("car");
         final EdgeFilter filter = new DefaultEdgeFilter(flagEncoder, false, true);
 
         TarjansStronglyConnectedComponentsAlgorithm tarjan = new TarjansStronglyConnectedComponentsAlgorithm(g, filter);
@@ -235,7 +235,7 @@ public void testNodeOrderingRegression() {
         g.edge(2, 0, 1, false);
 
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(2);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
         
         assertEquals(3, removed);
     }
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index 10cd5a4b08..bb43cef11b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -42,7 +42,7 @@ public LocationIndex createIndex( Graph g, int resolution )
     @Test
     public void testNormedDist()
     {
-        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager()), new RAMDirectory());
+        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
         assertEquals(2, index.getNormedDist(0, 7), 1e-6);
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index d86e375a8f..c6735a0a6e 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -37,6 +37,7 @@
 import javax.xml.validation.Validator;
 import org.junit.Test;
 import static org.junit.Assert.*;
+import org.junit.Before;
 import org.xml.sax.SAXException;
 
 /**
@@ -48,12 +49,19 @@
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation usTR = trMap.getWithFallBack(Locale.US);
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
+    private EncodingManager carManager;
+    private FlagEncoder carEncoder;
+    
+    @Before
+    public void setUp() {
+        carEncoder = new CarFlagEncoder();
+        carManager = new EncodingManager(carEncoder);
+    }
 
     @SuppressWarnings("unchecked")
     @Test
     public void testWayList()
-    {
-        EncodingManager carManager = new EncodingManager("CAR");
+    {                
         Graph g = new GraphBuilder(carManager).create();
         // 0-1-2
         // | | |
@@ -99,7 +107,7 @@ public void testWayList()
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 10);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 10);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
@@ -136,7 +144,6 @@ public void testWayList()
                 asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
-        FlagEncoder carEncoder = carManager.getSingle();
         p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
         assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
@@ -150,7 +157,7 @@ public void testWayList()
                 wayList.createStartPoints());
 
         // special case of identical start and end
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 0);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 0);
         wayList = p.calcInstructions(usTR);
         assertEquals(1, wayList.size());
         assertEquals("Finish!", wayList.get(0).getTurnDescription(usTR));
@@ -211,7 +218,6 @@ void compare( List<List<Double>> expected, List<List<Double>> was )
     @Test
     public void testWayList2()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -233,14 +239,14 @@ public void testWayList2()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
 
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Finish!"),
                 tmpList);
 
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(3, 5);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(usTR);
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-4", "Continue onto 4-5", "Finish!"),
@@ -251,7 +257,6 @@ public void testWayList2()
     @Test
     public void testNoInstructionIfSameStreet()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -273,7 +278,7 @@ public void testNoInstructionIfSameStreet()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto street", "Finish!"), tmpList);
@@ -282,7 +287,6 @@ public void testNoInstructionIfSameStreet()
     @Test
     public void testInstructionsWithTimeAndPlace()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   4-5
         //   |
@@ -301,7 +305,7 @@ public void testInstructionsWithTimeAndPlace()
         g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
         g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(1, 5);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
         InstructionList wayList = p.calcInstructions(usTR);
         assertEquals(5, wayList.size());
 
@@ -413,10 +417,9 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
 
     @Test
     public void testEmptyList()
-    {
-        EncodingManager carManager = new EncodingManager("CAR");
+    {        
         Graph g = new GraphBuilder(carManager).create();
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 1);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(usTR);
         assertEquals(0, il.size());
         assertEquals(0, il.createStartPoints().size());
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index ae932d78b7..48fd784f85 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -121,7 +121,7 @@ void start( CmdArgs args )
         try
         {
             maxNode = g.getNodes();
-            printGraphDetails(g);
+            printGraphDetails(g, vehicleStr);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
 
             // Route via dijkstrabi. Normal routing takes a lot of time => smaller query number than CH
@@ -161,13 +161,13 @@ void start( CmdArgs args )
         }
     }
 
-    private void printGraphDetails( GraphStorage g )
+    private void printGraphDetails( GraphStorage g, String vehicleStr )
     {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
         put("graph.edges", g.getAllEdges().getCount());
         put("graph.sizeInMB", g.getCapacity() / Helper.MB);
-        put("graph.encoder", g.getEncodingManager().getSingle().toString());
+        put("graph.encoder", vehicleStr);
     }
 
     private void printLocationIndexQuery( Graph g, final LocationIndex idx, int count )
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 6d8038ee2c..0049944ee0 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -76,7 +76,7 @@ public MiniGraphUI( GraphHopper hopper, boolean debug )
         this.graph = hopper.getGraph();
         this.na = graph.getNodeAccess();
         algoFactory = hopper.getAlgorithmFactory();
-        encoder = hopper.getEncodingManager().getSingle();
+        encoder = hopper.getEncodingManager().getEncoder("car");
         weighting = hopper.createWeighting(new WeightingMap("fastest"), encoder);
         algoOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
 
