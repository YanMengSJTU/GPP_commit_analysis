diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/GPSToPath.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/GPSToPath.java
new file mode 100644
index 0000000000..1d41f3ffa1
--- /dev/null
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/GPSToPath.java
@@ -0,0 +1,7 @@
+package com.graphhopper.reader.osm;
+
+/**
+ * Created by isaac on 11/26/16.
+ */
+public class GPSToPath {
+}
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
index cfef6e5c53..06c601f61a 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
@@ -7,7 +7,6 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.util.*;
 
-import java.awt.*;
 import java.util.*;
 
 import java.io.*;
@@ -19,30 +18,46 @@
  */
 public class runKSP {
 
-    private static final TranslationMap trMap = new TranslationMap().doImport();
-    private static final Translation usTR = trMap.getWithFallBack(Locale.US);
-    private static final boolean outputAlternative = true;
+    String city;
+    String route_type;
+    ArrayList<FileWriter> outputFiles;
+    private String osmFile = "./reader-osm/files/";
+    private String graphFolder = "./reader-osm/target/tmp/";
+    private String inputPointsFN = "../data/intermediate/";
+    private String outputPointsFN = "../data/output/";
+    private String gvfnStem = "../data/intermediate/";
+    private ArrayList<String> gridValuesFNs = new ArrayList<>();
+    private HashMap<String, Integer> gvHeaderMap;
+    private HashMap<String, Float> gridBeauty;
+    private GraphHopper hopper;
 
-    public static void process_routes(String city, String route_type, boolean useCH) throws Exception {
+    public runKSP(String city, String route_type) {
 
-        // set paths
-        String osmFile = "./reader-osm/files/";
-        String graphFolder = "./reader-osm/target/tmp/";
-        String inputPointsFN = "../data/intermediate/";
-        String outputPointsFN = "../data/output/";
-        ArrayList<String> gridValuesFNs = new ArrayList<>();
-        String gvfnStem = "../data/intermediate/";
+        this.city = city;
+        this.route_type = route_type;
+        this.outputFiles = new ArrayList<>(4);
+    }
+
+    public void setCiy(String city) {
+        this.city = city;
+    }
+
+    public void setRouteType(String route_type) {
+        this.route_type = route_type;
+    }
+
+    public void setDataSources() throws Exception {
         if (city.equals("SF")) {
             osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
-            graphFolder = graphFolder + "ghosm_sf";
+            graphFolder = graphFolder + "ghosm_sf_noch";
             inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "sf_" + route_type + "_graphhopper_routes_ksp.csv";
+            outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "06075_logfractionempath_flickr.csv");
         } else if (city.equals("NYC")) {
             osmFile = osmFile + "new-york_new-york.osm.pbf";
-            graphFolder = graphFolder + "ghosm_nyc";
+            graphFolder = graphFolder + "ghosm_nyc_noch";
             inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_graphhopper_routes_ksp.csv";
+            outputPointsFN = outputPointsFN + "nyc_" + route_type + "gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "36005_beauty_flickr.csv");
             gridValuesFNs.add(gvfnStem + "36047_beauty_flickr.csv");
             gridValuesFNs.add(gvfnStem + "36061_beauty_flickr.csv");
@@ -50,19 +65,19 @@ public static void process_routes(String city, String route_type, boolean useCH)
             gridValuesFNs.add(gvfnStem + "36085_beauty_flickr.csv");
         } else if (city.equals("BOS")) {
             osmFile = osmFile + "boston_massachusetts.osm.pbf";
-            graphFolder = graphFolder + "ghosm_bos";
+            graphFolder = graphFolder + "ghosm_bos_noch";
             inputPointsFN = inputPointsFN + "bos_" + route_type + "_od_pairs.csv";
-            outputPointsFN = outputPointsFN + "bos_" + route_type + "_graphhopper_routes_ksp.csv";
+            outputPointsFN = outputPointsFN + "bos_" + route_type + "gh_routes.csv";
             gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
         } else {
-            return;
-        }
-        if (!useCH) {
-            graphFolder = graphFolder + "_noch";
+            throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
         }
+    }
+
+    public void getGridValues() throws Exception {
+        gvHeaderMap = new HashMap<>();
+        gridBeauty = new HashMap<>();
 
-        HashMap<String, Integer> gvHeaderMap = new HashMap<>();
-        HashMap<String, Float> gridBeauty = new HashMap<>();
         for (String fn : gridValuesFNs) {
             Scanner sc_in = new Scanner(new File(fn));
             String[] gvHeader = sc_in.nextLine().split(",");
@@ -84,26 +99,60 @@ public static void process_routes(String city, String route_type, boolean useCH)
             }
 
         }
+    }
+
+    public void prepareGraphHopper() {
         // create one GraphHopper instance
-        GraphHopper hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
+        hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
         hopper.setDataReaderFile(osmFile);
         // where to store graphhopper files?
         hopper.setGraphHopperLocation(graphFolder);
         hopper.setEncodingManager(new EncodingManager("car"));
 
+        // now this can take minutes if it imports or a few seconds for loading
+        // of course this is dependent on the area you import
+        hopper.importOrLoad();
+    }
+
+    public void writeOutput(FileWriter fw, int i, String optimized, String od_id, PathWrapper bestPath, float score) throws IOException {
+
+        // points, distance in meters and time in seconds (convert from ms) of the full path
+        PointList pointList = bestPath.getPoints();
+        int simplicity = bestPath.getSimplicity();
+        double distance = Math.round(bestPath.getDistance() * 100) / 100;
+        long timeInSec = bestPath.getTime() / 1000;
+        InstructionList il = bestPath.getInstructions();
+        int numDirections = il.getSize();
+        // iterate over every turn instruction
+        ArrayList<String> maneuvers = new ArrayList<>();
+        for (Instruction instruction : il) {
+            maneuvers.add(instruction.getSimpleTurnDescription());
+        }
+
+        fw.write(od_id + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
+                ",\"" + maneuvers.toString() + "\"" + "," + score + "," + simplicity + System.getProperty("line.separator"));
+        System.out.println(i + " (" + optimized + "): Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tSimplicity: " + simplicity + ";\tScore: " + score);
+
+    }
+
+    public void process_routes() throws Exception {
         ArrayList<float[]> inputPoints = new ArrayList<float[]>();
         ArrayList<String> id_to_points = new ArrayList<String>();
-        ArrayList<String> maneuvers = new ArrayList<>();
-        Scanner sc_in = new Scanner(new File(inputPointsFN));
-        FileWriter sc_out = new FileWriter(outputPointsFN, true);
-        sc_out.write("ID,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers" +
-                System.getProperty("line.separator"));
-        FileWriter sc_out_alt;
-        if (outputAlternative) {
-            sc_out_alt = new FileWriter(outputPointsFN.replaceFirst(".csv","_alt.csv"), true);
-            sc_out_alt.write("ID,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers" +
-                    System.getProperty("line.separator"));
+
+        // Prep Filewriters (Optimized, Worst-but-same-distance, Fastest, Simplest)
+        String outputheader = "ID,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity" +
+                System.getProperty("line.separator");
+        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_beauty.csv"), true));
+        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_ugly.csv"), true));
+        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_fast.csv"), true));
+        outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_simple.csv"), true));
+
+        for (FileWriter fw : outputFiles) {
+            fw.write(outputheader);
         }
+
+        // Bring in origin-destination pairs for processing
+        Scanner sc_in = new Scanner(new File(inputPointsFN));
         String header = sc_in.nextLine();
         String od_id;
         float laF;
@@ -127,16 +176,12 @@ public static void process_routes(String city, String route_type, boolean useCH)
         int numPairs = inputPoints.size();
         System.out.println(numPairs + " origin-destination pairs.");
 
-        // now this can take minutes if it imports or a few seconds for loading
-        // of course this is dependent on the area you import
-        hopper.importOrLoad();
-
-        // simple configuration of the request object, see the GraphHopperServlet classs for more possibilities.
+        // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
         float[] points;
-        PointList pointList = null;
-        //List<Map<String, Object>> iList = null;
         int routes_skipped = 0;
         for (int i=0; i<numPairs; i++) {
+
+            // Get Routes
             points = inputPoints.get(i);
             od_id = id_to_points.get(i);
             GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
@@ -152,23 +197,24 @@ public static void process_routes(String city, String route_type, boolean useCH)
                 // handle them!
                 System.out.println(rsp.getErrors().toString());
                 System.out.println(i + ": Skipping.");
-                sc_out.write(od_id + "," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
-                        + ")]\"," + "-1,-1,-1,[]" + System.getProperty("line.separator"));
-                if (outputAlternative) {
-                    sc_out_alt.write(od_id + "," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
-                            + ")]\"," + "-1,-1,-1,[]" + System.getProperty("line.separator"));
+                String outputRow = od_id + "," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
+                        + ")]\"," + "-1,-1,-1,[]" + System.getProperty("line.separator");
+                for (FileWriter fw: outputFiles) {
+                    fw.write(outputRow);
                 }
                 routes_skipped++;
                 continue;
             }
 
-            // use the best path, see the GHResponse class for more possibilities.
+            // Get All Routes (up to 10K right now)
             List<PathWrapper> paths = rsp.getAll();
+
+            // Score each route on beauty to determine most beautiful
             HashSet<String> roundedPoints;
             int j = 0;
-            float maxscore = -1000;
-            int maxidx = 0;
-            for (PathWrapper path: paths) {
+            float bestscore = -1000;
+            int routeidx = -1;
+            for (PathWrapper path : paths) {
                 roundedPoints = path.roundPoints();
                 float score = 0;
                 for (String pt : roundedPoints) {
@@ -177,42 +223,23 @@ public static void process_routes(String city, String route_type, boolean useCH)
                     }
                 }
                 score = score / roundedPoints.size();
-                if (score > maxscore) {
-                    maxscore = score;
-                    maxidx = j;
+                if (score > bestscore) {
+                    bestscore = score;
+                    routeidx = j;
                 }
                 j++;
             }
+            writeOutput(outputFiles.get(0), i, "Best", od_id, paths.get(routeidx), bestscore);
 
-            PathWrapper bestPath = paths.get(maxidx);
-            // points, distance in meters and time in seconds (convert from ms) of the full path
-            pointList = bestPath.getPoints();
-            double distance = Math.round(bestPath.getDistance() * 100) / 100;
-            long timeInSec = bestPath.getTime() / 1000;
-            InstructionList il = bestPath.getInstructions();
-            int numDirections = il.getSize();
-            // iterate over every turn instruction
-            maneuvers.clear();
-            for (Instruction instruction : il) {
-                maneuvers.add(instruction.getSimpleTurnDescription());
-                // System.out.println(instruction.getTurnDescription(usTR) + " for " + instruction.getDistance() + " meters.");
-            }
-
-            sc_out.write(od_id + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
-                    ",\"" + maneuvers.toString() + "\"" + System.getProperty("line.separator"));
-            System.out.println(i + ": Distance: " + Math.round(paths.get(0).getDistance() * 100) / 100 + "m;\tTime: " + paths.get(0).getTime() / 1000 + "sec;\t# Directions: " + paths.get(0).getInstructions().getSize());
-            System.out.println(i + ": Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tScore: " + maxscore);
-
-            int k = 0;
-            int minidx = 0;
-            float minscore = 1000;
-            if (outputAlternative) {
-                double altdistance;
-                for (PathWrapper path: paths) {
-                    altdistance = path.getDistance();
-                    if (altdistance / distance > 1.05 || altdistance / distance < 0.95) {
-                        continue;
-                    }
+            // Find least-beautiful route within similar distance constraints
+            double beautyDistance = paths.get(routeidx).getDistance();
+            j = 0;
+            bestscore = 1000;
+            routeidx = -1;
+            double uglydistance;
+            for (PathWrapper path : paths) {
+                uglydistance = path.getDistance();
+                if (uglydistance / beautyDistance < 1.05 && uglydistance / beautyDistance > 0.95) {
                     roundedPoints = path.roundPoints();
                     float score = 0;
                     for (String pt : roundedPoints) {
@@ -221,44 +248,56 @@ public static void process_routes(String city, String route_type, boolean useCH)
                         }
                     }
                     score = score / roundedPoints.size();
-                    if (score < minscore) {
-                        minscore = score;
-                        minidx = k;
+                    if (score < bestscore) {
+                        bestscore = score;
+                        routeidx = j;
                     }
-                    k++;
-                }
-                bestPath = paths.get(minidx);
-                // points, distance in meters and time in seconds (convert from ms) of the full path
-                pointList = bestPath.getPoints();
-                distance = Math.round(bestPath.getDistance() * 100) / 100;
-                timeInSec = bestPath.getTime() / 1000;
-                il = bestPath.getInstructions();
-                numDirections = il.getSize();
-                // iterate over every turn instruction
-                maneuvers.clear();
-                for (Instruction instruction : il) {
-                    maneuvers.add(instruction.getSimpleTurnDescription());
-                    // System.out.println(instruction.getTurnDescription(usTR) + " for " + instruction.getDistance() + " meters.");
                 }
-                sc_out_alt.write(od_id + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
-                        ",\"" + maneuvers.toString() + "\"" + System.getProperty("line.separator"));
-                System.out.println(i + ": Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tScore: " + minscore);
-
+                j++;
             }
-            paths.clear();
+            writeOutput(outputFiles.get(1), i, "Wrst", od_id, paths.get(routeidx), bestscore);
 
-            // or get the json
-            //iList = il.createJson();
-            //System.out.println("JSON: " + iList);
+            // Simplest Route
+            j = 0;
+            bestscore = 10000;
+            routeidx = 0;
+            float beauty = -1;
+            for (PathWrapper path : paths) {
+                int score = path.getSimplicity();
+                if (score < bestscore) {
+                    bestscore = score;
+                    routeidx = j;
+                    roundedPoints = path.roundPoints();
+                    beauty = 0;
+                    for (String pt : roundedPoints) {
+                        if (gridBeauty.containsKey(pt)) {
+                            beauty = beauty + gridBeauty.get(pt);
+                        }
+                    }
+                    beauty = beauty / roundedPoints.size();
+                }
+                j++;
+            }
+            writeOutput(outputFiles.get(2), i, "Simp", od_id, paths.get(routeidx), beauty);
 
-            // or get the result as gpx entries:
-            //List<GPXEntry> list = il.createGPXList();
-            //System.out.println("GPX: " + list);
+            // Fastest Route
+            PathWrapper bestPath = paths.get(0);
+            roundedPoints = bestPath.roundPoints();
+            beauty = 0;
+            for (String pt : roundedPoints) {
+                if (gridBeauty.containsKey(pt)) {
+                    beauty = beauty + gridBeauty.get(pt);
+                }
+            }
+            beauty = beauty / roundedPoints.size();
+            writeOutput(outputFiles.get(3), i, "Fast", od_id, bestPath, beauty);
         }
-        // example JSON
-        //System.out.println("Example JSON: " + iList);
+
+        // Finished analysis: close filewriters and indicate how many paths skipped
         System.out.println(routes_skipped + " routes skipped out of " + numPairs);
-        sc_out.close();
+        for (FileWriter fw : outputFiles) {
+            fw.close();
+        }
     }
 
     public static void main(String[] args) throws Exception {
@@ -269,7 +308,11 @@ public static void main(String[] args) throws Exception {
         // NYC Random
         //process_routes("NYC", "rand", true);
         // SF Grid
-        process_routes("SF", "grid", false);
+        runKSP SFGrid = new runKSP("SF", "grid");
+        SFGrid.setDataSources();
+        SFGrid.getGridValues();
+        SFGrid.prepareGraphHopper();
+        SFGrid.process_routes();
         // SF Random
         //process_routes("SF", "rand", true);
         //process_routes("BOS", "check", true);
