diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
index 9a8e445b9b..945ef33072 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -26,25 +26,33 @@ public PolygonThroughRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, Loca
         super(ghRequest, ghRsp, locationIndex, ghStorage.getBaseGraph(), nodeAccess, ghStorage, encodingManager);
     }
 
-    private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
-        return !queryGraph.equals(this.queryGraph) || !algoFactory.equals(this.algoFactory) || !algoOpts.equals(this.algorithmOptions);
-    }
-
     protected RouteCandidateList findCandidateRoutes() {
         this.nodesInPolygon = getNodesInPolygon();
-        List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
-        List<List<Integer>> LOTNodes = findLocalOptimalTouchnodes(polygonEntryExitPoints);
+        final List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
+        final List<Integer> viaPointNodeIds = this.extractNodeIdsFromQueryResults();
+        final LOTNodeExtractor LOTNodes = LOTNodeExtractor.createExtractedData(this.graph, this.algoFactory, this.algorithmOptions, viaPointNodeIds, polygonEntryExitPoints);
         this.pathSkeletonRouter = new ManyToManyRouting(nodesInPolygon, polygonEntryExitPoints, this.graph, this.algoFactory, this.algorithmOptions);
         this.pathSkeletonRouter.findPathBetweenAllNodePairs();
 
-        for (int i = 0; i < LOTNodes.size() - 1; i++) {
-            buildRouteCandidatesForCurrentPoint(LOTNodes.get(i), i);
+
+        for (final int viaPointNodeId : viaPointNodeIds) {
+            buildRouteCandidatesForCurrentPoint(LOTNodes.getLotNodesFor(viaPointNodeId));
         }
 
         return this.routeCandidates;
     }
 
-    private void buildRouteCandidatesForCurrentPoint(List<Integer> currentPointsLOTNodes, int pointsIndex) {
+    private List<Integer> extractNodeIdsFromQueryResults() {
+        final List<Integer> nodeIds = new ArrayList<>(this.queryResults.size());
+
+        for (final QueryResult queryResult : this.queryResults) {
+            nodeIds.add(queryResult.getClosestNode());
+        }
+
+        return nodeIds;
+    }
+
+    private void buildRouteCandidatesForCurrentPoint(List<Integer> currentPointsLOTNodes) {
         int pointInQueryResultsIndex = this.queryResults.size() - 2;
         int currentPointID = this.queryResults.get(pointInQueryResultsIndex).getClosestNode();
         int nextPointID = this.queryResults.get(pointInQueryResultsIndex + 1).getClosestNode();
@@ -65,98 +73,7 @@ private RouteCandidatePolygon buildCandidatePath(int currentPointID, int nextPoi
         return routeCandidate;
     }
 
-    // Definition 6 in Storandts paper Region-Aware Routing Planning
-    private List<List<Integer>> findLocalOptimalTouchnodes(final List<Integer> polygonEntryExitPoints) {
-        // TODO: Is there an A* one to many option? Does this make sense at all?
-
-        final EdgeExplorer edgeExplorer = this.queryGraph.createEdgeExplorer();
-
-        List<QueryResult> fixedUserSpecifiedPoints = this.queryResults;
-        List<List<Integer>> LOTNodes = new ArrayList<>();
-        for (final QueryResult point : fixedUserSpecifiedPoints) {
-            makeLOTNodeListForThisPoint(polygonEntryExitPoints, edgeExplorer, LOTNodes, point);
-        }
-
-
-        return LOTNodes;
-    }
-
-    private void makeLOTNodeListForThisPoint(List<Integer> polygonEntryExitPoints, EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, QueryResult point) {
-        System.out.println(point.getClosestNode());
-        Map<Integer, Double> distancesToPolygonEntryExit = getDistancesFromPointToEntryExitPoints(point, polygonEntryExitPoints);
-        addEntryExitPointsCopyTo(polygonEntryExitPoints, LOTNodes);
-
-        List<Integer> thisPointLOTNodeList = LOTNodes.get(LOTNodes.size() - 1);
-        int i = 0;
-        do {
-
-
-            int entryExitPoint = thisPointLOTNodeList.get(i);
-            boolean betterFound = checkIfThisIsAValidLOTNode(edgeExplorer, LOTNodes, distancesToPolygonEntryExit, entryExitPoint);
-
-            if (betterFound) {
-                pruneThisNoteFromLOT(LOTNodes, entryExitPoint);
-            } else {
-                i++;
-            }
-        } while (i < thisPointLOTNodeList.size());
-    }
-
-    private boolean checkIfThisIsAValidLOTNode(EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, Map<Integer, Double> distancesToPolygonEntryExit, int entryExitPoint) {
-        EdgeIterator neighborFinder = edgeExplorer.setBaseNode(entryExitPoint);
-        Double distanceOfThisEntryExitPointFromPoint = distancesToPolygonEntryExit.get(entryExitPoint);
-
-        boolean foundABetterLOTNode =
-                lookForNeighborsThatMakeABetterLOTNode(distancesToPolygonEntryExit, neighborFinder, distanceOfThisEntryExitPointFromPoint);
-
-        return foundABetterLOTNode;
-    }
-
-    private void pruneThisNoteFromLOT(List<List<Integer>> LOTNodes, int entryExitPoint) {
-        LOTNodes.get(LOTNodes.size() - 1).remove((Integer) entryExitPoint);
-    }
-
-    private boolean lookForNeighborsThatMakeABetterLOTNode(Map<Integer, Double> distancesToPolygonEntryExit, EdgeIterator neighborFinder,
-                                                           Double distanceOfThisEntryExitPointFromPoint) {
-        boolean foundABetterLOTNode = false;
-        do {
-            foundABetterLOTNode = foundABetterLOTNode(distancesToPolygonEntryExit, neighborFinder, distanceOfThisEntryExitPointFromPoint);
-        }
-        while (neighborFinder.next() && !foundABetterLOTNode);
-        return foundABetterLOTNode;
-    }
-
-    private boolean foundABetterLOTNode(Map<Integer, Double> distancesToPolygonEntryExit, EdgeIterator neighborFinder, Double distanceOfThisEntryExitPointFromPoint) {
-        final int currentNeighbor = neighborFinder.getAdjNode();
-        Double distanceOfNeighborFromPoint = distancesToPolygonEntryExit.get(currentNeighbor);
-        if (distanceOfNeighborFromPoint != null) {
-            if (distanceOfNeighborFromPoint < distanceOfThisEntryExitPointFromPoint) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void addEntryExitPointsCopyTo(List<Integer> polygonEntryExitPoints, List<List<Integer>> LOTNodes) {
-        int index = LOTNodes.size();
-        LOTNodes.add(index, (ArrayList<Integer>) ((ArrayList<Integer>) polygonEntryExitPoints).clone());
-    }
-
-    private Map<Integer, Double> getDistancesFromPointToEntryExitPoints(QueryResult point, List<Integer> polygonEntryExitPoints) {
-        final int fromNode = point.getClosestNode();
-        this.lotNodeRouter = new OneToManyRouting(fromNode, polygonEntryExitPoints, this.nodesInPolygon, this.queryGraph, this.algoFactory, this.algorithmOptions);
-        this.lotNodeRouter.findPathBetweenAllNodePairs();
-        final List<Path> allFoundPaths = this.lotNodeRouter.getAllFoundPaths();
-
-        final Map<Integer, Double> weightsOfEntryExitPoints = new HashMap<>();
-        for (int i = 0; i < polygonEntryExitPoints.size(); i++) {
-            weightsOfEntryExitPoints.put(polygonEntryExitPoints.get(i), allFoundPaths.get(0).getDistance());
-        }
-
-        return weightsOfEntryExitPoints;
-    }
-
-    private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
+     private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
         final List<Integer> entryExitPoints = new ArrayList<>();
         final EdgeExplorer edgeExplorer = ghStorage.getBaseGraph().createEdgeExplorer();
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
index aabd82c15e..2075d3ce6a 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
@@ -30,7 +30,6 @@ public OneToManyRouting(final int fromNode, final List<Integer> toNodes, List<In
 
     void calculatePaths() {
         for (final int toNode : toNodes) {
-            System.out.println("to: " + toNode);
             final RoutingAlgorithm routingAlgorithm = buildRoutingAlgorithmForFromToPair(toNode);
             final Path path = routingAlgorithm.calcPath(this.fromNode, toNode);
             this.allFoundPaths.put(new Pair(this.fromNode, toNode), path);
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractorTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractorTest.java
index 248058941c..033ad23871 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/LOTNodeExtractorTest.java
@@ -5,11 +5,9 @@
 import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
 import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeExplorer;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
