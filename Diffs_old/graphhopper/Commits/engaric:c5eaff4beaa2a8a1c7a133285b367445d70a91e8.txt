diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index b3f749525f..ca0dddb46c 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -1495,7 +1495,7 @@ protected int loadNodesHeader()
         {
             bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
             bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
-        }        
+        }
 
         return 7;
     }
@@ -1579,7 +1579,7 @@ public boolean isClosed()
     }
 
     @Override
-    public GraphExtension getExtension()    
+    public GraphExtension getExtension()
     {
         return extStorage;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index d16a114944..a4f7477a90 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -95,7 +95,7 @@ public EdgeSkipIterState shortcut( int a, int b )
     public EdgeSkipIterState edge( int a, int b )
     {
         if (lastEdgeIndex + 1 < edgeCount)
-            throw new IllegalStateException("Cannot create after shortcut was created");
+            throw new IllegalStateException("Cannot create edge after first shortcut was created");
 
         lastEdgeIndex = edgeCount;
         return createEdge(a, b);
diff --git a/core/src/main/java/com/graphhopper/storage/VLongStorage.java b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
index 87096def80..c609eca201 100644
--- a/core/src/main/java/com/graphhopper/storage/VLongStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/VLongStorage.java
@@ -77,7 +77,7 @@ void writeByte( byte b )
      * Writes an long in a variable-length format. Writes between one and nine bytes. Smaller values
      * take fewer bytes. Negative numbers are not supported.
      * <p>
-     * The format is described further in {@link DataOutput#writeVInt(int)}.
+     * The format is described further in Lucene its DataOutput#writeVInt(int)
      * <p/>
      * See DataInput readVLong of Lucene
      */
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index d0d82b92f3..b75690f26f 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -47,14 +47,18 @@
     int findID( double lat, double lon );
 
     /**
+     * This method returns the closest QueryResult for the specified location (lat, lon) and only if
+     * the filter accepts the edge as valid candidate (e.g. filtering away car-only results for bike
+     * search)
+     * <p>
      * @param edgeFilter if a graph supports multiple vehicles we have to make sure that the entry
      * node into the graph is accessible from a selected vehicle. E.g. if you have a FOOT-query do:      <pre>
-     *   new DefaultEdgeFilter(new FootFlagEncoder());
+     *   new DefaultEdgeFilter(footFlagEncoder);
      * </pre>
      * <p>
      * @return An object containing the closest node and edge for the specfied location. The node id
-     * has at least one edge which is accepted from the specified edgeFilter. If nothing is found it
-     * returns null.
+     * has at least one edge which is accepted from the specified edgeFilter. If nothing is found
+     * the method QueryResult.isValid will return false.
      */
     QueryResult findClosest( double lat, double lon, EdgeFilter edgeFilter );
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index c3773e96f4..77b7a139b8 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -260,27 +260,6 @@ public int findID( double lat, double lon )
         return res.getClosestNode();
     }
 
-    @Override
-    public boolean loadExisting()
-    {
-        if (initialized)
-            throw new IllegalStateException("Call loadExisting only once");
-
-        if (!dataAccess.loadExisting())
-            return false;
-
-        if (dataAccess.getHeader(0) != MAGIC_INT)
-            throw new IllegalStateException("incorrect location2id index version, expected:" + MAGIC_INT);
-
-        if (dataAccess.getHeader(1 * 4) != calcChecksum())
-            throw new IllegalStateException("location2id index was opened with incorrect graph");
-
-        setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
-        prepareAlgo();
-        initialized = true;
-        return true;
-    }
-
     @Override
     public LocationIndex setResolution( int minResolutionInMeter )
     {
@@ -307,10 +286,32 @@ public LocationIndexTree create( long size )
         throw new UnsupportedOperationException("Not supported. Use prepareIndex instead.");
     }
 
+    @Override
+    public boolean loadExisting()
+    {
+        if (initialized)
+            throw new IllegalStateException("Call loadExisting only once");
+
+        if (!dataAccess.loadExisting())
+            return false;
+
+        if (dataAccess.getHeader(0) != MAGIC_INT)
+            throw new IllegalStateException("incorrect location2id index version, expected:" + MAGIC_INT);
+
+        if (dataAccess.getHeader(1 * 4) != calcChecksum())
+            throw new IllegalStateException("location2id index was opened with incorrect graph: "
+                    + dataAccess.getHeader(1 * 4) + " vs. " + calcChecksum());
+
+        setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
+        prepareAlgo();
+        initialized = true;
+        return true;
+    }
+
     @Override
     public void flush()
     {
-        dataAccess.setHeader(0, MAGIC_INT);
+        dataAccess.setHeader(0, MAGIC_INT);        
         dataAccess.setHeader(1 * 4, calcChecksum());
         dataAccess.setHeader(2 * 4, minResolutionInMeter);
 
@@ -346,6 +347,7 @@ public LocationIndex prepareIndex()
                 + ", leafs:" + Helper.nf(inMem.leafs)
                 + ", precision:" + minResolutionInMeter
                 + ", depth:" + entries.length
+                + ", checksum:" + calcChecksum()
                 + ", entries:" + Arrays.toString(entries)
                 + ", entriesPerLeaf:" + entriesPerLeaf);
 
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index 5e98e3ca80..800bc7c14d 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -17,6 +17,9 @@
  */
 package com.graphhopper.util;
 
+import static java.lang.Math.cos;
+import static java.lang.Math.toRadians;
+
 /**
  * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
  * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
@@ -58,7 +61,8 @@ static final double atan2( double y, double x )
      */
     public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
     {
-        return atan2((lat2 - lat1), (lon2 - lon1));
+        double shrinkFactor = cos(toRadians((lat1 + lat2) / 2));
+        return Math.atan2((lat2 - lat1), shrinkFactor * (lon2 - lon1));
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 7e21bb6055..3502bb7a85 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -133,15 +133,16 @@ public double calcNormalizedEdgeDistanceNew( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
     {
-        double shrink_factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
+
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * shrink_factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * shrink_factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * shrink_factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double delta_lon = b_lon - a_lon;
         double delta_lat = b_lat - a_lat;
@@ -168,7 +169,7 @@ else if (factor < 0)
         // x,y is projection of r onto segment a-b
         double c_lon = a_lon + factor * delta_lon;
         double c_lat = a_lat + factor * delta_lat;
-        return calcNormalizedDist(c_lat, c_lon / shrink_factor, r_lat_deg, r_lon_deg);
+        return calcNormalizedDist(c_lat, c_lon / shrinkFactor, r_lat_deg, r_lon_deg);
     }
 
     @Override
@@ -176,15 +177,15 @@ public GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg )
     {
-        double shrink_factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * shrink_factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * shrink_factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * shrink_factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double delta_lon = b_lon - a_lon;
         double delta_lat = b_lat - a_lat;
@@ -211,7 +212,7 @@ else if (factor < 0)
         // x,y is projection of r onto segment a-b
         double c_lon = a_lon + factor * delta_lon;
         double c_lat = a_lat + factor * delta_lat;
-        return new GHPoint(c_lat, c_lon / shrink_factor);
+        return new GHPoint(c_lat, c_lon / shrinkFactor);
     }
 
     @Override
@@ -219,15 +220,15 @@ public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg )
     {
-        double factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double ar_x = r_lon - a_lon;
         double ar_y = r_lat - a_lat;
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 5d36783569..8a5a878492 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -46,6 +46,14 @@ public InstructionList( int cap, Translation tr )
         this.tr = tr;
     }
 
+    public void replaceLast( Instruction instr )
+    {
+        if (instructions.isEmpty())
+            throw new IllegalStateException("Cannot replace last instruction as list is empty");
+
+        instructions.set(instructions.size() - 1, instr);
+    }
+
     public void add( Instruction instr )
     {
         instructions.add(instr);
@@ -78,8 +86,8 @@ public int size()
             instrJson.put("text", Helper.firstBig(str));
             if (!ia.isEmpty())
             {
-                instrJson.put("annotationText", ia.getMessage());
-                instrJson.put("annotationImportance", ia.getImportance());
+                instrJson.put("annotation_text", ia.getMessage());
+                instrJson.put("annotation_importance", ia.getImportance());
             }
 
             instrJson.put("time", instruction.getTime());
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
index c7786a3cc8..78b759471a 100644
--- a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -9,7 +9,8 @@
 public class RoundaboutInstruction extends Instruction
 {
     private int exitNumber = 0;
-    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private int clockwise = 0;
     private boolean exited = false;
     private double radian = Double.NaN;
 
@@ -107,6 +108,9 @@ public RoundaboutInstruction setRadian( double radian )
     @Override
     public String getTurnDescription( Translation tr )
     {
+        if (rawName)
+            return getName();
+
         String str;
         String streetName = getName();
         int indi = getSign();
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 4d161efd39..d6f385dfc1 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -32,9 +32,9 @@
 public class TranslationMap
 {
     // ISO codes (639-1), use 'en_US' as reference
-    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es", "fil",
-            "fi", "fr", "gl", "he", "it", "ja", "ne", "nl", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk",
-            "vi_VI", "zh_CN");
+    private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es",
+            "fa", "fil", "fi", "fr", "gl", "he", "it", "ja", "ne", "nl", "pt_BR", "pt_PT", "ro", "ru",
+            "si", "sk", "sv_SE", "tr", "uk", "vi_VI", "zh_CN");
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
