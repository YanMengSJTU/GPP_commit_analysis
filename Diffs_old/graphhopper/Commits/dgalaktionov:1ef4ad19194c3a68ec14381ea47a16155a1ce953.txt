diff --git a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
index 749ca67c32..3228251553 100644
--- a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
@@ -17,11 +17,21 @@
  */
 package com.graphhopper.routing.template;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.PathWrapper;
-import com.graphhopper.routing.*;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.NameSimilarityEdgeFilter;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIteratorState;
@@ -32,132 +42,129 @@
 import com.graphhopper.util.exceptions.PointNotFoundException;
 import com.graphhopper.util.shapes.GHPoint;
 
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * Implementation of calculating a route with multiple via points.
  *
  * @author Peter Karich
  */
 public class ViaRoutingTemplate extends AbstractRoutingTemplate implements RoutingTemplate {
-    protected final GHRequest ghRequest;
-    protected final GHResponse ghResponse;
-    protected final PathWrapper altResponse = new PathWrapper();
-    private final LocationIndex locationIndex;
-    // result from route
-    protected List<Path> pathList;
-
-    public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex) {
-        this.locationIndex = locationIndex;
-        this.ghRequest = ghRequest;
-        this.ghResponse = ghRsp;
-    }
-
-    @Override
-    public List<QueryResult> lookup(List<GHPoint> points, FlagEncoder encoder) {
-        if (points.size() < 2)
-            throw new IllegalArgumentException("At least 2 points have to be specified, but was:" + points.size());
-
-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-        queryResults = new ArrayList<>(points.size());
-        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
-            GHPoint point = points.get(placeIndex);
-            QueryResult res;
-            if (ghRequest.hasPointHints()) {
-                res = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(edgeFilter, ghRequest.getPointHints().get(placeIndex)));
-                if (!res.isValid()) {
-                    res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-                }
-            } else {
-                res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-            }
-            if (!res.isValid())
-                ghResponse.addError(new PointNotFoundException("Cannot find point " + placeIndex + ": " + point, placeIndex));
-
-            queryResults.add(res);
-        }
-
-        return queryResults;
-    }
-
-    @Override
-    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
-        long visitedNodesSum = 0L;
-        boolean viaTurnPenalty = ghRequest.getHints().getBool(Routing.PASS_THROUGH, false);
-        int pointCounts = ghRequest.getPoints().size();
-        pathList = new ArrayList<>(pointCounts - 1);
-        QueryResult fromQResult = queryResults.get(0);
-        StopWatch sw;
-        for (int placeIndex = 1; placeIndex < pointCounts; placeIndex++) {
-            if (placeIndex == 1) {
-                // enforce start direction
-                queryGraph.enforceHeading(fromQResult.getClosestNode(), ghRequest.getFavoredHeading(0), false);
-            } else if (viaTurnPenalty) {
-                // enforce straight start after via stop
-                Path prevRoute = pathList.get(placeIndex - 2);
-                if (prevRoute.getEdgeCount() > 0) {
-                    EdgeIteratorState incomingVirtualEdge = prevRoute.getFinalEdge();
-                    queryGraph.unfavorVirtualEdgePair(fromQResult.getClosestNode(), incomingVirtualEdge.getEdge());
-                }
-            }
-
-            QueryResult toQResult = queryResults.get(placeIndex);
-
-            // enforce end direction
-            queryGraph.enforceHeading(toQResult.getClosestNode(), ghRequest.getFavoredHeading(placeIndex), true);
-
-            sw = new StopWatch().start();
-            RoutingAlgorithm algo = algoFactory.createAlgo(queryGraph, algoOpts);
-            String debug = ", algoInit:" + sw.stop().getSeconds() + "s";
-
-            sw = new StopWatch().start();
-            List<Path> tmpPathList = algo.calcPaths(fromQResult.getClosestNode(), toQResult.getClosestNode());
-            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s";
-            if (tmpPathList.isEmpty())
-                throw new IllegalStateException("At least one path has to be returned for " + fromQResult + " -> " + toQResult);
-
-            int idx = 0;
-            for (Path path : tmpPathList) {
-                if (path.getTime() < 0)
-                    throw new RuntimeException("Time was negative " + path.getTime() + " for index " + idx + ". Please report as bug and include:" + ghRequest);
-
-                pathList.add(path);
-                debug += ", " + path.getDebugInfo();
-                idx++;
-            }
-
-            altResponse.addDebugInfo(debug);
-
-            // reset all direction enforcements in queryGraph to avoid influencing next path
-            queryGraph.clearUnfavoredStatus();
-
-            if (algo.getVisitedNodes() >= algoOpts.getMaxVisitedNodes())
-                throw new IllegalArgumentException("No path found due to maximum nodes exceeded " + algoOpts.getMaxVisitedNodes());
-
-            visitedNodesSum += algo.getVisitedNodes();
-            fromQResult = toQResult;
-        }
-
-        ghResponse.getHints().put("visited_nodes.sum", visitedNodesSum);
-        ghResponse.getHints().put("visited_nodes.average", (float) visitedNodesSum / (pointCounts - 1));
-
-        return pathList;
-    }
-
-    @Override
-    public boolean isReady(PathMerger pathMerger, Translation tr) {
-        if (ghRequest.getPoints().size() - 1 != pathList.size())
-            throw new RuntimeException("There should be exactly one more points than paths. points:" + ghRequest.getPoints().size() + ", paths:" + pathList.size());
-
-        altResponse.setWaypoints(getWaypoints());
-        ghResponse.add(altResponse);
-        pathMerger.doWork(altResponse, pathList, tr);
-        return true;
-    }
-
-    @Override
-    public int getMaxRetries() {
-        return 1;
-    }
+	protected final GHRequest ghRequest;
+	protected final GHResponse ghResponse;
+	protected final PathWrapper altResponse = new PathWrapper();
+	private final LocationIndex locationIndex;
+	// result from route
+	protected List<Path> pathList;
+
+	public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex) {
+		this.locationIndex = locationIndex;
+		this.ghRequest = ghRequest;
+		this.ghResponse = ghRsp;
+	}
+
+	@Override
+	public List<QueryResult> lookup(List<GHPoint> points, FlagEncoder encoder) {
+		if (points.size() < 2)
+			throw new IllegalArgumentException("At least 2 points have to be specified, but was:" + points.size());
+
+		EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+		queryResults = new ArrayList<>(points.size());
+		for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
+			GHPoint point = points.get(placeIndex);
+			QueryResult res;
+			if (ghRequest.hasPointHints()) {
+				res = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(edgeFilter, ghRequest.getPointHints().get(placeIndex)));
+				if (!res.isValid()) {
+					res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+				}
+			} else {
+				res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+			}
+			if (!res.isValid())
+				ghResponse.addError(new PointNotFoundException("Cannot find point " + placeIndex + ": " + point, placeIndex));
+
+			queryResults.add(res);
+		}
+
+		return queryResults;
+	}
+
+	@Override
+	public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
+		long visitedNodesSum = 0L;
+		boolean viaTurnPenalty = ghRequest.getHints().getBool(Routing.PASS_THROUGH, false);
+		int pointCounts = ghRequest.getPoints().size();
+		pathList = new ArrayList<>(pointCounts - 1);
+		QueryResult fromQResult = queryResults.get(0);
+		StopWatch sw;
+		for (int placeIndex = 1; placeIndex < pointCounts; placeIndex++) {
+			if (placeIndex == 1) {
+				// enforce start direction
+				queryGraph.enforceHeading(fromQResult.getClosestNode(), ghRequest.getFavoredHeading(0), false);
+			} else if (viaTurnPenalty) {
+				// enforce straight start after via stop
+				Path prevRoute = pathList.get(placeIndex - 2);
+				if (prevRoute.getEdgeCount() > 0) {
+					EdgeIteratorState incomingVirtualEdge = prevRoute.getFinalEdge();
+					queryGraph.unfavorVirtualEdgePair(fromQResult.getClosestNode(), incomingVirtualEdge.getEdge());
+				}
+			}
+
+			QueryResult toQResult = queryResults.get(placeIndex);
+
+			// enforce end direction
+			queryGraph.enforceHeading(toQResult.getClosestNode(), ghRequest.getFavoredHeading(placeIndex), true);
+
+			sw = new StopWatch().start();
+			RoutingAlgorithm algo = algoFactory.createAlgo(queryGraph, algoOpts);
+			String debug = ", algoInit:" + sw.stop().getSeconds() + "s";
+
+			sw = new StopWatch().start();
+			List<Path> tmpPathList = algo.calcPaths(fromQResult.getClosestNode(), toQResult.getClosestNode());
+			debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s";
+			if (tmpPathList.isEmpty())
+				throw new IllegalStateException("At least one path has to be returned for " + fromQResult + " -> " + toQResult);
+
+			int idx = 0;
+			for (Path path : tmpPathList) {
+				if (path.getTime() < 0)
+					throw new RuntimeException("Time was negative " + path.getTime() + " for index " + idx + ". Please report as bug and include:" + ghRequest);
+
+				pathList.add(path);
+				debug += ", " + path.getDebugInfo();
+				idx++;
+			}
+
+			altResponse.addDebugInfo(debug);
+
+			// reset all direction enforcements in queryGraph to avoid influencing next path
+			queryGraph.clearUnfavoredStatus();
+
+			if (algo.getVisitedNodes() >= algoOpts.getMaxVisitedNodes())
+				throw new IllegalArgumentException("No path found due to maximum nodes exceeded " + algoOpts.getMaxVisitedNodes());
+
+			visitedNodesSum += algo.getVisitedNodes();
+			fromQResult = toQResult;
+		}
+
+		ghResponse.getHints().put("visited_nodes.sum", visitedNodesSum);
+		ghResponse.getHints().put("visited_nodes.average", (float) visitedNodesSum / (pointCounts - 1));
+
+		return pathList;
+	}
+
+	@Override
+	public boolean isReady(PathMerger pathMerger, Translation tr) {
+		if (ghRequest.getPoints().size() - 1 != pathList.size())
+			throw new RuntimeException("There should be exactly one more points than paths. points:" + ghRequest.getPoints().size() + ", paths:" + pathList.size());
+
+		altResponse.setWaypoints(getWaypoints());
+		ghResponse.add(altResponse);
+		pathMerger.doWork(altResponse, pathList, tr);
+		return true;
+	}
+
+	@Override
+	public int getMaxRetries() {
+		return 1;
+	}
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 2147f3c6a5..fbf6e6414a 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -17,6 +17,17 @@
  */
 package com.graphhopper.storage.index;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.cursors.IntCursor;
 import com.carrotsearch.hppc.predicates.IntPredicate;
@@ -25,23 +36,24 @@
 import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.geohash.SpatialKeyAlgo;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.*;
-import com.graphhopper.util.*;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.BreadthFirstSearch;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 
-import java.util.ArrayList;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-
 /**
  * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
  * <p>
@@ -53,1000 +65,1000 @@
  * @author Peter Karich
  */
 public class LocationIndexTree implements LocationIndex {
-    // do not start with 0 as a positive value means leaf and a negative means "entry with subentries"
-    static final int START_POINTER = 1;
-    protected final Graph graph;
-    final DataAccess dataAccess;
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final int MAGIC_INT;
-    private final NodeAccess nodeAccess;
-    protected DistanceCalc distCalc = Helper.DIST_PLANE;
-    protected SpatialKeyAlgo keyAlgo;
-    int maxRegionSearch = 4;
-    private DistanceCalc preciseDistCalc = Helper.DIST_EARTH;
-    private int[] entries;
-    private byte[] shifts;
-    // convert spatial key to index for subentry of current depth
-    private long[] bitmasks;
-    private int minResolutionInMeter = 300;
-    private double deltaLat;
-    private double deltaLon;
-    private int initSizeLeafEntries = 4;
-    private boolean initialized = false;
-    private static final Comparator<QueryResult> QR_COMPARATOR = new Comparator<QueryResult>() {
-        @Override
-        public int compare(QueryResult o1, QueryResult o2) {
-            return Double.compare(o1.getQueryDistance(), o2.getQueryDistance());
-        }
-    };
-    /**
-     * If normed distance is smaller than this value the node or edge is 'identical' and the
-     * algorithm can stop search.
-     */
-    private double equalNormedDelta;
-
-    /**
-     * @param g the graph for which this index should do the lookup based on latitude,longitude.
-     */
-    public LocationIndexTree(Graph g, Directory dir) {
-        if (g instanceof CHGraph)
-            throw new IllegalArgumentException("Use base graph for LocationIndexTree instead of CHGraph");
-
-        MAGIC_INT = Integer.MAX_VALUE / 22316;
-        this.graph = g;
-        this.nodeAccess = g.getNodeAccess();
-        dataAccess = dir.find("location_index");
-    }
-
-    public int getMinResolutionInMeter() {
-        return minResolutionInMeter;
-    }
-
-    /**
-     * Minimum width in meter of one tile. Decrease this if you need faster queries, but keep in
-     * mind that then queries with different coordinates are more likely to fail.
-     */
-    public LocationIndexTree setMinResolutionInMeter(int minResolutionInMeter) {
-        this.minResolutionInMeter = minResolutionInMeter;
-        return this;
-    }
-
-    /**
-     * Searches also neighbouring tiles until the maximum distance from the query point is reached
-     * (minResolutionInMeter*regionAround). Set to 1 for to force avoiding a fall back, good if you
-     * have strict performance and lookup-quality requirements. Default is 4.
-     */
-    public LocationIndexTree setMaxRegionSearch(int numTiles) {
-        if (numTiles < 1)
-            throw new IllegalArgumentException("Region of location index must be at least 1 but was " + numTiles);
-
-        // see #232
-        if (numTiles % 2 == 1)
-            numTiles++;
-
-        this.maxRegionSearch = numTiles;
-        return this;
-    }
-
-    void prepareAlgo() {
-        // 0.1 meter should count as 'equal'
-        equalNormedDelta = distCalc.calcNormalizedDist(0.1);
-
-        // now calculate the necessary maxDepth d for our current bounds
-        // if we assume a minimum resolution like 0.5km for a leaf-tile                
-        // n^(depth/2) = toMeter(dLon) / minResolution
-        BBox bounds = graph.getBounds();
-        if (graph.getNodes() == 0)
-            throw new IllegalStateException("Cannot create location index of empty graph!");
-
-        if (!bounds.isValid())
-            throw new IllegalStateException("Cannot create location index when graph has invalid bounds: " + bounds);
-
-        double lat = Math.min(Math.abs(bounds.maxLat), Math.abs(bounds.minLat));
-        double maxDistInMeter = Math.max(
-                (bounds.maxLat - bounds.minLat) / 360 * DistanceCalcEarth.C,
-                (bounds.maxLon - bounds.minLon) / 360 * preciseDistCalc.calcCircumference(lat));
-        double tmp = maxDistInMeter / minResolutionInMeter;
-        tmp = tmp * tmp;
-        IntArrayList tmpEntries = new IntArrayList();
-        // the last one is always 4 to reduce costs if only a single entry
-        tmp /= 4;
-        while (tmp > 1) {
-            int tmpNo;
-            if (tmp >= 64) {
-                tmpNo = 64;
-            } else if (tmp >= 16) {
-                tmpNo = 16;
-            } else if (tmp >= 4) {
-                tmpNo = 4;
-            } else {
-                break;
-            }
-            tmpEntries.add(tmpNo);
-            tmp /= tmpNo;
-        }
-        tmpEntries.add(4);
-        initEntries(tmpEntries.toArray());
-        int shiftSum = 0;
-        long parts = 1;
-        for (int i = 0; i < shifts.length; i++) {
-            shiftSum += shifts[i];
-            parts *= entries[i];
-        }
-        if (shiftSum > 64)
-            throw new IllegalStateException("sum of all shifts does not fit into a long variable");
-
-        keyAlgo = new SpatialKeyAlgo(shiftSum).bounds(bounds);
-        parts = Math.round(Math.sqrt(parts));
-        deltaLat = (bounds.maxLat - bounds.minLat) / parts;
-        deltaLon = (bounds.maxLon - bounds.minLon) / parts;
-    }
-
-    private LocationIndexTree initEntries(int[] entries) {
-        if (entries.length < 1) {
-            // at least one depth should have been specified
-            throw new IllegalStateException("depth needs to be at least 1");
-        }
-        this.entries = entries;
-        int depth = entries.length;
-        shifts = new byte[depth];
-        bitmasks = new long[depth];
-        int lastEntry = entries[0];
-        for (int i = 0; i < depth; i++) {
-            if (lastEntry < entries[i]) {
-                throw new IllegalStateException("entries should decrease or stay but was:"
-                        + Arrays.toString(entries));
-            }
-            lastEntry = entries[i];
-            shifts[i] = getShift(entries[i]);
-            bitmasks[i] = getBitmask(shifts[i]);
-        }
-        return this;
-    }
-
-    private byte getShift(int entries) {
-        byte b = (byte) Math.round(Math.log(entries) / Math.log(2));
-        if (b <= 0)
-            throw new IllegalStateException("invalid shift:" + b);
-
-        return b;
-    }
-
-    private long getBitmask(int shift) {
-        long bm = (1L << shift) - 1;
-        if (bm <= 0) {
-            throw new IllegalStateException("invalid bitmask:" + bm);
-        }
-        return bm;
-    }
-
-    InMemConstructionIndex getPrepareInMemIndex() {
-        InMemConstructionIndex memIndex = new InMemConstructionIndex(entries[0]);
-        memIndex.prepare();
-        return memIndex;
-    }
-
-    @Override
-    public LocationIndex setResolution(int minResolutionInMeter) {
-        if (minResolutionInMeter <= 0)
-            throw new IllegalStateException("Negative precision is not allowed!");
-
-        setMinResolutionInMeter(minResolutionInMeter);
-        return this;
-    }
-
-    @Override
-    public LocationIndex setApproximation(boolean approx) {
-        if (approx)
-            distCalc = Helper.DIST_PLANE;
-        else
-            distCalc = Helper.DIST_EARTH;
-        return this;
-    }
-
-    @Override
-    public LocationIndexTree create(long size) {
-        throw new UnsupportedOperationException("Not supported. Use prepareIndex instead.");
-    }
-
-    @Override
-    public boolean loadExisting() {
-        if (initialized)
-            throw new IllegalStateException("Call loadExisting only once");
-
-        if (!dataAccess.loadExisting())
-            return false;
-
-        if (dataAccess.getHeader(0) != MAGIC_INT)
-            throw new IllegalStateException("incorrect location index version, expected:" + MAGIC_INT);
-
-        if (dataAccess.getHeader(1 * 4) != calcChecksum())
-            throw new IllegalStateException("location index was opened with incorrect graph: "
-                    + dataAccess.getHeader(1 * 4) + " vs. " + calcChecksum());
-
-        setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
-        prepareAlgo();
-        initialized = true;
-        return true;
-    }
-
-    @Override
-    public void flush() {
-        dataAccess.setHeader(0, MAGIC_INT);
-        dataAccess.setHeader(1 * 4, calcChecksum());
-        dataAccess.setHeader(2 * 4, minResolutionInMeter);
-
-        // saving space not necessary: dataAccess.trimTo((lastPointer + 1) * 4);
-        dataAccess.flush();
-    }
-
-    @Override
-    public LocationIndex prepareIndex() {
-        if (initialized)
-            throw new IllegalStateException("Call prepareIndex only once");
-
-        StopWatch sw = new StopWatch().start();
-        prepareAlgo();
-        // in-memory preparation
-        InMemConstructionIndex inMem = getPrepareInMemIndex();
-
-        // compact & store to dataAccess
-        dataAccess.create(64 * 1024);
-        try {
-            inMem.store(inMem.root, START_POINTER);
-            flush();
-        } catch (Exception ex) {
-            throw new IllegalStateException("Problem while storing location index. " + Helper.getMemInfo(), ex);
-        }
-        float entriesPerLeaf = (float) inMem.size / inMem.leafs;
-        initialized = true;
-        logger.info("location index created in " + sw.stop().getSeconds()
-                + "s, size:" + Helper.nf(inMem.size)
-                + ", leafs:" + Helper.nf(inMem.leafs)
-                + ", precision:" + minResolutionInMeter
-                + ", depth:" + entries.length
-                + ", checksum:" + calcChecksum()
-                + ", entries:" + Arrays.toString(entries)
-                + ", entriesPerLeaf:" + entriesPerLeaf);
-
-        return this;
-    }
-
-    int calcChecksum() {
-        // do not include the edges as we could get problem with CHGraph due to shortcuts
-        // ^ graph.getAllEdges().count();
-        return graph.getNodes();
-    }
-
-    @Override
-    public void close() {
-        dataAccess.close();
-    }
-
-    @Override
-    public boolean isClosed() {
-        return dataAccess.isClosed();
-    }
-
-    @Override
-    public long getCapacity() {
-        return dataAccess.getCapacity();
-    }
-
-    @Override
-    public void setSegmentSize(int bytes) {
-        dataAccess.setSegmentSize(bytes);
-    }
-
-    // just for test
-    IntArrayList getEntries() {
-        return IntArrayList.from(entries);
-    }
-
-    // fillIDs according to how they are stored
-    final void fillIDs(long keyPart, int intIndex, GHIntHashSet set, int depth) {
-        long pointer = (long) intIndex << 2;
-        if (depth == entries.length) {
-            int value = dataAccess.getInt(pointer);
-            if (value < 0) {
-                // single data entries (less disc space)
-                set.add(-(value + 1));
-            } else {
-                long max = (long) value * 4;
-                // leaf entry => value is maxPointer
-                for (long leafIndex = pointer + 4; leafIndex < max; leafIndex += 4) {
-                    set.add(dataAccess.getInt(leafIndex));
-                }
-            }
-            return;
-        }
-        int offset = (int) (bitmasks[depth] & keyPart) << 2;
-        int value = dataAccess.getInt(pointer + offset);
-        if (value > 0) {
-            // tree entry => negative value points to subentries
-            fillIDs(keyPart >>> shifts[depth], value, set, depth + 1);
-        }
-    }
-
-    // this method returns the spatial key in reverse order for easier right-shifting
-    final long createReverseKey(double lat, double lon) {
-        return BitUtil.BIG.reverse(keyAlgo.encode(lat, lon), keyAlgo.getBits());
-    }
-
-    final long createReverseKey(long key) {
-        return BitUtil.BIG.reverse(key, keyAlgo.getBits());
-    }
-
-    /**
-     * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
-     * context of a spatial key tile.
-     * <p>
-     */
-    final double calculateRMin(double lat, double lon) {
-        return calculateRMin(lat, lon, 0);
-    }
-
-    /**
-     * Calculates the distance to the nearest tile border, where the tile border is the rectangular
-     * region with dimension 2*paddingTiles + 1 and where the center tile contains the given lat/lon
-     * coordinate
-     */
-    final double calculateRMin(double lat, double lon, int paddingTiles) {
-        GHPoint query = new GHPoint(lat, lon);
-        long key = keyAlgo.encode(query);
-        GHPoint center = new GHPoint();
-        keyAlgo.decode(key, center);
-
-        // deltaLat and deltaLon comes from the LocationIndex:
-        double minLat = center.lat - (0.5 + paddingTiles) * deltaLat;
-        double maxLat = center.lat + (0.5 + paddingTiles) * deltaLat;
-        double minLon = center.lon - (0.5 + paddingTiles) * deltaLon;
-        double maxLon = center.lon + (0.5 + paddingTiles) * deltaLon;
-
-        double dSouthernLat = query.lat - minLat;
-        double dNorthernLat = maxLat - query.lat;
-        double dWesternLon = query.lon - minLon;
-        double dEasternLon = maxLon - query.lon;
-
-        // convert degree deltas into a radius in meter
-        double dMinLat, dMinLon;
-        if (dSouthernLat < dNorthernLat) {
-            dMinLat = distCalc.calcDist(query.lat, query.lon, minLat, query.lon);
-        } else {
-            dMinLat = distCalc.calcDist(query.lat, query.lon, maxLat, query.lon);
-        }
-
-        if (dWesternLon < dEasternLon) {
-            dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, minLon);
-        } else {
-            dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, maxLon);
-        }
-
-        double rMin = Math.min(dMinLat, dMinLon);
-        return rMin;
-    }
-
-    /**
-     * Provide info about tilesize for testing / visualization
-     */
-    public double getDeltaLat() {
-        return deltaLat;
-    }
-
-    public double getDeltaLon() {
-        return deltaLon;
-    }
-
-    GHPoint getCenter(double lat, double lon) {
-        GHPoint query = new GHPoint(lat, lon);
-        long key = keyAlgo.encode(query);
-        GHPoint center = new GHPoint();
-        keyAlgo.decode(key, center);
-        return center;
-    }
-
-    /**
-     * This method collects the node indices from the quad tree data structure in a certain order
-     * which makes sure not too many nodes are collected as well as no nodes will be missing. See
-     * discussion at issue #221.
-     * <p>
-     *
-     * @return true if no further call of this method is required. False otherwise, ie. a next
-     * iteration is necessary and no early finish possible.
-     */
-    public final boolean findNetworkEntries(double queryLat, double queryLon,
-                                            GHIntHashSet foundEntries, int iteration) {
-        // find entries in border of searchbox
-        for (int yreg = -iteration; yreg <= iteration; yreg++) {
-            double subqueryLat = queryLat + yreg * deltaLat;
-            double subqueryLonA = queryLon - iteration * deltaLon;
-            double subqueryLonB = queryLon + iteration * deltaLon;
-            findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonA);
-
-            // minor optimization for iteration == 0
-            if (iteration > 0)
-                findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonB);
-        }
-
-        for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++) {
-            double subqueryLon = queryLon + xreg * deltaLon;
-            double subqueryLatA = queryLat - iteration * deltaLat;
-            double subqueryLatB = queryLat + iteration * deltaLat;
-            findNetworkEntriesSingleRegion(foundEntries, subqueryLatA, subqueryLon);
-            findNetworkEntriesSingleRegion(foundEntries, subqueryLatB, subqueryLon);
-        }
-
-        if (iteration % 2 != 0) {
-            // Check if something was found already...
-            if (!foundEntries.isEmpty()) {
-                double rMin = calculateRMin(queryLat, queryLon, iteration);
-                double minDistance = calcMinDistance(queryLat, queryLon, foundEntries);
-
-                if (minDistance < rMin)
-                    // early finish => foundEntries contains a nearest node for sure
-                    return true;
-                // else: continue as an undetected nearer node may sit in a neighbouring tile.
-                // Now calculate how far we have to look outside to find any hidden nearest nodes
-                // and repeat whole process with wider search area until this distance is covered.
-            }
-        }
-
-        // no early finish possible
-        return false;
-    }
-
-    final double calcMinDistance(double queryLat, double queryLon, GHIntHashSet pointset) {
-        double min = Double.MAX_VALUE;
-        Iterator<IntCursor> itr = pointset.iterator();
-        while (itr.hasNext()) {
-            int node = itr.next().value;
-            double lat = nodeAccess.getLat(node);
-            double lon = nodeAccess.getLon(node);
-            double dist = distCalc.calcDist(queryLat, queryLon, lat, lon);
-            if (dist < min) {
-                min = dist;
-            }
-        }
-        return min;
-    }
-
-    public final void findNetworkEntriesSingleRegion(GHIntHashSet storedNetworkEntryIds, double queryLat, double queryLon) {
-        long keyPart = createReverseKey(queryLat, queryLon);
-        fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
-    }
-
-    @Override
-    public QueryResult findClosest(final double queryLat, final double queryLon, final EdgeFilter edgeFilter) {
-        if (isClosed())
-            throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
-
-        GHIntHashSet allCollectedEntryIds = new GHIntHashSet();
-        final QueryResult closestMatch = new QueryResult(queryLat, queryLon);
-        for (int iteration = 0; iteration < maxRegionSearch; iteration++) {
-            GHIntHashSet storedNetworkEntryIds = new GHIntHashSet();
-            boolean earlyFinish = findNetworkEntries(queryLat, queryLon, storedNetworkEntryIds, iteration);
-            storedNetworkEntryIds.removeAll(allCollectedEntryIds);
-            allCollectedEntryIds.addAll(storedNetworkEntryIds);
-
-            // clone storedIds to avoid interference with forEach
-            final GHBitSet checkBitset = new GHTBitSet(new GHIntHashSet(storedNetworkEntryIds));
-            // find nodes from the network entries which are close to 'point'
-            final EdgeExplorer explorer = graph.createEdgeExplorer();
-            storedNetworkEntryIds.forEach(new IntPredicate() {
-                @Override
-                public boolean apply(int networkEntryNodeId) {
-                    new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter) {
-                        @Override
-                        protected double getQueryDistance() {
-                            return closestMatch.getQueryDistance();
-                        }
-
-                        @Override
-                        protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorState edge, QueryResult.Position pos) {
-                            if (normedDist < closestMatch.getQueryDistance()) {
-                                closestMatch.setQueryDistance(normedDist);
-                                closestMatch.setClosestNode(node);
-                                closestMatch.setClosestEdge(edge.detach(false));
-                                closestMatch.setWayIndex(wayIndex);
-                                closestMatch.setSnappedPosition(pos);
-                                return true;
-                            }
-                            return false;
-                        }
-                    }.start(explorer, networkEntryNodeId);
-                    return true;
-                }
-            });
-
-            // do early finish only if something was found (#318)
-            if (earlyFinish && closestMatch.isValid())
-                break;
-        }
-
-        // denormalize distance and calculate snapping point only if closed match was found
-        if (closestMatch.isValid()) {
-            closestMatch.setQueryDistance(distCalc.calcDenormalizedDist(closestMatch.getQueryDistance()));
-            closestMatch.calcSnappedPoint(distCalc);
-        }
-
-        return closestMatch;
-    }
-    
-    /**
-     * Returns all edges that are within the specified radius around the queried position.
-     * Searches at most 9 cells to avoid performance problems. Hence, if the radius is larger than
-     * the cell width then not all edges might be returned.
-     * 
-     * TODO: either clarify the method name and description (to only search e.g. 9 tiles) or 
-     * refactor so it can handle a radius larger than 9 tiles. Also remove reference to 'NClosest',
-     * which is misleading, and don't always return at least one value. See map-matching #65.
-     * TODO: tidy up logic - see comments in graphhopper #994.
-     *
-     * @param radius in meters
-     */
-    public List<QueryResult> findNClosest(final double queryLat, final double queryLon,
-            final EdgeFilter edgeFilter, double radius) {
-        // Return ALL results which are very close and e.g. within the GPS signal accuracy.
-        // Also important to get all edges if GPS point is close to a junction.
-        final double returnAllResultsWithin = distCalc.calcNormalizedDist(radius);
-
-        // implement a cheap priority queue via List, sublist and Collections.sort
-        final List<QueryResult> queryResults = new ArrayList<QueryResult>();
-        GHIntHashSet set = new GHIntHashSet();
-
-        // Doing 2 iterations means searching 9 tiles.
-        for (int iteration = 0; iteration < 2; iteration++) {
-            // should we use the return value of earlyFinish?
-            findNetworkEntries(queryLat, queryLon, set, iteration);
-
-            final GHBitSet exploredNodes = new GHTBitSet(new GHIntHashSet(set));
-            final EdgeExplorer explorer = graph.createEdgeExplorer(edgeFilter);
-
-            set.forEach(new IntPredicate() {
-
-                @Override
-                public boolean apply(int node) {
-                    new XFirstSearchCheck(queryLat, queryLon, exploredNodes, edgeFilter) {
-                        @Override
-                        protected double getQueryDistance() {
-                            // do not skip search if distance is 0 or near zero (equalNormedDelta)
-                            return Double.MAX_VALUE;
-                        }
-
-                        @Override
-                        protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorState edge, QueryResult.Position pos) {
-                            if (normedDist < returnAllResultsWithin
-                                    || queryResults.isEmpty()
-                                    || queryResults.get(0).getQueryDistance() > normedDist) {
-                                // TODO: refactor below:
-                                // - should only add edges within search radius (below allows the
-                                // returning of a candidate outside search radius if it's the only
-                                // one). Removing this test would simplify it a lot and probably
-                                // match the expected behaviour (see method description)
-                                // - create QueryResult first and the add/set as required - clean up
-                                // the index tracking business.
-
-                                int index = -1;
-                                for (int qrIndex = 0; qrIndex < queryResults.size(); qrIndex++) {
-                                    QueryResult qr = queryResults.get(qrIndex);
-                                    // overwrite older queryResults which are potentially more far away than returnAllResultsWithin
-                                    if (qr.getQueryDistance() > returnAllResultsWithin) {
-                                        index = qrIndex;
-                                        break;
-                                    }
-
-                                    // avoid duplicate edges
-                                    if (qr.getClosestEdge().getEdge() == edge.getEdge()) {
-                                        if (qr.getQueryDistance() < normedDist) {
-                                            // do not add current edge
-                                            return true;
-                                        } else {
-                                            // overwrite old edge with current
-                                            index = qrIndex;
-                                            break;
-                                        }
-                                    }
-                                }
-
-                                QueryResult qr = new QueryResult(queryLat, queryLon);
-                                qr.setQueryDistance(normedDist);
-                                qr.setClosestNode(node);
-                                qr.setClosestEdge(edge.detach(false));
-                                qr.setWayIndex(wayIndex);
-                                qr.setSnappedPosition(pos);
-
-                                if (index < 0) {
-                                    queryResults.add(qr);
-                                } else {
-                                    queryResults.set(index, qr);
-                                }
-                            }
-                            return true;
-                        }
-                    }.start(explorer, node);
-                    return true;
-                }
-            });
-        }
-
-        // TODO: pass boolean argument for whether or not to sort? Can be expensive if not required.
-        Collections.sort(queryResults, QR_COMPARATOR);
-
-        for (QueryResult qr : queryResults) {
-            if (qr.isValid()) {
-                // denormalize distance
-                qr.setQueryDistance(distCalc.calcDenormalizedDist(qr.getQueryDistance()));
-                qr.calcSnappedPoint(distCalc);
-            } else {
-                throw new IllegalStateException("Invalid QueryResult should not happen here: " + qr);
-            }
-        }
-
-        return queryResults;
-    }
-    
-    // make entries static as otherwise we get an additional reference to this class (memory waste)
-    interface InMemEntry {
-        boolean isLeaf();
-    }
-
-    static class InMemLeafEntry extends SortedIntSet implements InMemEntry {
-        // private long key;
-
-        public InMemLeafEntry(int count, long key) {
-            super(count);
-            // this.key = key;
-        }
-
-        public boolean addNode(int nodeId) {
-            return addOnce(nodeId);
-        }
-
-        @Override
-        public final boolean isLeaf() {
-            return true;
-        }
-
-        @Override
-        public String toString() {
-            return "LEAF " + /*key +*/ " " + super.toString();
-        }
-
-        IntArrayList getResults() {
-            return this;
-        }
-    }
-
-    // Space efficient sorted integer set. Suited for only a few entries.
-    static class SortedIntSet extends IntArrayList {
-        public SortedIntSet() {
-        }
-
-        public SortedIntSet(int capacity) {
-            super(capacity);
-        }
-
-        /**
-         * Allow adding a value only once
-         */
-        public boolean addOnce(int value) {
-            int foundIndex = Arrays.binarySearch(buffer, 0, size(), value);
-            if (foundIndex >= 0) {
-                return false;
-            }
-            foundIndex = -foundIndex - 1;
-            insert(foundIndex, value);
-            return true;
-        }
-    }
-
-    static class InMemTreeEntry implements InMemEntry {
-        InMemEntry[] subEntries;
-
-        public InMemTreeEntry(int subEntryNo) {
-            subEntries = new InMemEntry[subEntryNo];
-        }
-
-        public InMemEntry getSubEntry(int index) {
-            return subEntries[index];
-        }
-
-        public void setSubEntry(int index, InMemEntry subEntry) {
-            this.subEntries[index] = subEntry;
-        }
-
-        public Collection<InMemEntry> getSubEntriesForDebug() {
-            List<InMemEntry> list = new ArrayList<InMemEntry>();
-            for (InMemEntry e : subEntries) {
-                if (e != null) {
-                    list.add(e);
-                }
-            }
-            return list;
-        }
-
-        @Override
-        public final boolean isLeaf() {
-            return false;
-        }
-
-        @Override
-        public String toString() {
-            return "TREE";
-        }
-    }
-
-    class InMemConstructionIndex {
-        int size;
-        int leafs;
-        InMemTreeEntry root;
-
-        public InMemConstructionIndex(int noOfSubEntries) {
-            root = new InMemTreeEntry(noOfSubEntries);
-        }
-
-        void prepare() {
-            final EdgeIterator allIter = graph.getAllEdges();
-            try {
-                while (allIter.next()) {
-                    int nodeA = allIter.getBaseNode();
-                    int nodeB = allIter.getAdjNode();
-                    double lat1 = nodeAccess.getLatitude(nodeA);
-                    double lon1 = nodeAccess.getLongitude(nodeA);
-                    double lat2;
-                    double lon2;
-                    PointList points = allIter.fetchWayGeometry(0);
-                    int len = points.getSize();
-                    for (int i = 0; i < len; i++) {
-                        lat2 = points.getLatitude(i);
-                        lon2 = points.getLongitude(i);
-                        addNode(nodeA, nodeB, lat1, lon1, lat2, lon2);
-                        lat1 = lat2;
-                        lon1 = lon2;
-                    }
-                    lat2 = nodeAccess.getLatitude(nodeB);
-                    lon2 = nodeAccess.getLongitude(nodeB);
-                    addNode(nodeA, nodeB, lat1, lon1, lat2, lon2);
-                }
-            } catch (Exception ex) {
-                logger.error("Problem! base:" + allIter.getBaseNode() + ", adj:" + allIter.getAdjNode()
-                        + ", edge:" + allIter.getEdge(), ex);
-            }
-        }
-
-        void addNode(final int nodeA, final int nodeB,
-                     final double lat1, final double lon1,
-                     final double lat2, final double lon2) {
-            PointEmitter pointEmitter = new PointEmitter() {
-                @Override
-                public void set(double lat, double lon) {
-                    long key = keyAlgo.encode(lat, lon);
-                    long keyPart = createReverseKey(key);
-                    // no need to feed both nodes as we search neighbors in fillIDs
-                    addNode(root, nodeA, 0, keyPart, key);
-                }
-            };
-
-            if (!distCalc.isCrossBoundary(lon1, lon2)) {
-                BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
-                        graph.getBounds().minLat, graph.getBounds().minLon,
-                        deltaLat, deltaLon);
-            }
-        }
-
-        void addNode(InMemEntry entry, int nodeId, int depth, long keyPart, long key) {
-            if (entry.isLeaf()) {
-                InMemLeafEntry leafEntry = (InMemLeafEntry) entry;
-                leafEntry.addNode(nodeId);
-            } else {
-                int index = (int) (bitmasks[depth] & keyPart);
-                keyPart = keyPart >>> shifts[depth];
-                InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
-                InMemEntry subentry = treeEntry.getSubEntry(index);
-                depth++;
-                if (subentry == null) {
-                    if (depth == entries.length) {
-                        subentry = new InMemLeafEntry(initSizeLeafEntries, key);
-                    } else {
-                        subentry = new InMemTreeEntry(entries[depth]);
-                    }
-                    treeEntry.setSubEntry(index, subentry);
-                }
-
-                addNode(subentry, nodeId, depth, keyPart, key);
-            }
-        }
-
-        Collection<InMemEntry> getEntriesOf(int selectDepth) {
-            List<InMemEntry> list = new ArrayList<InMemEntry>();
-            fillLayer(list, selectDepth, 0, ((InMemTreeEntry) root).getSubEntriesForDebug());
-            return list;
-        }
-
-        void fillLayer(Collection<InMemEntry> list, int selectDepth, int depth, Collection<InMemEntry> entries) {
-            for (InMemEntry entry : entries) {
-                if (selectDepth == depth) {
-                    list.add(entry);
-                } else if (entry instanceof InMemTreeEntry) {
-                    fillLayer(list, selectDepth, depth + 1, ((InMemTreeEntry) entry).getSubEntriesForDebug());
-                }
-            }
-        }
-
-        String print() {
-            StringBuilder sb = new StringBuilder();
-            print(root, sb, 0, 0);
-            return sb.toString();
-        }
-
-        void print(InMemEntry e, StringBuilder sb, long key, int depth) {
-            if (e.isLeaf()) {
-                InMemLeafEntry leaf = (InMemLeafEntry) e;
-                int bits = keyAlgo.getBits();
-                // print reverse keys
-                sb.append(BitUtil.BIG.toBitString(BitUtil.BIG.reverse(key, bits), bits)).append("  ");
-                IntArrayList entries = leaf.getResults();
-                for (int i = 0; i < entries.size(); i++) {
-                    sb.append(leaf.get(i)).append(',');
-                }
-                sb.append('\n');
-            } else {
-                InMemTreeEntry tree = (InMemTreeEntry) e;
-                key = key << shifts[depth];
-                for (int counter = 0; counter < tree.subEntries.length; counter++) {
-                    InMemEntry sube = tree.subEntries[counter];
-                    if (sube != null) {
-                        print(sube, sb, key | counter, depth + 1);
-                    }
-                }
-            }
-        }
-
-        // store and freezes tree
-        int store(InMemEntry entry, int intIndex) {
-            long refPointer = (long) intIndex * 4;
-            if (entry.isLeaf()) {
-                InMemLeafEntry leaf = ((InMemLeafEntry) entry);
-                IntArrayList entries = leaf.getResults();
-                int len = entries.size();
-                if (len == 0) {
-                    return intIndex;
-                }
-                size += len;
-                intIndex++;
-                leafs++;
-                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
-                if (len == 1) {
-                    // less disc space for single entries
-                    dataAccess.setInt(refPointer, -entries.get(0) - 1);
-                } else {
-                    for (int index = 0; index < len; index++, intIndex++) {
-                        dataAccess.setInt((long) intIndex * 4, entries.get(index));
-                    }
-                    dataAccess.setInt(refPointer, intIndex);
-                }
-            } else {
-                InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
-                int len = treeEntry.subEntries.length;
-                intIndex += len;
-                for (int subCounter = 0; subCounter < len; subCounter++, refPointer += 4) {
-                    InMemEntry subEntry = treeEntry.subEntries[subCounter];
-                    if (subEntry == null) {
-                        continue;
-                    }
-                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
-                    int beforeIntIndex = intIndex;
-                    intIndex = store(subEntry, beforeIntIndex);
-                    if (intIndex == beforeIntIndex) {
-                        dataAccess.setInt(refPointer, 0);
-                    } else {
-                        dataAccess.setInt(refPointer, beforeIntIndex);
-                    }
-                }
-            }
-            return intIndex;
-        }
-    }
-
-    /**
-     * Make it possible to collect nearby location also for other purposes.
-     */
-    protected abstract class XFirstSearchCheck extends BreadthFirstSearch {
-        final double queryLat;
-        final double queryLon;
-        final GHBitSet checkBitset;
-        final EdgeFilter edgeFilter;
-        boolean goFurther = true;
-        double currNormedDist;
-        double currLat;
-        double currLon;
-        int currNode;
-
-        public XFirstSearchCheck(double queryLat, double queryLon, GHBitSet checkBitset, EdgeFilter edgeFilter) {
-            this.queryLat = queryLat;
-            this.queryLon = queryLon;
-            this.checkBitset = checkBitset;
-            this.edgeFilter = edgeFilter;
-        }
-
-        @Override
-        protected GHBitSet createBitSet() {
-            return checkBitset;
-        }
-
-        @Override
-        protected boolean goFurther(int baseNode) {
-            currNode = baseNode;
-            currLat = nodeAccess.getLatitude(baseNode);
-            currLon = nodeAccess.getLongitude(baseNode);
-            currNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, currLat, currLon);
-            return goFurther;
-        }
-
-        @Override
-        protected boolean checkAdjacent(EdgeIteratorState currEdge) {
-            goFurther = false;
-            if (!edgeFilter.accept(currEdge)) {
-                // only limit the adjNode to a certain radius as currNode could be the wrong side of a valid edge
-                // goFurther = currDist < minResolution2InMeterNormed;
-                return true;
-            }
-
-            int tmpClosestNode = currNode;
-            if (check(tmpClosestNode, currNormedDist, 0, currEdge, QueryResult.Position.TOWER)) {
-                if (currNormedDist <= equalNormedDelta)
-                    return false;
-            }
-
-            int adjNode = currEdge.getAdjNode();
-            double adjLat = nodeAccess.getLatitude(adjNode);
-            double adjLon = nodeAccess.getLongitude(adjNode);
-            double adjDist = distCalc.calcNormalizedDist(adjLat, adjLon, queryLat, queryLon);
-            // if there are wayPoints this is only an approximation
-            if (adjDist < currNormedDist)
-                tmpClosestNode = adjNode;
-
-            double tmpLat = currLat;
-            double tmpLon = currLon;
-            double tmpNormedDist;
-            PointList pointList = currEdge.fetchWayGeometry(2);
-            int len = pointList.getSize();
-            for (int pointIndex = 0; pointIndex < len; pointIndex++) {
-                double wayLat = pointList.getLatitude(pointIndex);
-                double wayLon = pointList.getLongitude(pointIndex);
-                QueryResult.Position pos = QueryResult.Position.EDGE;
-                if (distCalc.isCrossBoundary(tmpLon, wayLon)) {
-                    tmpLat = wayLat;
-                    tmpLon = wayLon;
-                    continue;
-                }
-
-                if (distCalc.validEdgeDistance(queryLat, queryLon, tmpLat, tmpLon, wayLat, wayLon)) {
-                    tmpNormedDist = distCalc.calcNormalizedEdgeDistance(queryLat, queryLon,
-                            tmpLat, tmpLon, wayLat, wayLon);
-                    check(tmpClosestNode, tmpNormedDist, pointIndex, currEdge, pos);
-                } else {
-                    if (pointIndex + 1 == len) {
-                        tmpNormedDist = adjDist;
-                        pos = QueryResult.Position.TOWER;
-                    } else {
-                        tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
-                        pos = QueryResult.Position.PILLAR;
-                    }
-                    check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
-                }
-
-                if (tmpNormedDist <= equalNormedDelta)
-                    return false;
-
-                tmpLat = wayLat;
-                tmpLon = wayLon;
-            }
-            return getQueryDistance() > equalNormedDelta;
-        }
-
-        protected abstract double getQueryDistance();
-
-        protected abstract boolean check(int node, double normedDist, int wayIndex, EdgeIteratorState iter, QueryResult.Position pos);
-    }
+	// do not start with 0 as a positive value means leaf and a negative means "entry with subentries"
+	static final int START_POINTER = 1;
+	protected final Graph graph;
+	final DataAccess dataAccess;
+	private final Logger logger = LoggerFactory.getLogger(getClass());
+	private final int MAGIC_INT;
+	private final NodeAccess nodeAccess;
+	protected DistanceCalc distCalc = Helper.DIST_PLANE;
+	protected SpatialKeyAlgo keyAlgo;
+	int maxRegionSearch = 8;
+	private DistanceCalc preciseDistCalc = Helper.DIST_EARTH;
+	private int[] entries;
+	private byte[] shifts;
+	// convert spatial key to index for subentry of current depth
+	private long[] bitmasks;
+	private int minResolutionInMeter = 300;
+	private double deltaLat;
+	private double deltaLon;
+	private int initSizeLeafEntries = 4;
+	private boolean initialized = false;
+	private static final Comparator<QueryResult> QR_COMPARATOR = new Comparator<QueryResult>() {
+		@Override
+		public int compare(QueryResult o1, QueryResult o2) {
+			return Double.compare(o1.getQueryDistance(), o2.getQueryDistance());
+		}
+	};
+	/**
+	 * If normed distance is smaller than this value the node or edge is 'identical' and the
+	 * algorithm can stop search.
+	 */
+	private double equalNormedDelta;
+
+	/**
+	 * @param g the graph for which this index should do the lookup based on latitude,longitude.
+	 */
+	public LocationIndexTree(Graph g, Directory dir) {
+		if (g instanceof CHGraph)
+			throw new IllegalArgumentException("Use base graph for LocationIndexTree instead of CHGraph");
+
+		MAGIC_INT = Integer.MAX_VALUE / 22316;
+		this.graph = g;
+		this.nodeAccess = g.getNodeAccess();
+		dataAccess = dir.find("location_index");
+	}
+
+	public int getMinResolutionInMeter() {
+		return minResolutionInMeter;
+	}
+
+	/**
+	 * Minimum width in meter of one tile. Decrease this if you need faster queries, but keep in
+	 * mind that then queries with different coordinates are more likely to fail.
+	 */
+	public LocationIndexTree setMinResolutionInMeter(int minResolutionInMeter) {
+		this.minResolutionInMeter = minResolutionInMeter;
+		return this;
+	}
+
+	/**
+	 * Searches also neighbouring tiles until the maximum distance from the query point is reached
+	 * (minResolutionInMeter*regionAround). Set to 1 for to force avoiding a fall back, good if you
+	 * have strict performance and lookup-quality requirements. Default is 4.
+	 */
+	public LocationIndexTree setMaxRegionSearch(int numTiles) {
+		if (numTiles < 1)
+			throw new IllegalArgumentException("Region of location index must be at least 1 but was " + numTiles);
+
+		// see #232
+		if (numTiles % 2 == 1)
+			numTiles++;
+
+		this.maxRegionSearch = numTiles;
+		return this;
+	}
+
+	void prepareAlgo() {
+		// 0.1 meter should count as 'equal'
+		equalNormedDelta = distCalc.calcNormalizedDist(0.1);
+
+		// now calculate the necessary maxDepth d for our current bounds
+		// if we assume a minimum resolution like 0.5km for a leaf-tile                
+		// n^(depth/2) = toMeter(dLon) / minResolution
+		BBox bounds = graph.getBounds();
+		if (graph.getNodes() == 0)
+			throw new IllegalStateException("Cannot create location index of empty graph!");
+
+		if (!bounds.isValid())
+			throw new IllegalStateException("Cannot create location index when graph has invalid bounds: " + bounds);
+
+		double lat = Math.min(Math.abs(bounds.maxLat), Math.abs(bounds.minLat));
+		double maxDistInMeter = Math.max(
+				(bounds.maxLat - bounds.minLat) / 360 * DistanceCalcEarth.C,
+				(bounds.maxLon - bounds.minLon) / 360 * preciseDistCalc.calcCircumference(lat));
+		double tmp = maxDistInMeter / minResolutionInMeter;
+		tmp = tmp * tmp;
+		IntArrayList tmpEntries = new IntArrayList();
+		// the last one is always 4 to reduce costs if only a single entry
+		tmp /= 4;
+		while (tmp > 1) {
+			int tmpNo;
+			if (tmp >= 64) {
+				tmpNo = 64;
+			} else if (tmp >= 16) {
+				tmpNo = 16;
+			} else if (tmp >= 4) {
+				tmpNo = 4;
+			} else {
+				break;
+			}
+			tmpEntries.add(tmpNo);
+			tmp /= tmpNo;
+		}
+		tmpEntries.add(4);
+		initEntries(tmpEntries.toArray());
+		int shiftSum = 0;
+		long parts = 1;
+		for (int i = 0; i < shifts.length; i++) {
+			shiftSum += shifts[i];
+			parts *= entries[i];
+		}
+		if (shiftSum > 64)
+			throw new IllegalStateException("sum of all shifts does not fit into a long variable");
+
+		keyAlgo = new SpatialKeyAlgo(shiftSum).bounds(bounds);
+		parts = Math.round(Math.sqrt(parts));
+		deltaLat = (bounds.maxLat - bounds.minLat) / parts;
+		deltaLon = (bounds.maxLon - bounds.minLon) / parts;
+	}
+
+	private LocationIndexTree initEntries(int[] entries) {
+		if (entries.length < 1) {
+			// at least one depth should have been specified
+			throw new IllegalStateException("depth needs to be at least 1");
+		}
+		this.entries = entries;
+		int depth = entries.length;
+		shifts = new byte[depth];
+		bitmasks = new long[depth];
+		int lastEntry = entries[0];
+		for (int i = 0; i < depth; i++) {
+			if (lastEntry < entries[i]) {
+				throw new IllegalStateException("entries should decrease or stay but was:"
+						+ Arrays.toString(entries));
+			}
+			lastEntry = entries[i];
+			shifts[i] = getShift(entries[i]);
+			bitmasks[i] = getBitmask(shifts[i]);
+		}
+		return this;
+	}
+
+	private byte getShift(int entries) {
+		byte b = (byte) Math.round(Math.log(entries) / Math.log(2));
+		if (b <= 0)
+			throw new IllegalStateException("invalid shift:" + b);
+
+		return b;
+	}
+
+	private long getBitmask(int shift) {
+		long bm = (1L << shift) - 1;
+		if (bm <= 0) {
+			throw new IllegalStateException("invalid bitmask:" + bm);
+		}
+		return bm;
+	}
+
+	InMemConstructionIndex getPrepareInMemIndex() {
+		InMemConstructionIndex memIndex = new InMemConstructionIndex(entries[0]);
+		memIndex.prepare();
+		return memIndex;
+	}
+
+	@Override
+	public LocationIndex setResolution(int minResolutionInMeter) {
+		if (minResolutionInMeter <= 0)
+			throw new IllegalStateException("Negative precision is not allowed!");
+
+		setMinResolutionInMeter(minResolutionInMeter);
+		return this;
+	}
+
+	@Override
+	public LocationIndex setApproximation(boolean approx) {
+		if (approx)
+			distCalc = Helper.DIST_PLANE;
+		else
+			distCalc = Helper.DIST_EARTH;
+		return this;
+	}
+
+	@Override
+	public LocationIndexTree create(long size) {
+		throw new UnsupportedOperationException("Not supported. Use prepareIndex instead.");
+	}
+
+	@Override
+	public boolean loadExisting() {
+		if (initialized)
+			throw new IllegalStateException("Call loadExisting only once");
+
+		if (!dataAccess.loadExisting())
+			return false;
+
+		if (dataAccess.getHeader(0) != MAGIC_INT)
+			throw new IllegalStateException("incorrect location index version, expected:" + MAGIC_INT);
+
+		if (dataAccess.getHeader(1 * 4) != calcChecksum())
+			throw new IllegalStateException("location index was opened with incorrect graph: "
+					+ dataAccess.getHeader(1 * 4) + " vs. " + calcChecksum());
+
+		setMinResolutionInMeter(dataAccess.getHeader(2 * 4));
+		prepareAlgo();
+		initialized = true;
+		return true;
+	}
+
+	@Override
+	public void flush() {
+		dataAccess.setHeader(0, MAGIC_INT);
+		dataAccess.setHeader(1 * 4, calcChecksum());
+		dataAccess.setHeader(2 * 4, minResolutionInMeter);
+
+		// saving space not necessary: dataAccess.trimTo((lastPointer + 1) * 4);
+		dataAccess.flush();
+	}
+
+	@Override
+	public LocationIndex prepareIndex() {
+		if (initialized)
+			throw new IllegalStateException("Call prepareIndex only once");
+
+		StopWatch sw = new StopWatch().start();
+		prepareAlgo();
+		// in-memory preparation
+		InMemConstructionIndex inMem = getPrepareInMemIndex();
+
+		// compact & store to dataAccess
+		dataAccess.create(64 * 1024);
+		try {
+			inMem.store(inMem.root, START_POINTER);
+			flush();
+		} catch (Exception ex) {
+			throw new IllegalStateException("Problem while storing location index. " + Helper.getMemInfo(), ex);
+		}
+		float entriesPerLeaf = (float) inMem.size / inMem.leafs;
+		initialized = true;
+		logger.info("location index created in " + sw.stop().getSeconds()
+				+ "s, size:" + Helper.nf(inMem.size)
+				+ ", leafs:" + Helper.nf(inMem.leafs)
+				+ ", precision:" + minResolutionInMeter
+				+ ", depth:" + entries.length
+				+ ", checksum:" + calcChecksum()
+				+ ", entries:" + Arrays.toString(entries)
+				+ ", entriesPerLeaf:" + entriesPerLeaf);
+
+		return this;
+	}
+
+	int calcChecksum() {
+		// do not include the edges as we could get problem with CHGraph due to shortcuts
+		// ^ graph.getAllEdges().count();
+		return graph.getNodes();
+	}
+
+	@Override
+	public void close() {
+		dataAccess.close();
+	}
+
+	@Override
+	public boolean isClosed() {
+		return dataAccess.isClosed();
+	}
+
+	@Override
+	public long getCapacity() {
+		return dataAccess.getCapacity();
+	}
+
+	@Override
+	public void setSegmentSize(int bytes) {
+		dataAccess.setSegmentSize(bytes);
+	}
+
+	// just for test
+	IntArrayList getEntries() {
+		return IntArrayList.from(entries);
+	}
+
+	// fillIDs according to how they are stored
+	final void fillIDs(long keyPart, int intIndex, GHIntHashSet set, int depth) {
+		long pointer = (long) intIndex << 2;
+		if (depth == entries.length) {
+			int value = dataAccess.getInt(pointer);
+			if (value < 0) {
+				// single data entries (less disc space)
+				set.add(-(value + 1));
+			} else {
+				long max = (long) value * 4;
+				// leaf entry => value is maxPointer
+				for (long leafIndex = pointer + 4; leafIndex < max; leafIndex += 4) {
+					set.add(dataAccess.getInt(leafIndex));
+				}
+			}
+			return;
+		}
+		int offset = (int) (bitmasks[depth] & keyPart) << 2;
+		int value = dataAccess.getInt(pointer + offset);
+		if (value > 0) {
+			// tree entry => negative value points to subentries
+			fillIDs(keyPart >>> shifts[depth], value, set, depth + 1);
+		}
+	}
+
+	// this method returns the spatial key in reverse order for easier right-shifting
+	final long createReverseKey(double lat, double lon) {
+		return BitUtil.BIG.reverse(keyAlgo.encode(lat, lon), keyAlgo.getBits());
+	}
+
+	final long createReverseKey(long key) {
+		return BitUtil.BIG.reverse(key, keyAlgo.getBits());
+	}
+
+	/**
+	 * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
+	 * context of a spatial key tile.
+	 * <p>
+	 */
+	final double calculateRMin(double lat, double lon) {
+		return calculateRMin(lat, lon, 0);
+	}
+
+	/**
+	 * Calculates the distance to the nearest tile border, where the tile border is the rectangular
+	 * region with dimension 2*paddingTiles + 1 and where the center tile contains the given lat/lon
+	 * coordinate
+	 */
+	final double calculateRMin(double lat, double lon, int paddingTiles) {
+		GHPoint query = new GHPoint(lat, lon);
+		long key = keyAlgo.encode(query);
+		GHPoint center = new GHPoint();
+		keyAlgo.decode(key, center);
+
+		// deltaLat and deltaLon comes from the LocationIndex:
+		double minLat = center.lat - (0.5 + paddingTiles) * deltaLat;
+		double maxLat = center.lat + (0.5 + paddingTiles) * deltaLat;
+		double minLon = center.lon - (0.5 + paddingTiles) * deltaLon;
+		double maxLon = center.lon + (0.5 + paddingTiles) * deltaLon;
+
+		double dSouthernLat = query.lat - minLat;
+		double dNorthernLat = maxLat - query.lat;
+		double dWesternLon = query.lon - minLon;
+		double dEasternLon = maxLon - query.lon;
+
+		// convert degree deltas into a radius in meter
+		double dMinLat, dMinLon;
+		if (dSouthernLat < dNorthernLat) {
+			dMinLat = distCalc.calcDist(query.lat, query.lon, minLat, query.lon);
+		} else {
+			dMinLat = distCalc.calcDist(query.lat, query.lon, maxLat, query.lon);
+		}
+
+		if (dWesternLon < dEasternLon) {
+			dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, minLon);
+		} else {
+			dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, maxLon);
+		}
+
+		double rMin = Math.min(dMinLat, dMinLon);
+		return rMin;
+	}
+
+	/**
+	 * Provide info about tilesize for testing / visualization
+	 */
+	public double getDeltaLat() {
+		return deltaLat;
+	}
+
+	public double getDeltaLon() {
+		return deltaLon;
+	}
+
+	GHPoint getCenter(double lat, double lon) {
+		GHPoint query = new GHPoint(lat, lon);
+		long key = keyAlgo.encode(query);
+		GHPoint center = new GHPoint();
+		keyAlgo.decode(key, center);
+		return center;
+	}
+
+	/**
+	 * This method collects the node indices from the quad tree data structure in a certain order
+	 * which makes sure not too many nodes are collected as well as no nodes will be missing. See
+	 * discussion at issue #221.
+	 * <p>
+	 *
+	 * @return true if no further call of this method is required. False otherwise, ie. a next
+	 * iteration is necessary and no early finish possible.
+	 */
+	public final boolean findNetworkEntries(double queryLat, double queryLon,
+			GHIntHashSet foundEntries, int iteration) {
+		// find entries in border of searchbox
+		for (int yreg = -iteration; yreg <= iteration; yreg++) {
+			double subqueryLat = queryLat + yreg * deltaLat;
+			double subqueryLonA = queryLon - iteration * deltaLon;
+			double subqueryLonB = queryLon + iteration * deltaLon;
+			findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonA);
+
+			// minor optimization for iteration == 0
+			if (iteration > 0)
+				findNetworkEntriesSingleRegion(foundEntries, subqueryLat, subqueryLonB);
+		}
+
+		for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++) {
+			double subqueryLon = queryLon + xreg * deltaLon;
+			double subqueryLatA = queryLat - iteration * deltaLat;
+			double subqueryLatB = queryLat + iteration * deltaLat;
+			findNetworkEntriesSingleRegion(foundEntries, subqueryLatA, subqueryLon);
+			findNetworkEntriesSingleRegion(foundEntries, subqueryLatB, subqueryLon);
+		}
+
+		if (iteration % 2 != 0) {
+			// Check if something was found already...
+			if (!foundEntries.isEmpty()) {
+				double rMin = calculateRMin(queryLat, queryLon, iteration);
+				double minDistance = calcMinDistance(queryLat, queryLon, foundEntries);
+
+				if (minDistance < rMin)
+					// early finish => foundEntries contains a nearest node for sure
+					return true;
+				// else: continue as an undetected nearer node may sit in a neighbouring tile.
+				// Now calculate how far we have to look outside to find any hidden nearest nodes
+				// and repeat whole process with wider search area until this distance is covered.
+			}
+		}
+
+		// no early finish possible
+		return false;
+	}
+
+	final double calcMinDistance(double queryLat, double queryLon, GHIntHashSet pointset) {
+		double min = Double.MAX_VALUE;
+		Iterator<IntCursor> itr = pointset.iterator();
+		while (itr.hasNext()) {
+			int node = itr.next().value;
+			double lat = nodeAccess.getLat(node);
+			double lon = nodeAccess.getLon(node);
+			double dist = distCalc.calcDist(queryLat, queryLon, lat, lon);
+			if (dist < min) {
+				min = dist;
+			}
+		}
+		return min;
+	}
+
+	public final void findNetworkEntriesSingleRegion(GHIntHashSet storedNetworkEntryIds, double queryLat, double queryLon) {
+		long keyPart = createReverseKey(queryLat, queryLon);
+		fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
+	}
+
+	@Override
+	public QueryResult findClosest(final double queryLat, final double queryLon, final EdgeFilter edgeFilter) {
+		if (isClosed())
+			throw new IllegalStateException("You need to create a new LocationIndex instance as it is already closed");
+
+		GHIntHashSet allCollectedEntryIds = new GHIntHashSet();
+		final QueryResult closestMatch = new QueryResult(queryLat, queryLon);
+		for (int iteration = 0; iteration < maxRegionSearch; iteration++) {
+			GHIntHashSet storedNetworkEntryIds = new GHIntHashSet();
+			boolean earlyFinish = findNetworkEntries(queryLat, queryLon, storedNetworkEntryIds, iteration);
+			storedNetworkEntryIds.removeAll(allCollectedEntryIds);
+			allCollectedEntryIds.addAll(storedNetworkEntryIds);
+
+			// clone storedIds to avoid interference with forEach
+			final GHBitSet checkBitset = new GHTBitSet(new GHIntHashSet(storedNetworkEntryIds));
+			// find nodes from the network entries which are close to 'point'
+			final EdgeExplorer explorer = graph.createEdgeExplorer();
+			storedNetworkEntryIds.forEach(new IntPredicate() {
+				@Override
+				public boolean apply(int networkEntryNodeId) {
+					new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter) {
+						@Override
+						protected double getQueryDistance() {
+							return closestMatch.getQueryDistance();
+						}
+
+						@Override
+						protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorState edge, QueryResult.Position pos) {
+							if (normedDist < closestMatch.getQueryDistance()) {
+								closestMatch.setQueryDistance(normedDist);
+								closestMatch.setClosestNode(node);
+								closestMatch.setClosestEdge(edge.detach(false));
+								closestMatch.setWayIndex(wayIndex);
+								closestMatch.setSnappedPosition(pos);
+								return true;
+							}
+							return false;
+						}
+					}.start(explorer, networkEntryNodeId);
+					return true;
+				}
+			});
+
+			// do early finish only if something was found (#318)
+			if (earlyFinish && closestMatch.isValid())
+				break;
+		}
+
+		// denormalize distance and calculate snapping point only if closed match was found
+		if (closestMatch.isValid()) {
+			closestMatch.setQueryDistance(distCalc.calcDenormalizedDist(closestMatch.getQueryDistance()));
+			closestMatch.calcSnappedPoint(distCalc);
+		}
+
+		return closestMatch;
+	}
+
+	/**
+	 * Returns all edges that are within the specified radius around the queried position.
+	 * Searches at most 9 cells to avoid performance problems. Hence, if the radius is larger than
+	 * the cell width then not all edges might be returned.
+	 * 
+	 * TODO: either clarify the method name and description (to only search e.g. 9 tiles) or 
+	 * refactor so it can handle a radius larger than 9 tiles. Also remove reference to 'NClosest',
+	 * which is misleading, and don't always return at least one value. See map-matching #65.
+	 * TODO: tidy up logic - see comments in graphhopper #994.
+	 *
+	 * @param radius in meters
+	 */
+	public List<QueryResult> findNClosest(final double queryLat, final double queryLon,
+			final EdgeFilter edgeFilter, double radius) {
+		// Return ALL results which are very close and e.g. within the GPS signal accuracy.
+		// Also important to get all edges if GPS point is close to a junction.
+		final double returnAllResultsWithin = distCalc.calcNormalizedDist(radius);
+
+		// implement a cheap priority queue via List, sublist and Collections.sort
+		final List<QueryResult> queryResults = new ArrayList<QueryResult>();
+		GHIntHashSet set = new GHIntHashSet();
+
+		// Doing 2 iterations means searching 9 tiles.
+		for (int iteration = 0; iteration < 2; iteration++) {
+			// should we use the return value of earlyFinish?
+			findNetworkEntries(queryLat, queryLon, set, iteration);
+
+			final GHBitSet exploredNodes = new GHTBitSet(new GHIntHashSet(set));
+			final EdgeExplorer explorer = graph.createEdgeExplorer(edgeFilter);
+
+			set.forEach(new IntPredicate() {
+
+				@Override
+				public boolean apply(int node) {
+					new XFirstSearchCheck(queryLat, queryLon, exploredNodes, edgeFilter) {
+						@Override
+						protected double getQueryDistance() {
+							// do not skip search if distance is 0 or near zero (equalNormedDelta)
+							return Double.MAX_VALUE;
+						}
+
+						@Override
+						protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorState edge, QueryResult.Position pos) {
+							if (normedDist < returnAllResultsWithin
+									|| queryResults.isEmpty()
+									|| queryResults.get(0).getQueryDistance() > normedDist) {
+								// TODO: refactor below:
+								// - should only add edges within search radius (below allows the
+								// returning of a candidate outside search radius if it's the only
+								// one). Removing this test would simplify it a lot and probably
+								// match the expected behaviour (see method description)
+								// - create QueryResult first and the add/set as required - clean up
+								// the index tracking business.
+
+								int index = -1;
+								for (int qrIndex = 0; qrIndex < queryResults.size(); qrIndex++) {
+									QueryResult qr = queryResults.get(qrIndex);
+									// overwrite older queryResults which are potentially more far away than returnAllResultsWithin
+									if (qr.getQueryDistance() > returnAllResultsWithin) {
+										index = qrIndex;
+										break;
+									}
+
+									// avoid duplicate edges
+									if (qr.getClosestEdge().getEdge() == edge.getEdge()) {
+										if (qr.getQueryDistance() < normedDist) {
+											// do not add current edge
+											return true;
+										} else {
+											// overwrite old edge with current
+											index = qrIndex;
+											break;
+										}
+									}
+								}
+
+								QueryResult qr = new QueryResult(queryLat, queryLon);
+								qr.setQueryDistance(normedDist);
+								qr.setClosestNode(node);
+								qr.setClosestEdge(edge.detach(false));
+								qr.setWayIndex(wayIndex);
+								qr.setSnappedPosition(pos);
+
+								if (index < 0) {
+									queryResults.add(qr);
+								} else {
+									queryResults.set(index, qr);
+								}
+							}
+							return true;
+						}
+					}.start(explorer, node);
+					return true;
+				}
+			});
+		}
+
+		// TODO: pass boolean argument for whether or not to sort? Can be expensive if not required.
+		Collections.sort(queryResults, QR_COMPARATOR);
+
+		for (QueryResult qr : queryResults) {
+			if (qr.isValid()) {
+				// denormalize distance
+				qr.setQueryDistance(distCalc.calcDenormalizedDist(qr.getQueryDistance()));
+				qr.calcSnappedPoint(distCalc);
+			} else {
+				throw new IllegalStateException("Invalid QueryResult should not happen here: " + qr);
+			}
+		}
+
+		return queryResults;
+	}
+
+	// make entries static as otherwise we get an additional reference to this class (memory waste)
+	interface InMemEntry {
+		boolean isLeaf();
+	}
+
+	static class InMemLeafEntry extends SortedIntSet implements InMemEntry {
+		// private long key;
+
+		public InMemLeafEntry(int count, long key) {
+			super(count);
+			// this.key = key;
+		}
+
+		public boolean addNode(int nodeId) {
+			return addOnce(nodeId);
+		}
+
+		@Override
+		public final boolean isLeaf() {
+			return true;
+		}
+
+		@Override
+		public String toString() {
+			return "LEAF " + /*key +*/ " " + super.toString();
+		}
+
+		IntArrayList getResults() {
+			return this;
+		}
+	}
+
+	// Space efficient sorted integer set. Suited for only a few entries.
+	static class SortedIntSet extends IntArrayList {
+		public SortedIntSet() {
+		}
+
+		public SortedIntSet(int capacity) {
+			super(capacity);
+		}
+
+		/**
+		 * Allow adding a value only once
+		 */
+		public boolean addOnce(int value) {
+			int foundIndex = Arrays.binarySearch(buffer, 0, size(), value);
+			if (foundIndex >= 0) {
+				return false;
+			}
+			foundIndex = -foundIndex - 1;
+			insert(foundIndex, value);
+			return true;
+		}
+	}
+
+	static class InMemTreeEntry implements InMemEntry {
+		InMemEntry[] subEntries;
+
+		public InMemTreeEntry(int subEntryNo) {
+			subEntries = new InMemEntry[subEntryNo];
+		}
+
+		public InMemEntry getSubEntry(int index) {
+			return subEntries[index];
+		}
+
+		public void setSubEntry(int index, InMemEntry subEntry) {
+			this.subEntries[index] = subEntry;
+		}
+
+		public Collection<InMemEntry> getSubEntriesForDebug() {
+			List<InMemEntry> list = new ArrayList<InMemEntry>();
+			for (InMemEntry e : subEntries) {
+				if (e != null) {
+					list.add(e);
+				}
+			}
+			return list;
+		}
+
+		@Override
+		public final boolean isLeaf() {
+			return false;
+		}
+
+		@Override
+		public String toString() {
+			return "TREE";
+		}
+	}
+
+	class InMemConstructionIndex {
+		int size;
+		int leafs;
+		InMemTreeEntry root;
+
+		public InMemConstructionIndex(int noOfSubEntries) {
+			root = new InMemTreeEntry(noOfSubEntries);
+		}
+
+		void prepare() {
+			final EdgeIterator allIter = graph.getAllEdges();
+			try {
+				while (allIter.next()) {
+					int nodeA = allIter.getBaseNode();
+					int nodeB = allIter.getAdjNode();
+					double lat1 = nodeAccess.getLatitude(nodeA);
+					double lon1 = nodeAccess.getLongitude(nodeA);
+					double lat2;
+					double lon2;
+					PointList points = allIter.fetchWayGeometry(0);
+					int len = points.getSize();
+					for (int i = 0; i < len; i++) {
+						lat2 = points.getLatitude(i);
+						lon2 = points.getLongitude(i);
+						addNode(nodeA, nodeB, lat1, lon1, lat2, lon2);
+						lat1 = lat2;
+						lon1 = lon2;
+					}
+					lat2 = nodeAccess.getLatitude(nodeB);
+					lon2 = nodeAccess.getLongitude(nodeB);
+					addNode(nodeA, nodeB, lat1, lon1, lat2, lon2);
+				}
+			} catch (Exception ex) {
+				logger.error("Problem! base:" + allIter.getBaseNode() + ", adj:" + allIter.getAdjNode()
+				+ ", edge:" + allIter.getEdge(), ex);
+			}
+		}
+
+		void addNode(final int nodeA, final int nodeB,
+				final double lat1, final double lon1,
+				final double lat2, final double lon2) {
+			PointEmitter pointEmitter = new PointEmitter() {
+				@Override
+				public void set(double lat, double lon) {
+					long key = keyAlgo.encode(lat, lon);
+					long keyPart = createReverseKey(key);
+					// no need to feed both nodes as we search neighbors in fillIDs
+					addNode(root, nodeA, 0, keyPart, key);
+				}
+			};
+
+			if (!distCalc.isCrossBoundary(lon1, lon2)) {
+				BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
+						graph.getBounds().minLat, graph.getBounds().minLon,
+						deltaLat, deltaLon);
+			}
+		}
+
+		void addNode(InMemEntry entry, int nodeId, int depth, long keyPart, long key) {
+			if (entry.isLeaf()) {
+				InMemLeafEntry leafEntry = (InMemLeafEntry) entry;
+				leafEntry.addNode(nodeId);
+			} else {
+				int index = (int) (bitmasks[depth] & keyPart);
+				keyPart = keyPart >>> shifts[depth];
+										InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
+										InMemEntry subentry = treeEntry.getSubEntry(index);
+										depth++;
+										if (subentry == null) {
+											if (depth == entries.length) {
+												subentry = new InMemLeafEntry(initSizeLeafEntries, key);
+											} else {
+												subentry = new InMemTreeEntry(entries[depth]);
+											}
+											treeEntry.setSubEntry(index, subentry);
+										}
+
+										addNode(subentry, nodeId, depth, keyPart, key);
+			}
+		}
+
+		Collection<InMemEntry> getEntriesOf(int selectDepth) {
+			List<InMemEntry> list = new ArrayList<InMemEntry>();
+			fillLayer(list, selectDepth, 0, ((InMemTreeEntry) root).getSubEntriesForDebug());
+			return list;
+		}
+
+		void fillLayer(Collection<InMemEntry> list, int selectDepth, int depth, Collection<InMemEntry> entries) {
+			for (InMemEntry entry : entries) {
+				if (selectDepth == depth) {
+					list.add(entry);
+				} else if (entry instanceof InMemTreeEntry) {
+					fillLayer(list, selectDepth, depth + 1, ((InMemTreeEntry) entry).getSubEntriesForDebug());
+				}
+			}
+		}
+
+		String print() {
+			StringBuilder sb = new StringBuilder();
+			print(root, sb, 0, 0);
+			return sb.toString();
+		}
+
+		void print(InMemEntry e, StringBuilder sb, long key, int depth) {
+			if (e.isLeaf()) {
+				InMemLeafEntry leaf = (InMemLeafEntry) e;
+				int bits = keyAlgo.getBits();
+				// print reverse keys
+				sb.append(BitUtil.BIG.toBitString(BitUtil.BIG.reverse(key, bits), bits)).append("  ");
+				IntArrayList entries = leaf.getResults();
+				for (int i = 0; i < entries.size(); i++) {
+					sb.append(leaf.get(i)).append(',');
+				}
+				sb.append('\n');
+			} else {
+				InMemTreeEntry tree = (InMemTreeEntry) e;
+				key = key << shifts[depth];
+				for (int counter = 0; counter < tree.subEntries.length; counter++) {
+					InMemEntry sube = tree.subEntries[counter];
+					if (sube != null) {
+						print(sube, sb, key | counter, depth + 1);
+					}
+				}
+			}
+		}
+
+		// store and freezes tree
+		int store(InMemEntry entry, int intIndex) {
+			long refPointer = (long) intIndex * 4;
+			if (entry.isLeaf()) {
+				InMemLeafEntry leaf = ((InMemLeafEntry) entry);
+				IntArrayList entries = leaf.getResults();
+				int len = entries.size();
+				if (len == 0) {
+					return intIndex;
+				}
+				size += len;
+				intIndex++;
+				leafs++;
+				dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
+				if (len == 1) {
+					// less disc space for single entries
+					dataAccess.setInt(refPointer, -entries.get(0) - 1);
+				} else {
+					for (int index = 0; index < len; index++, intIndex++) {
+						dataAccess.setInt((long) intIndex * 4, entries.get(index));
+					}
+					dataAccess.setInt(refPointer, intIndex);
+				}
+			} else {
+				InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
+				int len = treeEntry.subEntries.length;
+				intIndex += len;
+				for (int subCounter = 0; subCounter < len; subCounter++, refPointer += 4) {
+					InMemEntry subEntry = treeEntry.subEntries[subCounter];
+					if (subEntry == null) {
+						continue;
+					}
+					dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
+					int beforeIntIndex = intIndex;
+					intIndex = store(subEntry, beforeIntIndex);
+					if (intIndex == beforeIntIndex) {
+						dataAccess.setInt(refPointer, 0);
+					} else {
+						dataAccess.setInt(refPointer, beforeIntIndex);
+					}
+				}
+			}
+			return intIndex;
+		}
+	}
+
+	/**
+	 * Make it possible to collect nearby location also for other purposes.
+	 */
+	protected abstract class XFirstSearchCheck extends BreadthFirstSearch {
+		final double queryLat;
+		final double queryLon;
+		final GHBitSet checkBitset;
+		final EdgeFilter edgeFilter;
+		boolean goFurther = true;
+		double currNormedDist;
+		double currLat;
+		double currLon;
+		int currNode;
+
+		public XFirstSearchCheck(double queryLat, double queryLon, GHBitSet checkBitset, EdgeFilter edgeFilter) {
+			this.queryLat = queryLat;
+			this.queryLon = queryLon;
+			this.checkBitset = checkBitset;
+			this.edgeFilter = edgeFilter;
+		}
+
+		@Override
+		protected GHBitSet createBitSet() {
+			return checkBitset;
+		}
+
+		@Override
+		protected boolean goFurther(int baseNode) {
+			currNode = baseNode;
+			currLat = nodeAccess.getLatitude(baseNode);
+			currLon = nodeAccess.getLongitude(baseNode);
+			currNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, currLat, currLon);
+			return goFurther;
+		}
+
+		@Override
+		protected boolean checkAdjacent(EdgeIteratorState currEdge) {
+			goFurther = false;
+			if (!edgeFilter.accept(currEdge)) {
+				// only limit the adjNode to a certain radius as currNode could be the wrong side of a valid edge
+				// goFurther = currDist < minResolution2InMeterNormed;
+				return true;
+			}
+
+			int tmpClosestNode = currNode;
+			if (check(tmpClosestNode, currNormedDist, 0, currEdge, QueryResult.Position.TOWER)) {
+				if (currNormedDist <= equalNormedDelta)
+					return false;
+			}
+
+			int adjNode = currEdge.getAdjNode();
+			double adjLat = nodeAccess.getLatitude(adjNode);
+			double adjLon = nodeAccess.getLongitude(adjNode);
+			double adjDist = distCalc.calcNormalizedDist(adjLat, adjLon, queryLat, queryLon);
+			// if there are wayPoints this is only an approximation
+			if (adjDist < currNormedDist)
+				tmpClosestNode = adjNode;
+
+			double tmpLat = currLat;
+			double tmpLon = currLon;
+			double tmpNormedDist;
+			PointList pointList = currEdge.fetchWayGeometry(2);
+			int len = pointList.getSize();
+			for (int pointIndex = 0; pointIndex < len; pointIndex++) {
+				double wayLat = pointList.getLatitude(pointIndex);
+				double wayLon = pointList.getLongitude(pointIndex);
+				QueryResult.Position pos = QueryResult.Position.EDGE;
+				if (distCalc.isCrossBoundary(tmpLon, wayLon)) {
+					tmpLat = wayLat;
+					tmpLon = wayLon;
+					continue;
+				}
+
+				if (distCalc.validEdgeDistance(queryLat, queryLon, tmpLat, tmpLon, wayLat, wayLon)) {
+					tmpNormedDist = distCalc.calcNormalizedEdgeDistance(queryLat, queryLon,
+							tmpLat, tmpLon, wayLat, wayLon);
+					check(tmpClosestNode, tmpNormedDist, pointIndex, currEdge, pos);
+				} else {
+					if (pointIndex + 1 == len) {
+						tmpNormedDist = adjDist;
+						pos = QueryResult.Position.TOWER;
+					} else {
+						tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
+						pos = QueryResult.Position.PILLAR;
+					}
+					check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
+				}
+
+				if (tmpNormedDist <= equalNormedDelta)
+					return false;
+
+				tmpLat = wayLat;
+				tmpLon = wayLon;
+			}
+			return getQueryDistance() > equalNormedDelta;
+		}
+
+		protected abstract double getQueryDistance();
+
+		protected abstract boolean check(int node, double normedDist, int wayIndex, EdgeIteratorState iter, QueryResult.Position pos);
+	}
 }
diff --git a/core/src/main/java/com/graphhopper/util/CmdArgs.java b/core/src/main/java/com/graphhopper/util/CmdArgs.java
index ebf9ee70d7..1c95cfd4d3 100644
--- a/core/src/main/java/com/graphhopper/util/CmdArgs.java
+++ b/core/src/main/java/com/graphhopper/util/CmdArgs.java
@@ -26,6 +26,9 @@
 import java.util.Map.Entry;
 import java.util.Properties;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * Stores command line options in a map. The capitalization of the key is ignored.
  * <p>
@@ -33,97 +36,98 @@
  * @author Peter Karich
  */
 public class CmdArgs extends PMap {
+	private static final Logger logger = LoggerFactory.getLogger(CmdArgs.class);
+
+	public CmdArgs() {
+	}
+
+	public CmdArgs(Map<String, String> map) {
+		super(map);
+	}
+
+	/**
+	 * @param fileStr        the file name of config.properties
+	 * @param systemProperty the property name of the configuration. E.g. -Dgraphhopper.config
+	 */
+	public static CmdArgs readFromConfig(String fileStr, String systemProperty) throws IOException {
+		if (systemProperty.startsWith("-D"))
+			systemProperty = systemProperty.substring(2);
+
+		String configLocation = System.getProperty(systemProperty);
+		if (Helper.isEmpty(configLocation))
+			configLocation = fileStr;
+
+		Map<String, String> map = new LinkedHashMap<String, String>();
+		Helper.loadProperties(map, new InputStreamReader(new FileInputStream(
+				new File(configLocation).getAbsoluteFile()), Helper.UTF_CS));
+		CmdArgs args = new CmdArgs();
+		args.merge(map);
+
+		// overwrite with system settings
+		Properties props = System.getProperties();
+		for (Entry<Object, Object> e : props.entrySet()) {
+			String k = ((String) e.getKey());
+			String v = ((String) e.getValue());
+			if (k.startsWith("graphhopper.")) {
+				k = k.substring("graphhopper.".length());
+				args.put(k, v);
+			}
+		}
+		return args;
+	}
+
+	/**
+	 * This method creates a CmdArgs object from the specified string array (a list of key=value pairs).
+	 */
+	public static CmdArgs read(String[] args) {
+		Map<String, String> map = new LinkedHashMap<>();
+		for (String arg : args) {
+			int index = arg.indexOf("=");
+			if (index <= 0) {
+				continue;
+			}
+
+			String key = arg.substring(0, index);
+			if (key.startsWith("-")) {
+				key = key.substring(1);
+			}
+
+			if (key.startsWith("-")) {
+				key = key.substring(1);
+			}
+
+			String value = arg.substring(index + 1);
+			String old = map.put(key.toLowerCase(), value);
+			if (old != null)
+				throw new IllegalArgumentException("Pair '" + key.toLowerCase() + "'='" + value + "' not possible to " +
+						"add to the CmdArgs-object as the key already exists with '" + old + "'");
+		}
+
+		return new CmdArgs(map);
+	}
+
+	/**
+	 * Command line configuration overwrites the ones in the config file.
+	 *
+	 * @return a new CmdArgs object if necessary.
+	 */
+	public static CmdArgs readFromConfigAndMerge(CmdArgs args, String configKey, String configSysAttr) {
+		String configVal = args.get(configKey, "../conf/graphhopper.config");
+		if (!Helper.isEmpty(configVal)) {
+			try {
+				CmdArgs tmp = CmdArgs.readFromConfig(configVal, configSysAttr);
+				tmp.merge(args);
+				return tmp;
+			} catch (Exception ex) {
+				throw new RuntimeException(ex);
+			}
+		}
+		return args;
+	}
 
-    public CmdArgs() {
-    }
-
-    public CmdArgs(Map<String, String> map) {
-        super(map);
-    }
-
-    /**
-     * @param fileStr        the file name of config.properties
-     * @param systemProperty the property name of the configuration. E.g. -Dgraphhopper.config
-     */
-    public static CmdArgs readFromConfig(String fileStr, String systemProperty) throws IOException {
-        if (systemProperty.startsWith("-D"))
-            systemProperty = systemProperty.substring(2);
-
-        String configLocation = System.getProperty(systemProperty);
-        if (Helper.isEmpty(configLocation))
-            configLocation = fileStr;
-
-        Map<String, String> map = new LinkedHashMap<String, String>();
-        Helper.loadProperties(map, new InputStreamReader(new FileInputStream(
-                new File(configLocation).getAbsoluteFile()), Helper.UTF_CS));
-        CmdArgs args = new CmdArgs();
-        args.merge(map);
-
-        // overwrite with system settings
-        Properties props = System.getProperties();
-        for (Entry<Object, Object> e : props.entrySet()) {
-            String k = ((String) e.getKey());
-            String v = ((String) e.getValue());
-            if (k.startsWith("graphhopper.")) {
-                k = k.substring("graphhopper.".length());
-                args.put(k, v);
-            }
-        }
-        return args;
-    }
-
-    /**
-     * This method creates a CmdArgs object from the specified string array (a list of key=value pairs).
-     */
-    public static CmdArgs read(String[] args) {
-        Map<String, String> map = new LinkedHashMap<>();
-        for (String arg : args) {
-            int index = arg.indexOf("=");
-            if (index <= 0) {
-                continue;
-            }
-
-            String key = arg.substring(0, index);
-            if (key.startsWith("-")) {
-                key = key.substring(1);
-            }
-
-            if (key.startsWith("-")) {
-                key = key.substring(1);
-            }
-
-            String value = arg.substring(index + 1);
-            String old = map.put(key.toLowerCase(), value);
-            if (old != null)
-                throw new IllegalArgumentException("Pair '" + key.toLowerCase() + "'='" + value + "' not possible to " +
-                        "add to the CmdArgs-object as the key already exists with '" + old + "'");
-        }
-
-        return new CmdArgs(map);
-    }
-
-    /**
-     * Command line configuration overwrites the ones in the config file.
-     *
-     * @return a new CmdArgs object if necessary.
-     */
-    public static CmdArgs readFromConfigAndMerge(CmdArgs args, String configKey, String configSysAttr) {
-        String configVal = args.get(configKey, "");
-        if (!Helper.isEmpty(configVal)) {
-            try {
-                CmdArgs tmp = CmdArgs.readFromConfig(configVal, configSysAttr);
-                tmp.merge(args);
-                return tmp;
-            } catch (Exception ex) {
-                throw new RuntimeException(ex);
-            }
-        }
-        return args;
-    }
-
-    @Override
-    public CmdArgs put(String key, Object str) {
-        super.put(key, str);
-        return this;
-    }
+	@Override
+	public CmdArgs put(String key, Object str) {
+		super.put(key, str);
+		return this;
+	}
 }
diff --git a/graphhopper.sh b/graphhopper.sh
index da33131d07..ccbd964747 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -1,5 +1,5 @@
 #!/bin/bash
-(set -o igncr) 2>/dev/null && set -o igncr; # this comment is required for handling Windows cr/lf 
+(set -o igncr) 2>/dev/null && set -o igncr; # this comment is required for handling Windows cr/lf
 # See StackOverflow answer http://stackoverflow.com/a/14607651
 
 GH_CLASS=com.graphhopper.tools.Import
@@ -43,11 +43,11 @@ function printUsage {
 }
 
 if [ "$ACTION" = "" ]; then
- echo "## action $ACTION not found. try" 
+ echo "## action $ACTION not found. try"
  printUsage
 fi
 
-function ensureOsm { 
+function ensureOsm {
   if [ "$OSM_FILE" = "" ]; then
     # skip
     return
@@ -55,21 +55,21 @@ function ensureOsm {
     echo "File not found '$OSM_FILE'. Press ENTER to get it from: $LINK"
     echo "Press CTRL+C if you do not have enough disc space or you don't want to download several MB."
     read -e
-      
+
     echo "## now downloading OSM file from $LINK and extracting to $OSM_FILE"
-    
+
     if [ ${OSM_FILE: -4} == ".pbf" ]; then
        wget -S -nv -O "$OSM_FILE" "$LINK"
     elif [ ${OSM_FILE: -4} == ".ghz" ]; then
        wget -S -nv -O "$OSM_FILE" "$LINK"
        cd $DATADIR && unzip "$BASENAME" -d "$NAME-gh"
-    else    
+    else
        # make sure aborting download does not result in loading corrupt osm file
        TMP_OSM=temp.osm
        wget -S -nv -O - "$LINK" | bzip2 -d > $TMP_OSM
        mv $TMP_OSM "$OSM_FILE"
     fi
-  
+
     if [[ ! -s "$OSM_FILE" ]]; then
       echo "ERROR couldn't download or extract OSM file $OSM_FILE ... exiting"
       exit
@@ -135,8 +135,8 @@ elif [ "$ACTION" = "eclipse" ]; then
 
 elif [ "$ACTION" = "build" ]; then
  packageCoreJar
- exit  
- 
+ exit
+
 elif [ "$ACTION" = "buildweb" ]; then
  execMvn --projects web -am -DskipTests=true package
  exit
@@ -147,7 +147,7 @@ elif [ "$ACTION" = "extract" ]; then
  #echo "$URL"
  wget -O extract.osm "$URL"
  exit
- 
+
 elif [ "$ACTION" = "android" ]; then
  execMvn -P include-android --projects android/app -am package android:deploy android:run
  exit
@@ -194,10 +194,10 @@ JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar
 LINK=$(echo $NAME | tr '_' '/')
 if [ "$FILE" == "-" ]; then
    LINK=
-elif [ ${FILE: -4} == ".osm" ]; then 
+elif [ ${FILE: -4} == ".osm" ]; then
    LINK="http://download.geofabrik.de/$LINK-latest.osm.bz2"
 elif [ ${FILE: -4} == ".ghz" ]; then
-   LINK="http://graphhopper.com/public/maps/0.1/$FILE"      
+   LINK="http://graphhopper.com/public/maps/0.1/$FILE"
 elif [ ${FILE: -4} == ".pbf" ]; then
    LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 else
@@ -206,7 +206,7 @@ else
 fi
 
 if [ "$JAVA_OPTS" = "" ]; then
-  JAVA_OPTS="-Xmx1000m -Xms1000m -server"
+  JAVA_OPTS="-Xmx2000m -Xms2000m -server"
 fi
 
 ensureOsm
@@ -216,7 +216,7 @@ echo "## now $ACTION. JAVA_OPTS=$JAVA_OPTS"
 
 if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
   export MAVEN_OPTS="$MAVEN_OPTS $JAVA_OPTS"
-  if [ "$JETTY_PORT" = "" ]; then  
+  if [ "$JETTY_PORT" = "" ]; then
     JETTY_PORT=8989
   fi
   WEB_JAR="$GH_HOME/web/target/graphhopper-web-$VERSION-with-dep.jar"
@@ -238,7 +238,7 @@ if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
     if [ "$GH_PID_FILE" != "" ]; then
        echo $! > $GH_PID_FILE
     fi
-    exit $?                    
+    exit $?
   fi
 
 elif [ "$ACTION" = "import" ]; then
@@ -252,7 +252,7 @@ elif [ "$ACTION" = "torture" ]; then
 
 elif [ "$ACTION" = "miniui" ]; then
  execMvn --projects tools -am -DskipTests clean package
- JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar   
+ JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar
  "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI datareader.file="$OSM_FILE" config=$CONFIG \
               graph.location="$GRAPH"
 
@@ -274,11 +274,11 @@ elif [ "$ACTION" = "measurement" ]; then
     "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.Measurement $ARGS measurement.count=$COUNT measurement.location="$M_FILE_NAME" \
             measurement.gitinfo="$commit_info"
  }
- 
- 
+
+
  # use all <last_commits> versions starting from HEAD
  last_commits=$3
-  
+
  if [ "$last_commits" = "" ]; then
    startMeasurement
    exit
@@ -291,7 +291,7 @@ elif [ "$ACTION" = "measurement" ]; then
    M_FILE_NAME=$(git log -n 1 --pretty=oneline | grep -o "\ .*" |  tr " ,;" "_")
    M_FILE_NAME="measurement$M_FILE_NAME.properties"
    echo -e "\nusing commit $commit and $M_FILE_NAME"
-   
+
    startMeasurement
    echo -e "\nmeasurement.commit=$commit\n" >> "$M_FILE_NAME"
  done
diff --git a/web/pom.xml b/web/pom.xml
index 89872c9952..339c047837 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -81,10 +81,23 @@
             <version>${jetty.version}</version>
         </dependency>
 
+		<dependency>
+		  <groupId>javax.servlet</groupId>
+          <artifactId>javax.servlet-api</artifactId>
+		  <version>3.1.0</version>
+		  <scope>provided</scope>
+		</dependency>
+
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
             <artifactId>jetty-server</artifactId>
             <version>${jetty.version}</version>
+            <exclusions>
+            	<exclusion>
+            		<groupId>javax.servlet</groupId>
+            		<artifactId>javax.servlet-api</artifactId>
+            	</exclusion>
+            </exclusions>
         </dependency>
         <dependency>
             <groupId>org.eclipse.jetty</groupId>
diff --git a/web/src/main/java/com/graphhopper/http/GHServer.java b/web/src/main/java/com/graphhopper/http/GHServer.java
index 3c0828a712..b54208d4d5 100644
--- a/web/src/main/java/com/graphhopper/http/GHServer.java
+++ b/web/src/main/java/com/graphhopper/http/GHServer.java
@@ -17,12 +17,10 @@
  */
 package com.graphhopper.http;
 
-import com.google.inject.AbstractModule;
-import com.google.inject.Guice;
-import com.google.inject.Injector;
-import com.google.inject.Module;
-import com.google.inject.servlet.GuiceFilter;
-import com.graphhopper.util.CmdArgs;
+import java.util.EnumSet;
+
+import javax.servlet.DispatcherType;
+
 import org.eclipse.jetty.server.Handler;
 import org.eclipse.jetty.server.HttpConnectionFactory;
 import org.eclipse.jetty.server.Server;
@@ -38,140 +36,161 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.servlet.DispatcherType;
-import java.util.EnumSet;
+import com.google.inject.AbstractModule;
+import com.google.inject.Guice;
+import com.google.inject.Injector;
+import com.google.inject.Module;
+import com.google.inject.servlet.GuiceFilter;
+import com.google.inject.servlet.GuiceServletContextListener;
+import com.graphhopper.util.CmdArgs;
 
 /**
  * Simple server similar to integration tests setup.
  */
-public class GHServer {
-    private final CmdArgs args;
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private Server server;
-    private Injector injector;
-
-    public GHServer(CmdArgs args) {
-        this.args = args;
-    }
-
-    public static void main(String[] args) throws Exception {
-        new GHServer(CmdArgs.read(args)).start();
-    }
-
-    public void start() throws Exception {
-        Injector injector = Guice.createInjector(createModule());
-        start(injector);
-    }
-
-    public void start(Injector injector) throws Exception {
-        if (this.injector != null)
-            throw new IllegalArgumentException("Server already started");
-
-        this.injector = injector;
-        ResourceHandler resHandler = new ResourceHandler();
-        resHandler.setDirectoriesListed(false);
-        resHandler.setWelcomeFiles(new String[]{
-                "index.html"
-        });
-        resHandler.setRedirectWelcome(false);
-
-        ContextHandler contextHandler = new ContextHandler();
-        contextHandler.setContextPath("/");
-        contextHandler.setBaseResource(Resource.newResource(args.get("jetty.resourcebase", "./web/src/main/webapp")));
-        contextHandler.setHandler(resHandler);
-
-        server = new Server();
-        // getSessionHandler and getSecurityHandler should always return null
-        ServletContextHandler servHandler = new ServletContextHandler(ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);
-        servHandler.setErrorHandler(new GHErrorHandler());
-        servHandler.setContextPath("/");
-
-        // Putting this here (and not in the guice servlet module) because it should take precedence
-        // over more specific routes. And guice, strangely, is order-dependent (even though, except in the servlet
-        // extension, modules are _not_ supposed to be ordered).
-        servHandler.addServlet(new ServletHolder(injector.getInstance(InvalidRequestServlet.class)), "/*");
-
-        servHandler.addFilter(new FilterHolder(new GuiceFilter()), "/*", EnumSet.allOf(DispatcherType.class));
-
-        ServerConnector connector0 = new ServerConnector(server);
-        int httpPort = args.getInt("jetty.port", 8989);
-        String host = args.get("jetty.host", "");
-        connector0.setPort(httpPort);
-
-        int requestHeaderSize = args.getInt("jetty.request_header_size", -1);
-        if (requestHeaderSize > 0)
-            connector0.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration().setRequestHeaderSize(requestHeaderSize);
-
-        if (!host.isEmpty())
-            connector0.setHost(host);
-
-        server.addConnector(connector0);
-
-        HandlerList handlers = new HandlerList();
-        handlers.setHandlers(new Handler[]{
-                contextHandler, servHandler
-        });
-
-        GzipHandler gzipHandler = new GzipHandler();
-        gzipHandler.setIncludedMethods("GET", "POST");
-        // Note: gzip only affects the response body like our previous 'GHGZIPHook' behaviour: http://stackoverflow.com/a/31565805/194609
-        // If no mimeTypes are defined the content-type is "not 'application/gzip'", See also https://github.com/graphhopper/directions-api/issues/28 for pitfalls
-        // gzipHandler.setIncludedMimeTypes();
-        gzipHandler.setHandler(handlers);
-
-        GraphHopperService graphHopper = injector.getInstance(GraphHopperService.class);
-        graphHopper.start();
-        createCallOnDestroyModule("AutoCloseable for GraphHopper", graphHopper);
-
-        server.setHandler(gzipHandler);
-        server.setStopAtShutdown(true);
-        server.start();
-        logger.info("Started server at HTTP " + host + ":" + httpPort);
-    }
-
-    protected Module createModule() {
-        return new AbstractModule() {
-            @Override
-            protected void configure() {
-                binder().requireExplicitBindings();
-                if (args.has("gtfs.file")) {
-                    // switch to different API implementation when using Pt
-                    install(new PtModule(args));
-                } else {
-                    install(new GraphHopperModule(args));
-                }
-                install(new GraphHopperServletModule(args));
-            }
-        };
-    }
-
-    /**
-     * Close resources on exit
-     */
-    public final void createCallOnDestroyModule(String name, final AutoCloseable closeable) {
-        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
-            try {
-                if (closeable != null)
-                    closeable.close();
-            } catch (Exception ex) {
-                if (logger != null)
-                    logger.error("Cannot close " + name + " (" + closeable + ")", ex);
-            }
-        }, name));
-    }
-
-    public void stop() {
-        if (server == null)
-            return;
-
-        try {
-            server.stop();
-        } catch (Exception ex) {
-            logger.error("Cannot stop jetty", ex);
-        }
-    }
-
-    Injector getInjector() {
-        return injector;
-    }
+public class GHServer extends GuiceServletContextListener {
+	private final CmdArgs args;
+	private final Logger logger = LoggerFactory.getLogger(getClass());
+	private Server server;
+	private Injector injector;
+
+	public GHServer() {
+		this.args = new CmdArgs();
+	}
+
+	public GHServer(CmdArgs args) {
+		this.args = args;
+	}
+
+	public static void main(String[] args) throws Exception {
+		new GHServer(CmdArgs.read(args)).start();
+	}
+
+	public void start() throws Exception {
+		Injector injector = Guice.createInjector(createModule());
+		start(injector);
+	}
+
+	public void start(Injector injector) throws Exception {
+		if (this.injector != null)
+			throw new IllegalArgumentException("Server already started");
+
+		this.injector = injector;
+		ResourceHandler resHandler = new ResourceHandler();
+		resHandler.setDirectoriesListed(false);
+		resHandler.setWelcomeFiles(new String[]{
+				"index.html"
+		});
+		resHandler.setRedirectWelcome(false);
+
+		ContextHandler contextHandler = new ContextHandler();
+		contextHandler.setContextPath("/");
+		contextHandler.setBaseResource(Resource.newResource(args.get("jetty.resourcebase", "./web/src/main/webapp")));
+		contextHandler.setHandler(resHandler);
+
+		server = new Server();
+		// getSessionHandler and getSecurityHandler should always return null
+		ServletContextHandler servHandler = new ServletContextHandler(ServletContextHandler.NO_SECURITY | ServletContextHandler.NO_SESSIONS);
+		servHandler.setErrorHandler(new GHErrorHandler());
+		servHandler.setContextPath("/");
+
+		// Putting this here (and not in the guice servlet module) because it should take precedence
+		// over more specific routes. And guice, strangely, is order-dependent (even though, except in the servlet
+		// extension, modules are _not_ supposed to be ordered).
+		servHandler.addServlet(new ServletHolder(injector.getInstance(InvalidRequestServlet.class)), "/*");
+
+		servHandler.addFilter(new FilterHolder(new GuiceFilter()), "/*", EnumSet.allOf(DispatcherType.class));
+
+		ServerConnector connector0 = new ServerConnector(server);
+		int httpPort = args.getInt("jetty.port", 8989);
+		String host = args.get("jetty.host", "");
+		connector0.setPort(httpPort);
+
+		int requestHeaderSize = args.getInt("jetty.request_header_size", -1);
+		if (requestHeaderSize > 0)
+			connector0.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration().setRequestHeaderSize(requestHeaderSize);
+
+		if (!host.isEmpty())
+			connector0.setHost(host);
+
+		server.addConnector(connector0);
+
+		HandlerList handlers = new HandlerList();
+		handlers.setHandlers(new Handler[]{
+				contextHandler, servHandler
+		});
+
+		GzipHandler gzipHandler = new GzipHandler();
+		gzipHandler.setIncludedMethods("GET", "POST");
+		// Note: gzip only affects the response body like our previous 'GHGZIPHook' behaviour: http://stackoverflow.com/a/31565805/194609
+		// If no mimeTypes are defined the content-type is "not 'application/gzip'", See also https://github.com/graphhopper/directions-api/issues/28 for pitfalls
+		// gzipHandler.setIncludedMimeTypes();
+		gzipHandler.setHandler(handlers);
+
+		GraphHopperService graphHopper = injector.getInstance(GraphHopperService.class);
+		graphHopper.start();
+		createCallOnDestroyModule("AutoCloseable for GraphHopper", graphHopper);
+
+		server.setHandler(gzipHandler);
+		server.setStopAtShutdown(true);
+		server.start();
+		logger.info("Started server at HTTP " + host + ":" + httpPort);
+	}
+
+	protected Module createModule() {
+		return new AbstractModule() {
+			@Override
+			protected void configure() {
+				binder().requireExplicitBindings();
+				if (args.has("gtfs.file")) {
+					// switch to different API implementation when using Pt
+					install(new PtModule(args));
+				} else {
+					install(new GraphHopperModule(args));
+				}
+				install(new GraphHopperServletModule(args));
+			}
+		};
+	}
+
+	/**
+	 * Close resources on exit
+	 */
+	public final void createCallOnDestroyModule(String name, final AutoCloseable closeable) {
+		Runtime.getRuntime().addShutdownHook(new Thread(() -> {
+			try {
+				if (closeable != null)
+					closeable.close();
+			} catch (Exception ex) {
+				if (logger != null)
+					logger.error("Cannot close " + name + " (" + closeable + ")", ex);
+			}
+		}, name));
+	}
+
+	public void stop() {
+		if (server == null)
+			return;
+
+		try {
+			server.stop();
+		} catch (Exception ex) {
+			logger.error("Cannot stop jetty", ex);
+		}
+	}
+
+	@Override
+	protected Injector getInjector() {
+		if (injector == null) {
+			logger.warn("Bootstrapping injector");
+			Injector injector = Guice.createInjector(createModule());
+
+			try {
+				start(injector);
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+
+		return injector;
+	}
 }
diff --git a/web/src/main/webapp/WEB-INF/web.xml b/web/src/main/webapp/WEB-INF/web.xml
new file mode 100644
index 0000000000..cd3d095b9d
--- /dev/null
+++ b/web/src/main/webapp/WEB-INF/web.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
+	version="2.4">
+
+	<display-name>Graphhopper Router</display-name>
+
+	<!-- ======== Sesion ======== -->
+
+	<session-config>
+		<session-timeout>30</session-timeout>
+	</session-config>
+	
+	  <filter>
+	    <filter-name>guiceFilter</filter-name>
+	    <filter-class>com.google.inject.servlet.GuiceFilter</filter-class>
+	  </filter>
+	
+	  <filter-mapping>
+	    <filter-name>guiceFilter</filter-name>
+	    <url-pattern>/*</url-pattern>
+	  </filter-mapping>
+	
+	<listener>
+	  <listener-class>com.graphhopper.http.GHServer</listener-class>
+	</listener>
+</web-app>
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 8a76769f58..b780afa7d5 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -42169,12 +42169,16 @@ var GHRequest = require('./graphhopper/GHRequest.js');
 var host = ghenv.routing.host;
 if (!host) {
     if (location.port === '') {
-        host = location.protocol + '//' + location.hostname;
+        host = location.protocol + '//' + location.hostname + location.pathname;
     } else {
-        host = location.protocol + '//' + location.hostname + ":" + location.port;
+        host = location.protocol + '//' + location.hostname + ":" + location.port + location.pathname;
     }
 }
 
+if (host.endsWith("/")) {
+	host = host.substr(0, host.length-1);
+}
+
 var AutoComplete = require('./autocomplete.js');
 if (ghenv.environment === 'development')
     var autocomplete = AutoComplete.prototype.createStub();
