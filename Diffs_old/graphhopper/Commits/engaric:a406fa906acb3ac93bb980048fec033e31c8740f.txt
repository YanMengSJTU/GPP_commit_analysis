diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index c45718e40b..7378f53961 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
+ *  license agreements. See the NOTICE file distributed with this work for 
  *  additional information regarding copyright ownership.
- *
- *  GraphHopper licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
  *  compliance with the License. You may obtain a copy of the License at
- *
+ * 
  *       http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,81 +17,40 @@
  */
 package com.graphhopper;
 
-import java.io.File;
-import java.io.IOException;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.OSMReader;
+import com.graphhopper.reader.osgb.OsItnReader;
+import com.graphhopper.reader.osgb.dpn.OsDpnReader;
 import com.graphhopper.reader.dem.CGIARProvider;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
-import com.graphhopper.reader.osgb.OsItnReader;
-import com.graphhopper.reader.osgb.dpn.OsDpnReader;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.QueryGraph;
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.RoutingAlgorithmFactory;
-import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FastestWeighting;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.PrepareRoutingSubnetworks;
-import com.graphhopper.routing.util.PriorityWeighting;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.TurnWeighting;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.routing.util.WeightingMap;
-import com.graphhopper.storage.DAType;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.GHDirectory;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.storage.LevelGraphStorage;
-import com.graphhopper.storage.Lock;
-import com.graphhopper.storage.LockFactory;
-import com.graphhopper.storage.NativeFSLockFactory;
-import com.graphhopper.storage.SimpleFSLockFactory;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Constants;
-import com.graphhopper.util.DouglasPeucker;
-import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PathMerger;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.TranslationMap;
-import com.graphhopper.util.Unzipper;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Easy to use access point to configure import and (offline) routing.
  * <p/>
- *
  * @see GraphHopperAPI
  * @author Peter Karich
  */
-public class GraphHopper implements GraphHopperAPI {
-    private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM or OSITN";
+public class GraphHopper implements GraphHopperAPI
+{
+    private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM, OSITN or OSDPN";
     private final Logger logger = LoggerFactory.getLogger(getClass());
     // for graph:
     private GraphStorage graph;
@@ -120,7 +79,7 @@
     // for prepare
     private int minNetworkSize = 200;
     private int minOneWayNetworkSize = 0;
-    // for CH prepare
+    // for CH prepare    
     private boolean doPrepare = true;
     private boolean chEnabled = true;
     private String chWeightingStr = "fastest";
@@ -129,36 +88,37 @@
     private int neighborUpdates = -1;
     private double logMessages = -1;
     // for OSM import
+    private String dataReader = "OSM";
     private String osmFile;
     private double osmReaderWayPointMaxDistance = 1;
     private int workerThreads = -1;
     private boolean calcPoints = true;
-    // utils
+    // utils    
     private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private final AtomicLong visitedSum = new AtomicLong(0);
-    private String dataReader = "OSM";
 
-    public GraphHopper() {
+    public GraphHopper()
+    {
     }
 
     /**
      * For testing only
      */
-    protected GraphHopper loadGraph(GraphStorage g) {
+    protected GraphHopper loadGraph( GraphStorage g )
+    {
         this.graph = g;
         fullyLoaded = true;
         initLocationIndex();
-        initDefaultVehicleIfNecessary();
         return this;
     }
 
     /**
-     * Specify which vehicles can be read by this GraphHopper instance. An
-     * encoding manager defines how data from every vehicle is written (und
-     * read) into edges of the graph.
+     * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
+     * how data from every vehicle is written (und read) into edges of the graph.
      */
-    public GraphHopper setEncodingManager(EncodingManager em) {
+    public GraphHopper setEncodingManager( EncodingManager em )
+    {
         ensureNotLoaded();
         this.encodingManager = em;
         if (em.needsTurnCostsSupport())
@@ -167,15 +127,23 @@ public GraphHopper setEncodingManager(EncodingManager em) {
         return this;
     }
 
-    private FlagEncoder getFirstVehicle() {
+    FlagEncoder getDefaultVehicle()
+    {
+        if (encodingManager == null)
+        {
+            throw new IllegalStateException("No encoding manager specified or loaded");
+        }
+
         return encodingManager.fetchEdgeEncoders().get(0);
     }
 
-    public EncodingManager getEncodingManager() {
+    public EncodingManager getEncodingManager()
+    {
         return encodingManager;
     }
 
-    public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
+    public GraphHopper setElevationProvider( ElevationProvider eleProvider )
+    {
         if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
             setElevation(false);
         else
@@ -187,24 +155,25 @@ public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
     /**
      * Threads for data reading.
      */
-    protected int getWorkerThreads() {
+    protected int getWorkerThreads()
+    {
         return workerThreads;
     }
 
     /**
-     * Return maximum distance (in meter) to reduce points via douglas peucker
-     * while OSM import.
+     * Return maximum distance (in meter) to reduce points via douglas peucker while OSM import.
      */
-    protected double getWayPointMaxDistance() {
+    protected double getWayPointMaxDistance()
+    {
         return osmReaderWayPointMaxDistance;
     }
 
     /**
-     * This parameter specifies how to reduce points via douglas peucker while
-     * OSM import. Higher value means more details, unit is meter. Default is 1.
-     * Disable via 0.
+     * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
+     * value means more details, unit is meter. Default is 1. Disable via 0.
      */
-    public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
+    public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
+    {
         this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
         return this;
     }
@@ -212,55 +181,61 @@ public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
     /**
      * Sets the default traversal mode used for the algorithms and preparation.
      */
-    public GraphHopper setTraversalMode(TraversalMode traversalMode) {
+    public GraphHopper setTraversalMode( TraversalMode traversalMode )
+    {
         this.traversalMode = traversalMode;
         return this;
     }
 
-    public TraversalMode getTraversalMode() {
+    public TraversalMode getTraversalMode()
+    {
         return traversalMode;
     }
 
     /**
-     * Configures the underlying storage and response to be used on a well
-     * equipped server. Result also optimized for usage in the web module i.e.
-     * try reduce network IO.
+     * Configures the underlying storage and response to be used on a well equipped server. Result
+     * also optimized for usage in the web module i.e. try reduce network IO.
      */
-    public GraphHopper forServer() {
+    public GraphHopper forServer()
+    {
         setSimplifyResponse(true);
         return setInMemory();
     }
 
     /**
-     * Configures the underlying storage to be used on a Desktop computer or
-     * within another Java application with enough RAM but no network latency.
+     * Configures the underlying storage to be used on a Desktop computer or within another Java
+     * application with enough RAM but no network latency.
      */
-    public GraphHopper forDesktop() {
+    public GraphHopper forDesktop()
+    {
         setSimplifyResponse(false);
         return setInMemory();
     }
 
     /**
-     * Configures the underlying storage to be used on a less powerful machine
-     * like Android or Raspberry Pi with only few MB of RAM.
+     * Configures the underlying storage to be used on a less powerful machine like Android or
+     * Raspberry Pi with only few MB of RAM.
      */
-    public GraphHopper forMobile() {
+    public GraphHopper forMobile()
+    {
         setSimplifyResponse(false);
         return setMemoryMapped();
     }
 
     /**
-     * Precise location resolution index means also more space (disc/RAM) could
-     * be consumed and probably slower query times, which would be e.g. not
-     * suitable for Android. The resolution specifies the tile width (in meter).
+     * Precise location resolution index means also more space (disc/RAM) could be consumed and
+     * probably slower query times, which would be e.g. not suitable for Android. The resolution
+     * specifies the tile width (in meter).
      */
-    public GraphHopper setPreciseIndexResolution(int precision) {
+    public GraphHopper setPreciseIndexResolution( int precision )
+    {
         ensureNotLoaded();
         preciseIndexResolution = precision;
         return this;
     }
 
-    public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
+    public void setMinNetworkSize( int minNetworkSize, int minOneWayNetworkSize )
+    {
         this.minNetworkSize = minNetworkSize;
         this.minOneWayNetworkSize = minOneWayNetworkSize;
     }
@@ -268,23 +243,22 @@ public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
     /**
      * This method call results in an in-memory graph.
      */
-    public GraphHopper setInMemory() {
+    public GraphHopper setInMemory()
+    {
         ensureNotLoaded();
         dataAccessType = DAType.RAM_STORE;
         return this;
     }
 
     /**
-     * Only valid option for in-memory graph and if you e.g. want to disable
-     * store on flush for unit tests. Specify storeOnFlush to true if you want
-     * that existing data will be loaded FROM disc and all in-memory data will
-     * be flushed TO disc after flush is called e.g. while OSM import.
+     * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
+     * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
+     * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
      * <p>
-     *
-     * @param storeOnFlush
-     *            true by default
+     * @param storeOnFlush true by default
      */
-    public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
+    public GraphHopper setStoreOnFlush( boolean storeOnFlush )
+    {
         ensureNotLoaded();
         if (storeOnFlush)
             dataAccessType = DAType.RAM_STORE;
@@ -294,10 +268,10 @@ public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
     }
 
     /**
-     * Enable memory mapped configuration if not enough memory is available on
-     * the target platform.
+     * Enable memory mapped configuration if not enough memory is available on the target platform.
      */
-    public GraphHopper setMemoryMapped() {
+    public GraphHopper setMemoryMapped()
+    {
         ensureNotLoaded();
         dataAccessType = DAType.MMAP;
         return this;
@@ -306,75 +280,50 @@ public GraphHopper setMemoryMapped() {
     /**
      * Not yet stable enough to offer it for everyone
      */
-    private GraphHopper setUnsafeMemory() {
+    private GraphHopper setUnsafeMemory()
+    {
         ensureNotLoaded();
         dataAccessType = DAType.UNSAFE_STORE;
         return this;
     }
 
     /**
-     * This method sets the default vehicle to use if no vehicle is specified in
-     * the GHRequest object. Per default the lexicographically first vehicle is
-     * used.
-     */
-    public void setDefaultVehicle(String defaultVehicleStr)
-    {
-        if (this.defaultVehicleStr != null)
-            throw new RuntimeException("Cannot change default vehicle " + this.defaultVehicleStr + " to " + defaultVehicleStr);
-
-        this.defaultVehicleStr = defaultVehicleStr;
-    }
-
-    /**
-     * The default vehicle is the single vehicle used for CH preparation as well
-     * as the default vehicle if no specified in GHRequest. Per default the
-     * lexicographically first vehicle is used.
-     */
-    public String getDefaultVehicle() {
-        if (defaultVehicleStr == null)
-            throw new RuntimeException("Set default vehicle before");
-
-        return defaultVehicleStr;
-    }
-
-    /**
-     * Enables the use of contraction hierarchies to reduce query times. Enabled
-     * by default.
+     * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p/>
-     *
-     * @param weighting
-     *            can be "fastest", "shortest" or your own weight-calculation
-     *            type.
+     * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
      * @see #setCHEnable(boolean)
      */
-    public GraphHopper setCHWeighting(String weighting) {
+    public GraphHopper setCHWeighting( String weighting )
+    {
         ensureNotLoaded();
         chWeightingStr = weighting;
         return this;
     }
 
-    public String getCHWeighting() {
+    public String getCHWeighting()
+    {
         return chWeightingStr;
     }
 
     /**
-     * Disables the "CH-preparation" preparation only. Use only if you know what
-     * you do. To disable the full usage of CH use setCHEnable(false) instead.
+     * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
+     * the full usage of CH use setCHEnable(false) instead.
      */
-    public GraphHopper setDoPrepare(boolean doPrepare) {
+    public GraphHopper setDoPrepare( boolean doPrepare )
+    {
         this.doPrepare = doPrepare;
         return this;
     }
 
     /**
-     * Enables or disables contraction hierarchies (CH). This speed-up mode is
-     * enabled by default. Disabling CH is only recommended for short routes or
-     * in combination with setDefaultWeightLimit and called flexibility mode
+     * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
+     * Disabling CH is only recommended for short routes or in combination with
+     * setDefaultWeightLimit and called flexibility mode
      * <p>
-     *
      * @see #setDefaultWeightLimit(double)
      */
-    public GraphHopper setCHEnable(boolean enable) {
+    public GraphHopper setCHEnable( boolean enable )
+    {
         ensureNotLoaded();
         algoFactory = null;
         chEnabled = enable;
@@ -382,60 +331,64 @@ public GraphHopper setCHEnable(boolean enable) {
     }
 
     /**
-     * This methods stops the algorithm from searching further if the resulting
-     * path would go over specified weight, important if CH is disabled. The
-     * unit is defined by the used weighting created from createWeighting, e.g.
-     * distance for shortest or seconds for the standard FastestWeighting
-     * implementation.
+     * This methods stops the algorithm from searching further if the resulting path would go over
+     * specified weight, important if CH is disabled. The unit is defined by the used weighting
+     * created from createWeighting, e.g. distance for shortest or seconds for the standard
+     * FastestWeighting implementation.
      */
-    public void setDefaultWeightLimit(double defaultWeightLimit) {
+    public void setDefaultWeightLimit( double defaultWeightLimit )
+    {
         this.defaultWeightLimit = defaultWeightLimit;
     }
 
-    public boolean isCHEnabled() {
+    public boolean isCHEnabled()
+    {
         return chEnabled;
     }
 
     /**
-     * @return true if storing and fetching elevation data is enabled. Default
-     *         is false
+     * @return true if storing and fetching elevation data is enabled. Default is false
      */
-    public boolean hasElevation() {
+    public boolean hasElevation()
+    {
         return elevation;
     }
 
     /**
      * Enable storing and fetching elevation data. Default is false
      */
-    public GraphHopper setElevation(boolean includeElevation) {
+    public GraphHopper setElevation( boolean includeElevation )
+    {
         this.elevation = includeElevation;
         return this;
     }
 
     /**
-     * This method specifies if the import should include way names to be able
-     * to return instructions for a route.
+     * This method specifies if the import should include way names to be able to return
+     * instructions for a route.
      */
-    public GraphHopper setEnableInstructions(boolean b) {
+    public GraphHopper setEnableInstructions( boolean b )
+    {
         ensureNotLoaded();
         enableInstructions = b;
         return this;
     }
 
     /**
-     * This methods enables gps point calculation. If disabled only distance
-     * will be calculated.
+     * This methods enables gps point calculation. If disabled only distance will be calculated.
      */
-    public GraphHopper setEnableCalcPoints(boolean b) {
+    public GraphHopper setEnableCalcPoints( boolean b )
+    {
         calcPoints = b;
         return this;
     }
 
     /**
-     * This method specifies if the returned path should be simplified or not,
-     * via douglas-peucker or similar algorithm.
+     * This method specifies if the returned path should be simplified or not, via douglas-peucker
+     * or similar algorithm.
      */
-    private GraphHopper setSimplifyResponse(boolean doSimplify) {
+    private GraphHopper setSimplifyResponse( boolean doSimplify )
+    {
         this.simplifyResponse = doSimplify;
         return this;
     }
@@ -443,7 +396,8 @@ private GraphHopper setSimplifyResponse(boolean doSimplify) {
     /**
      * Sets the graphhopper folder.
      */
-    public GraphHopper setGraphHopperLocation(String ghLocation) {
+    public GraphHopper setGraphHopperLocation( String ghLocation )
+    {
         ensureNotLoaded();
         if (ghLocation == null)
             throw new IllegalArgumentException("graphhopper location cannot be null");
@@ -452,15 +406,17 @@ public GraphHopper setGraphHopperLocation(String ghLocation) {
         return this;
     }
 
-    public String getGraphHopperLocation() {
+    public String getGraphHopperLocation()
+    {
         return ghLocation;
     }
 
     /**
-     * This file can be an osm xml (.osm), a compressed xml (.osm.zip or
-     * .osm.gz) or a protobuf file (.pbf).
+     * This file can be an osm xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file
+     * (.pbf).
      */
-    public GraphHopper setOSMFile(String osmFileStr) {
+    public GraphHopper setOSMFile( String osmFileStr )
+    {
         ensureNotLoaded();
         if (Helper.isEmpty(osmFileStr))
             throw new IllegalArgumentException("OSM file cannot be empty.");
@@ -469,40 +425,41 @@ public GraphHopper setOSMFile(String osmFileStr) {
         return this;
     }
 
-    public String getOSMFile() {
+    public String getOSMFile()
+    {
         return osmFile;
     }
 
     /**
      * The underlying graph used in algorithms.
      * <p>
-     *
-     * @throws IllegalStateException
-     *             if graph is not instantiated.
+     * @throws IllegalStateException if graph is not instantiated.
      */
-    public GraphStorage getGraph() {
+    public GraphStorage getGraph()
+    {
         if (graph == null)
             throw new IllegalStateException("Graph not initialized");
 
         return graph;
     }
 
-    public void setGraph(GraphStorage graph) {
+    public void setGraph( GraphStorage graph )
+    {
         this.graph = graph;
     }
 
-    protected void setLocationIndex(LocationIndex locationIndex) {
+    protected void setLocationIndex( LocationIndex locationIndex )
+    {
         this.locationIndex = locationIndex;
     }
 
     /**
      * The location index created from the graph.
      * <p>
-     *
-     * @throws IllegalStateException
-     *             if index is not initialized
+     * @throws IllegalStateException if index is not initialized
      */
-    public LocationIndex getLocationIndex() {
+    public LocationIndex getLocationIndex()
+    {
         if (locationIndex == null)
             throw new IllegalStateException("Location index not initialized");
 
@@ -512,37 +469,40 @@ public LocationIndex getLocationIndex() {
     /**
      * Sorts the graph which requires more RAM while import. See #12
      */
-    public GraphHopper setSortGraph(boolean sortGraph) {
+    public GraphHopper setSortGraph( boolean sortGraph )
+    {
         ensureNotLoaded();
         this.sortGraph = sortGraph;
         return this;
     }
 
     /**
-     * Specifies if it is allowed for GraphHopper to write. E.g. for read only
-     * filesystems it is not possible to create a lock file and so we can avoid
-     * write locks.
+     * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
+     * possible to create a lock file and so we can avoid write locks.
      */
-    public GraphHopper setAllowWrites(boolean allowWrites) {
+    public GraphHopper setAllowWrites( boolean allowWrites )
+    {
         this.allowWrites = allowWrites;
         return this;
     }
 
-    public boolean isAllowWrites() {
+    public boolean isAllowWrites()
+    {
         return allowWrites;
     }
 
-    public TranslationMap getTranslationMap() {
+    public TranslationMap getTranslationMap()
+    {
         return trMap;
     }
 
     /**
-     * Reads configuration from a CmdArgs object. Which can be manually filled,
-     * or via main(String[] args) ala CmdArgs.read(args) or via configuration
-     * file ala CmdArgs.readFromConfig("config.properties",
-     * "graphhopper.config")
+     * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
+     * args) ala CmdArgs.read(args) or via configuration file ala
+     * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
      */
-    public GraphHopper init(CmdArgs args) {
+    public GraphHopper init( CmdArgs args )
+    {
         args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
         String tmpOsmFile = args.get("osmreader.osm", "");
         if (!Helper.isEmpty(tmpOsmFile))
@@ -551,7 +511,8 @@ public GraphHopper init(CmdArgs args) {
         dataReader = args.get("reader.implementation", dataReader);
 
         String graphHopperFolder = args.get("graph.location", "");
-        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
+        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
+        {
             if (Helper.isEmpty(osmFile))
                 throw new IllegalArgumentException("You need to specify an OSM file.");
 
@@ -581,8 +542,10 @@ public GraphHopper init(CmdArgs args) {
         DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
         ElevationProvider tmpProvider = ElevationProvider.NOOP;
         if (eleProviderStr.equalsIgnoreCase("srtm"))
+        {
             tmpProvider = new SRTMProvider();
-        else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
+        } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
+        {
             CGIARProvider cgiarProvider = new CGIARProvider();
             cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
             tmpProvider = cgiarProvider;
@@ -611,17 +574,15 @@ else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
         neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
         logMessages = args.getDouble("prepare.logmessages", logMessages);
 
+        // osm import
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
         String flagEncoders = args.get("graph.flagEncoders", "");
-        if(!flagEncoders.isEmpty())
+        if (!flagEncoders.isEmpty())
             setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
 
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
-        // default vehicle which is used if no algorithm is specified
-        setDefaultVehicle(args.get("algorithm.defaultVehicle", getFirstVehicle().toString()));
-
         // index
         preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
         maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
@@ -631,65 +592,77 @@ else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
         return this;
     }
 
-    private void printInfo() {
+    private void printInfo()
+    {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
         if (graph != null)
             logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
     }
 
     /**
-     * Imports provided data from disc and creates graph. Depending on the
-     * settings the resulting graph will be stored to disc so on a second call
-     * this method will only load the graph from disc which is usually a lot
-     * faster.
+     * Imports provided data from disc and creates graph. Depending on the settings the resulting
+     * graph will be stored to disc so on a second call this method will only load the graph from
+     * disc which is usually a lot faster.
      */
-    public GraphHopper importOrLoad() {
-        if (!load(ghLocation)) {
+    public GraphHopper importOrLoad()
+    {
+        if (!load(ghLocation))
+        {
             printInfo();
             process(ghLocation);
         } else
+        {
             printInfo();
+        }
         return this;
     }
 
     /**
      * Creates the graph from OSM data.
      */
-    private GraphHopper process(String graphHopperLocation) {
+    private GraphHopper process( String graphHopperLocation )
+    {
         setGraphHopperLocation(graphHopperLocation);
         Lock lock = null;
-        try {
-            if (graph.getDirectory().getDefaultType().isStoring()) {
+        try
+        {
+            if (graph.getDirectory().getDefaultType().isStoring())
+            {
                 lockFactory.setLockDir(new File(graphHopperLocation));
                 lock = lockFactory.create(fileLockName, true);
                 if (!lock.tryLock())
                     throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
             }
 
-            try {
+            try
+            {
                 importData();
                 graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
-            } catch (IOException ex) {
+            } catch (IOException ex)
+            {
                 throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
             }
             cleanUp();
             optimize();
             postProcessing();
             flush();
-        } finally {
+        } finally
+        {
             if (lock != null)
                 lock.release();
         }
         return this;
     }
 
-    protected DataReader importData() throws IOException {
+    protected DataReader importData() throws IOException
+    {
         ensureWriteAccess();
         if (graph == null)
             throw new IllegalStateException("Load graph before importing OSM data");
 
         if (osmFile == null)
-            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation + " but also cannot import from OSM file as it wasn't specified!");
+            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
+                    + " but also cannot import from OSM file as it wasn't specified!");
 
         encodingManager.setEnableInstructions(enableInstructions);
         DataReader reader = createReader(graph);
@@ -719,40 +692,52 @@ protected DataReader initReader(DataReader reader) {
 
         logger.info("start creating graph from " + osmFile);
         File osmTmpFile = new File(osmFile);
-        return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider).setWorkerThreads(workerThreads).setEncodingManager(encodingManager).setWayPointMaxDistance(osmReaderWayPointMaxDistance);
+        return reader.setOSMFile(osmTmpFile).
+                setElevationProvider(eleProvider).
+                setWorkerThreads(workerThreads).
+                setEncodingManager(encodingManager).
+                setWayPointMaxDistance(osmReaderWayPointMaxDistance);
     }
 
     /**
      * Opens existing graph.
      * <p/>
-     *
-     * @param graphHopperFolder
-     *            is the folder containing graphhopper files (which can be
-     *            compressed too)
+     * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
+     * too)
      */
     @Override
-    public boolean load(String graphHopperFolder) {
+    public boolean load( String graphHopperFolder )
+    {
         if (Helper.isEmpty(graphHopperFolder))
             throw new IllegalStateException("graphHopperLocation is not specified. call init before");
 
         if (fullyLoaded)
             throw new IllegalStateException("graph is already successfully loaded");
 
-        if (graphHopperFolder.endsWith("-gh")) {
-            // do nothing
+        if (graphHopperFolder.endsWith("-gh"))
+        {
+            // do nothing  
         } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
+        {
             throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-        else if (!graphHopperFolder.contains(".")) {
+        } else if (!graphHopperFolder.contains("."))
+        {
             if (new File(graphHopperFolder + "-gh").exists())
                 graphHopperFolder += "-gh";
-        } else {
+        } else
+        {
             File compressed = new File(graphHopperFolder + ".ghz");
             if (compressed.exists() && !compressed.isDirectory())
-                try {
+            {
+                try
+                {
                     new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
-                } catch (IOException ex) {
-                    throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath() + " to " + graphHopperFolder, ex);
+                } catch (IOException ex)
+                {
+                    throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath()
+                            + " to " + graphHopperFolder, ex);
                 }
+            }
         }
 
         setGraphHopperLocation(graphHopperFolder);
@@ -760,8 +745,6 @@ else if (!graphHopperFolder.contains(".")) {
         if (encodingManager == null)
             setEncodingManager(EncodingManager.create(ghLocation));
 
-        initDefaultVehicleIfNecessary();
-
         if (!allowWrites && dataAccessType.isMMap())
             dataAccessType = DAType.MMAP_RO;
 
@@ -776,11 +759,12 @@ else if (encodingManager.needsTurnCostsSupport())
         graph.setSegmentSize(defaultSegmentSize);
 
         Lock lock = null;
-        try {
-            // create locks only if writes are allowed, if they are not allowed
-            // a lock cannot be created
+        try
+        {
+            // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
             // (e.g. on a read only filesystem locks would fail)
-            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
+            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+            {
                 lockFactory.setLockDir(new File(ghLocation));
                 lock = lockFactory.create(fileLockName, false);
                 if (!lock.tryLock())
@@ -793,27 +777,31 @@ else if (encodingManager.needsTurnCostsSupport())
             postProcessing();
             fullyLoaded = true;
             return true;
-        } finally {
+        } finally
+        {
             if (lock != null)
                 lock.release();
         }
     }
 
-    public RoutingAlgorithmFactory getAlgorithmFactory() {
+    public RoutingAlgorithmFactory getAlgorithmFactory()
+    {
         if (algoFactory == null)
             this.algoFactory = new RoutingAlgorithmFactorySimple();
 
         return algoFactory;
     }
 
-    public void setAlgorithmFactory(RoutingAlgorithmFactory algoFactory) {
+    public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
+    {
         this.algoFactory = algoFactory;
     }
 
     /**
      * Sets EncodingManager, does the preparation and creates the locationIndex
      */
-    protected void postProcessing() {
+    protected void postProcessing()
+    {
         initLocationIndex();
         if (chEnabled)
             algoFactory = createPrepare();
@@ -821,69 +809,73 @@ protected void postProcessing() {
             algoFactory = new RoutingAlgorithmFactorySimple();
 
         if (!isPrepared())
-            prepare();
+            prepare();        
     }
 
-    private boolean isPrepared() {
+    private boolean isPrepared()
+    {
         return "true".equals(graph.getProperties().get("prepare.done"));
     }
 
-    protected RoutingAlgorithmFactory createPrepare() {
-
-        if (!encodingManager.supports(getDefaultVehicle())) {
-            throw new IllegalStateException("Should not happen: default vehicle " + getDefaultVehicle() + " not supported" + " from EncodingManager " + encodingManager.toDetailsString() + ". Cannot do CH preparation");
-        }
-
-        FlagEncoder defaultVehicle = encodingManager.getEncoder(getDefaultVehicle());
+    protected RoutingAlgorithmFactory createPrepare()
+    {
+        FlagEncoder defaultVehicle = getDefaultVehicle();
         Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph, defaultVehicle, weighting, traversalMode);
-        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates).setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
+        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
+                (LevelGraph) graph, defaultVehicle, weighting, traversalMode);
+        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
+                setLazyUpdates(lazyUpdates).
+                setNeighborUpdates(neighborUpdates).
+                setLogMessages(logMessages);
 
         return tmpPrepareCH;
     }
 
     /**
-     * Based on the weightingParameters and the specified vehicle a Weighting
-     * instance can be created. Note that all URL parameters are available in
-     * the weightingParameters as String if you use the GraphHopper Web module.
+     * Based on the weightingParameters and the specified vehicle a Weighting instance can be
+     * created. Note that all URL parameters are available in the weightingParameters as String if
+     * you use the GraphHopper Web module.
      * <p>
-     *
-     * @see Weighting.Params.create
-     * @param wMap
-     *            all parameters influencing the weighting. E.g. URL parameters
-     *            coming via GHRequest
-     * @param encoder
-     *            the required vehicle
+     * @see WeightingMap
+     * @param weightingMap all parameters influencing the weighting. E.g. parameters coming via
+     * GHRequest.getHints or directly via "&api.xy=" from the URL of the web UI
+     * @param encoder the required vehicle
      * @return the weighting to be used for route calculation
      */
-    public Weighting createWeighting(WeightingMap wMap, FlagEncoder encoder) {
-        String weighting = wMap.getWeighting();
+    public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
+    {
+        String weighting = weightingMap.getWeighting();
         Weighting result;
 
         if ("shortest".equalsIgnoreCase(weighting))
+        {
             result = new ShortestWeighting();
-        else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty()) {
+        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
+        {
             if (encoder.supports(PriorityWeighting.class))
                 result = new PriorityWeighting(encoder);
             else
                 result = new FastestWeighting(encoder);
         } else
+        {
             throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+        }
         return result;
     }
 
     /**
      * Potentially wraps the specified weighting into a TurnWeighting instance.
      */
-    public Weighting createTurnWeighting(Weighting weighting, Graph graph, FlagEncoder encoder) {
-        if (encoder.supports(TurnWeighting.class)) {
+    public Weighting createTurnWeighting( Weighting weighting, Graph graph, FlagEncoder encoder )
+    {
+        if (encoder.supports(TurnWeighting.class))
             return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
-        }
         return weighting;
     }
 
     @Override
-    public GHResponse route(GHRequest request) {
+    public GHResponse route( GHRequest request )
+    {
         GHResponse response = new GHResponse();
         List<Path> paths = getPaths(request, response);
         if (response.hasErrors())
@@ -895,11 +887,17 @@ public GHResponse route(GHRequest request) {
         Locale locale = request.getLocale();
         DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
 
-        new PathMerger().setCalcPoints(tmpCalcPoints).setDouglasPeucker(peucker).setEnableInstructions(tmpEnableInstructions).setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).doWork(response, paths, trMap.getWithFallBack(locale));
+        new PathMerger().
+                setCalcPoints(tmpCalcPoints).
+                setDouglasPeucker(peucker).
+                setEnableInstructions(tmpEnableInstructions).
+                setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).
+                doWork(response, paths, trMap.getWithFallBack(locale));
         return response;
     }
 
-    protected List<Path> getPaths(GHRequest request, GHResponse rsp) {
+    protected List<Path> getPaths( GHRequest request, GHResponse rsp )
+    {
         if (graph == null || !fullyLoaded)
             throw new IllegalStateException("Call load or importOrLoad before routing");
 
@@ -908,24 +906,29 @@ public GHResponse route(GHRequest request) {
 
         String vehicle = request.getVehicle();
         if (vehicle.isEmpty())
-            vehicle = getDefaultVehicle();
+            vehicle = getDefaultVehicle().toString();
 
-        if (!encodingManager.supports(vehicle)) {
-            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. " + "Supported are: " + getEncodingManager()));
+        if (!encodingManager.supports(vehicle))
+        {
+            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
+                    + "Supported are: " + getEncodingManager()));
             return Collections.emptyList();
         }
 
         TraversalMode tMode;
         String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
-        try {
+        try
+        {
             tMode = TraversalMode.fromString(tModeStr);
-        } catch (Exception ex) {
+        } catch (Exception ex)
+        {
             rsp.addError(ex);
             return Collections.emptyList();
         }
 
         List<GHPoint> points = request.getPoints();
-        if (points.size() < 2) {
+        if (points.size() < 2)
+        {
             rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
             return Collections.emptyList();
         }
@@ -937,7 +940,8 @@ public GHResponse route(GHRequest request) {
 
         StopWatch sw = new StopWatch().start();
         List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
-        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
+        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++)
+        {
             GHPoint point = points.get(placeIndex);
             QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
             if (!res.isValid())
@@ -953,11 +957,13 @@ public GHResponse route(GHRequest request) {
 
         QueryGraph queryGraph;
         RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
-        if (chEnabled && !vehicle.equals(getDefaultVehicle())) {
+        if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString()))
+        {
             // fall back to normal traversing
             tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
             queryGraph = new QueryGraph(graph.getBaseGraph());
-        } else {
+        } else
+        {
             queryGraph = new QueryGraph(graph);
         }
 
@@ -970,9 +976,12 @@ public GHResponse route(GHRequest request) {
 
         double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
         String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).build();
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().
+                algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+                build();
 
-        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++) {
+        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
+        {
             QueryResult toQResult = qResults.get(placeIndex);
             sw = new StopWatch().start();
             RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
@@ -1001,11 +1010,13 @@ public GHResponse route(GHRequest request) {
         return paths;
     }
 
-    protected LocationIndex createLocationIndex(Directory dir) {
+    protected LocationIndex createLocationIndex( Directory dir )
+    {
         LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
         tmpIndex.setResolution(preciseIndexResolution);
         tmpIndex.setMaxRegionSearch(maxRegionSearch);
-        if (!tmpIndex.loadExisting()) {
+        if (!tmpIndex.loadExisting())
+        {
             ensureWriteAccess();
             tmpIndex.prepareIndex();
         }
@@ -1016,22 +1027,24 @@ protected LocationIndex createLocationIndex(Directory dir) {
     /**
      * Initializes the location index after the import is done.
      */
-    protected void initLocationIndex() {
+    protected void initLocationIndex()
+    {
         if (locationIndex != null)
             throw new IllegalStateException("Cannot initialize locationIndex twice!");
 
         locationIndex = createLocationIndex(graph.getDirectory());
     }
 
-    protected void optimize() {
+    protected void optimize()
+    {
         logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
         graph.optimize();
         logger.info("finished optimize (" + Helper.getMemInfo() + ")");
 
         // Later: move this into the GraphStorage.optimize method
-        // Or: Doing it after preparation to optimize shortcuts too. But not
-        // possible yet #12
-        if (sortGraph) {
+        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
+        if (sortGraph)
+        {
             if (graph instanceof LevelGraph && isPrepared())
                 throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
 
@@ -1042,9 +1055,11 @@ protected void optimize() {
         }
     }
 
-    protected void prepare() {
+    protected void prepare()
+    {
         boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
-        if (tmpPrepare) {
+        if (tmpPrepare)
+        {
             ensureWriteAccess();
             logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
             ((PrepareContractionHierarchies) algoFactory).doWork();
@@ -1053,7 +1068,8 @@ protected void prepare() {
         graph.getProperties().put("prepare.done", tmpPrepare);
     }
 
-    protected void cleanUp() {
+    protected void cleanUp()
+    {
         int prev = graph.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
@@ -1063,40 +1079,44 @@ protected void cleanUp() {
         int n = graph.getNodes();
         // calculate remaining subnetworks
         int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were " + preparation.getSubNetworks() + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
+                + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
     }
 
-    protected void flush() {
+    protected void flush()
+    {
         logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
         graph.flush();
         fullyLoaded = true;
     }
 
     /**
-     * Releases all associated resources like memory or files. But it does not
-     * remove them. To remove the files created in graphhopperLocation you have
-     * to call clean().
+     * Releases all associated resources like memory or files. But it does not remove them. To
+     * remove the files created in graphhopperLocation you have to call clean().
      */
-    public void close() {
+    public void close()
+    {
         if (graph != null)
             graph.close();
 
         if (locationIndex != null)
             locationIndex.close();
 
-        try {
+        try
+        {
             lockFactory.forceRemove(fileLockName, true);
-        } catch (Exception ex) {
-            // silently fail e.g. on Windows where we cannot remove an
-            // unreleased native lock
+        } catch (Exception ex)
+        {
+            // silently fail e.g. on Windows where we cannot remove an unreleased native lock
         }
     }
 
     /**
-     * Removes the on-disc routing files. Call only after calling close or
-     * before importOrLoad or load
+     * Removes the on-disc routing files. Call only after calling close or before importOrLoad or
+     * load
      */
-    public void clean() {
+    public void clean()
+    {
         if (getGraphHopperLocation().isEmpty())
             throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
 
@@ -1106,25 +1126,29 @@ public void clean() {
 
     // make sure this is identical to buildDate used in pom.xml
     // <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
-    private String formatDateTime(Date date) {
+    private String formatDateTime( Date date )
+    {
         return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
     }
 
-    protected void ensureNotLoaded() {
+    protected void ensureNotLoaded()
+    {
         if (fullyLoaded)
             throw new IllegalStateException("No configuration changes are possible after loading the graph");
     }
 
-    protected void ensureWriteAccess() {
+    protected void ensureWriteAccess()
+    {
         if (!allowWrites)
             throw new IllegalStateException("Writes are not allowed!");
     }
 
     /**
-     * Returns the current sum of the visited nodes while routing. Mainly for
-     * statistic and debugging purposes.
+     * Returns the current sum of the visited nodes while routing. Mainly for statistic and
+     * debugging purposes.
      */
-    public long getVisitedSum() {
+    public long getVisitedSum()
+    {
         return visitedSum.get();
     }
 
@@ -1142,12 +1166,4 @@ public GraphHopper setAsDpnReader() {
         dataReader = "OSDPN";
         return this;
     }
-
-    private void initDefaultVehicleIfNecessary() {
-        if (defaultVehicleStr == null)
-            setDefaultVehicle(getFirstVehicle().toString());
-
-        if (!encodingManager.supports(getDefaultVehicle()))
-            throw new IllegalArgumentException("Default vehicle " + defaultVehicleStr + " is not supported. " + "Include vehicle in EncodingManager or via the property graph.flagEncoders OR set it explicitely via setDefaultVehicle");
-    }
 }
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index f71ff9e8c2..8f078d918d 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -336,31 +336,36 @@ public void testFailsForWrongConfig() throws IOException
         assertEquals(5, instance.getGraph().getNodes());
         instance.close();
 
-        instance = new GraphHopper().init(
-                new CmdArgs().
-                put("osmreader.osm", testOsm3).
-                put("osmreader.dataaccess", "RAM").
-                put("graph.flagEncoders", "FOOT").
-                put("prepare.chWeighting", "no")).
-                setOSMFile(testOsm3);
+        // different config (flagEncoder list)
         try
         {
-            instance.load(ghLoc);
+            GraphHopper tmpGH = new GraphHopper().init(
+                    new CmdArgs().
+                    put("osmreader.osm", testOsm3).
+                    put("osmreader.dataaccess", "RAM").
+                    put("graph.flagEncoders", "FOOT").
+                    put("prepare.chWeighting", "no")).
+                    setOSMFile(testOsm3);
+            tmpGH.load(ghLoc);
             assertTrue(false);
         } catch (Exception ex)
         {
         }
 
-        // different order should be ok
-        instance = new GraphHopper().init(
-                new CmdArgs().
-                put("osmreader.osm", testOsm3).
-                put("osmreader.dataaccess", "RAM").
-                put("prepare.chWeighting", "no").
-                put("graph.flagEncoders", "CAR,FOOT")).
-                setOSMFile(testOsm3);
-        assertTrue(instance.load(ghLoc));
-        assertEquals(5, instance.getGraph().getNodes());
+        // different order is no longer okay, see #350
+        try
+        {
+            GraphHopper tmpGH = new GraphHopper().init(new CmdArgs().
+                    put("osmreader.osm", testOsm3).
+                    put("osmreader.dataaccess", "RAM").
+                    put("prepare.chWeighting", "no").
+                    put("graph.flagEncoders", "CAR,FOOT")).
+                    setOSMFile(testOsm3);
+            tmpGH.load(ghLoc);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
     }
 
     @Test
