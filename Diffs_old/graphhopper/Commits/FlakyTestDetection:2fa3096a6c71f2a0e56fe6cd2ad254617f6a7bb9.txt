diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
new file mode 100644
index 0000000000..d10cefbf83
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
@@ -0,0 +1,442 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.DijkstraOneToMany;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.*;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+class NodeContractor {
+    private final GraphHopperStorage ghStorage;
+    private final CHGraph prepareGraph;
+    private final PreparationWeighting prepareWeighting;
+    // todo: so far node contraction can only be done for node-based graph traversal
+    private final TraversalMode traversalMode;
+    private final DataAccess originalEdges;
+    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<>();
+    private final AddShortcutHandler addScHandler = new AddShortcutHandler();
+    private final CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
+    private CHEdgeExplorer vehicleInExplorer;
+    private CHEdgeExplorer vehicleOutExplorer;
+    private IgnoreNodeFilter ignoreNodeFilter;
+    private DijkstraOneToMany prepareAlgo;
+    private int addedShortcutsCount;
+    private long dijkstraCount;
+    private int maxVisitedNodes = Integer.MAX_VALUE;
+    private StopWatch dijkstraSW = new StopWatch();
+    private int maxEdgesCount;
+    private int maxLevel;
+
+    NodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting,
+                   TraversalMode traversalMode) {
+        if (traversalMode.isEdgeBased()) {
+            throw new IllegalArgumentException("Contraction Hierarchies only support node based traversal so far, given: " + traversalMode);
+        }
+        // todo: it would be nice to check if ghStorage is frozen here
+        this.ghStorage = ghStorage;
+        this.prepareGraph = prepareGraph;
+        this.prepareWeighting = new PreparationWeighting(weighting);
+        this.traversalMode = traversalMode;
+        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
+        originalEdges.create(1000);
+    }
+
+    void initFromGraph() {
+        // todo: do we really need this method ? the problem is that ghStorage/prepareGraph can potentially be modified
+        // between the constructor call and contractNode,calcShortcutCount etc. ...
+        maxLevel = prepareGraph.getNodes() + 1;
+        maxEdgesCount = ghStorage.getAllEdges().getMaxId();
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
+        FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
+        vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
+        vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
+        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareWeighting, traversalMode);
+    }
+
+    void close() {
+        prepareAlgo.close();
+        originalEdges.close();
+    }
+
+    void setMaxVisitedNodes(int maxVisitedNodes) {
+        this.maxVisitedNodes = maxVisitedNodes;
+    }
+
+    long contractNode(int node) {
+        shortcuts.clear();
+        long degree = findShortcuts(addScHandler.setNode(node));
+        addedShortcutsCount += addShortcuts(shortcuts.keySet());
+        return degree;
+    }
+
+    CalcShortcutsResult calcShortcutCount(int node) {
+        findShortcuts(calcScHandler.setNode(node));
+        return calcScHandler.calcShortcutsResult;
+    }
+
+    /**
+     * Searches for shortcuts and calls the given handler on each shortcut that is found. The graph is not directly
+     * changed by this method.
+     * Returns the 'degree' of the handler's node (disregarding edges from/to already contracted nodes). Note that 
+     * here the degree is not the total number of adjacent edges, but only the number of incoming edges
+     */
+    private long findShortcuts(ShortcutHandler sch) {
+        long degree = 0;
+        EdgeIterator incomingEdges = vehicleInExplorer.setBaseNode(sch.getNode());
+        // collect outgoing nodes (goal-nodes) only once
+        while (incomingEdges.next()) {
+            int fromNode = incomingEdges.getAdjNode();
+            // accept only uncontracted nodes
+            if (prepareGraph.getLevel(fromNode) != maxLevel)
+                continue;
+
+            final double incomingEdgeDistance = incomingEdges.getDistance();
+            double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
+            int incomingEdge = incomingEdges.getEdge();
+            int incomingEdgeOrigCount = getOrigEdgeCount(incomingEdge);
+            // collect outgoing nodes (goal-nodes) only once
+            EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
+            // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
+            prepareAlgo.clear();
+            degree++;
+            while (outgoingEdges.next()) {
+                int toNode = outgoingEdges.getAdjNode();
+                // add only uncontracted nodes
+                if (prepareGraph.getLevel(toNode) != maxLevel || fromNode == toNode)
+                    continue;
+
+                // Limit weight as ferries or forbidden edges can increase local search too much.
+                // If we decrease the correct weight we only explore less and introduce more shortcuts.
+                // I.e. no change to accuracy is made.
+                double existingDirectWeight = incomingEdgeWeight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
+                if (Double.isNaN(existingDirectWeight))
+                    throw new IllegalStateException("Weighting should never return NaN values"
+                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
+                            + ", dist:" + outgoingEdges.getDistance());
+
+                if (Double.isInfinite(existingDirectWeight))
+                    continue;
+
+                final double existingDistSum = incomingEdgeDistance + outgoingEdges.getDistance();
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setMaxVisitedNodes(maxVisitedNodes);
+                prepareAlgo.setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
+
+                dijkstraSW.start();
+                dijkstraCount++;
+                int endNode = prepareAlgo.findEndNode(fromNode, toNode);
+                dijkstraSW.stop();
+
+                // compare end node as the limit could force dijkstra to finish earlier
+                if (endNode == toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
+                    // FOUND witness path, so do not add shortcut
+                    continue;
+
+                sch.foundShortcut(fromNode, toNode,
+                        existingDirectWeight, existingDistSum,
+                        outgoingEdges.getEdge(), getOrigEdgeCount(outgoingEdges.getEdge()),
+                        incomingEdge, incomingEdgeOrigCount);
+            }
+        }
+        return degree;
+    }
+
+    /**
+     * Adds the given shortcuts to the graph.
+     *
+     * @return the actual number of shortcuts that were added to the graph
+     */
+    private int addShortcuts(Collection<Shortcut> shortcuts) {
+        int tmpNewShortcuts = 0;
+        NEXT_SC:
+        for (Shortcut sc : shortcuts) {
+            boolean updatedInGraph = false;
+            // check if we need to update some existing shortcut in the graph
+            CHEdgeIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
+            while (iter.next()) {
+                if (iter.isShortcut() && iter.getAdjNode() == sc.to) {
+                    int status = iter.getMergeStatus(sc.flags);
+                    if (status == 0)
+                        continue;
+
+                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE)) {
+                        // special case if a bidirectional shortcut has worse weight and still has to be added as otherwise the opposite direction would be missing
+                        // see testShortcutMergeBug
+                        if (status == 2)
+                            break;
+
+                        continue NEXT_SC;
+                    }
+
+                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2) {
+                        throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
+                                + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
+                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
+                                + ", sc:" + sc
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
+                                + ", neighbors:" + GHUtility.getNeighbors(iter));
+                    }
+
+                    // note: flags overwrite weight => call first
+                    iter.setFlags(sc.flags);
+                    iter.setWeight(sc.weight);
+                    iter.setDistance(sc.dist);
+                    iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
+                    setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
+                    updatedInGraph = true;
+                    break;
+                }
+            }
+
+            if (!updatedInGraph) {
+                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
+                // note: flags overwrite weight => call first
+                edgeState.setFlags(sc.flags);
+                edgeState.setWeight(sc.weight);
+                edgeState.setDistance(sc.dist);
+                edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
+                setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
+                tmpNewShortcuts++;
+            }
+        }
+        return tmpNewShortcuts;
+    }
+
+    private String getCoords(EdgeIteratorState edge, Graph graph) {
+        NodeAccess na = graph.getNodeAccess();
+        int base = edge.getBaseNode();
+        int adj = edge.getAdjNode();
+        return base + "->" + adj + " (" + edge.getEdge() + "); "
+                + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
+    }
+
+    int getAddedShortcutsCount() {
+        return addedShortcutsCount;
+    }
+
+    private void setOrigEdgeCount(int edgeId, int value) {
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0) {
+            // ignore setting as every normal edge has original edge count of 1
+            if (value != 1)
+                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
+                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" +
+                        prepareGraph.getAllEdges().getMaxId());
+            return;
+        }
+
+        long tmp = (long) edgeId * 4;
+        originalEdges.ensureCapacity(tmp + 4);
+        originalEdges.setInt(tmp, value);
+    }
+
+    private int getOrigEdgeCount(int edgeId) {
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0)
+            return 1;
+
+        long tmp = (long) edgeId * 4;
+        originalEdges.ensureCapacity(tmp + 4);
+        return originalEdges.getInt(tmp);
+    }
+
+    String getPrepareAlgoMemoryUsage() {
+        return prepareAlgo.getMemoryUsageAsString();
+    }
+
+    long getDijkstraCount() {
+        return dijkstraCount;
+    }
+
+    void resetDijkstraTime() {
+        dijkstraSW = new StopWatch();
+    }
+
+    float getDijkstraSeconds() {
+        return dijkstraSW.getSeconds();
+    }
+
+    static class IgnoreNodeFilter implements EdgeFilter {
+        int avoidNode;
+        int maxLevel;
+        CHGraph graph;
+
+        IgnoreNodeFilter(CHGraph chGraph, int maxLevel) {
+            this.graph = chGraph;
+            this.maxLevel = maxLevel;
+        }
+
+        IgnoreNodeFilter setAvoidNode(int node) {
+            this.avoidNode = node;
+            return this;
+        }
+
+        @Override
+        public final boolean accept(EdgeIteratorState iter) {
+            // ignore if it is skipNode or adjNode is already contracted
+            int node = iter.getAdjNode();
+            return avoidNode != node && graph.getLevel(node) == maxLevel;
+        }
+    }
+
+    static class Shortcut {
+        int from;
+        int to;
+        int skippedEdge1;
+        int skippedEdge2;
+        double dist;
+        double weight;
+        int originalEdges;
+        long flags = PrepareEncoder.getScFwdDir();
+
+        public Shortcut(int from, int to, double weight, double dist) {
+            this.from = from;
+            this.to = to;
+            this.weight = weight;
+            this.dist = dist;
+        }
+
+        @Override
+        public int hashCode() {
+            int hash = 5;
+            hash = 23 * hash + from;
+            hash = 23 * hash + to;
+            return 23 * hash
+                    + (int) (Double.doubleToLongBits(this.weight) ^ (Double.doubleToLongBits(this.weight) >>> 32));
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == null || getClass() != obj.getClass())
+                return false;
+
+            final Shortcut other = (Shortcut) obj;
+            return this.from == other.from && this.to == other.to &&
+                    Double.doubleToLongBits(this.weight) == Double.doubleToLongBits(other.weight);
+
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            if (flags == PrepareEncoder.getScDirMask())
+                str = from + "<->";
+            else
+                str = from + "->";
+
+            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
+        }
+    }
+
+    interface ShortcutHandler {
+        void foundShortcut(int fromNode, int toNode,
+                           double existingDirectWeight, double distance,
+                           int outgoingEdge, int outgoingEdgeOrigCount,
+                           int incomingEdge, int incomingEdgeOrigCount);
+
+        int getNode();
+    }
+
+    class CalcShortcutHandler implements ShortcutHandler {
+        int node;
+        CalcShortcutsResult calcShortcutsResult = new CalcShortcutsResult();
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public CalcShortcutHandler setNode(int node) {
+            this.node = node;
+            calcShortcutsResult.originalEdgesCount = 0;
+            calcShortcutsResult.shortcutsCount = 0;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int fromNode, int toNode,
+                                  double existingDirectWeight, double distance,
+                                  int outgoingEdge, int outgoingEdgeOrigCount,
+                                  int incomingEdge, int incomingEdgeOrigCount) {
+            calcShortcutsResult.shortcutsCount++;
+            calcShortcutsResult.originalEdgesCount += incomingEdgeOrigCount + outgoingEdgeOrigCount;
+        }
+    }
+
+    class AddShortcutHandler implements ShortcutHandler {
+        int node;
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public AddShortcutHandler setNode(int node) {
+            shortcuts.clear();
+            this.node = node;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int fromNode, int toNode,
+                                  double existingDirectWeight, double existingDistSum,
+                                  int outgoingEdge, int outgoingEdgeOrigCount,
+                                  int incomingEdge, int incomingEdgeOrigCount) {
+            // FOUND shortcut
+            // but be sure that it is the only shortcut in the collection
+            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
+            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
+            // know yet the levels so we need to determine the correct direction or if both directions
+            Shortcut sc = new Shortcut(fromNode, toNode, existingDirectWeight, existingDistSum);
+            if (shortcuts.containsKey(sc))
+                return;
+
+            Shortcut tmpSc = new Shortcut(toNode, fromNode, existingDirectWeight, existingDistSum);
+            Shortcut tmpRetSc = shortcuts.get(tmpSc);
+            // overwrite flags only if skipped edges are identical
+            if (tmpRetSc != null && tmpRetSc.skippedEdge2 == incomingEdge && tmpRetSc.skippedEdge1 == outgoingEdge) {
+                tmpRetSc.flags = PrepareEncoder.getScDirMask();
+                return;
+            }
+
+            Shortcut old = shortcuts.put(sc, sc);
+            if (old != null)
+                throw new IllegalStateException("Shortcut did not exist (" + sc + ") but was overwriting another one? " + old);
+
+            sc.skippedEdge1 = incomingEdge;
+            sc.skippedEdge2 = outgoingEdge;
+            sc.originalEdges = incomingEdgeOrigCount + outgoingEdgeOrigCount;
+        }
+    }
+
+    static class CalcShortcutsResult {
+        int originalEdgesCount;
+        int shortcutsCount;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 2701f7c3bd..1afc3a550f 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -20,7 +20,6 @@
 import com.graphhopper.coll.GHTreeMapComposed;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.routing.weighting.AbstractWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
@@ -36,7 +35,7 @@
  * This class prepares the graph for a bidirectional algorithm supporting contraction hierarchies
  * ie. an algorithm returned by createAlgo.
  * <p>
- * There are several description of contraction hierarchies available. The following is one of the
+ * There are several descriptions of contraction hierarchies available. The following is one of the
  * more detailed: http://web.cs.du.edu/~sturtevant/papers/highlevelpathfinding.pdf
  * <p>
  * The only difference is that we use two skipped edges instead of one skipped node for faster
@@ -47,19 +46,15 @@
  */
 public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory {
     private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Directory dir;
     private final PreparationWeighting prepareWeighting;
+    private final Weighting weighting;
     private final TraversalMode traversalMode;
-    private final LevelEdgeFilter levelFilter;
     private final GraphHopperStorage ghStorage;
     private final CHGraphImpl prepareGraph;
-    private final DataAccess originalEdges;
-    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
     private final Random rand = new Random(123);
     private final StopWatch allSW = new StopWatch();
-    AddShortcutHandler addScHandler = new AddShortcutHandler();
-    CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
-    private CHEdgeExplorer vehicleInExplorer;
-    private CHEdgeExplorer vehicleOutExplorer;
+    private NodeContractor nodeContractor;
     private CHEdgeExplorer vehicleAllExplorer;
     private CHEdgeExplorer vehicleAllTmpExplorer;
     private CHEdgeExplorer calcPrioAllExplorer;
@@ -67,13 +62,7 @@
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
     private int oldPriorities[];
-    private IgnoreNodeFilter ignoreNodeFilter;
-    private DijkstraOneToMany prepareAlgo;
-    private long counter;
-    private int newShortcuts;
-    private long dijkstraCount;
     private double meanDegree;
-    private StopWatch dijkstraSW = new StopWatch();
     private int periodicUpdatesPercentage = 20;
     private int lastNodesLazyUpdatePercentage = 10;
     private int neighborUpdatePercentage = 20;
@@ -83,18 +72,15 @@
     private double periodTime;
     private double lazyTime;
     private double neighborTime;
-    private int maxEdgesCount;
 
     public PrepareContractionHierarchies(Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph,
                                          Weighting weighting, TraversalMode traversalMode) {
+        this.dir = dir;
         this.ghStorage = ghStorage;
         this.prepareGraph = (CHGraphImpl) chGraph;
         this.traversalMode = traversalMode;
-        levelFilter = new LevelEdgeFilter(prepareGraph);
-
+        this.weighting = weighting;
         prepareWeighting = new PreparationWeighting(weighting);
-        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
-        originalEdges.create(1000);
     }
 
     /**
@@ -171,9 +157,6 @@ public PrepareContractionHierarchies setContractedNodes(double nodesContracted)
 
     @Override
     public void doWork() {
-        if (prepareWeighting == null)
-            throw new IllegalStateException("No weight calculation set.");
-
         allSW.start();
         super.doWork();
 
@@ -184,7 +167,57 @@ public void doWork() {
         contractNodes();
     }
 
-    boolean prepareNodes() {
+    @Override
+    public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
+        AbstractBidirAlgo algo;
+        if (ASTAR_BI.equals(opts.getAlgorithm())) {
+            AStarBidirection tmpAlgo = new AStarBidirectionCH(graph, prepareWeighting, traversalMode);
+            tmpAlgo.setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
+            algo = tmpAlgo;
+        } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
+            if (opts.getHints().getBool("stall_on_demand", true)) {
+                algo = new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
+            } else {
+                algo = new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
+            }
+        } else {
+            throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies. Try with ch.disable=true");
+        }
+
+        algo.setMaxVisitedNodes(opts.getMaxVisitedNodes());
+        algo.setEdgeFilter(new LevelEdgeFilter(prepareGraph));
+        return algo;
+    }
+
+    private void initFromGraph() {
+        ghStorage.freeze();
+        FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
+        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
+        // filter by vehicle and level number
+        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph) {
+            @Override
+            public final boolean accept(EdgeIteratorState edgeState) {
+                return super.accept(edgeState) && allFilter.accept(edgeState);
+            }
+        };
+
+        maxLevel = prepareGraph.getNodes() + 1;
+        vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
+
+        // Use an alternative to PriorityQueue as it has some advantages:
+        //   1. Gets automatically smaller if less entries are stored => less total RAM used.
+        //      Important because Graph is increasing until the end.
+        //   2. is slightly faster
+        //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
+        sortedNodes = new GHTreeMapComposed();
+        oldPriorities = new int[prepareGraph.getNodes()];
+        nodeContractor = new NodeContractor(dir, ghStorage, prepareGraph, weighting, traversalMode);
+        nodeContractor.initFromGraph();
+    }
+
+    private boolean prepareNodes() {
         int nodes = prepareGraph.getNodes();
         for (int node = 0; node < nodes; node++) {
             prepareGraph.setLevel(node, maxLevel);
@@ -195,16 +228,19 @@ boolean prepareNodes() {
             sortedNodes.insert(node, priority);
         }
 
-        if (sortedNodes.isEmpty())
-            return false;
-
-        return true;
+        return !sortedNodes.isEmpty();
     }
 
-    void contractNodes() {
+    private void contractNodes() {
+        // meanDegree is the number of edges / number of nodes ratio of the graph, not really the average degree, because
+        // each edge can exist in both directions
+        // todo: initializing meanDegree here instead of in initFromGraph() means that in the first round of calculating
+        // node priorities all shortcut searches are cancelled immediately and all possible shortcuts are counted because
+        // no witness path can be found. this is not really what we want, but changing it requires re-optimizing the
+        // graph contraction parameters, because it affects the node contraction order.
         meanDegree = prepareGraph.getAllEdges().getMaxId() / prepareGraph.getNodes();
         int level = 1;
-        counter = 0;
+        long counter = 0;
         int initSize = sortedNodes.getSize();
         long logSize = Math.round(Math.max(10, sortedNodes.getSize() / 100 * logMessagesPercentage));
         if (logMessagesPercentage == 0)
@@ -256,21 +292,21 @@ void contractNodes() {
             }
 
             if (counter % logSize == 0) {
-                dijkstraTime += dijkstraSW.getSeconds();
+                dijkstraTime += nodeContractor.getDijkstraSeconds();
                 periodTime += periodSW.getSeconds();
                 lazyTime += lazySW.getSeconds();
                 neighborTime += neighborSW.getSeconds();
 
                 logger.info(Helper.nf(counter) + ", updates:" + updateCounter
                         + ", nodes: " + Helper.nf(sortedNodes.getSize())
-                        + ", shortcuts:" + Helper.nf(newShortcuts)
-                        + ", dijkstras:" + Helper.nf(dijkstraCount)
+                        + ", shortcuts:" + Helper.nf(nodeContractor.getAddedShortcutsCount())
+                        + ", dijkstras:" + Helper.nf(nodeContractor.getDijkstraCount())
                         + ", " + getTimesAsString()
                         + ", meanDegree:" + (long) meanDegree
-                        + ", algo:" + prepareAlgo.getMemoryUsageAsString()
+                        + ", algo:" + nodeContractor.getPrepareAlgoMemoryUsage()
                         + ", " + Helper.getMemInfo());
 
-                dijkstraSW = new StopWatch();
+                nodeContractor.resetDijkstraTime();
                 periodSW = new StopWatch();
                 lazySW = new StopWatch();
                 neighborSW = new StopWatch();
@@ -292,9 +328,10 @@ void contractNodes() {
             }
 
             // contract node v!
-            shortcuts.clear();
-            findShortcuts(addScHandler.setNode(polledNode));
-            newShortcuts += addShortcuts(shortcuts.keySet());
+            nodeContractor.setMaxVisitedNodes(getMaxVisitedNodesEstimate());
+            long degree = nodeContractor.contractNode(polledNode);
+            // put weight factor on meanDegree instead of taking the average => meanDegree is more stable
+            meanDegree = (meanDegree * 2 + degree) / 3;
             prepareGraph.setLevel(polledNode, level);
             level++;
 
@@ -305,7 +342,7 @@ void contractNodes() {
             CHEdgeIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next()) {
 
-                if(Thread.currentThread().isInterrupted()){
+                if (Thread.currentThread().isInterrupted()) {
                     throw new RuntimeException("Thread was interrupted");
                 }
 
@@ -331,14 +368,14 @@ void contractNodes() {
         // The preparation object itself has to be intact to create the algorithm.
         close();
 
-        dijkstraTime += dijkstraSW.getSeconds();
+        dijkstraTime += nodeContractor.getDijkstraSeconds();
         periodTime += periodSW.getSeconds();
         lazyTime += lazySW.getSeconds();
         neighborTime += neighborSW.getSeconds();
         logger.info("took:" + (int) allSW.stop().getSeconds()
-                + ", new shortcuts: " + Helper.nf(newShortcuts)
+                + ", new shortcuts: " + Helper.nf(nodeContractor.getAddedShortcutsCount())
                 + ", " + prepareWeighting
-                + ", dijkstras:" + dijkstraCount
+                + ", dijkstras:" + nodeContractor.getDijkstraCount()
                 + ", " + getTimesAsString()
                 + ", meanDegree:" + (long) meanDegree
                 + ", initSize:" + initSize
@@ -348,8 +385,18 @@ void contractNodes() {
                 + ", " + Helper.getMemInfo());
     }
 
+    public void close() {
+        nodeContractor.close();
+        sortedNodes = null;
+        oldPriorities = null;
+    }
+
     public long getDijkstraCount() {
-        return dijkstraCount;
+        return nodeContractor.getDijkstraCount();
+    }
+
+    public int getShortcuts() {
+        return nodeContractor.getAddedShortcutsCount();
     }
 
     public double getLazyTime() {
@@ -372,13 +419,6 @@ public Weighting getWeighting() {
         return prepareGraph.getWeighting();
     }
 
-    public void close() {
-        prepareAlgo.close();
-        originalEdges.close();
-        sortedNodes = null;
-        oldPriorities = null;
-    }
-
     private String getTimesAsString() {
         return "t(dijk):" + Helper.round2(dijkstraTime)
                 + ", t(period):" + Helper.round2(periodTime)
@@ -386,32 +426,23 @@ private String getTimesAsString() {
                 + ", t(neighbor):" + Helper.round2(neighborTime);
     }
 
-    Set<Shortcut> testFindShortcuts(int node) {
-        findShortcuts(addScHandler.setNode(node));
-        return shortcuts.keySet();
-    }
-
     /**
-     * Calculates the priority of adjNode v without changing the graph. Warning: the calculated
-     * priority must NOT depend on priority(v) and therefor findShortcuts should also not depend on
+     * Calculates the priority of a node v without changing the graph. Warning: the calculated
+     * priority must NOT depend on priority(v) and therefore findShortcuts should also not depend on
      * the priority(v). Otherwise updating the priority before contracting in contractNodes() could
      * lead to a slowish or even endless loop.
      */
-    int calculatePriority(int v) {
-        // set of shortcuts that would be added if adjNode v would be contracted next.
-        findShortcuts(calcScHandler.setNode(v));
+    private int calculatePriority(int node) {
+        nodeContractor.setMaxVisitedNodes(getMaxVisitedNodesEstimate());
+        NodeContractor.CalcShortcutsResult calcShortcutsResult = nodeContractor.calcShortcutCount(node);
 
-//        System.out.println(v + "\t " + tmpShortcuts);
         // # huge influence: the bigger the less shortcuts gets created and the faster is the preparation
         //
         // every adjNode has an 'original edge' number associated. initially it is r=1
         // when a new shortcut is introduced then r of the associated edges is summed up:
         // r(u,w)=r(u,v)+r(v,w) now we can define
         // originalEdgesCount = σ(v) := sum_{ (u,w) ∈ shortcuts(v) } of r(u, w)
-        int originalEdgesCount = calcScHandler.originalEdgesCount;
-//        for (Shortcut sc : tmpShortcuts) {
-//            originalEdgesCount += sc.originalEdges;
-//        }
+        int originalEdgesCount = calcShortcutsResult.originalEdgesCount;
 
         // # lowest influence on preparation speed or shortcut creation count
         // (but according to paper should speed up queries)
@@ -419,7 +450,7 @@ int calculatePriority(int v) {
         // number of already contracted neighbors of v
         int contractedNeighbors = 0;
         int degree = 0;
-        CHEdgeIterator iter = calcPrioAllExplorer.setBaseNode(v);
+        CHEdgeIterator iter = calcPrioAllExplorer.setBaseNode(node);
         while (iter.next()) {
             degree++;
             if (iter.isShortcut())
@@ -432,234 +463,17 @@ int calculatePriority(int v) {
         // |shortcuts(v)| − |{(u, v) | v uncontracted}| − |{(v, w) | v uncontracted}|
         // meanDegree is used instead of outDegree+inDegree as if one adjNode is in both directions
         // only one bucket memory is used. Additionally one shortcut could also stand for two directions.
-        int edgeDifference = calcScHandler.shortcuts - degree;
+        int edgeDifference = calcShortcutsResult.shortcutsCount - degree;
 
         // according to the paper do a simple linear combination of the properties to get the priority.
         // this is the current optimum for unterfranken:
         return 10 * edgeDifference + originalEdgesCount + contractedNeighbors;
     }
 
-    /**
-     * Finds shortcuts, does not change the underlying graph.
-     */
-    void findShortcuts(ShortcutHandler sch) {
-        long tmpDegreeCounter = 0;
-        EdgeIterator incomingEdges = vehicleInExplorer.setBaseNode(sch.getNode());
-        // collect outgoing nodes (goal-nodes) only once
-        while (incomingEdges.next()) {
-            int u_fromNode = incomingEdges.getAdjNode();
-            // accept only uncontracted nodes
-            if (prepareGraph.getLevel(u_fromNode) != maxLevel)
-                continue;
-
-            double v_u_dist = incomingEdges.getDistance();
-            double v_u_weight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
-            int skippedEdge1 = incomingEdges.getEdge();
-            int incomingEdgeOrigCount = getOrigEdgeCount(skippedEdge1);
-            // collect outgoing nodes (goal-nodes) only once
-            EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
-            // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
-            prepareAlgo.clear();
-            tmpDegreeCounter++;
-            while (outgoingEdges.next()) {
-                int w_toNode = outgoingEdges.getAdjNode();
-                // add only uncontracted nodes
-                if (prepareGraph.getLevel(w_toNode) != maxLevel || u_fromNode == w_toNode)
-                    continue;
-
-                // Limit weight as ferries or forbidden edges can increase local search too much.
-                // If we decrease the correct weight we only explore less and introduce more shortcuts.
-                // I.e. no change to accuracy is made.
-                double existingDirectWeight = v_u_weight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
-                if (Double.isNaN(existingDirectWeight))
-                    throw new IllegalStateException("Weighting should never return NaN values"
-                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
-                            + ", dist:" + outgoingEdges.getDistance());
-
-                if (Double.isInfinite(existingDirectWeight))
-                    continue;
-
-                double existingDistSum = v_u_dist + outgoingEdges.getDistance();
-                prepareAlgo.setWeightLimit(existingDirectWeight);
-                prepareAlgo.setMaxVisitedNodes((int) meanDegree * 100);
-                prepareAlgo.setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
-
-                dijkstraSW.start();
-                dijkstraCount++;
-                int endNode = prepareAlgo.findEndNode(u_fromNode, w_toNode);
-                dijkstraSW.stop();
-
-                // compare end node as the limit could force dijkstra to finish earlier
-                if (endNode == w_toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
-                    // FOUND witness path, so do not add shortcut
-                    continue;
-
-                sch.foundShortcut(u_fromNode, w_toNode,
-                        existingDirectWeight, existingDistSum,
-                        outgoingEdges,
-                        skippedEdge1, incomingEdgeOrigCount);
-            }
-        }
-        if (sch instanceof AddShortcutHandler) {
-            // sliding mean value when using "*2" => slower changes
-            meanDegree = (meanDegree * 2 + tmpDegreeCounter) / 3;
-            // meanDegree = (meanDegree + tmpDegreeCounter) / 2;
-        }
-    }
-
-    /**
-     * Introduces the necessary shortcuts for adjNode v in the graph.
-     */
-    int addShortcuts(Collection<Shortcut> tmpShortcuts) {
-        int tmpNewShortcuts = 0;
-        NEXT_SC:
-        for (Shortcut sc : tmpShortcuts) {
-            boolean updatedInGraph = false;
-            // check if we need to update some existing shortcut in the graph
-            CHEdgeIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
-            while (iter.next()) {
-                if (iter.isShortcut() && iter.getAdjNode() == sc.to) {
-                    int status = iter.getMergeStatus(sc.flags);
-                    if (status == 0)
-                        continue;
-
-                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE)) {
-                        // special case if a bidirectional shortcut has worse weight and still has to be added as otherwise the opposite direction would be missing
-                        // see testShortcutMergeBug
-                        if (status == 2)
-                            break;
-
-                        continue NEXT_SC;
-                    }
-
-                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2) {
-                        throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
-                                + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
-                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
-                                + ", sc:" + sc
-                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
-                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
-                                + ", neighbors:" + GHUtility.getNeighbors(iter));
-                    }
-
-                    // note: flags overwrite weight => call first
-                    iter.setFlags(sc.flags);
-                    iter.setWeight(sc.weight);
-                    iter.setDistance(sc.dist);
-                    iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                    setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
-                    updatedInGraph = true;
-                    break;
-                }
-            }
-
-            if (!updatedInGraph) {
-                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
-                // note: flags overwrite weight => call first
-                edgeState.setFlags(sc.flags);
-                edgeState.setWeight(sc.weight);
-                edgeState.setDistance(sc.dist);
-                edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
-                tmpNewShortcuts++;
-            }
-        }
-        return tmpNewShortcuts;
-    }
-
-    String getCoords(EdgeIteratorState e, Graph g) {
-        NodeAccess na = g.getNodeAccess();
-        int base = e.getBaseNode();
-        int adj = e.getAdjNode();
-        return base + "->" + adj + " (" + e.getEdge() + "); "
-                + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
-    }
-
-    PrepareContractionHierarchies initFromGraph() {
-        ghStorage.freeze();
-        maxEdgesCount = ghStorage.getAllEdges().getMaxId();
-        FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
-        vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
-        vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
-        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
-
-        // filter by vehicle and level number
-        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph) {
-            @Override
-            public final boolean accept(EdgeIteratorState edgeState) {
-                if (!super.accept(edgeState))
-                    return false;
-
-                return allFilter.accept(edgeState);
-            }
-        };
-
-        maxLevel = prepareGraph.getNodes() + 1;
-        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
-        vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
-        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
-        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
-
-        // Use an alternative to PriorityQueue as it has some advantages:
-        //   1. Gets automatically smaller if less entries are stored => less total RAM used.
-        //      Important because Graph is increasing until the end.
-        //   2. is slightly faster
-        //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
-        sortedNodes = new GHTreeMapComposed();
-        oldPriorities = new int[prepareGraph.getNodes()];
-        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareWeighting, traversalMode);
-        return this;
-    }
-
-    public int getShortcuts() {
-        return newShortcuts;
-    }
-
-    private void setOrigEdgeCount(int edgeId, int value) {
-        edgeId -= maxEdgesCount;
-        if (edgeId < 0) {
-            // ignore setting as every normal edge has original edge count of 1
-            if (value != 1)
-                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
-                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" + ghStorage.getAllEdges().getMaxId());
-            return;
-        }
-
-        long tmp = (long) edgeId * 4;
-        originalEdges.ensureCapacity(tmp + 4);
-        originalEdges.setInt(tmp, value);
-    }
-
-    private int getOrigEdgeCount(int edgeId) {
-        edgeId -= maxEdgesCount;
-        if (edgeId < 0)
-            return 1;
-
-        long tmp = (long) edgeId * 4;
-        originalEdges.ensureCapacity(tmp + 4);
-        return originalEdges.getInt(tmp);
-    }
-
-    @Override
-    public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
-        AbstractBidirAlgo algo;
-        if (ASTAR_BI.equals(opts.getAlgorithm())) {
-            AStarBidirection tmpAlgo = new AStarBidirectionCH(graph, prepareWeighting, traversalMode);
-            tmpAlgo.setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
-            algo = tmpAlgo;
-        } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
-            if (opts.getHints().getBool("stall_on_demand", true)) {
-                algo = new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
-            } else {
-                algo = new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
-            }
-        } else {
-            throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies. Try with ch.disable=true");
-        }
-
-        algo.setMaxVisitedNodes(opts.getMaxVisitedNodes());
-        algo.setEdgeFilter(levelFilter);
-        return algo;
+    private int getMaxVisitedNodesEstimate() {
+        // todo: we return 0 here if meanDegree is < 1, which is not really what we want, but changing this changes
+        // the node contraction order and requires re-optimizing the parameters of the graph contraction
+        return (int) meanDegree * 100;
     }
 
     @Override
@@ -667,163 +481,4 @@ public String toString() {
         return "prepare|dijkstrabi|ch";
     }
 
-    interface ShortcutHandler {
-        void foundShortcut(int u_fromNode, int w_toNode,
-                           double existingDirectWeight, double distance,
-                           EdgeIterator outgoingEdges,
-                           int skippedEdge1, int incomingEdgeOrigCount);
-
-        int getNode();
-    }
-
-    static class IgnoreNodeFilter implements EdgeFilter {
-        int avoidNode;
-        int maxLevel;
-        CHGraph graph;
-
-        public IgnoreNodeFilter(CHGraph g, int maxLevel) {
-            this.graph = g;
-            this.maxLevel = maxLevel;
-        }
-
-        public IgnoreNodeFilter setAvoidNode(int node) {
-            this.avoidNode = node;
-            return this;
-        }
-
-        @Override
-        public final boolean accept(EdgeIteratorState iter) {
-            // ignore if it is skipNode or adjNode is already contracted
-            int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == maxLevel;
-        }
-    }
-
-    static class Shortcut {
-        int from;
-        int to;
-        int skippedEdge1;
-        int skippedEdge2;
-        double dist;
-        double weight;
-        int originalEdges;
-        long flags = PrepareEncoder.getScFwdDir();
-
-        public Shortcut(int from, int to, double weight, double dist) {
-            this.from = from;
-            this.to = to;
-            this.weight = weight;
-            this.dist = dist;
-        }
-
-        @Override
-        public int hashCode() {
-            int hash = 5;
-            hash = 23 * hash + from;
-            hash = 23 * hash + to;
-            return 23 * hash
-                    + (int) (Double.doubleToLongBits(this.weight) ^ (Double.doubleToLongBits(this.weight) >>> 32));
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj == null || getClass() != obj.getClass())
-                return false;
-
-            final Shortcut other = (Shortcut) obj;
-            if (this.from != other.from || this.to != other.to)
-                return false;
-
-            return Double.doubleToLongBits(this.weight) == Double.doubleToLongBits(other.weight);
-        }
-
-        @Override
-        public String toString() {
-            String str;
-            if (flags == PrepareEncoder.getScDirMask())
-                str = from + "<->";
-            else
-                str = from + "->";
-
-            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
-        }
-    }
-
-    class CalcShortcutHandler implements ShortcutHandler {
-        int node;
-        int originalEdgesCount;
-        int shortcuts;
-
-        @Override
-        public int getNode() {
-            return node;
-        }
-
-        public CalcShortcutHandler setNode(int n) {
-            node = n;
-            originalEdgesCount = 0;
-            shortcuts = 0;
-            return this;
-        }
-
-        @Override
-        public void foundShortcut(int u_fromNode, int w_toNode,
-                                  double existingDirectWeight, double distance,
-                                  EdgeIterator outgoingEdges,
-                                  int skippedEdge1, int incomingEdgeOrigCount) {
-            shortcuts++;
-            originalEdgesCount += incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
-        }
-    }
-
-    class AddShortcutHandler implements ShortcutHandler {
-        int node;
-
-        public AddShortcutHandler() {
-        }
-
-        @Override
-        public int getNode() {
-            return node;
-        }
-
-        public AddShortcutHandler setNode(int n) {
-            shortcuts.clear();
-            node = n;
-            return this;
-        }
-
-        @Override
-        public void foundShortcut(int u_fromNode, int w_toNode,
-                                  double existingDirectWeight, double existingDistSum,
-                                  EdgeIterator outgoingEdges,
-                                  int skippedEdge1, int incomingEdgeOrigCount) {
-            // FOUND shortcut
-            // but be sure that it is the only shortcut in the collection
-            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
-            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
-            // know yet the levels so we need to determine the correct direction or if both directions
-            Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
-            if (shortcuts.containsKey(sc))
-                return;
-
-            Shortcut tmpSc = new Shortcut(w_toNode, u_fromNode, existingDirectWeight, existingDistSum);
-            Shortcut tmpRetSc = shortcuts.get(tmpSc);
-            if (tmpRetSc != null) {
-                // overwrite flags only if skipped edges are identical
-                if (tmpRetSc.skippedEdge2 == skippedEdge1 && tmpRetSc.skippedEdge1 == outgoingEdges.getEdge()) {
-                    tmpRetSc.flags = PrepareEncoder.getScDirMask();
-                    return;
-                }
-            }
-
-            Shortcut old = shortcuts.put(sc, sc);
-            if (old != null)
-                throw new IllegalStateException("Shortcut did not exist (" + sc + ") but was overwriting another one? " + old);
-
-            sc.skippedEdge1 = skippedEdge1;
-            sc.skippedEdge2 = outgoingEdges.getEdge();
-            sc.originalEdges = incomingEdgeOrigCount + getOrigEdgeCount(outgoingEdges.getEdge());
-        }
-    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java
new file mode 100644
index 0000000000..c73b25eebe
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java
@@ -0,0 +1,395 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.DijkstraOneToMany;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Objects;
+import java.util.Set;
+
+import static org.junit.Assert.*;
+
+public class NodeContractorTest {
+    private final CarFlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager encodingManager = new EncodingManager(encoder);
+    private final Weighting weighting = new ShortestWeighting(encoder);
+    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
+    private final CHGraph lg = graph.getGraph(CHGraph.class);
+    private final TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private Directory dir;
+
+    @Before
+    public void setUp() {
+        dir = new GHDirectory("", DAType.RAM_INT);
+    }
+
+    private NodeContractor createNodeContractor() {
+        NodeContractor nodeContractor = new NodeContractor(dir, graph, lg, weighting, traversalMode);
+        nodeContractor.initFromGraph();
+        return nodeContractor;
+    }
+
+    private void createExampleGraph() {
+        //5-1-----2
+        //   \ __/|
+        //    0   |
+        //   /    |
+        //  4-----3
+        //
+        graph.edge(0, 1, 1, true);
+        graph.edge(0, 2, 1, true);
+        graph.edge(0, 4, 3, true);
+        graph.edge(1, 2, 3, true);
+        graph.edge(2, 3, 1, true);
+        graph.edge(4, 3, 2, true);
+        graph.edge(5, 1, 2, true);
+        graph.freeze();
+    }
+
+    @Test
+    public void testShortestPathSkipNode() {
+        createExampleGraph();
+        final double normalDist = new Dijkstra(graph, weighting, traversalMode).calcPath(4, 2).getDistance();
+        DijkstraOneToMany algo = new DijkstraOneToMany(graph, weighting, traversalMode);
+        CHGraph lg = graph.getGraph(CHGraph.class);
+
+        setMaxLevelOnAllNodes();
+
+        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(100);
+        int nodeEntry = algo.findEndNode(4, 2);
+        assertTrue(algo.getWeight(nodeEntry) > normalDist);
+
+        algo.clear();
+        algo.setMaxVisitedNodes(1);
+        nodeEntry = algo.findEndNode(4, 2);
+        assertEquals(-1, nodeEntry);
+    }
+
+    @Test
+    public void testShortestPathSkipNode2() {
+        createExampleGraph();
+        final double normalDist = new Dijkstra(graph, weighting, traversalMode).calcPath(4, 2).getDistance();
+        assertEquals(3, normalDist, 1e-5);
+        DijkstraOneToMany algo = new DijkstraOneToMany(graph, weighting, traversalMode);
+
+        setMaxLevelOnAllNodes();
+
+        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(10);
+        int nodeEntry = algo.findEndNode(4, 2);
+        assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
+
+        nodeEntry = algo.findEndNode(4, 1);
+        assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
+    }
+
+    @Test
+    public void testShortestPathLimit() {
+        createExampleGraph();
+        DijkstraOneToMany algo = new DijkstraOneToMany(graph, weighting, traversalMode);
+
+        setMaxLevelOnAllNodes();
+
+        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes() + 1).setAvoidNode(0));
+        algo.setWeightLimit(2);
+        int endNode = algo.findEndNode(4, 1);
+        // did not reach endNode
+        assertNotEquals(1, endNode);
+    }
+
+    @Test
+    public void testDirectedGraph() {
+        //5 6 7
+        // \|/
+        //4-3_1<-\ 10
+        //     \_|/
+        //   0___2_11
+
+        graph.edge(0, 2, 2, true);
+        graph.edge(10, 2, 2, true);
+        graph.edge(11, 2, 2, true);
+        // create a longer one directional edge => no longish one-dir shortcut should be created
+        final EdgeIteratorState edge2to1bidirected = graph.edge(2, 1, 2, true);
+        final EdgeIteratorState edge2to1directed = graph.edge(2, 1, 10, false);
+        final EdgeIteratorState edge1to3 = graph.edge(1, 3, 2, true);
+        graph.edge(3, 4, 2, true);
+        graph.edge(3, 5, 2, true);
+        graph.edge(3, 6, 2, true);
+        graph.edge(3, 7, 2, true);
+        graph.freeze();
+
+        setMaxLevelOnAllNodes();
+
+        // find all shortcuts if we contract node 1
+        NodeContractor nodeContractor = createNodeContractor();
+        nodeContractor.contractNode(1);
+        checkShortcuts(
+                expectedShortcut(2, 3, edge1to3, edge2to1bidirected, true, true),
+                expectedShortcut(2, 3, edge2to1directed, edge1to3, true, false)
+        );
+    }
+
+    @Test
+    public void testFindShortcuts_Roundabout() {
+        // 1 -- 3 -- 4 ---> 5 ---> 6 -- 7
+        //            \           /
+        //             <--- 8 <--- 
+        final EdgeIteratorState iter1to3 = graph.edge(1, 3, 1, true);
+        final EdgeIteratorState iter3to4 = graph.edge(3, 4, 1, true);
+        final EdgeIteratorState iter4to5 = graph.edge(4, 5, 1, false);
+        final EdgeIteratorState iter5to6 = graph.edge(5, 6, 1, false);
+        final EdgeIteratorState iter6to8 = graph.edge(6, 8, 2, false);
+        final EdgeIteratorState iter8to4 = graph.edge(8, 4, 1, false);
+        graph.edge(6, 7, 1, true);
+        graph.freeze();
+
+        CHEdgeIteratorState sc1to4 = lg.shortcut(1, 4);
+        sc1to4.setFlags(PrepareEncoder.getScDirMask());
+        sc1to4.setWeight(2);
+        sc1to4.setDistance(2);
+        sc1to4.setSkippedEdges(iter1to3.getEdge(), iter3to4.getEdge());
+
+        long f = PrepareEncoder.getScFwdDir();
+        CHEdgeIteratorState sc4to6 = lg.shortcut(4, 6);
+        sc4to6.setFlags(f);
+        sc4to6.setWeight(2);
+        sc4to6.setDistance(2);
+        sc4to6.setSkippedEdges(iter4to5.getEdge(), iter5to6.getEdge());
+
+        CHEdgeIteratorState sc6to4 = lg.shortcut(6, 4);
+        sc6to4.setFlags(f);
+        sc6to4.setWeight(3);
+        sc6to4.setDistance(3);
+        sc6to4.setSkippedEdges(iter6to8.getEdge(), iter8to4.getEdge());
+
+        setMaxLevelOnAllNodes();
+
+        lg.setLevel(3, 3);
+        lg.setLevel(5, 5);
+        lg.setLevel(7, 7);
+        lg.setLevel(8, 8);
+
+        Shortcut manualSc1 = expectedShortcut(1, 4, iter1to3, iter3to4, true, true);
+        Shortcut manualSc2 = expectedShortcut(4, 6, iter4to5, iter5to6, true, false);
+        Shortcut manualSc3 = expectedShortcut(4, 6, iter6to8, iter8to4, false, true);
+        checkShortcuts(manualSc1, manualSc2, manualSc3);
+
+        // after 'manual contraction' of nodes 3, 5, 8 the graph looks like:
+        // 1 -- 4 -->-- 6 -- 7
+        //       \      |
+        //        --<----
+
+        // contract node 4!
+        NodeContractor nodeContractor = createNodeContractor();
+        nodeContractor.contractNode(4);
+        checkShortcuts(manualSc1, manualSc2, manualSc3,
+                // there should be two different shortcuts for both directions!
+                expectedShortcut(1, 6, sc1to4, sc4to6, true, false),
+                expectedShortcut(1, 6, sc6to4, sc1to4, false, true)
+        );
+    }
+
+
+    @Test
+    public void testShortcutMergeBug() {
+        // We refer to this real world situation http://www.openstreetmap.org/#map=19/52.71205/-1.77326
+        // assume the following graph:
+        //
+        // ---1---->----2-----3
+        //    \--------/
+        //
+        // where there are two roads from 1 to 2 and the directed road has a smaller weight
+        // leading to two shortcuts sc1 (unidir) and sc2 (bidir) where the second should NOT be rejected due to the larger weight
+        final EdgeIteratorState edge1to2bidirected = graph.edge(1, 2, 1, true);
+        final EdgeIteratorState edge1to2directed = graph.edge(1, 2, 1, false);
+        final EdgeIteratorState edge2to3 = graph.edge(2, 3, 1, true);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        NodeContractor nodeContractor = createNodeContractor();
+        nodeContractor.contractNode(2);
+        checkShortcuts(
+                expectedShortcut(1, 3, edge2to3, edge1to2bidirected, false, true),
+                expectedShortcut(1, 3, edge1to2directed, edge2to3, true, false)
+        );
+    }
+
+    @Test
+    public void testContractNode_directed_shortcutRequired() {
+        // 0 --> 1 --> 2
+        final EdgeIteratorState edge1 = graph.edge(0, 1, 1, false);
+        final EdgeIteratorState edge2 = graph.edge(1, 2, 2, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        createNodeContractor().contractNode(1);
+        checkShortcuts(expectedShortcut(0, 2, edge1, edge2, true, false));
+    }
+
+    @Test
+    public void testContractNode_directed_shortcutRequired_reverse() {
+        // 0 <-- 1 <-- 2
+        final EdgeIteratorState edge1 = graph.edge(2, 1, 1, false);
+        final EdgeIteratorState edge2 = graph.edge(1, 0, 2, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        createNodeContractor().contractNode(1);
+        checkShortcuts(expectedShortcut(0, 2, edge1, edge2, false, true));
+    }
+
+    @Test
+    public void testContractNode_bidirected_shortcutsRequired() {
+        // 0 -- 1 -- 2
+        final EdgeIteratorState edge1 = graph.edge(0, 1, 1, true);
+        final EdgeIteratorState edge2 = graph.edge(1, 2, 2, true);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        createNodeContractor().contractNode(1);
+        checkShortcuts(expectedShortcut(0, 2, edge2, edge1, true, true));
+    }
+
+    @Test
+    public void testContractNode_directed_withWitness() {
+        // 0 --> 1 --> 2
+        //  \_________/
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 2, false);
+        graph.edge(0, 2, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        createNodeContractor().contractNode(1);
+        checkNoShortcuts();
+    }
+
+    /**
+     * Queries the ch graph and checks if the graph's shortcuts match the given expected shortcuts.
+     */
+    private void checkShortcuts(Shortcut... expectedShortcuts) {
+        Set<Shortcut> expected = setOf(expectedShortcuts);
+        if (expected.size() != expectedShortcuts.length) {
+            fail("was given duplicate shortcuts");
+        }
+        AllCHEdgesIterator iter = lg.getAllEdges();
+        Set<Shortcut> given = new HashSet<>();
+        while (iter.next()) {
+            if (iter.isShortcut()) {
+                given.add(new Shortcut(
+                        iter.getBaseNode(), iter.getAdjNode(), iter.getWeight(), iter.getDistance(),
+                        iter.isForward(encoder), iter.isBackward(encoder),
+                        iter.getSkippedEdge1(), iter.getSkippedEdge2()));
+            }
+        }
+        assertEquals(expected, given);
+    }
+
+    private void checkNoShortcuts() {
+        checkShortcuts();
+    }
+
+    private Shortcut expectedShortcut(int baseNode, int adjNode, EdgeIteratorState edge1, EdgeIteratorState edge2,
+                                      boolean fwd, boolean bwd) {
+        //todo: weight calculation might have to be adjusted for different encoders/weightings/reverse speed
+        double weight = weighting.calcWeight(edge1, false, EdgeIterator.NO_EDGE) +
+                weighting.calcWeight(edge2, false, EdgeIterator.NO_EDGE);
+        double distance = edge1.getDistance() + edge2.getDistance();
+        return new Shortcut(baseNode, adjNode, weight, distance, fwd, bwd, edge1.getEdge(), edge2.getEdge());
+    }
+
+    private Set<Shortcut> setOf(Shortcut... shortcuts) {
+        Set<Shortcut> result = new HashSet<>();
+        result.addAll(Arrays.asList(shortcuts));
+        return result;
+    }
+
+    private void setMaxLevelOnAllNodes() {
+        int nodes = lg.getNodes();
+        for (int node = 0; node < nodes; node++) {
+            lg.setLevel(node, nodes + 1);
+        }
+    }
+
+    private static class Shortcut {
+        int baseNode;
+        int adjNode;
+        double weight;
+        double distance;
+        boolean fwd;
+        boolean bwd;
+        int skipEdge1;
+        int skipEdge2;
+
+        Shortcut(int baseNode, int adjNode, double weight, double distance, boolean fwd, boolean bwd, int skipEdge1, int skipEdge2) {
+            this.baseNode = baseNode;
+            this.adjNode = adjNode;
+            this.weight = weight;
+            this.distance = distance;
+            this.fwd = fwd;
+            this.bwd = bwd;
+            this.skipEdge1 = skipEdge1;
+            this.skipEdge2 = skipEdge2;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) return true;
+            if (obj == null || getClass() != obj.getClass()) return false;
+            Shortcut shortcut = (Shortcut) obj;
+            return baseNode == shortcut.baseNode &&
+                    adjNode == shortcut.adjNode &&
+                    Double.compare(shortcut.weight, weight) == 0 &&
+                    Double.compare(shortcut.distance, distance) == 0 &&
+                    fwd == shortcut.fwd &&
+                    bwd == shortcut.bwd &&
+                    skipEdge1 == shortcut.skipEdge1 &&
+                    skipEdge2 == shortcut.skipEdge2;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(baseNode, adjNode, weight, distance, fwd, bwd, skipEdge1, skipEdge2);
+        }
+
+        @Override
+        public String toString() {
+            return "Shortcut{" +
+                    "baseNode=" + baseNode +
+                    ", adjNode=" + adjNode +
+                    ", weight=" + weight +
+                    ", distance=" + distance +
+                    ", fwd=" + fwd +
+                    ", bwd=" + bwd +
+                    ", skipEdge1=" + skipEdge1 +
+                    ", skipEdge2=" + skipEdge2 +
+                    '}';
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index f88c684057..d588a05dd3 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -19,7 +19,6 @@
 
 import com.carrotsearch.hppc.IntIndexedContainer;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.ch.PrepareContractionHierarchies.Shortcut;
 import com.graphhopper.routing.util.BikeFlagEncoder;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
@@ -33,8 +32,6 @@
 import org.junit.Test;
 
 import java.util.Arrays;
-import java.util.Collection;
-import java.util.Iterator;
 import java.util.List;
 
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
@@ -140,7 +137,7 @@ GraphHopperStorage createExampleGraph() {
         g.edge(0, 1, 1, true);
         g.edge(0, 2, 1, true);
         g.edge(0, 4, 3, true);
-        g.edge(1, 2, 2, true);
+        g.edge(1, 2, 3, true);
         g.edge(2, 3, 1, true);
         g.edge(4, 3, 2, true);
         g.edge(5, 1, 2, true);
@@ -152,59 +149,6 @@ public void setUp() {
         dir = new GHDirectory("", DAType.RAM_INT);
     }
 
-    @Test
-    public void testShortestPathSkipNode() {
-        GraphHopperStorage g = createExampleGraph();
-        double normalDist = new Dijkstra(g, weighting, tMode).calcPath(4, 2).getDistance();
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, weighting, tMode);
-        CHGraph lg = g.getGraph(CHGraph.class);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg,
-                weighting, tMode);
-        prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
-        algo.setWeightLimit(100);
-        int nodeEntry = algo.findEndNode(4, 2);
-        assertTrue(algo.getWeight(nodeEntry) > normalDist);
-
-        algo.clear();
-        algo.setMaxVisitedNodes(1);
-        nodeEntry = algo.findEndNode(4, 2);
-        assertEquals(-1, nodeEntry);
-    }
-
-    @Test
-    public void testShortestPathSkipNode2() {
-        GraphHopperStorage g = createExampleGraph();
-        CHGraph lg = g.getGraph(CHGraph.class);
-        double normalDist = new Dijkstra(g, weighting, tMode).calcPath(4, 2).getDistance();
-        assertEquals(3, normalDist, 1e-5);
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
-        prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(3));
-        algo.setWeightLimit(10);
-        int nodeEntry = algo.findEndNode(4, 2);
-        assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
-
-        nodeEntry = algo.findEndNode(4, 1);
-        assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
-    }
-
-    @Test
-    public void testShortestPathLimit() {
-        GraphHopperStorage g = createExampleGraph();
-        CHGraph lg = g.getGraph(CHGraph.class);
-
-        DijkstraOneToMany algo = new DijkstraOneToMany(g, weighting, tMode);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
-        prepare.initFromGraph().prepareNodes();
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(lg, g.getNodes() + 1).setAvoidNode(0));
-        algo.setWeightLimit(2);
-        int endNode = algo.findEndNode(4, 1);
-        // did not reach endNode
-        assertNotEquals(1, endNode);
-    }
-
     @Test
     public void testAddShortcuts() {
         GraphHopperStorage g = createExampleGraph();
@@ -212,7 +156,7 @@ public void testAddShortcuts() {
         int old = lg.getAllEdges().getMaxId();
         PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 1, lg.getAllEdges().getMaxId());
+        assertEquals(old + 2, lg.getAllEdges().getMaxId());
     }
 
     @Test
@@ -263,66 +207,16 @@ public void testDirectedGraph2() {
         assertEquals(oldCount, g.getAllEdges().getMaxId());
         assertEquals(oldCount, GHUtility.count(g.getAllEdges()));
 
-        assertEquals(9, prepare.getShortcuts());
-        assertEquals(oldCount + 9, lg.getAllEdges().getMaxId());
-        assertEquals(oldCount + 9, GHUtility.count(lg.getAllEdges()));
+        int numShortcuts = 9;
+        assertEquals(numShortcuts, prepare.getShortcuts());
+        assertEquals(oldCount + numShortcuts, lg.getAllEdges().getMaxId());
+        assertEquals(oldCount + numShortcuts, GHUtility.count(lg.getAllEdges()));
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
     }
 
-    @Test
-    public void testDirectedGraph3() {
-        GraphHopperStorage g = createGHStorage();
-        CHGraphImpl lg = (CHGraphImpl) g.getGraph(CHGraph.class);
-        //5 6 7
-        // \|/
-        //4-3_1<-\ 10
-        //     \_|/
-        //   0___2_11
-
-        g.edge(0, 2, 2, true);
-        g.edge(10, 2, 2, true);
-        g.edge(11, 2, 2, true);
-        // create a longer one directional edge => no longish one-dir shortcut should be created
-        g.edge(2, 1, 2, true);
-        g.edge(2, 1, 10, false);
-
-        g.edge(1, 3, 2, true);
-        g.edge(3, 4, 2, true);
-        g.edge(3, 5, 2, true);
-        g.edge(3, 6, 2, true);
-        g.edge(3, 7, 2, true);
-
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
-        prepare.initFromGraph();
-        prepare.prepareNodes();
-
-        // find all shortcuts if we contract node 1
-        Collection<Shortcut> scs = prepare.testFindShortcuts(1);
-        assertEquals(2, scs.size());
-        Iterator<Shortcut> iter = scs.iterator();
-        Shortcut sc1 = iter.next();
-        Shortcut sc2 = iter.next();
-        if (sc1.weight > sc2.weight) {
-            Shortcut tmp = sc1;
-            sc1 = sc2;
-            sc2 = tmp;
-        }
-
-        // both dirs
-        assertTrue(sc1.toString(), sc1.from == 3 && sc1.to == 2);
-        assertTrue(sc1.toString(), carEncoder.isForward(sc1.flags) && carEncoder.isBackward(sc1.flags));
-
-        // directed
-        assertTrue(sc2.toString(), sc2.from == 2 && sc2.to == 3);
-        assertTrue(sc2.toString(), carEncoder.isForward(sc2.flags));
-
-        assertEquals(sc1.toString(), 4, sc1.weight, 1e-4);
-        assertEquals(sc2.toString(), 12, sc2.weight, 1e-4);
-    }
-
     void initRoundaboutGraph(Graph g) {
         //              roundabout:
         //16-0-9-10--11   12<-13
@@ -389,58 +283,6 @@ public void testRoundaboutUnpacking() {
         assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
     }
 
-    @Test
-    public void testFindShortcuts_Roundabout() {
-        GraphHopperStorage ghStorage = createGHStorage();
-        CHGraph lg = ghStorage.getGraph(CHGraph.class);
-        EdgeIteratorState iter1_3 = ghStorage.edge(1, 3, 1, true);
-        EdgeIteratorState iter3_4 = ghStorage.edge(3, 4, 1, true);
-        EdgeIteratorState iter4_5 = ghStorage.edge(4, 5, 1, false);
-        EdgeIteratorState iter5_6 = ghStorage.edge(5, 6, 1, false);
-        EdgeIteratorState iter6_8 = ghStorage.edge(6, 8, 2, false);
-        EdgeIteratorState iter8_4 = ghStorage.edge(8, 4, 1, false);
-        ghStorage.edge(6, 7, 1, true);
-        ghStorage.freeze();
-
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg,
-                weighting, tMode);
-        CHEdgeIteratorState tmp = lg.shortcut(1, 4);
-        tmp.setFlags(PrepareEncoder.getScDirMask());
-        tmp.setWeight(2);
-        tmp.setSkippedEdges(iter1_3.getEdge(), iter3_4.getEdge());
-        long f = PrepareEncoder.getScFwdDir();
-        tmp = lg.shortcut(4, 6);
-        tmp.setFlags(f);
-        tmp.setWeight(2);
-        tmp.setSkippedEdges(iter4_5.getEdge(), iter5_6.getEdge());
-        tmp = lg.shortcut(6, 4);
-        tmp.setFlags(f);
-        tmp.setWeight(3);
-        tmp.setSkippedEdges(iter6_8.getEdge(), iter8_4.getEdge());
-
-        prepare.initFromGraph();
-        prepare.prepareNodes();
-        lg.setLevel(3, 3);
-        lg.setLevel(5, 5);
-        lg.setLevel(7, 7);
-        lg.setLevel(8, 8);
-
-        // there should be two different shortcuts for both directions!
-        Collection<Shortcut> sc = prepare.testFindShortcuts(4);
-        assertEquals(2, sc.size());
-        Iterator<Shortcut> iter = sc.iterator();
-        Shortcut sc1 = iter.next();
-        Shortcut sc2 = iter.next();
-        if (sc1.from > sc2.from) {
-            Shortcut tmpSc = sc1;
-            sc1 = sc2;
-            sc2 = tmpSc;
-        }
-
-        assertEquals("1->6, weight:4.0 (7,8)", sc1.toString());
-        assertEquals("6->1, weight:5.0 (9,7)", sc2.toString());
-    }
-
     void initUnpackingGraph(GraphHopperStorage ghStorage, CHGraph g, Weighting w) {
         final long flags = carEncoder.setProperties(30, true, false);
         double dist = 1;
@@ -646,30 +488,4 @@ void checkPath(GraphHopperStorage ghStorage, Weighting w, int expShortcuts, doub
         assertEquals(w.toString(), expNodes, p.calcNodes());
     }
 
-    @Test
-    public void testShortcutMergeBug() {
-        // We refer to this real world situation http://www.openstreetmap.org/#map=19/52.71205/-1.77326
-        // assume the following graph:
-        //
-        // ---1---->----2-----3
-        //    \--------/
-        //
-        // where there are two roads from 1 to 2 and the directed road has a smaller weight
-        // leading to two shortcuts sc1 (unidir) and sc2 (bidir) where the second should NOT be rejected due to the larger weight
-        GraphHopperStorage g = createGHStorage();
-        g.edge(1, 2, 1, true);
-        g.edge(1, 2, 1, false);
-        g.edge(2, 3, 1, true);
-
-        CHGraph lg = g.getGraph(CHGraph.class);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
-        prepare.initFromGraph();
-
-        // order is important here
-        Shortcut sc1 = new Shortcut(1, 3, 6.81620625, 121.18);
-        Shortcut sc2 = new Shortcut(1, 3, 6.82048125, 121.25);
-        sc2.flags = PrepareEncoder.getScDirMask();
-        List<Shortcut> list = Arrays.asList(sc1, sc2);
-        assertEquals(2, prepare.addShortcuts(list));
-    }
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index 0af3c065b0..6fd91cc3b3 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -26,7 +26,6 @@
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.CHAlgoFactoryDecorator;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.routing.lm.LandmarkStorage;
 import com.graphhopper.routing.lm.PrepareLandmarks;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.AbstractWeighting;
