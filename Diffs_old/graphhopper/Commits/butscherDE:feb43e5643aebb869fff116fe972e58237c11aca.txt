diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 0230aab5a2..16173b7636 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1155,7 +1155,7 @@ private RoutingTemplate buildRoutingTemplate(GHRequest request, GHResponse ghRsp
         } else if (validPolygonInRequest(request)) {
             routingTemplate = new PolygonRoutingTemplate(request, ghRsp, locationIndex, this, encodingManager);
         } else {
-                routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
+            routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
         }
         return routingTemplate;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index 0afd0ced36..0feb83a67d 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -49,6 +49,7 @@ public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationInd
         this.algoOpts = algoOpts;
         this.routingAlgorithm = algoFactory.createAlgo(queryGraph, algoOpts);
         this.routeCandidates = new LinkedList<>();
+        this.dijkstraForLOTNodes = new DijkstraOneToMany(this.queryGraph, this.algoOpts.getWeighting(), this.algoOpts.getTraversalMode());
         return routeWithPolygon();
     }
 
@@ -58,7 +59,8 @@ private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFac
 
     private List<Path> routeWithPolygon() {
         this.findCandidateRoutes();
-        //this.pruneDominatedCandidateRoutes();
+        this.pruneDominatedCandidateRoutes();
+        this.pruneLowerQuantileInROIcandidateRoutes();
 
         throw new NotImplementedException();
     }
@@ -67,6 +69,8 @@ private void findCandidateRoutes() {
         List<Integer> nodesInPolygon = getNodesInPolygon();
         List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
         List<List<Integer>> LOTNodes = findLocalOptimalTouchnodes(polygonEntryExitPoints);
+        this.dijkstraForPathSkeleton = new DijkstraManyToMany(this.queryGraph, this.algoOpts.getWeighting(), this.algoOpts.getTraversalMode(), nodesInPolygon,
+                                                              polygonEntryExitPoints);
 
         for (int i = 0; i < LOTNodes.size() - 1; i++) {
             lookUpStartEndNodes(i);
@@ -213,6 +217,87 @@ private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPol
         return visitor.getNodesInPolygon();
     }
 
+    // Do it in a skyline problem pruning fashion
+    private void pruneDominatedCandidateRoutes() {
+        sortRouteCandidatesToDistanceInROIDescending();
+
+        int currentPruningCandidateIndex = 1;
+        while (indexInCandidateBounds(currentPruningCandidateIndex)) {
+            RouteCandidate currentPruningCandidate = this.routeCandidates.get(currentPruningCandidateIndex);
+
+            boolean foundDominatingPath = isThisCandidateDominatedByAny(currentPruningCandidateIndex, currentPruningCandidate);
+
+            currentPruningCandidateIndex = pruneOrUpdateIndex(currentPruningCandidateIndex, foundDominatingPath);
+        }
+    }
+
+    private boolean isThisCandidateDominatedByAny(int currentPruningCandidateIndex, RouteCandidate currentPruningCandidate) {
+        boolean foundDominatingPath = false;
+        for (int i = currentPruningCandidateIndex - 1; i >= 0 && !foundDominatingPath; i++) {
+            // routeCandidates must be sorted by now. Therefore dominators can only bbe found on lower indices than the current pruning candidate.
+            RouteCandidate possiblyBetterRouteCandidate = this.routeCandidates.get(i);
+
+            if (isPruningCandidateDominated(currentPruningCandidate, possiblyBetterRouteCandidate)) {
+                foundDominatingPath = true;
+            }
+        }
+        return foundDominatingPath;
+    }
+
+    private int pruneOrUpdateIndex(int currentPruningCandidateIndex, boolean foundDominatingPath) {
+        if (foundDominatingPath) {
+            this.routeCandidates.remove(currentPruningCandidateIndex);
+        } else {
+            currentPruningCandidateIndex++;
+        }
+        return currentPruningCandidateIndex;
+    }
+
+    private boolean isPruningCandidateDominated(RouteCandidate currentPruningCandidate, RouteCandidate possiblyBetterRouteCandidate) {
+        return possiblyBetterRouteCandidate.getDistance() < currentPruningCandidate.getDistance() && possiblyBetterRouteCandidate.getDistanceInROI() > currentPruningCandidate.getDistanceInROI();
+    }
+
+    private void sortRouteCandidatesToDistanceInROIDescending() {
+        Collections.sort(this.routeCandidates, new Comparator<RouteCandidate>() {
+            @Override
+            public int compare(RouteCandidate rc1, RouteCandidate rc2) {
+                double distanceDifference = rc1.getDistanceInROI() - rc2.getDistanceInROI();
+                int output;
+                if (distanceDifference < 0) {
+                    output = 1;
+                } else if (distanceDifference == 0) {
+                    output = 0;
+                } else {
+                    output = -1;
+                }
+
+                return output;
+            }
+        });
+    }
+
+    private boolean indexInCandidateBounds(int currentPruningCandidateIndex) {
+        return currentPruningCandidateIndex < this.routeCandidates.size();
+    }
+
+    private void pruneLowerQuantileInROIcandidateRoutes() {
+        // Assumes that routeCandidates was already sorted descending to roi distance after pruning dominated route candidates
+        final int routeCandidatesSize = this.routeCandidates.size();
+        int startIndex = (int) (routeCandidatesSize * 0.75) + 1;
+
+        for (int i = startIndex; i < routeCandidatesSize; i++) {
+            this.routeCandidates.remove(i);
+        }
+    }
+
+    public RoutingAlgorithm getRoutingAlgorithm() {
+        return this.routingAlgorithm;
+    }
+
+    public DijkstraManyToMany getPathSkeletonRouter() {
+        return this.dijkstraForPathSkeleton;
+    }
+
     private class NodesInPolygonFindingVisitor extends LocationIndex.Visitor {
         private final List<Integer> nodesInPolygon = new LinkedList<>();
         private final Polygon polygon;
@@ -238,15 +323,7 @@ public void onNode(int nodeId) {
         }
     }
 
-    public RoutingAlgorithm getRoutingAlgorithm() {
-        return this.routingAlgorithm;
-    }
-
-    public DijkstraManyToMany getPathSkeletonRouter() {
-        return this.dijkstraForPathSkeleton;
-    }
-
-    private class RouteCandidate {
+    private class RouteCandidate implements Comparable<RouteCandidate> {
         private final Path startToPolygonEntry;
         private final Path polygonEntryToPolygonExit;
         private final Path polygonExitToEnd;
@@ -314,5 +391,22 @@ public boolean isDetourSelfIntersecting() {
             return false;
             // TODO: Check with storandt what she means with intersections
         }
+
+        @Override
+        /**
+         * @param   o - The Route Candidate to be compared.
+         * @return  A negative integer, zero, or a positive integer as this RouteCandidate
+         *          is less than, equal to, or greater than the supplied RouteCandidate object.
+         */
+        public int compareTo(RouteCandidate o) {
+            double gainDifference = this.getGain() - o.getGain();
+            if (gainDifference < 0) {
+                return -1;
+            } else if (gainDifference == 0) {
+                return 0;
+            } else {
+                return 1;
+            }
+        }
     }
 }
