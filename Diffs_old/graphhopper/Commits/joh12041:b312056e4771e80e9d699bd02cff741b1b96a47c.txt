diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index e21f549152..b17e84e255 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -101,6 +101,9 @@
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private FlagEncoderFactory flagEncoderFactory = FlagEncoderFactory.DEFAULT;
 
+    private String bannedGridCellsFn;
+    private HashSet<Integer> bannedEdges = null;
+
     public GraphHopper() {
         chFactoryDecorator.setEnabled(true);
         algoDecorators.add(chFactoryDecorator);
@@ -156,6 +159,121 @@ public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
         return this;
     }
 
+    public void setBannedGridCellsFn(String bannedGridCellsFn) {
+        this.bannedGridCellsFn = bannedGridCellsFn;
+    }
+
+
+    private void getBannedEdges() throws IOException {
+        bannedEdges = new HashSet<>();
+        LocationIndex index = getLocationIndex();
+        int numcells = 0;
+        try {
+            HashMap<String, Integer> bpHeaderMap = new HashMap<>();
+            Scanner sc_in = new Scanner(new File(bannedGridCellsFn));
+            String[] bpHeader = sc_in.nextLine().split(",");
+            int i = 0;
+            for (String col : bpHeader) {
+                bpHeaderMap.put(col, i);
+                i++;
+            }
+            String line;
+            String[] vals;
+            Double rid;
+            Double cid;
+            int doBlock;
+            while (sc_in.hasNext()) {
+                line = sc_in.nextLine();
+                vals = line.split(",");
+                try {
+                    rid = Double.valueOf(vals[bpHeaderMap.get("rid")]) / 1000.0;
+                    cid = Double.valueOf(vals[bpHeaderMap.get("cid")]) / 1000.0;
+                    doBlock = Integer.valueOf(vals[bpHeaderMap.get("block")]);
+                    if (doBlock == 1) {
+                        numcells++;
+                        boolean keepSearching = false;
+                        QueryResult qr = index.findClosest(rid + 0.0005, cid + 0.0005, EdgeFilter.ALL_EDGES);  // use point in middle of box
+                        if (!qr.isValid()) {
+                            System.out.println("No valid edge for lat/lon: " + rid + "," + cid);
+                            continue;
+                        }
+                        EdgeIteratorState edge = qr.getClosestEdge();
+                        BBox bBox = new BBox(cid, cid + 0.001, rid, rid + 0.001);
+                        PointList pl = edge.fetchWayGeometry(3);
+                        HashSet<Integer> edgesFound = new HashSet<>();
+                        HashSet<Integer> edgesChecked = new HashSet<>();
+                        for (int n = 0; n < pl.size(); n++) {
+                            double nodeLat = pl.getLat(n);
+                            double nodeLon = pl.getLon(n);
+                            if (bBox.contains(nodeLat, nodeLon)) {
+                                String lineWKT = "LINESTRING (";
+                                for (int m = 0; m < pl.size(); m++) {
+                                    lineWKT = lineWKT + pl.getLon(m) + " " + pl.getLat(m) + ", ";
+                                }
+                                lineWKT = lineWKT.substring(0, lineWKT.length() - 2) + ")";
+                                System.out.println(lineWKT);
+                                edgesFound.add(edge.getEdge());
+                                edgesChecked.add(edge.getEdge());
+                                keepSearching = true;
+                                break;
+                            }
+                        }
+                        if (keepSearching) {
+                            ArrayList<Integer> nodes = new ArrayList<>();
+                            EdgeExplorer explorer = ghStorage.createEdgeExplorer();
+                            for (int k = 0; k < 2; k++) {
+                                if (k == 0) {
+                                    nodes.add(edge.getBaseNode());
+                                } else {
+                                    nodes.add(edge.getAdjNode());
+                                }
+                                while (nodes.size() > 0) {
+                                    EdgeIterator iter = explorer.setBaseNode(nodes.get(0));
+                                    while (iter.next()) {
+                                        if (!edgesChecked.contains(iter.getEdge())) {
+                                            pl = iter.fetchWayGeometry(3);
+                                            edgesChecked.add(iter.getEdge());
+                                            for (int n = 0; n < pl.size(); n++) {
+                                                double nodeLat = pl.getLat(n);
+                                                double nodeLon = pl.getLon(n);
+                                                if (bBox.contains(nodeLat, nodeLon)) {
+                                                    int eid = edge.getEdge();
+                                                    if (!edgesFound.contains(eid)) {
+                                                        String lineWKT = "LINESTRING (";
+                                                        for (int m = 0; m < pl.size(); m++) {
+                                                            lineWKT = lineWKT + pl.getLon(m) + " " + pl.getLat(m) + ", ";
+                                                        }
+                                                        lineWKT = lineWKT.substring(0, lineWKT.length() - 2) + ")";
+                                                        System.out.println(lineWKT);
+                                                        edgesFound.add(eid);
+                                                        nodes.add(edge.getAdjNode());
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                    nodes.remove(0);
+                                }
+                            }
+                        }
+                        for (Integer eid : edgesFound) {
+                            bannedEdges.add(eid);
+                        }
+                    }
+                } catch (NullPointerException ex) {
+                    System.out.println(ex.getMessage());
+                    System.out.println(line);
+                    continue;
+                }
+            }
+        } catch (IOException io) {
+            System.out.println(io + ": " + bannedGridCellsFn + " does not exist.");
+        }
+        System.out.println(numcells + " cells checked.");
+        System.out.println(bannedEdges.size() + " banned edges.");
+    }
+
+
     /**
      * Threads for data reading.
      */
@@ -932,6 +1050,17 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder) {
 
         } else if ("short_fastest".equalsIgnoreCase(weighting)) {
             return new ShortFastestWeighting(encoder, hintsMap);
+        } else if ("safest_fastest".equalsIgnoreCase(weighting)) {
+            if (bannedEdges == null) {
+                try {
+                    System.out.println("\nCalculating banned edges!");
+                    getBannedEdges();
+                } catch (IOException io) {
+                    System.out.println("Banned edges calculation failed.");
+                    bannedEdges = new HashSet<>();
+                }
+            }
+            return new AvoidanceWeighting(encoder, hintsMap, bannedEdges);
         }
 
         throw new IllegalArgumentException("weighting " + weighting + " not supported");
diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/core/src/main/java/com/graphhopper/PathWrapper.java
index 0e0a9be8d3..3d7f9fa70d 100644
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/core/src/main/java/com/graphhopper/PathWrapper.java
@@ -39,11 +39,13 @@
     private List<String> description;
     private double distance;
     private double distanceNonHighway;
+    private double distanceSmallNeigh;
     private double ascend;
     private double descend;
     private double routeWeight;
     private long time;
     private long timeNonHighway;
+    private long timeSmallNeigh;
     private String debugInfo = "";
     private InstructionList instructions;
     private PointList waypointList = PointList.EMPTY;
@@ -159,11 +161,21 @@ public double getNonHighwayDistance() {
         return distanceNonHighway;
     }
 
+    public double getNeiHighwayDistance() {
+        check("getDistance");
+        return distanceSmallNeigh;
+    }
+
     public PathWrapper setNonHighwayDistance(double distance) {
         this.distanceNonHighway = distance;
         return this;
     }
 
+    public PathWrapper setNeiHighwayDistance(double distance) {
+        this.distanceSmallNeigh = distance;
+        return this;
+    }
+
     /**
      * This method returns the total elevation change (going upwards) in meter.
      * <p>
@@ -218,11 +230,21 @@ public long getNonHighwayTime() {
         return timeNonHighway;
     }
 
+    public long getTimeSmallNeigh() {
+        check("getTimes");
+        return timeSmallNeigh;
+    }
+
     public PathWrapper setNonHighwayTime(long timeInMillis) {
         this.timeNonHighway = timeInMillis;
         return this;
     }
 
+    public PathWrapper setNeiHighwayTime(long timeInMilis) {
+        this.timeSmallNeigh = timeInMilis;
+        return this;
+    }
+
     /**
      * This method returns a double value which is better than the time for comparison of routes but
      * only if you know what you are doing, e.g. only to compare routes gained with the same query
diff --git a/core/src/main/java/com/graphhopper/routing/KSP.java b/core/src/main/java/com/graphhopper/routing/KSP.java
index ed60ef1041..d6c443da1f 100644
--- a/core/src/main/java/com/graphhopper/routing/KSP.java
+++ b/core/src/main/java/com/graphhopper/routing/KSP.java
@@ -63,7 +63,7 @@ public int compare(AlternativeInfo o1, AlternativeInfo o2) {
     // the higher the maxWeightFactor the higher the explorationFactor needs to be
     // 1 is default for bidir Dijkstra, 0.8 seems to be a very similar value for bidir A* but roughly 1/2 of the nodes explored
     private double maxExplorationFactor = 10;  //
-    private int maxPaths = 10000;  // K
+    private int maxPaths = 1000;  // K
 
     public KSP(Graph graph, Weighting weighting, TraversalMode traversalMode) {
         this.graph = graph;
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 11363f4ff5..1325ff1439 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.Weighting;
@@ -29,6 +30,7 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 
 /**
@@ -51,6 +53,8 @@
     protected long time;
     protected double distanceNonHighway;
     protected long timeNonHighway;
+    protected double distanceSmallNeigh;
+    protected long timeSmallNeigh;
     /**
      * Shortest path tree entry
      */
@@ -173,6 +177,8 @@ public double getNonHighwayDistance() {
         return distanceNonHighway;
     }
 
+    public double getDistanceSmallNeigh() { return distanceSmallNeigh; }
+
     /**
      * @return time in millis
      */
@@ -184,6 +190,8 @@ public long getNonHighwayime() {
         return timeNonHighway;
     }
 
+    public long getTimeSmallNeigh() { return timeSmallNeigh; }
+
     /**
      * This weight will be updated during the algorithm. The initial value is maximum double.
      */
@@ -246,7 +254,12 @@ protected void processEdge(int edgeId, int adjNode, int prevEdgeId) {
         long t = weighting.calcMillis(iter, false, prevEdgeId);
         distance += d;
         time += t;
-        if (d / (t / 1000.0) > 20)  {  // 20 m per sec just under 45 mph
+        double speed = d / (t / 1000.0);
+        if (speed < 12) {  // 12 m per sec just over 25 mph
+            distanceSmallNeigh += d;
+            timeSmallNeigh += t;
+        }
+        if (speed < 20)  {  // 20 m per sec just under 45 mph
             distanceNonHighway += d;
             timeNonHighway += t;
         }
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 98272fcf39..0421ffc14f 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -63,9 +63,11 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
         int origPoints = 0;
         long fullTimeInMillis = 0;
         long fullNHTimeInMillis = 0;
+        long fullNeiTimeInMillis = 0;
         double fullWeight = 0;
         double fullDistance = 0;
         double fullNHDistance = 0;
+        double fullNeiDistance = 0;
         boolean allFound = true;
         int simplicity = 0;
 
@@ -77,8 +79,10 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
             description.addAll(path.getDescription());
             fullTimeInMillis += path.getTime();
             fullNHTimeInMillis += path.getNonHighwayime();
+            fullNeiTimeInMillis += path.getTimeSmallNeigh();
             fullDistance += path.getDistance();
             fullNHDistance += path.getNonHighwayDistance();
+            fullNeiDistance += path.getDistanceSmallNeigh();
             fullWeight += path.getWeight();
             if (enableInstructions) {
                 InstructionList il = path.calcInstructions(tr);
@@ -144,6 +148,8 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
                 setTime(fullTimeInMillis).
                 setNonHighwayDistance(fullNHDistance).
                 setNonHighwayTime(fullNHTimeInMillis).
+                setNeiHighwayTime(fullNeiTimeInMillis).
+                setNeiHighwayDistance(fullNeiDistance).
                 setSimplicity(simplicity);
     }
 
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java
index 4471dabe23..23013d7bfb 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP.java
@@ -31,7 +31,7 @@
     private String osmFile = "./reader-osm/files/";
     private String graphFolder = "./reader-osm/target/tmp/";
     private String inputPointsFN = "../data/intermediate/";
-    private String outputPointsFN = "../data/testing/";
+    private String outputPointsFN = "../data/final/impacts/";
     private String gvfnStem = "../data/intermediate/";
     private String gctfnStem = "../geometries/";
     private ArrayList<String> gridValuesFNs = new ArrayList<>();
@@ -41,7 +41,7 @@
     private HashMap<String, Integer> gridCT;
     private GraphHopper hopper;
     private MapMatching mapMatching;
-    private String outputheader = "ID,name,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity,numCTs,pctHighwayTime,pctHighwayDist" +
+    private String outputheader = "ID,name,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity,pctNonHighwayTime,pctNonHighwayDist,pctNeiTime,pctNeiDist" +
             System.getProperty("line.separator");
     private ArrayList<float[]> inputPoints = new ArrayList<>();
     private ArrayList<String> id_to_points = new ArrayList<>();
@@ -54,13 +54,13 @@ public parallelKSP(String city, String route_type) {
         this.route_type = route_type;
         this.outputFiles = new HashMap<>();
         optimizations.add("beauty");
-        optimizations.add("ugly");
+        //optimizations.add("ugly");
         optimizations.add("simple");
-        optimizations.add("besi");
+        //optimizations.add("besi");
         optimizations.add("fast");
-        optimizations.add("short");
-        optimizations.add("alt");
-        optimizations.add("mindirections");
+        //optimizations.add("short");
+        //optimizations.add("alt");
+        //optimizations.add("mindirections");
 
     }
 
@@ -200,10 +200,10 @@ else if (pointsList.size() > 0) {
             PathWrapper path = GPXToPath(pointLists.get(routeID));
             if (path.getDistance() > 0) {
                 float score = getBeauty(path);
-                results.put(routeID, writeOutput(i, optimized, routeNames.get(routeID), routeID, path, score, getNumCTs(path)));
+                results.put(routeID, writeOutput(i, optimized, routeNames.get(routeID), routeID, path, score));
             }
             if (i % 50 == 0) {
-                System.out.println(i + " of " + num_routes + " routes matched.");
+                System.out.println("\t\t" + i + " of " + num_routes + " routes matched.");
             }
         }
         );
@@ -370,17 +370,21 @@ public void prepMapMatcher() {
     }
 
 
-    public String writeOutput(int i, String optimized, String name, String od_id, PathWrapper bestPath, float score, int numCTs) {
+    public String writeOutput(int i, String optimized, String name, String od_id, PathWrapper bestPath, float score) {
 
         // points, distance in meters and time in seconds (convert from ms) of the full path
         PointList pointList = bestPath.getPoints();
         int simplicity = bestPath.getSimplicity();
         double distance = Math.round(bestPath.getDistance() * 100) / 100;
         double nonHighwayDistance = bestPath.getNonHighwayDistance();
-        float pctNHD = Math.round(1000 * nonHighwayDistance / distance) / 1000;
+        double pctNHD = Math.round(1000.0 * (float) nonHighwayDistance / distance) / 1000.0;
         long timeInSec = bestPath.getTime() / 1000;
         long nonHighwayTimeInSec = bestPath.getNonHighwayTime() / 1000;
-        float pctNHT = Math.round(1000 * (float) nonHighwayTimeInSec / timeInSec) / 1000;
+        double pctNHT = Math.round(1000.0 * (float) nonHighwayTimeInSec / timeInSec) / 1000.0;
+        double smallNeiDistance = bestPath.getNeiHighwayDistance();
+        double pctNeiD = Math.round(1000.0 * (float) smallNeiDistance / distance) / 1000.0;
+        long neiHighwayTimeInSec = bestPath.getTimeSmallNeigh() / 1000;
+        double pctNeiT = Math.round(1000.0 * (float) neiHighwayTimeInSec / timeInSec) / 1000.0;
         InstructionList il = bestPath.getInstructions();
         int numDirections = il.getSize();
         // iterate over every turn instruction
@@ -389,9 +393,19 @@ public String writeOutput(int i, String optimized, String name, String od_id, Pa
             maneuvers.add(instruction.getSimpleTurnDescription());
         }
 
-        System.out.println(i + " (" + optimized + "): Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections + ";\tSimplicity: " + simplicity + ";\tScore: " + score + ";\tNumCts: " + numCTs + ";\tPctNHT: " + nonHighwayTimeInSec + ";\tPctNHD: " + nonHighwayDistance);
-        return od_id + "," + name + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
-                ",\"" + maneuvers.toString() + "\"" + "," + score + "," + simplicity + "," + numCTs + "," + pctNHT + "," + pctNHD + System.getProperty("line.separator");
+        System.out.println(i + " (" + optimized + "): Distance: " +
+                distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections +
+                ";\tSimplicity: " + simplicity + ";\tScore: " + score +
+                ";\tPctNHT: " + pctNHT + ";\tPctNeiT: " + pctNeiT);
+
+        return od_id + "," + name + "," +
+                "\"[" + pointList + "]\"," +
+                timeInSec + "," + distance + "," + numDirections +
+                ",\"" + maneuvers.toString() + "\"" + "," +
+                score + "," + simplicity + "," +
+                pctNHT + "," + pctNHD + "," +
+                pctNeiT + "," + pctNeiD +
+                System.getProperty("line.separator");
 
 
     }
@@ -477,7 +491,7 @@ public void process_routes() throws Exception {
             }
             int i = num_processed.incrementAndGet();
             if (i % 50 == 0) {
-                System.out.println(i + " of " + num_odpairs + " o-d pairs processed.");
+                System.out.println(System.getProperty("line.separator") + i + " of " + num_odpairs + " o-d pairs processed." + System.getProperty("line.separator"));
             }
         }
         );
@@ -508,7 +522,7 @@ public void process_routes() throws Exception {
         GHResponse rsp = hopper.route(req);
 
         String defaultRow = od_id + ",main," + "\"[(" + points[0] + "," + points[1] + "),(" + points[2] + "," + points[3]
-                + ")]\"," + "-1,-1,-1,[],-1,-1,-1" + System.getProperty("line.separator");
+                + ")]\"," + "-1,-1,-1,[],-1,-1,-1,-1" + System.getProperty("line.separator");
 
         // first check for errors
         if (rsp.hasErrors()) {
@@ -537,23 +551,19 @@ public void process_routes() throws Exception {
         float bestscore = -1000;
         //float originalscore = getBeauty(paths.get(0));
         int routeidx = -1;
-        //int capPathsPerMVT = paths.size() - 1;
         for (PathWrapper path : paths) {
             float score = getBeauty(path);
             if (score > bestscore) {
                 bestscore = score;
                 routeidx = j;
             }
-            //if ((bestscore - originalscore) < (bestscore / (j + 1))) {
-            //    j = j + 0;
-            //}
-            //System.out.println(j + "\t" + score);
             j++;
         }
         //System.out.println("Most beautiful route: " + routeidx);
-        responses.put("beauty", writeOutput(route, "Best", "beauty", od_id, paths.get(routeidx), bestscore, getNumCTs(paths.get(routeidx))));
-        float maxBeauty = bestscore;
+        responses.put("beauty", writeOutput(route, "Beau", "beauty", od_id, paths.get(routeidx), bestscore));
+        //float maxBeauty = bestscore;
 
+        /*
         // Find least-beautiful route within similar distance constraints
         double beautyDistance = paths.get(routeidx).getDistance();
         j = 0;
@@ -575,30 +585,31 @@ public void process_routes() throws Exception {
             //    break;
             //}
         }
-        responses.put("ugly", writeOutput(route, "Wrst", "ugly", od_id, paths.get(routeidx), bestscore, getNumCTs(paths.get(routeidx))));
+        responses.put("ugly", writeOutput(route, "Wrst", "ugly", od_id, paths.get(routeidx), bestscore)));
+
+        */
 
         // Simplest Route
         j = 0;
         bestscore = 10000;
         routeidx = 0;
-        float beauty = -1;
         for (PathWrapper path : paths) {
             int score = path.getSimplicity();
             if (score < bestscore) {
                 bestscore = score;
                 routeidx = j;
-                beauty = getBeauty(path);
             }
             j++;
         }
         //System.out.println("Simplest route: " + routeidx);
-        responses.put("simple", writeOutput(route, "Simp", "simple", od_id, paths.get(routeidx), beauty, getNumCTs(paths.get(routeidx))));
-        float minSimplicity = bestscore;
+        responses.put("simple", writeOutput(route, "Simp", "simple", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx))));
+        //float minSimplicity = bestscore;
 
         // Fastest Route
         PathWrapper bestPath = paths.get(0);
-        beauty = getBeauty(bestPath);
-        responses.put("fast", writeOutput(route, "Fast", "Fastest", od_id, bestPath, beauty, getNumCTs(bestPath)));
+        responses.put("fast", writeOutput(route, "Fast", "fastest", od_id, bestPath, getBeauty(bestPath)));
+
+        /*
 
         // Beautifully simple route
         j = 0;
@@ -656,7 +667,6 @@ public void process_routes() throws Exception {
             responses.put("short", writeOutput(route, "Shrt", "shortest", od_id, bestPath, beauty, getNumCTs(bestPath)));
         }
 
-
         // Alternative Route
         req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
                 setWeighting("fastest").
@@ -684,6 +694,7 @@ public void process_routes() throws Exception {
             }
         }
 
+        */
 
         return responses;
     }
@@ -692,9 +703,11 @@ public static void main(String[] args) throws Exception {
 
         // PBFs from: https://mapzen.com/data/metro-extracts/
 
-        //String city = args[0];
-        String city = "man";  // sf, nyc, chi, lon, man, sin
+        String city = "sf";  // sf, nyc, chi, lon, man, sin
         String odtype = "grid";  // grid, rand
+        //System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "12");
+        //String city = args[0];
+        //String odtype = args[1];
         parallelKSP ksp = new parallelKSP(city, odtype);
         boolean matchexternal = false;
         boolean getghroutes = true;
@@ -706,16 +719,16 @@ public static void main(String[] args) throws Exception {
             ksp.getGridCTs();
             ksp.prepMapMatcher();  // score external API routes
             String inputfolder = "../data/intermediate/";
-            String outputfolder = "../data/SCRATCH/";
+            String outputfolder = "../data/finalMatched/";
             ArrayList<String> platforms = new ArrayList<>();
             platforms.add("google");
             platforms.add("mapquest");
             ArrayList<String> conditions = new ArrayList<>();
             conditions.add("traffic");
-            conditions.add("notraffic");
+            //conditions.add("notraffic");
             ArrayList<String> routetypes = new ArrayList<>();
             routetypes.add("main");
-            routetypes.add("alt");
+            //routetypes.add("alt");
             for (String platform : platforms) {
                 for (String condition : conditions) {
                     for (String routetype : routetypes) {
@@ -729,7 +742,7 @@ public static void main(String[] args) throws Exception {
             ksp.setDataSources();
             ksp.getGridValues();
             ksp.prepareGraphHopper();
-            ksp.getGridCTs();
+            //ksp.getGridCTs();
             ksp.setODPairs();
             ksp.process_routes();  // get Graphhopper routes
         }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_debug.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_pctimprovements.java
similarity index 99%
rename from reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_debug.java
rename to reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_pctimprovements.java
index 4db05dbf0e..4bbeacc9e0 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_debug.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_pctimprovements.java
@@ -23,7 +23,7 @@
 /**
  * Created by isaac on 09/14/16.
  */
-public class parallelKSP_debug {
+public class parallelKSP_pctimprovements {
 
     String city;
     String route_type;
@@ -49,7 +49,7 @@
     private int maxstep = 500;
 
 
-    public parallelKSP_debug(String city, String route_type) {
+    public parallelKSP_pctimprovements(String city, String route_type) {
 
         this.city = city;
         this.route_type = route_type;
@@ -607,7 +607,7 @@ public static void main(String[] args) throws Exception {
         //String city = args[0];
         String city = "sf";  // sf, nyc, chi, lon, man, sin
         String odtype = "grid";  // grid, rand
-        parallelKSP_debug ksp = new parallelKSP_debug(city, odtype);
+        parallelKSP_pctimprovements ksp = new parallelKSP_pctimprovements(city, odtype);
         boolean matchexternal = false;
         boolean getghroutes = true;
 
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_tradeoffs.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_tradeoffs.java
new file mode 100644
index 0000000000..fc3a321192
--- /dev/null
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/parallelKSP_tradeoffs.java
@@ -0,0 +1,795 @@
+package com.graphhopper.reader.osm;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.matching.MapMatching;
+import com.graphhopper.matching.MatchResult;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.util.*;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/**
+ * Created by isaac on 09/14/16.
+ */
+public class parallelKSP_tradeoffs {
+
+    String city;
+    String route_type;
+    HashMap<String, FileWriter> outputFiles;
+    private String osmFile = "./reader-osm/files/";
+    private String graphFolder = "./reader-osm/target/tmp/";
+    private String inputPointsFN = "../data/intermediate/";
+    private String outputPointsFN = "../data/final/tradeoffs/";
+    private String gvfnStem = "../data/intermediate/";
+    private String gctfnStem = "../geometries/";
+    private ArrayList<String> gridValuesFNs = new ArrayList<>();
+    private ArrayList<String> gridCTsFNs = new ArrayList<>();
+    private HashMap<String, Integer> gvHeaderMap;
+    private HashMap<String, Float> gridBeauty;
+    private HashMap<String, Integer> gridCT;
+    private GraphHopper hopper;
+    private MapMatching mapMatching;
+    private String outputheader = "ID";
+    private ArrayList<float[]> inputPoints = new ArrayList<>();
+    private ArrayList<String> id_to_points = new ArrayList<>();
+    private ArrayList<String> optimizations = new ArrayList<>();
+    private int stepsize = 10;
+    private int maxstep = 100;
+
+    public parallelKSP_tradeoffs(String city, String route_type) {
+
+        this.city = city;
+        this.route_type = route_type;
+        this.outputFiles = new HashMap<>();
+        optimizations.add("beauty_time");
+        optimizations.add("simple_time");
+        optimizations.add("beauty_beauty");
+        optimizations.add("simple_simple");
+        for (int i = 0; i <= maxstep; i += stepsize) {
+            outputheader = outputheader + "," + i + "pct";
+        }
+        outputheader = outputheader + System.getProperty("line.separator");
+    }
+
+    public void setCity(String city) {
+        this.city = city;
+    }
+
+    public void setRouteType(String route_type) {
+        this.route_type = route_type;
+    }
+
+    public PathWrapper GPXToPath(ArrayList<GPXEntry> gpxEntries) {
+        PathWrapper matchGHRsp = new PathWrapper();
+        try {
+            MatchResult mr = mapMatching.doWork(gpxEntries);
+            Path path = mapMatching.calcPath(mr);
+            new PathMerger().doWork(matchGHRsp, Collections.singletonList(path), new TranslationMap().doImport().getWithFallBack(Locale.US));
+        }
+        catch (RuntimeException e) {
+            System.out.println("Broken GPX trace.");
+            System.out.println(e.getMessage());
+        }
+        return matchGHRsp;
+    }
+
+    public void PointsToPath(String fin, String fout) throws IOException {
+        Scanner sc_in = new Scanner(new File(fin));
+        String[] pointsHeader = sc_in.nextLine().split(",");
+        int idIdx = -1;
+        int nameIdx = -1;
+        int latIdx = -1;
+        int lonIdx = -1;
+        int timeIdx = -1;
+        for (int i=0; i<pointsHeader.length; i++) {
+            if (pointsHeader[i].equalsIgnoreCase("ID")) {
+                idIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("name")) {
+                nameIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("lat")) {
+                latIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("lon")) {
+                lonIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("millis")) {
+                timeIdx = i;
+            }
+            else {
+                System.out.println("Unexpected header value: " + pointsHeader[i]);
+            }
+        }
+        String optimized = "";
+        if (fin.indexOf("google") > -1) {
+            optimized = optimized + "Goog";
+        } else if (fin.indexOf("mapquest") > -1) {
+            optimized = optimized + "MapQ";
+        } else {
+            System.out.println("Don't recognize platform: " + fin);
+        }
+        if (fin.indexOf("alt") > -1) {
+            optimized = optimized + " altn";
+        } else if (fin.indexOf("main") > -1) {
+            optimized = optimized + " main";
+        } else {
+            System.out.println("Don't recognize route type: " + fin);
+        }
+        String line;
+        String[] vals;
+        String routeID = "";
+        String prevRouteID = "";
+        String name = "";
+        String prevName = "";
+        String label = "";
+        String prevLabel = "";
+        double lat;
+        double lon;
+        long time;
+        HashMap<String, ArrayList<GPXEntry>> pointsLists = new HashMap<>();
+        HashMap<String, String> routeNames = new HashMap<>();
+        ArrayList<GPXEntry> pointsList = new ArrayList<>();
+        while (sc_in.hasNext()) {
+            line = sc_in.nextLine();
+            vals = line.split(",");
+            routeID = vals[idIdx];
+            name = vals[nameIdx];
+            if (name.equalsIgnoreCase("alternative 2") || name.equalsIgnoreCase("alternative 3")) {
+                continue;
+            }
+            lat = Double.valueOf(vals[latIdx]);
+            lon = Double.valueOf(vals[lonIdx]);
+            time = Long.valueOf(vals[timeIdx]);
+            label = routeID + "|" + name;
+            GPXEntry pt = new GPXEntry(lat, lon, time);
+            if (label.equalsIgnoreCase(prevLabel)) {
+                pointsList.add(pt);
+            }
+            else if (pointsList.size() > 0) {
+                pointsLists.put(prevRouteID, pointsList);
+                routeNames.put(prevRouteID, prevName);
+                pointsList = new ArrayList<>();
+                pointsList.add(pt);
+            } else {
+                System.out.println("First point.");
+                pointsList.add(pt);
+            }
+            prevRouteID = routeID;
+            prevName = name;
+            prevLabel = label;
+        }
+        if (pointsList.size() > 0) {
+            pointsLists.put(prevRouteID, pointsList);
+            routeNames.put(prevRouteID, prevName);
+        }
+        sc_in.close();
+
+        ConcurrentHashMap<String, String> results = getPaths(pointsLists, routeNames, optimized);
+        FileWriter sc_out = new FileWriter(fout, true);
+        sc_out.write(outputheader);
+        for (String result : results.values()) {
+            sc_out.write(result);
+        }
+        sc_out.close();
+    }
+
+    public ConcurrentHashMap<String, String> getPaths(HashMap<String, ArrayList<GPXEntry>> pointLists, HashMap<String, String> routeNames, String optimized) {
+
+        AtomicInteger num_processed = new AtomicInteger();
+        int num_routes = pointLists.size();
+        Set<String> routeIDs = pointLists.keySet();
+
+        ConcurrentHashMap<String, String> results = new ConcurrentHashMap<>();
+        routeIDs.parallelStream().forEach(routeID -> {
+            System.out.println("Processing: " + routeID);
+            int i = num_processed.incrementAndGet();
+            PathWrapper path = GPXToPath(pointLists.get(routeID));
+            if (path.getDistance() > 0) {
+                float score = getBeauty(path);
+                results.put(routeID, writeOutput(routeID, new float[1], new int[1]));
+            }
+            if (i % 50 == 0) {
+                System.out.println(i + " of " + num_routes + " routes matched.");
+            }
+        }
+        );
+
+        return results;
+    }
+
+    //TODO: find some way to match path to virtual nodes at start/finish or hope map-matcher updates
+    public PathWrapper trimPath(PathWrapper path, ArrayList<GPXEntry> original) {
+        return new PathWrapper();
+    }
+
+
+    public void setDataSources() throws Exception {
+        if (city.equals("sf")) {
+            osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
+            graphFolder = graphFolder + "ghosm_sf_noch";
+            inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "sf_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "06075_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "06075_ct_grid.csv");
+        } else if (city.equals("nyc")) {
+            osmFile = osmFile + "new-york_new-york.osm.pbf";
+            graphFolder = graphFolder + "ghosm_nyc_noch";
+            inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "nyc_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "36005_logfractionempath_ft.csv");
+            gridValuesFNs.add(gvfnStem + "36047_logfractionempath_ft.csv");
+            gridValuesFNs.add(gvfnStem + "36061_logfractionempath_ft.csv");
+            gridValuesFNs.add(gvfnStem + "36081_logfractionempath_ft.csv");
+            gridValuesFNs.add(gvfnStem + "36085_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "nyc_ct_grid.csv");
+        } else if (city.equals("bos")) {
+            osmFile = osmFile + "boston_massachusetts.osm.pbf";
+            graphFolder = graphFolder + "ghosm_bos_noch";
+            inputPointsFN = inputPointsFN + "bos_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "bos_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
+            gridCTsFNs.add(gctfnStem + "25025_ct_grid.csv");
+        } else if (city.equals("chi")) {
+            osmFile = osmFile + "chicago_illinois.osm.pbf";
+            graphFolder = graphFolder + "ghosm_chi_noch";
+            inputPointsFN = inputPointsFN + "chi_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "chi_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "17031_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "17031_ct_grid.csv");
+        } else if (city.equals("sin")) {
+            osmFile = osmFile + "singapore.osm.pbf";
+            graphFolder = graphFolder + "ghosm_sin_noch";
+            inputPointsFN = inputPointsFN + "sin_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "sin_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "SINGAPORE_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "");
+        } else if (city.equals("lon")) {
+            osmFile = osmFile + "london_england.osm.pbf";
+            graphFolder = graphFolder + "ghosm_lon_noch";
+            inputPointsFN = inputPointsFN + "lon_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "lon_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "LONDON_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "");
+        } else if (city.equals("man")) {
+            osmFile = osmFile + "manila_philippines.osm.pbf";
+            graphFolder = graphFolder + "ghosm_man_noch";
+            inputPointsFN = inputPointsFN + "man_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "man_" + route_type + "_gh_routes.csv";
+            gridValuesFNs.add(gvfnStem + "MANILA_logfractionempath_ft.csv");
+            gridCTsFNs.add(gctfnStem + "");
+        } else {
+            throw new Exception("Invalid Parameters: city must be of 'SF','NYC', or 'BOS' and route_type of 'grid' or 'rand'");
+        }
+    }
+
+    public void getGridValues() throws Exception {
+        gvHeaderMap = new HashMap<>();
+        gridBeauty = new HashMap<>();
+
+        for (String fn : gridValuesFNs) {
+            try {
+                Scanner sc_in = new Scanner(new File(fn));
+                String[] gvHeader = sc_in.nextLine().split(",");
+                int i = 0;
+                for (String col : gvHeader) {
+                    gvHeaderMap.put(col, i);
+                    i++;
+                }
+                String line;
+                String[] vals;
+                String rc;
+                float beauty;
+                while (sc_in.hasNext()) {
+                    line = sc_in.nextLine();
+                    vals = line.split(",");
+                    try {
+                        rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
+                        beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
+                        gridBeauty.put(rc, beauty);
+                    } catch (NullPointerException ex) {
+                        System.out.println(ex.getMessage());
+                        System.out.println(line);
+                        continue;
+                    }
+                }
+            } catch (IOException io) {
+                System.out.println(io + ": " + fn + " does not exist.");
+            }
+        }
+    }
+
+    public void getGridCTs() throws Exception {
+        gridCT = new HashMap<>();
+        for (String fn : gridCTsFNs) {
+            try {
+                Scanner sc_in = new Scanner(new File(fn));
+                sc_in.nextLine();
+                String line;
+                String[] vals;
+                String rc;
+                int ct;
+                while (sc_in.hasNext()) {
+                    line = sc_in.nextLine();
+                    vals = line.split(",");
+                    try {
+                        rc = vals[1] + "," + vals[0];
+                        ct = Integer.valueOf(vals[2]);
+                        gridCT.put(rc, ct);
+                    } catch (NullPointerException ex) {
+                        System.out.println(ex.getMessage());
+                        System.out.println(line);
+                        continue;
+                    }
+                }
+
+            } catch (IOException io) {
+                System.out.println(io + ": " + fn + " does not exist.");
+            }
+        }
+    }
+
+    public void prepareGraphHopper() {
+        // create one GraphHopper instance
+        hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
+        hopper.setDataReaderFile(osmFile);
+        // where to store graphhopper files?
+        hopper.setGraphHopperLocation(graphFolder);
+        hopper.setEncodingManager(new EncodingManager("car"));
+
+        // now this can take minutes if it imports or a few seconds for loading
+        // of course this is dependent on the area you import
+        hopper.importOrLoad();
+    }
+
+    public void prepMapMatcher() {
+
+        // create MapMatching object, can and should be shared accross threads
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().
+                algorithm(Parameters.Algorithms.DIJKSTRA).
+                traversalMode(hopper.getTraversalMode()).
+                hints(new HintsMap().put("weighting", "fastest").put("vehicle", "car")).
+                build();
+        mapMatching = new MapMatching(hopper, algoOpts);
+        mapMatching.setTransitionProbabilityBeta(0.00959442);
+//        mapMatching.setTransitionProbabilityBeta(0.000959442);
+        mapMatching.setMeasurementErrorSigma(100);
+    }
+
+
+    public String writeOutput(String od_id, float[] scores, int[] bestindices) {
+
+        // preps output for CSV
+        String result = od_id;
+        int num_bins = bestindices.length;
+        for (int i = 0; i < num_bins; i++) {
+            try {
+                result = result + "," + scores[bestindices[i]];
+            } catch (ArrayIndexOutOfBoundsException ai) {
+                result = result + ",";
+                System.out.println(System.getProperty("line.separator") + System.getProperty("line.separator") + "ArrayIndexException: beauty" + System.getProperty("line.separator") + System.getProperty("line.separator"));
+            }
+        }
+        System.out.println(result);
+        return result + System.getProperty("line.separator");
+
+
+    }
+
+    public String writeOutput(String od_id, long[] scores, int[] bestindices) {
+
+        // preps output for CSV
+        String result = od_id;
+        int num_bins = bestindices.length;
+        for (int i = 0; i < num_bins; i++) {
+            try {
+                result = result + "," + scores[bestindices[i]];
+            } catch (ArrayIndexOutOfBoundsException ai) {
+                result = result + ",";
+                System.out.println(System.getProperty("line.separator") + System.getProperty("line.separator") + "ArrayIndexException: time" + System.getProperty("line.separator") + System.getProperty("line.separator"));
+            }
+        }
+        System.out.println(result);
+        return result + System.getProperty("line.separator");
+
+
+    }
+
+    public String writeOutput(String od_id, int[] scores, int[] bestindices) {
+
+        // preps output for CSV
+        String result = od_id;
+        int num_bins = bestindices.length;
+        for (int i = 0; i < num_bins; i++) {
+            try {
+                result = result + "," + scores[bestindices[i]];
+            } catch (ArrayIndexOutOfBoundsException ai) {
+                result = result + ",";
+                System.out.println(System.getProperty("line.separator") + System.getProperty("line.separator") + "ArrayIndexException: simplicity" + System.getProperty("line.separator") + System.getProperty("line.separator"));
+            }
+        }
+        System.out.println(result);
+        return result + System.getProperty("line.separator");
+
+
+    }
+
+    public int getNumCTs(PathWrapper path) {
+        if (gridCT.size() == 0) {
+            return -1;
+        }
+        HashSet<String> roundedPoints = path.roundPoints();
+        HashSet<Integer> cts = new HashSet<>();
+        for (String pt : roundedPoints) {
+            if (gridCT.containsKey(pt)) {
+                cts.add(gridCT.get(pt));
+            }
+        }
+        return cts.size();
+    }
+
+    public float getBeauty(PathWrapper path) {
+        HashSet<String> roundedPoints = path.roundPoints();
+        float score = 0;
+        for (String pt : roundedPoints) {
+            if (gridBeauty.containsKey(pt)) {
+                score = score + gridBeauty.get(pt);
+            }
+        }
+        score = score / roundedPoints.size();
+        return score;
+    }
+
+    public void setODPairs() throws Exception {
+        // Prep Filewriters (Optimized, Worst-but-same-distance, Fastest, Simplest)
+        for (String optimization : optimizations) {
+            outputFiles.put(optimization, new FileWriter(outputPointsFN.replaceFirst(".csv", "_optimize" + optimization + "tradeoff.csv"), true));
+        }
+
+        for (FileWriter fw : outputFiles.values()) {
+            fw.write(outputheader);
+        }
+
+        // Bring in origin-destination pairs for processing
+        Scanner sc_in = new Scanner(new File(inputPointsFN));
+        String header = sc_in.nextLine();
+        String od_id;
+        float laF;
+        float loF;
+        float laT;
+        float loT;
+        float idx = 0;
+        System.out.println("Input data points header: " + header);
+        while (sc_in.hasNext()) {
+            idx = idx + 1;
+            String line = sc_in.nextLine();
+            String[] vals = line.split(",");
+            od_id = vals[0];
+            loF = Float.valueOf(vals[1]);
+            laF = Float.valueOf(vals[2]);
+            loT = Float.valueOf(vals[3]);
+            laT = Float.valueOf(vals[4]);
+            inputPoints.add(new float[]{laF, loF, laT, loT, idx});
+            id_to_points.add(od_id);
+        }
+        int numPairs = inputPoints.size();
+        System.out.println(numPairs + " origin-destination pairs.");
+
+    }
+
+    public void process_routes() throws Exception {
+
+        AtomicInteger num_processed = new AtomicInteger();
+        int num_odpairs = id_to_points.size();
+
+        ConcurrentHashMap<String, ConcurrentHashMap<String, String>> results = new ConcurrentHashMap<>();
+        for (String optimization : optimizations) {
+            results.put(optimization, new ConcurrentHashMap<>());
+        }
+        id_to_points.parallelStream().forEach(od_id -> {
+            System.out.println("Processing: " + od_id);
+            int route = id_to_points.indexOf(od_id);
+            HashMap<String, String> routes = process_route(route);
+            for (String optimization : optimizations) {
+                results.get(optimization).put(od_id, routes.getOrDefault(optimization, "FAILURE"));
+            }
+            int i = num_processed.incrementAndGet();
+            if (i % 50 == 0) {
+                System.out.println(i + " of " + num_odpairs + " o-d pairs processed.");
+            }
+        }
+        );
+
+        for (String optimization : optimizations) {
+            for (String result : results.get(optimization).values()) {
+                outputFiles.get(optimization).write(result);
+            }
+            outputFiles.get(optimization).close();
+        }
+    }
+
+
+    public HashMap<String, String> process_route(int route) {
+        // Loop through origin-destination pairs, processing each one for beauty, non-beautiful matched, fastest, and simplest
+        float[] points;
+        String od_id;
+        HashMap<String, String> responses = new HashMap<>();
+
+        // Get Routes
+        points = inputPoints.get(route);
+        od_id = id_to_points.get(route);
+        GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
+                setWeighting("fastest").
+                setVehicle("car").
+                setLocale(Locale.US).
+                setAlgorithm("ksp");
+        GHResponse rsp = hopper.route(req);
+
+        String defaultRow = od_id;
+        for (int i = 0; i <= maxstep; i = i + stepsize) {
+            defaultRow = defaultRow + ",";
+        }
+        defaultRow = defaultRow + System.getProperty("line.separator");
+
+        // first check for errors
+        if (rsp.hasErrors()) {
+            // handle them!
+            System.out.println(rsp.getErrors().toString());
+            System.out.println(route + ": Error - skipping.");
+            for (String optimization : optimizations) {
+                responses.put(optimization, defaultRow);
+            }
+            return responses;
+        }
+
+        // Get All Routes (up to 10K right now)
+        List<PathWrapper> paths = rsp.getAll();
+        int numpaths = paths.size();
+
+        if (numpaths == 0) {
+            System.out.println(route + ": No paths - skipping.");
+            for (String optimization : optimizations) {
+                responses.put(optimization, defaultRow);
+            }
+            return responses;
+        }
+
+        /**
+         *   Algorithm Order:
+         *   1. Most Beautiful
+         *   2. Fastest
+         *   3. Vary Beauty/Fastest by 10%
+         *   4. Simplest
+         *   5. Vary Simplicity/Fastest by 10%
+         *
+         *   Metrics:
+         *   1. Time
+         *   2. What's being optimized - beauty or simplicity
+         *
+         */
+        float[] beautyscores = new float[numpaths];
+        long[] timescores = new long[numpaths];
+        int numbins = Math.floorDiv(maxstep, stepsize) + 1;
+        int[] bestindices = new int[numbins];
+
+        // Store beauty values for all routes and min/max
+        int j = 0;
+        int bestidx = 0;
+        int worstidx = 0;
+        for (PathWrapper path : paths) {
+            beautyscores[j] = getBeauty(path);
+            timescores[j] = path.getTime();
+            if (beautyscores[j] > beautyscores[bestidx]) {
+                bestidx = j;
+            } else if (beautyscores[j] < beautyscores[worstidx]) {
+                worstidx = j;
+            }
+            j++;
+        }
+        // 100% beauty = most beautiful route idx; 0% beauty is by default already 0, the fastest path
+        bestindices[numbins - 1] = bestidx;
+        // fastest path = 1st, slowest path = last
+        long fastest = paths.get(0).getTime();
+        long slowest = paths.get(numpaths - 1).getTime();
+
+        /*
+        long baselinetime = paths.get(0).getTime();
+        float baselinebeauty = getBeauty(paths.get(0));
+        int baselinesimplicity = paths.get(0).getSimplicity();
+
+        if (baselinebeauty == 0) {
+            int i = 1;
+            while (baselinebeauty == 0) {
+                baselinebeauty = getBeauty(paths.get(i));
+                i++;
+            }
+            System.out.println("\tUsed beauty for " + (i-1) + "th path for " + od_id);
+        }
+        */
+
+        // Loop through 10% to 90% weightings, scoring each route on beauty to determine most beautiful
+        for (int i = 1; i < numbins - 1; i = i + 1) {
+            float bestscore = -1;
+            float combinedscore;
+            float beautyscore;
+            float timescore;
+            int bestcomboidx = -1;
+            for (j=0; j<numpaths; j++) {
+                beautyscore = (beautyscores[j] - beautyscores[worstidx]) / (beautyscores[bestidx] - beautyscores[worstidx]);
+                timescore = 1 - (((float) timescores[j] - fastest) / (slowest - fastest));
+                combinedscore = (i * beautyscore) + ((stepsize - i) * timescore);
+                if (combinedscore > bestscore) {
+                    bestscore = combinedscore;
+                    bestcomboidx = j;
+                }
+            }
+            bestindices[i] = bestcomboidx;
+        }
+        responses.put("beauty_beauty", writeOutput(od_id, beautyscores, bestindices));
+        responses.put("beauty_time", writeOutput(od_id, timescores, bestindices));
+
+
+        /* Find least-beautiful route within similar distance constraints
+        double beautyDistance = paths.get(routeidx).getDistance();
+        j = 0;
+        bestscore = 1000;
+        routeidx = -1;
+        double uglydistance;
+        for (PathWrapper path : paths) {
+            uglydistance = path.getDistance();
+            if (uglydistance / beautyDistance < 1.05 && uglydistance / beautyDistance > 0.95) {
+                float score = getBeauty(path);
+                if (score < bestscore) {
+                    bestscore = score;
+                    routeidx = j;
+                }
+            }
+            j++;
+        }
+        responses.put("ugly", writeOutput(route, "Wrst", "ugly", od_id, paths.get(routeidx), bestscore, getNumCTs(paths.get(routeidx))));
+        */
+
+        // Simplest Route
+        int[] simplescores = new int[numpaths];
+        bestindices = new int[numbins];
+
+        // Store beauty values for all routes and min/max
+        j = 0;
+        bestidx = 0;
+        worstidx = 0;
+        for (PathWrapper path : paths) {
+            simplescores[j] = path.getSimplicity();
+            if (simplescores[j] < simplescores[bestidx]) {
+                bestidx = j;
+            } else if (simplescores[j] > simplescores[worstidx]) {
+                worstidx = j;
+            }
+            j++;
+        }
+        // 100% simple = simplest route idx; 0% simplicity is by default already 0, the fastest path
+        bestindices[numbins - 1] = bestidx;
+
+        // Loop through 10% to 90% weightings, scoring each route on beauty to determine most beautiful
+        for (int i = 1; i < numbins - 1; i = i + 1) {
+            float bestscore = -1;
+            float combinedscore;
+            float simplescore;
+            float timescore;
+            int bestcomboidx = -1;
+            for (j=0; j<numpaths; j++) {
+                simplescore = 1 - (((float) simplescores[j] - simplescores[bestidx]) / (simplescores[worstidx] - simplescores[bestidx]));
+                timescore = 1 - (((float) timescores[j] - fastest) / (slowest - fastest));
+                combinedscore = (i * simplescore) + ((stepsize - i) * timescore);
+                if (combinedscore > bestscore) {
+                    bestscore = combinedscore;
+                    bestcomboidx = j;
+                }
+            }
+            bestindices[i] = bestcomboidx;
+        }
+        responses.put("simple_simple", writeOutput(od_id, simplescores, bestindices));
+        responses.put("simple_time", writeOutput(od_id, timescores, bestindices));
+
+        /*
+        //System.out.println("Simplest route: " + routeidx);
+        responses.put("simple", writeOutput(route, "Simp", "simple", od_id, paths.get(routeidx), beauty, getNumCTs(paths.get(routeidx))));
+        float minSimplicity = bestscore;
+
+        // Fastest Route
+        PathWrapper bestPath = paths.get(0);
+        beauty = getBeauty(bestPath);
+        responses.put("fast", writeOutput(route, "Fast", "Fastest", od_id, bestPath, beauty, getNumCTs(bestPath)));
+
+        // Beautifully simple route
+        j = 0;
+        bestscore = 0;
+        routeidx = 0;
+        float combined;
+        for (PathWrapper path : paths) {
+            combined = (minSimplicity / path.getSimplicity()) + (getBeauty(path) / maxBeauty);
+            if (combined > bestscore) {
+                bestscore = combined;
+                routeidx = j;
+            }
+            j++;
+        }
+        //System.out.println("Most beautiful-simple route: " + routeidx);
+        responses.put("besi", writeOutput(route, "BeSi", "beauty-simple", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx)), getNumCTs(paths.get(routeidx))));
+        */
+
+        /* Fewest # directions
+        j = 0;
+        bestscore = 10000;
+        routeidx = 0;
+        InstructionList il;
+        int numDirections;
+        for (PathWrapper path : paths) {
+            il = path.getInstructions();
+            numDirections = il.getSize();
+            if (numDirections < bestscore) {
+                bestscore = numDirections;
+                routeidx = j;
+            }
+            j++;
+        }
+        responses.put("mindirections", writeOutput(route, "MnDi", "mindirections", od_id, paths.get(routeidx), getBeauty(paths.get(routeidx)), getNumCTs(paths.get(routeidx))));
+        */
+
+        /* Shortest Route
+        req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
+                setWeighting("shortest").
+                setVehicle("car").
+                setLocale(Locale.US).
+                setAlgorithm("dijkstrabi");
+        rsp = hopper.route(req);
+
+        // first check for errors
+        if (rsp.hasErrors()) {
+            // handle them!
+            System.out.println(rsp.getErrors().toString());
+            System.out.println(route + ": Skipping shortest path.");
+            responses.put("short", defaultRow);
+        } else {
+            // Get shortest path
+            bestPath = rsp.getBest();
+            beauty = getBeauty(bestPath);
+            responses.put("short", writeOutput(route, "Shrt", "shortest", od_id, bestPath, beauty, getNumCTs(bestPath)));
+        }
+         */
+
+        return responses;
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        // PBFs from: https://mapzen.com/data/metro-extracts/
+
+        //String city = args[0];
+        //String odtype = args[1];
+        String city = "lon";  // sf, nyc, chi, lon, man, sin
+        String odtype = "grid";  // grid, rand
+        parallelKSP_tradeoffs ksp = new parallelKSP_tradeoffs(city, odtype);
+        boolean getghroutes = true;
+
+        if (getghroutes) {
+            ksp.setDataSources();
+            ksp.getGridValues();
+            ksp.prepareGraphHopper();
+            //ksp.getGridCTs();
+            ksp.setODPairs();
+            ksp.process_routes();  // get Graphhopper routes
+        }
+    }
+}
