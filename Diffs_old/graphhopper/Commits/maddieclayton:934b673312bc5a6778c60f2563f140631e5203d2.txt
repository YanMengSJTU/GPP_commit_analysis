diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
old mode 100644
new mode 100755
index f7d7fef2b1..7cb1a87306
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -22,6 +22,8 @@
 import gnu.trove.map.hash.TIntObjectHashMap;
 
 import java.util.PriorityQueue;
+import java.util.HashMap;
+import java.util.List;
 
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
@@ -33,6 +35,11 @@
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 
+import com.graphhopper.safety.ColorMapParser;
+import com.graphhopper.safety.NodeInformation;
+import com.graphhopper.safety.OSMParser;
+import com.graphhopper.safety.Way;
+
 /**
  * This class implements the A* algorithm according to
  * http://en.wikipedia.org/wiki/A*_search_algorithm
@@ -92,6 +99,16 @@ public Path calcPath( int from, int to )
 
     private Path runAlgo()
     {
+        HashMap<Long, NodeInformation> nodeMap = new HashMap<Long, NodeInformation>();
+        HashMap<Long, Way> wayMap = new HashMap<Long, Way>();
+        HashMap<Long, HashMap<Long, Integer>> scores = new HashMap<Long, HashMap<Long, Integer>>();
+        double maxLong = -74.65986;
+        double minLat = 40.34993;
+        double minLong = -74.66236;
+        double maxLat = 40.35111;
+        OSMParser.parseFile(minLong, minLat, maxLong, maxLat, nodeMap, wayMap);
+        ColorMapParser.parseFile(nodeMap, wayMap, scores);
+
         double currWeightToGoal, estimationFullWeight;
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
@@ -112,7 +129,9 @@ private Path runAlgo()
 
                 int neighborNode = iter.getAdjNode();
                 int traversalId = traversalMode.createTraversalId(iter, false);
-                double alreadyVisitedWeight = weighting.calcWeight(iter, false, currEdge.edge)
+                int safetyWeight = ColorMapParser.getSafetyWeight((long) currVertex,
+                    (long) neighborNode, scores);
+                double alreadyVisitedWeight = (weighting.calcWeight(iter, false, currEdge.edge))*safetyWeight
                         + currEdge.weightOfVisitedPath;
                 if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
diff --git a/core/src/main/java/com/graphhopper/routing/safety/ColorInfo.xlsx b/core/src/main/java/com/graphhopper/routing/safety/ColorInfo.xlsx
new file mode 100644
index 0000000000..ca150d3d25
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/ColorInfo.xlsx differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.class b/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.class
new file mode 100644
index 0000000000..b234646cb5
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.class differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.java b/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.java
new file mode 100644
index 0000000000..93909ada87
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.java
@@ -0,0 +1,166 @@
+import org.apache.poi.xssf.usermodel.XSSFCell;
+import org.apache.poi.xssf.usermodel.XSSFRow;
+import org.apache.poi.xssf.usermodel.XSSFSheet;
+import org.apache.poi.xssf.usermodel.XSSFWorkbook;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+public class ColorMapParser {
+
+    public static void parseFile(HashMap<Long, NodeInformation> nodeMap, 
+        HashMap<Long, Way> wayMap, HashMap<Long, HashMap<Long, Integer>> scores) {
+        try {
+            File file = new File("ColorInfo.xlsx");
+            FileInputStream fs = new FileInputStream(file);
+            XSSFWorkbook wb = new XSSFWorkbook(fs);
+            XSSFSheet sheet = wb.getSheetAt(0);
+            XSSFRow row;
+            XSSFCell cell;
+
+            int rows; // No of rows
+            rows = sheet.getPhysicalNumberOfRows();
+
+            int cols = 4; // No of columns
+
+            for(int r = 0; r < rows; r++) {
+                row = sheet.getRow(r);
+                boolean found = false;
+                Way way = new Way(0);
+                boolean unchangedScore = false;
+                long startNode = 0;
+                long endNode = 0;
+                if(row != null) {
+                    for(int c = 0; c < cols; c++) {
+                        cell = row.getCell((short)c);
+                        if (cell == null) {
+                        	break;
+                        }
+                        if (c == 0) {
+                        	for (long l : wayMap.keySet()) {
+                        		if (cell.toString().equals(wayMap.get(l).getName())) {
+                        			way = wayMap.get(l);
+                        			if (way.getIsRoad()) {
+                        				found = true;
+                        			}
+                        		}
+                        	}
+                        }
+                        if (c == 1) {
+                        	if (cell.getCellType() == XSSFCell.CELL_TYPE_BLANK) {
+                        		unchangedScore = true;
+                        	}
+                        	else {
+                        		for (long id : way.getRefs()) {
+                        			for (Way way1 : nodeMap.get(id).getWays()) {
+                        				if (cell.toString().equals(way1.getName())) {
+                        					startNode = way1.getWayId();
+                        				}
+                        			}
+                        		}
+                        	}
+                        }
+                        if (c == 2) {
+                        	if (cell.getCellType() == XSSFCell.CELL_TYPE_BLANK) {
+                        		unchangedScore = true;
+                        	}
+                        	else {
+                        		for (long id : way.getRefs()) {
+                        			for (Way way1 : nodeMap.get(id).getWays()) {
+                        				if (cell.toString().equals(way1.getName())) {
+                        					endNode = way1.getWayId();
+                        				}
+                        			}
+                        		}
+                        	}
+                        }
+                        if (c == 3) {
+                        	int score = (int) Double.parseDouble(cell.toString());
+                        	if (found) {
+                        		if (unchangedScore) {
+                        			for (long id : way.getRefs()) {
+                        				for (long id1 : way.getRefs()) {
+                        					if (id != id1) {
+                        						if (scores.containsKey(id)) {
+                        							HashMap<Long, Integer> temp = scores.get(id);
+                        							temp.put(id1, score);
+                        							scores.put(id, temp);
+                        						}
+                        						else {
+                        							HashMap<Long, Integer> temp = new HashMap<Long, Integer>();
+                        							temp.put(id1, score);
+                        							scores.put(id, temp);
+                        						}
+                        					}
+                        				}
+                        			}
+                        		}
+                        		else {
+                        			boolean inPath = false;
+                        			List<Long> references = new ArrayList<Long>();
+                        			for (long id : way.getRefs()) {
+                        				if ((id == startNode || id == endNode)) {
+                        					inPath = !inPath;
+                        					references.add(id);
+                        				}
+                        				else if (inPath) {
+                        					references.add(id);
+                        				}
+                        			}
+                        			for (long id : references) {
+                        				for (long id1 : references) {
+                        					if (id != id1) {
+                        						if (scores.containsKey(id)) {
+                        							HashMap<Long, Integer> temp = scores.get(id);
+                        							temp.put(id1, score);
+                        							scores.put(id, temp);
+                        						}
+                        						else {
+                        							HashMap<Long, Integer> temp = new HashMap<Long, Integer>();
+                        							temp.put(id1, score);
+                        							scores.put(id, temp);
+                        						}
+                        					}
+                        				}
+                        			}
+                        		}
+                        	}
+                        }
+                    }
+                }
+            }
+            wb.close();
+        } catch(Exception ioe) {
+            ioe.printStackTrace();
+        }
+    }
+
+    public static int getSafetyWeight(long first, long second, HashMap<Long, HashMap<Long, Integer>> scores) {
+        for (long l : scores.keySet()) {
+            if (first == l) {
+                for (long l1 : scores.get(l).keySet()) {
+                    if (second == l1) {
+                        return scores.get(l).get(l1);
+                    }
+                }
+            }
+        }
+        return 4;
+    }
+
+    public static void main(String[] args) {
+        HashMap<Long, NodeInformation> nodeMap = new HashMap<Long, NodeInformation>();
+        HashMap<Long, Way> wayMap = new HashMap<Long, Way>();
+        HashMap<Long, HashMap<Long, Integer>> scores = new HashMap<Long, HashMap<Long, Integer>>();
+        double maxLong = -74.65986;
+        double minLat = 40.34993;
+        double minLong = -74.66236;
+        double maxLat = 40.35111;
+        OSMParser.parseFile(minLong, minLat, maxLong, maxLat, nodeMap, wayMap);
+        parseFile(nodeMap, wayMap, scores);
+    	System.out.println(getSafetyWeight(103994789, 104040288, scores));
+    }
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/safety/EndpointParser.java b/core/src/main/java/com/graphhopper/routing/safety/EndpointParser.java
new file mode 100644
index 0000000000..ffe5d34c69
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/safety/EndpointParser.java
@@ -0,0 +1,73 @@
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class EndpointParser {
+
+    public static NodeInformation findEndpoint(String query) {
+    	String key = "01fa5850-2d3d-407f-ba51-123944197407";
+    	String limit = "1";
+    	try {
+    		URL yahoo = new URL("https://graphhopper.com/api/1/geocode?q=" + query + "&limit=" 
+    			+ limit + "&debug=true&key=" + key);
+    		URLConnection yc = yahoo.openConnection();
+    		BufferedReader in = new BufferedReader(
+                                new InputStreamReader(
+                                yc.getInputStream()));
+    		String inputLine;
+	      	
+	      	long nodeID = 0;
+	      	double lat = 0;
+	      	double lng = 0;
+	      	String unparsedStreet = "";
+        	while ((inputLine = in.readLine()) != null) {
+        		String pattern = "osm_id\": [0-9]*,";
+		    	Pattern r = Pattern.compile(pattern);
+	      		Matcher m = r.matcher(inputLine);
+        		if (m.find()) {
+        			nodeID = Long.parseLong(m.group(0).substring(9, m.group(0).length()-1));
+	      		}
+        		pattern = "lng\": -?[0-9]*.[0-9]*,";
+		    	r = Pattern.compile(pattern);
+	      		m = r.matcher(inputLine);
+        		if (m.find()) {
+        			lng = Double.parseDouble(m.group(0).substring(6, m.group(0).length()-1));
+	      		}
+        		pattern = "lat\": -?[0-9]*.[0-9]*";
+		    	r = Pattern.compile(pattern);
+	      		m = r.matcher(inputLine);
+        		if (m.find()) {
+        			lat = Double.parseDouble(m.group(0).substring(6, m.group(0).length()));
+	      		}
+        		pattern = "street\": \".*\"";
+		    	r = Pattern.compile(pattern);
+	      		m = r.matcher(inputLine);
+        		if (m.find()) {
+        			unparsedStreet = m.group(0).substring(10, m.group(0).length()-1);
+	      		}
+	        }
+        	in.close();
+        	NodeInformation ni = new NodeInformation(nodeID);
+        	ni.addLat(lat);
+        	ni.addLong(lng);
+        	ni.addUnparsedStreet(unparsedStreet);
+        	return ni;
+    	} catch (MalformedURLException e) {
+			e.printStackTrace();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+		return null;
+    }
+
+    public static void main(String[] args) {
+    	String query = "Pyne%20Hall%2008544";
+    	findEndpoint(query);
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/safety/Navigation.java b/core/src/main/java/com/graphhopper/routing/safety/Navigation.java
new file mode 100644
index 0000000000..c2e73afcca
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/safety/Navigation.java
@@ -0,0 +1,44 @@
+import java.util.HashMap;
+
+public class Navigation {
+	public static Way getClosestRoadNode(NodeInformation ni, 
+			HashMap<Long, Way> wayMap, HashMap<Long, NodeInformation> nodeMap) {
+		Way nodeWay = new Way(0);
+		for (long id : wayMap.keySet()) {
+			if (ni.getUnparsedStreet().equals(wayMap.get(id).getName())) {
+				nodeWay = wayMap.get(id);
+				break;
+			}
+		}
+		return nodeWay;
+	}
+	
+	public static void main(String[] args) {
+		// Find start and end points
+		String start = "Halo%20Pub%02008540";
+		String end = "J%20Crew%2008540";
+    	NodeInformation startPoint = EndpointParser.findEndpoint(start);
+    	NodeInformation endPoint = EndpointParser.findEndpoint(end);
+    	
+    	// Create box
+    	double topLong = Math.max(startPoint.getLong(), endPoint.getLong());
+		double bottomLat = Math.min(startPoint.getLat(), endPoint.getLat());
+		double bottomLong = Math.min(startPoint.getLong(), endPoint.getLong());
+		double topLat = Math.max(startPoint.getLat(), endPoint.getLat());
+		double distance = NodeInformation.findDistance(startPoint, endPoint);
+		double maxLong = topLong + distance;
+		double minLong = bottomLong - distance;
+		double maxLat = topLat + distance;
+		double minLat = bottomLat - distance;
+		
+		// Parse information in box given
+		HashMap<Long, NodeInformation> nodeMap = new HashMap<Long, NodeInformation>();
+    	HashMap<Long, Way> wayMap = new HashMap<Long, Way>();
+    	HashMap<Long, HashMap<Long, Integer>> scores = new HashMap<Long, HashMap<Long, Integer>>();
+		OSMParser.parseFile(minLong, minLat, maxLong, maxLat, nodeMap, wayMap);
+		ColorMapParser.parseFile(nodeMap, wayMap, scores);
+		
+		Way nearestToStart = getClosestRoadNode(startPoint, wayMap, nodeMap);
+		Way nearestToEnd = getClosestRoadNode(endPoint, wayMap, nodeMap);
+	}
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/safety/NodeInformation.class b/core/src/main/java/com/graphhopper/routing/safety/NodeInformation.class
new file mode 100644
index 0000000000..cc714881a9
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/NodeInformation.class differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/NodeInformation.java b/core/src/main/java/com/graphhopper/routing/safety/NodeInformation.java
new file mode 100644
index 0000000000..2989122d58
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/safety/NodeInformation.java
@@ -0,0 +1,73 @@
+import java.util.ArrayList;
+import java.util.List;
+
+public class NodeInformation {
+
+	private List<Way> ways = new ArrayList<Way>();
+	private String unparsedStreet = "";
+	private long id = 0;
+	private double wayLat = 0;
+	private double wayLong = 0;
+	private boolean isRoad = false;
+
+	public NodeInformation(long nodeID) {
+		id = nodeID;
+	}
+	
+	public long getId() {
+		return id;
+	}
+	
+	public void addUnparsedStreet(String street) {
+		unparsedStreet = street;
+	}
+	
+	public String getUnparsedStreet() {
+		return unparsedStreet;
+	}
+
+	public void addWay(Way way) {
+		ways.add(way);
+	}
+	
+	public List<Way> getWays() {
+		return ways;
+	}
+
+	public void addLat(double wayLatitude) {
+		wayLat = wayLatitude;
+	}
+	
+	public double getLat() {
+		return wayLat;
+	}
+
+	public void addLong(double wayLongitude) {
+		wayLong = wayLongitude;
+	}
+	
+	public double getLong() {
+		return wayLong;
+	}
+
+	public void setIsRoad(boolean nodeIsRoad) {
+		isRoad = nodeIsRoad;
+	}
+	
+	public boolean getIsRoad() {
+		return isRoad;
+	}
+
+	public static double findDistance(NodeInformation n1, NodeInformation n2) {
+		double length = Math.abs(n1.wayLat - n2.wayLat);
+		double width = Math.abs(n1.wayLong - n2.wayLong);
+		return Math.sqrt(length*length + width*width);
+	}
+
+	public static void main(String[] args) {
+		NodeInformation ni = new NodeInformation(1);
+		Way way = new Way(1);
+		ni.addWay(way);
+		System.out.println(ni.ways);
+	}
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/safety/OSMParser.class b/core/src/main/java/com/graphhopper/routing/safety/OSMParser.class
new file mode 100644
index 0000000000..eade80298e
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/OSMParser.class differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/OSMParser.java b/core/src/main/java/com/graphhopper/routing/safety/OSMParser.java
new file mode 100644
index 0000000000..02a33d45ee
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/safety/OSMParser.java
@@ -0,0 +1,160 @@
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.HashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class OSMParser {
+
+	public static void parseFile(double minLong, double minLat, double maxLong, double maxLat, 
+		HashMap<Long, NodeInformation> nodeMap, HashMap<Long, Way> wayMap) {
+		try {
+    		URL yahoo = new URL("https://api.openstreetmap.org/api/0.6/map?bbox=" 
+    			+ minLong + "," + minLat + "," + maxLong + "," + maxLat);
+    		URLConnection yc = yahoo.openConnection();
+    		BufferedReader in = new BufferedReader(
+                                new InputStreamReader(
+                                yc.getInputStream()));
+    		String inputLine;
+	      	
+        	while ((inputLine = in.readLine()) != null) {
+        		// Parse nodes
+        		String pattern = "<node.*>";
+		    	Pattern r = Pattern.compile(pattern);
+	      		Matcher m = r.matcher(inputLine);
+        		if (m.find()) {
+        			// Create node with correct id
+        			pattern = "id=\"[0-9]*\"";
+		    		r = Pattern.compile(pattern);
+	      			m = r.matcher(inputLine);
+        			if (m.find()) {
+        				long nodeID = 
+        					Long.parseLong(m.group(0).substring(4, m.group(0).length()-1));
+        				NodeInformation node = new NodeInformation(nodeID);
+
+        				// Add latitude and longitude
+        				pattern = "lat=\"-?[0-9]*.[0-9]*\"";
+		    			r = Pattern.compile(pattern);
+	      				m = r.matcher(inputLine);
+        				if (m.find()) {
+        					double lat = Double.parseDouble(
+        						m.group(0).substring(5, m.group(0).length()-1));
+        					node.addLat(lat);
+        				}
+        				else {
+        					System.out.println("Latitude not found for node: " + nodeID);
+        				}
+        				pattern = "lon=\"-?[0-9]*.[0-9]*\"";
+		    			r = Pattern.compile(pattern);
+	      				m = r.matcher(inputLine);
+        				if (m.find()) {
+        					double longitude = Double.parseDouble(
+        						m.group(0).substring(5, m.group(0).length()-1));
+        					node.addLong(longitude);
+        				}
+        				else {
+        					System.out.println("Longitude not found for node: " + nodeID);
+        				}
+
+        				nodeMap.put(nodeID, node);
+        			}
+        			else {
+        				System.out.println("ID not found for node: " + inputLine);
+        			}
+	      		}
+
+        		// Parse ways
+        		pattern = "<way.*>";
+		    	r = Pattern.compile(pattern);
+	      		m = r.matcher(inputLine);
+        		if (m.find()) {
+        			// make new Way with correct id
+        			Way way = new Way(0);
+        			pattern = "id=\"[0-9]*\"";
+		    		r = Pattern.compile(pattern);
+	      			m = r.matcher(inputLine);
+	      			long wayID = 0;
+        			if (m.find()) {
+        				wayID = Long.parseLong(
+        					m.group(0).substring(4, m.group(0).length()-1));
+        				way = new Way(wayID);
+        			}
+        			while ((inputLine = in.readLine()) != null) {
+        				// Check for end
+        				pattern = "</way>";
+        				r = Pattern.compile(pattern);
+        				m = r.matcher(inputLine);
+	         			if (m.find()) {
+	         				break;
+	         			}
+
+	         			// Check for name
+        				pattern = "\"name\"";
+        				r = Pattern.compile(pattern);
+        				m = r.matcher(inputLine);
+	         			if (m.find()) {
+	         				pattern = "v=\".*\"";
+        					r = Pattern.compile(pattern);
+        					m = r.matcher(inputLine);
+        					if (m.find()) {
+        						String name = m.group(0).substring(3, m.group(0).length()-1);
+	         					way.addName(name);
+	         				}
+	         			}
+
+	         			// Add references to correct nodes
+	         			pattern = "ref=\"[0-9]*\"";
+        				r = Pattern.compile(pattern);
+        				m = r.matcher(inputLine);
+	         			if (m.find()) {
+        					long ref = Long.parseLong(
+        						m.group(0).substring(5, m.group(0).length()-1));
+        					way.addReference(ref);
+        					if (nodeMap.containsKey(ref)) {
+        						NodeInformation ni = nodeMap.get(ref);
+        						ni.addWay(way);
+        						nodeMap.put(ref, ni);
+        					}
+        					else {
+        						System.out.println("No node found for ref: " + ref);
+        					}
+	         			}
+
+	         			// Add isStreet info to ways
+	         			pattern = "highway";
+        				r = Pattern.compile(pattern);
+        				m = r.matcher(inputLine);
+        				if (m.find()) {
+        					way.setIsRoad(true);
+        				}
+
+        				wayMap.put(wayID, way);
+	         		}
+	      		}
+	        }
+        	in.close();
+    	} catch (MalformedURLException e) {
+			e.printStackTrace();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public static void main(String[] args) {
+		HashMap<Long, NodeInformation> nodeMap = new HashMap<Long, NodeInformation>();
+		HashMap<Long, Way> wayMap = new HashMap<Long, Way>();
+		double maxLong = -74.65986;
+		double minLat = 40.34993;
+		double minLong = -74.66236;
+		double maxLat = 40.35111;
+		parseFile(minLong, minLat, maxLong, maxLat, nodeMap, wayMap);
+		for (long l : wayMap.keySet()) {
+			System.out.println(wayMap.get(l).getName() + " " + wayMap.get(l).getIsRoad());
+		}
+	}
+
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/safety/Way.class b/core/src/main/java/com/graphhopper/routing/safety/Way.class
new file mode 100644
index 0000000000..fe0144c6e1
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/Way.class differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/Way.java b/core/src/main/java/com/graphhopper/routing/safety/Way.java
new file mode 100644
index 0000000000..da9eca0b13
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/safety/Way.java
@@ -0,0 +1,42 @@
+import java.util.ArrayList;
+import java.util.List;
+
+public class Way{
+
+	private List<Long> references = new ArrayList<Long>();
+	private String name = "Untitled Road";
+	private long id = 0;
+	private boolean isRoad = false;
+
+	public Way(long wayId) {
+		id = wayId;
+	}
+	
+	public long getWayId() {
+		return id;
+	}
+
+	public void addReference(long refId) {
+		references.add(refId);
+	}
+	
+	public List<Long> getRefs() {
+		return references;
+	}
+
+	public void addName(String wayName) {
+		name = wayName;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public void setIsRoad(boolean wayIsRoad) {
+		isRoad = wayIsRoad;
+	}
+
+	public boolean getIsRoad() {
+		return isRoad;
+	}
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/safety/poi-3.13-20150929.jar b/core/src/main/java/com/graphhopper/routing/safety/poi-3.13-20150929.jar
new file mode 100644
index 0000000000..a9e3800852
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/poi-3.13-20150929.jar differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/poi-examples-3.13-20150929.jar b/core/src/main/java/com/graphhopper/routing/safety/poi-examples-3.13-20150929.jar
new file mode 100644
index 0000000000..a500614448
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/poi-examples-3.13-20150929.jar differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/poi-excelant-3.13-20150929.jar b/core/src/main/java/com/graphhopper/routing/safety/poi-excelant-3.13-20150929.jar
new file mode 100644
index 0000000000..6b8750c529
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/poi-excelant-3.13-20150929.jar differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/poi-ooxml-3.13-20150929.jar b/core/src/main/java/com/graphhopper/routing/safety/poi-ooxml-3.13-20150929.jar
new file mode 100644
index 0000000000..726768cfd7
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/poi-ooxml-3.13-20150929.jar differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/poi-ooxml-schemas-3.13-20150929.jar b/core/src/main/java/com/graphhopper/routing/safety/poi-ooxml-schemas-3.13-20150929.jar
new file mode 100644
index 0000000000..bd883978b3
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/poi-ooxml-schemas-3.13-20150929.jar differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/poi-scratchpad-3.13-20150929.jar b/core/src/main/java/com/graphhopper/routing/safety/poi-scratchpad-3.13-20150929.jar
new file mode 100644
index 0000000000..735eb7ded0
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/poi-scratchpad-3.13-20150929.jar differ
diff --git a/core/src/main/java/com/graphhopper/routing/safety/xmlbeans-2.6.0.jar b/core/src/main/java/com/graphhopper/routing/safety/xmlbeans-2.6.0.jar
new file mode 100644
index 0000000000..d1b66271f5
Binary files /dev/null and b/core/src/main/java/com/graphhopper/routing/safety/xmlbeans-2.6.0.jar differ
