diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 9d656156d6..35b7d4979a 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -6,6 +6,7 @@
  * b3nn0, Android improvements
  * boldtrn, motorcycle improvements
  * cgarreau, increase of routing success rate via subnetwork cleanup
+ * ChristianSeitzer motorcycle improvements
  * daisy1754, fixed usage of graphhopper.sh script
  * dardin88, instructions improved
  * dewos, web API bug fixes
@@ -16,6 +17,7 @@
  * lmar, improved instructions information
  * florent-morel, improvements regarding fords, #320
  * fredao, translations 
+ * HarelM, improvements regarding elevation
  * henningvs, doc improvements
  * jansoe, many improvements regarding A* algorithm, forcing direction, roundabouts etc
  * jansonhanson, general host config
@@ -29,6 +31,7 @@
  * rajanski, script to do routing via PostGIS
  * rodneyodonnell, improved dead end removal and fords
  * rodo, more descriptions
+ * seeebiii motorcycle improvements
  * Svantulden, improved documentation and nearest API
  * vvikas, ideas for many to many improvements
 
diff --git a/core/files/N48W125.hgt.zip b/core/files/N48W125.hgt.zip
new file mode 100644
index 0000000000..815c82541f
Binary files /dev/null and b/core/files/N48W125.hgt.zip differ
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index b7b44f0f85..2886e43905 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,5 @@
 0.6
+    more strict naming for Weighting enforced and more strict matching to select Weighting (equals check), #490
     specify the preferred-language for way names during graph import (ISO 639-1 or ISO 639-2)
 
 0.5
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index d928d3c393..b8ab0d58d3 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -302,7 +302,7 @@ private GraphHopper setUnsafeMemory()
     public GraphHopper setCHWeighting( String weighting )
     {
         ensureNotLoaded();
-        chWeightingStr = weighting;
+        chWeightingStr = weighting.toLowerCase();
         return this;
     }
 
@@ -952,18 +952,18 @@ public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder
         }
 
         throw new UnsupportedOperationException("weighting " + weighting + " not supported");
-
     }
 
     public Weighting getWeightingForCH( WeightingMap weightingMap, FlagEncoder encoder )
     {
-        String encoderStr = encoder.toString().toLowerCase();
+        // get requested weighting name
         String weightingStr = weightingMap.getWeighting().toLowerCase();
+        if (weightingStr.isEmpty())
+            weightingStr = chWeightingStr;
+        
         for (Weighting w : algoFactories.keySet())
         {
-            // TODO too loose matching? see #490
-            String str = w.toString().toLowerCase();
-            if (str.contains(weightingStr) && str.contains(encoderStr))
+            if (w.matches(weightingStr, encoder))
                 return w;
         }
 
@@ -1184,7 +1184,7 @@ protected void prepare()
                 if (!(entry.getValue() instanceof PrepareContractionHierarchies))
                     throw new IllegalStateException("RoutingAlgorithmFactory is not suited for CH preparation " + entry.getValue());
 
-                final String name = CHGraphImpl.weightingToFileName(entry.getKey());
+                final String name = AbstractWeighting.weightingToFileName(entry.getKey());
                 chPreparePool.execute(new Runnable()
                 {
                     @Override
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index d3da6895c3..05901a6958 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -142,7 +142,7 @@ protected BufferedImage makeARGB()
         int height = width;
         BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
         Graphics g = argbImage.getGraphics();
-        long len = heights.getCapacity() / 2;
+        long len = width * width;
         for (int i = 0; i < len; i++)
         {
             int lonSimilar = i % width;
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index 596e00c82b..ec7a9b27fb 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -64,7 +64,8 @@ public static void main( String[] args ) throws IOException
 
     private static final BitUtil BIT_UTIL = BitUtil.BIG;
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final int WIDTH = 1201;
+    private final int DEFAULT_WIDTH = 1201;
+    private final int WIDTH_BYTE_INDEX = 0;
     private Directory dir;
     private DAType daType = DAType.MMAP;
     private Downloader downloader = new Downloader("GraphHopper SRTMReader").setTimeout(10000);
@@ -100,9 +101,9 @@ private SRTMProvider init()
         try
         {
             String strs[] =
-                    {
-                            "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
-                    };
+            {
+                "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
+            };
             for (String str : strs)
             {
                 InputStream is = getClass().getResourceAsStream(str + "_names.txt");
@@ -221,91 +222,102 @@ public double getEle( double lat, double lon )
         lon = (int) (lon * precision) / precision;
         int intKey = calcIntKey(lat, lon);
         HeightTile demProvider = cacheData.get(intKey);
-        if (demProvider == null)
+        if (demProvider != null)
+            return demProvider.getHeight(lat, lon);
+
+        if (!cacheDir.exists())
+            cacheDir.mkdirs();
+
+        String fileDetails = getFileString(lat, lon);
+        if (fileDetails == null)
+            return 0;
+
+        DataAccess heights = getDirectory().find("dem" + intKey);
+        boolean loadExisting = false;
+        try
         {
-            if (!cacheDir.exists())
-                cacheDir.mkdirs();
-
-            String fileDetails = getFileString(lat, lon);
-            if (fileDetails == null)
-                return 0;
-
-            int minLat = down(lat);
-            int minLon = down(lon);
-            demProvider = new HeightTile(minLat, minLon, WIDTH, precision, 1);
-            demProvider.setCalcMean(calcMean);
-            cacheData.put(intKey, demProvider);
-            DataAccess heights = getDirectory().find("dem" + intKey);
-            demProvider.setHeights(heights);
-            boolean loadExisting = false;
-            try
-            {
-                loadExisting = heights.loadExisting();
-            } catch (Exception ex)
+            loadExisting = heights.loadExisting();
+        } catch (Exception ex)
+        {
+            logger.warn("cannot load dem" + intKey + ", error:" + ex.getMessage());
+        }
+
+        if (!loadExisting)
+            updateHeightsFromZipFile(fileDetails, heights);
+
+        int width = (int) (Math.sqrt(heights.getHeader(WIDTH_BYTE_INDEX)) + 0.5);
+        if (width == 0)
+            width = DEFAULT_WIDTH;
+
+        demProvider = new HeightTile(down(lat), down(lon), width, precision, 1);
+        demProvider.setCalcMean(calcMean);
+        cacheData.put(intKey, demProvider);
+        demProvider.setHeights(heights);
+        return demProvider.getHeight(lat, lon);
+    }
+
+    private void updateHeightsFromZipFile( String fileDetails, DataAccess heights ) throws RuntimeException
+    {
+        try
+        {
+            byte[] bytes = getByteArrayFromZipFile(fileDetails);
+            heights.create(bytes.length);
+            for (int bytePos = 0; bytePos < bytes.length; bytePos += 2)
             {
-                logger.warn("cannot load dem" + intKey + ", error:" + ex.getMessage());
+                short val = BIT_UTIL.toShort(bytes, bytePos);
+                if (val < -1000 || val > 12000)
+                    val = Short.MIN_VALUE;
+
+                heights.setShort(bytePos, val);
             }
+            heights.setHeader(WIDTH_BYTE_INDEX, bytes.length / 2);
+            heights.flush();
+
+        } catch (Exception ex)
+        {
+            throw new RuntimeException(ex);
+        }
+    }
 
-            if (!loadExisting)
+    private byte[] getByteArrayFromZipFile( String fileDetails ) throws InterruptedException, FileNotFoundException, IOException
+    {
+        String zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
+        File file = new File(cacheDir, new File(zippedURL).getName());
+        InputStream is;
+        // get zip file if not already in cacheDir - unzip later and in-memory only!
+        if (!file.exists())
+            for (int i = 0; i < 3; i++)
             {
-                byte[] bytes = new byte[2 * WIDTH * WIDTH];
-                heights.create(bytes.length);
                 try
                 {
-                    String zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
-                    File file = new File(cacheDir, new File(zippedURL).getName());
-                    InputStream is;
-                    // get zip file if not already in cacheDir - unzip later and in-memory only!
-                    if (!file.exists())
-                    {
-                        for (int i = 0; i < 3; i++)
-                        {
-                            try
-                            {
-                                downloader.downloadFile(zippedURL, file.getAbsolutePath());
-                                break;
-                            } catch (SocketTimeoutException ex)
-                            {
-                                // just try again after a little nap
-                                Thread.sleep(2000);
-                                continue;
-                            } catch (FileNotFoundException ex)
-                            {
-                                // now try different URL (without point!), necessary if mirror is used
-                                zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
-                                continue;
-                            }
-                        }
-                    }
-
-                    is = new FileInputStream(file);
-                    ZipInputStream zis = new ZipInputStream(is);
-                    zis.getNextEntry();
-                    BufferedInputStream buff = new BufferedInputStream(zis);
-                    int len;
-                    while ((len = buff.read(bytes)) > 0)
-                    {
-                        for (int bytePos = 0; bytePos < len; bytePos += 2)
-                        {
-                            short val = BIT_UTIL.toShort(bytes, bytePos);
-                            if (val < -1000 || val > 12000)
-                                val = Short.MIN_VALUE;
-
-                            heights.setShort(bytePos, val);
-                        }
-                    }
-                    heights.flush();
-
-                    // demProvider.toImage("x" + file.getName() + ".png");
-                    // TODO remove hgt and zip?
-                } catch (Exception ex)
+                    downloader.downloadFile(zippedURL, file.getAbsolutePath());
+                    break;
+                } catch (SocketTimeoutException ex)
                 {
-                    throw new RuntimeException(ex);
+                    // just try again after a little nap
+                    Thread.sleep(2000);
+                    continue;
+                } catch (FileNotFoundException ex)
+                {
+                    // now try different URL (without point!), necessary if mirror is used
+                    zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
+                    continue;
                 }
-            } // loadExisting
-        }
+            }
 
-        return demProvider.getHeight(lat, lon);
+        is = new FileInputStream(file);
+        ZipInputStream zis = new ZipInputStream(is);
+        zis.getNextEntry();
+        BufferedInputStream buff = new BufferedInputStream(zis);
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        byte[] buffer = new byte[0xFFFF];
+        int len;
+        while ((len = buff.read(buffer)) > 0)
+        {
+            os.write(buffer, 0, len);
+        }
+        os.flush();
+        return os.toByteArray();
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index 662d58eda1..12bf1d27fb 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -62,8 +62,14 @@ public FlagEncoder getFlagEncoder()
     }
 
     @Override
-    public String toString()
+    public boolean matches( String weightingAsStr, FlagEncoder encoder )
     {
-        return "PREPARE+" + userWeighting.toString();
+        return userWeighting.getName().equals(weightingAsStr) && encoder == userWeighting.getFlagEncoder();
+    }
+
+    @Override
+    public String getName()
+    {
+        return "prepare|" + userWeighting.getName();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 237e159dc2..d7bd68c839 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -97,7 +97,7 @@ public PrepareContractionHierarchies( Directory dir, GraphHopperStorage ghStorag
         levelFilter = new LevelEdgeFilter(prepareGraph);
 
         prepareWeighting = new PreparationWeighting(weighting);
-        originalEdges = dir.find("original_edges_" + CHGraphImpl.weightingToFileName(weighting));
+        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
         originalEdges.create(1000);
     }
 
@@ -1004,6 +1004,6 @@ public String toString()
     @Override
     public String toString()
     {
-        return "PREPARE|CH|dijkstrabi";
+        return "prepare|CH|dijkstrabi";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractWeighting.java b/core/src/main/java/com/graphhopper/routing/util/AbstractWeighting.java
new file mode 100644
index 0000000000..a13b26bf88
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractWeighting.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2015 peterk.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public abstract class AbstractWeighting implements Weighting
+{
+    protected final FlagEncoder flagEncoder;
+
+    public AbstractWeighting( FlagEncoder encoder )
+    {
+        this.flagEncoder = encoder;
+        if (!flagEncoder.isRegistered())
+            throw new IllegalStateException("Make sure you add the FlagEncoder " + flagEncoder + " to an EncodingManager before using it elsewhere");
+        if (!isValidName(getName()))
+            throw new IllegalStateException("Not a valid name for a Weighting: " + getName());
+    }
+
+    @Override
+    public boolean matches( String weightingAsStr, FlagEncoder encoder )
+    {
+        return getName().equals(weightingAsStr) && encoder == flagEncoder;
+    }
+
+    @Override
+    public FlagEncoder getFlagEncoder()
+    {
+        return flagEncoder;
+    }
+
+    @Override
+    public int hashCode()
+    {
+        int hash = 7;
+        hash = 71 * hash + toString().hashCode();
+        return hash;
+    }
+
+    @Override
+    public boolean equals( Object obj )
+    {
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        final Weighting other = (Weighting) obj;
+        return toString().equals(other.toString());
+    }
+
+    static final boolean isValidName( String name )
+    {
+        if (name == null || name.isEmpty())
+            return false;
+
+        return name.matches("[\\|_a-z]+");
+    }
+
+    /**
+     * Replaces all characters which are not numbers, characters or underscores with underscores
+     */
+    public static String weightingToFileName( Weighting w )
+    {
+        return w.toString().toLowerCase().replaceAll("\\|", "_");
+    }
+
+    @Override
+    public String toString()
+    {
+        return getName() + "|" + flagEncoder;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/CurvatureWeighting.java b/core/src/main/java/com/graphhopper/routing/util/CurvatureWeighting.java
index 2ce1e68e36..2b9d92070a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CurvatureWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CurvatureWeighting.java
@@ -63,8 +63,8 @@ protected double getRoadSpeed( EdgeIteratorState edge, boolean reverse )
     }
 
     @Override
-    public String toString()
+    public String getName()
     {
-        return "CURVATURE|" + flagEncoder;
+        return "curvature";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index 1bb441021a..0e5772ce61 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -27,7 +27,7 @@
  *
  * @author Peter Karich
  */
-public class FastestWeighting implements Weighting
+public class FastestWeighting extends AbstractWeighting
 {
     /**
      * Converting to seconds is not necessary but makes adding other penalities easier (e.g. turn
@@ -35,17 +35,13 @@
      */
     protected final static double SPEED_CONV = 3.6;
     final static double DEFAULT_HEADING_PENALTY = 300; //[s]
-    private final double heading_penalty;
-    protected final FlagEncoder flagEncoder;
+    private final double headingPenalty;
     private final double maxSpeed;
 
     public FastestWeighting( FlagEncoder encoder, PMap pMap )
     {
-        if (!encoder.isRegistered())
-            throw new IllegalStateException("Make sure you add the FlagEncoder " + encoder + " to an EncodingManager before using it elsewhere");
-
-        this.flagEncoder = encoder;
-        heading_penalty = pMap.getDouble("heading_penalty", DEFAULT_HEADING_PENALTY);
+        super(encoder);
+        headingPenalty = pMap.getDouble("heading_penalty", DEFAULT_HEADING_PENALTY);
         maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
 
@@ -72,39 +68,14 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
         // add direction penalties at start/stop/via points
         boolean penalizeEdge = edge.getBoolean(EdgeIteratorState.K_UNFAVORED_EDGE, reverse, false);
         if (penalizeEdge)
-            time += heading_penalty;
+            time += headingPenalty;
 
         return time;
     }
 
     @Override
-    public FlagEncoder getFlagEncoder()
-    {
-        return flagEncoder;
-    }
-
-    @Override
-    public int hashCode()
-    {
-        int hash = 7;
-        hash = 71 * hash + toString().hashCode();
-        return hash;
-    }
-
-    @Override
-    public boolean equals( Object obj )
-    {
-        if (obj == null)
-            return false;
-        if (getClass() != obj.getClass())
-            return false;
-        final FastestWeighting other = (FastestWeighting) obj;
-        return toString().equals(other.toString());
-    }
-
-    @Override
-    public String toString()
+    public String getName()
     {
-        return "FASTEST|" + flagEncoder;
+        return "fastest";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
index 6ac03176b3..2609e46fc2 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWeighting.java
@@ -25,19 +25,11 @@
  * <p>
  * @author Peter Karich
  */
-public class ShortestWeighting implements Weighting
+public class ShortestWeighting extends AbstractWeighting
 {
-    private final FlagEncoder flagEncoder;
-
     public ShortestWeighting( FlagEncoder flagEncoder )
     {
-        this.flagEncoder = flagEncoder;
-    }
-
-    @Override
-    public FlagEncoder getFlagEncoder()
-    {
-        return flagEncoder;
+        super(flagEncoder);
     }
 
     @Override
@@ -53,8 +45,8 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
     }
 
     @Override
-    public String toString()
+    public String getName()
     {
-        return "SHORTEST|" + flagEncoder;
+        return "shortest";
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
index 3fd4efd813..0c7436b706 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
@@ -103,8 +103,15 @@ public FlagEncoder getFlagEncoder()
     }
 
     @Override
-    public String toString()
+    public boolean matches( String weightingAsStr, FlagEncoder encoder )
     {
-        return "TURN|" + superWeighting.toString();
+        // TODO without 'turn' in comparison
+        return superWeighting.matches(weightingAsStr, encoder);
+    }
+
+    @Override
+    public String getName()
+    {
+        return "turn|" + superWeighting.getName();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/Weighting.java b/core/src/main/java/com/graphhopper/routing/util/Weighting.java
index 04e3074c14..6490c89c51 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Weighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Weighting.java
@@ -45,4 +45,11 @@
     double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId );
 
     FlagEncoder getFlagEncoder();
+
+    String getName();
+
+    /**
+     * Returns true if the specified weighting and encoder matches to this Weighting.
+     */
+    boolean matches( String weightingAsStr, FlagEncoder encoder );
 }
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index 1f4f4a0ed7..fd5293477c 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -18,10 +18,7 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.routing.ch.PrepareEncoder;
-import com.graphhopper.routing.util.AllCHEdgesIterator;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.BaseGraph.AllEdgeIterator;
 import com.graphhopper.storage.BaseGraph.CommonEdgeIterator;
 import com.graphhopper.storage.BaseGraph.EdgeIterable;
@@ -64,7 +61,7 @@
 
         this.weighting = w;
         this.baseGraph = baseGraph;
-        final String name = CHGraphImpl.weightingToFileName(w);
+        final String name = AbstractWeighting.weightingToFileName(w);
         this.nodesCH = dir.find("nodes_ch_" + name);
         this.shortcuts = dir.find("shortcuts_" + name);
         this.chEdgeAccess = new EdgeAccess(shortcuts, baseGraph.bitUtil)
@@ -136,14 +133,6 @@ public final Weighting getWeighting()
         return weighting;
     }
 
-    /**
-     * Replaces all characters which are not numbers, characters or underscores with underscores
-     */
-    public static String weightingToFileName( Weighting w )
-    {
-        return w.toString().toLowerCase().replaceAll("\\W+", "_");
-    }
-
     @Override
     public boolean isShortcut( int edgeId )
     {
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index 79aa608512..b5f6a327b2 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -867,7 +867,7 @@ public void testMultipleCHPreparationsInParallel()
                 PrepareContractionHierarchies pch = (PrepareContractionHierarchies) raf;
                 assertTrue("Preparation wasn't run! [" + threadCount + "]", pch.isPrepared());
 
-                String name = CHGraphImpl.weightingToFileName(pch.getWeighting());
+                String name = AbstractWeighting.weightingToFileName(pch.getWeighting());
                 Integer singleThreadShortcutCount = shortcutCountMap.get(name);
                 if (singleThreadShortcutCount == null)
                     shortcutCountMap.put(name, pch.getShortcuts());
@@ -885,4 +885,36 @@ public void testMultipleCHPreparationsInParallel()
             tmpGH.close();
         }
     }
+
+    class TestEncoder extends CarFlagEncoder
+    {
+        private final String name;
+
+        public TestEncoder( String name )
+        {
+            this.name = name;
+        }
+
+        @Override
+        public String toString()
+        {
+            return name;
+        }
+    }
+
+    @Test
+    public void testGetWeightingForCH()
+    {
+        GraphHopper hopper = new GraphHopper();
+        TestEncoder truck = new TestEncoder("truck");
+        TestEncoder sTruck = new TestEncoder("simple_truck");
+
+        // use simple truck first
+        new EncodingManager(sTruck, truck);
+        hopper.putAlgorithmFactory(new FastestWeighting(sTruck), new RoutingAlgorithmFactorySimple());
+        hopper.putAlgorithmFactory(new FastestWeighting(truck), new RoutingAlgorithmFactorySimple());
+
+        assertEquals("fastest|truck", hopper.getWeightingForCH(new WeightingMap("fastest"), truck).toString());
+        assertEquals("fastest|simple_truck", hopper.getWeightingForCH(new WeightingMap("fastest"), sTruck).toString());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
index 30f2439d3a..952f9b3f02 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
@@ -93,6 +93,15 @@ public void testGetHeight() throws IOException
         // assertEquals(161, instance.getEle(55.8943144, -3.0000001), 1e-1);
     }
 
+    @Test
+    public void testGetHeight_issue545() throws IOException
+    {
+        instance.setCacheDir(new File("./files/"));
+
+        // test different precision of the elevation file (3600)
+        assertEquals(84, instance.getEle(48.003878, -124.660492), 1e-1);
+    }
+
     @Test
     public void testGetHeightMMap() throws IOException
     {
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 7e0f7c8a40..f114e59777 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -737,7 +737,6 @@ public void testTwoWeightsPerEdge2()
         // other direction should be different!
         Weighting fakeWeighting = new Weighting()
         {
-
             @Override
             public FlagEncoder getFlagEncoder()
             {
@@ -772,6 +771,18 @@ else if (adj == 4)
 
                 return edgeState.getDistance() * 0.8;
             }
+
+            @Override
+            public boolean matches( String weightingAsStr, FlagEncoder encoder )
+            {
+                throw new UnsupportedOperationException("Not supported");
+            }
+
+            @Override
+            public String getName()
+            {
+                return "custom";
+            }
         };
 
         AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(defaultOpts.getWeighting()).build();
@@ -794,7 +805,7 @@ else if (adj == 4)
         assertEquals(37009621, p.getTime());
         assertEquals(616827, p.getDistance(), 1);
         assertEquals(493462, p.getWeight(), 1);
-    }        
+    }
 
     @Test
     public void testMultipleVehicles_issue548()
@@ -802,7 +813,7 @@ public void testMultipleVehicles_issue548()
         FastestWeighting footWeighting = new FastestWeighting(footEncoder);
         AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
                 weighting(footWeighting).build();
-        
+
         FastestWeighting carWeighting = new FastestWeighting(carEncoder);
         AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
                 weighting(carWeighting).build();
@@ -810,13 +821,13 @@ public void testMultipleVehicles_issue548()
         GraphHopperStorage ghStorage = createGHStorage(encodingManager,
                 Arrays.asList(footOptions.getWeighting(), carOptions.getWeighting()), false);
         initFootVsCar(ghStorage);
-        
+
         // normal path would be 0-4-6-7 but block 4-6
         GHUtility.getEdge(ghStorage, 4, 6).setFlags(carEncoder.setProperties(20, false, false));
-        
+
         RoutingAlgorithm algoFoot = createFactory(ghStorage, footOptions).
                 createAlgo(getGraph(ghStorage, footWeighting), footOptions);
-                        
+
         RoutingAlgorithm algoCar = createFactory(ghStorage, carOptions).
                 createAlgo(getGraph(ghStorage, carWeighting), carOptions);
         Path p1 = algoCar.calcPath(0, 7);
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index e4e6b9b153..2542b07d9e 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -68,8 +68,8 @@ public void testPathRecursiveUnpacking()
     {
         // use an encoder where it is possible to store 2 weights per edge        
         FlagEncoder encoder = new Bike2WeightFlagEncoder();
-        ShortestWeighting weighting = new ShortestWeighting(encoder);
         EncodingManager em = new EncodingManager(encoder);
+        ShortestWeighting weighting = new ShortestWeighting(encoder);
         GraphHopperStorage ghStorage = createGHStorage(em, Arrays.asList(weighting), false);
         CHGraphImpl g2 = (CHGraphImpl) ghStorage.getGraph(CHGraph.class, weighting);
         g2.edge(0, 1, 1, true);
@@ -118,10 +118,12 @@ public void testPathRecursiveUnpacking()
     public void testBaseGraph()
     {
         CarFlagEncoder carFE = new CarFlagEncoder();
+        EncodingManager em = new EncodingManager(carFE);
         AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carFE).
                 weighting(new ShortestWeighting(carFE)).build();
-        GraphHopperStorage ghStorage = createGHStorage(new EncodingManager(carFE),
+        GraphHopperStorage ghStorage = createGHStorage(em,
                 Arrays.asList(opts.getWeighting()), false);
+
         initDirectedAndDiffSpeed(ghStorage, carFE);
 
         // do CH preparation for car        
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index a9ab59dadc..dea0c775c2 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -435,4 +435,17 @@ public void testBarrierAccess()
         // no barrier!
         assertTrue(encoder.handleNodeTags(node) == 0);
     }
+
+    @Test
+    public void testBarrierAccessFord()
+    {
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("ford", "yes");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        node.setTag("bicycle", "yes");
+        // no barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/AbstractWeightingTest.java
new file mode 100644
index 0000000000..a3bc4c8ce1
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractWeightingTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015 peterk.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class AbstractWeightingTest
+{
+    @Test
+    public void testToString()
+    {
+        assertTrue(AbstractWeighting.isValidName("blup"));
+        assertTrue(AbstractWeighting.isValidName("blup_a"));
+        assertTrue(AbstractWeighting.isValidName("blup|a"));
+        assertFalse(AbstractWeighting.isValidName("Blup"));
+        assertFalse(AbstractWeighting.isValidName("Blup!"));
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index 7636e6ac76..6fba55f9b2 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -511,7 +511,7 @@ public void testBarrierAccess()
     }
 
     @Test
-    public void testclassBicycle()
+    public void testClassBicycle()
     {
         OSMWay way = new OSMWay(1);
         way.setTag("highway", "tertiary");
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index fb3e38cdff..e84f759031 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -233,11 +233,11 @@ public void testPriority()
         way.setTag("bicycle", "official");
         way.setTag("sidewalk", "no");
         assertEquals(PriorityCode.AVOID_IF_POSSIBLE.getValue(), footEncoder.handlePriority(way, 0));
-        
+
         way.clearTags();
-        way.setTag("highway", "residential");        
+        way.setTag("highway", "residential");
         way.setTag("sidewalk", "yes");
-        assertEquals(PriorityCode.PREFER.getValue(), footEncoder.handlePriority(way, 0));                
+        assertEquals(PriorityCode.PREFER.getValue(), footEncoder.handlePriority(way, 0));
     }
 
     @Test
@@ -335,6 +335,10 @@ public void testFord()
         node.setTag("ford", "yes");
         assertTrue(footEncoder.handleNodeTags(node) > 0);
 
+        node.setTag("foot", "yes");
+        // no barrier!
+        assertTrue(footEncoder.handleNodeTags(node) == 0);
+
         // Now let's allow fords for foot
         footEncoder.setBlockFords(Boolean.FALSE);
 
diff --git a/graphhopper.sh b/graphhopper.sh
index 0daca4f5b9..2738698996 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -79,7 +79,7 @@ function ensureMaven {
   # maven home existent?
   if [ "$MAVEN_HOME" = "" ]; then
     # not existent but probably is maven in the path?
-    MAVEN_HOME=$(mvn -v | grep "Maven home" | cut -d' ' -f3)
+    MAVEN_HOME=$(mvn -v | grep "Maven home" | cut -d' ' -f3,4,5,6)
     if [ "$MAVEN_HOME" = "" ]; then
       # try to detect previous downloaded version
       MAVEN_HOME="$GH_HOME/maven"
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 1a640dd27d..f05070fae5 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -476,17 +476,17 @@ function initMap(selectLayer) {
 //        attribution: osmAttr + ', <a href="http://www.alberding.eu/">&copy; Alberding GmbH, CC-BY-SA</a>'
 //    });
 
-    var thunderTransport = L.tileLayer('http://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png', {
+    var thunderTransport = L.tileLayer('https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png', {
         attribution: osmAttr + ', <a href="http://www.thunderforest.com/transport/" target="_blank">Thunderforest Transport</a>',
         subdomains: ['a', 'b', 'c']
     });
 
-    var thunderCycle = L.tileLayer('http://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png', {
+    var thunderCycle = L.tileLayer('https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png', {
         attribution: osmAttr + ', <a href="http://www.thunderforest.com/opencyclemap/" target="_blank">Thunderforest Cycle</a>',
         subdomains: ['a', 'b', 'c']
     });
 
-    var thunderOutdoors = L.tileLayer('http://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png', {
+    var thunderOutdoors = L.tileLayer('https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png', {
         attribution: osmAttr + ', <a href="http://www.thunderforest.com/outdoors/" target="_blank">Thunderforest Outdoors</a>',
         subdomains: ['a', 'b', 'c']
     });
