diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index 052ec9b6e8..bcb7d833bd 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -813,12 +813,21 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
             towerNodeDistance = 0.0001;
         }
 
-        if (Double.isInfinite(towerNodeDistance) || Double.isNaN(towerNodeDistance))
+        double maxDistance = (Integer.MAX_VALUE - 1) / 1000d;
+        if (Double.isNaN(towerNodeDistance))
         {
             logger.warn("Bug in OSM or GraphHopper. Illegal tower node distance " + towerNodeDistance + " reset to 1m, osm way " + wayOsmId);
             towerNodeDistance = 1;
         }
 
+        if (Double.isInfinite(towerNodeDistance) || towerNodeDistance > maxDistance)
+        {
+            // Too large is very rare and often the wrong tagging. See #435 
+            // so we can avoid the complexity of splitting the way for now (new towernodes would be required, splitting up geometry etc)
+            logger.warn("Bug in OSM or GraphHopper. Too big tower node distance " + towerNodeDistance + " reset to large value, osm way " + wayOsmId);
+            towerNodeDistance = maxDistance;
+        }
+
         EdgeIteratorState iter = graph.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
 
         if (nodes > 2)
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTagParser.java b/core/src/main/java/com/graphhopper/reader/OSMTagParser.java
index 2863ef6c9e..9f56b3de73 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTagParser.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTagParser.java
@@ -22,7 +22,8 @@
 import javax.xml.datatype.Duration;
 
 /**
- *
+ * This class currently parses the duration tag only.
+ * <p/>
  * @author ratrun
  */
 public class OSMTagParser
@@ -43,7 +44,7 @@ public static long parseDuration( String str ) throws IllegalArgumentException
         // Check for ISO_8601 format
         if (str.startsWith("P"))
         {
-                // A common mistake is the the minutes format is intended but month format specified 
+            // A common mistake is when the minutes format is intended but the month format is specified 
             // e.g. one month "P1M" is set, but on minute "PT1M" is meant.
             Duration dur;
             try
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
index a0d81fa620..27ad34115c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -25,6 +25,8 @@
 import com.graphhopper.util.PointList;
 
 import static com.graphhopper.util.Helper.*;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Stores two speed values into an edge to support avoiding too much incline
@@ -172,10 +174,8 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
             double fullDist2D = edge.getDistance();
 
             if (Double.isInfinite(fullDist2D))
-            {
-                System.err.println("infinity distance? for way:" + way.getId());
-                return;
-            }
+                throw new IllegalStateException("Infinite distance should not happen due to #435. OSMID=" + way.getId());
+
             // for short edges an incline makes no sense and for 0 distances could lead to NaN values for speed, see #432
             if (fullDist2D < 1)
                 return;
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 07a0e5a4eb..c0c29b9460 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -73,9 +73,9 @@
     final NodeAccess nodeAccess;
     final GraphExtension extStorage;
     // length | nodeA | nextNode | ... | nodeB
-    // as we use integer index in 'egdes' area => 'geometry' area is limited to 2GB (currently ~311M for world wide)
-    final DataAccess wayGeometry;
-    private int maxGeoRef;
+    // as we use integer index in 'egdes' area => 'geometry' area is limited to 4GB (we use pos&neg values!)
+    private final DataAccess wayGeometry;
+    private long maxGeoRef;
     final NameIndex nameIndex;
     final BitUtil bitUtil;
     private final Directory dir;
@@ -220,13 +220,14 @@ protected int setEdgesHeader()
 
     protected int loadWayGeometryHeader()
     {
-        maxGeoRef = wayGeometry.getHeader(0);
+        maxGeoRef = bitUtil.combineIntsToLong(wayGeometry.getHeader(0), wayGeometry.getHeader(4));
         return 1;
     }
 
     protected int setWayGeometryHeader()
     {
-        wayGeometry.setHeader(0, maxGeoRef);
+        wayGeometry.setHeader(0, bitUtil.getIntLow(maxGeoRef));
+        wayGeometry.setHeader(4, bitUtil.getIntHigh(maxGeoRef));
         return 1;
     }
 
@@ -824,8 +825,8 @@ private void setWayGeometry_( PointList pillarNodes, long edgePointer, boolean r
 
             int len = pillarNodes.getSize();
             int dim = nodeAccess.getDimension();
-            int tmpRef = nextGeoRef(len * dim);
-            edges.setInt(edgePointer + E_GEO, tmpRef);
+            long tmpRef = nextGeoRef(len * dim);
+            edges.setInt(edgePointer + E_GEO, Helper.toSignedInt(tmpRef));
             long geoRef = (long) tmpRef * 4;
             byte[] bytes = new byte[len * dim * 4 + 4];
             ensureGeometry(geoRef, bytes.length);
@@ -859,15 +860,15 @@ private void setWayGeometry_( PointList pillarNodes, long edgePointer, boolean r
 
     private PointList fetchWayGeometry_( long edgePointer, boolean reverse, int mode, int baseNode, int adjNode )
     {
-        long geoRef = edges.getInt(edgePointer + E_GEO);
+        long geoRef = Helper.toUnsignedLong(edges.getInt(edgePointer + E_GEO));
         int count = 0;
         byte[] bytes = null;
         if (geoRef > 0)
         {
-            geoRef *= 4;
+            geoRef *= 4L;
             count = wayGeometry.getInt(geoRef);
 
-            geoRef += 4;
+            geoRef += 4L;
             bytes = new byte[count * nodeAccess.getDimension() * 4];
             wayGeometry.getBytes(geoRef, bytes, bytes.length);
         } else if (mode == 0)
@@ -944,11 +945,13 @@ private void ensureGeometry( long bytePos, int byteLength )
         wayGeometry.ensureCapacity(bytePos + byteLength);
     }
 
-    private int nextGeoRef( int arrayLength )
+    private long nextGeoRef( int arrayLength )
     {
-        int tmp = maxGeoRef;
-        // one more integer to store also the size itself
-        maxGeoRef += arrayLength + 1;
+        long tmp = maxGeoRef;
+        maxGeoRef += arrayLength + 1L;
+        if (maxGeoRef >= 0xFFFFffffL)
+            throw new IllegalStateException("Geometry too large, does not fit in 32 bits " + maxGeoRef);
+
         return tmp;
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
index c8a978d537..74325e0167 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
@@ -29,6 +29,7 @@
 {
     // distance of around +-1000 000 meter are ok
     private static final double INT_DIST_FACTOR = 1000d;
+    static double MAX_DIST = (Integer.MAX_VALUE - 1) / INT_DIST_FACTOR;
     static final int NO_NODE = -1;
     int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS;
     final DataAccess edges;
@@ -83,15 +84,9 @@ private int distToInt( double distance )
     {
         int integ = (int) (distance * INT_DIST_FACTOR);
         if (integ < 0)
-            throw new IllegalArgumentException("Distance cannot be empty: "
-                    + distance + ", maybe overflow issue? integer: " + integ);
-
-        // Due to rounding errors e.g. when getting the distance from another DataAccess object
-        // the following exception is not a good idea: 
-        // Allow integ to be 0 only if distance is 0
-        // if (integ == 0 && distance > 0)
-        //    throw new IllegalStateException("Distance wasn't 0 but converted integer was: " + 
-        //            distance + ", integer: " + integ);
+            throw new IllegalArgumentException("Distance cannot be negative: " + distance);
+        if (integ >= Integer.MAX_VALUE)
+            throw new IllegalArgumentException("Distance too large leading to overflowed integer (#435): " + distance + " ");
         return integ;
     }
 
@@ -101,9 +96,7 @@ private int distToInt( double distance )
     final double getDist( long pointer )
     {
         int val = edges.getInt(pointer + E_DIST);
-        if (val == Integer.MAX_VALUE)
-            return Double.POSITIVE_INFINITY;
-
+        // do never return infinity even if INT MAX, see #435
         return val / INT_DIST_FACTOR;
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 796634dc59..7d2a7f28a9 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -53,7 +53,7 @@
     public static final String OS_VERSION = System.getProperty("os.version");
     public static final String JAVA_VENDOR = System.getProperty("java.vendor");
     public static final int VERSION_NODE = 4;
-    public static final int VERSION_EDGE = 12;
+    public static final int VERSION_EDGE = 13;
     public static final int VERSION_SHORTCUT = 1;
     public static final int VERSION_GEOMETRY = 3;
     public static final int VERSION_LOCATION_IDX = 2;
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 8441d2da10..b876f9b920 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -17,7 +17,15 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
+import com.sun.org.apache.bcel.internal.generic.AASTORE;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
 
@@ -509,4 +517,21 @@ public static DateFormat createFormatter()
         df.setTimeZone(TimeZone.getTimeZone("UTC"));
         return df;
     }
+
+    /**
+     * This method handles the specified (potentially negative) int as unsigned bit representation
+     * and returns the positive converted long.
+     */
+    public static final long toUnsignedLong( int x )
+    {
+        return ((long) x) & 0xFFFFffffL;
+    }
+
+    /**
+     * Converts the specified long back into a signed int (reverse method for toUnsignedLong)
+     */
+    public static final int toSignedInt( long x )
+    {
+        return (int) x;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMTagParserTest.java b/core/src/test/java/com/graphhopper/reader/OSMTagParserTest.java
index be2a8bc832..8e0691eab9 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMTagParserTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMTagParserTest.java
@@ -23,7 +23,8 @@
 
 /**
  *
- * @author Peter Karich, ratrun
+ * @author Peter Karich
+ * @author ratrun
  */
 public class OSMTagParserTest
 {
@@ -38,8 +39,14 @@ public void testParseDuration()
         assertEquals(60 * 20 * 60, OSMTagParser.parseDuration("20:00"));
         assertEquals(20 * 60, OSMTagParser.parseDuration("0:20:00"));
         assertEquals((60 * 2 + 20) * 60 + 2, OSMTagParser.parseDuration("02:20:02"));
-        assertTrue(87840 * 60 <= OSMTagParser.parseDuration("P2M"));
-        assertTrue(87900 * 60 >= OSMTagParser.parseDuration("P2M"));
+
+        // two months, see #588
+        // 28+31
+        assertTrue(2 * 28 * 24 * 60 * 60 <= OSMTagParser.parseDuration("P2M"));
+        // 31+31
+        assertTrue(2 * 31 * 24 * 60 * 60 >= OSMTagParser.parseDuration("P2M"));
+
+        // two minutes
         assertEquals(2 * 60, OSMTagParser.parseDuration("PT2M"));
         assertEquals((5 * 60 + 12) * 60 + 36, OSMTagParser.parseDuration("PT5H12M36S"));
     }
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index 1da02770cd..ae2cf22354 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -85,12 +85,22 @@ public void tearDown()
     }
 
     @Test
-    public void testInfinityWeight()
+    public void testSetTooBigDistance_435()
     {
         graph = createGHStorage();
-        EdgeIteratorState edge = graph.edge(0, 1);
-        edge.setDistance(Double.POSITIVE_INFINITY);
-        assertTrue(Double.isInfinite(edge.getDistance()));
+
+        double maxDist = EdgeAccess.MAX_DIST;
+        EdgeIteratorState edge1 = graph.edge(0, 1, maxDist, true);
+        assertEquals(maxDist, edge1.getDistance(), 1);
+
+        // max out should NOT lead to infinity as this leads fast to NaN!
+        try
+        {
+            graph.edge(0, 2, maxDist + 1, true);
+        } catch (Exception ex)
+        {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Distance too large"));
+        }
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/HelperTest.java b/core/src/test/java/com/graphhopper/util/HelperTest.java
index 082bad914b..b9b46c0c44 100644
--- a/core/src/test/java/com/graphhopper/util/HelperTest.java
+++ b/core/src/test/java/com/graphhopper/util/HelperTest.java
@@ -102,4 +102,27 @@ public void testLoadProperties() throws IOException
         assertEquals("test", map.get("blup"));
         assertEquals("xy", map.get("blup2"));
     }
+
+    @Test
+    public void testUnsignedConversions()
+    {
+        long l = Helper.toUnsignedLong(-1);
+        assertEquals(4294967295L, l);
+        assertEquals(-1, Helper.toSignedInt(l));
+
+        int intVal = Integer.MAX_VALUE;
+        long maxInt = (long) intVal;
+        assertEquals(intVal, Helper.toSignedInt(maxInt));
+
+        intVal++;
+        maxInt = Helper.toUnsignedLong(intVal);
+        assertEquals(intVal, Helper.toSignedInt(maxInt));
+
+        intVal++;
+        maxInt = Helper.toUnsignedLong(intVal);
+        assertEquals(intVal, Helper.toSignedInt(maxInt));
+
+        assertEquals(0xFFFFffffL, (1L << 32) - 1);
+        assertTrue(0xFFFFffffL > 0L);
+    }
 }
diff --git a/docs/core/translations.md b/docs/core/translations.md
index 2cc52cb92a..1bc0133098 100644
--- a/docs/core/translations.md
+++ b/docs/core/translations.md
@@ -9,6 +9,8 @@ and add a column for your language. Revisit it regularly to update or add new it
 
 de -> German, en -> Englisch, zh -> Simplified Chinese, ...
 
+There are already many existing :jp: :cn: :us: :fr: :es: :it: :ru: :de:
+
 ## Questions
 
  1. **What does the string after the language name mean ala 'Spanish: es'?**
