diff --git a/core/pom.xml b/core/pom.xml
index 5a04549e57..a21cb212c9 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -6,26 +6,26 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-core</artifactId>
     <name>GraphHopper</name>
-    <version>0.8-SNAPSHOT</version>
-    <packaging>jar</packaging> 
+    <version>0.8-SNAPSHOT-GRAB</version>
+    <packaging>jar</packaging>
     <description>
-        GraphHopper is a fast and memory efficient Java road routing engine 
+        GraphHopper is a fast and memory efficient Java road routing engine
         working seamlessly with OpenStreetMap data.
     </description>
     <parent>
         <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
+        <artifactId>graphhopper-parent</artifactId>
         <version>0.8-SNAPSHOT</version>
     </parent>
-        
+
     <properties>
-        <netbeans.hint.license>apache20</netbeans.hint.license>        
+        <netbeans.hint.license>apache20</netbeans.hint.license>
         <!-- Make sure that we use the same format as for Helper.createFormatter.
              We cannot force the UTC TimeZone so it will just throw away the local offset or is this
              fixed due to https://issues.apache.org/jira/browse/MNG-5647 ?
         -->
-        <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ss'Z'</maven.build.timestamp.format>        
-        <builddate>${maven.build.timestamp}</builddate>        
+        <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ss'Z'</maven.build.timestamp.format>
+        <builddate>${maven.build.timestamp}</builddate>
     </properties>
     <licenses>
         <license>
@@ -34,20 +34,20 @@
             <distribution>repo</distribution>
             <comments>A business-friendly OSS license</comments>
         </license>
-    </licenses> 
+    </licenses>
     <dependencies>
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>graphhopper-tools-lgpl</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
-        
-        <!-- Trove is LGPL and slightly big (~3MB) -->        
+
+        <!-- Trove is LGPL and slightly big (~3MB) -->
         <dependency>
             <groupId>net.sf.trove4j</groupId>
             <artifactId>trove4j</artifactId>
             <version>3.0.3</version>
-        </dependency>        
+        </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
@@ -61,7 +61,7 @@
             <scope>test</scope>
         </dependency>
         -->
-        
+
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-log4j12</artifactId>
@@ -74,13 +74,13 @@
             <version>${log4j.version}</version>
             <scope>test</scope>
         </dependency>
-        
+
         <!-- for using CGIAR: elevation data importing via tif files-->
         <dependency>
             <groupId>org.apache.xmlgraphics</groupId>
             <artifactId>xmlgraphics-commons</artifactId>
             <version>2.1</version>
-        </dependency>        
+        </dependency>
 
         <dependency>
             <groupId>org.json</groupId>
@@ -88,24 +88,24 @@
             <version>${json.org.version}</version>
             <scope>test</scope>
         </dependency>
-        
+
     </dependencies>
-        
+
     <build>
         <pluginManagement>
             <plugins>
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-assembly-plugin</artifactId>
-                    <configuration>                     
+                    <configuration>
                         <!-- for usage on android -->
                         <descriptors>
                             <descriptor>src/main/assembly/android.xml</descriptor>
                         </descriptors>
                     </configuration>
-                </plugin>                
-                
-                <!-- create jar with test classes to be reused in other projects like external or our reader-osm -->                
+                </plugin>
+
+                <!-- create jar with test classes to be reused in other projects like external or our reader-osm -->
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-jar-plugin</artifactId>
@@ -117,10 +117,10 @@
                         </execution>
                     </executions>
                 </plugin>
-                
+
             </plugins>
         </pluginManagement>
-        
+
         <!-- make version available at runtime via version file -->
         <resources>
             <resource>
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index ebb8f61c53..7d2d623701 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -143,6 +143,7 @@ public void lookup( List<QueryResult> resList )
         // calculate snapped point and swap direction of closest edge if necessary
         for (QueryResult res : resList)
         {
+            res.setOsrmTrafficNode(res.getClosestNode());
             // Do not create virtual node for a query result if it is directly on a tower node or not found
             if (res.getSnappedPosition() == QueryResult.Position.TOWER)
                 continue;
@@ -153,7 +154,7 @@ public void lookup( List<QueryResult> resList )
 
             int base = closestEdge.getBaseNode();
 
-            // Force the identical direction for all closest edges. 
+            // Force the identical direction for all closest edges.
             // It is important to sort multiple results for the same edge by its wayIndex
             boolean doReverse = base > closestEdge.getAdjNode();
             if (base == closestEdge.getAdjNode())
@@ -170,7 +171,7 @@ public void lookup( List<QueryResult> resList )
                 PointList fullPL = closestEdge.fetchWayGeometry(3);
                 res.setClosestEdge(closestEdge);
                 if (res.getSnappedPosition() == QueryResult.Position.PILLAR)
-                    // ON pillar node                
+                    // ON pillar node
                     res.setWayIndex(fullPL.getSize() - res.getWayIndex() - 1);
                 else
                     // for case "OFF pillar node"
@@ -240,7 +241,7 @@ public int compare( QueryResult o1, QueryResult o2 )
                 boolean addedEdges = false;
 
                 // Create base and adjacent PointLists for all none-equal virtual nodes.
-                // We do so via inserting them at the correct position of fullPL and cutting the                
+                // We do so via inserting them at the correct position of fullPL and cutting the
                 // fullPL into the right pieces.
                 for (int counter = 0; counter < results.size(); counter++)
                 {
@@ -295,9 +296,9 @@ public int compare( QueryResult o1, QueryResult o2 )
     @Override
     public Graph getBaseGraph()
     {
-        // Note: if the mainGraph of this QueryGraph is a CHGraph then ignoring the shortcuts will produce a 
+        // Note: if the mainGraph of this QueryGraph is a CHGraph then ignoring the shortcuts will produce a
         // huge gap of edgeIds between base and virtual edge ids. The only solution would be to move virtual edges
-        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
+        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.
         return baseGraph;
     }
 
@@ -671,7 +672,7 @@ private EdgeExplorer createUncachedEdgeExplorer( EdgeFilter edgeFilter )
         final EdgeExplorer mainExplorer = mainGraph.createEdgeExplorer(edgeFilter);
         final TIntHashSet towerNodesToChange = new TIntHashSet(queryResults.size());
 
-        // 1. virtualEdges should also get fresh EdgeIterators on every createEdgeExplorer call!        
+        // 1. virtualEdges should also get fresh EdgeIterators on every createEdgeExplorer call!
         for (int i = 0; i < queryResults.size(); i++)
         {
             // create outgoing edges
@@ -686,7 +687,7 @@ private EdgeExplorer createUncachedEdgeExplorer( EdgeFilter edgeFilter )
             int virtNode = mainNodes + i;
             node2EdgeMap.put(virtNode, virtEdgeIter);
 
-            // replace edge list of neighboring tower nodes: 
+            // replace edge list of neighboring tower nodes:
             // add virtual edges only and collect tower nodes where real edges will be added in step 2.
             //
             // base node
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index 9025cf6620..f829de2532 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,8 +27,8 @@
  * Result of LocationIndex lookup.
  * <pre> X=query coordinates S=snapped coordinates: "snapping" real coords to road N=tower or pillar
  * node T=closest tower node XS=distance
- * X
- * |
+ *    X
+ *    |
  * T--S----N
  * </pre>
  * <p>
@@ -43,6 +43,7 @@
     private final GHPoint queryPoint;
     private GHPoint3D snappedPoint;
     private Position snappedPosition;
+    private int osrmTrafficNode = -1;
 
     /**
      * Due to precision differences it is hard to define when something is exactly 90° or "on-node"
@@ -194,4 +195,12 @@ public String toString()
             return closestEdge.getBaseNode() + "-" + closestEdge.getAdjNode() + "  " + snappedPoint;
         return closestNode + ", " + queryPoint + ", " + wayIndex;
     }
+
+    public void setOsrmTrafficNode(int osrmTrafficNode) {
+        this.osrmTrafficNode = osrmTrafficNode;
+    }
+
+    public int getOsrmTrafficNode() {
+        return osrmTrafficNode;
+    }
 }
diff --git a/reader-osm/pom.xml b/reader-osm/pom.xml
index 2ce3a4cf97..c2c6afa410 100644
--- a/reader-osm/pom.xml
+++ b/reader-osm/pom.xml
@@ -5,7 +5,7 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-osm</artifactId>
-    <version>0.8-SNAPSHOT</version>
+    <version>0.8-SNAPSHOT-GRAB</version>
     <packaging>jar</packaging>
     <name>GraphHopper Reader for OpenStreetMap Data</name>
 
@@ -19,7 +19,7 @@
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>graphhopper-core</artifactId>
-            <version>${project.parent.version}</version>
+            <version>0.8-SNAPSHOT-GRAB</version>
         </dependency>
         
         <dependency>
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index 3c663ab42d..14ecc3468f 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,43 +17,39 @@
  */
 package com.graphhopper.reader.osm;
 
-import com.graphhopper.reader.ReaderRelation;
-import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.reader.ReaderNode;
-import com.graphhopper.reader.ReaderElement;
-import static com.graphhopper.util.Helper.nf;
-
+import com.graphhopper.coll.GHLongIntBTree;
+import com.graphhopper.coll.LongIntMap;
+import com.graphhopper.reader.*;
+import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.reader.osm.OSMTurnRelation.TurnCostTableEntry;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TurnWeighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.list.TLongList;
 import gnu.trove.list.array.TLongArrayList;
 import gnu.trove.map.TIntLongMap;
 import gnu.trove.map.TLongLongMap;
+import gnu.trove.map.TLongObjectMap;
 import gnu.trove.map.hash.TIntLongHashMap;
 import gnu.trove.map.hash.TLongLongHashMap;
+import gnu.trove.map.hash.TLongObjectHashMap;
 import gnu.trove.set.TLongSet;
 import gnu.trove.set.hash.TLongHashSet;
-
-import java.io.File;
-import java.io.IOException;
-
-import javax.xml.stream.XMLStreamException;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.graphhopper.coll.GHLongIntBTree;
-import com.graphhopper.coll.LongIntMap;
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.osm.OSMTurnRelation.TurnCostTableEntry;
-import com.graphhopper.reader.PillarInfo;
-import com.graphhopper.reader.dem.ElevationProvider;
-import com.graphhopper.routing.util.*;
-import com.graphhopper.storage.*;
-import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.GHPoint;
-import gnu.trove.map.TLongObjectMap;
-import gnu.trove.map.hash.TLongObjectHashMap;
-
+import javax.xml.stream.XMLStreamException;
+import java.io.File;
+import java.io.IOException;
 import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static com.graphhopper.util.Helper.nf;
 
 /**
  * This class parses an OSM xml or pbf file and creates a graph from it. It does so in a two phase
@@ -126,6 +122,11 @@
     private final Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
     private final Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
 
+    private Map<Integer, Long> internalNodeToOsmNodeIdMap = new HashMap<>();
+    private Map<Long,Integer> osmWayIdToInternalIdMap = new ConcurrentHashMap<>();
+    private AtomicInteger nexInternalWayId = new AtomicInteger(0);
+
+
     public OSMReader( GraphHopperStorage ghStorage )
     {
         this.ghStorage = ghStorage;
@@ -152,6 +153,7 @@ public void readGraph() throws IOException
 
         StopWatch sw1 = new StopWatch().start();
         preProcess(osmFile);
+        System.out.println("------------------osmWayIdToInternalIdMap size:" + osmWayIdToInternalIdMap.size() +"------------------");
         sw1.stop();
 
         StopWatch sw2 = new StopWatch().start();
@@ -184,6 +186,11 @@ void preProcess( File osmFile )
                     boolean valid = filterWay(way);
                     if (valid)
                     {
+                        Integer internalId = osmWayIdToInternalIdMap.get(way.getId());
+                        if (internalId == null) {
+                            osmWayIdToInternalIdMap.put(way.getId(),nexInternalWayId.getAndIncrement());
+                        }
+
                         TLongList wayNodes = way.getNodes();
                         int s = wayNodes.size();
                         for (int index = 0; index < s; index++)
@@ -614,15 +621,18 @@ boolean addNode( ReaderNode node )
         double lat = node.getLat();
         double lon = node.getLon();
         double ele = getElevation(node);
+        int id = EMPTY;
         if (nodeType == TOWER_NODE)
         {
-            addTowerNode(node.getId(), lat, lon, ele);
+            id = addTowerNode(node.getId(), lat, lon, ele);
         } else if (nodeType == PILLAR_NODE)
         {
             pillarInfo.setNode(nextPillarId, lat, lon, ele);
-            getNodeMap().put(node.getId(), nextPillarId + 3);
+            id = nextPillarId + 3;
+            getNodeMap().put(node.getId(), id);
             nextPillarId++;
         }
+        internalNodeToOsmNodeIdMap.put(id,node.getId());
         return true;
     }
 
@@ -687,7 +697,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
     /**
      * This method creates from an OSM way (via the osm ids) one or more edges in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay( final TLongList osmNodeIds, final long flags, final long wayOsmId )
+    protected Collection<EdgeIteratorState> addOSMWay( final TLongList osmNodeIds, final long flags, final long wayOsmId )
     {
         PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
         List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
@@ -810,7 +820,7 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
         }
         if (towerNodeDistance < 0.0001)
         {
-            // As investigation shows often two paths should have crossed via one identical point 
+            // As investigation shows often two paths should have crossed via one identical point
             // but end up in two very close points.
             zeroCounter++;
             towerNodeDistance = 0.0001;
@@ -825,7 +835,7 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
 
         if (Double.isInfinite(towerNodeDistance) || towerNodeDistance > maxDistance)
         {
-            // Too large is very rare and often the wrong tagging. See #435 
+            // Too large is very rare and often the wrong tagging. See #435
             // so we can avoid the complexity of splitting the way for now (new towernodes would be required, splitting up geometry etc)
             LOGGER.warn("Bug in OSM or GraphHopper. Too big tower node distance " + towerNodeDistance + " reset to large value, osm way " + wayOsmId);
             towerNodeDistance = maxDistance;
@@ -891,6 +901,7 @@ protected void finishedReading()
         osmWayIdToRouteWeightMap = null;
         osmWayIdSet = null;
         edgeIdToOsmWayIdMap = null;
+        internalNodeToOsmNodeIdMap = null;
     }
 
     /**
@@ -1064,4 +1075,13 @@ public String toString()
     {
         return getClass().getSimpleName();
     }
+
+    protected Map<Integer, Long> getInternalNodeToOsrmNodeIdMap() {
+        return internalNodeToOsmNodeIdMap;
+    }
+
+    public Map<Long, Integer> getOsmWayIdToInternalIdMap() {
+        return osmWayIdToInternalIdMap;
+    }
+
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
index f8b1bb5ba1..e4aa5b2213 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
@@ -17,46 +17,35 @@
  */
 package com.graphhopper.reader.osm;
 
-import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.reader.ReaderNode;
-import com.graphhopper.reader.ReaderRelation;
-import static org.junit.Assert.*;
-
-import gnu.trove.list.TLongList;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URISyntaxException;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import com.graphhopper.GraphHopper;
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
 import com.graphhopper.GraphHopperIT;
 import com.graphhopper.reader.DataReader;
+import com.graphhopper.reader.ReaderNode;
+import com.graphhopper.reader.ReaderRelation;
+import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.Helper;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import gnu.trove.list.TLongList;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URISyntaxException;
 import java.util.*;
 
+import static org.junit.Assert.*;
+
 /**
  * Tests the OSMReader with the normal helper initialized.
  * <p>
@@ -656,7 +645,7 @@ public long handleNodeTags( ReaderNode node )
             }
 
             @Override
-            Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long wayFlags, long osmId )
+            protected Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long wayFlags, long osmId )
             {
                 return Collections.emptyList();
             }
