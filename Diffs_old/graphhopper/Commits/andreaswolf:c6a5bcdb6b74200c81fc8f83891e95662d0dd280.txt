diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index b183084ce4..ea3d23ccb8 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -21,7 +21,8 @@
 import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.dem.CGIARProvider;
 import com.graphhopper.reader.dem.ElevationProvider;
-import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.reader.dem.HighPrecisionSRTMProvider;
+import com.graphhopper.reader.dem.LowPrecisionSRTMProvider;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
@@ -545,7 +546,10 @@ public GraphHopper init( CmdArgs args )
         ElevationProvider tmpProvider = ElevationProvider.NOOP;
         if (eleProviderStr.equalsIgnoreCase("srtm"))
         {
-            tmpProvider = new SRTMProvider();
+            tmpProvider = new LowPrecisionSRTMProvider();
+        } else if (eleProviderStr.equalsIgnoreCase("srtmhigh"))
+        {
+            tmpProvider = new HighPrecisionSRTMProvider();
         } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
         {
             CGIARProvider cgiarProvider = new CGIARProvider();
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HighPrecisionSRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/HighPrecisionSRTMProvider.java
new file mode 100644
index 0000000000..40d130f8b9
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/HighPrecisionSRTMProvider.java
@@ -0,0 +1,116 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.*;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.Downloader;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.io.*;
+import java.net.SocketTimeoutException;
+import java.util.zip.ZipInputStream;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Elevation data from NASA (SRTM). Downloaded from http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/
+ * <p/>
+ * Important information about SRTM: the coordinates of the lower-left corner of tile N40W118 are 40
+ * degrees north latitude and 118 degrees west longitude. To be more exact, these coordinates refer
+ * to the geometric center of the lower left sample, which in the case of SRTM3 data will be about
+ * 90 meters in extent.
+ * <p/>
+ *
+ * @author Peter Karich
+ */
+public class HighPrecisionSRTMProvider extends SRTMProvider
+{
+    public static void main(String[] args) throws IOException
+    {
+        HighPrecisionSRTMProvider provider = new HighPrecisionSRTMProvider();
+        // 1046
+        System.out.println(provider.getEle(47.468668, 14.575127));
+        // 1113
+        System.out.println(provider.getEle(47.467753, 14.573911));
+
+        // 1946
+        System.out.println(provider.getEle(46.468835, 12.578777));
+
+        // 845
+        System.out.println(provider.getEle(48.469123, 9.576393));
+
+        // 1113 vs new: 
+        provider.setCalcMean(true);
+        System.out.println(provider.getEle(47.467753, 14.573911));
+    }
+
+    private static final BitUtil BIT_UTIL = BitUtil.BIG;
+    // use a map as an array is not quite useful if we want to hold only parts of the world
+    private final TIntObjectHashMap<HeightTile> cacheData = new TIntObjectHashMap<HeightTile>();
+    private final double precision = 1e7;
+    private final double invPrecision = 1 / precision;
+    // mirror: base = "http://mirror.ufs.ac.za/datasets/SRTM3/"
+
+    private LowPrecisionSRTMProvider lowResProvider = new LowPrecisionSRTMProvider();
+
+    public HighPrecisionSRTMProvider()
+    {
+        WIDTH = 3601;
+        baseUrl = "http://e4ftl01.cr.usgs.gov/SRTM/SRTMGL1.003/2000.02.11/";
+    }
+
+    String getFileString(double lat, double lon)
+    {
+        return getElevationAsString(lat, lon)  + ".SRTMGL1";
+    }
+
+    private String getElevationAsString(double lat, double lon)
+    {
+        int minLat = Math.abs(down(lat));
+        int minLon = Math.abs(down(lon));
+
+        return String.format("%s%02d%s%03d",
+                (lat >= 0) ? "N" : "S",
+                minLat,
+                (lon >= 0) ? "E" : "W",
+                minLon
+        );
+    }
+
+    public double getEle(double lat, double lon)
+    {
+        try
+        {
+            return super.getEle(lat, lon);
+        } catch (RuntimeException ex)
+        {
+            logger.warn("Falling back to low-resolution SRTM data for " + getElevationAsString(lat, lon));
+            return lowResProvider.getEle(lat, lon);
+        }
+    }
+
+    @Override
+    public String toString()
+    {
+        return "HighPrecisionSRTM";
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/LowPrecisionSRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/LowPrecisionSRTMProvider.java
new file mode 100644
index 0000000000..c263b1bbc0
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/LowPrecisionSRTMProvider.java
@@ -0,0 +1,116 @@
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.util.Helper;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+public class LowPrecisionSRTMProvider extends SRTMProvider
+{
+    private final TIntObjectHashMap<String> areas = new TIntObjectHashMap<String>();
+
+    public static void main( String[] args ) throws IOException
+    {
+        SRTMProvider provider = new LowPrecisionSRTMProvider();
+        // 1046
+        System.out.println(provider.getEle(47.468668, 14.575127));
+        // 1113
+        System.out.println(provider.getEle(47.467753, 14.573911));
+
+        // 1946
+        System.out.println(provider.getEle(46.468835, 12.578777));
+
+        // 845
+        System.out.println(provider.getEle(48.469123, 9.576393));
+
+        // 1113 vs new:
+        provider.setCalcMean(true);
+        System.out.println(provider.getEle(47.467753, 14.573911));
+    }
+
+    public LowPrecisionSRTMProvider()
+    {
+        WIDTH = 1201;
+        baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
+        // move to explicit calls?
+        init();
+    }
+
+    /**
+     * The URLs are a bit ugly and so we need to find out which area name a certain lat,lon
+     * coordinate has.
+     */
+    private SRTMProvider init()
+    {
+        try
+        {
+            String strs[] =
+            {
+                "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
+            };
+            for (String str : strs)
+            {
+                InputStream is = getClass().getResourceAsStream(str + "_names.txt");
+                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
+                {
+                    int lat = Integer.parseInt(line.substring(1, 3));
+                    if (line.substring(0, 1).charAt(0) == 'S')
+                        lat = -lat;
+
+                    int lon = Integer.parseInt(line.substring(4, 7));
+                    if (line.substring(3, 4).charAt(0) == 'W')
+                        lon = -lon;
+
+                    int intKey = calcIntKey(lat, lon);
+                    String key = areas.put(intKey, str);
+                    if (key != null)
+                        throw new IllegalStateException("do not overwrite existing! key " + intKey + " " + key + " vs. " + str);
+                }
+            }
+            return this;
+        } catch (Exception ex)
+        {
+            throw new IllegalStateException("Cannot load area names from classpath", ex);
+        }
+    }
+
+    String getFileString( double lat, double lon )
+    {
+        int intKey = calcIntKey(lat, lon);
+        String str = areas.get(intKey);
+        if (str == null)
+            return null;
+
+        int minLat = Math.abs(down(lat));
+        int minLon = Math.abs(down(lon));
+        str += "/";
+        if (lat >= 0)
+            str += "N";
+        else
+            str += "S";
+
+        if (minLat < 10)
+            str += "0";
+        str += minLat;
+
+        if (lon >= 0)
+            str += "E";
+        else
+            str += "W";
+
+        if (minLon < 10)
+            str += "0";
+        if (minLon < 100)
+            str += "0";
+        str += minLon;
+        return str;
+    }
+
+    @Override
+    public String toString()
+    {
+        return "SRTM";
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index 596e00c82b..bfcd78e178 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -21,7 +21,6 @@
 import com.graphhopper.storage.*;
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Downloader;
-import com.graphhopper.util.Helper;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
 import java.io.*;
@@ -41,49 +40,24 @@
  * <p>
  * @author Peter Karich
  */
-public class SRTMProvider implements ElevationProvider
+public abstract class SRTMProvider implements ElevationProvider
 {
-    public static void main( String[] args ) throws IOException
-    {
-        SRTMProvider provider = new SRTMProvider();
-        // 1046
-        System.out.println(provider.getEle(47.468668, 14.575127));
-        // 1113
-        System.out.println(provider.getEle(47.467753, 14.573911));
-
-        // 1946
-        System.out.println(provider.getEle(46.468835, 12.578777));
-
-        // 845
-        System.out.println(provider.getEle(48.469123, 9.576393));
-
-        // 1113 vs new: 
-        provider.setCalcMean(true);
-        System.out.println(provider.getEle(47.467753, 14.573911));
-    }
 
     private static final BitUtil BIT_UTIL = BitUtil.BIG;
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final int WIDTH = 1201;
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+    protected int WIDTH;
     private Directory dir;
     private DAType daType = DAType.MMAP;
     private Downloader downloader = new Downloader("GraphHopper SRTMReader").setTimeout(10000);
     private File cacheDir = new File("/tmp/srtm");
     // use a map as an array is not quite useful if we want to hold only parts of the world
     private final TIntObjectHashMap<HeightTile> cacheData = new TIntObjectHashMap<HeightTile>();
-    private final TIntObjectHashMap<String> areas = new TIntObjectHashMap<String>();
     private final double precision = 1e7;
     private final double invPrecision = 1 / precision;
     // possible alternatives see #451
     // http://mirror.ufs.ac.za/datasets/SRTM3/
-    private String baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
     private boolean calcMean = false;
-
-    public SRTMProvider()
-    {
-        // move to explicit calls?
-        init();
-    }
+    protected String baseUrl;
 
     @Override
     public void setCalcMean( boolean calcMean )
@@ -91,46 +65,9 @@ public void setCalcMean( boolean calcMean )
         this.calcMean = calcMean;
     }
 
-    /**
-     * The URLs are a bit ugly and so we need to find out which area name a certain lat,lon
-     * coordinate has.
-     */
-    private SRTMProvider init()
-    {
-        try
-        {
-            String strs[] =
-                    {
-                            "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
-                    };
-            for (String str : strs)
-            {
-                InputStream is = getClass().getResourceAsStream(str + "_names.txt");
-                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
-                {
-                    int lat = Integer.parseInt(line.substring(1, 3));
-                    if (line.substring(0, 1).charAt(0) == 'S')
-                        lat = -lat;
-
-                    int lon = Integer.parseInt(line.substring(4, 7));
-                    if (line.substring(3, 4).charAt(0) == 'W')
-                        lon = -lon;
-
-                    int intKey = calcIntKey(lat, lon);
-                    String key = areas.put(intKey, str);
-                    if (key != null)
-                        throw new IllegalStateException("do not overwrite existing! key " + intKey + " " + key + " vs. " + str);
-                }
-            }
-            return this;
-        } catch (Exception ex)
-        {
-            throw new IllegalStateException("Cannot load area names from classpath", ex);
-        }
-    }
 
     // use int key instead of string for lower memory usage
-    private int calcIntKey( double lat, double lon )
+    protected int calcIntKey( double lat, double lon )
     {
         // we could use LinearKeyAlgo but this is simpler as we only need integer precision:
         return (down(lat) + 90) * 1000 + down(lon) + 180;
@@ -182,37 +119,7 @@ int down( double val )
         return intVal - 1;
     }
 
-    String getFileString( double lat, double lon )
-    {
-        int intKey = calcIntKey(lat, lon);
-        String str = areas.get(intKey);
-        if (str == null)
-            return null;
-
-        int minLat = Math.abs(down(lat));
-        int minLon = Math.abs(down(lon));
-        str += "/";
-        if (lat >= 0)
-            str += "N";
-        else
-            str += "S";
-
-        if (minLat < 10)
-            str += "0";
-        str += minLat;
-
-        if (lon >= 0)
-            str += "E";
-        else
-            str += "W";
-
-        if (minLon < 10)
-            str += "0";
-        if (minLon < 100)
-            str += "0";
-        str += minLon;
-        return str;
-    }
+    abstract String getFileString(double lat, double lon);
 
     @Override
     public double getEle( double lat, double lon )
@@ -238,6 +145,7 @@ public double getEle( double lat, double lon )
             DataAccess heights = getDirectory().find("dem" + intKey);
             demProvider.setHeights(heights);
             boolean loadExisting = false;
+
             try
             {
                 loadExisting = heights.loadExisting();
@@ -252,49 +160,9 @@ public double getEle( double lat, double lon )
                 heights.create(bytes.length);
                 try
                 {
-                    String zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
-                    File file = new File(cacheDir, new File(zippedURL).getName());
-                    InputStream is;
-                    // get zip file if not already in cacheDir - unzip later and in-memory only!
-                    if (!file.exists())
-                    {
-                        for (int i = 0; i < 3; i++)
-                        {
-                            try
-                            {
-                                downloader.downloadFile(zippedURL, file.getAbsolutePath());
-                                break;
-                            } catch (SocketTimeoutException ex)
-                            {
-                                // just try again after a little nap
-                                Thread.sleep(2000);
-                                continue;
-                            } catch (FileNotFoundException ex)
-                            {
-                                // now try different URL (without point!), necessary if mirror is used
-                                zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
-                                continue;
-                            }
-                        }
-                    }
-
-                    is = new FileInputStream(file);
-                    ZipInputStream zis = new ZipInputStream(is);
-                    zis.getNextEntry();
-                    BufferedInputStream buff = new BufferedInputStream(zis);
-                    int len;
-                    while ((len = buff.read(bytes)) > 0)
-                    {
-                        for (int bytePos = 0; bytePos < len; bytePos += 2)
-                        {
-                            short val = BIT_UTIL.toShort(bytes, bytePos);
-                            if (val < -1000 || val > 12000)
-                                val = Short.MIN_VALUE;
-
-                            heights.setShort(bytePos, val);
-                        }
-                    }
-                    heights.flush();
+                    File file = downloadFile(fileDetails);
+
+                    processFile(heights, bytes, file);
 
                     // demProvider.toImage("x" + file.getName() + ".png");
                     // TODO remove hgt and zip?
@@ -308,6 +176,57 @@ public double getEle( double lat, double lon )
         return demProvider.getHeight(lat, lon);
     }
 
+    private File downloadFile(String fileDetails) throws IOException, InterruptedException {
+        String zippedURL = baseUrl + fileDetails + ".hgt.zip";
+        File file = new File(cacheDir, new File(zippedURL).getName());
+
+        // get zip file if not already in cacheDir - unzip later and in-memory only!
+        if (!file.exists())
+        {
+            for (int i = 0; i < 3; i++)
+            {
+                try
+                {
+                    downloader.downloadFile(zippedURL, file.getAbsolutePath());
+                    break;
+                } catch (SocketTimeoutException ex)
+                {
+                    // just try again after a little nap
+                    Thread.sleep(2000);
+                    continue;
+                } catch (FileNotFoundException ex)
+                {
+                    // now try different URL (with dot!), necessary if mirror is used
+                    zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
+                    continue;
+                }
+            }
+        }
+        return file;
+    }
+
+    private void processFile(DataAccess heights, byte[] bytes, File file) throws IOException {
+        InputStream is;
+
+        is = new FileInputStream(file);
+        ZipInputStream zis = new ZipInputStream(is);
+        zis.getNextEntry();
+        BufferedInputStream buff = new BufferedInputStream(zis);
+        int len;
+        while ((len = buff.read(bytes)) > 0)
+        {
+            for (int bytePos = 0; bytePos < len; bytePos += 2)
+            {
+                short val = BIT_UTIL.toShort(bytes, bytePos);
+                if (val < -1000 || val > 12000)
+                    val = Short.MIN_VALUE;
+
+                heights.setShort(bytePos, val);
+            }
+        }
+        heights.flush();
+    }
+
     @Override
     public void release()
     {
@@ -318,12 +237,6 @@ public void release()
             dir.clear();
     }
 
-    @Override
-    public String toString()
-    {
-        return "SRTM";
-    }
-
     private Directory getDirectory()
     {
         if (dir != null)
diff --git a/core/src/test/java/com/graphhopper/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
index f2e3c90721..dbf55f9e72 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper;
 
-import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.reader.dem.LowPrecisionSRTMProvider;
 import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.RoutingAlgorithmFactory;
 import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
@@ -230,7 +230,7 @@ public void testSRTMWithInstructions() throws Exception
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager(importVehicles));
 
-        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
+        tmpHopper.setElevationProvider(new LowPrecisionSRTMProvider().setCacheDir(new File("./files/")));
         tmpHopper.importOrLoad();
 
         GHResponse rsp = tmpHopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index 0f11e420ac..dc156a53ec 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -19,6 +19,7 @@
 
 import static org.junit.Assert.*;
 
+import com.graphhopper.reader.dem.LowPrecisionSRTMProvider;
 import gnu.trove.list.TLongList;
 
 import java.io.File;
@@ -37,7 +38,6 @@
 
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.dem.ElevationProvider;
-import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeExplorer;
@@ -692,7 +692,7 @@ public void testReadEleFromDataProvider()
     {
         GraphHopper hopper = new GraphHopperTest("test-osm5.xml");
         // get N10E046.hgt.zip
-        ElevationProvider provider = new SRTMProvider();
+        ElevationProvider provider = new LowPrecisionSRTMProvider();
         provider.setCacheDir(new File("./files"));
         hopper.setElevationProvider(provider);
         hopper.importOrLoad();
diff --git a/core/src/test/java/com/graphhopper/reader/dem/HighPrecisionSRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/HighPrecisionSRTMProviderTest.java
new file mode 100644
index 0000000000..0f856a3882
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/dem/HighPrecisionSRTMProviderTest.java
@@ -0,0 +1,100 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.DAType;
+import java.io.File;
+import java.io.IOException;
+import org.junit.After;
+import org.junit.Test;
+import static org.junit.Assert.*;
+import org.junit.Before;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class HighPrecisionSRTMProviderTest
+{
+    HighPrecisionSRTMProvider instance;
+
+    @Before
+    public void setUp()
+    {
+        instance = new HighPrecisionSRTMProvider();
+    }
+
+    @After
+    public void tearDown()
+    {
+        instance.release();
+    }
+
+    @Test
+    public void testGetFileString()
+    {
+        assertEquals("N49E011.SRTMGL1", instance.getFileString(49, 11));
+        assertEquals("N52W002.SRTMGL1", instance.getFileString(52.268157, -1.230469));
+        assertEquals("S06E034.SRTMGL1", instance.getFileString(-5.965754, 34.804687));
+        assertEquals("S29E131.SRTMGL1", instance.getFileString(-28.304381, 131.484375));
+        assertEquals("S09W045.SRTMGL1", instance.getFileString(-9, -45));
+        assertEquals("S10W046.SRTMGL1", instance.getFileString(-9.1, -45.1));
+        assertEquals("S10W045.SRTMGL1", instance.getFileString(-9.6, -45));
+        assertEquals("S28W071.SRTMGL1", instance.getFileString(-28, -71));
+        assertEquals("S29W072.SRTMGL1", instance.getFileString(-28.88316, -71.070557));
+    }
+
+    @Test
+    public void testGetHeight() throws IOException
+    {
+        instance.setCacheDir(new File("./files/"));
+        // easy to verify orientation of tile:
+//        instance.getEle(43, 13);
+
+        // siegesturm
+        assertEquals(466, instance.getEle(49.968651, 11.574869), 1e-1);
+        // am main
+        assertEquals(330, instance.getEle(49.958233, 11.558647), 1e-1);
+        // south america
+        assertEquals(1678, instance.getEle(-28.88316, -71.070557), 1e-1);
+        assertEquals(0, instance.getEle(-28.671311, -71.38916), 1e-1);
+
+        // montevideo
+        // assertEquals(45, instance.getEle(-34.906205,-56.189575), 1e-1);
+        // new york
+        // assertEquals(21, instance.getEle(40.730348,-73.985882), 1e-1);
+        // use 0 elevation if area not found
+        assertEquals(0, instance.getEle(55.4711873, 19.2501641), 1e-1);
+
+        assertEquals(161, instance.getEle(55.8943144, -3), 1e-1);
+        // precision = 1e6 => -3
+        // assertEquals(160, instance.getEle(55.8943144, -3.0000004), 1e-1);
+        // precision = 1e7 => -4
+        // assertEquals(161, instance.getEle(55.8943144, -3.0004), 1e-1);
+        // assertEquals(161, instance.getEle(55.8943144, -3.0000001), 1e-1);
+    }
+
+    @Test
+    public void testGetHeightMMap() throws IOException
+    {
+        instance.setCacheDir(new File("./files/"));
+        instance.setDAType(DAType.MMAP);
+        assertEquals(161, instance.getEle(55.8943144, -3), 1e-1);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/LowPrecisionSRTMProviderTest.java
similarity index 96%
rename from core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
rename to core/src/test/java/com/graphhopper/reader/dem/LowPrecisionSRTMProviderTest.java
index 30f2439d3a..f27b31ace6 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/LowPrecisionSRTMProviderTest.java
@@ -33,14 +33,14 @@
 /**
  * @author Peter Karich
  */
-public class SRTMProviderTest
+public class LowPrecisionSRTMProviderTest
 {
-    SRTMProvider instance;
+    LowPrecisionSRTMProvider instance;
 
     @Before
     public void setUp()
     {
-        instance = new SRTMProvider();
+        instance = new LowPrecisionSRTMProvider();
     }
 
     @After
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index c08eb3c6eb..bc4a43d3e3 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.reader.dem.LowPrecisionSRTMProvider;
 import com.graphhopper.routing.util.TestAlgoCollector;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.PrinctonReader;
@@ -556,7 +557,7 @@ Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
                     setGraphHopperLocation(graphFile).
                     setEncodingManager(new EncodingManager(importVehicles));
             if (is3D)
-                hopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files")));
+                hopper.setElevationProvider(new LowPrecisionSRTMProvider().setCacheDir(new File("./files")));
 
             hopper.importOrLoad();
 
