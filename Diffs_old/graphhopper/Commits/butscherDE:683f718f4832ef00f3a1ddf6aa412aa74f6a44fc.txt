diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index b746028b62..cb7262a456 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1153,7 +1153,8 @@ private RoutingTemplate buildRoutingTemplate(GHRequest request, GHResponse ghRsp
             routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
         } else if (validPolygonInRequest(request)) {
             routingTemplate =
-                    new PolygonThroughRoutingTemplate(request, ghRsp, locationIndex, this.getGraphHopperStorage().getNodeAccess(), this.getGraphHopperStorage(), encodingManager);
+                    new PolygonThroughRoutingTemplate(request, ghRsp, locationIndex, this.getGraphHopperStorage().getNodeAccess(),
+                    this.getGraphHopperStorage(), encodingManager);
         } else {
             routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index 64a88cb88e..d44408b4c7 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -7,6 +7,7 @@
 import com.graphhopper.routing.template.polygonRoutingUtil.RouteCandidatePolygon;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
@@ -26,13 +27,14 @@
     final GraphHopperStorage ghStorage;
     final NodeAccess nodeAccess;
     final LocationIndex locationIndex;
+    final Graph graph;
     QueryGraph queryGraph;
     AlgorithmOptions algorithmOptions;
     RoutingAlgorithmFactory algoFactory;
     RoutingAlgorithm routingAlgorithm;
     RouteCandidateList<RouteCandidatePolygon> routeCandidates;
 
-    public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, NodeAccess nodeAccess, GraphHopperStorage ghStorage,
+    public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, Graph graph, NodeAccess nodeAccess, GraphHopperStorage ghStorage,
                                          EncodingManager encodingManager) {
         super(ghRequest, ghRsp, locationIndex, encodingManager);
         this.ghRequest = ghRequest;
@@ -40,6 +42,7 @@ public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationInd
         this.ghStorage = ghStorage;
         this.nodeAccess = nodeAccess;
         this.locationIndex = locationIndex;
+        this.graph = graph;
         this.pathList = new ArrayList<>(ghRequest.getPoints().size() - 1);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
index db4d690e31..b2f4e3d192 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -3,10 +3,9 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.template.polygonRoutingUtil.RouteCandidatePolygon;
-import com.graphhopper.routing.template.polygonRoutingUtil.RouteCandidateList;
-import com.graphhopper.routing.template.polygonRoutingUtil.RouteCandidatePolygonThrough;
+import com.graphhopper.routing.template.polygonRoutingUtil.*;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
@@ -19,12 +18,13 @@
 import java.util.*;
 
 public class PolygonThroughRoutingTemplate extends PolygonRoutingTemplate {
-    private DijkstraOneToMany dijkstraForLOTNodes;
-    private DijkstraManyToMany dijkstraForPathSkeleton;
+    private OneToManyRouting dijkstraForLOTNodes;
+    private ManyToManyRouting dijkstraForPathSkeleton;
+    private List<Integer> nodesInPolygon;
 
     public PolygonThroughRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, NodeAccess nodeAccess, GraphHopperStorage ghStorage,
                                          EncodingManager encodingManager) {
-        super(ghRequest, ghRsp, locationIndex, nodeAccess, ghStorage, encodingManager);
+        super(ghRequest, ghRsp, locationIndex, ghStorage.getBaseGraph(), nodeAccess, ghStorage, encodingManager);
     }
 
     private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
@@ -32,12 +32,11 @@ private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFac
     }
 
     protected RouteCandidateList findCandidateRoutes() {
-        List<Integer> nodesInPolygon = getNodesInPolygon();
+        this.nodesInPolygon = getNodesInPolygon();
         List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
         List<List<Integer>> LOTNodes = findLocalOptimalTouchnodes(polygonEntryExitPoints);
-        this.dijkstraForPathSkeleton = new DijkstraManyToMany(this.queryGraph, this.algorithmOptions.getWeighting(), this.algorithmOptions.getTraversalMode(), nodesInPolygon,
-                                                              polygonEntryExitPoints);
-        this.dijkstraForPathSkeleton.findAllPathsBetweenEntryExitPoints();
+        this.dijkstraForPathSkeleton = new ManyToManyRouting(nodesInPolygon, polygonEntryExitPoints, this.graph, this.algoFactory, this.algorithmOptions);
+        this.dijkstraForPathSkeleton.findPathBetweenAllNodePairs();
 
         for (int i = 0; i < LOTNodes.size() - 1; i++) {
             buildRouteCandidatesForCurrentPoint(LOTNodes.get(i), i);
@@ -142,17 +141,20 @@ private void addEntryExitPointsCopyTo(List<Integer> polygonEntryExitPoints, List
     }
 
     private Map<Integer, Double> getDistancesFromPointToEntryExitPoints(QueryResult point, List<Integer> polygonEntryExitPoints) {
-        final Map<Integer, Double> weightsOfEntryExitPoints = new HashMap<Integer, Double>();
-        for (final int entryExitPoint : polygonEntryExitPoints) {
-            this.dijkstraForLOTNodes.calcPath(point.getClosestNode(), entryExitPoint);
-            weightsOfEntryExitPoints.put(entryExitPoint, this.dijkstraForLOTNodes.getWeight(entryExitPoint));
+        final int fromNode = point.getClosestNode();
+        this.dijkstraForLOTNodes = new OneToManyRouting(fromNode, polygonEntryExitPoints, this.nodesInPolygon, this.queryGraph, this.algoFactory, this.algorithmOptions);
+        this.dijkstraForLOTNodes.findPathBetweenAllNodePairs();
+        final List<Path> allFoundPaths = this.dijkstraForLOTNodes.getAllFoundPaths();
+
+        final Map<Integer, Double> weightsOfEntryExitPoints = new HashMap<>();
+        for (int i = 0; i < polygonEntryExitPoints.size(); i++) {
+            weightsOfEntryExitPoints.put(polygonEntryExitPoints.get(i), allFoundPaths.get(0).getDistance());
         }
 
         return weightsOfEntryExitPoints;
     }
 
     private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
-        this.dijkstraForLOTNodes = new DijkstraOneToMany(this.queryGraph, this.algorithmOptions.getWeighting(), this.algorithmOptions.getTraversalMode());
         final List<Integer> entryExitPoints = new ArrayList<>();
         final EdgeExplorer edgeExplorer = ghStorage.getBaseGraph().createEdgeExplorer();
 
@@ -187,7 +189,7 @@ private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPol
         return visitor.getNodesInPolygon();
     }
 
-    public DijkstraManyToMany getPathSkeletonRouter() {
+    public ManyToManyRouting getPathSkeletonRouter() {
         return this.dijkstraForPathSkeleton;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java
index a5ff3e42c4..bb16db06b9 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRouting.java
@@ -1,20 +1,16 @@
 package com.graphhopper.routing.template.polygonRoutingUtil;
 
 import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.Path;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.RoutingAlgorithmFactory;
 import com.graphhopper.routing.template.util.QueryGraphCreator;
 import com.graphhopper.storage.Graph;
 
-
-import java.util.ArrayList;
 import java.util.List;
 
-public class ManyToManyRouting {
+public class ManyToManyRouting extends MultiRouting {
     private final List<Integer> nodesToConsiderForRouting;
     private final List<Integer> nodesToBuildRoutesWith;
-    private final List<Path> allFoundPaths;
     private final Graph graph;
     private final QueryGraph queryGraph;
     private final RoutingAlgorithmFactory routingAlgorithmFactory;
@@ -24,7 +20,6 @@ public ManyToManyRouting(final List<Integer> nodesToConsiderForRouting, final Li
                              Graph graph, RoutingAlgorithmFactory routingAlgorithmFactory, AlgorithmOptions algorithmOptions) {
         this.nodesToConsiderForRouting = nodesToConsiderForRouting;
         this.nodesToBuildRoutesWith = nodesToBuildRoutesWith;
-        this.allFoundPaths = new ArrayList<>(nodesToBuildRoutesWith.size() * nodesToBuildRoutesWith.size());
         this.graph = graph;
         this.queryGraph = prepareQueryGraph();
         this.routingAlgorithmFactory = routingAlgorithmFactory;
@@ -36,23 +31,12 @@ private QueryGraph prepareQueryGraph() {
         return queryGraphCreator.createQueryGraph();
     }
 
-    public void findAllPathsBetweenEntryExitPoints() {
-        if (allFoundPaths.size() > 0) {
-            throw new IllegalStateException("The algorithm was already run. Retrieve results with getAllPaths() or invoke clear first");
-        }
-
+    void calculatePaths() {
         for (int fromNode : nodesToBuildRoutesWith) {
-            final OneToManyRouting oneToManyRouting = new OneToManyRouting(fromNode, this.nodesToBuildRoutesWith, nodesToConsiderForRouting, this.queryGraph, this.routingAlgorithmFactory, this.algorithmOptions);
-            oneToManyRouting.calcAllPaths();
-            this.allFoundPaths.addAll(oneToManyRouting.getAllFoundPaths());
+            final OneToManyRouting
+                    oneToManyRouting = new OneToManyRouting(fromNode, this.nodesToBuildRoutesWith, nodesToConsiderForRouting, this.queryGraph, this.routingAlgorithmFactory, this.algorithmOptions);
+            oneToManyRouting.findPathBetweenAllNodePairs();
+            this.allFoundPaths.putAll(oneToManyRouting.getAllFoundPathsMap());
         }
     }
-
-    public void clear() {
-        this.allFoundPaths.clear();
-    }
-
-    public List<Path> getAllFoundPaths() {
-        return this.allFoundPaths;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/MultiRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/MultiRouting.java
new file mode 100644
index 0000000000..4b983bd379
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/MultiRouting.java
@@ -0,0 +1,57 @@
+package com.graphhopper.routing.template.polygonRoutingUtil;
+
+import com.graphhopper.routing.Path;
+import javafx.util.Pair;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public abstract class MultiRouting {
+    protected final Map<Pair<Integer, Integer>, Path> allFoundPaths;
+
+    public MultiRouting() {
+        this.allFoundPaths = new HashMap<>();
+    }
+
+    /**
+     * Called once to find all paths between the nodes given in the class.
+     */
+    public void findPathBetweenAllNodePairs() {
+        if (pathsNotAlreadySearched()) {
+            calculatePaths();
+        }
+    }
+
+    private boolean pathsNotAlreadySearched() {
+        return allFoundPaths.size() == 0;
+    }
+
+    abstract void calculatePaths();
+
+    /**
+     * Outputs a list of all found paths
+     * @return
+     */
+    public List<Path> getAllFoundPaths() {
+        final List<Path> allFoundPathsList = new ArrayList<>(this.allFoundPaths.size());
+
+        for (final Path path : this.allFoundPaths.values()) {
+            allFoundPathsList.add(path);
+        }
+
+        return allFoundPathsList;
+    }
+
+    /**
+     * Gets a specific path between two nodes.
+     *
+     * @param fromNodeId node where the path shall start from.
+     * @param toNodeId node where the path shall end to.
+     * @return
+     */
+    public Path getPathByFromEndNodeID(Integer fromNodeId, Integer toNodeId) {
+        return this.allFoundPaths.get(new Pair<Integer, Integer>(fromNodeId, toNodeId));
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
index 005ae7d652..a7d2b15973 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
@@ -1,44 +1,37 @@
 package com.graphhopper.routing.template.polygonRoutingUtil;
 
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.template.RoutingTemplate;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.shapes.GHPoint;
+import javafx.util.Pair;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 
-public class OneToManyRouting {
+public class OneToManyRouting extends MultiRouting {
     private final int fromNode;
     private final List<Integer> toNodes;
     private final List<Integer> nodesToConsiderForRouting;
     private final QueryGraph queryGraph;
     private final RoutingAlgorithmFactory routingAlgorithmFactory;
     private final AlgorithmOptions algorithmOptions;
-    private final List<Path> allFoundPaths;
 
     public OneToManyRouting(final int fromNode, final List<Integer> toNodes, List<Integer> nodesToConsiderForRouting, final QueryGraph queryGraph,
                             final RoutingAlgorithmFactory routingAlgorithmFactory, final AlgorithmOptions algorithmOptions) {
         this.fromNode = fromNode;
         this.toNodes = toNodes;
-        this.allFoundPaths = new ArrayList<>(toNodes.size());
         this.nodesToConsiderForRouting = nodesToConsiderForRouting;
         this.queryGraph = queryGraph;
         this.routingAlgorithmFactory = routingAlgorithmFactory;
         this.algorithmOptions = algorithmOptions;
     }
 
-    public void calcAllPaths() {
+    void calculatePaths() {
         for (final int toNode : toNodes) {
             final RoutingAlgorithm routingAlgorithm = buildRoutingAlgorithmForFromToPair(toNode);
             final Path path = routingAlgorithm.calcPath(this.fromNode, toNode);
-            this.allFoundPaths.add(path);
+            this.allFoundPaths.put(new Pair(this.fromNode, toNode), path);
         }
     }
 
@@ -49,7 +42,7 @@ private RoutingAlgorithm buildRoutingAlgorithmForFromToPair(int toNode) {
         return routingAlgorithm;
     }
 
-    public List<Path> getAllFoundPaths() {
+    public Map<Pair<Integer, Integer>, Path> getAllFoundPathsMap() {
         return this.allFoundPaths;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygonThrough.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygonThrough.java
index 7ed8ac19b4..0b669cec13 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygonThrough.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygonThrough.java
@@ -1,10 +1,9 @@
 package com.graphhopper.routing.template.polygonRoutingUtil;
 
-import com.graphhopper.routing.DijkstraManyToMany;
 import com.graphhopper.routing.template.PolygonThroughRoutingTemplate;
 
 public class RouteCandidatePolygonThrough extends RouteCandidatePolygon {
-    private final DijkstraManyToMany pathSkeletonRouter;
+    private final ManyToManyRouting pathSkeletonRouter;
     public RouteCandidatePolygonThrough(PolygonThroughRoutingTemplate polygonRoutingTemplate, int startNodeID, int endNodeID,
                                         int polygonEntryNodeID, int polygonExitNodeID) {
         super(polygonRoutingTemplate, startNodeID, endNodeID, polygonEntryNodeID, polygonExitNodeID);
@@ -17,7 +16,7 @@ private void calcPathFromStartToDetourEntry() {
     }
 
     private void calcDetourPath() {
-        this.detourEntryToDetourExit = this.pathSkeletonRouter.getPathByFromEndPoint(polygonEntryNodeID, polygonExitNodeID);
+        this.detourEntryToDetourExit = this.pathSkeletonRouter.getPathByFromEndNodeID(polygonEntryNodeID, polygonExitNodeID);
     }
 
     private void calcPathFromDetourExitToEnd() {
diff --git a/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
index 242cef130c..4dff8a98ef 100644
--- a/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
@@ -5,7 +5,6 @@
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
 import com.graphhopper.routing.util.*;
-import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
@@ -17,18 +16,19 @@
 import static com.graphhopper.util.Parameters.Routing.*;
 
 public class PolygonThroughRoutingTemplateTest {
-    private final PolygonRoutingTestGraph testGraph = new PolygonRoutingTestGraph();
+    private final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
 
     @Test
     public void quickStartingTest() {
         // Just to let something run
         GHRequest request = buildRequest(new GHPoint(25, 0), new GHPoint(25, 46));
         GHResponse response = new GHResponse();
-        final int maxVisitedNodes = this.testGraph.algorithmHints.getInt(MAX_VISITED_NODES, Integer.MAX_VALUE);
-        final RoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(request, response, this.testGraph.locationIndex, this.testGraph.nodeAccess, this.testGraph.graph,
-                                                                            this.testGraph.encodingManager);
+        final int maxVisitedNodes = this.graphMocker.algorithmHints.getInt(MAX_VISITED_NODES, Integer.MAX_VALUE);
+        final RoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(request, response, this.graphMocker.locationIndex, this.graphMocker.nodeAccess,
+                                                                                  this.graphMocker.graph,
+                                                                                  this.graphMocker.encodingManager);
         final RoutingAlgorithmFactory algorithmFactory = new RoutingAlgorithmFactorySimple();
-        final AlgorithmOptions algorithmOptions = testGraph.algorithmOptions;
+        final AlgorithmOptions algorithmOptions = graphMocker.algorithmOptions;
         final QueryGraph queryGraph = createQueryGraph(request, routingTemplate);
 
         List<Path> paths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algorithmOptions);
@@ -37,8 +37,8 @@ public void quickStartingTest() {
     }
 
     private QueryGraph createQueryGraph(GHRequest request, RoutingTemplate routingTemplate) {
-        final QueryGraph queryGraph = new QueryGraph(this.testGraph.graph);
-        List<QueryResult> results = routingTemplate.lookup(request.getPoints(), this.testGraph.flagEncoder);
+        final QueryGraph queryGraph = new QueryGraph(this.graphMocker.graph);
+        List<QueryResult> results = routingTemplate.lookup(request.getPoints(), this.graphMocker.flagEncoder);
         queryGraph.lookup(results);
         return queryGraph;
     }
@@ -50,7 +50,7 @@ private void printPath(List<Path> paths) {
 
     @Test
     public void showAllEdgesWithIDs() {
-        AllEdgesIterator aei = this.testGraph.graph.getAllEdges();
+        AllEdgesIterator aei = this.graphMocker.graph.getAllEdges();
         while (aei.next()) {
             System.out.println(aei.toString());
         }
@@ -74,7 +74,7 @@ private GHRequest buildRequest(GHPoint... startViaEndPoints) {
                 setPointHints(new ArrayList<String>()).
                 setSnapPreventions(new ArrayList<String>()).
                 setPathDetails(new ArrayList<String>()).
-                setPolygon(this.testGraph.polygon).
+                setPolygon(this.graphMocker.polygon).
                 getHints().
                 put(CALC_POINTS, calcPoints).
                 put(INSTRUCTIONS, instructions).
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRoutingTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRoutingTest.java
index 0ac7b551a9..9d0cc8df90 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRoutingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/ManyToManyRoutingTest.java
@@ -23,7 +23,7 @@ public void setUp() {
         final AlgorithmOptions algorithmOptions = this.graphMocker.algorithmOptions;
 
         this.manyToManyRouting = new ManyToManyRouting(nodesToConsiderForRouting, sourceDestinations, this.graphMocker.graph, routingAlgorithmFactory, algorithmOptions);
-        this.manyToManyRouting.findAllPathsBetweenEntryExitPoints();
+        this.manyToManyRouting.findPathBetweenAllNodePairs();
     }
 
     private List<Integer> prepareSourceDestination() {
@@ -34,21 +34,21 @@ public void setUp() {
     public void validate28To28() {
         final List<Integer> firstPathOption = createPathCandidate(28);
 
-        validatePath(0, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate28to29() {
         final List<Integer> firstPathOption = createPathCandidate(28, 29);
 
-        validatePath(1, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate28To30() {
         final List<Integer> firstPathOption = createPathCandidate(28, 47, 30);
 
-        validatePath(2, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
@@ -56,163 +56,166 @@ public void validate28to32() {
         final List<Integer> firstPathOption = createPathCandidate(28, 47, 48, 49, 32);
         final List<Integer> secondPathOption = createPathCandidate(28, 47, 55, 49, 32);
 
-        validatePath(3, firstPathOption, secondPathOption);
+        validatePath(firstPathOption, secondPathOption);
     }
 
     @Test
     public void validate28To40() {
         final List<Integer> firstPathOption = createPathCandidate(28, 46, 53, 52, 40);
 
-        validatePath(4, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate29To28() {
         final List<Integer> firstPathOption = createPathCandidate(29, 28);
 
-        validatePath(5, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate29To29() {
         final List<Integer> firstPathOption = createPathCandidate(29);
 
-        validatePath(6, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate29To30() {
         final List<Integer> firstPathOption = createPathCandidate(29, 30);
 
-        validatePath(7, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate29To32() {
         final List<Integer> firstPathOption = createPathCandidate(29, 48, 49, 32);
 
-        validatePath(8, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate29To40() {
         final List<Integer> firstPathOption = createPathCandidate(29, 48, 55, 57, 52, 40);
 
-        validatePath(9, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate30To28() {
         final List<Integer> firstPathOption = createPathCandidate(30, 47, 28);
 
-        validatePath(10, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate30To29() {
         final List<Integer> firstPathOption = createPathCandidate(30, 29);
 
-        validatePath(11, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate30To30() {
         final List<Integer> firstPathOption = createPathCandidate(30);
 
-        validatePath(12, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate30To32() {
         final List<Integer> firstPathOption = createPathCandidate(30, 48, 49, 32);
 
-        validatePath(13, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate30To40() {
         final List<Integer> firstPathOption = createPathCandidate(30, 48, 55, 57, 52, 40);
 
-        validatePath(14, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate32To28() {
         final List<Integer> firstPathOption = createPathCandidate(32, 49, 48, 47, 28);
 
-        validatePath(15, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate32To29() {
         final List<Integer> firstPathOption = createPathCandidate(32, 49, 48, 29);
 
-        validatePath(16, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate32To30() {
         final List<Integer> firstPathOption = createPathCandidate(32, 49, 48, 30);
 
-        validatePath(17, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate32To32() {
         final List<Integer> firstPathOption = createPathCandidate(32);
 
-        validatePath(18, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate32To40() {
         final List<Integer> firstPathOption = createPathCandidate(32, 49, 50, 51, 52, 40);
 
-        validatePath(19, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate40To28() {
         final List<Integer> firstPathOption = createPathCandidate(40, 52, 53, 46, 28);
 
-        validatePath(20, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate40To29() {
         final List<Integer> firstPathOption = createPathCandidate(40, 52, 57, 55, 48, 29);
 
-        validatePath(21, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate40To30() {
         final List<Integer> firstPathOption = createPathCandidate(40, 52, 57, 55, 48, 30);
 
-        validatePath(22, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate40To32() {
         final List<Integer> firstPathOption = createPathCandidate(40, 52, 51, 50, 49, 32);
 
-        validatePath(23, firstPathOption);
+        validatePath(firstPathOption);
     }
 
     @Test
     public void validate40To40() {
         final List<Integer> firstPathOption = createPathCandidate(40);
 
-        validatePath(24, firstPathOption);
+        validatePath(firstPathOption);
     }
 
-    private void validatePath(final int pathIndex, List<Integer>... possiblePaths) {
-        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(pathIndex);
+    private void validatePath(List<Integer>... possiblePaths) {
+        final int fromNode = possiblePaths[0].get(0);
+        final int toNode = possiblePaths[0].get(possiblePaths[0].size() - 1);
+
+        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(fromNode, toNode);
         OneToManyRoutingTest.validatePath(nodesInPathOrder, possiblePaths);
     }
 
-    private List<Integer> retrieveFoundPathsNode(final int index) {
-        return this.manyToManyRouting.getAllFoundPaths().get(index).getNodesInPathOrder();
+    private List<Integer> retrieveFoundPathsNode(final int fromNode, final int toNode) {
+        return this.manyToManyRouting.getPathByFromEndNodeID(fromNode, toNode).getNodesInPathOrder();
     }
 
     private List<Integer> createPathCandidate(Integer... nodeIdsOnPath) {
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java
index b0554ef618..3d2dc262ae 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRoutingTest.java
@@ -11,23 +11,27 @@
 import java.util.List;
 
 import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
 
 public class OneToManyRoutingTest {
     private final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
     private QueryGraph queryGraph;
     private OneToManyRouting oneToManyRouting;
+    private int fromNode;
+    private List<Integer> toNodes;
 
     @Before
     public void setupOneToManyRouting() {
-        final int fromNode = 28;
-        final List<Integer> toNodes = prepareToNodes();
+        this.fromNode = 28;
+        this.toNodes = prepareToNodes();
         final List<Integer> nodesToConsiderForRouting = prepareInteriorGraph();
         final RoutingAlgorithmFactory routingAlgorithmFactory = new RoutingAlgorithmFactorySimple();
         final AlgorithmOptions algorithmOptions = this.graphMocker.algorithmOptions;
 
         this.prepareQueryGraph(fromNode, toNodes);
         this.oneToManyRouting = new OneToManyRouting(fromNode, toNodes, nodesToConsiderForRouting, queryGraph, routingAlgorithmFactory, algorithmOptions);
-        this.oneToManyRouting.calcAllPaths();
+        this.oneToManyRouting.findPathBetweenAllNodePairs();
     }
 
     private List<Integer> prepareToNodes() {
@@ -54,24 +58,24 @@ private void prepareQueryGraph(final int fromNode, final List<Integer> toNodes)
     }
 
     @Test
-    public void validateFirstPath() {
-        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(0);
+    public void validate28to29() {
+        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(28, 29);
         final List<Integer> firstPathOption = new ArrayList<>(Arrays.asList(new Integer[] {28, 29}));
 
         validatePath(nodesInPathOrder, firstPathOption);
     }
 
     @Test
-    public void validateSecondPath() {
-        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(1);
+    public void validate28to30() {
+        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(28, 30);
         final List<Integer> firstPathOption = new ArrayList<>(Arrays.asList(new Integer[] {28, 47, 30}));
 
         validatePath(nodesInPathOrder, firstPathOption);
     }
 
     @Test
-    public void validateThirdPath() {
-        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(2);
+    public void validate28to32() {
+        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(28, 32);
         final List<Integer> firstPathOption = new ArrayList<>(Arrays.asList(new Integer[] {28, 47, 48, 49, 32}));
         final List<Integer> secondPathOption = new ArrayList<>(Arrays.asList(new Integer[] {28, 47, 55, 49, 32}));
 
@@ -79,15 +83,39 @@ public void validateThirdPath() {
     }
 
     @Test
-    public void validateFourthPath() {
-        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(3);
+    public void validate28to40() {
+        final List<Integer> nodesInPathOrder = this.retrieveFoundPathsNode(28, 40);
         final List<Integer> firstPathOption = new ArrayList<>(Arrays.asList(new Integer[] {28, 46, 53, 52, 40}));
 
         validatePath(nodesInPathOrder, firstPathOption);
     }
 
-    private List<Integer> retrieveFoundPathsNode(final int index) {
-        return this.oneToManyRouting.getAllFoundPaths().get(index).getNodesInPathOrder();
+    @Test
+    public void numberOfPathsFound() {
+        final List<Path> allPaths = this.oneToManyRouting.getAllFoundPaths();
+
+        assertEquals(4, allPaths.size());
+    }
+
+    @Test
+    public void noDuplicatesFound() {
+        final List<Path> allPaths = this.oneToManyRouting.getAllFoundPaths();
+
+        crossValidateAllPathsToFindDuplicates(allPaths);
+    }
+
+    private void crossValidateAllPathsToFindDuplicates(List<Path> allPaths) {
+        for (int i = 0; i < allPaths.size(); i++) {
+            for (int j = 0; j < allPaths.size(); j++) {
+                if (i != j) {
+                    assertNotEquals(allPaths.get(i), allPaths.get(j));
+                }
+            }
+        }
+    }
+
+    private List<Integer> retrieveFoundPathsNode(final int fromNode, final int toNode) {
+        return this.oneToManyRouting.getPathByFromEndNodeID(fromNode, toNode).getNodesInPathOrder();
     }
 
     static void validatePath(final List<Integer> foundPath, final List<Integer>... possibleShortestPaths) {
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
index 423835b6c0..1309f8a252 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
@@ -17,7 +17,8 @@
 public class RouteCandidateTest {
     private final GHRequest ghRequest = new GHRequest(0, 0, 10, 10).setPolygon(new Polygon(new double [] {5, 10, 10, 5}, new double [] {5, 5, 10, 10}));
     private final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
-    private final PolygonThroughRoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(ghRequest, null, graphMocker.locationIndex, graphMocker.nodeAccess, graphMocker.graph
+    private final PolygonThroughRoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(ghRequest, null, graphMocker.locationIndex, graphMocker.nodeAccess,
+                                                                                                    graphMocker.graph
             , graphMocker.encodingManager);
 
 
