diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/core/src/main/java/com/graphhopper/PathWrapper.java
index bb4d9034d2..d9a48e47d6 100644
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/core/src/main/java/com/graphhopper/PathWrapper.java
@@ -20,11 +20,14 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint3D;
 
-import java.util.ArrayList;
-import java.util.Collections;
+import java.awt.*;
+import java.util.*;
 import java.util.List;
 
+import static java.lang.Math.round;
+
 /**
  * This class holds the data like points and instructions of a Path.
  * <p>
@@ -84,6 +87,19 @@ public PointList getPoints() {
         return pointList;
     }
 
+    public HashSet<String> roundPoints() {
+        check("getPoints");
+        HashSet<String> roundedPoints = new HashSet<>();
+        long lon;
+        long lat;
+        for (GHPoint3D pt : pointList) {
+            lon = Math.round(pt.getLon() * 1000);
+            lat = Math.round(pt.getLat() * 1000);
+            roundedPoints.add(lat + "," + lon);
+        }
+        return roundedPoints;
+    }
+
     public PathWrapper setPoints(PointList points) {
         if (pointList != PointList.EMPTY)
             throw new IllegalStateException("Cannot call setPoint twice");
diff --git a/core/src/main/java/com/graphhopper/routing/KSP.java b/core/src/main/java/com/graphhopper/routing/KSP.java
index 87d5063dfe..fa8a7c8891 100644
--- a/core/src/main/java/com/graphhopper/routing/KSP.java
+++ b/core/src/main/java/com/graphhopper/routing/KSP.java
@@ -59,11 +59,11 @@ public int compare(AlternativeInfo o1, AlternativeInfo o2) {
     private final TraversalMode traversalMode;
     private int visitedNodes;
     private int maxVisitedNodes = Integer.MAX_VALUE;
-    private double maxWeightFactor = 2;  // time can be twice as long
+    private double maxWeightFactor = 10;  // time can be twice as long
     // the higher the maxWeightFactor the higher the explorationFactor needs to be
     // 1 is default for bidir Dijkstra, 0.8 seems to be a very similar value for bidir A* but roughly 1/2 of the nodes explored
-    private double maxExplorationFactor = 2;  //
-    private int maxPaths = 100;  // K
+    private double maxExplorationFactor = 10;  //
+    private int maxPaths = 100000;  // K
 
     public KSP(Graph graph, Weighting weighting, TraversalMode traversalMode) {
         this.graph = graph;
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/runFastest.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/runFastest.java
index dc32e929a2..ed09b2d371 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/runFastest.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/runFastest.java
@@ -25,7 +25,7 @@ public static void process_routes(String city, String route_type, boolean useCH)
         // set paths
         String osmFile = "./reader-osm/files/";
         String graphFolder = "./reader-osm/target/tmp/";
-        String inputPointsFN = "../data/output/";
+        String inputPointsFN = "../data/intermediate/";
         String outputPointsFN = "../data/output/";
         if (city.equals("SF")) {
             osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
@@ -40,7 +40,7 @@ public static void process_routes(String city, String route_type, boolean useCH)
         } else {
             return;
         }
-        if (useCH) {
+        if (!useCH) {
             graphFolder = graphFolder + "_noch";
         }
 
@@ -96,8 +96,7 @@ public static void process_routes(String city, String route_type, boolean useCH)
             GHRequest req = new GHRequest(points[0], points[1], points[2], points[3]).  // latFrom, lonFrom, latTo, lonTo
                     setWeighting("fastest").
                     setVehicle("car").
-                    setLocale(Locale.US).
-                    setAlgorithm("dijkstra");
+                    setLocale(Locale.US);
             GHResponse rsp = hopper.route(req);
 
             // first check for errors
@@ -150,10 +149,10 @@ public static void main(String[] args) throws Exception {
         // NYC Grid
         process_routes("NYC", "grid", true);
         // NYC Random
-        //process_routes("NYC", "rand", true);
+        process_routes("NYC", "rand", true);
         // SF Grid
-        //process_routes("SF", "grid", true);
+        process_routes("SF", "grid", true);
         // SF Random
-        //process_routes("SF", "rand", true);
+        process_routes("SF", "rand", true);
     }
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
index 65e4d7ae67..2b6e67352b 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
@@ -25,25 +25,62 @@ public static void process_routes(String city, String route_type, boolean useCH)
         // set paths
         String osmFile = "./reader-osm/files/";
         String graphFolder = "./reader-osm/target/tmp/";
-        String inputPointsFN = "../data/output/";
+        String inputPointsFN = "../data/intermediate/";
         String outputPointsFN = "../data/output/";
+        ArrayList<String> gridValuesFNs = new ArrayList<>();
+        String gvfnStem = "../data/intermediate/";
         if (city.equals("SF")) {
             osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
             graphFolder = graphFolder + "ghosm_sf";
             inputPointsFN = inputPointsFN + "sf_" + route_type + "_od_pairs.csv";
             outputPointsFN = outputPointsFN + "sf_" + route_type + "_graphhopper_routes_ksp.csv";
+            gridValuesFNs.add(gvfnStem + "06075_beauty_flickr.csv");
         } else if (city.equals("NYC")) {
             osmFile = osmFile + "new-york_new-york.osm.pbf";
             graphFolder = graphFolder + "ghosm_nyc";
             inputPointsFN = inputPointsFN + "nyc_" + route_type + "_od_pairs.csv";
             outputPointsFN = outputPointsFN + "nyc_" + route_type + "_graphhopper_routes_ksp.csv";
+            gridValuesFNs.add(gvfnStem + "36005_beauty_flickr.csv");
+            gridValuesFNs.add(gvfnStem + "36047_beauty_flickr.csv");
+            gridValuesFNs.add(gvfnStem + "36061_beauty_flickr.csv");
+            gridValuesFNs.add(gvfnStem + "36081_beauty_flickr.csv");
+            gridValuesFNs.add(gvfnStem + "36085_beauty_flickr.csv");
+        } else if (city.equals("BOS")) {
+            osmFile = osmFile + "boston_massachusetts.osm.pbf";
+            graphFolder = graphFolder + "ghosm_bos";
+            inputPointsFN = inputPointsFN + "bos_" + route_type + "_od_pairs.csv";
+            outputPointsFN = outputPointsFN + "bos_" + route_type + "_graphhopper_routes_ksp.csv";
+            gridValuesFNs.add(gvfnStem + "25025_beauty_twitter.csv");
         } else {
             return;
         }
-        if (useCH) {
+        if (!useCH) {
             graphFolder = graphFolder + "_noch";
         }
 
+        HashMap<String, Integer> gvHeaderMap = new HashMap<>();
+        HashMap<String, Float> gridBeauty = new HashMap<>();
+        for (String fn : gridValuesFNs) {
+            Scanner sc_in = new Scanner(new File(fn));
+            String[] gvHeader = sc_in.nextLine().split(",");
+            int i = 0;
+            for (String col : gvHeader) {
+                gvHeaderMap.put(col, i);
+                i++;
+            }
+            String line;
+            String[] vals;
+            String rc;
+            float beauty;
+            while (sc_in.hasNext()) {
+                line = sc_in.nextLine();
+                vals = line.split(",");
+                rc = vals[gvHeaderMap.get("rid")] + "," + vals[gvHeaderMap.get("cid")];
+                beauty = Float.valueOf(vals[gvHeaderMap.get("beauty")]);
+                gridBeauty.put(rc, beauty);
+            }
+
+        }
         // create one GraphHopper instance
         GraphHopper hopper = new GraphHopperOSM().forDesktop().setCHEnabled(false);
         hopper.setDataReaderFile(osmFile);
@@ -114,28 +151,45 @@ public static void process_routes(String city, String route_type, boolean useCH)
 
             // use the best path, see the GHResponse class for more possibilities.
             List<PathWrapper> paths = rsp.getAll();
-            for (PathWrapper path : paths) {
-
-                // points, distance in meters and time in seconds (convert from ms) of the full path
-                pointList = path.getPoints();
-                double distance = Math.round(path.getDistance() * 100) / 100;
-                long timeInSec = path.getTime() / 1000;
-                InstructionList il = path.getInstructions();
-                int numDirections = il.getSize();
-                // iterate over every turn instruction
-                maneuvers.clear();
-                for (Instruction instruction : il) {
-                    maneuvers.add(instruction.getSimpleTurnDescription());
-                    // System.out.println(instruction.getTurnDescription(usTR) + " for " + instruction.getDistance() + " meters.");
+            HashSet<String> roundedPoints;
+            int j = 0;
+            float maxscore = -1000;
+            int maxidx = 0;
+            for (PathWrapper path: paths) {
+                roundedPoints = path.roundPoints();
+                float score = 0;
+                for (String pt : roundedPoints) {
+                    if (gridBeauty.containsKey(pt)) {
+                        score = score + gridBeauty.get(pt);
+                    }
                 }
-                sc_out.write(od_id + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
-                        ",\"" + maneuvers.toString() + "\"" + System.getProperty("line.separator"));
-                System.out.println(i + ": Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections);
+                score = score / roundedPoints.size();
+                if (score > maxscore) {
+                    maxscore = score;
+                    maxidx = j;
+                }
+                j++;
+            }
+            PathWrapper bestPath = paths.get(maxidx);
+            // points, distance in meters and time in seconds (convert from ms) of the full path
+            pointList = bestPath.getPoints();
+            double distance = Math.round(bestPath.getDistance() * 100) / 100;
+            long timeInSec = bestPath.getTime() / 1000;
+            InstructionList il = bestPath.getInstructions();
+            int numDirections = il.getSize();
+            // iterate over every turn instruction
+            maneuvers.clear();
+            for (Instruction instruction : il) {
+                maneuvers.add(instruction.getSimpleTurnDescription());
+                // System.out.println(instruction.getTurnDescription(usTR) + " for " + instruction.getDistance() + " meters.");
             }
-            break;
+            sc_out.write(od_id + "," + "\"[" + pointList + "]\"," + timeInSec + "," + distance + "," + numDirections +
+                    ",\"" + maneuvers.toString() + "\"" + System.getProperty("line.separator"));
+
+            System.out.println(i + ": Distance: " + distance + "m;\tTime: " + timeInSec + "sec;\t# Directions: " + numDirections);
 
             // or get the json
-            //iList = il.createJson();
+            iList = il.createJson();
             //System.out.println("JSON: " + iList);
 
             // or get the result as gpx entries:
@@ -152,12 +206,13 @@ public static void main(String[] args) throws Exception {
 
         // PBF from: https://mapzen.com/data/metro-extracts/
         // NYC Grid
-        process_routes("NYC", "grid", true);
+        //process_routes("NYC", "grid", true);
         // NYC Random
         //process_routes("NYC", "rand", true);
         // SF Grid
         //process_routes("SF", "grid", true);
         // SF Random
         //process_routes("SF", "rand", true);
+        process_routes("BOS", "check", true);
     }
 }
