diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index e5ba0d3fa8..8d85a2bf79 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -15,6 +15,11 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
+ 
+ // Modified from original to implement custom weighting options
+ // Indoor and Lit weighting were added
+ // Changes made to method: public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
+ 
 package com.graphhopper;
 
 import com.graphhopper.reader.DataReader;
@@ -31,6 +36,7 @@
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -51,6 +57,11 @@
  */
 public class GraphHopper implements GraphHopperAPI
 {
+	// CUSTOM VARIABLES GO HERE
+	// CUSTOM CODE GOES AT THE END OF THE FILE!!
+	// IF ANY METHODS ARE MODIFIED, PLACE LINE NUMBER & METHOD NAME HERE
+	// LINE 945-ish @ public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
+
     private final Logger logger = LoggerFactory.getLogger(getClass());
     // for graph:
     private GraphHopperStorage ghStorage;
@@ -82,7 +93,7 @@
     // for CH prepare    
     private boolean doPrepare = true;
     private boolean chEnabled = true;
-    private final List<String> chWeightingList = new ArrayList<String>(Arrays.asList("fastest"));
+    private String chWeightingStr = "fastest";
     private int chPrepareThreads = -1;
     private ExecutorService chPreparePool;
     private int preparePeriodicUpdates = -1;
@@ -292,60 +303,22 @@ private GraphHopper setUnsafeMemory()
         return this;
     }
 
-    /**
-     * Wrapper method for {@link GraphHopper#setCHWeightings(List)}
-     * <p>
-     * @deprecated This method is used as a deprecated wrapper to not break the JavaApi. This will
-     * be removed in the future. Please use {@link GraphHopper#setCHWeightings(List)} or
-     * {@link GraphHopper#setCHWeightings(String...)}
-     */
-    @Deprecated
-    public GraphHopper setCHWeighting( String weightingName )
-    {
-        return this.setCHWeightings(weightingName);
-    }
-
-    /**
-     * Wrapper method for {@link GraphHopper#setCHWeightings(List)}
-     */
-    public GraphHopper setCHWeightings( String... weightingNames )
-    {
-        return this.setCHWeightings(Arrays.asList(weightingNames));
-    }
-
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p>
      *
-     * @param weightingList A list containing multiple weightings like: "fastest", "shortest" or
-     * your own weight-calculation type.
+     * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
      */
-    public GraphHopper setCHWeightings( List<String> weightingList )
+    public GraphHopper setCHWeighting( String weighting )
     {
         ensureNotLoaded();
-
-        if (weightingList.isEmpty())
-            throw new IllegalArgumentException("It is not allowed to pass an emtpy weightingList");
-
-        this.chWeightingList.clear();
-        for (String weight : weightingList)
-        {
-            weight = weight.toLowerCase();
-            weight = weight.trim();
-            this.chWeightingList.add(weight);
-        }
+        chWeightingStr = weighting.toLowerCase();
         return this;
     }
 
-    /**
-     * Returns all CHWeighting names
-     */
-    public List<String> getCHWeightings()
+    public String getCHWeighting()
     {
-        if (this.chWeightingList.isEmpty())
-            throw new IllegalStateException("Potential bug: chWeightingList is empty");
-
-        return this.chWeightingList;
+        return chWeightingStr;
     }
 
     /**
@@ -657,15 +630,10 @@ public GraphHopper init( CmdArgs args )
         doPrepare = args.getBool("prepare.doPrepare", doPrepare);
         setCHPrepareThreads(args.getInt("prepare.threads", chPrepareThreads));
 
-        String chWeightingsStr = args.get("prepare.chWeightings", "");
-        // remove when deprecated setCHWeighting method is removed
-        if (chWeightingsStr.isEmpty())
-            chWeightingsStr = args.get("prepare.chWeighting", "fastest");
-
-        List<String> tmpCHWeightingList = Arrays.asList(chWeightingsStr.split(","));
-        chEnabled = !"no".equals(chWeightingsStr);
+        String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
+        chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
         if (chEnabled)
-            setCHWeightings(tmpCHWeightingList);
+            setCHWeighting(tmpCHWeighting);
 
         preparePeriodicUpdates = args.getInt("prepare.updates.periodic", preparePeriodicUpdates);
         prepareLazyUpdates = args.getInt("prepare.updates.lazy", prepareLazyUpdates);
@@ -903,11 +871,8 @@ private void initCHAlgoFactories()
         if (algoFactories.isEmpty())
             for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders())
             {
-                for (String chWeightingStr : getCHWeightings())
-                {
-                    Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), encoder);
-                    algoFactories.put(weighting, null);
-                }
+                Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), encoder);
+                algoFactories.put(weighting, null);
             }
     }
 
@@ -975,6 +940,8 @@ private boolean isPrepared()
      * @return the weighting to be used for route calculation
      * @see WeightingMap
      */
+	 
+	//THIS METHOD HAS BEEN MODIFIED TO ALLOW FOR INDOOR ROUTING
     public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder )
     {
         String weighting = weightingMap.getWeighting().toLowerCase();
@@ -994,7 +961,15 @@ public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder
                 return new CurvatureWeighting(encoder, weightingMap, ghStorage);
             else
                 return new FastestWeighting(encoder, weightingMap);
-        }
+        } 
+		// CUSTOM CONDITION ADDED HERE
+		else if("indoors".equalsIgnoreCase(weighting)) {
+			return new IndoorWeighting(encoder);
+		}
+		else if("lit".equalsIgnoreCase(weighting)) {
+			return new LitWeighting(encoder);
+		}
+		// END CUSTOM CODE
 
         throw new UnsupportedOperationException("weighting " + weighting + " not supported");
     }
@@ -1004,8 +979,8 @@ public Weighting getWeightingForCH( WeightingMap weightingMap, FlagEncoder encod
         // get requested weighting name
         String weightingStr = weightingMap.getWeighting().toLowerCase();
         if (weightingStr.isEmpty())
-            weightingStr = getCHWeightings().get(0);
-
+            weightingStr = chWeightingStr;
+        
         for (Weighting w : algoFactories.keySet())
         {
             if (w.matches(weightingStr, encoder))
diff --git a/core/src/main/java/com/graphhopper/routing/util/IndoorWeighting.java b/core/src/main/java/com/graphhopper/routing/util/IndoorWeighting.java
new file mode 100755
index 0000000000..6060692d5c
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/IndoorWeighting.java
@@ -0,0 +1,104 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
+import java.util.HashSet;
+/**
+ * Places higher priority on indoor routes
+ *	The indoorEdges set contains a list of indoor streets by name
+ *  It is generated in this file for better code separation
+**/
+public class IndoorWeighting implements Weighting
+{
+	// This sets the priority for using indoor streets
+	// A factor of 2 is the same as saying the distance is 1/2 compared to a street not in the set
+	private final int INDOOR_PRIORITY_FACTOR = 8;
+
+	private final FlagEncoder flagEncoder;
+	private final double maxSpeed;
+	
+	// Initialized by determineIndoorEdges() at the end of this class
+	private static HashSet<String> indoorEdges;
+
+    public IndoorWeighting( FlagEncoder encoder)
+    {
+		this.flagEncoder = encoder;
+        maxSpeed = encoder.getMaxSpeed();
+		determineIndoorEdges();
+    }
+	
+	@Override
+    public double getMinWeight( double distance )
+    {
+        return distance / maxSpeed;
+    }
+
+    @Override
+    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
+    {
+		double speed = reverse ? flagEncoder.getReverseSpeed(edge.getFlags()) : flagEncoder.getSpeed(edge.getFlags());
+		if(indoorEdges.contains(edge.getName()))
+			return edge.getDistance() / (speed * INDOOR_PRIORITY_FACTOR);
+
+		// Outdoor routes get normal weighting
+		return edge.getDistance() / speed;
+    }
+
+    @Override
+    public boolean matches( String weightingAsStr, FlagEncoder encoder )
+    {
+        return getName().equals(weightingAsStr) && encoder == flagEncoder;
+    }	
+	
+	@Override
+    public FlagEncoder getFlagEncoder()
+    {
+        return flagEncoder;
+    }
+	
+    @Override
+    public String getName()
+    {
+        return "indoors";
+    }
+	
+	
+	public static void determineIndoorEdges() {
+		indoorEdges = new HashSet<String>();
+		
+		indoorEdges.add("BB1");
+		indoorEdges.add("BB3");
+		indoorEdges.add("BB2");
+		indoorEdges.add("Chrysler Hall 1");
+		indoorEdges.add("Chrysler Hall 2");
+		indoorEdges.add("Chrysler Hall 3");
+		indoorEdges.add("Chrysler Hall South 1");
+		indoorEdges.add("Odette 1");
+		indoorEdges.add("Odette 2");
+		indoorEdges.add("CHN 1");
+		indoorEdges.add("CHN 4");
+		indoorEdges.add("CHN 2");
+		indoorEdges.add("Essex 1");
+		indoorEdges.add("Essex 4");
+		indoorEdges.add("Essex 7");
+		indoorEdges.add("Essex 8");
+		indoorEdges.add("DH1");
+		indoorEdges.add("DH3");
+		indoorEdges.add("DH4");
+		indoorEdges.add("DH2");
+		indoorEdges.add("Memorial Hall");
+		indoorEdges.add("MH1");
+		indoorEdges.add("MH2");
+		indoorEdges.add("Law Library");
+		indoorEdges.add("Toldo");
+		indoorEdges.add("CAW 4");
+		indoorEdges.add("CAW 5");
+		indoorEdges.add("CAW 6");
+		indoorEdges.add("CAW 7");
+		indoorEdges.add("CAW 9");
+		indoorEdges.add("CAW 10");
+		indoorEdges.add("LT 1");
+		indoorEdges.add("Erie 1");
+		indoorEdges.add("Leddy 2"); // Incomplete list; only for testing purposes
+	}
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/LitWeighting.java b/core/src/main/java/com/graphhopper/routing/util/LitWeighting.java
new file mode 100755
index 0000000000..434df10e09
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/LitWeighting.java
@@ -0,0 +1,73 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
+import java.util.HashSet;
+/**
+ * Places higher priority on lit routes (safer routes)
+ *
+**/
+public class LitWeighting implements Weighting
+{
+	// This sets the priority for using lit streets
+	// A factor of 2 is the same as saying the distance is 1/2 compared to a street not in the set
+	private final int LIT_PRIORITY_FACTOR = 8;
+
+	private final FlagEncoder flagEncoder;
+	private final double maxSpeed;
+	private static HashSet<String> litEdges;
+
+    public LitWeighting( FlagEncoder encoder )
+    {
+		this.flagEncoder = encoder;
+        maxSpeed = encoder.getMaxSpeed();
+		determineLitEdges();
+    }
+	
+	@Override
+    public double getMinWeight( double distance )
+    {
+        return distance / maxSpeed;
+    }
+
+    @Override
+    public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
+    {
+		double speed = reverse ? flagEncoder.getReverseSpeed(edge.getFlags()) : flagEncoder.getSpeed(edge.getFlags());
+		// Indoor edge; cut weight in 12
+		if(edge.getName() != null && litEdges.contains(edge.getName()))
+			return edge.getDistance() / (speed * LIT_PRIORITY_FACTOR);
+
+		// Outdoor routes get normal weighting
+		return edge.getDistance() / speed;
+    }
+
+    @Override
+    public boolean matches( String weightingAsStr, FlagEncoder encoder )
+    {
+        return getName().equals(weightingAsStr) && encoder == flagEncoder;
+    }	
+	
+	@Override
+    public FlagEncoder getFlagEncoder()
+    {
+        return flagEncoder;
+    }
+	
+    @Override
+    public String getName()
+    {
+        return "lit";
+    }
+	
+	public static void determineLitEdges() {
+		litEdges = new HashSet<String>();
+		
+		litEdges.add("Sunset Avenue Pedestrian Area");
+		litEdges.add("Sunset Avenue");
+		litEdges.add("DH Courtyard");
+		litEdges.add("DH Courtyard 2");
+		litEdges.add("Leddy 1");
+		
+	}
+}
diff --git a/graphhopper.sh b/graphhopper.sh
index 51f5cdaf5a..0edc95d8f3 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -1,5 +1,9 @@
 #!/bin/bash
 
+# This is mostly the same as the original graphhopper.sh file
+# The only change is that the JETTY_PORT value is changed from the default to 8080
+# This was done because it was a straightforward way to set up 2 HTTP application servers on the same host
+
 GH_CLASS=com.graphhopper.tools.Import
 GH_HOME=$(dirname "$0")
 JAVA=$JAVA_HOME/bin/java
@@ -207,7 +211,7 @@ else
 fi
 
 if [ "$JAVA_OPTS" = "" ]; then
-  JAVA_OPTS="-Xmx1000m -Xms1000m -server"
+  JAVA_OPTS="-Xmx1000m -Xms512m -server"
 fi
 
 
@@ -215,12 +219,12 @@ ensureOsmXml
 ensureMaven
 packageCoreJar
 
-echo "## now $ACTION. JAVA_OPTS=$JAVA_OPTS"
+echo "## now $ACTION. JAVA_OPTS=$JAVA_OPTS. GH_WEB_OPTS: $GH_WEB_OPTS"
 
 if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
   export MAVEN_OPTS="$MAVEN_OPTS $JAVA_OPTS"
-  if [ "$JETTY_PORT" = "" ]; then  
-    JETTY_PORT=8989
+  if [ "$JETTY_PORT" = "" ]; then
+    JETTY_PORT=8080
   fi
   WEB_JAR="$GH_HOME/web/target/graphhopper-web-$VERSION-with-dep.jar"
   if [ ! -s "$WEB_JAR" ]; then         
@@ -228,7 +232,7 @@ if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
   fi
 
   RC_BASE=./web/src/main/webapp
-
+  
   if [ "$GH_FOREGROUND" = "" ]; then
     exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
 	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
