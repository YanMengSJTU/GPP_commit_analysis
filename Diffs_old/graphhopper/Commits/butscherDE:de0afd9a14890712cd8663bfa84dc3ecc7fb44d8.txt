diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 03687d0ee9..0230aab5a2 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -29,10 +29,7 @@
 import com.graphhopper.routing.profiles.EnumEncodedValue;
 import com.graphhopper.routing.profiles.RoadEnvironment;
 import com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks;
-import com.graphhopper.routing.template.AlternativeRoutingTemplate;
-import com.graphhopper.routing.template.RoundTripRoutingTemplate;
-import com.graphhopper.routing.template.RoutingTemplate;
-import com.graphhopper.routing.template.ViaRoutingTemplate;
+import com.graphhopper.routing.template.*;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.util.parsers.DefaultTagParserFactory;
 import com.graphhopper.routing.util.parsers.TagParserFactory;
@@ -1074,7 +1071,7 @@ public GHResponse route(GHRequest request) {
             AlgorithmOptions algoOpts = buildAlgorithmOptions(hints, tMode, algoStr, weighting, maxVisitedNodesForRequest);
 
             // do the actual route calculation !
-            altPaths = routePointsAndPolygons(routingTemplate, tmpAlgoFactory, queryGraph, algoOpts);
+            altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
 
             boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
             boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
@@ -1094,115 +1091,6 @@ public GHResponse route(GHRequest request) {
 
         readLock.unlock();
         return altPaths;
-
-
-    }
-
-    private List<Path> routePointsAndPolygons(RoutingTemplate routingTemplate, RoutingAlgorithmFactory tmpAlgoFactory, QueryGraph queryGraph, AlgorithmOptions algoOpts) {
-        List<Path> altPaths;
-
-        if (routingTemplate.getGhRequest().getPolygon().size() <= 0) {
-            altPaths = routeWithoutPolygon(routingTemplate, tmpAlgoFactory, queryGraph, algoOpts);
-        } else {
-            altPaths = routeWithPolygon(routingTemplate, tmpAlgoFactory, queryGraph, algoOpts);
-        }
-        return altPaths;
-    }
-
-    private List<Path> routeWithPolygon(RoutingTemplate routingTemplate, RoutingAlgorithmFactory tmpAlgoFactory, QueryGraph queryGraph, AlgorithmOptions algoOpts) {
-        List<QueryResult> additionalPoints = this.findViaPointsToFullfillPolygonOrientedRouting(routingTemplate);
-
-        throw new NotImplementedException();
-    }
-
-    private List<QueryResult> findViaPointsToFullfillPolygonOrientedRouting(RoutingTemplate routingTemplate) {
-        List<Integer> nodesInPolygon = getNodesInPolygon(routingTemplate);
-        List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
-        List<Integer> subgraphNodes = nodeUnion(nodesInPolygon, polygonEntryExitPoints);
-        List<Integer> pathSkeleton = calculatePathSkeleton(subgraphNodes);
-
-        throw new NotImplementedException();
-    }
-
-    private List<Integer> nodeUnion(List<Integer> nodesInPolygon, List<Integer> polygonEntryExitPoints) {
-        List<Integer> subgraphNodes = new ArrayList<>(nodesInPolygon.size() + polygonEntryExitPoints.size());
-        subgraphNodes.addAll(nodesInPolygon);
-        subgraphNodes.addAll(polygonEntryExitPoints);
-        return subgraphNodes;
-    }
-
-    // According to Prof. Storandts paper Region-Aware Route Planning Definition 2.
-    private List<Integer> calculatePathSkeleton(final List<Integer>  subGraphNodes) {
-        throw new NotImplementedException();
-    }
-
-    private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
-        final List<Integer> entryExitPoints = new LinkedList<>();
-        final EdgeExplorer edgeExplorer = ghStorage.getBaseGraph().createEdgeExplorer();
-
-        addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(nodesInPolygon, entryExitPoints, edgeExplorer);
-
-        return entryExitPoints;
-    }
-
-    private void addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeExplorer edgeExplorer) {
-        for (int node : nodesInPolygon) {
-            final EdgeIterator edgeIterator = edgeExplorer.setBaseNode(node);
-
-            do {
-                addToEntryExitIfNotExistentAndNotInPolygon(nodesInPolygon, entryExitPoints, edgeIterator);
-            } while (edgeIterator.next());
-        }
-    }
-
-    private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeIterator edgeIterator) {
-        final int adjacentNode = edgeIterator.getAdjNode();
-        if (!nodesInPolygon.contains(adjacentNode) && !entryExitPoints.contains(adjacentNode)) {
-            entryExitPoints.add(adjacentNode);
-        }
-    }
-
-    private List<Integer> filterOutNodesNotInPolygon(final List<Integer> nodes, final Polygon polygon) {
-        final List<Integer> filterResult = new LinkedList<>();
-
-        while (!nodes.isEmpty()) {
-            filterNextNode(nodes, polygon, filterResult);
-        }
-
-        return filterResult;
-    }
-
-    private void filterNextNode(List<Integer> nodes, Polygon polygon, List<Integer> filterResult) {
-        int nodeToFilter = popNode(nodes);
-        final NodeAccess nodeAccess = ghStorage.getNodeAccess();
-        final double lat = nodeAccess.getLat(nodeToFilter);
-        final double lon = nodeAccess.getLon(nodeToFilter);
-
-        if (polygon.contains(lat, lon)) {
-            filterResult.add(nodeToFilter);
-        }
-    }
-
-    private int popNode(List<Integer> nodes) {
-        final int nodeToFilter = nodes.get(0);
-        nodes.remove(0);
-        return nodeToFilter;
-    }
-
-    private List<Integer> getNodesInPolygon(RoutingTemplate routingTemplate) {
-        final Polygon polygon = routingTemplate.getGhRequest().getPolygon();
-        final NodeAccess nodeAccess = this.ghStorage.getNodeAccess();
-
-        BBox minimumPolygonBoundingBox = BBox.createMinimalBoundingBoxFromPolygon(polygon);
-        final NodesInPolygonFindingVisitor visitor =new NodesInPolygonFindingVisitor(polygon, nodeAccess);
-        this.locationIndex.query(minimumPolygonBoundingBox, visitor);
-        return visitor.getNodesInPolygon();
-    }
-
-    private List<Path> routeWithoutPolygon(RoutingTemplate routingTemplate, RoutingAlgorithmFactory tmpAlgoFactory, QueryGraph queryGraph, AlgorithmOptions algoOpts) {
-        List<Path> altPaths;
-        altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
-        return altPaths;
     }
 
     private boolean isCHUsageGranted(boolean disableCH) {
@@ -1264,12 +1152,18 @@ private RoutingTemplate buildRoutingTemplate(GHRequest request, GHResponse ghRsp
             routingTemplate = new RoundTripRoutingTemplate(request, ghRsp, locationIndex, encodingManager, maxRoundTripRetries);
         } else if (ALT_ROUTE.equalsIgnoreCase(algoStr)) {
             routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
+        } else if (validPolygonInRequest(request)) {
+            routingTemplate = new PolygonRoutingTemplate(request, ghRsp, locationIndex, this, encodingManager);
         } else {
-            routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
+                routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
         }
         return routingTemplate;
     }
 
+    private boolean validPolygonInRequest(GHRequest request) {
+        return request.getPolygon().size() > 2;
+    }
+
     /**
      * This method applies the changes to the graph specified as feature collection. It does so by locking the routing
      * to avoid concurrent changes which could result in incorrect routing (like when done while a Dijkstra search) or
@@ -1603,27 +1497,4 @@ BuilderForWeightingAndQueryGraph invoke() {
             return this;
         }
     }
-
-    private class NodesInPolygonFindingVisitor extends LocationIndex.Visitor {
-        private final List<Integer> nodesInPolygon = new LinkedList<>();
-        private final Polygon polygon;
-        private final NodeAccess nodeAccess;
-
-        public NodesInPolygonFindingVisitor(final Polygon polygon, final NodeAccess nodeAccess) {
-            this.polygon = polygon;
-            this.nodeAccess = nodeAccess;
-        }
-
-        @Override
-        public void onNode(int nodeId) {
-            final double lat = nodeAccess.getLat(nodeId);
-            final double lon = nodeAccess.getLon(nodeId);
-
-            if (polygon.contains(lat, lon)) {
-                this.nodesInPolygon.add(nodeId);
-            }
-        }
-
-        public List<Integer> getNodesInPolygon() { return this.nodesInPolygon; }
-    };
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
new file mode 100644
index 0000000000..b44e2e1d42
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -0,0 +1,146 @@
+package com.graphhopper.routing.template;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.Polygon;
+import sun.reflect.generics.reflectiveObjects.NotImplementedException;
+
+import java.util.LinkedList;
+import java.util.List;
+
+public class PolygonRoutingTemplate extends ViaRoutingTemplate {
+    private final Polygon polygon;
+    private final GraphHopper gh;
+    private final GraphHopperStorage ghStorage;
+
+    public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, GraphHopper gh,
+                                  EncodingManager encodingManager) {
+        super(ghRequest, ghRsp, locationIndex, encodingManager);
+        this.polygon = ghRequest.getPolygon();
+        this.gh = gh;
+        this.ghStorage = this.gh.getGraphHopperStorage();
+    }
+
+    @Override
+    public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
+        return routeWithPolygon(algoFactory, queryGraph, algoOpts);
+    }
+
+    private List<Path> routeWithPolygon(RoutingAlgorithmFactory tmpAlgoFactory, QueryGraph queryGraph, AlgorithmOptions algoOpts) {
+        List<QueryResult> additionalPoints = this.findViaPointsToFullfillPolygonOrientedRouting(algoOpts);
+
+        throw new NotImplementedException();
+    }
+
+    private List<QueryResult> findViaPointsToFullfillPolygonOrientedRouting(AlgorithmOptions algoOpts) {
+        List<Integer> nodesInPolygon = getNodesInPolygon();
+        List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
+        List<Integer> pathSkeleton = calculatePathSkeleton(nodesInPolygon, polygonEntryExitPoints, algoOpts);
+
+        throw new NotImplementedException();
+    }
+
+        private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
+        final List<Integer> entryExitPoints = new LinkedList<>();
+        final EdgeExplorer edgeExplorer = ghStorage.getBaseGraph().createEdgeExplorer();
+
+        addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(nodesInPolygon, entryExitPoints, edgeExplorer);
+
+        return entryExitPoints;
+    }
+
+    private void addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeExplorer edgeExplorer) {
+        for (int node : nodesInPolygon) {
+            final EdgeIterator edgeIterator = edgeExplorer.setBaseNode(node);
+
+            do {
+                addToEntryExitIfNotExistentAndNotInPolygon(nodesInPolygon, entryExitPoints, edgeIterator);
+            } while (edgeIterator.next());
+        }
+    }
+
+    private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeIterator edgeIterator) {
+        final int adjacentNode = edgeIterator.getAdjNode();
+        if (!nodesInPolygon.contains(adjacentNode) && !entryExitPoints.contains(adjacentNode)) {
+            entryExitPoints.add(adjacentNode);
+        }
+    }
+
+    // According to Prof. Storandts paper Region-Aware Route Planning Definition 2.
+    private List<Integer> calculatePathSkeleton(List<Integer> subGraphNodes, final List<Integer> polygonEntryExitPoints, AlgorithmOptions algoOpts) {
+        DijkstraManyToMany dijkstraMTM = new DijkstraManyToMany(this.ghStorage.getBaseGraph(), algoOpts.getWeighting(), algoOpts.getTraversalMode(), subGraphNodes,
+                                                                polygonEntryExitPoints);
+        dijkstraMTM.findAllPathsBetweenEntryExitPoints();
+        return dijkstraMTM.buildPathSkeleton();
+    }
+
+    private List<Integer> filterOutNodesNotInPolygon(final List<Integer> nodes, final Polygon polygon) {
+        final List<Integer> filterResult = new LinkedList<>();
+
+        while (!nodes.isEmpty()) {
+            filterNextNode(nodes, polygon, filterResult);
+        }
+
+        return filterResult;
+    }
+
+    private void filterNextNode(List<Integer> nodes, Polygon polygon, List<Integer> filterResult) {
+        int nodeToFilter = popNode(nodes);
+        final NodeAccess nodeAccess = this.ghStorage.getNodeAccess();
+        final double lat = nodeAccess.getLat(nodeToFilter);
+        final double lon = nodeAccess.getLon(nodeToFilter);
+
+        if (polygon.contains(lat, lon)) {
+            filterResult.add(nodeToFilter);
+        }
+    }
+
+    private int popNode(List<Integer> nodes) {
+        final int nodeToFilter = nodes.get(0);
+        nodes.remove(0);
+        return nodeToFilter;
+    }
+
+    private List<Integer> getNodesInPolygon() {
+        final Polygon polygon = this.getGhRequest().getPolygon();
+        final NodeAccess nodeAccess = gh.getGraphHopperStorage().getNodeAccess();
+
+        BBox minimumPolygonBoundingBox = BBox.createMinimalBoundingBoxFromPolygon(polygon);
+        final NodesInPolygonFindingVisitor visitor =new NodesInPolygonFindingVisitor(polygon, nodeAccess);
+        this.gh.getLocationIndex().query(minimumPolygonBoundingBox, visitor);
+        return visitor.getNodesInPolygon();
+    }
+
+    private class NodesInPolygonFindingVisitor extends LocationIndex.Visitor {
+        private final List<Integer> nodesInPolygon = new LinkedList<>();
+        private final Polygon polygon;
+        private final NodeAccess nodeAccess;
+
+        public NodesInPolygonFindingVisitor(final Polygon polygon, final NodeAccess nodeAccess) {
+            this.polygon = polygon;
+            this.nodeAccess = nodeAccess;
+        }
+
+        @Override
+        public void onNode(int nodeId) {
+            final double lat = nodeAccess.getLat(nodeId);
+            final double lon = nodeAccess.getLon(nodeId);
+
+            if (polygon.contains(lat, lon)) {
+                this.nodesInPolygon.add(nodeId);
+            }
+        }
+
+        public List<Integer> getNodesInPolygon() { return this.nodesInPolygon; }
+    }
+}
