diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 6479551aee..db99ddd34a 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -387,6 +387,7 @@ public InstructionList calcInstructions( final Translation tr )
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
             private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
+            private int prevNode = -1;
             private double prevOrientation;
             private Instruction prevInstruction;
             private boolean prevInRoundabout = false;
@@ -443,6 +444,18 @@ public void next( EdgeIteratorState edge, int index )
                                     annotation, new PointList(10, nodeAccess.is3D()));
                             if (prevName != null)
                             {
+                                // check if there is an exit at the same node the roundabout was entered
+                                EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
+                                while (edgeIter.next()) 
+                                {
+                                    if ((edgeIter.getAdjNode() != prevNode) 
+                                         && !encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT))
+                                    {
+                                        roundaboutInstruction.increaseExitNumber();
+                                        break;
+                                    }
+                                }
+
                                 // previous orientation is last orientation before entering roundabout
                                 prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
 
@@ -463,14 +476,16 @@ public void next( EdgeIteratorState edge, int index )
                             ways.add(prevInstruction);
                         }
 
-                        // Add passed exits to instruction. There is an exit if there are
-                        // at least 2 out-going edges (one continuing in the roundabout)
-                        // This could lead to problems if there are non-complete roundabouts!
+                        // Add passed exits to instruction. A node is countet if there is at least one outgoing edge
+                        // out of the roundabout
                         EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
-                        edgeIter.next();
-                        if (edgeIter.next())
+                        while (edgeIter.next())
                         {
-                            ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
+                            if (!encoder.isBool(edgeIter.getFlags(), encoder.K_ROUNDABOUT))
+                            {
+                                ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
+                                break;
+                            }
                         }
 
                     } else if (prevInRoundabout) //previously in roundabout but not anymore
@@ -554,7 +569,9 @@ public void next( EdgeIteratorState edge, int index )
                     doublePrevLat = wayGeo.getLatitude(beforeLast);
                     doublePrevLong = wayGeo.getLongitude(beforeLast);
                 }
+                
                 prevInRoundabout = isRoundabout;
+                prevNode = baseNode;
                 prevLat = adjLat;
                 prevLon = adjLon;
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 021114f241..fcf8179ec5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -313,6 +313,12 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
             encoded = handleSpeed(way, speed, encoded);
             encoded = handleBikeRelated(way, encoded, relationFlags > UNCHANGED.getValue());
 
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+            {
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
+            }
+
         } else
         {
             encoded = handleFerryTags(way,
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 9f449d659e..b11e3182a6 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -262,7 +262,7 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
 
         long encoded;
         if (!isFerry(allowed))
-        {
+        {           
             String sacScale = way.getTag("sac_scale");
             if (sacScale != null)
             {
@@ -282,6 +282,12 @@ public long handleWayTags( OSMWay way, long allowed, long relationFlags )
 
             encoded = setLong(encoded, PriorityWeighting.KEY, handlePriority(way, priorityFromRelation));
 
+            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            if (isRoundabout)
+            {
+                encoded = setBool(encoded, K_ROUNDABOUT, true);
+            }
+
         } else
         {
             encoded = handleFerryTags(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 61922dbdc7..2da8f5e766 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -51,7 +51,7 @@
     public static final String OS_VERSION = System.getProperty("os.version");
     public static final String JAVA_VENDOR = System.getProperty("java.vendor");
     public static final int VERSION_NODE = 4;
-    public static final int VERSION_EDGE = 11;
+    public static final int VERSION_EDGE = 12;
     public static final int VERSION_GEOMETRY = 3;
     public static final int VERSION_LOCATION_IDX = 2;
     public static final int VERSION_NAME_IDX = 2;
diff --git a/core/src/test/java/com/graphhopper/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
index b88ba45408..072d094b7f 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -312,8 +312,11 @@ public void testRoundaboutInstructionsWithCH()
 
         rsp = tmpHopper.route(new GHRequest(43.745948, 7.42914, 43.746173, 7.428834)
                 .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
-
         assertEquals(1, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+
+        rsp = tmpHopper.route(new GHRequest(43.735817,7.417096, 43.735666,7.416587)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 59f0747242..6b684c5120 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -39,9 +39,12 @@
 {
     private final FlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager carManager = new EncodingManager(encoder);
+    private final EncodingManager mixedEncoders = new EncodingManager(
+            new CarFlagEncoder(), new FootFlagEncoder(),new BikeFlagEncoder());
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
     private final AngleCalc ac = new AngleCalc();
+    private final RoundaboutGraph roundaboutGraph = new RoundaboutGraph();
 
     @Test
     public void testFound()
@@ -213,14 +216,15 @@ public void testFindInstruction()
 
     private class RoundaboutGraph
     {
-        public EdgeIteratorState edge2change;
-        boolean clockwise;
-        final public Graph g = new GraphBuilder(carManager).create();
+        private EdgeIteratorState edge3to6, edge3to9;
+        boolean clockwise = false;
+        final public Graph g = new GraphBuilder(mixedEncoders).create();
         final public NodeAccess na = g.getNodeAccess();
+        List<EdgeIteratorState> roundaboutEdges = new LinkedList<EdgeIteratorState>();
 
-        private RoundaboutGraph(boolean clockwise)
+        private RoundaboutGraph()
         {
-            //
+            //                          
             //      8
             //       \
             //         5
@@ -228,34 +232,78 @@ private RoundaboutGraph(boolean clockwise)
             //  1 - 2    4 - 7
             //       \  /
             //        3
-            //        |
-            //        6
+            //        | \
+            //        6 [ 9 ] edge 9 is turned off in default mode 
 
             na.setNode(1, 52.514, 13.348);
             na.setNode(2, 52.514, 13.349);
             na.setNode(3, 52.5135,13.35);
             na.setNode(4, 52.514, 13.351);
             na.setNode(5, 52.5145,13.351);
-            na.setNode(6, 52.513, 13.351);
+            na.setNode(6, 52.513, 13.35);
             na.setNode(7, 52.514, 13.352);
             na.setNode(8, 52.515, 13.351);
-
+            na.setNode(9, 52.513, 13.351);
+          
+           
             EdgeIteratorState tmpEdge;
             tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
-            tmpEdge = clockwise? g.edge(3, 2, 5, false).setName("2-3") : g.edge(2, 3, 5, false).setName("2-3");
-            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-            tmpEdge = clockwise? g.edge(4, 3, 5, false).setName("3-4") : g.edge(3, 4, 5, false).setName("3-4");
-            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-            tmpEdge = clockwise? g.edge(5, 4, 5, false).setName("4-5") : g.edge(4, 5, 5, false).setName("4-5");
-            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
-            tmpEdge = clockwise? g.edge(2, 5, 5, false).setName("5-2") : g.edge(5, 2, 5, false).setName("5-2");
-            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            
+            // roundabout
+            tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+            roundaboutEdges.add(tmpEdge.detach(false));
+            tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+            roundaboutEdges.add(tmpEdge.detach(false));
+
             tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
             tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+
             tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
-            edge2change = tmpEdge.detach(false);
+            edge3to6 = tmpEdge.detach(false);
+
+            tmpEdge = g.edge(3, 9, 5, false).setName("3-9");
+            edge3to9 = tmpEdge.detach(false);
+            
+            setRoundabout(clockwise);
+            inverse3to9();
+            
+        }
+        
+        public void setRoundabout(boolean clockwise)
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                for (EdgeIteratorState edge : roundaboutEdges)
+                {
+                    edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
+                    edge.setFlags(encoder.setBool(edge.getFlags(), encoder.K_ROUNDABOUT, true));
+                }
+            }    
             this.clockwise = clockwise;
         }
+        
+        public void inverse3to9()
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to9.getFlags();
+                edge3to9.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), false));
+            }
+        }
+
+        public void inverse3to6()
+        {
+            for (FlagEncoder encoder: mixedEncoders.fetchEdgeEncoders())
+            {
+                long flags = edge3to6.getFlags();
+                edge3to6.setFlags(encoder.setAccess(flags, !encoder.isForward(flags), true));
+            }
+        }
+        
 
         private double getAngle(int n1, int n2, int n3, int n4)
         {
@@ -268,63 +316,85 @@ private double getAngle(int n1, int n2, int n3, int n4)
         }
     }
 
+    /**
+     * Test roundabout instructions for different profiles
+     */
     @Test
     public void testCalcInstructionsRoundabout()
     {
-        RoundaboutGraph rg = new RoundaboutGraph(false);
-        rg.edge2change.setFlags(encoder.setAccess(rg.edge2change.getFlags(), true, false));
-        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        for(FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders())
+        {
+            Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                    .calcPath(1, 8);
+            InstructionList wayList = p.calcInstructions(tr);
+            // Test instructions
+            List<String> tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 3 onto 5-8",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
+            RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+
+            // case of continuing a street through a roundabout
+            p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+            wayList = p.calcInstructions(tr);
+            tmpList = pick("text", wayList.createJson());
+            assertEquals(Arrays.asList("Continue onto MainStreet",
+                            "At roundabout, take exit 2 onto MainStreet",
+                            "Finish!"),
+                    tmpList);
+            // Test Radian
+            delta = roundaboutGraph.getAngle(1, 2, 4, 7);
+            instr = (RoundaboutInstruction) wayList.get(1);
+            assertEquals(delta, instr.getRadian(), 0.01);
+        }
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(2, 8);
         InstructionList wayList = p.calcInstructions(tr);
-        // Test instructions
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet",
-                        "At roundabout, take exit 3 onto 5-8",
-                        "Finish!"),
-                tmpList);
-        // Test Radian
-        double delta = rg.getAngle(1, 2, 5, 8);
-        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
-        assertEquals(delta, instr.getRadian(), 0.01);
-
-        // case of continuing a street through a roundabout
-        p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
-        wayList = p.calcInstructions(tr);
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet",
-                        "At roundabout, take exit 2 onto MainStreet",
-                        "Finish!"),
+        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
+                                    "Finish!"),
                 tmpList);
-        // Test Radian
-        delta = rg.getAngle(1, 2, 4, 7);
-        instr = (RoundaboutInstruction) wayList.get(1);
-        assertEquals(delta, instr.getRadian(), 0.01);
     }
 
     /**
-     * case with one edge being not an exit
+     * case with one node being containig already exit 
      */
     @Test
-    public void testCalcInstructionsRoundabout2()
+    public void testCalcInstructionsRoundaboutDirectExit()
     {
-        RoundaboutGraph rg = new RoundaboutGraph(false);
-        rg.edge2change.setFlags(encoder.setAccess(rg.edge2change.getFlags(), true, false));
-        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
+        roundaboutGraph.inverse3to9();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
-                                    "Finish!"),
+        assertEquals(Arrays.asList("Continue onto 3-6",
+                        "At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
                 tmpList);
+        roundaboutGraph.inverse3to9();
     }
 
     /**
-     * case starting in Roundabout
+     * case with one edge being not an exit
      */
     @Test
-    public void testCalcInstructionsRoundaboutBegin()
+    public void testCalcInstructionsRoundabout2()
     {
-        RoundaboutGraph rg = new RoundaboutGraph(false);
-        rg.edge2change.setFlags(encoder.setAccess(rg.edge2change.getFlags(), false, false));        
-        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        roundaboutGraph.inverse3to6();
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto MainStreet",
@@ -332,12 +402,89 @@ public void testCalcInstructionsRoundaboutBegin()
                         "Finish!"),
                 tmpList);
         // Test Radian
-        double delta = rg.getAngle(1, 2, 5, 8);
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
         RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
         assertEquals(delta, instr.getRadian(), 0.01);
+        roundaboutGraph.inverse3to6();
+
     }
 
 
+    /**
+     * see https://github.com/graphhopper/graphhopper/issues/353
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutIssue353()
+    {
+        final Graph g = new GraphBuilder(carManager).create();
+        final NodeAccess na = g.getNodeAccess();
+
+
+        //
+        //          8
+        //           \
+        //            5
+        //           /  \
+        //  11- 1 - 2    4 - 7
+        //      |     \  /
+        //      10 -9 -3
+        //       \    |
+        //        --- 6
+
+        na.setNode(1, 52.514, 13.348);
+        na.setNode(2, 52.514, 13.349);
+        na.setNode(3, 52.5135,13.35);
+        na.setNode(4, 52.514, 13.351);
+        na.setNode(5, 52.5145,13.351);
+        na.setNode(6, 52.513, 13.35);
+        na.setNode(7, 52.514, 13.352);
+        na.setNode(8, 52.515, 13.351);
+
+        // Sidelane
+        na.setNode(9, 52.5135, 13.349);
+        na.setNode(10, 52.5135, 13.348);
+        na.setNode(11, 52.514, 13.347);
+
+
+        EdgeIteratorState tmpEdge;
+        tmpEdge = g.edge(2, 1, 5, false).setName("MainStreet");
+        tmpEdge = g.edge(1, 11, 5, false).setName("MainStreet");
+
+
+         // roundabout
+        tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(9, 10, 2, false).setName("9-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(6, 10, 2, false).setName("6-10");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(10, 1, 2, false).setName("10-1");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), encoder.K_ROUNDABOUT, true));
+
+        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+
+
+        
+        
+        Path p = new Dijkstra(g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(6, 11);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet",
+                                    "Finish!"),
+                tmpList);
+    }
+
     /**
      * clockwise roundabout
      */
@@ -345,10 +492,9 @@ public void testCalcInstructionsRoundaboutBegin()
     public void testCalcInstructionsRoundaboutClockwise()
     {
 
-        RoundaboutGraph rg = new RoundaboutGraph(true);
-        System.out.println(rg.clockwise);
-
-        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        roundaboutGraph.setRoundabout(true);
+        Path p = new Dijkstra(roundaboutGraph.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED)
+                .calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList( "Continue onto MainStreet",
@@ -356,7 +502,7 @@ public void testCalcInstructionsRoundaboutClockwise()
                         "Finish!"),
                 tmpList);
         // Test Radian
-        double delta = rg.getAngle(1, 2, 5, 8);
+        double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
         RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
         assertEquals(delta, instr.getRadian(), 0.01);
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index c21dfd8bdf..239692901b 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -141,6 +141,12 @@ public void testHandleWayTags()
         way.setTag("tracktype", "grade2");
         wayType = getWayTypeFromFlags(way);
         assertEquals("get off the bike, unpaved", wayType);
+
+        way.clearTags();
+        way.setTag("junction", "roundabout");
+        way.setTag("highway", "tertiary");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
     @Test
@@ -199,7 +205,7 @@ public void testOneway()
         assertTrue(encoder.isBackward(flags));
         way.clearTags();
     }
-
+    
     @Test
     public void testHandleWayTagsInfluencedByRelation()
     {
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 37bf0c3b38..f39640cb08 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -255,4 +255,13 @@ public void testBarrierAccess()
         // barrier!
         assertTrue(footEncoder.handleNodeTags(node) > 0);
     }
+
+    @Test
+    public void handleWayTagsRoundabout() {
+        OSMWay way = new OSMWay(1);
+        way.setTag("junction", "roundabout");
+        way.setTag("highway", "tertiary");
+        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+    }
 }
