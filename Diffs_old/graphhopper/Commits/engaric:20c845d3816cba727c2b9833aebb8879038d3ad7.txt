diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 43e06b83a1..1b1e5c650e 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -115,7 +115,6 @@
 	private double defaultWeightLimit = Double.MAX_VALUE;
 	private boolean simplifyResponse = true;
 	private TraversalMode traversalMode = TraversalMode.NODE_BASED;
-	private String defaultVehicleStr;
 	private RoutingAlgorithmFactory algoFactory;
 	// for index
 	private LocationIndex locationIndex;
@@ -1056,7 +1055,7 @@ public GHResponse route(GHRequest request) {
 			sw = new StopWatch().start();
 			Path path = algo.calcPath(fromQResult.getClosestNode(),
 					toQResult.getClosestNode());
-			if (path.getMillis() < 0)
+			if (path.getTime() < 0)
 				throw new RuntimeException(
 						"Time was negative. Please report as bug and include:"
 								+ request);
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java
index ca64c8a220..4d1699f468 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java
@@ -216,7 +216,7 @@ protected void parseNetworkMember(String elementText) {
 
 	@Override
 	protected void addNode(String nodeId) {
-		String idStr = nodeId.substring(1);
+		String idStr = nodeId.substring(4);
 		if (0 == nodes.size()) {
 			nodes.add(idStr);
 		} else {
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
index 676b4938c3..f2cca8dfe2 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
@@ -20,9 +20,9 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
     {
         long wayType = edge.getFlags();
         wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        
-        if((wayType & bitMask) == bitMask)
+        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
             return Double.POSITIVE_INFINITY;
+        }
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
index b5b796683f..b621e7474b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
@@ -20,8 +20,9 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
     {
         long wayType = edge.getFlags();
         wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        if(bitMask!=0 && ((wayType & bitMask) == bitMask))
+        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
             return Double.POSITIVE_INFINITY;
+        }
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
index 897d0b4348..74bfed8399 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
@@ -22,9 +22,9 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
     {
         long wayType = edge.getFlags();
         wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        
-        if((wayType & bitMask) == bitMask)
+        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
             return Double.POSITIVE_INFINITY;
+        }
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java
new file mode 100644
index 0000000000..81b5e30c5a
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java
@@ -0,0 +1,94 @@
+package com.graphhopper.routing.util;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class FastestWithAvoidancesWeightingTest {
+	@Mock
+	FlagEncoder encoder;
+	
+	@Mock
+	EdgeIteratorState edge;
+	
+	@Before
+	public void configureMocks() {
+		MockitoAnnotations.initMocks(this);
+		configureSpeeds();
+	}
+
+	@Test
+	public void testSingleAvoidWhenMatches() {
+		String[] avoidances = {"cliff"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testSingleAvoidWhenNoMatch() {
+		String[] avoidances = {"cliff"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenRouteIsExactMatch() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenNoMatch() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+
+	/**
+	 * Sets up :-
+	 *  max speed = 100
+	 *  edge speed = 50
+	 */
+	private void configureSpeeds() {
+		when(encoder.getMaxSpeed()).thenReturn(100D);
+		when(encoder.getSpeed(anyLong())).thenReturn(50D);
+	}
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
new file mode 100644
index 0000000000..c6e303c645
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
@@ -0,0 +1,96 @@
+package com.graphhopper.routing.util;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class PriorityWithAvoidancesWeightingTest {
+	@Mock
+	FlagEncoder encoder;
+	
+	@Mock
+	EdgeIteratorState edge;
+	
+	@Before
+	public void configureMocks() {
+		MockitoAnnotations.initMocks(this);
+		configureSpeedsAndPriority();
+	}
+
+	@Test
+	public void testSingleAvoidWhenMatches() {
+		String[] avoidances = {"cliff"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testSingleAvoidWhenNoMatch() {
+		String[] avoidances = {"cliff"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenRouteIsExactMatch() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenNoMatch() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+
+	/**
+	 * Sets up :-
+	 *  max speed = 100
+	 *  edge speed = 50
+	 *  edge priority = 10
+	 */
+	private void configureSpeedsAndPriority() {
+		when(encoder.getMaxSpeed()).thenReturn(100D);
+		when(encoder.getSpeed(anyLong())).thenReturn(50D);
+		when(encoder.getDouble(anyLong(), eq(101))).thenReturn(10D);
+	}
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java
new file mode 100644
index 0000000000..6cd618de38
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java
@@ -0,0 +1,95 @@
+package com.graphhopper.routing.util;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class ShortestWithAvoidancesWeightingTest {
+	@Mock
+	FlagEncoder encoder;
+	
+	@Mock
+	EdgeIteratorState edge;
+	
+	@Before
+	public void configureMocks() {
+		MockitoAnnotations.initMocks(this);
+		configureSpeeds();
+	}
+
+	@Test
+	public void testSingleAvoidWhenMatches() {
+		String[] avoidances = {"cliff"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testSingleAvoidWhenNoMatch() {
+		String[] avoidances = {"cliff"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenRouteIsExactMatch() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+	
+	@Test
+	public void testMultiAvoidWhenNoMatch() {
+		String[] avoidances = {"cliff","aroad"};
+		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
+		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		int prevOrNextEdgeId=1;
+		boolean reverse = false;
+		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
+	}
+
+	/**
+	 * Sets up :-
+	 *  max speed = 100
+	 *  edge speed = 50
+	 *  edge priority = 10
+	 */
+	private void configureSpeeds() {
+		when(encoder.getMaxSpeed()).thenReturn(100D);
+		when(encoder.getSpeed(anyLong())).thenReturn(50D);
+	}
+
+}
diff --git a/core/src/test/resources/com/graphhopper/reader/osgb/dpn/directory_ingestion/os-dpn-sample1.xml b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/directory_ingestion/os-dpn-sample1.xml
index b351349448..47be26276e 100644
--- a/core/src/test/resources/com/graphhopper/reader/osgb/dpn/directory_ingestion/os-dpn-sample1.xml
+++ b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/directory_ingestion/os-dpn-sample1.xml
@@ -46,8 +46,8 @@
       <dpn:featureID>016c1a07-6bfa-4e52-91f2-d894a6873313</dpn:featureID>
       <dpn:versionID>1</dpn:versionID>
       <dpn:versionDate>2014-12-12</dpn:versionDate>
-      <dpn:startNode xlink:href="#a1d8f9ca-33f8-4875-bd61-fa9097c44e4c"/>
-      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:startNode xlink:href="#ID_a1d8f9ca-33f8-4875-bd61-fa9097c44e4c"/>
+      <dpn:endNode xlink:href="#ID_56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
       <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
       <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
       <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#Unmade">Unmade</dpn:surfaceType>
@@ -78,8 +78,8 @@
       <dpn:featureID>cc33c9f4-ff8e-41fb-86b3-3fd9daa8a6e0</dpn:featureID>
       <dpn:versionID>1</dpn:versionID>
       <dpn:versionDate>2014-12-12</dpn:versionDate>
-      <dpn:startNode xlink:href="#39e9eba8-4500-44cb-88c8-4f450bf7da14"/>
-      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:startNode xlink:href="#ID_39e9eba8-4500-44cb-88c8-4f450bf7da14"/>
+      <dpn:endNode xlink:href="#ID_56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
       <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
       <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#Alley">Alley</dpn:descriptiveTerm>
       <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#Unmade">Unmade</dpn:surfaceType>
diff --git a/core/src/test/resources/com/graphhopper/reader/osgb/dpn/directory_ingestion/os-dpn-sample2.xml b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/directory_ingestion/os-dpn-sample2.xml
index ed54adfcde..62b88132a5 100644
--- a/core/src/test/resources/com/graphhopper/reader/osgb/dpn/directory_ingestion/os-dpn-sample2.xml
+++ b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/directory_ingestion/os-dpn-sample2.xml
@@ -32,8 +32,8 @@
       <dpn:featureID>35cff694-c2a8-461e-9540-730e3ae11a7a</dpn:featureID>
       <dpn:versionID>1</dpn:versionID>
       <dpn:versionDate>2014-12-12</dpn:versionDate>
-      <dpn:startNode xlink:href="#df162dd8-c284-469b-81d6-d63105a39c7f"/>
-      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:startNode xlink:href="#ID_df162dd8-c284-469b-81d6-d63105a39c7f"/>
+      <dpn:endNode xlink:href="#ID_56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
       <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
       <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
       <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#Unmade">Unmade</dpn:surfaceType>
@@ -65,8 +65,8 @@
       <dpn:featureID>34dd4b18-ade0-48ea-9a34-e567107bd061</dpn:featureID>
       <dpn:versionID>1</dpn:versionID>
       <dpn:versionDate>2014-12-12</dpn:versionDate>
-      <dpn:startNode xlink:href="#2357d994-6688-44b1-8769-6466ffdd69dd"/>
-      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:startNode xlink:href="#ID_2357d994-6688-44b1-8769-6466ffdd69dd"/>
+      <dpn:endNode xlink:href="#ID_56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
       <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
       <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#Cableway">Cableway</dpn:descriptiveTerm>
       <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#"/>
diff --git a/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-avoid.xml b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-avoid.xml
index 8920ec0481..05aa08341e 100644
--- a/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-avoid.xml
+++ b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-avoid.xml
@@ -85,8 +85,8 @@
 		<dpn:RouteLink gml:id="ID_4000000025288016">
 			<dpn:versionID>4</dpn:versionID>
 			<dpn:versionDate>2006-02-03</dpn:versionDate>
-			<dpn:startNode xlink:href="#4000000025277879" />
-			<dpn:endNode xlink:href="#4000000025277880" />
+			<dpn:startNode xlink:href="#ID_4000000025277879" />
+			<dpn:endNode xlink:href="#ID_4000000025277880" />
 			<dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
 			 <dpn:name>Link 16</dpn:name>
 			<dpn:rightOfUse codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RightOfWayValue#Footpath">Footpath</dpn:rightOfUse>
@@ -101,8 +101,8 @@
 		<dpn:RouteLink gml:id="ID_4000000025288017">
 			<dpn:versionID>4</dpn:versionID>
 			<dpn:versionDate>2006-02-03</dpn:versionDate>
-			<dpn:startNode xlink:href="#4000000025277880" />
-			<dpn:endNode xlink:href="#4000000025277884" />
+			<dpn:startNode xlink:href="#ID_4000000025277880" />
+			<dpn:endNode xlink:href="#ID_4000000025277884" />
 			<dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
 			<dpn:name>Link 17</dpn:name>
 			<dpn:rightOfUse codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RightOfWayValue#Footpath">Footpath</dpn:rightOfUse>
@@ -117,8 +117,8 @@
 		<dpn:RouteLink gml:id="ID_4000000025288018">
 			<dpn:versionID>4</dpn:versionID>
 			<dpn:versionDate>2006-02-03</dpn:versionDate>
-			<dpn:startNode xlink:href="#4000000025277884" />
-			<dpn:endNode xlink:href="#4000000025277882" />
+			<dpn:startNode xlink:href="#ID_4000000025277884" />
+			<dpn:endNode xlink:href="#ID_4000000025277882" />
 			<dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
 			<dpn:name>Link 18</dpn:name>
 			<dpn:potentialHazardCrossed>Boulders</dpn:potentialHazardCrossed>
@@ -134,8 +134,8 @@
 		<dpn:RouteLink gml:id="ID_4000000025288019">
 			<dpn:versionID>4</dpn:versionID>
 			<dpn:versionDate>2006-02-03</dpn:versionDate>
-			<dpn:startNode xlink:href="#4000000025277880" />
-			<dpn:endNode xlink:href="#4000000025277883" />
+			<dpn:startNode xlink:href="#ID_4000000025277880" />
+			<dpn:endNode xlink:href="#ID_4000000025277883" />
 			<dpn:descriptiveTerm	codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
 			<dpn:name>Link 19</dpn:name>
 			<dpn:rightOfUse codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RightOfWayValue#Footpath">Footpath</dpn:rightOfUse>
@@ -150,8 +150,8 @@
 		<dpn:RouteLink gml:id="ID_4000000025288020">
 			<dpn:versionID>4</dpn:versionID>
 			<dpn:versionDate>2006-02-03</dpn:versionDate>
-			<dpn:startNode xlink:href="#4000000025277883" />
-			<dpn:endNode xlink:href="#4000000025277882" />
+			<dpn:startNode xlink:href="#ID_4000000025277883" />
+			<dpn:endNode xlink:href="#ID_4000000025277882" />
 			<dpn:descriptiveTerm	codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
 			<dpn:name>Link 20</dpn:name>
 			<dpn:rightOfUse codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RightOfWayValue#Footpath">Footpath</dpn:rightOfUse>
@@ -166,8 +166,8 @@
 		<dpn:RouteLink gml:id="ID_4000000025288021">
 			<dpn:versionID>4</dpn:versionID>
 			<dpn:versionDate>2006-02-03</dpn:versionDate>
-			<dpn:startNode xlink:href="#4000000025277882" />
-			<dpn:endNode xlink:href="#4000000025277885" />
+			<dpn:startNode xlink:href="#ID_4000000025277882" />
+			<dpn:endNode xlink:href="#ID_4000000025277885" />
 			<dpn:descriptiveTerm	codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
 			<dpn:name>Link 21</dpn:name>
 			<dpn:rightOfUse codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RightOfWayValue#Footpath">Footpath</dpn:rightOfUse>
diff --git a/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml
index 55b35b5dd7..1de2456c56 100644
--- a/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml
+++ b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml
@@ -74,8 +74,8 @@
       <dpn:featureID>35cff694-c2a8-461e-9540-730e3ae11a7a</dpn:featureID>
       <dpn:versionID>1</dpn:versionID>
       <dpn:versionDate>2014-12-12</dpn:versionDate>
-      <dpn:startNode xlink:href="#df162dd8-c284-469b-81d6-d63105a39c7f"/>
-      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:startNode xlink:href="#ID_df162dd8-c284-469b-81d6-d63105a39c7f"/>
+      <dpn:endNode xlink:href="#ID_56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
       <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
       <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
       <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#Unmade">Unmade</dpn:surfaceType>
@@ -107,8 +107,8 @@
       <dpn:featureID>34dd4b18-ade0-48ea-9a34-e567107bd061</dpn:featureID>
       <dpn:versionID>1</dpn:versionID>
       <dpn:versionDate>2014-12-12</dpn:versionDate>
-      <dpn:startNode xlink:href="#2357d994-6688-44b1-8769-6466ffdd69dd"/>
-      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:startNode xlink:href="#ID_2357d994-6688-44b1-8769-6466ffdd69dd"/>
+      <dpn:endNode xlink:href="#ID_56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
       <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
       <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#Cableway">Cableway</dpn:descriptiveTerm>
       <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#"/>
@@ -141,8 +141,8 @@
       <dpn:featureID>016c1a07-6bfa-4e52-91f2-d894a6873313</dpn:featureID>
       <dpn:versionID>1</dpn:versionID>
       <dpn:versionDate>2014-12-12</dpn:versionDate>
-      <dpn:startNode xlink:href="#a1d8f9ca-33f8-4875-bd61-fa9097c44e4c"/>
-      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:startNode xlink:href="#ID_a1d8f9ca-33f8-4875-bd61-fa9097c44e4c"/>
+      <dpn:endNode xlink:href="#ID_56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
       <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
       <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
       <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#Unmade">Unmade</dpn:surfaceType>
@@ -173,8 +173,8 @@
       <dpn:featureID>cc33c9f4-ff8e-41fb-86b3-3fd9daa8a6e0</dpn:featureID>
       <dpn:versionID>1</dpn:versionID>
       <dpn:versionDate>2014-12-12</dpn:versionDate>
-      <dpn:startNode xlink:href="#39e9eba8-4500-44cb-88c8-4f450bf7da14"/>
-      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:startNode xlink:href="#ID_39e9eba8-4500-44cb-88c8-4f450bf7da14"/>
+      <dpn:endNode xlink:href="#ID_56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
       <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
       <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#Alley">Alley</dpn:descriptiveTerm>
       <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#Unmade">Unmade</dpn:surfaceType>
