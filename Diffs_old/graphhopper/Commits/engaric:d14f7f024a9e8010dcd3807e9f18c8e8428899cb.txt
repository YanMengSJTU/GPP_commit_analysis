diff --git a/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java b/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java
index 104d08b18d..99932e4d4e 100755
--- a/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java
@@ -147,8 +147,8 @@
 	public class ProcessVisitor
 	{
 		public void process( ProcessData processData, OsItnInputFile in )
-		        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-		        TransformException
+				throws XMLStreamException, MismatchedDimensionException, FactoryException,
+				TransformException
 		{
 		}
 	}
@@ -246,7 +246,7 @@ public OsItnReader( GraphStorage storage, CmdArgs commandLineArguments )
 		super(storage);
 		this.commandLineArguments = commandLineArguments;
 		String addAdditionalTowerNodesString = graphStorage.getProperties().get(
-		        "add.additional.tower.nodes");
+				"add.additional.tower.nodes");
 		if (addAdditionalTowerNodesString != null && addAdditionalTowerNodesString.length() > 0)
 		{
 			// Only parse this if it has been explicitly set otherwise set to
@@ -267,7 +267,7 @@ public OsItnReader( GraphStorage storage, CmdArgs commandLineArguments )
 
 	@Override
 	protected void preProcessSingleFile( File itnFile ) throws XMLStreamException, IOException,
-	        MismatchedDimensionException, FactoryException, TransformException
+	MismatchedDimensionException, FactoryException, TransformException
 	{
 		OsItnInputFile in = null;
 		try
@@ -283,7 +283,7 @@ protected void preProcessSingleFile( File itnFile ) throws XMLStreamException, I
 	}
 
 	private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException,
-	        MismatchedDimensionException, FactoryException, TransformException
+	MismatchedDimensionException, FactoryException, TransformException
 	{
 		logger.error("==== preProcessSingleFile");
 		long tmpWayCounter = 1;
@@ -310,8 +310,8 @@ private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException
 					if (++tmpWayCounter % 500000 == 0)
 					{
 						logger.info(PREPROCESS_OSM_ID_MAP_MB_FORMAT, nf(tmpWayCounter),
-						        nf(getNodeMap().getSize()), getNodeMap().getMemoryUsage(),
-						        Helper.getMemInfo());
+								nf(getNodeMap().getSize()), getNodeMap().getMemoryUsage(),
+								Helper.getMemInfo());
 					}
 				}
 			}
@@ -322,11 +322,11 @@ private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException
 				// item.getTag(OSITNElement.TAG_KEY_TYPE) + " meta?" +
 				// relation.isMetaRelation());
 				if (!relation.isMetaRelation()
-				        && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
+						&& relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
 					prepareWaysWithRelationInfo(relation);
 
 				if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
-				        OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
+						OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
 					prepareRestrictionRelation(relation);
 
 				if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_NOENTRY))
@@ -337,9 +337,9 @@ private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException
 				// If this way is prohibited then we want to make a note of it
 				// so we don't include it in later route generation
 				if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
-				        OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED)
-				        || relation.hasTag(OSITNElement.TAG_KEY_TYPE,
-				                OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED))
+						OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED)
+						|| relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+								OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED))
 				{
 					prepareAccessProhibitedRelation(relation);
 				}
@@ -363,7 +363,7 @@ private void preProcessSingleFile( OsItnInputFile in ) throws XMLStreamException
 				if (++tmpRelationCounter % 50000 == 0)
 				{
 					logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:"
-					        + nf(getOsmWayIdToRouteWeightMap().size()) + " " + Helper.getMemInfo());
+							+ nf(getOsmWayIdToRouteWeightMap().size()) + " " + Helper.getMemInfo());
 				}
 
 			}
@@ -388,7 +388,7 @@ private void prepareRestrictionRelation( Relation relation )
 	private void prepareAccessProhibitedRelation( Relation relation )
 	{
 		if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
-		        && !encodingManager.isVehicleQualifierTypeIncluded(relation))
+				&& !encodingManager.isVehicleQualifierTypeIncluded(relation))
 		{
 			ArrayList<? extends RelationMember> members = relation.getMembers();
 			// There will be only one
@@ -437,7 +437,7 @@ private void prepareRoadDirectionRelation( Relation relation )
 		// Check if this vehicle has an exception meaning we shouldn't handle
 		// one way
 		if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
-		        && !encodingManager.isVehicleQualifierTypeIncluded(relation))
+				&& !encodingManager.isVehicleQualifierTypeIncluded(relation))
 		{
 			// This will be "-1" the first time this is called
 			String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION);
@@ -488,7 +488,7 @@ private void prepareNoEntryRelation( Relation relation )
 		// Check if this vehicle has an exception meaning we shouldn't handle no
 		// entry
 		if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
-		        && !encodingManager.isVehicleQualifierTypeIncluded(relation))
+				&& !encodingManager.isVehicleQualifierTypeIncluded(relation))
 		{
 			long flags = 1l; // (+) orientation
 			String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_NOENTRY_ORIENTATION);
@@ -522,7 +522,7 @@ private void prepareNoEntryRelation( Relation relation )
 				}
 				// now put the flag in there
 				logger.info(EDGE_ID_COORDS_TO_NODE_FLAGS_MAP_PUT_FORMAT, wayId, xCoord, yCoord,
-				        flags);
+						flags);
 
 				yCoordMap.put(yCoord, flags);
 			}
@@ -637,7 +637,7 @@ protected void writeOsm2Graph( File osmFile )
 	{
 		int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
 		logger.error(CREATING_GRAPH_FOUND_NODES_PILLAR_TOWER_FORMAT, nf(getNodeMap().getSize()),
-		        Helper.getMemInfo());
+				Helper.getMemInfo());
 		graphStorage.create(tmp);
 
 		ProcessData processData = new ProcessData();
@@ -647,8 +647,8 @@ protected void writeOsm2Graph( File osmFile )
 			{
 				@Override
 				public void process( ProcessData processData, OsItnInputFile in )
-				        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-				        TransformException
+						throws XMLStreamException, MismatchedDimensionException, FactoryException,
+						TransformException
 				{
 					logger.error("PROCESS STAGE 1");
 					processStageOne(processData, in);
@@ -662,8 +662,8 @@ public void process( ProcessData processData, OsItnInputFile in )
 			{
 				@Override
 				public void process( ProcessData processData, OsItnInputFile in )
-				        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-				        TransformException
+						throws XMLStreamException, MismatchedDimensionException, FactoryException,
+						TransformException
 				{
 					logger.error("PROCESS STAGE 2");
 					processStageTwo(processData, in);
@@ -675,8 +675,8 @@ public void process( ProcessData processData, OsItnInputFile in )
 			{
 				@Override
 				public void process( ProcessData processData, OsItnInputFile in )
-				        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-				        TransformException
+						throws XMLStreamException, MismatchedDimensionException, FactoryException,
+						TransformException
 				{
 					logger.error("PROCESS STAGE 3");
 					processStageThree(processData, in);
@@ -693,12 +693,12 @@ public void process( ProcessData processData, OsItnInputFile in )
 		finishedReading();
 		if (graphStorage.getNodes() == 0)
 			throw new IllegalStateException("osm must not be empty. read " + processData.counter
-			        + " lines and " + locations + " locations");
+					+ " lines and " + locations + " locations");
 	}
 
 	private void writeOsm2GraphFromDirOrFile( File osmFile, ProcessData processData,
-	        ProcessVisitor processVisitor ) throws XMLStreamException, IOException,
-	        MismatchedDimensionException, FactoryException, TransformException
+			ProcessVisitor processVisitor ) throws XMLStreamException, IOException,
+			MismatchedDimensionException, FactoryException, TransformException
 	{
 		if (osmFile.isDirectory())
 		{
@@ -716,8 +716,8 @@ private void writeOsm2GraphFromDirOrFile( File osmFile, ProcessData processData,
 	}
 
 	private void writeOsm2GraphFromSingleFile( File osmFile, ProcessData processData,
-	        ProcessVisitor processVisitor ) throws XMLStreamException, IOException,
-	        MismatchedDimensionException, FactoryException, TransformException
+			ProcessVisitor processVisitor ) throws XMLStreamException, IOException,
+			MismatchedDimensionException, FactoryException, TransformException
 	{
 		OsItnInputFile in = null;
 		try
@@ -735,8 +735,8 @@ private void writeOsm2GraphFromSingleFile( File osmFile, ProcessData processData
 	}
 
 	private void processStageOne( ProcessData processData, OsItnInputFile in )
-	        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-	        TransformException
+			throws XMLStreamException, MismatchedDimensionException, FactoryException,
+			TransformException
 	{
 		logger.error("==== processStageOne");
 		RoutingElement item;
@@ -777,7 +777,7 @@ private void processStageOne( ProcessData processData, OsItnInputFile in )
 			if (++processData.counter % 5000000 == 0)
 			{
 				logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations),
-				        skippedLocations, Helper.getMemInfo());
+						skippedLocations, Helper.getMemInfo());
 			}
 		}
 	}
@@ -816,7 +816,7 @@ protected DataReader createReader( GraphStorage tmpGraph )
 					}
 
 				}.setOSMFile(hnPath).setGraphHopperLocation(hnGraphLocation)
-				        .setEncodingManager(encodingManager).setCHEnable(false).setAsHnReader();
+				.setEncodingManager(encodingManager).setCHEnable(false).setAsHnReader();
 				hnGraphHopper.importOrLoad();
 				// OsHnReader hnReader = new OsHnReader(hnGraphHopper.getGraph());
 				logger.error("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<=================================================");
@@ -826,8 +826,8 @@ protected DataReader createReader( GraphStorage tmpGraph )
 	}
 
 	private void processStageTwo( ProcessData processData, OsItnInputFile in )
-	        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-	        TransformException
+			throws XMLStreamException, MismatchedDimensionException, FactoryException,
+			TransformException
 	{
 		logger.error("==== processStageTwo");
 		RoutingElement item;
@@ -856,16 +856,16 @@ private void processStageTwo( ProcessData processData, OsItnInputFile in )
 			if (++processData.counter % 5000000 == 0)
 			{
 				logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations),
-				        skippedLocations, Helper.getMemInfo());
+						skippedLocations, Helper.getMemInfo());
 			}
 		}
 	}
 
 	private List<OSITNNode> prepareWaysNodes( RoutingElement item, LongIntMap nodeFilter )
-	        throws MismatchedDimensionException, FactoryException, TransformException
-	{
+			throws MismatchedDimensionException, FactoryException, TransformException
+			{
 		List<OSITNNode> evaluateWayNodes = ((OSITNWay) item)
-		        .evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
+				.evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
 		for (OSITNNode ositnNode : evaluateWayNodes)
 		{
 			nodeFilter.put(ositnNode.getId(), PILLAR_NODE);
@@ -873,11 +873,11 @@ private void processStageTwo( ProcessData processData, OsItnInputFile in )
 		}
 		logger.info(WE_HAVE_EVALUATED_WAY_NODES_FORMAT, evaluateWayNodes.size());
 		return evaluateWayNodes;
-	}
+			}
 
 	private void processStageThree( ProcessData processData, OsItnInputFile in )
-	        throws XMLStreamException, MismatchedDimensionException, FactoryException,
-	        TransformException
+			throws XMLStreamException, MismatchedDimensionException, FactoryException,
+			TransformException
 	{
 		logger.error("==== processStageThree");
 		RoutingElement item;
@@ -899,7 +899,7 @@ private void processStageThree( ProcessData processData, OsItnInputFile in )
 			if (++processData.counter % 5000000 == 0)
 			{
 				logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations),
-				        skippedLocations, Helper.getMemInfo());
+						skippedLocations, Helper.getMemInfo());
 			}
 		}
 	}
@@ -946,18 +946,18 @@ private void processWay( OSITNWay way, List<OSITNNode> wayNodes )
 			// attributes
 			if ((attributeBits & ATTRIBUTE_BIT_FORD) != 0)
 			{
-				System.err.println("FORD_NBIT");
+				// System.err.println("FORD_NBIT");
 				way.setTag(OSITNElement.TAG_VALUE_CLASSIFICATION_FORD, "yes");
 			}
 			if ((attributeBits & ATTRIBUTE_BIT_GATE) != 0)
 			{
-				System.err.println("GATE_NBIT");
+				// System.err.println("GATE_NBIT");
 				way.setTag("barrier", OSITNElement.TAG_VALUE_CLASSIFICATION_GATE);
 			}
 			if ((attributeBits & ATTRIBUTE_BIT_LEVEL_CROSSING) != 0)
 			{
 				way.setTag(OSITNElement.TAG_KEY_CLASSIFICATION,
-				        OSITNElement.TAG_VALUE_CLASSIFICATION_LEVEL_CROSSING);
+						OSITNElement.TAG_VALUE_CLASSIFICATION_LEVEL_CROSSING);
 			}
 		}
 
@@ -1011,12 +1011,12 @@ private void processWay( OSITNWay way, List<OSITNNode> wayNodes )
 			double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
 			double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
 			if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat)
-			        && !Double.isNaN(lastLon))
+					&& !Double.isNaN(lastLon))
 			{
 				double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
 				way.setTag("estimated_distance", estimatedDist);
 				way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2,
-				        (firstLon + lastLon) / 2));
+						(firstLon + lastLon) / 2));
 			}
 		}
 
@@ -1042,7 +1042,7 @@ private void processWay( OSITNWay way, List<OSITNNode> wayNodes )
 	}
 
 	private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay way,
-	        List<OSITNNode> wayNodes, long wayFlags, long wayOsmId )
+			List<OSITNNode> wayNodes, long wayFlags, long wayOsmId )
 	{
 		// if (osmNodeIds.size()>2) {
 		List<EdgeIteratorState> startCreatedEdges = new ArrayList<EdgeIteratorState>();
@@ -1097,8 +1097,8 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 	 * @return
 	 */
 	private List<EdgeIteratorState> processNoEntry( OSITNWay way, List<OSITNNode> wayNodes,
-	        TLongList osmNodeIds, long wayFlags, long wayOsmId )
-	{
+			TLongList osmNodeIds, long wayFlags, long wayOsmId )
+			{
 		List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
 		int lastNoEntry = -1;
 		List<EdgeIteratorState> noEntryCreatedEdges = new ArrayList<EdgeIteratorState>();
@@ -1130,7 +1130,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 
 				// create zero length edge for barrier to the next node
 				Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId,
-				        wayFlags, nodeFlags, wayOsmId);
+						wayFlags, nodeFlags, wayOsmId);
 				// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 				// newBarriers.size());
 				noEntryCreatedEdges.addAll(newBarriers);
@@ -1148,10 +1148,10 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 			{
 				failedStartNoEntries++;
 				errors_logger
-				        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
-				                + nodeId + " on way " + way.getId() + " for START Node "
-				                + osmNodeIds.toString() + " (" + successfulStartNoEntries
-				                + " succeeded, " + failedStartNoEntries + " failed)");
+				.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+						+ nodeId + " on way " + way.getId() + " for START Node "
+						+ osmNodeIds.toString() + " (" + successfulStartNoEntries
+						+ " succeeded, " + failedStartNoEntries + " failed)");
 			}
 		}
 		// Process Way Nodes
@@ -1190,7 +1190,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 
 					// create zero length edge for barrier to the next node
 					Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId,
-					        wayFlags, nodeFlags, wayOsmId);
+							wayFlags, nodeFlags, wayOsmId);
 					// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 					// newBarriers.size());
 					noEntryCreatedEdges.addAll(newBarriers);
@@ -1210,7 +1210,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 					// TODO end of way we will have issues
 					// run edge from real first node to shadow node
 					Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId, newNodeId,
-					        wayFlags, nodeFlags, wayOsmId);
+							wayFlags, nodeFlags, wayOsmId);
 					// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 					// newBarriers.size());
 					noEntryCreatedEdges.addAll(newBarriers);
@@ -1242,7 +1242,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 					long transfer[] = osmNodeIds.toArray(lastNoEntry, size - lastNoEntry - 1);
 					nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
 					Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor,
-					        wayFlags, wayOsmId);
+							wayFlags, wayOsmId);
 					// logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
 					// newEdges.size());
 					createdEdges.addAll(newEdges);
@@ -1275,7 +1275,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 
 				// create zero length edge for barrier to the next node
 				Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId,
-				        wayFlags, nodeFlags, wayOsmId);
+						wayFlags, nodeFlags, wayOsmId);
 				// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 				// newBarriers.size());
 				noEntryCreatedEdges.addAll(newBarriers);
@@ -1294,10 +1294,10 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 				// TODO Figure out why there are some end nodes that don't have
 				// internal node ids
 				errors_logger
-				        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
-				                + nodeId + " on way " + way.getId() + " for END Node "
-				                + osmNodeIds.toString() + " (" + successfulEndNoEntries
-				                + " succeeded, " + failedEndNoEntries + " failed)");
+				.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+						+ nodeId + " on way " + way.getId() + " for END Node "
+						+ osmNodeIds.toString() + " (" + successfulEndNoEntries
+						+ " succeeded, " + failedEndNoEntries + " failed)");
 			}
 		}
 
@@ -1336,7 +1336,7 @@ private TLongList createStartTowerNodeAndEdge( TLongList osmNodeIds, OSITNWay wa
 			}
 		}
 		return createdEdges;
-	}
+			}
 
 	/**
 	 *
@@ -1350,7 +1350,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 		// x, y combination
 		long key = wayId;
 		TDoubleObjectMap<TDoubleLongMap> xToYToNodeFlagsMap = getEdgeIdToXToYToNodeFlagsMap().get(
-		        key);
+				key);
 		if (xToYToNodeFlagsMap != null)
 		{
 			String[] coordParts = wayCoord.split(",");
@@ -1404,8 +1404,8 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 	 * @return
 	 */
 	private List<EdgeIteratorState> processBarriers( Way way, TLongList osmNodeIds, long wayFlags,
-	        long wayOsmId )
-	{
+			long wayOsmId )
+			{
 		List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
 		// look for barriers along the way
 		final int size = osmNodeIds.size();
@@ -1443,14 +1443,14 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 						transfer[transfer.length - 1] = newNodeId;
 						TLongList partIds = new TLongArrayList(transfer);
 						Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags,
-						        wayOsmId);
+								wayOsmId);
 						// logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
 						// newWays.size());
 						createdEdges.addAll(newWays);
 
 						// create zero length edge for barrier
 						Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId,
-						        nodeId, wayFlags, nodeFlags, wayOsmId);
+								nodeId, wayFlags, nodeFlags, wayOsmId);
 						// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 						// newBarriers.size());
 						createdEdges.addAll(newBarriers);
@@ -1458,7 +1458,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 					{
 						// run edge from real first node to shadow node
 						Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId,
-						        newNodeId, wayFlags, nodeFlags, wayOsmId);
+								newNodeId, wayFlags, nodeFlags, wayOsmId);
 						// logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
 						// newBarriers.size());
 						createdEdges.addAll(newBarriers);
@@ -1500,7 +1500,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 
 			// An index < TOWER_NODE means it is a tower node.
 			boolean doInsertAdditionalTowerNodes = addAdditionalTowerNodes
-			        && (graphIndex < TOWER_NODE);
+					&& (graphIndex < TOWER_NODE);
 
 			// logger.error("doInsertAdditionalTowerNodes is " +
 			// doInsertAdditionalTowerNodes + " for lastNodeId "+ lastNodeId );
@@ -1518,7 +1518,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 			}
 
 			Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor, wayFlags,
-			        wayOsmId);
+					wayOsmId);
 
 			createdEdges.addAll(newEdges);
 			if (doInsertAdditionalTowerNodes)
@@ -1535,7 +1535,7 @@ private String checkForNoEntryDirection( long wayId, String wayCoord )
 			encodingManager.applyWayTags(way, edge);
 		}
 		return createdEdges;
-	}
+			}
 
 	private String getWayName( long id )
 	{
@@ -1579,17 +1579,17 @@ public void processRelation( Relation relation ) throws XMLStreamException
 				getOsmIdStoreRequiredSet().add(toId);
 
 				logger.info(TURN_FROM_TO_VIA_FORMAT, turnRelation.getOsmIdFrom(),
-				        turnRelation.getOsmIdTo(), turnRelation.getVia());
+						turnRelation.getOsmIdTo(), turnRelation.getVia());
 				GraphExtension extendedStorage = graphStorage.getExtension();
 				if (extendedStorage instanceof TurnCostExtension)
 				{
 					TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
 					Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(
-					        turnRelation, this);
+							turnRelation, this);
 					for (ITurnCostTableEntry entry : entries)
 					{
 						tcs.addTurnInfo(entry.getEdgeFrom(), entry.getVia(), entry.getEdgeTo(),
-						        entry.getFlags());
+								entry.getFlags());
 					}
 				}
 			}
@@ -1830,7 +1830,7 @@ private int addTowerNode( long osmId, double lat, double lon, double ele )
 
 				if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
 					throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", "
-					        + osmId);
+							+ osmId);
 
 				if (tmpNode > -TOWER_NODE)
 				{
@@ -1868,15 +1868,15 @@ private int addTowerNode( long osmId, double lat, double lon, double ele )
 	}
 
 	EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags,
-	        long wayOsmId )
+			long wayOsmId )
 	{
 		// sanity checks
 		if (fromIndex < 0 || toIndex < 0)
 			throw new AssertionError("to or from index is invalid for this edge " + fromIndex
-			        + "->" + toIndex + ", points:" + pointList);
+					+ "->" + toIndex + ", points:" + pointList);
 		if (pointList.getDimension() != nodeAccess.getDimension())
 			throw new AssertionError("Dimension does not match for pointList vs. nodeAccess "
-			        + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
+					+ pointList.getDimension() + " <-> " + nodeAccess.getDimension());
 
 		double towerNodeDistance = 0;
 		double prevLat = pointList.getLatitude(0);
@@ -1918,7 +1918,7 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
 		}
 		logger.info("Add edge flags:" + flags);
 		EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
-		        .setDistance(towerNodeDistance).setFlags(flags);
+				.setDistance(towerNodeDistance).setFlags(flags);
 		if (nodes > 2)
 		{
 			if (doSimplify)
@@ -1949,7 +1949,7 @@ private void storeOSMWayID( int edgeId, long osmWayID )
 	 * @return converted tower node
 	 */
 	private int handlePillarNode( int tmpNode, long osmId, PointList pointList,
-	        boolean convertToTowerNode )
+			boolean convertToTowerNode )
 	{
 		logger.info(CONVERTING_PILLAR_TO_PILLAR_FORMAT, osmId, convertToTowerNode);
 		tmpNode = tmpNode - 3;
@@ -1958,7 +1958,7 @@ private int handlePillarNode( int tmpNode, long osmId, PointList pointList,
 		double ele = pillarInfo.getElevation(tmpNode);
 		if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
 			throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
-			        + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+					+ "osmId:" + osmId + " pillarIndex:" + tmpNode);
 
 		if (convertToTowerNode)
 		{
@@ -2042,8 +2042,8 @@ private long createNewNodeId()
 	 * Add a zero length edge with reduced routing options to the graph.
 	 */
 	private Collection<EdgeIteratorState> addBarrierEdge( long fromId, long toId, long flags,
-	        long nodeFlags, long wayOsmId )
-	{
+			long nodeFlags, long wayOsmId )
+			{
 		// clear barred directions from routing flags
 		flags &= ~nodeFlags;
 		// add edge
@@ -2051,7 +2051,7 @@ private long createNewNodeId()
 		barrierNodeIds.add(fromId);
 		barrierNodeIds.add(toId);
 		return addOSMWay(barrierNodeIds, flags, wayOsmId);
-	}
+			}
 
 	/**
 	 * Creates an OSM turn relation out of an unspecified OSM relation
@@ -2062,7 +2062,7 @@ private long createNewNodeId()
 	OSITNTurnRelation createTurnRelation( Relation relation )
 	{
 		OSMTurnRelation.Type type = OSITNTurnRelation.getRestrictionType(relation
-		        .getTag(OSITNElement.TAG_KEY_RESTRICTION));
+				.getTag(OSITNElement.TAG_KEY_RESTRICTION));
 
 		// Handle No Turn and Mandatory Turn Exceptions. This is done by
 		// selectively ignoring restrictions based on excluded/included vehicle
@@ -2078,7 +2078,7 @@ OSITNTurnRelation createTurnRelation( Relation relation )
 		{
 			// There is a no entry or mandatory turn
 			if (encodingManager.isVehicleQualifierTypeExcluded(relation)
-			        || encodingManager.isVehicleQualifierTypeIncluded(relation))
+					|| encodingManager.isVehicleQualifierTypeIncluded(relation))
 			{
 				// The current encoder vehicle is excluded from this restriction
 				// so remove it OR (except buses=false)
@@ -2120,7 +2120,7 @@ OSITNTurnRelation createTurnRelation( Relation relation )
 				if (-1 < foundViaNode)
 				{
 					OSITNTurnRelation osmTurnRelation = new OSITNTurnRelation(fromWayID,
-					        foundViaNode, toWayID, type);
+							foundViaNode, toWayID, type);
 					return osmTurnRelation;
 				}
 			}
@@ -2182,8 +2182,8 @@ private TLongLongHashMap getOsmWayIdToRouteWeightMap()
 	private void printInfo( String str )
 	{
 		logger.info(PRINT_INFO_FORMAT, str, graphStorage.getNodes(), getNodeMap().getSize(),
-		        getNodeMap().getMemoryUsage(), getNodeFlagsMap().size(),
-		        getOsmWayIdToRouteWeightMap().size(), Helper.getMemInfo());
+				getNodeMap().getMemoryUsage(), getNodeFlagsMap().size(),
+				getOsmWayIdToRouteWeightMap().size(), Helper.getMemInfo());
 	}
 
 	private long findViaNode( long fromOsm, long toOsm )
