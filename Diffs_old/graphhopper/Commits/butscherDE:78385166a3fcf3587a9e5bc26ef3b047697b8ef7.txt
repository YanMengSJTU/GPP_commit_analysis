diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index a474b04a64..ef44349c6c 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -83,6 +83,10 @@ public Path(Graph graph, Weighting weighting) {
      */
     Path(Path p) {
         this(p.graph, p.weighting);
+        buildThisPathFromAnotherPath(p);
+    }
+
+    private void buildThisPathFromAnotherPath(Path p) {
         weight = p.weight;
         edgeIds = new GHIntArrayList(p.edgeIds);
         sptEntry = p.sptEntry;
@@ -422,6 +426,14 @@ public String toDetailsString() {
     }
 
     public void addPath(final Path newPath) {
+        if (this.edgeIds.size() > 0) {
+            addIfThisPathIsntEmpty(newPath);
+        } else {
+            buildThisPathFromAnotherPath(newPath);
+        }
+    }
+
+    private void addIfThisPathIsntEmpty(Path newPath) {
         final EdgeIteratorState lastEdgeOfThisPath = this.getFinalEdge();
         final List<EdgeIteratorState> otherPathsEdges = newPath.calcEdges();
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index e24847435a..1b0a0b6068 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -103,7 +103,7 @@ private void pruneDominatedCandidateRoutes() {
 
     private boolean isThisCandidateDominatedByAny(int currentPruningCandidateIndex, RouteCandidate currentPruningCandidate) {
         boolean foundDominatingPath = false;
-        for (int i = currentPruningCandidateIndex - 1; i >= 0 && !foundDominatingPath; i++) {
+        for (int i = currentPruningCandidateIndex - 1; i >= 0 && !foundDominatingPath; i--) {
             // routeCandidates must be sorted by now. Therefore dominators can only bbe found on lower indices than the current pruning candidate.
             RouteCandidate possiblyBetterRouteCandidate = this.routeCandidates.candidates.get(i);
 
@@ -134,10 +134,9 @@ private boolean indexInCandidateBounds(int currentPruningCandidateIndex) {
 
     private void pruneLowerQuantileInROIcandidateRoutes() {
         // Assumes that routeCandidates was already sorted descending to roi distance after pruning dominated route candidates
-        final int routeCandidatesSize = this.routeCandidates.candidates.size();
-        int startIndex = (int) (routeCandidatesSize * 0.75) + 1;
+        int startIndex = (int) (this.routeCandidates.candidates.size() * 0.75) + 1;
 
-        for (int i = startIndex; i < routeCandidatesSize; i++) {
+        for (int i = startIndex; i < this.routeCandidates.candidates.size(); i++) {
             this.routeCandidates.candidates.remove(i);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
index 4c1d79447b..39a06198f6 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
@@ -7,29 +7,47 @@
  * A route candidate as in Prof. Dr. Sabine Storandts Paper Region-Aware Route Planning.
  */
 public class RouteCandidate implements Comparable<RouteCandidate> {
-    private final Path startToPolygonEntry;
-    private final Path polygonEntryToPolygonExit;
-    private final Path polygonExitToEnd;
-    private final Path directRouteStartEnd;
+    private Path startToPolygonEntry;
+    private Path polygonEntryToPolygonExit;
+    private Path polygonExitToEnd;
+    private Path directRouteStartEnd;
     private final PolygonThroughRoutingTemplate polygonRoutingTemplate;
-    private final RoutingAlgorithm routingAlgorithm;
+    private RoutingAlgorithm routingAlgorithm;
     private final DijkstraManyToMany pathSkeletonRouter;
     private final double distance;
 
     public RouteCandidate(final PolygonThroughRoutingTemplate polygonRoutingTemplate, final int startNodeID, final int endNodeID, final int polygonEntryNodeID,
                           final int polygonExitNodeID) {
         this.polygonRoutingTemplate = polygonRoutingTemplate;
-        this.routingAlgorithm = polygonRoutingTemplate.getRoutingAlgorithm();
         this.pathSkeletonRouter = polygonRoutingTemplate.getPathSkeletonRouter();
 
-        this.startToPolygonEntry = this.routingAlgorithm.calcPath(startNodeID, polygonEntryNodeID);
-        this.polygonEntryToPolygonExit = this.pathSkeletonRouter.getPathByStartEndPoint(polygonEntryNodeID, polygonExitNodeID);
-        this.polygonExitToEnd = this.routingAlgorithm.calcPath(polygonExitNodeID, endNodeID);
-        this.directRouteStartEnd = this.routingAlgorithm.calcPath(startNodeID, endNodeID);
+        calcPathFromStartToPolygonEntry(polygonRoutingTemplate, startNodeID, polygonEntryNodeID);
+        calcPathThroughPolygon(polygonEntryNodeID, polygonExitNodeID);
+        calcPathFromPolygonExitToEnd(polygonRoutingTemplate, endNodeID, polygonExitNodeID);
+        calcDirectRouteFromStartToEnd(polygonRoutingTemplate, startNodeID, endNodeID);
 
         this.distance = this.startToPolygonEntry.getDistance() + this.polygonEntryToPolygonExit.getDistance() + this.polygonExitToEnd.getDistance();
     }
 
+    private void calcDirectRouteFromStartToEnd(PolygonThroughRoutingTemplate polygonRoutingTemplate, int startNodeID, int endNodeID) {
+        this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
+        this.directRouteStartEnd = this.routingAlgorithm.calcPath(startNodeID, endNodeID);
+    }
+
+    private void calcPathFromPolygonExitToEnd(PolygonThroughRoutingTemplate polygonRoutingTemplate, int endNodeID, int polygonExitNodeID) {
+        this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
+        this.polygonExitToEnd = this.routingAlgorithm.calcPath(polygonExitNodeID, endNodeID);
+    }
+
+    private void calcPathThroughPolygon(int polygonEntryNodeID, int polygonExitNodeID) {
+        this.polygonEntryToPolygonExit = this.pathSkeletonRouter.getPathByStartEndPoint(polygonEntryNodeID, polygonExitNodeID);
+    }
+
+    private void calcPathFromStartToPolygonEntry(PolygonThroughRoutingTemplate polygonRoutingTemplate, int startNodeID, int polygonEntryNodeID) {
+        this.routingAlgorithm = polygonRoutingTemplate.getNewRoutingAlgorithm();
+        this.startToPolygonEntry = this.routingAlgorithm.calcPath(startNodeID, polygonEntryNodeID);
+    }
+
     public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
         Path completePathCandidate = new Path(queryGraph, algoOpts.getWeighting());
         completePathCandidate.addPath(startToPolygonEntry);
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
index 9b77cc5863..54e0df9822 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -2,7 +2,6 @@
 
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidate;
 import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidateList;
@@ -38,6 +37,7 @@ RouteCandidateList findCandidateRoutes() {
         List<List<Integer>> LOTNodes = findLocalOptimalTouchnodes(polygonEntryExitPoints);
         this.dijkstraForPathSkeleton = new DijkstraManyToMany(this.queryGraph, this.algorithmOptions.getWeighting(), this.algorithmOptions.getTraversalMode(), nodesInPolygon,
                                                               polygonEntryExitPoints);
+        this.dijkstraForPathSkeleton.findAllPathsBetweenEntryExitPoints();
 
         for (int i = 0; i < LOTNodes.size() - 1; i++) {
             lookUpStartEndNodes(i);
@@ -67,12 +67,12 @@ private RouteCandidate buildCandidatePath(int currentPointID, int nextPointID, i
 
     private void lookUpStartEndNodes(int pointsIndex) {
         // TODO Check if this is necessary since we already have node ids and we would add additional via points to the queryGraph result cache. This could have an impact.
-        final GHPoint currentPoint = this.ghRequest.getPoints().get(pointsIndex);
-        final GHPoint nextPoint = this.ghRequest.getPoints().get(pointsIndex + 1);
-
-        List<GHPoint> LOTNodesGHPoints = Arrays.asList(currentPoint, nextPoint);
-        List<QueryResult> lookupResults = super.lookup(LOTNodesGHPoints, this.encodingManager.getEncoder(this.ghRequest.getVehicle()));
-        this.queryGraph.lookup(lookupResults);
+//        final GHPoint currentPoint = this.ghRequest.getPoints().get(pointsIndex);
+//        final GHPoint nextPoint = this.ghRequest.getPoints().get(pointsIndex + 1);
+//
+//        List<GHPoint> LOTNodesGHPoints = Arrays.asList(currentPoint, nextPoint);
+//        List<QueryResult> lookupResults = super.lookup(LOTNodesGHPoints, this.encodingManager.getEncoder(this.ghRequest.getVehicle()));
+//        this.queryGraph.lookup(lookupResults);
     }
 
     // Definition 6 in Storandts paper Region-Aware Routing Planning
@@ -94,25 +94,33 @@ private void lookUpStartEndNodes(int pointsIndex) {
     private void makeLOTNodeListForThisPoint(List<Integer> polygonEntryExitPoints, EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, QueryResult point) {
         Map<Integer, Double> distancesToPolygonEntryExit = getDistancesFromPointToEntryExitPoints(point, polygonEntryExitPoints);
         addEntryExitPointsCopyTo(polygonEntryExitPoints, LOTNodes);
-        for (final int entryExitPoint : LOTNodes.get(LOTNodes.size() - 1)) {
-            checkIfThisIsAValidLOTNode(edgeExplorer, LOTNodes, distancesToPolygonEntryExit, entryExitPoint);
-        }
+
+        List<Integer> thisPointLOTNodeList = LOTNodes.get(LOTNodes.size() - 1);
+        int i = 0;
+        do {
+            int entryExitPoint = thisPointLOTNodeList.get(i);
+            boolean betterFound = checkIfThisIsAValidLOTNode(edgeExplorer, LOTNodes, distancesToPolygonEntryExit, entryExitPoint);
+
+            if (betterFound) {
+                pruneThisNoteFromLOT(LOTNodes, entryExitPoint);
+            } else {
+                i++;
+            }
+        } while (i < thisPointLOTNodeList.size());
     }
 
-    private void checkIfThisIsAValidLOTNode(EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, Map<Integer, Double> distancesToPolygonEntryExit, int entryExitPoint) {
+    private boolean checkIfThisIsAValidLOTNode(EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, Map<Integer, Double> distancesToPolygonEntryExit, int entryExitPoint) {
         EdgeIterator neighborFinder = edgeExplorer.setBaseNode(entryExitPoint);
         Double distanceOfThisEntryExitPointFromPoint = distancesToPolygonEntryExit.get(entryExitPoint);
 
         boolean foundABetterLOTNode =
                 lookForNeighborsThatMakeABetterLOTNode(distancesToPolygonEntryExit, neighborFinder, distanceOfThisEntryExitPointFromPoint);
 
-        pruneThisNoteFromLOTIfBetterWasFound(LOTNodes, entryExitPoint, foundABetterLOTNode);
+        return foundABetterLOTNode;
     }
 
-    private void pruneThisNoteFromLOTIfBetterWasFound(List<List<Integer>> LOTNodes, int entryExitPoint, boolean foundABetterLOTNode) {
-        if (foundABetterLOTNode) {
-            LOTNodes.get(LOTNodes.size() - 1).remove((Integer) entryExitPoint);
-        }
+    private void pruneThisNoteFromLOT(List<List<Integer>> LOTNodes, int entryExitPoint) {
+        LOTNodes.get(LOTNodes.size() - 1).remove((Integer) entryExitPoint);
     }
 
     private boolean lookForNeighborsThatMakeABetterLOTNode(Map<Integer, Double> distancesToPolygonEntryExit, EdgeIterator neighborFinder,
@@ -165,10 +173,9 @@ private void addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoi
         for (int node : nodesInPolygon) {
             final EdgeIterator edgeIterator = edgeExplorer.setBaseNode(node);
 
-            do {
+            while (edgeIterator.next()) {
                 addToEntryExitIfNotExistentAndNotInPolygon(nodesInPolygon, entryExitPoints, edgeIterator);
             }
-            while (edgeIterator.next());
         }
     }
 
@@ -188,8 +195,9 @@ private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPol
         return visitor.getNodesInPolygon();
     }
 
-    public RoutingAlgorithm getRoutingAlgorithm() {
-        return this.routingAlgorithm;
+    public RoutingAlgorithm getNewRoutingAlgorithm() {
+        return this.algoFactory.createAlgo(queryGraph, algorithmOptions);
+        //return this.routingAlgorithm;
     }
 
     public DijkstraManyToMany getPathSkeletonRouter() {
diff --git a/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java b/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java
index 9f7ed35dd5..a14c9aac74 100644
--- a/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java
+++ b/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java
@@ -98,9 +98,9 @@ private void getNodeList() {
                                 new Node(52, 11, 16),
                                 new Node(53, 14, 15),
                                 new Node(54, 15, 18),
+                                new Node(55, 15, 20),
                                 new Node(56, 15, 20),
-                                new Node(57, 13, 20),
-                                new Node(58, 13, 18)};
+                                new Node(57, 13, 20)};
     }
 
     private void setDistanceToEuclidean() {
@@ -136,7 +136,7 @@ private void buildEdges() {
         this.graph.edge(6, 14, 1, true);
         this.graph.edge(7, 19, 1, true);
         this.graph.edge(7, 43, 1, true);
-        this.graph.edge(7, 48, 1, true);
+        this.graph.edge(7, 44, 1, true);
         this.graph.edge(8, 44, 1, true);
         this.graph.edge(8, 45, 1, true);
         this.graph.edge(9, 30, 1, true);
@@ -200,6 +200,7 @@ private void buildEdges() {
         this.graph.edge(34, 35, 1, true);
         this.graph.edge(34, 50, 1, true);
         this.graph.edge(35, 36, 1, true);
+        this.graph.edge(35, 50, 1, true);
         this.graph.edge(36, 37, 1, true);
         this.graph.edge(36, 50, 1, true);
         this.graph.edge(37, 38, 1, true);
