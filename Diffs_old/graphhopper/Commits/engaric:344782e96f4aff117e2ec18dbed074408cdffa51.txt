diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 0a08df0dbe..0bbae6b6d8 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -314,32 +314,71 @@ private void createRteptBlock( StringBuilder output, Instruction instruction, In
     /**
      * This method is useful for navigation devices to find the next instruction for the specified
      * coordinate (e.g. the current position).
+     * <p>
+     * @param maxDistance the maximum acceptable distance to the instruction (in meter)
+     * @return the next Instruction or null if too far away.
      */
-    public Instruction find( double lat, double lon )
-    {        
-        double distanceToPath = Double.MAX_VALUE;
-        int nextInstrNumber = 0;
-
-        // Search the closest edge to the point
-        for (int instructionIndex = 0; instructionIndex < getSize() - 1; instructionIndex++)
+    public Instruction find( double lat, double lon, double maxDistance )
+    {
+        // handle special cases
+        if (getSize() == 0)
         {
-            double edgeNodeLat1 = get(instructionIndex).getPoints().getLatitude(0);
-            double edgeNodeLon1 = get(instructionIndex).getPoints().getLongitude(0);
-            int node2NOP = get(instructionIndex + 1).getPoints().getSize();
-            double edgeNodeLat2 = get(instructionIndex + 1).getPoints().getLatitude(node2NOP - 1);
-            double edgeNodeLon2 = get(instructionIndex + 1).getPoints().getLongitude(node2NOP - 1);
-
-            // calculate the distance from the point to the edge
-            double distanceToEdge = Helper.DIST_EARTH.calcNormalizedEdgeDistance(lat, lon, edgeNodeLat1, edgeNodeLon1, edgeNodeLat2, edgeNodeLon2);
-
-            if (distanceToEdge < distanceToPath)
+            return null;
+        }
+        PointList points = get(0).getPoints();
+        double prevLat = points.getLatitude(0);
+        double prevLon = points.getLongitude(0);
+        DistanceCalc distCalc = Helper.DIST_EARTH;
+        double foundMinDistance = distCalc.calcNormalizedDist(lat, lon, prevLat, prevLon);
+        int foundInstruction = 0;
+
+        // Search the closest edge to the query point
+        if (getSize() > 1)
+        {
+            for (int instructionIndex = 0; instructionIndex < getSize(); instructionIndex++)
             {
-                distanceToPath = distanceToEdge;
-                nextInstrNumber = instructionIndex + 1;
+                points = get(instructionIndex).getPoints();
+                for (int pointIndex = 0; pointIndex < points.size(); pointIndex++)
+                {
+                    double currLat = points.getLatitude(pointIndex);
+                    double currLon = points.getLongitude(pointIndex);
+
+                    if (!(instructionIndex == 0 && pointIndex == 0))
+                    {
+                        // calculate the distance from the point to the edge
+                        double distance;
+                        int index = instructionIndex;
+                        if (distCalc.validEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon))
+                        {
+                            distance = distCalc.calcNormalizedEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon);
+                            if (pointIndex > 0)
+                                index++;
+                        } else
+                        {
+                            distance = distCalc.calcNormalizedDist(lat, lon, currLat, currLon);
+                        }
+
+                        if (distance < foundMinDistance)
+                        {
+                            foundMinDistance = distance;
+                            foundInstruction = index;
+                        }
+                    }
+
+                    prevLat = currLat;
+                    prevLon = currLon;
+                }
             }
         }
 
-        return get(nextInstrNumber);
+        if (distCalc.calcDenormalizedDist(foundMinDistance) > maxDistance)
+            return null;
+
+        // special case finish condition
+        if (foundInstruction == getSize())
+            foundInstruction--;
+
+        return get(foundInstruction);
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index b551120613..4e6b9e423f 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -141,7 +141,7 @@ public void testWayList()
         path.extract();
         // 2-1-0
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
-        
+
         instr = path.calcInstructions(tr);
         res = instr.createJson();
         tmp = res.get(0);
@@ -193,15 +193,24 @@ public void testFindInstruction()
         path.extract();
 
         InstructionList il = path.calcInstructions(tr);
-        Instruction nextInstr1 = il.find(0.0, 0.1);
-        Instruction nextInstr2 = il.find(5.0, 0.4);
-        Instruction nextInstr3 = il.find(9.0, 0.53);
-        Instruction nextInstr4 = il.find(7.8, 0.25);
-
+        Instruction nextInstr0 = il.find(-0.001, 0.0, 1000);
+        assertEquals(Instruction.CONTINUE_ON_STREET, nextInstr0.getSign());
+        
+        Instruction nextInstr1 = il.find(0.001, 0.001, 1000);
         assertEquals(Instruction.TURN_RIGHT, nextInstr1.getSign());
+
+        Instruction nextInstr2 = il.find(5.0, 0.004, 1000);
         assertEquals(Instruction.TURN_LEFT, nextInstr2.getSign());
+
+        Instruction nextInstr3 = il.find(9.99, 0.503, 1000);
         assertEquals(Instruction.TURN_SHARP_LEFT, nextInstr3.getSign());
+
+        // a bit far away ...
+        Instruction nextInstr4 = il.find(7.40, 0.25, 20000);
         assertEquals(Instruction.FINISH, nextInstr4.getSign());
+
+        // too far away
+        assertNull(il.find(50.8, 50.25, 1000));
     }
 
 }
