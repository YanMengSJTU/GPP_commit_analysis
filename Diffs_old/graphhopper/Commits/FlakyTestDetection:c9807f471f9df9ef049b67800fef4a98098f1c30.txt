diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 0bf8616b9c..f903a28234 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1183,7 +1183,7 @@ protected void prepareCH() {
      * For landmarks it is required to always call this method: either it creates the landmark data or it loads it.
      */
     protected void loadOrPrepareLM() {
-        boolean tmpPrepare = lmFactoryDecorator.isEnabled();
+        boolean tmpPrepare = lmFactoryDecorator.isEnabled() && !lmFactoryDecorator.getPreparations().isEmpty();
         if (tmpPrepare) {
             ensureWriteAccess();
             ghStorage.freeze();
diff --git a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java b/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
index cb31c43956..33cc90ea75 100644
--- a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
+++ b/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
@@ -3,6 +3,7 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.routing.lm.LandmarkStorage;
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.FlagEncoderFactory;
@@ -11,12 +12,15 @@
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupBuilder;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.PMap;
+import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.BBox;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.io.FileReader;
 import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
 
 /**
  * Helper class to build the spatial rule index
@@ -27,7 +31,7 @@
 
     private static final Logger logger = LoggerFactory.getLogger(SpatialRuleLookupHelper.class);
 
-    public static void buildAndInjectSpatialRuleIntoGH(GraphHopper graphHopper, CmdArgs args){
+    public static void buildAndInjectSpatialRuleIntoGH(GraphHopper graphHopper, CmdArgs args) {
         String spatialRuleLocation = args.get("spatial_rules.location", "");
         if (!spatialRuleLocation.isEmpty()) {
             try {
@@ -52,4 +56,14 @@ public FlagEncoder createFlagEncoder(String name, PMap configuration) {
         }
     }
 
+    public static JsonFeatureCollection createLandmarkSplittingFeatureCollection(String location) {
+        try {
+            Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
+            return new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class);
+        } catch (IOException e) {
+            logger.error("Problem while reading border map GeoJSON. Skipping this.", e);
+        }
+        return null;
+    }
+
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java
index 0c8e47ff70..13fd33146c 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java
@@ -18,15 +18,32 @@
 package com.graphhopper.reader.osm;
 
 import com.graphhopper.GraphHopper;
+import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.reader.DataReader;
+import com.graphhopper.routing.lm.PrepareLandmarks;
+import com.graphhopper.routing.util.spatialrules.*;
 import com.graphhopper.storage.GraphHopperStorage;
 
+import java.util.List;
+
 /**
  * This class is the simplified entry to all functionality if you import from OpenStreetMap data.
  *
  * @author Peter Karich
  */
 public class GraphHopperOSM extends GraphHopper {
+
+    private final JsonFeatureCollection landmarkSplittingFeatureCollection;
+
+    public GraphHopperOSM() {
+        this(null);
+    }
+
+    public GraphHopperOSM(JsonFeatureCollection landmarkSplittingFeatureCollection) {
+        super();
+        this.landmarkSplittingFeatureCollection = landmarkSplittingFeatureCollection;
+    }
+
     @Override
     protected DataReader createReader(GraphHopperStorage ghStorage) {
         return initDataReader(new OSMReader(ghStorage));
@@ -44,4 +61,32 @@ public GraphHopperOSM setOSMFile(String osmFileStr) {
         super.setDataReaderFile(osmFileStr);
         return this;
     }
+
+    @Override
+    protected void loadOrPrepareLM() {
+        if (!getLMFactoryDecorator().isEnabled() || getLMFactoryDecorator().getPreparations().isEmpty())
+            return;
+
+        if (landmarkSplittingFeatureCollection != null && !landmarkSplittingFeatureCollection.getFeatures().isEmpty()) {
+            SpatialRuleLookup ruleLookup = SpatialRuleLookupBuilder.buildIndex(landmarkSplittingFeatureCollection, "area", new SpatialRuleLookupBuilder.SpatialRuleFactory() {
+                @Override
+                public SpatialRule createSpatialRule(final String id, List<Polygon> polygons) {
+                    return new DefaultSpatialRule() {
+                        @Override
+                        public String getId() {
+                            return id;
+                        }
+                    }.setBorders(polygons);
+                }
+            });
+            for (PrepareLandmarks prep : getLMFactoryDecorator().getPreparations()) {
+                // the ruleLookup splits certain areas from each other but avoids making this a permanent change so that other algorithms still can route through these regions.
+                if (ruleLookup != null && ruleLookup.size() > 0) {
+                    prep.setSpatialRuleLookup(ruleLookup);
+                }
+            }
+        }
+
+        super.loadOrPrepareLM();
+    }
 }
diff --git a/tools/src/main/java/com/graphhopper/tools/Import.java b/tools/src/main/java/com/graphhopper/tools/Import.java
index 7854e9fd76..84c1571919 100644
--- a/tools/src/main/java/com/graphhopper/tools/Import.java
+++ b/tools/src/main/java/com/graphhopper/tools/Import.java
@@ -18,18 +18,33 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.GraphHopper;
+import com.graphhopper.json.GHJsonFactory;
+import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.routing.lm.LandmarkStorage;
 import com.graphhopper.spatialrules.SpatialRuleLookupHelper;
 import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Parameters;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
 
 /**
  * @author Peter Karich
  */
 public class Import {
+    private static final Logger logger = LoggerFactory.getLogger(Import.class);
+
     public static void main(String[] strs) throws Exception {
         CmdArgs args = CmdArgs.read(strs);
         args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
-        GraphHopper hopper = new GraphHopperOSM();
+        GraphHopper hopper = new GraphHopperOSM(
+                SpatialRuleLookupHelper.createLandmarkSplittingFeatureCollection(args.get(Parameters.Landmark.PREPARE + "split_area_location", ""))
+        );
         SpatialRuleLookupHelper.buildAndInjectSpatialRuleIntoGH(hopper, args);
         hopper.init(args);
         hopper.importOrLoad();
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
index 23658883b3..c1329ba70e 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
@@ -68,43 +68,9 @@ protected void configure() {
     @Provides
     @Singleton
     GraphHopper createGraphHopper(CmdArgs args) {
-        GraphHopper graphHopper = new GraphHopperOSM() {
-            @Override
-            protected void loadOrPrepareLM() {
-                if (!getLMFactoryDecorator().isEnabled() || getLMFactoryDecorator().getPreparations().isEmpty())
-                    return;
-
-                try {
-                    String location = args.get(Parameters.Landmark.PREPARE + "split_area_location", "");
-                    Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
-                    JsonFeatureCollection jsonFeatureCollection = new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class);
-                    if (!jsonFeatureCollection.getFeatures().isEmpty()) {
-                        SpatialRuleLookup ruleLookup = SpatialRuleLookupBuilder.buildIndex(jsonFeatureCollection, "area", new SpatialRuleLookupBuilder.SpatialRuleFactory() {
-                            @Override
-                            public SpatialRule createSpatialRule(String id, List<Polygon> polygons) {
-                                return new DefaultSpatialRule() {
-                                    @Override
-                                    public String getId() {
-                                        return id;
-                                    }
-                                }.setBorders(polygons);
-                            }
-                        });
-                        for (PrepareLandmarks prep : getLMFactoryDecorator().getPreparations()) {
-                            // the ruleLookup splits certain areas from each other but avoids making this a permanent change so that other algorithms still can route through these regions.
-                            if (ruleLookup != null && ruleLookup.size() > 0) {
-                                prep.setSpatialRuleLookup(ruleLookup);
-                            }
-                        }
-                    }
-                } catch (IOException ex) {
-                    logger.error("Problem while reading border map GeoJSON. Skipping this.", ex);
-                }
-
-                super.loadOrPrepareLM();
-            }
-        }.forServer();
-
+        GraphHopper graphHopper = new GraphHopperOSM(
+                SpatialRuleLookupHelper.createLandmarkSplittingFeatureCollection(args.get(Parameters.Landmark.PREPARE + "split_area_location", ""))
+        ).forServer();
         SpatialRuleLookupHelper.buildAndInjectSpatialRuleIntoGH(graphHopper, args);
 
         graphHopper.init(args);
