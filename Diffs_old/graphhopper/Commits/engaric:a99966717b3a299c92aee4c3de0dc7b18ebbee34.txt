diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index c52873d140..48251c1120 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -34,7 +34,6 @@
     no reflection done in EncodingManager which improves portability and makes configuration of encoders possible before adding to manager
     removed dijkstraNativebi as no performance advantage but maintenance disadvantage and similar to oneToManyDijkstra
     to provide context for turn costs we needed to add prevEdgeId into Weighting.calcWeight, see new documentation
->>>>>>> master
     with the introduction of lock protection mechanism (see #112) GraphHopper needs always write access, see also #217
     new GraphHopper.clean method to remove the graph directory via Java API
     FlagEncoder: replaced isFoward and isBackward with more generic isBool(flags, FlagEncoder.FORWARD|BACKWARD)
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 2552a736d3..bc428557e0 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -51,7 +51,8 @@
     private final NodeAccess mainNodeAccess;
     private final int mainNodes;
     private final int mainEdges;
-    private final Graph origGraph;
+    private final QueryGraph origGraph;
+    private final GraphExtension wrappedExtension;
     private List<QueryResult> queryResults;
     /**
      * Virtual edges are created between existing graph and new virtual tower nodes. For every
@@ -64,13 +65,10 @@
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
-    private final DistanceCalc distCalc = Helper.DIST_PLANE;
-    private final GraphExtension wrappedExtension;
 
     public QueryGraph( Graph graph )
     {
         mainGraph = graph;
-        origGraph = this;// TODO graph instanceof LevelGraph ? new OriginalGraph(this) : this;
         mainNodeAccess = graph.getNodeAccess();
         mainNodes = graph.getNodes();
         mainEdges = graph.getAllEdges().getCount();
@@ -79,6 +77,22 @@ public QueryGraph( Graph graph )
             wrappedExtension = new QueryGraphTurnExt(this);
         else
             wrappedExtension = mainGraph.getExtension();
+
+        // create very lightweight QueryGraph which uses variables from this QueryGraph (same virtual edges)
+        origGraph = new QueryGraph(graph.getOriginalGraph(), this);
+    }
+
+    /**
+     * See 'lookup' for further variables that are initialized
+     */
+    private QueryGraph( Graph graph, QueryGraph superQueryGraph )
+    {
+        mainGraph = graph;
+        origGraph = this;
+        wrappedExtension = superQueryGraph.wrappedExtension;
+        mainNodeAccess = graph.getNodeAccess();
+        mainNodes = superQueryGraph.mainNodes;
+        mainEdges = superQueryGraph.mainEdges;
     }
 
     /**
@@ -102,9 +116,13 @@ public void lookup( List<QueryResult> resList )
         if (isInitialized())
             throw new IllegalStateException("Call lookup only once. Otherwise you'll have problems for queries sharing the same edge.");
 
+        // initialize all none-final variables
         virtualEdges = new ArrayList<EdgeIteratorState>(resList.size() * 2);
         virtualNodes = new PointList(resList.size(), mainNodeAccess.is3D());
         queryResults = new ArrayList<QueryResult>(resList.size());
+        origGraph.virtualEdges = virtualEdges;
+        origGraph.virtualNodes = virtualNodes;
+        origGraph.queryResults = queryResults;
 
         TIntObjectMap<List<QueryResult>> edge2res = new TIntObjectHashMap<List<QueryResult>>(resList.size());
 
@@ -190,8 +208,8 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                             double fromLat = fullPL.getLatitude(o1.getWayIndex());
                             double fromLon = fullPL.getLongitude(o1.getWayIndex());
-                            if (distCalc.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
-                                    > distCalc.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
+                            if (Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
+                                    > Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
                                 return 1;
                             return -1;
                         }
@@ -262,7 +280,7 @@ public Graph getOriginalGraph()
     {
         // Note: if the mainGraph of this QueryGraph is a LevelGraph then ignoring the shortcuts will produce a 
         // huge gap of edgeIds between original and virtual edge ids. The only solution would be to move virtual edges
-        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.
+        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
         return origGraph;
     }
 
@@ -325,7 +343,7 @@ private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D cur
         basePoints.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
         PointList baseReversePoints = basePoints.clone(true);
-        double baseDistance = basePoints.calcDistance(distCalc);
+        double baseDistance = basePoints.calcDistance(Helper.DIST_PLANE);
         int virtEdgeId = mainEdges + virtualEdges.size();
 
         // edges between base and snapped point
diff --git a/core/src/main/java/com/graphhopper/storage/OriginalGraph.java b/core/src/main/java/com/graphhopper/storage/OriginalGraph.java
index 26f2fae930..4081d9ece8 100644
--- a/core/src/main/java/com/graphhopper/storage/OriginalGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/OriginalGraph.java
@@ -204,6 +204,9 @@ public EdgeIteratorState detach( boolean reverse )
     @Override
     public EdgeExplorer createEdgeExplorer( final EdgeFilter filter )
     {
+        if (filter == EdgeFilter.ALL_EDGES)
+            return createEdgeExplorer();
+
         return lg.createEdgeExplorer(new EdgeFilter()
         {
             @Override
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
index 114053515c..5f583926ce 100644
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
@@ -17,14 +17,11 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.ch.PrepareEncoder;
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.LevelEdgeFilter;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.GHUtility;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
 import static org.junit.Assert.*;
 import org.junit.Test;
 
@@ -68,7 +65,7 @@ public void testCannotBeLoadedViaDifferentClass()
     @Test
     public void testPriosWhileDeleting()
     {
-        LevelGraphStorage g = createGraph();        
+        LevelGraphStorage g = createGraph();
         g.getNodeAccess().ensureNode(19);
         for (int i = 0; i < 20; i++)
         {
@@ -85,7 +82,7 @@ public void testPrios()
     {
         LevelGraph g = createGraph();
         g.getNodeAccess().ensureNode(30);
-        
+
         assertEquals(0, g.getLevel(10));
 
         g.setLevel(10, 100);
@@ -182,7 +179,7 @@ public void testGetWeight()
         flags = carEncoder.setProperties(10, false, true);
         sc1.setFlags(flags);
         sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);        
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
         assertFalse(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_FORWARD));
         assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_BACKWARD));
     }
@@ -209,4 +206,47 @@ public void testGetWeightIfAdvancedEncoder()
         sc1.setWeight(1.011011);
         assertEquals(1.011011, sc1.getWeight(), 1e-3);
     }
+
+    @Test
+    public void testQueryGraph()
+    {
+        LevelGraph levelGraph = createGraph();
+        NodeAccess na = levelGraph.getNodeAccess();
+        na.setNode(0, 1.00, 1.00);
+        na.setNode(1, 1.02, 1.00);
+        na.setNode(2, 1.04, 1.00);
+
+        EdgeIteratorState edge1 = levelGraph.edge(0, 1);
+        EdgeIteratorState edge2 = levelGraph.edge(1, 2);
+        levelGraph.shortcut(0, 1);
+        
+        QueryGraph qGraph = new QueryGraph(levelGraph);
+        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
+        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
+        qGraph.lookup(fromRes, toRes);
+
+        Graph oGraph = qGraph.getOriginalGraph();
+        EdgeExplorer explorer = oGraph.createEdgeExplorer();
+
+        assertTrue(levelGraph.getNodes() < qGraph.getNodes());
+        assertTrue(oGraph.getNodes() == qGraph.getNodes());
+
+        // traverse virtual edges and normal edges but no shortcuts!
+        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
+        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
+
+        // get neighbors from virtual nodes
+        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
+        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
+    }
+
+    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
+    {
+        QueryResult res = new QueryResult(lat, lon);
+        res.setClosestEdge(edge);
+        res.setWayIndex(wayIndex);
+        res.setSnappedPosition(QueryResult.Position.EDGE);
+        res.calcSnappedPoint(Helper.DIST_PLANE);
+        return res;
+    }
 }
