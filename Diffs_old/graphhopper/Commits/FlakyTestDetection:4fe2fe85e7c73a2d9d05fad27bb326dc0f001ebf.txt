diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index aa23cb20cb..3f26531b71 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -38,6 +38,7 @@ Here is an overview:
  * JohannesPelzer, improved GPX information and various other things
  * karussell, one of the core developers
  * khuebner, initial turn costs support
+ * legraina, improved docker for dockerhub
  * lmar, improved instructions
  * michaz, one of the core developers
  * mprins, improvements for travis CI and regarding JDK9 #806
diff --git a/Dockerfile b/Dockerfile
index 07d264dfd3..19d70fc819 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,10 +1,21 @@
 FROM openjdk:8-jdk
 
-RUN mkdir -p /data
-RUN mkdir -p /graphhopper
+ENV JETTY_PORT 11111
+ENV JAVA_OPTS "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
+
+RUN mkdir -p /data && \
+    mkdir -p /graphhopper
 
 COPY . /graphhopper/
 
 WORKDIR /graphhopper
 
 RUN ./graphhopper.sh buildweb
+
+VOLUME [ "/data" ]
+
+EXPOSE 11111
+
+ENTRYPOINT [ "./graphhopper.sh", "web" ]
+
+CMD [ "/data/europe_germany_berlin.pbf" ]
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index 48daf5a87d..9bce2ca7dc 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -174,6 +174,11 @@ PathWrapper createPathWrapper(JsonNode path,
                         instr = new FinishInstruction(text, instPL, 0);
                     } else {
                         instr = new Instruction(sign, text, ia, instPL);
+                        if(sign == Instruction.CONTINUE_ON_STREET){
+                            if(jsonObj.has("heading")){
+                                instr.setExtraInfo("heading", jsonObj.get("heading").asDouble());
+                            }
+                        }
                     }
 
                     // Usually, the translation is done from the routing service so just use the provided string
diff --git a/core/files/docker-compose.yml b/core/files/docker-compose.yml
index 55c7c34c5b..ff9d1f7c7c 100644
--- a/core/files/docker-compose.yml
+++ b/core/files/docker-compose.yml
@@ -10,7 +10,4 @@ services:
             JAVA_OPTS: "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
         ports:
             - "11111:11111"
-        entrypoint:
-            - ./graphhopper.sh
-            - web
-            - ../data/europe_germany_berlin.pbf
+        command: /data/europe_germany_berlin.pbf
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 0a8c326924..b59f5885f6 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1074,6 +1074,9 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                         setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
                         setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
 
+                if(request.hasFavoredHeading(0))
+                    pathMerger.setFavoredHeading(request.getFavoredHeading(0));
+
                 if (routingTemplate.isReady(pathMerger, tr))
                     break;
             }
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
index 4278e995b7..6307564897 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
@@ -66,13 +66,17 @@
     private double doublePrevLat, doublePrevLon; // Lat and Lon of node t-2
     private int prevNode;
     private double prevOrientation;
+    private double prevInstructionPrevOrientation = Double.NaN;
     private Instruction prevInstruction;
     private boolean prevInRoundabout;
     private String prevName;
+    private String prevInstructionName;
     private InstructionAnnotation prevAnnotation;
     private EdgeExplorer outEdgeExplorer;
     private EdgeExplorer crossingExplorer;
 
+    private final int MAX_U_TURN_DISTANCE = 35;
+
     public InstructionsFromEdges(int tmpNode, Graph graph, Weighting weighting, FlagEncoder encoder, NodeAccess nodeAccess, Translation tr, InstructionList ways) {
         this.weighting = weighting;
         this.encoder = encoder;
@@ -119,6 +123,10 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
         {
             int sign = Instruction.CONTINUE_ON_STREET;
             prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+            double startLat = nodeAccess.getLat(baseNode);
+            double startLon = nodeAccess.getLon(baseNode);
+            double heading = Helper.ANGLE_CALC.calcAzimuth(startLat, startLon, latitude, longitude);
+            prevInstruction.setExtraInfo("heading", Helper.round(heading, 2));
             ways.add(prevInstruction);
             prevName = name;
             prevAnnotation = annotation;
@@ -130,6 +138,7 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
                 int sign = Instruction.USE_ROUNDABOUT;
                 RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
                         annotation, new PointList(10, nodeAccess.is3D()));
+                prevInstructionPrevOrientation = prevOrientation;
                 if (prevName != null) {
                     // check if there is an exit at the same node the roundabout was entered
                     EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
@@ -192,6 +201,7 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
                     .setDirOfRotation(deltaOut)
                     .setExited();
 
+            prevInstructionName = prevName;
             prevName = name;
             prevAnnotation = annotation;
 
@@ -199,9 +209,56 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
             int sign = getTurn(edge, baseNode, prevNode, adjNode, annotation, name);
 
             if (sign != Instruction.IGNORE) {
-                prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
-                ways.add(prevInstruction);
-                prevAnnotation = annotation;
+                /*
+                    Check if the next instruction is likely to only be a short connector to execute a u-turn
+                    --A->--
+                           |    <-- This is the short connector
+                    --B-<--
+                    Road A and Road B have to have the same name and roughly the same, but opposite orientation, otherwise we are assuming this is no u-turn.
+
+                    Note: This approach only works if there a turn instruction fro A->Connector and Connector->B.
+                    Currently we don't create a turn instruction if there is no other possible turn
+                    We only create a u-turn if edge B is a one-way, see #1073 for more details.
+                  */
+
+                boolean isUTurn = false;
+                int uTurnType = Instruction.U_TURN_UNKNOWN;
+                if (!Double.isNaN(prevInstructionPrevOrientation)
+                        && prevInstruction.getDistance() < MAX_U_TURN_DISTANCE
+                        && (sign < 0) == (prevInstruction.getSign() < 0)
+                        && (Math.abs(sign) == Instruction.TURN_SLIGHT_RIGHT || Math.abs(sign) == Instruction.TURN_RIGHT || Math.abs(sign) == Instruction.TURN_SHARP_RIGHT)
+                        && (Math.abs(prevInstruction.getSign()) == Instruction.TURN_SLIGHT_RIGHT || Math.abs(prevInstruction.getSign()) == Instruction.TURN_RIGHT || Math.abs(prevInstruction.getSign()) == Instruction.TURN_SHARP_RIGHT)
+                        && edge.isForward(encoder) != edge.isBackward(encoder)
+                        && InstructionsHelper.isNameSimilar(prevInstructionName, name)) {
+                    // Chances are good that this is a u-turn, we only need to check if the orientation matches
+                    GHPoint point = InstructionsHelper.getPointForOrientationCalculation(edge, nodeAccess);
+                    double lat = point.getLat();
+                    double lon = point.getLon();
+                    double currentOrientation = Helper.ANGLE_CALC.calcOrientation(prevLat, prevLon, lat, lon, false);
+
+                    double diff = Math.abs(prevInstructionPrevOrientation - currentOrientation);
+                    if (diff > (Math.PI * .9) && diff < (Math.PI * 1.1)) {
+                        isUTurn = true;
+                        if (sign < 0) {
+                            uTurnType = Instruction.U_TURN_LEFT;
+                        } else {
+                            uTurnType = Instruction.U_TURN_RIGHT;
+                        }
+                    }
+
+                }
+
+                if (isUTurn) {
+                    prevInstruction.setSign(uTurnType);
+                    prevInstruction.setName(name);
+                } else {
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                    // Remember the Orientation and name of the road, before doing this maneuver
+                    prevInstructionPrevOrientation = prevOrientation;
+                    prevInstructionName = prevName;
+                    ways.add(prevInstruction);
+                    prevAnnotation = annotation;
+                }
             }
             // Updated the prevName, since we don't always create an instruction on name changes the previous
             // name can be an old name. This leads to incorrect turn instructions due to name changes
@@ -236,7 +293,11 @@ public void finish() {
             ((RoundaboutInstruction) prevInstruction).setRadian(delta);
 
         }
-        ways.add(new FinishInstruction(nodeAccess, prevEdge.getAdjNode()));
+
+        Instruction finishInstruction = new FinishInstruction(nodeAccess, prevEdge.getAdjNode());
+        // This is the heading how the edge ended
+        finishInstruction.setExtraInfo("last_heading", Helper.ANGLE_CALC.calcAzimuth(doublePrevLat, doublePrevLon, prevLat, prevLon));
+        ways.add(finishInstruction);
     }
 
     private int getTurn(EdgeIteratorState edge, int baseNode, int prevNode, int adjNode, InstructionAnnotation annotation, String name) {
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java b/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java
index daebfb9543..b395f6025f 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsHelper.java
@@ -39,9 +39,6 @@ static int calculateSign(double prevLatitude, double prevLongitude, double latit
         double delta = calculateOrientationDelta(prevLatitude, prevLongitude, latitude, longitude, prevOrientation);
         double absDelta = Math.abs(delta);
 
-        // TODO not only calculate the mathematical orientation, but also compare to other streets
-        // TODO If there is one street turning slight right and one right, but no straight street
-        // TODO We can assume the slight right street would be a continue
         if (absDelta < 0.2) {
             // 0.2 ~= 11°
             return Instruction.CONTINUE_ON_STREET;
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index b780f0ee74..b2c42fee57 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -115,7 +115,7 @@ public double calcAzimuth(double lat1, double lon1, double lat2, double lon2) {
         if (orientation < 0)
             orientation += 2 * Math.PI;
 
-        return Math.toDegrees(Helper.round4(orientation))%360;
+        return Math.toDegrees(Helper.round4(orientation)) % 360;
     }
 
     String azimuth2compassPoint(double azimuth) {
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index 28af4c88a7..085cb88ba9 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,12 +17,14 @@
  */
 package com.graphhopper.util;
 
-import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 public class Instruction {
     public static final int UNKNOWN = -99;
+    public static final int U_TURN_UNKNOWN = -98;
+    public static final int U_TURN_LEFT = -8;
     public static final int KEEP_LEFT = -7;
     public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
@@ -37,6 +39,7 @@
     public static final int USE_ROUNDABOUT = 6;
     public static final int IGNORE = Integer.MIN_VALUE;
     public static final int KEEP_RIGHT = 7;
+    public static final int U_TURN_RIGHT = 8;
     public static final int PT_START_TRIP = 101;
     public static final int PT_TRANSFER = 102;
     public static final int PT_END_TRIP = 103;
@@ -48,6 +51,7 @@
     protected String name;
     protected double distance;
     protected long time;
+    protected Map<String, Object> extraInfo = new HashMap<>(3);
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
@@ -79,6 +83,10 @@ public int getSign() {
         return sign;
     }
 
+    public void setSign(int sign) {
+        this.sign = sign;
+    }
+
     public String getName() {
         return name;
     }
@@ -88,11 +96,11 @@ public void setName(String name) {
     }
 
     public Map<String, Object> getExtraInfoJSON() {
-        return Collections.<String, Object>emptyMap();
+        return extraInfo;
     }
 
     public void setExtraInfo(String key, Object value) {
-        throw new IllegalArgumentException("Key" + key + " is not a valid option");
+        extraInfo.put(key, value);
     }
 
     /**
@@ -270,6 +278,15 @@ public String getTurnDescription(Translation tr) {
         } else {
             String dir = null;
             switch (indi) {
+                case Instruction.U_TURN_UNKNOWN:
+                    dir = tr.tr("u_turn");
+                    break;
+                case Instruction.U_TURN_LEFT:
+                    dir = tr.tr("u_turn");
+                    break;
+                case Instruction.U_TURN_RIGHT:
+                    dir = tr.tr("u_turn");
+                    break;
                 case Instruction.KEEP_LEFT:
                     dir = tr.tr("keep_left");
                     break;
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index b2aeba8f43..4395e0d395 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -48,6 +48,7 @@
     private boolean calcPoints = true;
     private PathDetailsBuilderFactory pathBuilderFactory;
     private List<String> requestedPathDetails = Collections.EMPTY_LIST;
+    private double favoredHeading = Double.NaN;
 
     public PathMerger setCalcPoints(boolean calcPoints) {
         this.calcPoints = calcPoints;
@@ -135,8 +136,10 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
                 calcAscendDescend(altRsp, fullPoints);
         }
 
-        if (enableInstructions)
+        if (enableInstructions) {
+            fullInstructions = updateInstructionsWithContext(fullInstructions);
             altRsp.setInstructions(fullInstructions);
+        }
 
         if (!allFound) {
             altRsp.addError(new ConnectionNotFoundException("Connection between locations not found", Collections.<String, Object>emptyMap()));
@@ -173,6 +176,51 @@ public static void merge(List<PathDetail> pathDetails, List<PathDetail> otherDet
         pathDetails.addAll(otherDetails);
     }
 
+    /**
+     * This method iterates over all instructions and uses the available context to improve the instructions.
+     * If the requests contains a heading, this method can transform the first continue to a u-turn if the heading
+     * points into the opposite direction of the route.
+     * At a waypoint it can transform the continue to a u-turn if the route involves turning.
+     */
+    private InstructionList updateInstructionsWithContext(InstructionList instructions) {
+        Instruction instruction;
+        Instruction nextInstruction;
+
+        for (int i = 0; i < instructions.size() - 1; i++) {
+            instruction = instructions.get(i);
+
+            if (i == 0 && !Double.isNaN(favoredHeading) && instruction.extraInfo.containsKey("heading")) {
+                double heading = (double) instruction.extraInfo.get("heading");
+                double diff = Math.abs(heading - favoredHeading) % 360;
+                if (diff > 170 && diff < 190) {
+                    // The requested heading points into the opposite direction of the calculated heading
+                    // therefore we change the continue instruction to a u-turn
+                    instruction.setSign(Instruction.U_TURN_UNKNOWN);
+                }
+            }
+
+            if (instruction.getSign() == Instruction.REACHED_VIA) {
+                nextInstruction = instructions.get(i + 1);
+                if (nextInstruction.getSign() != Instruction.CONTINUE_ON_STREET
+                        || !instruction.extraInfo.containsKey("last_heading")
+                        || !nextInstruction.extraInfo.containsKey("heading")) {
+                    // TODO throw exception?
+                    continue;
+                }
+                double lastHeading = (double) instruction.extraInfo.get("last_heading");
+                double heading = (double) nextInstruction.extraInfo.get("heading");
+
+                // Since it's supposed to go back the same edge, we can be very strict with the diff
+                double diff = Math.abs(lastHeading - heading) % 360;
+                if (diff > 179 && diff < 181) {
+                    nextInstruction.setSign(Instruction.U_TURN_UNKNOWN);
+                }
+            }
+        }
+
+        return instructions;
+    }
+
     private void calcAscendDescend(final PathWrapper rsp, final PointList pointList) {
         double ascendMeters = 0;
         double descendMeters = 0;
@@ -192,4 +240,8 @@ private void calcAscendDescend(final PathWrapper rsp, final PointList pointList)
         rsp.setAscend(ascendMeters);
         rsp.setDescend(descendMeters);
     }
+
+    public void setFavoredHeading(double favoredHeading) {
+        this.favoredHeading = favoredHeading;
+    }
 }
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/util/ViaInstruction.java b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
index 6d348bc768..cf35a22237 100644
--- a/core/src/main/java/com/graphhopper/util/ViaInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/ViaInstruction.java
@@ -31,6 +31,7 @@ public ViaInstruction(Instruction instr) {
         this(instr.getName(), instr.getAnnotation(), instr.getPoints());
         setDistance(instr.getDistance());
         setTime(instr.getTime());
+        this.extraInfo = instr.extraInfo;
     }
 
     @Override
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index c2df7a627d..fbbb480a43 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -597,6 +597,76 @@ public void testCalcInstructionSlightTurn() {
         assertEquals(-1, wayList.get(1).getSign());
     }
 
+    @Test
+    public void testUTurnLeft() {
+        final Graph g = new GraphBuilder(carManager).create();
+        final NodeAccess na = g.getNodeAccess();
+
+        // Real Situation: point=48.402116%2C9.994367&point=48.402198%2C9.99507
+        //       7
+        //       |
+        //  4----5----6
+        //       |
+        //  1----2----3
+        na.setNode(1, 48.402116, 9.994367);
+        na.setNode(2, 48.402198, 9.99507);
+        na.setNode(3, 48.402344, 9.996266);
+        na.setNode(4, 48.402191, 9.994351);
+        na.setNode(5, 48.402298, 9.995053);
+        na.setNode(6, 48.402422, 9.996067);
+        na.setNode(7, 48.402604, 9.994962);
+
+        g.edge(1, 2, 5, false).setName("Olgastraße");
+        g.edge(2, 3, 5, false).setName("Olgastraße");
+        g.edge(6, 5, 5, false).setName("Olgastraße");
+        g.edge(5, 4, 5, false).setName("Olgastraße");
+        g.edge(2, 5, 5, true).setName("Neithardtstraße");
+        g.edge(5, 7, 5, true).setName("Neithardtstraße");
+
+        Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(1, 4);
+        assertTrue(p.isFound());
+        InstructionList wayList = p.calcInstructions(tr);
+
+        assertEquals(3, wayList.size());
+        assertEquals(Instruction.U_TURN_LEFT, wayList.get(1).getSign());
+    }
+
+    @Test
+    public void testUTurnRight() {
+        final Graph g = new GraphBuilder(carManager).create();
+        final NodeAccess na = g.getNodeAccess();
+
+        // Real Situation: point=-33.885758,151.181472&point=-33.885692,151.181445
+        //       7
+        //       |
+        //  4----5----6
+        //       |
+        //  3----2----1
+        na.setNode(1, -33.885758,151.181472);
+        na.setNode(2, -33.885852,151.180968);
+        na.setNode(3, -33.885968,151.180501);
+        na.setNode(4, -33.885883,151.180442);
+        na.setNode(5, -33.885772,151.180941);
+        na.setNode(6, -33.885692,151.181445);
+        na.setNode(7, -33.885692,151.181445);
+
+        g.edge(1, 2, 5, false).setName("Parramatta Road");
+        g.edge(2, 3, 5, false).setName("Parramatta Road");
+        g.edge(4, 5, 5, false).setName("Parramatta Road");
+        g.edge(5, 6, 5, false).setName("Parramatta Road");
+        g.edge(2, 5, 5, true).setName("Larkin Street");
+        g.edge(5, 7, 5, true).setName("Larkin Street");
+
+        Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(1, 6);
+        assertTrue(p.isFound());
+        InstructionList wayList = p.calcInstructions(tr);
+
+        assertEquals(3, wayList.size());
+        assertEquals(Instruction.U_TURN_RIGHT, wayList.get(1).getSign());
+    }
+
     @Test
     public void testCalcInstructionsForTurn() {
         // The street turns left, but there is not turn
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index bcc5e252b1..e1ca2b6d7b 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -129,6 +129,35 @@ public void testMonacoWithInstructions() throws Exception {
         assertEquals(totalResponseMillis, lastEntryMillis);
     }
 
+    @Test
+    public void testUTurn() throws Exception {
+        GraphHopper tmpHopper = new GraphHopperOSM().
+                setOSMFile(DIR + "/monaco.osm.gz").
+                setCHEnabled(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager("car"));
+        tmpHopper.importOrLoad();
+
+        GHRequest request = new GHRequest();
+        //Force initial U-Turn
+        request.addPoint(new GHPoint(43.743887, 7.431151), 200);
+        request.addPoint(new GHPoint(43.744007, 7.431076));
+
+        request.setAlgorithm(ASTAR).setVehicle("car").setWeighting(weightCalcStr);
+        GHResponse rsp = tmpHopper.route(request);
+
+        assertFalse(rsp.hasErrors());
+        PathWrapper arsp = rsp.getBest();
+        InstructionList il = arsp.getInstructions();
+        assertEquals(3, il.size());
+
+        List<Map<String, Object>> resultJson = il.createJson();
+        // Initial U-turn
+        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(0).get("text"));
+        // Second U-turn to get to destination
+        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(1).get("text"));
+    }
+
     @Test
     public void testAlternativeRoutes() {
         GHRequest req = new GHRequest(43.729057, 7.41251, 43.740298, 7.423561).
@@ -339,6 +368,7 @@ public void testMonacoVia() {
         assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
 
         assertEquals("Waypoint 1", resultJson.get(20).get("text"));
+        assertEquals(Instruction.U_TURN_UNKNOWN, resultJson.get(21).get("sign"));
 
         assertEquals("Continue onto Avenue Albert II", resultJson.get(31).get("text"));
         assertEquals("Turn left", resultJson.get(32).get("text"));
@@ -656,6 +686,7 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
 
         assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
         assertEquals("get off the bike", resultJson.get(0).get("annotation_text"));
+        assertEquals(69.28, (Double) resultJson.get(0).get("heading"), .01);
         assertEquals("Turn left onto Kirchengasse", resultJson.get(1).get("text"));
         assertEquals("get off the bike", resultJson.get(1).get("annotation_text"));
 
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index ccd2d2715f..87a694e3fd 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -80,7 +80,7 @@ function initFromParams(e,t){ghRequest.init(e);var o=new Flatpickr(document.getE
 function adjustMapSize(){var e=$("#map"),t=$(window).width()-280;t<400?(t=400,e.attr("style","position: relative; float: right;")):e.attr("style","position: absolute; right: 0;");var a=$(window).height();a<500&&(a=500),e.width(t).height(a),$("#input").height(a);var n=a-60-$("#input_header").height()-$("#footer").height()-$(".route_description").height(),o=$("#route_result_tabs li").height();isNaN(o)||(n-=o),$(".instructions_info").css("max-height",n)}function initMap(e,t,a,n,o,r){adjustMapSize();var i=tileLayers.selectLayer(o);defaultContextmenuItems=[{separator:!0,index:10},{text:translate.tr("show_coords"),callback:function(e){alert(e.latlng.lat+","+e.latlng.lng)},index:11},{text:translate.tr("center_map"),callback:function(e){map.panTo(e.latlng)},index:12}],map=L.map("map",{layers:[i],minZoom:2,contextmenu:!0,contextmenuItems:defaultContextmenuItems,zoomControl:!1,loadingControl:!1});var l={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:t,index:0},m={text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:a,disabled:!0,index:1},s={text:translate.tr("set_end"),icon:"./img/marker-small-red.png",callback:n,index:2};menuStart=map.contextmenu.insertItem(l,l.index),menuIntermediate=map.contextmenu.insertItem(m,m.index),menuEnd=map.contextmenu.insertItem(s,s.index);var u=new L.Control.Zoom({position:"topleft",zoomInTitle:translate.tr("zoom_in"),zoomOutTitle:translate.tr("zoom_out")}).addTo(map);new L.Control.loading({zoomControl:u}).addTo(map),L.control.layers(tileLayers.getAvailableTileLayers()).addTo(map),map.on("baselayerchange",function(e){e.name&&(tileLayers.activeLayerName=e.name,$("#export-link a").attr("href",function(e,t){return t.replace(/(layer=)([\w\s]+)/,"$1"+tileLayers.activeLayerName)}))}),scaleControl=L.control.scale(r?{metric:!1}:{imperial:!1}).addTo(map),map.fitBounds(new L.LatLngBounds(new L.LatLng(e.minLat,e.minLon),new L.LatLng(e.maxLat,e.maxLon))),map.attributionControl.setPrefix(!1);var d={color:"black",weight:2,opacity:.3},c={type:"Feature",geometry:{type:"LineString",coordinates:[[e.minLon,e.minLat],[e.maxLon,e.minLat],[e.maxLon,e.maxLat],[e.minLon,e.maxLat],[e.minLon,e.minLat]]}};e.initialized&&L.geoJson(c,{style:d}).addTo(map),routingLayer=L.geoJson().addTo(map),routingLayer.options={style:function(e){return e.properties&&e.properties.style},contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("route"),disabled:!0,index:0},{text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:a,index:1}]),contextmenuInheritItems:!1}}function focus(e,t,a){e.lat&&e.lng&&(t||(t=11),routingLayer.clearLayers(),map.setView(new L.LatLng(e.lat,e.lng),t),mainTemplate.setFlag(e,a))}function getToFrom(e,t){return 0===e?FROM:e===t.route.size()-1?TO:-1}var mainTemplate=require("./main-template.js"),tileLayers=require("./config/tileLayers.js"),translate=require("./translate.js"),routingLayer,map,menuStart,menuIntermediate,menuEnd,elevationControl=null,defaultContextmenuItems;module.exports.clearLayers=function(){routingLayer.clearLayers()},module.exports.getRoutingLayer=function(){return routingLayer},module.exports.getSubLayers=function(e){var t=routingLayer.getLayers();return t.filter(function(t){return t.feature&&t.feature.properties&&t.feature.properties.name===e})},module.exports.addDataToRoutingLayer=function(e){routingLayer.addData(e)},module.exports.eachLayer=function(e){routingLayer.eachLayer(e)},module.exports.setDisabledForMapsContextMenu=function(e,t){"start"===e&&map.contextmenu.setDisabled(menuStart,t),"end"===e&&map.contextmenu.setDisabled(menuEnd,t),"intermediate"===e&&map.contextmenu.setDisabled(menuIntermediate,t)},module.exports.fitMapToBounds=function(e){map.fitBounds(e,{padding:[42,42]})},module.exports.removeLayerFromMap=function(e){map.removeLayer(e)},module.exports.focus=focus,module.exports.initMap=initMap,module.exports.adjustMapSize=adjustMapSize,module.exports.addElevation=function(e,t){null===elevationControl&&(elevationControl=L.control.elevation({position:"bottomright",theme:"white-theme",width:450,height:125,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:2,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1}),elevationControl.addTo(map)),elevationControl.options.imperial=t,elevationControl.addData(e)},module.exports.clearElevation=function(){elevationControl&&elevationControl.clear()},module.exports.getMap=function(){return map},module.exports.updateScale=function(e){if(null!==scaleControl){scaleControl.remove();var t=e?{metric:!1}:{imperial:!1};scaleControl=L.control.scale(t).addTo(map)}};var FROM="from",TO="to",iconFrom=L.icon({iconUrl:"./img/marker-icon-green.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]}),iconTo=L.icon({iconUrl:"./img/marker-icon-red.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]});module.exports.createMarker=function(e,t,a,n,o,r){var i=getToFrom(e,r);return L.marker([t.lat,t.lng],{icon:i===FROM?iconFrom:i===TO?iconTo:new L.NumberedDivIcon({number:e}),draggable:!0,contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("marker")+" "+(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e),disabled:!0,index:0},{text:translate.tr(i!==TO?"set_end":"set_start"),icon:i!==TO?"./img/marker-small-red.png":"./img/marker-small-green.png",callback:i!==TO?a:n,index:2},{text:translate.tr("delete_from_route"),callback:o,disabled:i!==-1&&2===r.route.size(),index:3}]),contextmenuInheritItems:!1}).addTo(routingLayer).bindPopup(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e)};
 
 },{"./config/tileLayers.js":10,"./main-template.js":22,"./translate.js":31}],24:[function(require,module,exports){
-module.exports.extractMetaVersionInfo=function(e){return metaVersionInfo="",e.data_date&&(metaVersionInfo+="<br/>Data date: "+e.data_date),e.import_date&&(metaVersionInfo+="<br/>Import date: "+e.import_date),e.prepare_date&&(metaVersionInfo+="<br/>Prepare date: "+e.prepare_date),e.version&&(metaVersionInfo+="<br/>GH version: "+e.version),e.build_date&&(metaVersionInfo+="<br/>Jar date: "+e.build_date),metaVersionInfo},module.exports.getSignName=function(e){return e===-7?"keep_left":e===-3?"sharp_left":e===-2?"left":e===-1?"slight_left":0===e?"continue":1===e?"slight_right":2===e?"right":3===e?"sharp_right":4===e?"marker-icon-red":5===e?"marker-icon-blue":6===e?"roundabout":7===e?"keep_right":101===e?"pt_start_trip":102===e?"pt_transfer_to":103===e?"pt_end_trip":"unknown"},module.exports.browserTitle="GraphHopper Maps - Driving Directions";
+module.exports.extractMetaVersionInfo=function(e){return metaVersionInfo="",e.data_date&&(metaVersionInfo+="<br/>Data date: "+e.data_date),e.import_date&&(metaVersionInfo+="<br/>Import date: "+e.import_date),e.prepare_date&&(metaVersionInfo+="<br/>Prepare date: "+e.prepare_date),e.version&&(metaVersionInfo+="<br/>GH version: "+e.version),e.build_date&&(metaVersionInfo+="<br/>Jar date: "+e.build_date),metaVersionInfo},module.exports.getSignName=function(e){return e===-98?"u_turn_unknown":e===-8?"u_turn_left":e===-7?"keep_left":e===-3?"sharp_left":e===-2?"left":e===-1?"slight_left":0===e?"continue":1===e?"slight_right":2===e?"right":3===e?"sharp_right":4===e?"marker-icon-red":5===e?"marker-icon-blue":6===e?"roundabout":7===e?"keep_right":8===e?"u_turn_right":101===e?"pt_start_trip":102===e?"pt_transfer_to":103===e?"pt_end_trip":"unknown"},module.exports.browserTitle="GraphHopper Maps - Driving Directions";
 
 },{}],25:[function(require,module,exports){
 function createAmbiguityList(o){o.error="",o.resolvedList=[];var n=3e3;if(o.isResolved()){var r=$.Deferred();return r.resolve([o]),r}if(o.lat&&o.lng){var t=nominatimReverseURL+"?lat="+o.lat+"&lon="+o.lng+"&format=json&zoom=16";return $.ajax({url:t,type:"GET",dataType:"json",timeout:n}).then(function(n){if(!n)return o.error="No description found for coordinate",[o];var r=n.address,t={};return t.lat=o.lat,t.lng=o.lng,t.bbox=n.boundingbox,t.positionType=n.type,t.locationDetails=format.formatLocationEntry(r),o.resolvedList.push(t),[o]},function(n){return console.log("[nominatim_reverse] Error while looking up coordinate lat="+o.lat+"&lon="+o.lng),o.error="Problem while looking up location.",[o]})}return doGeoCoding(o.input,10,n).then(function(n){if(!n||0===n.length)return o.error="No area description found",[o];var r,t=n[0].importance;for(var e in n){var i=n[e];if(t-i.importance>.4)break;if(!r||JSON.stringify(r)!==JSON.stringify(i.address)){r=i.address,t=i.importance;var a={};a.lat=mathTools.round(i.lat),a.lng=mathTools.round(i.lon),a.locationDetails=format.formatLocationEntry(r),a.bbox=i.boundingbox,a.positionType=i.type,o.resolvedList.push(a)}}if(0===o.resolvedList.length)return o.error="No area description found",[o];var s=o.resolvedList;return o.lat=s[0].lat,o.lng=s[0].lng,[o]},function(){return o.error="Problem while looking up address",[o]})}function doGeoCoding(o,n,r){n||(n=10);var t=nominatimURL+"?format=json&addressdetails=1&q="+encodeURIComponent(o)+"&limit="+n;return bounds.initialized&&(t+="&bounded=1&viewbox="+bounds.minLon+","+bounds.maxLat+","+bounds.maxLon+","+bounds.minLat),$.ajax({url:t,type:"GET",dataType:"json",timeout:r}).fail(createCallback("[nominatim] Problem while looking up location "+o))}function createCallback(o){return function(n){console.log(o+" "+JSON.stringify(n))}}function resolve(o,n){var r=$("#locationpoints > div.pointDiv").eq(o);return $(r).find(".pointFlag").hide(),$(r).find(".pointIndicator").show(),$(r).find(".pointInput").val(n.input),createAmbiguityList(n).always(function(){var o=$(r).find(".pointResolveError");return o.empty(),n.error&&(o.show(),o.text(n.error).fadeOut(5e3),n.error=""),$(r).find(".pointIndicator").hide(),$(r).find(".pointFlag").show(),n})}var nominatimURL="https://nominatim.openstreetmap.org/search",nominatimReverseURL="https://nominatim.openstreetmap.org/reverse",bounds,mathTools=require("./tools/math.js"),format=require("./tools/format.js");module.exports.resolve=resolve,module.exports.setBounds=function(o){bounds=o};
diff --git a/web/src/main/webapp/js/messages.js b/web/src/main/webapp/js/messages.js
index 9fa39c9384..fafe236e7b 100644
--- a/web/src/main/webapp/js/messages.js
+++ b/web/src/main/webapp/js/messages.js
@@ -15,9 +15,13 @@ module.exports.extractMetaVersionInfo = function (json) {
 };
 
 module.exports.getSignName = function (sign) {
-    if (sign === -7)
+    if (sign === -98)
+        return "u_turn_unknown";
+    else if (sign === -8)
+        return "u_turn_left";
+    else if (sign === -7)
         return "keep_left";
-    if (sign === -3)
+    else if (sign === -3)
         return "sharp_left";
     else if (sign === -2)
         return "left";
@@ -39,6 +43,8 @@ module.exports.getSignName = function (sign) {
         return "roundabout";
     else if (sign === 7)
         return "keep_right";
+    else if (sign === 8)
+        return "u_turn_right";
     else if (sign === 101)
         return "pt_start_trip";
     else if (sign === 102)
@@ -46,7 +52,7 @@ module.exports.getSignName = function (sign) {
     else if (sign === 103)
         return "pt_end_trip";
     else
-        // throw "did not find sign " + sign;
+    // throw "did not find sign " + sign;
         return "unknown";
 };
 
