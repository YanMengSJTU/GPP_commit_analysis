diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 16173b7636..3f0d8cba9c 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -52,7 +52,6 @@
 import com.graphhopper.util.shapes.Polygon;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
 import java.io.File;
 import java.io.IOException;
@@ -1153,7 +1152,7 @@ private RoutingTemplate buildRoutingTemplate(GHRequest request, GHResponse ghRsp
         } else if (ALT_ROUTE.equalsIgnoreCase(algoStr)) {
             routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
         } else if (validPolygonInRequest(request)) {
-            routingTemplate = new PolygonRoutingTemplate(request, ghRsp, locationIndex, this, encodingManager);
+            routingTemplate = new PolygonThroughRoutingTemplate(request, ghRsp, locationIndex, this, encodingManager);
         } else {
             routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index 9a041f760e..e01d880236 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -10,31 +10,24 @@
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Polygon;
 
-import java.util.*;
+import java.util.List;
 
-public class PolygonRoutingTemplate extends ViaRoutingTemplate {
-    private final GHRequest ghRequest;
-    private final Polygon polygon;
-    private final GraphHopper gh;
-    private final GraphHopperStorage ghStorage;
-    private final NodeAccess nodeAccess;
-    private QueryGraph queryGraph;
-    private AlgorithmOptions algorithmOptions;
-    private RoutingAlgorithmFactory algoFactory;
-    private DijkstraOneToMany dijkstraForLOTNodes;
-    private DijkstraManyToMany dijkstraForPathSkeleton;
-    private RoutingAlgorithm routingAlgorithm;
-    private RouteCandidateList routeCandidates;
+public abstract class PolygonRoutingTemplate extends ViaRoutingTemplate {
+    final GHRequest ghRequest;
+    final Polygon polygon;
+    final GraphHopper gh;
+    final GraphHopperStorage ghStorage;
+    final NodeAccess nodeAccess;
+    QueryGraph queryGraph;
+    AlgorithmOptions algorithmOptions;
+    RoutingAlgorithmFactory algoFactory;
+    RoutingAlgorithm routingAlgorithm;
+    RouteCandidateList routeCandidates;
 
     public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, GraphHopper gh,
-                                  EncodingManager encodingManager) {
+                                         EncodingManager encodingManager) {
         super(ghRequest, ghRsp, locationIndex, encodingManager);
         this.ghRequest = ghRequest;
         this.polygon = ghRequest.getPolygon();
@@ -50,177 +43,20 @@ public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationInd
         this.algorithmOptions = algoOpts;
         this.routingAlgorithm = algoFactory.createAlgo(queryGraph, algoOpts);
         this.routeCandidates = RouteCandidateList.createEmptyCandidateList();
-        this.dijkstraForLOTNodes = new DijkstraOneToMany(this.queryGraph, this.algorithmOptions.getWeighting(), this.algorithmOptions.getTraversalMode());
         return routeWithPolygon();
     }
 
-    private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
-        return !queryGraph.equals(this.queryGraph) || !algoFactory.equals(this.algoFactory) || !algoOpts.equals(this.algorithmOptions);
-    }
-
     private List<Path> routeWithPolygon() {
         this.findCandidateRoutes();
         this.pruneDominatedCandidateRoutes();
         this.pruneLowerQuantileInROIcandidateRoutes();
 
-        this.routeCandidates.sortByGainAscending();
 
         // TODO Maybe more? Dont know what happens in the gui then.
+        this.routeCandidates.sortByGainAscending();
         return this.routeCandidates.getFirstAsPathList(1, this.queryGraph, this.algorithmOptions);
     }
 
-    private void findCandidateRoutes() {
-        List<Integer> nodesInPolygon = getNodesInPolygon();
-        List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
-        List<List<Integer>> LOTNodes = findLocalOptimalTouchnodes(polygonEntryExitPoints);
-        this.dijkstraForPathSkeleton = new DijkstraManyToMany(this.queryGraph, this.algorithmOptions.getWeighting(), this.algorithmOptions.getTraversalMode(), nodesInPolygon,
-                                                              polygonEntryExitPoints);
-
-        for (int i = 0; i < LOTNodes.size() - 1; i++) {
-            lookUpStartEndNodes(i);
-            buildRouteCandidatesForCurrentPoint(LOTNodes.get(i), i);
-        }
-    }
-
-    private void buildRouteCandidatesForCurrentPoint(List<Integer> currentPointsLOTNodes, int pointsIndex) {
-        int pointInQueryResultsIndex = this.queryResults.size() - 2;
-        int currentPointID = this.queryResults.get(pointInQueryResultsIndex).getClosestNode();
-        int nextPointID = this.queryResults.get(pointInQueryResultsIndex + 1).getClosestNode();
-
-        for (final int LOTNodeL : currentPointsLOTNodes) {
-            for (final int LOTNodeLPrime : currentPointsLOTNodes) {
-                this.routeCandidates.candidates.add(buildCandidatePath(currentPointID, nextPointID, LOTNodeL, LOTNodeLPrime));
-            }
-        }
-    }
-
-    private RouteCandidate buildCandidatePath(int currentPointID, int nextPointID, int LOTNodeL, int LOTNodeLPrime) {
-        RouteCandidate routeCandidate = new RouteCandidate(this, currentPointID, nextPointID, LOTNodeL, LOTNodeLPrime);
-
-        return routeCandidate;
-    }
-
-    private void lookUpStartEndNodes(int pointsIndex) {
-        final GHPoint currentPoint = this.ghRequest.getPoints().get(pointsIndex);
-        final GHPoint nextPoint = this.ghRequest.getPoints().get(pointsIndex + 1);
-
-        List<GHPoint> LOTNodesGHPoints = Arrays.asList(currentPoint, nextPoint);
-        super.lookup(LOTNodesGHPoints, this.encodingManager.getEncoder(this.ghRequest.getVehicle()));
-    }
-
-    // Definition 6 in Storandts paper Region-Aware Routing Planning
-    private List<List<Integer>> findLocalOptimalTouchnodes(final List<Integer> polygonEntryExitPoints) {
-        // TODO: Is there an A* one to many option? Does this make sense at all?
-
-        final EdgeExplorer edgeExplorer = this.queryGraph.createEdgeExplorer();
-
-        List<QueryResult> fixedUserSpecifiedPoints = this.queryResults;
-        List<List<Integer>> LOTNodes = new ArrayList<>();
-        for (final QueryResult point : fixedUserSpecifiedPoints) {
-            makeLOTNodeListForThisPoint(polygonEntryExitPoints, edgeExplorer, LOTNodes, point);
-        }
-
-
-        return LOTNodes;
-    }
-
-    private void makeLOTNodeListForThisPoint(List<Integer> polygonEntryExitPoints, EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, QueryResult point) {
-        Map<Integer, Double> distancesToPolygonEntryExit = getDistancesFromPointToEntryExitPoints(point, polygonEntryExitPoints);
-        addEntryExitPointsCopyTo(polygonEntryExitPoints, LOTNodes);
-        for (final int entryExitPoint : LOTNodes.get(LOTNodes.size() - 1)) {
-            checkIfThisIsAValidLOTNode(edgeExplorer, LOTNodes, distancesToPolygonEntryExit, entryExitPoint);
-        }
-    }
-
-    private void checkIfThisIsAValidLOTNode(EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, Map<Integer, Double> distancesToPolygonEntryExit, int entryExitPoint) {
-        EdgeIterator neighborFinder = edgeExplorer.setBaseNode(entryExitPoint);
-        Double distanceOfThisEntryExitPointFromPoint = distancesToPolygonEntryExit.get(entryExitPoint);
-
-        boolean foundABetterLOTNode =
-                lookForNeighborsThatMakeABetterLOTNode(distancesToPolygonEntryExit, neighborFinder, distanceOfThisEntryExitPointFromPoint);
-
-        pruneThisNoteFromLOTIfBetterWasFound(LOTNodes, entryExitPoint, foundABetterLOTNode);
-    }
-
-    private void pruneThisNoteFromLOTIfBetterWasFound(List<List<Integer>> LOTNodes, int entryExitPoint, boolean foundABetterLOTNode) {
-        if (foundABetterLOTNode) {
-            LOTNodes.get(LOTNodes.size() - 1).remove(entryExitPoint);
-        }
-    }
-
-    private boolean lookForNeighborsThatMakeABetterLOTNode(Map<Integer, Double> distancesToPolygonEntryExit, EdgeIterator neighborFinder,
-                                                           Double distanceOfThisEntryExitPointFromPoint) {
-        boolean foundABetterLOTNode = false;
-        do {
-            foundABetterLOTNode = foundABetterLOTNode(distancesToPolygonEntryExit, neighborFinder, distanceOfThisEntryExitPointFromPoint);
-        }
-        while (neighborFinder.next() && !foundABetterLOTNode);
-        return foundABetterLOTNode;
-    }
-
-    private boolean foundABetterLOTNode(Map<Integer, Double> distancesToPolygonEntryExit, EdgeIterator neighborFinder, Double distanceOfThisEntryExitPointFromPoint) {
-        final int currentNeighbor = neighborFinder.getAdjNode();
-        Double distanceOfNeighborFromPoint = distancesToPolygonEntryExit.get(currentNeighbor);
-        if (distanceOfNeighborFromPoint != null) {
-            if (distanceOfNeighborFromPoint < distanceOfThisEntryExitPointFromPoint) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void addEntryExitPointsCopyTo(List<Integer> polygonEntryExitPoints, List<List<Integer>> LOTNodes) {
-        int index = LOTNodes.size();
-        LOTNodes.add(index, (ArrayList<Integer>) ((ArrayList<Integer>) polygonEntryExitPoints).clone());
-    }
-
-    private Map<Integer, Double> getDistancesFromPointToEntryExitPoints(QueryResult point, List<Integer> polygonEntryExitPoints) {
-        final Map<Integer, Double> weightsOfEntryExitPoints = new HashMap<Integer, Double>();
-        for (final int entryExitPoint : polygonEntryExitPoints) {
-            this.dijkstraForLOTNodes.calcPath(point.getClosestNode(), entryExitPoint);
-            weightsOfEntryExitPoints.put(entryExitPoint, this.dijkstraForLOTNodes.getWeight(entryExitPoint));
-        }
-
-        return weightsOfEntryExitPoints;
-    }
-
-    private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
-        final List<Integer> entryExitPoints = new LinkedList<>();
-        final EdgeExplorer edgeExplorer = ghStorage.getBaseGraph().createEdgeExplorer();
-
-        addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(nodesInPolygon, entryExitPoints, edgeExplorer);
-
-        return entryExitPoints;
-    }
-
-    private void addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeExplorer edgeExplorer) {
-        for (int node : nodesInPolygon) {
-            final EdgeIterator edgeIterator = edgeExplorer.setBaseNode(node);
-
-            do {
-                addToEntryExitIfNotExistentAndNotInPolygon(nodesInPolygon, entryExitPoints, edgeIterator);
-            }
-            while (edgeIterator.next());
-        }
-    }
-
-    private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeIterator edgeIterator) {
-        final int adjacentNode = edgeIterator.getAdjNode();
-        if (!nodesInPolygon.contains(adjacentNode) && !entryExitPoints.contains(adjacentNode)) {
-            entryExitPoints.add(adjacentNode);
-        }
-    }
-
-    private List<Integer> getNodesInPolygon() {
-        final Polygon polygon = this.getGhRequest().getPolygon();
-        final NodeAccess nodeAccess = gh.getGraphHopperStorage().getNodeAccess();
-
-        BBox minimumPolygonBoundingBox = BBox.createMinimalBoundingBoxFromPolygon(polygon);
-        final NodesInPolygonFindingVisitor visitor = new NodesInPolygonFindingVisitor(polygon, nodeAccess);
-        this.gh.getLocationIndex().query(minimumPolygonBoundingBox, visitor);
-        return visitor.getNodesInPolygon();
-    }
-
     // Do it in a skyline problem pruning fashion
     private void pruneDominatedCandidateRoutes() {
         this.routeCandidates.sortRouteCandidatesToDistanceInROIDescending();
@@ -276,37 +112,5 @@ private void pruneLowerQuantileInROIcandidateRoutes() {
         }
     }
 
-    public RoutingAlgorithm getRoutingAlgorithm() {
-        return this.routingAlgorithm;
-    }
-
-    public DijkstraManyToMany getPathSkeletonRouter() {
-        return this.dijkstraForPathSkeleton;
-    }
-
-    private class NodesInPolygonFindingVisitor extends LocationIndex.Visitor {
-        private final List<Integer> nodesInPolygon = new LinkedList<>();
-        private final Polygon polygon;
-        private final NodeAccess nodeAccess;
-
-        public NodesInPolygonFindingVisitor(final Polygon polygon, final NodeAccess nodeAccess) {
-            this.polygon = polygon;
-            this.nodeAccess = nodeAccess;
-        }
-
-        @Override
-        public void onNode(int nodeId) {
-            final double lat = nodeAccess.getLat(nodeId);
-            final double lon = nodeAccess.getLon(nodeId);
-
-            if (polygon.contains(lat, lon)) {
-                this.nodesInPolygon.add(nodeId);
-            }
-        }
-
-        public List<Integer> getNodesInPolygon() {
-            return this.nodesInPolygon;
-        }
-    }
-
+    abstract RouteCandidateList findCandidateRoutes();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
index 8614229d8c..4c1d79447b 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingUtil/RouteCandidate.java
@@ -1,7 +1,7 @@
 package com.graphhopper.routing.template.PolygonRoutingUtil;
 
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.template.PolygonRoutingTemplate;
+import com.graphhopper.routing.template.PolygonThroughRoutingTemplate;
 
 /**
  * A route candidate as in Prof. Dr. Sabine Storandts Paper Region-Aware Route Planning.
@@ -11,12 +11,12 @@
     private final Path polygonEntryToPolygonExit;
     private final Path polygonExitToEnd;
     private final Path directRouteStartEnd;
-    private final PolygonRoutingTemplate polygonRoutingTemplate;
+    private final PolygonThroughRoutingTemplate polygonRoutingTemplate;
     private final RoutingAlgorithm routingAlgorithm;
     private final DijkstraManyToMany pathSkeletonRouter;
     private final double distance;
 
-    public RouteCandidate(final PolygonRoutingTemplate polygonRoutingTemplate, final int startNodeID, final int endNodeID, final int polygonEntryNodeID,
+    public RouteCandidate(final PolygonThroughRoutingTemplate polygonRoutingTemplate, final int startNodeID, final int endNodeID, final int polygonEntryNodeID,
                           final int polygonExitNodeID) {
         this.polygonRoutingTemplate = polygonRoutingTemplate;
         this.routingAlgorithm = polygonRoutingTemplate.getRoutingAlgorithm();
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
new file mode 100644
index 0000000000..c93797e522
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -0,0 +1,223 @@
+package com.graphhopper.routing.template;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidate;
+import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidateList;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.Polygon;
+
+import java.util.*;
+
+public class PolygonThroughRoutingTemplate extends PolygonRoutingTemplate {
+    private DijkstraOneToMany dijkstraForLOTNodes;
+    private DijkstraManyToMany dijkstraForPathSkeleton;
+
+    public PolygonThroughRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, GraphHopper gh,
+                                         EncodingManager encodingManager) {
+        super(ghRequest, ghRsp, locationIndex, gh, encodingManager);
+    }
+
+    private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
+        return !queryGraph.equals(this.queryGraph) || !algoFactory.equals(this.algoFactory) || !algoOpts.equals(this.algorithmOptions);
+    }
+
+    RouteCandidateList findCandidateRoutes() {
+        List<Integer> nodesInPolygon = getNodesInPolygon();
+        List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
+        List<List<Integer>> LOTNodes = findLocalOptimalTouchnodes(polygonEntryExitPoints);
+        this.dijkstraForPathSkeleton = new DijkstraManyToMany(this.queryGraph, this.algorithmOptions.getWeighting(), this.algorithmOptions.getTraversalMode(), nodesInPolygon,
+                                                              polygonEntryExitPoints);
+
+        for (int i = 0; i < LOTNodes.size() - 1; i++) {
+            lookUpStartEndNodes(i);
+            buildRouteCandidatesForCurrentPoint(LOTNodes.get(i), i);
+        }
+
+        return this.routeCandidates;
+    }
+
+    private void buildRouteCandidatesForCurrentPoint(List<Integer> currentPointsLOTNodes, int pointsIndex) {
+        int pointInQueryResultsIndex = this.queryResults.size() - 2;
+        int currentPointID = this.queryResults.get(pointInQueryResultsIndex).getClosestNode();
+        int nextPointID = this.queryResults.get(pointInQueryResultsIndex + 1).getClosestNode();
+
+        for (final int LOTNodeL : currentPointsLOTNodes) {
+            for (final int LOTNodeLPrime : currentPointsLOTNodes) {
+                this.routeCandidates.candidates.add(buildCandidatePath(currentPointID, nextPointID, LOTNodeL, LOTNodeLPrime));
+            }
+        }
+    }
+
+    private RouteCandidate buildCandidatePath(int currentPointID, int nextPointID, int LOTNodeL, int LOTNodeLPrime) {
+        RouteCandidate routeCandidate = new RouteCandidate(this, currentPointID, nextPointID, LOTNodeL, LOTNodeLPrime);
+
+        return routeCandidate;
+    }
+
+    private void lookUpStartEndNodes(int pointsIndex) {
+        final GHPoint currentPoint = this.ghRequest.getPoints().get(pointsIndex);
+        final GHPoint nextPoint = this.ghRequest.getPoints().get(pointsIndex + 1);
+
+        List<GHPoint> LOTNodesGHPoints = Arrays.asList(currentPoint, nextPoint);
+        super.lookup(LOTNodesGHPoints, this.encodingManager.getEncoder(this.ghRequest.getVehicle()));
+    }
+
+    // Definition 6 in Storandts paper Region-Aware Routing Planning
+    private List<List<Integer>> findLocalOptimalTouchnodes(final List<Integer> polygonEntryExitPoints) {
+        // TODO: Is there an A* one to many option? Does this make sense at all?
+
+        final EdgeExplorer edgeExplorer = this.queryGraph.createEdgeExplorer();
+
+        List<QueryResult> fixedUserSpecifiedPoints = this.queryResults;
+        List<List<Integer>> LOTNodes = new ArrayList<>();
+        for (final QueryResult point : fixedUserSpecifiedPoints) {
+            makeLOTNodeListForThisPoint(polygonEntryExitPoints, edgeExplorer, LOTNodes, point);
+        }
+
+
+        return LOTNodes;
+    }
+
+    private void makeLOTNodeListForThisPoint(List<Integer> polygonEntryExitPoints, EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, QueryResult point) {
+        Map<Integer, Double> distancesToPolygonEntryExit = getDistancesFromPointToEntryExitPoints(point, polygonEntryExitPoints);
+        addEntryExitPointsCopyTo(polygonEntryExitPoints, LOTNodes);
+        for (final int entryExitPoint : LOTNodes.get(LOTNodes.size() - 1)) {
+            checkIfThisIsAValidLOTNode(edgeExplorer, LOTNodes, distancesToPolygonEntryExit, entryExitPoint);
+        }
+    }
+
+    private void checkIfThisIsAValidLOTNode(EdgeExplorer edgeExplorer, List<List<Integer>> LOTNodes, Map<Integer, Double> distancesToPolygonEntryExit, int entryExitPoint) {
+        EdgeIterator neighborFinder = edgeExplorer.setBaseNode(entryExitPoint);
+        Double distanceOfThisEntryExitPointFromPoint = distancesToPolygonEntryExit.get(entryExitPoint);
+
+        boolean foundABetterLOTNode =
+                lookForNeighborsThatMakeABetterLOTNode(distancesToPolygonEntryExit, neighborFinder, distanceOfThisEntryExitPointFromPoint);
+
+        pruneThisNoteFromLOTIfBetterWasFound(LOTNodes, entryExitPoint, foundABetterLOTNode);
+    }
+
+    private void pruneThisNoteFromLOTIfBetterWasFound(List<List<Integer>> LOTNodes, int entryExitPoint, boolean foundABetterLOTNode) {
+        if (foundABetterLOTNode) {
+            LOTNodes.get(LOTNodes.size() - 1).remove(entryExitPoint);
+        }
+    }
+
+    private boolean lookForNeighborsThatMakeABetterLOTNode(Map<Integer, Double> distancesToPolygonEntryExit, EdgeIterator neighborFinder,
+                                                           Double distanceOfThisEntryExitPointFromPoint) {
+        boolean foundABetterLOTNode = false;
+        do {
+            foundABetterLOTNode = foundABetterLOTNode(distancesToPolygonEntryExit, neighborFinder, distanceOfThisEntryExitPointFromPoint);
+        }
+        while (neighborFinder.next() && !foundABetterLOTNode);
+        return foundABetterLOTNode;
+    }
+
+    private boolean foundABetterLOTNode(Map<Integer, Double> distancesToPolygonEntryExit, EdgeIterator neighborFinder, Double distanceOfThisEntryExitPointFromPoint) {
+        final int currentNeighbor = neighborFinder.getAdjNode();
+        Double distanceOfNeighborFromPoint = distancesToPolygonEntryExit.get(currentNeighbor);
+        if (distanceOfNeighborFromPoint != null) {
+            if (distanceOfNeighborFromPoint < distanceOfThisEntryExitPointFromPoint) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void addEntryExitPointsCopyTo(List<Integer> polygonEntryExitPoints, List<List<Integer>> LOTNodes) {
+        int index = LOTNodes.size();
+        LOTNodes.add(index, (ArrayList<Integer>) ((ArrayList<Integer>) polygonEntryExitPoints).clone());
+    }
+
+    private Map<Integer, Double> getDistancesFromPointToEntryExitPoints(QueryResult point, List<Integer> polygonEntryExitPoints) {
+        final Map<Integer, Double> weightsOfEntryExitPoints = new HashMap<Integer, Double>();
+        for (final int entryExitPoint : polygonEntryExitPoints) {
+            this.dijkstraForLOTNodes.calcPath(point.getClosestNode(), entryExitPoint);
+            weightsOfEntryExitPoints.put(entryExitPoint, this.dijkstraForLOTNodes.getWeight(entryExitPoint));
+        }
+
+        return weightsOfEntryExitPoints;
+    }
+
+    private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
+        this.dijkstraForLOTNodes = new DijkstraOneToMany(this.queryGraph, this.algorithmOptions.getWeighting(), this.algorithmOptions.getTraversalMode());
+        final List<Integer> entryExitPoints = new LinkedList<>();
+        final EdgeExplorer edgeExplorer = ghStorage.getBaseGraph().createEdgeExplorer();
+
+        addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(nodesInPolygon, entryExitPoints, edgeExplorer);
+
+        return entryExitPoints;
+    }
+
+    private void addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeExplorer edgeExplorer) {
+        for (int node : nodesInPolygon) {
+            final EdgeIterator edgeIterator = edgeExplorer.setBaseNode(node);
+
+            do {
+                addToEntryExitIfNotExistentAndNotInPolygon(nodesInPolygon, entryExitPoints, edgeIterator);
+            }
+            while (edgeIterator.next());
+        }
+    }
+
+    private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeIterator edgeIterator) {
+        final int adjacentNode = edgeIterator.getAdjNode();
+        if (!nodesInPolygon.contains(adjacentNode) && !entryExitPoints.contains(adjacentNode)) {
+            entryExitPoints.add(adjacentNode);
+        }
+    }
+
+    private List<Integer> getNodesInPolygon() {
+        final Polygon polygon = this.getGhRequest().getPolygon();
+        final NodeAccess nodeAccess = gh.getGraphHopperStorage().getNodeAccess();
+
+        BBox minimumPolygonBoundingBox = BBox.createMinimalBoundingBoxFromPolygon(polygon);
+        final NodesInPolygonFindingVisitor visitor = new NodesInPolygonFindingVisitor(polygon, nodeAccess);
+        this.gh.getLocationIndex().query(minimumPolygonBoundingBox, visitor);
+        return visitor.getNodesInPolygon();
+    }
+
+    public RoutingAlgorithm getRoutingAlgorithm() {
+        return this.routingAlgorithm;
+    }
+
+    public DijkstraManyToMany getPathSkeletonRouter() {
+        return this.dijkstraForPathSkeleton;
+    }
+
+    private class NodesInPolygonFindingVisitor extends LocationIndex.Visitor {
+        private final List<Integer> nodesInPolygon = new LinkedList<>();
+        private final Polygon polygon;
+        private final NodeAccess nodeAccess;
+
+        public NodesInPolygonFindingVisitor(final Polygon polygon, final NodeAccess nodeAccess) {
+            this.polygon = polygon;
+            this.nodeAccess = nodeAccess;
+        }
+
+        @Override
+        public void onNode(int nodeId) {
+            final double lat = nodeAccess.getLat(nodeId);
+            final double lon = nodeAccess.getLon(nodeId);
+
+            if (polygon.contains(lat, lon)) {
+                this.nodesInPolygon.add(nodeId);
+            }
+        }
+
+        public List<Integer> getNodesInPolygon() {
+            return this.nodesInPolygon;
+        }
+    }
+
+}
