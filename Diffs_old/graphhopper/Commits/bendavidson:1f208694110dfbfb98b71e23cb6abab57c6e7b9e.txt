diff --git a/NOTICE.md b/NOTICE.md
index 85b2bf59be..0a6ba1f912 100644
--- a/NOTICE.md
+++ b/NOTICE.md
@@ -15,6 +15,9 @@ The core product includes the following software
 tools
  * apache-compress
 
+tools-lgpl
+ * tools from OpenTripPlanner licensed under LGPL
+
 web
  * org.json, MIT style license
  * com.google.inject, Apache License 2.0
diff --git a/android/app/build.gradle b/android/app/build.gradle
index 8c1da116eb..9e494eba0a 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -1,8 +1,8 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 22
-    buildToolsVersion "23.0.1"
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
 
     defaultConfig {
         applicationId "com.graphhopper.android"
diff --git a/android/app/project.properties b/android/app/project.properties
index 00cf62bacc..916037e334 100644
--- a/android/app/project.properties
+++ b/android/app/project.properties
@@ -11,4 +11,4 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-22
+target=android-23
diff --git a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
index becd0e6280..e5fdcda78f 100644
--- a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
+++ b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
@@ -1,19 +1,6 @@
 package com.graphhopper.android;
 
 import com.graphhopper.util.Downloader;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.ProgressListener;
-import com.graphhopper.util.Unzipper;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.DefaultHttpClient;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
 
 public class AndroidDownloader extends Downloader
 {
@@ -21,47 +8,4 @@ public AndroidDownloader()
     {
         super("GraphHopper Android");
     }
-
-    @Override
-    public void downloadAndUnzip( String url, String toFolder, final ProgressListener progressListener ) throws IOException
-    {
-        HttpEntity entity = getEntity(url);
-        InputStream iStream = entity.getContent();
-        final long length = entity.getContentLength();
-
-        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
-        {
-            @Override
-            public void update( long sumBytes )
-            {
-                progressListener.update((int) (100 * sumBytes / length));
-            }
-        });
-    }
-
-    private HttpEntity getEntity( String url )
-    {
-        // there is something broken with HTTPS and Android HttpURLConnection
-        HttpClient httpclient = new DefaultHttpClient();
-        HttpGet httpget = new HttpGet(url);
-        try
-        {
-            HttpResponse response = httpclient.execute(httpget);
-            HttpEntity entity = response.getEntity();
-            if (entity == null)
-                throw new RuntimeException("no entity for URL " + url);
-
-            return entity;
-
-        } catch (Exception ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
-
-    @Override
-    public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
-    {
-        return Helper.isToString(getEntity(url).getContent());
-    }
 }
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index d846fd1d9c..1fd5d7e614 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -72,7 +72,7 @@
     private volatile boolean prepareInProgress = false;
     private volatile boolean shortestPathRunning = false;
     private String currentArea = "berlin";
-    private String fileListURL = "https://graphhopper.com/public/maps/0.6/";
+    private String fileListURL = "http://download2.graphhopper.com/public/maps/0.6/";
     private String prefixURL = fileListURL;
     private String downloadURL;
     private File mapsFolder;
@@ -265,17 +265,18 @@ private void chooseAreaFromRemote()
             @Override
             protected void onPostExecute( List<String> nameList )
             {
-                if (nameList.isEmpty())
-                {
-                    logUser("No maps created for your version!? " + fileListURL);
-                    return;
-                } else if (hasError())
+                if (hasError())
                 {
                     getError().printStackTrace();
                     logUser("Are you connected to the internet? Problem while fetching remote area list: "
                             + getErrorMessage());
                     return;
+                } else if (nameList == null || nameList.isEmpty())
+                {
+                    logUser("No maps created for your version!? " + fileListURL);
+                    return;
                 }
+
                 MySpinnerListener spinnerListener = new MySpinnerListener()
                 {
                     @Override
@@ -409,13 +410,13 @@ void loadMap( File areaFolder )
 
         tileRendererLayer = new TileRendererLayer(tileCache, mapDataStore,
                 mapView.getModel().mapViewPosition, false, true, AndroidGraphicFactory.INSTANCE)
-        {
-            @Override
-            public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
-            {
-                return onMapTap(tapLatLong, layerXY, tapXY);
-            }
-        };
+                {
+                    @Override
+                    public boolean onLongPress( LatLong tapLatLong, Point layerXY, Point tapXY )
+                    {
+                        return onMapTap(tapLatLong, layerXY, tapXY);
+                    }
+                };
         tileRendererLayer.setTextScale(1.5f);
         tileRendererLayer.setXmlRenderTheme(InternalRenderTheme.OSMARENDER);
         mapView.getModel().mapViewPosition.setMapPosition(new MapPosition(mapDataStore.boundingBox().getCenterPoint(), (byte) 15));
@@ -466,9 +467,9 @@ private Polyline createPolyline( GHResponse response )
         paintStroke.setStyle(Style.STROKE);
         paintStroke.setColor(Color.argb(128, 0, 0xCC, 0x33));
         paintStroke.setDashPathEffect(new float[]
-                {
-                        25, 15
-                });
+        {
+            25, 15
+        });
         paintStroke.setStrokeWidth(8);
 
         Polyline line = new Polyline((org.mapsforge.core.graphics.Paint) paintStroke, AndroidGraphicFactory.INSTANCE);
diff --git a/android/build.gradle b/android/build.gradle
index 01a9b3f3f9..f3c1da8514 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -4,7 +4,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.3.1'
+        classpath 'com.android.tools.build:gradle:1.5.0'
     }
 }
 
diff --git a/android/gradle/wrapper/gradle-wrapper.jar b/android/gradle/wrapper/gradle-wrapper.jar
index 8c0fb64a86..05ef575b0c 100644
Binary files a/android/gradle/wrapper/gradle-wrapper.jar and b/android/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index e7faee01a4..f23df6e463 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Apr 10 15:27:10 PDT 2013
+#Wed Oct 21 11:34:03 PDT 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-all.zip
diff --git a/android/gradlew b/android/gradlew
index 91a7e269e1..9d82f78915 100755
--- a/android/gradlew
+++ b/android/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -61,9 +56,9 @@ while [ -h "$PRG" ] ; do
     fi
 done
 SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
+cd "`dirname \"$PRG\"`/" >/dev/null
 APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
+cd "$SAVED" >/dev/null
 
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/config-example.properties b/config-example.properties
index ec4752d466..c4af6a09dc 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -29,7 +29,7 @@ graph.flagEncoders=car
 # MMAP_STORE_SYNC could be used otherwise but will be a lot slower
 graph.dataaccess=RAM_STORE
 
-# if you want to reduce storage size and you don't need instructions for the resulting path use:
+# if you don't need turn instruction, you can reduce storage size by not storing way names:
 # osmreader.instructions=false
 
 # will write way names in the preferred language (language code as defined in ISO 639-1 or ISO 639-2):
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 2783a49d6f..e7a5d40f90 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,5 @@
 0.6
+    moving lgpl licensed file into own submodule graphhopper-tools-lgpl
     renaming of Tarjans algorithm class to TarjansSCCAlgorithm
     more strict naming for Weighting enforced and more strict matching to select Weighting (equals check), #490
     specify the preferred-language for way names during graph import (ISO 639-1 or ISO 639-2)
diff --git a/core/pom.xml b/core/pom.xml
index 4c29c2ef10..34c78835ac 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -36,8 +36,13 @@
         </license>
     </licenses> 
     <dependencies>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-tools-lgpl</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
         
-        <!-- Trove is LGPL and slightly big (~3MB) -->
+        <!-- Trove is LGPL and slightly big (~3MB) -->        
         <dependency>
             <groupId>net.sf.trove4j</groupId>
             <artifactId>trove4j</artifactId>
diff --git a/core/src/main/java/com/graphhopper/coll/BigLongIntMap.java b/core/src/main/java/com/graphhopper/coll/BigLongIntMap.java
deleted file mode 100644
index 58f79ab968..0000000000
--- a/core/src/main/java/com/graphhopper/coll/BigLongIntMap.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.coll;
-
-import com.graphhopper.util.Helper;
-import gnu.trove.map.hash.TLongIntHashMap;
-
-/**
- * Segmented HashMap to make it possible to store more than Integer.MAX values.
- * <p>
- * @author Peter Karich
- */
-public class BigLongIntMap implements LongIntMap
-{
-    private TLongIntHashMap[] maps;
-//    private MyLongIntHashMap[] maps;
-
-    public BigLongIntMap( long maxSize, int noNumber )
-    {
-        this(maxSize, Math.max(1, (int) (maxSize / 10000000)), noNumber);
-    }
-
-    public BigLongIntMap( long maxSize, int minSegments, int noNumber )
-    {
-        if (maxSize < 0)
-        {
-            throw new IllegalArgumentException("Maximum size illegal " + maxSize);
-        }
-        if (minSegments < 1)
-        {
-            throw new IllegalArgumentException("Minimun segment number illegal " + minSegments);
-        }
-        minSegments = Math.max((int) (maxSize / Integer.MAX_VALUE), minSegments);
-        maps = new TLongIntHashMap[minSegments];
-        int size = (int) (maxSize / minSegments) + 1;
-        for (int i = 0; i < maps.length; i++)
-        {
-            maps[i] = new TLongIntHashMap(size, 1.4f, noNumber, noNumber);
-        }
-    }
-
-    @Override
-    public int put( long key, int value )
-    {
-        int segment = Math.abs((int) ((key >> 32) ^ key)) % maps.length;
-        return maps[segment].put(key, value);
-    }
-
-    @Override
-    public int get( long key )
-    {
-        int segment = Math.abs((int) ((key >> 32) ^ key)) % maps.length;
-        return maps[segment].get(key);
-    }
-
-    public long getCapacity()
-    {
-        long cap = 0;
-        for (int i = 0; i < maps.length; i++)
-        {
-            cap += maps[i].capacity();
-        }
-        return cap;
-    }
-
-    @Override
-    public long getSize()
-    {
-        long size = 0;
-        for (int i = 0; i < maps.length; i++)
-        {
-            size += maps[i].size();
-        }
-        return size;
-    }
-
-    @Override
-    public String toString()
-    {
-        String str = "";
-        for (int i = 0; i < maps.length; i++)
-        {
-            str += Helper.nf(maps[i].size()) + ", ";
-        }
-        return str;
-    }
-
-    public void clear()
-    {
-        for (int i = 0; i < maps.length; i++)
-        {
-            maps[i].clear();
-        }
-    }
-
-    /**
-     * memory usage in MB
-     */
-    @Override
-    public int getMemoryUsage()
-    {
-        return Math.round(getCapacity() * (8 + 4 + 1) / Helper.MB);
-    }
-
-    @Override
-    public void optimize()
-    {
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java b/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java
index 76ec7291cf..415966e26d 100644
--- a/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java
+++ b/core/src/main/java/com/graphhopper/coll/IntDoubleBinHeap.java
@@ -1,309 +1,33 @@
-/* This program is free software: you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public License
- as published by the Free Software Foundation, either version 3 of
- the License, or (at your option) any later version.
-
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>. */
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package com.graphhopper.coll;
 
-import java.util.Arrays;
-
 /**
- * Taken from opentripplanner.
+ * @author Peter Karich
  */
-public class IntDoubleBinHeap implements BinHeapWrapper<Number, Integer>
+public class IntDoubleBinHeap extends OTPIntDoubleBinHeap implements BinHeapWrapper<Number, Integer>
 {
-    private static final double GROW_FACTOR = 2.0;
-    private float[] keys;
-    private int[] elem;
-    private int size;
-    private int capacity;
-
     public IntDoubleBinHeap()
     {
-        this(1000);
     }
 
     public IntDoubleBinHeap( int capacity )
     {
-        if (capacity < 10)
-        {
-            capacity = 10;
-        }
-        this.capacity = capacity;
-        size = 0;
-        elem = new int[capacity + 1];
-        // 1-based indexing
-        keys = new float[capacity + 1];
-        // set sentinel
-        keys[0] = Float.NEGATIVE_INFINITY;
-    }
-
-    @Override
-    public int getSize()
-    {
-        return size;
-    }
-
-    public int size()
-    {
-        return size;
-    }
-
-    @Override
-    public boolean isEmpty()
-    {
-        return size == 0;
-    }
-
-    @Override
-    public Double peekKey()
-    {
-        return peek_key();
-    }
-
-    public double peek_key()
-    {
-        if (size > 0)
-        {
-            return keys[1];
-        } else
-        {
-            throw new IllegalStateException("An empty queue does not have a minimum key.");
-        }
-    }
-
-    @Override
-    public Integer peekElement()
-    {
-        return peek_element();
-    }
-
-    public int peek_element()
-    {
-        if (size > 0)
-        {
-            return elem[1];
-        } else
-        {
-            throw new IllegalStateException("An empty queue does not have a minimum value.");
-        }
-    }
-
-    @Override
-    public Integer pollElement()
-    {
-        return poll_element();
-    }
-
-    public int poll_element()
-    {
-        int i, child;
-        int minElem = elem[1];
-        int lastElem = elem[size];
-        double lastPrio = keys[size];
-        if (size <= 0)
-        {
-            throw new IllegalStateException("An empty queue does not have a minimum value.");
-        }
-        size -= 1;
-        for (i = 1; i * 2 <= size; i = child)
-        {
-            child = i * 2;
-            if (child != size && keys[child + 1] < keys[child])
-            {
-                child++;
-            }
-            if (lastPrio > keys[child])
-            {
-                elem[i] = elem[child];
-                keys[i] = keys[child];
-            } else
-            {
-                break;
-            }
-        }
-        elem[i] = lastElem;
-        keys[i] = (float) lastPrio;
-        return minElem;
-    }
-
-    @Override
-    public void update( Number key, Integer element )
-    {
-        update_(key.doubleValue(), element);
-    }
-
-    public boolean update_( double key, int element )
-    {
-        // Perform "inefficient" but straightforward linear search 
-        // for an element then change its key by sifting up or down
-        int i;
-        for (i = 1; i <= size; i++)
-        {
-            if (elem[i] == element)
-            {
-                break;
-            }
-        }
-        if (i > size)
-        {
-            return false;
-        }
-
-        if (key > keys[i])
-        {
-            // sift up (as in extract)
-            while (i * 2 <= size)
-            {
-                int child = i * 2;
-                if (child != size && keys[child + 1] < keys[child])
-                {
-                    child++;
-                }
-                if (key > keys[child])
-                {
-                    elem[i] = elem[child];
-                    keys[i] = keys[child];
-                    i = child;
-                } else
-                {
-                    break;
-                }
-            }
-            elem[i] = element;
-            keys[i] = (float) key;
-        } else
-        {
-            // sift down (as in insert_)
-            while (keys[i / 2] > key)
-            {
-                elem[i] = elem[i / 2];
-                keys[i] = keys[i / 2];
-                i /= 2;
-            }
-            elem[i] = element;
-            keys[i] = (float) key;
-        }
-        return true;
-    }
-
-    @Override
-    public void insert( Number key, Integer element )
-    {
-        insert_(key.doubleValue(), element);
-    }
-
-    public void insert_( double key, int element )
-    {
-        int i;
-        size += 1;
-        if (size > capacity)
-        {
-            ensureCapacity((int) (capacity * GROW_FACTOR));
-        }
-        for (i = size; keys[i / 2] > key; i /= 2)
-        {
-            elem[i] = elem[i / 2];
-            keys[i] = keys[i / 2];
-        }
-        elem[i] = element;
-        keys[i] = (float) key;
-    }
-
-    @Override
-    public void ensureCapacity( int capacity )
-    {
-        // System.out.println("Growing queue to " + capacity);
-        if (capacity < size)
-        {
-            throw new IllegalStateException("BinHeap contains too many elements to fit in new capacity.");
-        }
-        this.capacity = capacity;
-        keys = Arrays.copyOf(keys, capacity + 1);
-        elem = Arrays.copyOf(elem, capacity + 1);
-    }
-
-    public int getCapacity()
-    {
-        return capacity;
-    }
-
-    float getKey( int index )
-    {
-        return keys[index];
-    }
-
-    int getElement( int index )
-    {
-        return elem[index];
-    }
-
-    void set( int index, float key, int element )
-    {
-        keys[index] = key;
-        elem[index] = element;
-    }
-
-    void trimTo( int toSize )
-    {
-        this.size = toSize;
-        toSize++;
-        // necessary?
-        Arrays.fill(keys, toSize, size + 1, 0f);
-        Arrays.fill(elem, toSize, size + 1, 0);
-    }
-
-    @Override
-    public void clear()
-    {
-        trimTo(0);
-    }
-
-    @Override
-    public String toString()
-    {
-        StringBuilder sb = new StringBuilder();
-        for (int i = 1; i <= size; i++)
-        {
-            if (i > 1)
-            {
-                sb.append(", ");
-            }
-            sb.append(keys[i]).append(":").append(elem[i]);
-        }
-        return sb.toString();
-    }
-
-    public String toKeyString()
-    {
-        StringBuilder sb = new StringBuilder();
-        for (int i = 1; i <= size; i++)
-        {
-            if (i > 1)
-            {
-                sb.append(", ");
-            }
-            sb.append(keys[i]);
-        }
-        return sb.toString();
-    }
-
-    public int indexOfValue( int value )
-    {
-        for (int i = 0; i <= size; i++)
-        {
-            if (elem[i] == value)
-            {
-                return i;
-            }
-        }
-        return -1;
+        super(capacity);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java b/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
deleted file mode 100644
index 693149ee47..0000000000
--- a/core/src/main/java/com/graphhopper/coll/OSMIDSegmentedMap.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.coll;
-
-import com.graphhopper.storage.VLongStorage;
-import com.graphhopper.util.Helper;
-
-import java.util.Arrays;
-
-/**
- * This is a special purpose map for writing increasing OSM IDs with consecutive values. It stores
- * the keys in vlong format and values are determined by the resulting index.
- * <p>
- * @author Peter Karich
- */
-public class OSMIDSegmentedMap implements LongIntMap
-{
-    private int bucketSize;
-    private long[] keys;
-    private VLongStorage[] buckets;
-    private long lastKey = -1;
-    private long lastValue = -1;
-    private int currentBucket = 0;
-    private int currentIndex = -1;
-    private long size;
-
-    public OSMIDSegmentedMap()
-    {
-        this(100, 10);
-    }
-
-    public OSMIDSegmentedMap( int initialCapacity, int maxEntryPerBucket )
-    {
-        this.bucketSize = maxEntryPerBucket;
-        int cap = initialCapacity / bucketSize;
-        keys = new long[cap];
-        buckets = new VLongStorage[cap];
-    }
-
-    public void write( long key )
-    {
-        if (key <= lastKey)
-        {
-            throw new IllegalStateException("Not supported: key " + key + " is lower than last one " + lastKey);
-        }
-
-        currentIndex++;
-        if (currentIndex >= bucketSize)
-        {
-            currentBucket++;
-            currentIndex = 0;
-        }
-
-        if (currentBucket >= buckets.length)
-        {
-            int cap = (int) (currentBucket * 1.5f);
-            buckets = Arrays.copyOf(buckets, cap);
-            keys = Arrays.copyOf(keys, cap);
-        }
-
-        if (buckets[currentBucket] == null)
-        {
-            keys[currentBucket] = key;
-            if (currentBucket > 0)
-            {
-                buckets[currentBucket - 1].trimToSize();
-            }
-            buckets[currentBucket] = new VLongStorage(bucketSize);
-        } else
-        {
-            long delta = key - lastKey;
-            buckets[currentBucket].writeVLong(delta);
-        }
-
-        size++;
-        lastKey = key;
-    }
-
-    @Override
-    public int get( long key )
-    {
-        int retBucket = SparseLongLongArray.binarySearch(keys, 0, currentBucket + 1, key);
-        if (retBucket < 0)
-        {
-            retBucket = ~retBucket;
-            retBucket--;
-            if (retBucket < 0)
-            {
-                return (int) getNoEntryValue();
-            }
-
-            long storedKey = keys[retBucket];
-            if (storedKey == key)
-            {
-                return retBucket * bucketSize;
-            }
-
-            VLongStorage buck = buckets[retBucket];
-            long tmp = buck.getPosition();
-            buck.seek(0);
-            int max = currentBucket == retBucket ? currentIndex + 1 : bucketSize;
-            int ret = getNoEntryValue();
-            for (int i = 1; i < max; i++)
-            {
-                storedKey += buck.readVLong();
-                if (storedKey == key)
-                {
-                    ret = retBucket * bucketSize + i;
-                    break;
-                } else if (storedKey > key)
-                {
-                    break;
-                }
-            }
-            buck.seek(tmp);
-            return ret;
-        }
-
-        return retBucket * bucketSize;
-    }
-
-    public int getNoEntryValue()
-    {
-        return -1;
-    }
-
-    @Override
-    public long getSize()
-    {
-        return size;
-    }
-
-    @Override
-    public void optimize()
-    {
-    }
-
-    @Override
-    public int getMemoryUsage()
-    {
-        long bytes = 0;
-        for (int i = 0; i < buckets.length; i++)
-        {
-            if (buckets[i] != null)
-            {
-                bytes += buckets[i].getLength();
-            }
-        }
-        return Math.round((keys.length * 4 + bytes) / Helper.MB);
-    }
-
-    @Override
-    public int put( long key, int value )
-    {
-        throw new UnsupportedOperationException("Not supported yet.");
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/coll/SparseArray.java b/core/src/main/java/com/graphhopper/coll/SparseArray.java
deleted file mode 100644
index 76ab43aa7a..0000000000
--- a/core/src/main/java/com/graphhopper/coll/SparseArray.java
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.coll;
-
-import com.graphhopper.util.Helper;
-
-/**
- * Copied from Android project: android.util.SparseArray.java
- * <p>
- * SparseArrays map integers to Objects. Unlike a normal array of Objects, there can be gaps in the
- * indices. It is intended to be more efficient than using a HashMap to map Integers to Objects.
- */
-public class SparseArray<E> implements Cloneable
-{
-    private static final Object DELETED = new Object();
-    private boolean mGarbage = false;
-    private int[] mKeys;
-    private Object[] mValues;
-    private int mSize;
-
-    /**
-     * Creates a new SparseArray containing no mappings.
-     */
-    public SparseArray()
-    {
-        this(10);
-    }
-
-    /**
-     * Creates a new SparseArray containing no mappings that will not require any additional memory
-     * allocation to store the specified number of mappings.
-     */
-    public SparseArray( int initialCapacity )
-    {
-        initialCapacity = Helper.idealIntArraySize(initialCapacity);
-
-        mKeys = new int[initialCapacity];
-        mValues = new Object[initialCapacity];
-        mSize = 0;
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public SparseArray<E> clone()
-    {
-        SparseArray<E> clone = null;
-        try
-        {
-            clone = (SparseArray<E>) super.clone();
-            clone.mKeys = mKeys.clone();
-            clone.mValues = mValues.clone();
-        } catch (CloneNotSupportedException cnse)
-        {
-            /* ignore */
-        }
-        return clone;
-    }
-
-    /**
-     * Gets the Object mapped from the specified key, or <code>null</code> if no such mapping has
-     * been made.
-     */
-    public E get( int key )
-    {
-        return get(key, null);
-    }
-
-    /**
-     * Gets the Object mapped from the specified key, or the specified Object if no such mapping has
-     * been made.
-     */
-    @SuppressWarnings("unchecked")
-    public E get( int key, E valueIfKeyNotFound )
-    {
-        int i = binarySearch(mKeys, 0, mSize, key);
-
-        if (i < 0 || mValues[i] == DELETED)
-        {
-            return valueIfKeyNotFound;
-        } else
-        {
-            return (E) mValues[i];
-        }
-    }
-
-    /**
-     * Removes the mapping from the specified key, if there was any.
-     */
-    public void remove( int key )
-    {
-        int i = binarySearch(mKeys, 0, mSize, key);
-        if (i >= 0)
-        {
-            if (mValues[i] != DELETED)
-            {
-                mValues[i] = DELETED;
-                mGarbage = true;
-            }
-        }
-    }
-
-    /**
-     * Removes the mapping at the specified index.
-     */
-    public void removeAt( int index )
-    {
-        if (mValues[index] != DELETED)
-        {
-            mValues[index] = DELETED;
-            mGarbage = true;
-        }
-    }
-
-    private void gc()
-    {
-        // Log.e("SparseArray", "gc start with " + mSize);
-
-        int n = mSize;
-        int o = 0;
-        int[] keys = mKeys;
-        Object[] values = mValues;
-
-        for (int i = 0; i < n; i++)
-        {
-            Object val = values[i];
-
-            if (val != DELETED)
-            {
-                if (i != o)
-                {
-                    keys[o] = keys[i];
-                    values[o] = val;
-                    values[i] = null;
-                }
-
-                o++;
-            }
-        }
-
-        mGarbage = false;
-        mSize = o;
-
-        // Log.e("SparseArray", "gc end with " + mSize);
-    }
-
-    /**
-     * Adds a mapping from the specified key to the specified value, replacing the previous mapping
-     * from the specified key if there was one.
-     */
-    public void put( int key, E value )
-    {
-        int i = binarySearch(mKeys, 0, mSize, key);
-
-        if (i >= 0)
-        {
-            mValues[i] = value;
-        } else
-        {
-            i = ~i;
-
-            if (i < mSize && mValues[i] == DELETED)
-            {
-                mKeys[i] = key;
-                mValues[i] = value;
-                return;
-            }
-
-            if (mGarbage && mSize >= mKeys.length)
-            {
-                gc();
-
-                // Search again because indices may have changed.
-                i = ~binarySearch(mKeys, 0, mSize, key);
-            }
-
-            if (mSize >= mKeys.length)
-            {
-                int n = Helper.idealIntArraySize(mSize + 1);
-
-                int[] nkeys = new int[n];
-                Object[] nvalues = new Object[n];
-
-                // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
-                System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-                System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-
-                mKeys = nkeys;
-                mValues = nvalues;
-            }
-
-            if (mSize - i != 0)
-            {
-                // Log.e("SparseArray", "move " + (mSize - i));
-                System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
-                System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
-            }
-
-            mKeys[i] = key;
-            mValues[i] = value;
-            mSize++;
-        }
-    }
-
-    /**
-     * Returns the number of key-value mappings that this SparseArray currently stores.
-     */
-    public int getSize()
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        return mSize;
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, returns the key from the
-     * <code>index</code>th key-value mapping that this SparseArray stores.
-     */
-    public int keyAt( int index )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        return mKeys[index];
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, returns the value from the
-     * <code>index</code>th key-value mapping that this SparseArray stores.
-     */
-    @SuppressWarnings("unchecked")
-    public E valueAt( int index )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        return (E) mValues[index];
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, sets a new value for the
-     * <code>index</code>th key-value mapping that this SparseArray stores.
-     */
-    public void setValueAt( int index, E value )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        mValues[index] = value;
-    }
-
-    /**
-     * Returns the index for which {@link #keyAt} would return the specified key, or a negative
-     * number if the specified key is not mapped.
-     */
-    public int indexOfKey( int key )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        return binarySearch(mKeys, 0, mSize, key);
-    }
-
-    /**
-     * Returns an index for which {@link #valueAt} would return the specified key, or a negative
-     * number if no keys map to the specified value. Beware that this is a linear search, unlike
-     * lookups by key, and that multiple keys can map to the same value and this will find only one
-     * of them.
-     */
-    public int indexOfValue( E value )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        for (int i = 0; i < mSize; i++)
-        {
-            if (mValues[i] == value)
-            {
-                return i;
-            }
-        }
-
-        return -1;
-    }
-
-    /**
-     * Removes all key-value mappings from this SparseArray.
-     */
-    public void clear()
-    {
-        trimTo(0);
-    }
-
-    public void trimTo( int size )
-    {
-        // let the gc do its work
-        int max = Math.min(mSize, size);
-        for (int i = max; i < mSize; i++)
-        {
-            mValues[i] = null;
-        }
-
-        mSize = 0;
-        mGarbage = false;
-    }
-
-    /**
-     * Puts a key/value pair into the array, optimizing for the case where the key is greater than
-     * all existing keys in the array.
-     */
-    public void append( int key, E value )
-    {
-        if (mSize != 0 && key <= mKeys[mSize - 1])
-        {
-            put(key, value);
-            return;
-        }
-
-        if (mGarbage && mSize >= mKeys.length)
-        {
-            gc();
-        }
-
-        int pos = mSize;
-        if (pos >= mKeys.length)
-        {
-            int n = Helper.idealIntArraySize(pos + 1);
-
-            int[] nkeys = new int[n];
-            Object[] nvalues = new Object[n];
-
-            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
-            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-
-            mKeys = nkeys;
-            mValues = nvalues;
-        }
-
-        mKeys[pos] = key;
-        mValues[pos] = value;
-        mSize = pos + 1;
-    }
-
-    // Warning: returns ~index and not -(index+1) like trove and jdk do
-    private static int binarySearch( int[] a, int start, int len, int key )
-    {
-        int high = start + len, low = start - 1, guess;
-        while (high - low > 1)
-        {
-            // use >>> for average or we could get an integer overflow. 
-            guess = (high + low) >>> 1;
-
-            if (a[guess] < key)
-            {
-                low = guess;
-            } else
-            {
-                high = guess;
-            }
-        }
-
-        if (high == start + len)
-        {
-            return ~(start + len);
-        } else if (a[high] == key)
-        {
-            return high;
-        } else
-        {
-            return ~high;
-        }
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java b/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
deleted file mode 100644
index 15577939ce..0000000000
--- a/core/src/main/java/com/graphhopper/coll/SparseLongLongArray.java
+++ /dev/null
@@ -1,446 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.graphhopper.coll;
-
-import com.graphhopper.util.Helper;
-
-/**
- * Copied from Android project. android.util.LongSparseArray.java
- * <p>
- * SparseArrays map longs to longs. Unlike a normal array of longs, there can be gaps in the
- * indices.
- */
-public class SparseLongLongArray
-{
-    private static final long DELETED = Long.MIN_VALUE;
-    private boolean mGarbage = false;
-
-    /**
-     * Creates a new SparseLongLongArray containing no mappings.
-     */
-    public SparseLongLongArray()
-    {
-        this(10);
-    }
-
-    /**
-     * Creates a new SparseLongLongArray containing no mappings that will not require any additional
-     * memory allocation to store the specified number of mappings.
-     */
-    public SparseLongLongArray( int cap )
-    {
-        try
-        {
-            cap = Helper.idealIntArraySize(cap);
-            mKeys = new long[cap];
-            mValues = new long[cap];
-            mSize = 0;
-        } catch (OutOfMemoryError err)
-        {
-            System.err.println("requested capacity " + cap);
-            throw err;
-        }
-    }
-
-    /**
-     * @return A copy of all keys contained in the sparse array.
-     */
-    private long[] getKeys()
-    {
-        int length = mKeys.length;
-        long[] result = new long[length];
-        System.arraycopy(mKeys, 0, result, 0, length);
-        return result;
-    }
-
-    /**
-     * Sets all supplied keys to the given unique value.
-     * <p>
-     * @param keys Keys to set
-     * @param uniqueValue Value to set all supplied keys to
-     */
-    private void setValues( long[] keys, long uniqueValue )
-    {
-        int length = keys.length;
-        for (int i = 0; i < length; i++)
-        {
-            put(keys[i], uniqueValue);
-        }
-    }
-
-    /**
-     * Gets the Object mapped from the specified key, or <code>null</code> if no such mapping has
-     * been made.
-     */
-    public long get( long key )
-    {
-        return get(key, -1);
-    }
-
-    /**
-     * Gets the Object mapped from the specified key, or the specified Object if no such mapping has
-     * been made.
-     */
-    private long get( long key, long valueIfKeyNotFound )
-    {
-        int i = binarySearch(mKeys, 0, mSize, key);
-        if (i < 0 || mValues[i] == DELETED)
-        {
-            return valueIfKeyNotFound;
-        } else
-        {
-            return mValues[i];
-        }
-    }
-
-    /**
-     * Removes the mapping from the specified key, if there was any.
-     */
-    public void remove( long key )
-    {
-        int i = binarySearch(mKeys, 0, mSize, key);
-
-        if (i >= 0)
-        {
-            if (mValues[i] != DELETED)
-            {
-                mValues[i] = DELETED;
-                mGarbage = true;
-            }
-        }
-    }
-
-    private void gc()
-    {
-        int n = mSize;
-        int o = 0;
-        long[] keys = mKeys;
-        long[] values = mValues;
-
-        for (int i = 0; i < n; i++)
-        {
-            long val = values[i];
-
-            if (val != DELETED)
-            {
-                if (i != o)
-                {
-                    keys[o] = keys[i];
-                    values[o] = val;
-                }
-
-                o++;
-            }
-        }
-
-        mGarbage = false;
-        mSize = o;
-    }
-
-    /**
-     * Adds a mapping from the specified key to the specified value, replacing the previous mapping
-     * from the specified key if there was one.
-     */
-    public int put( long key, long value )
-    {
-        int i = binarySearch(mKeys, 0, mSize, key);
-
-        if (i >= 0)
-        {
-            mValues[i] = value;
-        } else
-        {
-            i = ~i;
-
-            if (i < mSize && mValues[i] == DELETED)
-            {
-                mKeys[i] = key;
-                mValues[i] = value;
-                return i;
-            }
-
-            if (mGarbage && mSize >= mKeys.length)
-            {
-                gc();
-
-                // Search again because indices may have changed.
-                i = ~binarySearch(mKeys, 0, mSize, key);
-            }
-
-            if (mSize >= mKeys.length)
-            {
-                int n = Helper.idealIntArraySize(mSize + 1);
-
-                long[] nkeys = new long[n];
-                long[] nvalues = new long[n];
-
-                System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-                System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-
-                mKeys = nkeys;
-                mValues = nvalues;
-            }
-
-            if (mSize - i != 0)
-            {
-                System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
-                System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
-            }
-
-            mKeys[i] = key;
-            mValues[i] = value;
-            mSize++;
-        }
-        return i;
-    }
-
-    /**
-     * Returns the number of key-value mappings that this SparseLongLongArray currently stores.
-     */
-    public int getSize()
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        return mSize;
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, returns the key from the
-     * <code>index</code>th key-value mapping that this SparseLongLongArray stores.
-     */
-    public long keyAt( int index )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        return mKeys[index];
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, sets a new key for the
-     * <code>index</code>th key-value mapping that this SparseLongLongArray stores.
-     */
-    public void setKeyAt( int index, long key )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        mKeys[index] = key;
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, returns the value from the
-     * <code>index</code>th key-value mapping that this SparseLongLongArray stores.
-     */
-    public long valueAt( int index )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        return mValues[index];
-    }
-
-    /**
-     * Given an index in the range <code>0...size()-1</code>, sets a new value for the
-     * <code>index</code>th key-value mapping that this SparseLongLongArray stores.
-     */
-    public void setValueAt( int index, long value )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        mValues[index] = value;
-    }
-
-    /**
-     * Returns the index for which {@link #keyAt} would return the specified key, or a negative
-     * number if the specified key is not mapped.
-     */
-    private int indexOfKey( long key )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        return binarySearch(mKeys, 0, mSize, key);
-    }
-
-    /**
-     * Returns an index for which {@link #valueAt} would return the specified key, or a negative
-     * number if no keys map to the specified value. Beware that this is a linear search, unlike
-     * lookups by key, and that multiple keys can map to the same value and this will find only one
-     * of them.
-     */
-    private int indexOfValue( long value )
-    {
-        if (mGarbage)
-        {
-            gc();
-        }
-
-        for (int i = 0; i < mSize; i++)
-        {
-            if (mValues[i] == value)
-            {
-                return i;
-            }
-        }
-
-        return -1;
-    }
-
-    /**
-     * Removes all key-value mappings from this SparseLongLongArray.
-     */
-    public void clear()
-    {
-        int n = mSize;
-        long[] values = mValues;
-
-        for (int i = 0; i < n; i++)
-        {
-            values[i] = -1;
-        }
-
-        mSize = 0;
-        mGarbage = false;
-    }
-
-    /**
-     * Puts a key/value pair into the array, optimizing for the case where the key is greater than
-     * all existing keys in the array.
-     */
-    public int append( long key, long value )
-    {
-        if (mSize != 0 && key <= mKeys[mSize - 1])
-        {
-            return put(key, value);
-        }
-
-        if (mGarbage && mSize >= mKeys.length)
-        {
-            gc();
-        }
-
-        int pos = mSize;
-        if (pos >= mKeys.length)
-        {
-            int n = Helper.idealIntArraySize(pos + 1);
-
-            long[] nkeys = new long[n];
-            long[] nvalues = new long[n];
-
-            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
-            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
-
-            mKeys = nkeys;
-            mValues = nvalues;
-        }
-
-        mKeys[pos] = key;
-        mValues[pos] = value;
-        mSize = pos + 1;
-        return pos;
-    }
-
-    @Override
-    public String toString()
-    {
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < mKeys.length; i++)
-        {
-            long k = mKeys[i];
-            long v = mValues[i];
-            if (i > 0)
-            {
-                sb.append(",");
-            }
-            sb.append(k);
-            sb.append(":");
-            sb.append(v);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Warning: returns ~index and not -(index+1) like trove and jdk do
-     */
-    public int binarySearch( long key )
-    {
-        return binarySearch(mKeys, 0, mSize, key);
-    }
-
-    static int binarySearch( long[] a, int start, int len, long key )
-    {
-        int high = start + len, low = start - 1, guess;
-        while (high - low > 1)
-        {
-            // use >>> for average or we could get an integer overflow. 
-            guess = (high + low) >>> 1;
-
-            if (a[guess] < key)
-            {
-                low = guess;
-            } else
-            {
-                high = guess;
-            }
-        }
-
-        if (high == start + len)
-        {
-            return ~(start + len);
-        } else if (a[high] == key)
-        {
-            return high;
-        } else
-        {
-            return ~high;
-        }
-    }
-
-    private void checkIntegrity()
-    {
-        for (int i = 1; i < mSize; i++)
-        {
-            if (mKeys[i] <= mKeys[i - 1])
-            {
-                for (int j = 0; j < mSize; j++)
-                {
-                    System.err.println("FAIL " + j + ": " + mKeys[j] + " -> " + mValues[j]);
-                }
-
-                throw new RuntimeException();
-            }
-        }
-    }
-
-    private long[] mKeys;
-    private long[] mValues;
-    private int mSize;
-}
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidir.java b/core/src/main/java/com/graphhopper/routing/PathBidir.java
deleted file mode 100644
index af397d52f8..0000000000
--- a/core/src/main/java/com/graphhopper/routing/PathBidir.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing;
-
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeWrapper;
-
-/**
- * This class creates a Path from two Edge's resulting from a BidirectionalDijkstra
- * <p>
- * @author Peter Karich
- */
-public class PathBidir extends Path
-{
-    public boolean switchWrapper = false;
-    public int fromRef = -1;
-    public int toRef = -1;
-    private EdgeWrapper edgeWFrom;
-    private EdgeWrapper edgeWTo;
-
-    public PathBidir( Graph g, FlagEncoder encoder,
-                      EdgeWrapper edgesFrom, EdgeWrapper edgesTo )
-    {
-        super(g, encoder);
-        this.edgeWFrom = edgesFrom;
-        this.edgeWTo = edgesTo;
-    }
-
-    /**
-     * Extracts path from two shortest-path-tree
-     */
-    @Override
-    public Path extract()
-    {
-        if (fromRef < 0 || toRef < 0)
-            return this;
-
-        if (switchWrapper)
-        {
-            int tmp = fromRef;
-            fromRef = toRef;
-            toRef = tmp;
-        }
-
-        int nodeFrom = edgeWFrom.getNode(fromRef);
-        int nodeTo = edgeWTo.getNode(toRef);
-        if (nodeFrom != nodeTo)
-            throw new IllegalStateException("'to' and 'from' have to be the same. " + toString());
-
-        int currRef = fromRef;
-        while (currRef > 0)
-        {
-            int edgeId = edgeWFrom.getEdgeId(currRef);
-            if (edgeId < 0)
-                break;
-
-            processEdge(edgeId, nodeFrom);
-            currRef = edgeWFrom.getParent(currRef);
-            nodeFrom = edgeWFrom.getNode(currRef);
-        }
-        reverseOrder();
-        setFromNode(nodeFrom);
-        // skip node of toRef (equal to fromRef)
-        currRef = toRef;
-        while (currRef > 0)
-        {
-            int edgeId = edgeWTo.getEdgeId(currRef);
-            if (edgeId < 0)
-                break;
-
-            int tmpRef = edgeWTo.getParent(currRef);
-            nodeTo = edgeWTo.getNode(tmpRef);
-            processEdge(edgeId, nodeTo);
-            currRef = tmpRef;
-        }
-        setEndNode(nodeTo);
-        return setFound(true);
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/Downloader.java b/core/src/main/java/com/graphhopper/util/Downloader.java
index 40ba9e0911..3b3e214b96 100644
--- a/core/src/main/java/com/graphhopper/util/Downloader.java
+++ b/core/src/main/java/com/graphhopper/util/Downloader.java
@@ -64,21 +64,30 @@ public Downloader setReferrer( String referrer )
         return this;
     }
 
-    public InputStream fetch( HttpURLConnection conn, boolean readErrorStreamNoException ) throws IOException
+    /**
+     * This method initiates a connect call of the provided connection and returns the response
+     * stream. It only returns the error stream if it is available and readErrorStreamNoException is
+     * true otherwise it throws an IOException if an error happens. Furthermore it wraps the stream
+     * to decompress it if the connection content encoding is specified.
+     */
+    public InputStream fetch( HttpURLConnection connection, boolean readErrorStreamNoException ) throws IOException
     {
         // create connection but before reading get the correct inputstream based on the compression and if error
-        conn.connect();
+        connection.connect();
 
         InputStream is;
-        if (readErrorStreamNoException && conn.getResponseCode() >= 400 && conn.getErrorStream() != null)
-            is = conn.getErrorStream();
+        if (readErrorStreamNoException && connection.getResponseCode() >= 400 && connection.getErrorStream() != null)
+            is = connection.getErrorStream();
         else
-            is = conn.getInputStream();
+            is = connection.getInputStream();
+
+        if (is == null)
+            throw new IOException("Stream is null. Message:" + connection.getResponseMessage());
 
         // wrap
         try
         {
-            String encoding = conn.getContentEncoding();
+            String encoding = connection.getContentEncoding();
             if (encoding != null && encoding.equalsIgnoreCase("gzip"))
                 is = new GZIPInputStream(is);
             else if (encoding != null && encoding.equalsIgnoreCase("deflate"))
@@ -99,8 +108,8 @@ public HttpURLConnection createConnection( String urlStr ) throws IOException
     {
         URL url = new URL(urlStr);
         HttpURLConnection conn = (HttpURLConnection) url.openConnection();
-        // conn.setDoInput(true); // Will yield in a POST request
-        conn.setDoOutput(true);
+        // Will yield in a POST request: conn.setDoOutput(true);
+        conn.setDoInput(true);
         conn.setUseCaches(true);
         conn.setRequestProperty("Referrer", referrer);
         conn.setRequestProperty("User-Agent", userAgent);
@@ -147,7 +156,7 @@ public void update( long sumBytes )
             {
                 progressListener.update((int) (100 * sumBytes / length));
             }
-        });    
+        });
     }
 
     public String downloadAsString( String url, boolean readErrorStreamNoException ) throws IOException
diff --git a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java b/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
deleted file mode 100644
index 896c6e71ed..0000000000
--- a/core/src/main/java/com/graphhopper/util/EdgeWrapper.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util;
-
-import com.graphhopper.routing.PathBidir;
-import gnu.trove.map.hash.TIntIntHashMap;
-
-import java.util.Arrays;
-
-/**
- * This class acts as a HashMap (nodes to weights) and is used to implement references from one edge
- * to its parent.
- * <p>
- * @author Peter Karich
- * @see PathBidir
- */
-@NotThreadSafe
-public class EdgeWrapper
-{
-    private static final float GROW_FACTOR = 1.5f;
-    private int refCounter;
-    private int[] nodes;
-    private int[] edgeIds;
-    private int[] parents;
-    private float[] weights;
-    protected TIntIntHashMap node2ref;
-
-    public EdgeWrapper()
-    {
-        this(10);
-    }
-
-    public EdgeWrapper( int size )
-    {
-        nodes = new int[size];
-        parents = new int[size];
-        edgeIds = new int[size];
-        weights = new float[size];
-        node2ref = new TIntIntHashMap(size, GROW_FACTOR, -1, -1);
-    }
-
-    /**
-     * @return edge id of current added (node,distance) tuple
-     */
-    public int add( int nodeId, double distance, int edgeId )
-    {
-        int ref = refCounter;
-        refCounter++;
-        node2ref.put(nodeId, ref);
-        ensureCapacity(ref);
-        weights[ref] = (float) distance;
-        nodes[ref] = nodeId;
-        parents[ref] = -1;
-        edgeIds[ref] = edgeId;
-        return ref;
-    }
-
-    public void putWeight( int ref, double dist )
-    {
-        if (ref < 1)
-            throw new IllegalStateException("You cannot save a reference with values smaller 1. 0 is reserved");
-
-        weights[ref] = (float) dist;
-    }
-
-    public void putEdgeId( int ref, int edgeId )
-    {
-        if (ref < 1)
-            throw new IllegalStateException("You cannot save a reference with values smaller 1. 0 is reserved");
-
-        edgeIds[ref] = edgeId;
-    }
-
-    public void putParent( int ref, int link )
-    {
-        if (ref < 1)
-            throw new IllegalStateException("You cannot save a reference with values smaller 1. 0 is reserved");
-
-        parents[ref] = link;
-    }
-
-    public double getWeight( int ref )
-    {
-        return weights[ref];
-    }
-
-    public int getNode( int ref )
-    {
-        return nodes[ref];
-    }
-
-    public int getParent( int ref )
-    {
-        return parents[ref];
-    }
-
-    public int getEdgeId( int ref )
-    {
-        return edgeIds[ref];
-    }
-
-    private void ensureCapacity( int size )
-    {
-        if (size < nodes.length)
-            return;
-
-        resize(Math.round(GROW_FACTOR * size));
-    }
-
-    private void resize( int cap )
-    {
-        weights = Arrays.copyOf(weights, cap);
-        nodes = Arrays.copyOf(nodes, cap);
-        parents = Arrays.copyOf(parents, cap);
-        edgeIds = Arrays.copyOf(edgeIds, cap);
-        node2ref.ensureCapacity(cap);
-    }
-
-    public void clear()
-    {
-        refCounter = 0;
-        Arrays.fill(weights, 0);
-        Arrays.fill(nodes, 0);
-        Arrays.fill(parents, 0);
-        Arrays.fill(edgeIds, EdgeIterator.NO_EDGE);
-        node2ref.clear();
-    }
-
-    public int getRef( int node )
-    {
-        return node2ref.get(node);
-    }
-
-    public boolean isEmpty()
-    {
-        return refCounter == 0;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 4d7e8451cc..f0015664bb 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -179,28 +179,39 @@ public String createGPX( String trackName, long startTimeMillis )
     private void createWayPointBlock( StringBuilder output, Instruction instruction )
     {
         output.append("\n<wpt ");
-        output.append("lat='").append(Helper.round6(instruction.getFirstLat()));
-        output.append("' lon='").append(Helper.round6(instruction.getFirstLon())).append("'>");
+        output.append("lat=\"").append(Helper.round6(instruction.getFirstLat()));
+        output.append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
+        String name;
         if (instruction.getName().isEmpty())
-            output.append(" <name>").append(instruction.getTurnDescription(tr)).append("</name>");
+            name = instruction.getTurnDescription(tr);
         else
-            output.append(" <name>").append(instruction.getName()).append("</name>");
+            name = instruction.getName();
+
+        output.append(" <name>").append(simpleXMLEscape(name)).append("</name>");
         output.append("</wpt>");
     }
 
+    static String simpleXMLEscape( String str )
+    {
+        // We could even use the 'more flexible' CDATA section but for now do the following. The 'and' could be important sometimes:
+        return str.replaceAll("&", "&amp;").
+                // but do not care for:
+                replaceAll("[\\<\\>]", "_");
+    }
+
     public String createGPX( String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints )
     {
         DateFormat formatter = Helper.createFormatter();
-        
-        String header = "<?xml version='1.0' encoding='UTF-8' standalone='no' ?>"
-                + "<gpx xmlns='http://www.topografix.com/GPX/1/1' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'"
-                + " creator='Graphhopper version " + Constants.VERSION + "' version='1.1'"
+
+        String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
+                + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
+                + " creator=\"Graphhopper version " + Constants.VERSION + "\" version=\"1.1\""
                 // This xmlns:gh acts only as ID, no valid URL necessary.
                 // Use a separate namespace for custom extensions to make basecamp happy.
-                + " xmlns:gh='https://graphhopper.com/public/schema/gpx/1.1'>"
+                + " xmlns:gh=\"https://graphhopper.com/public/schema/gpx/1.1\">"
                 + "\n<metadata>"
                 + "<copyright author=\"OpenStreetMap contributors\"/>"
-                + "<link href='http://graphhopper.com'>"
+                + "<link href=\"http://graphhopper.com\">"
                 + "<text>GraphHopper GPX</text>"
                 + "</link>"
                 + "<time>" + formatter.format(startTimeMillis) + "</time>"
@@ -242,8 +253,8 @@ public String createGPX( String trackName, long startTimeMillis, boolean include
             gpxOutput.append("<trkseg>");
             for (GPXEntry entry : createGPXList())
             {
-                gpxOutput.append("\n<trkpt lat='").append(Helper.round6(entry.getLat()));
-                gpxOutput.append("' lon='").append(Helper.round6(entry.getLon())).append("'>");
+                gpxOutput.append("\n<trkpt lat=\"").append(Helper.round6(entry.getLat()));
+                gpxOutput.append("\" lon=\"").append(Helper.round6(entry.getLon())).append("\">");
                 if (includeElevation)
                     gpxOutput.append("<ele>").append(Helper.round2(entry.getEle())).append("</ele>");
                 gpxOutput.append("<time>").append(formatter.format(startTimeMillis + entry.getTime())).append("</time>");
@@ -255,7 +266,7 @@ public String createGPX( String trackName, long startTimeMillis, boolean include
 
         // we could now use 'wpt' for via points
         gpxOutput.append("\n</gpx>");
-        return gpxOutput.toString().replaceAll("\\'", "\"");
+        return gpxOutput.toString();
     }
 
     public void createRteptBlock( StringBuilder output, Instruction instruction, Instruction nextI )
@@ -264,7 +275,7 @@ public void createRteptBlock( StringBuilder output, Instruction instruction, Ins
                 append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
 
         if (!instruction.getName().isEmpty())
-            output.append("<desc>").append(instruction.getTurnDescription(tr)).append("</desc>");
+            output.append("<desc>").append(simpleXMLEscape(instruction.getTurnDescription(tr))).append("</desc>");
 
         output.append("<extensions>");
         output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 49c479b46f..26b56c412c 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -31,31 +31,34 @@
  */
 public class PathMerger
 {
+    private static final DouglasPeucker DP = new DouglasPeucker();
     private boolean enableInstructions = true;
     private boolean simplifyResponse = true;
-    private DouglasPeucker douglasPeucker;
+    private DouglasPeucker douglasPeucker = DP;
     private boolean calcPoints = true;
 
-    private void calcAscendDescend( final GHResponse rsp, final PointList pointList )
+    public PathMerger setCalcPoints( boolean calcPoints )
     {
-        double ascendMeters = 0;
-        double descendMeters = 0;
-        double lastEle = pointList.getElevation(0);
-        for (int i = 1; i < pointList.size(); ++i)
-        {
-            double ele = pointList.getElevation(i);
-            double diff = Math.abs(ele - lastEle);
+        this.calcPoints = calcPoints;
+        return this;
+    }
 
-            if (ele > lastEle)
-                ascendMeters += diff;
-            else
-                descendMeters += diff;
+    public PathMerger setDouglasPeucker( DouglasPeucker douglasPeucker )
+    {
+        this.douglasPeucker = douglasPeucker;
+        return this;
+    }
 
-            lastEle = ele;
+    public PathMerger setSimplifyResponse( boolean simplifyRes )
+    {
+        this.simplifyResponse = simplifyRes;
+        return this;
+    }
 
-        }
-        rsp.setAscend(ascendMeters);
-        rsp.setDescend(descendMeters);
+    public PathMerger setEnableInstructions( boolean enableInstructions )
+    {
+        this.enableInstructions = enableInstructions;
+        return this;
     }
 
     public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
@@ -144,27 +147,25 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                 setTime(fullTimeInMillis);
     }
 
-    public PathMerger setCalcPoints( boolean calcPoints )
+    private void calcAscendDescend( final GHResponse rsp, final PointList pointList )
     {
-        this.calcPoints = calcPoints;
-        return this;
-    }
+        double ascendMeters = 0;
+        double descendMeters = 0;
+        double lastEle = pointList.getElevation(0);
+        for (int i = 1; i < pointList.size(); ++i)
+        {
+            double ele = pointList.getElevation(i);
+            double diff = Math.abs(ele - lastEle);
 
-    public PathMerger setDouglasPeucker( DouglasPeucker douglasPeucker )
-    {
-        this.douglasPeucker = douglasPeucker;
-        return this;
-    }
+            if (ele > lastEle)
+                ascendMeters += diff;
+            else
+                descendMeters += diff;
 
-    public PathMerger setSimplifyResponse( boolean simplifyRes )
-    {
-        this.simplifyResponse = simplifyRes;
-        return this;
-    }
+            lastEle = ele;
 
-    public PathMerger setEnableInstructions( boolean enableInstructions )
-    {
-        this.enableInstructions = enableInstructions;
-        return this;
+        }
+        rsp.setAscend(ascendMeters);
+        rsp.setDescend(descendMeters);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java b/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
deleted file mode 100644
index d5904de16f..0000000000
--- a/core/src/test/java/com/graphhopper/coll/BigLongIntMapTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.coll;
-
-import org.junit.Test;
-
-import static org.junit.Assert.*;
-
-/**
- * @author Peter Karich
- */
-public class BigLongIntMapTest
-{
-    @Test
-    public void testPut()
-    {
-        int segments = 10;
-        BigLongIntMap instance = new BigLongIntMap(1000, segments, -1);
-        assertEquals(-1, instance.put(Long.MAX_VALUE / 2, 123));
-        assertEquals(123, instance.get(Long.MAX_VALUE / 2));
-        assertEquals(1, instance.getSize());
-        instance.clear();
-
-        for (int i = 0; i < segments; i++)
-        {
-            assertEquals(-1, instance.put(Integer.MAX_VALUE * i, 123));
-        }
-        assertEquals(segments, instance.getSize());
-        // assertEquals("1, 2, 0, ...", instance.toString());
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
deleted file mode 100644
index a755752b45..0000000000
--- a/core/src/test/java/com/graphhopper/coll/IntIntBinHeapTest.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.coll;
-
-/**
- * @author Peter Karich
- */
-public class IntIntBinHeapTest extends AbstractBinHeapTest
-{
-    @Override
-    public BinHeapWrapper<Number, Integer> createHeap( int capacity )
-    {
-        return new IntIntBinHeap(capacity);
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java b/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
deleted file mode 100644
index fec5f54f3b..0000000000
--- a/core/src/test/java/com/graphhopper/coll/OSMIDSegmentedMapTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.coll;
-
-import org.junit.Test;
-
-import static org.junit.Assert.*;
-
-/**
- * @author Peter Karich
- */
-public class OSMIDSegmentedMapTest
-{
-
-    @Test
-    public void testZeroKey()
-    {
-        OSMIDSegmentedMap map = new OSMIDSegmentedMap();
-        map.write(0);
-        assertEquals(1, map.getSize());
-        assertEquals(0, map.get(0));
-        assertEquals(-1, map.get(1));
-    }
-
-    @Test
-    public void testGet()
-    {
-        OSMIDSegmentedMap map = new OSMIDSegmentedMap();
-        map.write(9);
-        map.write(10);
-        map.write(11);
-        map.write(12);
-        map.write(20);
-        map.write(21);
-        map.write(31);
-
-        assertEquals(7, map.getSize());
-        assertEquals(-1, map.get(8));
-        assertEquals(0, map.get(9));
-        assertEquals(1, map.get(10));
-        assertEquals(2, map.get(11));
-        assertEquals(3, map.get(12));
-        assertEquals(-1, map.get(13));
-        assertEquals(-1, map.get(19));
-        assertEquals(4, map.get(20));
-        assertEquals(5, map.get(21));
-        assertEquals(6, map.get(31));
-        assertEquals(-1, map.get(32));
-
-        for (int i = 0; i < 200; i++)
-        {
-            map.write(i + 50);
-        }
-        assertEquals(207, map.getSize());
-        assertEquals(-1, map.get(49));
-        assertEquals(7, map.get(50));
-    }
-
-    @Test
-    public void testGet2()
-    {
-        OSMIDSegmentedMap map = new OSMIDSegmentedMap();
-        map.write(9);
-        map.write(10);
-        map.write(11);
-        map.write(12);
-        map.write(13);
-        map.write(14);
-        map.write(16);
-        map.write(18);
-        map.write(19);
-
-        assertEquals(9, map.getSize());
-        assertEquals(-1, map.get(8));
-        assertEquals(0, map.get(9));
-        assertEquals(1, map.get(10));
-        assertEquals(2, map.get(11));
-        assertEquals(3, map.get(12));
-        assertEquals(4, map.get(13));
-        assertEquals(5, map.get(14));
-        assertEquals(6, map.get(16));
-        assertEquals(-1, map.get(17));
-        assertEquals(7, map.get(18));
-        assertEquals(8, map.get(19));
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java b/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
deleted file mode 100644
index cb11ee8218..0000000000
--- a/core/src/test/java/com/graphhopper/coll/SparseLongLongArrayTest.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.coll;
-
-import org.junit.Test;
-
-import static org.junit.Assert.*;
-
-/**
- * @author Peter Karich
- */
-public class SparseLongLongArrayTest
-{
-    @Test
-    public void testBinarySearch()
-    {
-        long a[] = new long[]
-                {
-                        9, 53, 100
-                };
-        assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 3, 50));
-        assertEquals(~2, SparseLongLongArray.binarySearch(a, 0, 3, 55));
-        assertEquals(~3, SparseLongLongArray.binarySearch(a, 0, 3, 155));
-
-        a = new long[]
-                {
-                        9
-                };
-        assertEquals(~0, SparseLongLongArray.binarySearch(a, 0, 1, 5));
-        assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 1, 50));
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java b/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
deleted file mode 100644
index 3a1f77790e..0000000000
--- a/core/src/test/java/com/graphhopper/util/EdgeWrapperTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.util;
-
-import org.junit.Test;
-
-import static org.junit.Assert.*;
-
-/**
- * @author Peter Karich
- */
-public class EdgeWrapperTest
-{
-    @Test
-    public void testPut()
-    {
-        EdgeWrapper instance = new EdgeWrapper(5);
-        int ref = instance.add(10, 100f, -1);
-        assertEquals(100f, instance.getWeight(ref), 1e-4);
-        assertEquals(-1, instance.getParent(ref));
-        assertEquals(10, instance.getNode(ref));
-    }
-
-    @Test
-    public void testClear()
-    {
-        EdgeWrapper instance = new EdgeWrapper(5);
-        assertEquals(0, instance.add(1, 10, 10));
-        instance.add(2, 20, 20);
-        instance.add(3, 30, 30);
-        instance.clear();
-        assertEquals(0, instance.add(1, 10, 10));
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index bfd765ebdb..367ddba68a 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -534,6 +534,13 @@ public void testFind()
 
         // query north-west of pillar node n , get instruction for fourth edge
         assertEquals("4-5", wayList.find(15.21, 9.85, 100000).getName());
+    }
 
+    @Test
+    public void testXMLEscape_issue572()
+    {
+        assertEquals("_", InstructionList.simpleXMLEscape("<"));
+        assertEquals("_blup_", InstructionList.simpleXMLEscape("<blup>"));
+        assertEquals("a&amp;b", InstructionList.simpleXMLEscape("a&b"));
     }
 }
diff --git a/graphhopper.sh b/graphhopper.sh
index 2738698996..1c5f1423a3 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -112,7 +112,7 @@ function packageCoreJar {
     echo "## now building graphhopper jar: $JAR"
     echo "## using maven at $MAVEN_HOME"
     #mvn clean
-    "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests=true install assembly:single > /tmp/graphhopper-compile.log
+    "$MAVEN_HOME/bin/mvn" --projects tools -DskipTests=true install assembly:single > /tmp/graphhopper-compile.log
     returncode=$?
     if [[ $returncode != 0 ]] ; then
         echo "## compilation of core failed"
@@ -153,7 +153,7 @@ elif [ "$ACTION" = "extract" ]; then
  
 elif [ "$ACTION" = "android" ]; then
  prepareEclipse
- "$MAVEN_HOME/bin/mvn" -P include-android --projects android install android:deploy android:run
+ "$MAVEN_HOME/bin/mvn" -P include-android --projects android/app install android:deploy android:run
  exit
 fi
 
@@ -288,7 +288,7 @@ elif [ "$ACTION" = "measurement" ]; then
   
  if [ "$last_commits" = "" ]; then
    # use current version
-   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects tools -DskipTests clean install assembly:single
    startMeasurement
    exit
  fi
@@ -301,7 +301,7 @@ elif [ "$ACTION" = "measurement" ]; then
    M_FILE_NAME="measurement$M_FILE_NAME.properties"
    echo -e "\nusing commit $commit and $M_FILE_NAME"
    
-   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects tools -DskipTests clean install assembly:single
    startMeasurement
    echo -e "\nmeasurement.commit=$commit\n" >> "$M_FILE_NAME"
  done
diff --git a/pom.xml b/pom.xml
index e6d4aae7dc..e80ee5d44e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -8,7 +8,7 @@
     <name>GraphHopper Parent Project</name>
     <version>0.6-SNAPSHOT</version>
     <packaging>pom</packaging> 
-    <url>http://graphhopper.com</url> 
+    <url>https://graphhopper.com</url> 
     <inceptionYear>2012</inceptionYear>
     <description>
         Super pom of GraphHopper core, a fast Java road routing engine.
@@ -64,11 +64,8 @@
     <mailingLists>
         <mailingList>
             <name>GraphHopper</name>
-            <subscribe>http://lists.openstreetmap.org/listinfo/graphhopper</subscribe>      
-            <archive>http://lists.openstreetmap.org/pipermail/graphhopper/</archive>
-            <otherArchives>
-                <otherArchive>http://graphhopper.1087335.n5.nabble.com/</otherArchive>
-            </otherArchives>
+            <subscribe>https://discuss.graphhopper.com/</subscribe>
+            <archive>https://discuss.graphhopper.com/</archive>
         </mailingList>
     </mailingLists>
     <issueManagement>
@@ -76,6 +73,7 @@
         <url>https://github.com/graphhopper/graphhopper/issues</url>
     </issueManagement>
     <modules>
+        <module>tools-lgpl</module>
         <module>core</module>
         <module>tools</module>
         <module>web</module>
diff --git a/tools-lgpl/pom.xml b/tools-lgpl/pom.xml
new file mode 100644
index 0000000000..f88b161b05
--- /dev/null
+++ b/tools-lgpl/pom.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.graphhopper</groupId>
+    <artifactId>graphhopper-tools-lgpl</artifactId>
+    <version>0.6-SNAPSHOT</version>
+    <packaging>jar</packaging>
+    <name>GraphHopper Tools LGPL licensed</name>
+
+    <parent>
+        <groupId>com.graphhopper</groupId>
+        <artifactId>graphhopper-parent</artifactId>    	
+        <version>0.6-SNAPSHOT</version>
+    </parent>
+
+    <dependencies>
+        
+    </dependencies>
+</project>
diff --git a/core/src/main/java/com/graphhopper/coll/IntIntBinHeap.java b/tools-lgpl/src/main/java/com/graphhopper/coll/OTPIntDoubleBinHeap.java
similarity index 64%
rename from core/src/main/java/com/graphhopper/coll/IntIntBinHeap.java
rename to tools-lgpl/src/main/java/com/graphhopper/coll/OTPIntDoubleBinHeap.java
index 0f1b98ea75..da1776280b 100644
--- a/core/src/main/java/com/graphhopper/coll/IntIntBinHeap.java
+++ b/tools-lgpl/src/main/java/com/graphhopper/coll/OTPIntDoubleBinHeap.java
@@ -17,20 +17,20 @@
 /**
  * Taken from opentripplanner.
  */
-public class IntIntBinHeap implements BinHeapWrapper<Number, Integer>
+public class OTPIntDoubleBinHeap
 {
     private static final double GROW_FACTOR = 2.0;
-    private int[] keys;
+    private float[] keys;
     private int[] elem;
     private int size;
     private int capacity;
 
-    public IntIntBinHeap()
+    public OTPIntDoubleBinHeap()
     {
         this(1000);
     }
 
-    public IntIntBinHeap( int capacity )
+    public OTPIntDoubleBinHeap( int capacity )
     {
         if (capacity < 10)
         {
@@ -40,30 +40,32 @@ public IntIntBinHeap( int capacity )
         size = 0;
         elem = new int[capacity + 1];
         // 1-based indexing
-        keys = new int[capacity + 1];
+        keys = new float[capacity + 1];
         // set sentinel
-        keys[0] = Integer.MIN_VALUE;
+        keys[0] = Float.NEGATIVE_INFINITY;
     }
 
-    @Override
     public int getSize()
     {
         return size;
     }
 
-    @Override
+    public int size()
+    {
+        return size;
+    }
+
     public boolean isEmpty()
     {
         return size == 0;
     }
 
-    @Override
-    public Integer peekKey()
+    public Double peekKey()
     {
         return peek_key();
     }
 
-    public int peek_key()
+    public double peek_key()
     {
         if (size > 0)
         {
@@ -74,7 +76,6 @@ public int peek_key()
         }
     }
 
-    @Override
     public Integer peekElement()
     {
         return peek_element();
@@ -91,7 +92,6 @@ public int peek_element()
         }
     }
 
-    @Override
     public Integer pollElement()
     {
         return poll_element();
@@ -102,7 +102,7 @@ public int poll_element()
         int i, child;
         int minElem = elem[1];
         int lastElem = elem[size];
-        int lastPrio = keys[size];
+        double lastPrio = keys[size];
         if (size <= 0)
         {
             throw new IllegalStateException("An empty queue does not have a minimum value.");
@@ -125,31 +125,30 @@ public int poll_element()
             }
         }
         elem[i] = lastElem;
-        keys[i] = lastPrio;
+        keys[i] = (float) lastPrio;
         return minElem;
     }
 
-    @Override
-    public void update( Number key, Integer value )
+    public void update( Number key, Integer element )
     {
-        update_(key.intValue(), value);
+        update_(key.doubleValue(), element);
     }
 
-    public void update_( int key, int value )
+    public boolean update_( double key, int element )
     {
         // Perform "inefficient" but straightforward linear search 
         // for an element then change its key by sifting up or down
         int i;
         for (i = 1; i <= size; i++)
         {
-            if (elem[i] == value)
+            if (elem[i] == element)
             {
                 break;
             }
         }
         if (i > size)
         {
-            return;
+            return false;
         }
 
         if (key > keys[i])
@@ -172,35 +171,29 @@ public void update_( int key, int value )
                     break;
                 }
             }
-            elem[i] = value;
-            keys[i] = key;
+            elem[i] = element;
+            keys[i] = (float) key;
         } else
         {
-            // sift down (as in insert)
+            // sift down (as in insert_)
             while (keys[i / 2] > key)
             {
                 elem[i] = elem[i / 2];
                 keys[i] = keys[i / 2];
                 i /= 2;
             }
-            elem[i] = value;
-            keys[i] = key;
+            elem[i] = element;
+            keys[i] = (float) key;
         }
+        return true;
     }
 
-    public void reset()
-    {
-        // empties the queue in one operation
-        size = 0;
-    }
-
-    @Override
-    public void insert( Number key, Integer value )
+    public void insert( Number key, Integer element )
     {
-        insert_(key.intValue(), value);
+        insert_(key.doubleValue(), element);
     }
 
-    public void insert_( int key, int value )
+    public void insert_( double key, int element )
     {
         int i;
         size += 1;
@@ -213,13 +206,13 @@ public void insert_( int key, int value )
             elem[i] = elem[i / 2];
             keys[i] = keys[i / 2];
         }
-        elem[i] = value;
-        keys[i] = key;
+        elem[i] = element;
+        keys[i] = (float) key;
     }
 
-    @Override
     public void ensureCapacity( int capacity )
     {
+        // System.out.println("Growing queue to " + capacity);
         if (capacity < size)
         {
             throw new IllegalStateException("BinHeap contains too many elements to fit in new capacity.");
@@ -229,11 +222,79 @@ public void ensureCapacity( int capacity )
         elem = Arrays.copyOf(elem, capacity + 1);
     }
 
-    @Override
+    public int getCapacity()
+    {
+        return capacity;
+    }
+
+    float getKey( int index )
+    {
+        return keys[index];
+    }
+
+    int getElement( int index )
+    {
+        return elem[index];
+    }
+
+    void set( int index, float key, int element )
+    {
+        keys[index] = key;
+        elem[index] = element;
+    }
+
+    void trimTo( int toSize )
+    {
+        this.size = toSize;
+        toSize++;
+        // necessary as we currently do not init arrays when inserting
+        Arrays.fill(keys, toSize, size + 1, 0f);
+        Arrays.fill(elem, toSize, size + 1, 0);
+    }
+
     public void clear()
     {
-        this.size = 0;
-        Arrays.fill(keys, 0);
-        Arrays.fill(elem, 0);
+        trimTo(0);
+    }
+
+    @Override
+    public String toString()
+    {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 1; i <= size; i++)
+        {
+            if (i > 1)
+            {
+                sb.append(", ");
+            }
+            sb.append(keys[i]).append(":").append(elem[i]);
+        }
+        return sb.toString();
+    }
+
+    public String toKeyString()
+    {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 1; i <= size; i++)
+        {
+            if (i > 1)
+            {
+                sb.append(", ");
+            }
+            sb.append(keys[i]);
+        }
+        return sb.toString();
+    }
+
+    public int indexOfValue( int value )
+    {
+        for (int i = 0; i <= size; i++)
+        {
+            if (elem[i] == value)
+            {
+                return i;
+            }
+        }
+        return -1;
     }
 }
diff --git a/web/src/main/webapp/css/style.css b/web/src/main/webapp/css/style.css
index ca10039879..0a8ae3e140 100644
--- a/web/src/main/webapp/css/style.css
+++ b/web/src/main/webapp/css/style.css
@@ -144,6 +144,11 @@ body {
 #header_img img {
     width: 230px;
 }
+
+#gpx_dialog {
+    display: none;
+}
+
 #gpxExportButton {
     margin-top: -3px;
 }
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 54c9455bd4..c7e1b29586 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -224,7 +224,7 @@ $(document).ready(function (e) {
                                 hiddenVehicles[i].show();
                             }
                         });
-                        vehiclesDiv.append($("<a class='vehicle-info-link' href='https://github.com/graphhopper/directions-api/blob/master/supported-vehicle-profiles.md'>?</a>"))
+                        vehiclesDiv.append($("<a class='vehicle-info-link' href='https://graphhopper.com/api/1/docs/supported-vehicle-profiles/'>?</a>"))
                         vehiclesDiv.append(moreBtn);
                     }
                 }
