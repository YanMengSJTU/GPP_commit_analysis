diff --git a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
index de28c78e29..5df39ea330 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
@@ -284,4 +284,8 @@ private void addAllLatLonToPoints(int numPoints, List<GHPoint> points) {
     public int size() {
         return this.lat.length;
     }
+
+    public boolean isRepresentingArea() {
+        return this.size() > 2;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 641a6fa98d..63b9c84334 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -78,7 +78,7 @@
     private final Set<RoutingAlgorithmFactoryDecorator> algoDecorators = new LinkedHashSet<>();
     // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
-    private boolean removeZipped = true;
+    boolean removeZipped = true;
     // for graph:
     private GraphHopperStorage ghStorage;
     private EncodingManager encodingManager;
@@ -147,9 +147,8 @@ protected GraphHopper loadGraph(GraphHopperStorage g) {
      * @return the first flag encoder of the encoding manager
      */
     FlagEncoder getDefaultVehicle() {
-        if (encodingManager == null) {
+        if (encodingManager == null)
             throw new IllegalStateException("No encoding manager specified or loaded");
-        }
 
         return encodingManager.fetchEdgeEncoders().get(0);
     }
@@ -165,9 +164,8 @@ public EncodingManager getEncodingManager() {
     public GraphHopper setEncodingManager(EncodingManager em) {
         ensureNotLoaded();
         this.encodingManager = em;
-        if (em.needsTurnCostsSupport()) {
+        if (em.needsTurnCostsSupport())
             traversalMode = TraversalMode.EDGE_BASED;
-        }
 
         return this;
     }
@@ -177,11 +175,10 @@ public ElevationProvider getElevationProvider() {
     }
 
     public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
-        if (eleProvider == null || eleProvider == ElevationProvider.NOOP) {
+        if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
             setElevation(false);
-        } else {
+        else
             setElevation(true);
-        }
         this.eleProvider = eleProvider;
         return this;
     }
@@ -277,7 +274,7 @@ public GraphHopper setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSiz
     /**
      * This method call results in an in-memory graph.
      */
-    private GraphHopper setInMemory() {
+    public GraphHopper setInMemory() {
         ensureNotLoaded();
         dataAccessType = DAType.RAM_STORE;
         return this;
@@ -292,18 +289,17 @@ private GraphHopper setInMemory() {
      */
     public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
         ensureNotLoaded();
-        if (storeOnFlush) {
+        if (storeOnFlush)
             dataAccessType = DAType.RAM_STORE;
-        } else {
+        else
             dataAccessType = DAType.RAM;
-        }
         return this;
     }
 
     /**
      * Enable memory mapped configuration if not enough memory is available on the target platform.
      */
-    private GraphHopper setMemoryMapped() {
+    public GraphHopper setMemoryMapped() {
         ensureNotLoaded();
         dataAccessType = DAType.MMAP;
         return this;
@@ -393,9 +389,8 @@ public String getGraphHopperLocation() {
      */
     public GraphHopper setGraphHopperLocation(String ghLocation) {
         ensureNotLoaded();
-        if (ghLocation == null) {
+        if (ghLocation == null)
             throw new IllegalArgumentException("graphhopper location cannot be null");
-        }
 
         this.ghLocation = ghLocation;
         return this;
@@ -411,9 +406,8 @@ public String getDataReaderFile() {
      */
     public GraphHopper setDataReaderFile(String dataReaderFileStr) {
         ensureNotLoaded();
-        if (isEmpty(dataReaderFileStr)) {
+        if (isEmpty(dataReaderFileStr))
             throw new IllegalArgumentException("Data reader file cannot be empty.");
-        }
 
         dataReaderFile = dataReaderFileStr;
         return this;
@@ -425,9 +419,8 @@ public GraphHopper setDataReaderFile(String dataReaderFileStr) {
      * @throws IllegalStateException if graph is not instantiated.
      */
     public GraphHopperStorage getGraphHopperStorage() {
-        if (ghStorage == null) {
+        if (ghStorage == null)
             throw new IllegalStateException("GraphHopper storage not initialized");
-        }
 
         return ghStorage;
     }
@@ -443,9 +436,8 @@ public void setGraphHopperStorage(GraphHopperStorage ghStorage) {
      * @throws IllegalStateException if index is not initialized
      */
     public LocationIndex getLocationIndex() {
-        if (locationIndex == null) {
+        if (locationIndex == null)
             throw new IllegalStateException("Location index not initialized");
-        }
 
         return locationIndex;
     }
@@ -463,7 +455,7 @@ public GraphHopper setSortGraph(boolean sortGraph) {
         return this;
     }
 
-    private boolean isAllowWrites() {
+    public boolean isAllowWrites() {
         return allowWrites;
     }
 
@@ -509,20 +501,17 @@ public GraphHopper setTagParserFactory(TagParserFactory factory) {
      */
     public GraphHopper init(CmdArgs args) {
         args.merge(CmdArgs.readFromSystemProperties());
-        if (args.has("osmreader.osm")) {
+        if (args.has("osmreader.osm"))
             throw new IllegalArgumentException("Instead osmreader.osm use datareader.file, for other changes see core/files/changelog.txt");
-        }
 
         String tmpOsmFile = args.get("datareader.file", "");
-        if (!isEmpty(tmpOsmFile)) {
+        if (!isEmpty(tmpOsmFile))
             dataReaderFile = tmpOsmFile;
-        }
 
         String graphHopperFolder = args.get("graph.location", "");
         if (isEmpty(graphHopperFolder) && isEmpty(ghLocation)) {
-            if (isEmpty(dataReaderFile)) {
+            if (isEmpty(dataReaderFile))
                 throw new IllegalArgumentException("If no graph.location is provided you need to specify an OSM file.");
-            }
 
             graphHopperFolder = pruneFileEnd(dataReaderFile) + "-gh";
         }
@@ -541,23 +530,20 @@ public GraphHopper init(CmdArgs args) {
         String flagEncodersStr = args.get("graph.flag_encoders", "");
         String encodedValueStr = args.get("graph.encoded_values", "");
         if (!flagEncodersStr.isEmpty() || !encodedValueStr.isEmpty()) {
-            if (!encodedValueStr.isEmpty()) {
+            if (!encodedValueStr.isEmpty())
                 emBuilder.addAll(tagParserFactory, encodedValueStr);
-            }
-            if (!flagEncodersStr.isEmpty()) {
+            if (!flagEncodersStr.isEmpty())
                 emBuilder.addAll(flagEncoderFactory, flagEncodersStr);
-            }
             emBuilder.setEnableInstructions(args.getBool("datareader.instructions", true));
             emBuilder.setPreferredLanguage(args.get("datareader.preferred_language", ""));
             // overwrite EncodingManager object from configuration file
             setEncodingManager(emBuilder.build());
         }
 
-        if (args.get("graph.locktype", "native").equals("simple")) {
+        if (args.get("graph.locktype", "native").equals("simple"))
             lockFactory = new SimpleFSLockFactory();
-        } else {
+        else
             lockFactory = new NativeFSLockFactory();
-        }
 
         // elevation
         String eleProviderStr = toLowerCase(args.get("graph.elevation.provider", "noop"));
@@ -569,14 +555,12 @@ public GraphHopper init(CmdArgs args) {
                               : args.getBool("graph.elevation.calc_mean", false);
 
         String cacheDirStr = args.get("graph.elevation.cache_dir", "");
-        if (cacheDirStr.isEmpty()) {
+        if (cacheDirStr.isEmpty())
             cacheDirStr = args.get("graph.elevation.cachedir", "");
-        }
 
         String baseURL = args.get("graph.elevation.base_url", "");
-        if (baseURL.isEmpty()) {
+        if (baseURL.isEmpty())
             args.get("graph.elevation.baseurl", "");
-        }
 
         boolean removeTempElevationFiles = args.getBool("graph.elevation.cgiar.clear", true);
         removeTempElevationFiles = args.getBool("graph.elevation.clear", removeTempElevationFiles);
@@ -597,9 +581,8 @@ public GraphHopper init(CmdArgs args) {
 
         tmpProvider.setAutoRemoveTemporaryFiles(removeTempElevationFiles);
         tmpProvider.setCalcMean(eleCalcMean);
-        if (!baseURL.isEmpty()) {
+        if (!baseURL.isEmpty())
             tmpProvider.setBaseURL(baseURL);
-        }
         tmpProvider.setDAType(elevationDAType);
         setElevationProvider(tmpProvider);
 
@@ -631,9 +614,8 @@ public GraphHopper init(CmdArgs args) {
 
     private void printInfo() {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        if (ghStorage != null) {
+        if (ghStorage != null)
             logger.info("graph " + ghStorage.toString() + ", details:" + ghStorage.toDetailsString());
-        }
     }
 
     /**
@@ -661,18 +643,16 @@ private GraphHopper process(String graphHopperLocation) {
             if (ghStorage.getDirectory().getDefaultType().isStoring()) {
                 lockFactory.setLockDir(new File(graphHopperLocation));
                 lock = lockFactory.create(fileLockName, true);
-                if (!lock.tryLock()) {
+                if (!lock.tryLock())
                     throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
-                }
             }
 
             try {
                 DataReader reader = importData();
                 DateFormat f = createFormatter();
                 ghStorage.getProperties().put("datareader.import.date", f.format(new Date()));
-                if (reader.getDataDate() != null) {
+                if (reader.getDataDate() != null)
                     ghStorage.getProperties().put("datareader.data.date", f.format(reader.getDataDate()));
-                }
             } catch (IOException ex) {
                 throw new RuntimeException("Cannot read file " + getDataReaderFile(), ex);
             }
@@ -680,23 +660,20 @@ private GraphHopper process(String graphHopperLocation) {
             postProcessing();
             flush();
         } finally {
-            if (lock != null) {
+            if (lock != null)
                 lock.release();
-            }
         }
         return this;
     }
 
     protected DataReader importData() throws IOException {
         ensureWriteAccess();
-        if (ghStorage == null) {
+        if (ghStorage == null)
             throw new IllegalStateException("Load graph before importing OSM data");
-        }
 
-        if (dataReaderFile == null) {
+        if (dataReaderFile == null)
             throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
                                             + " but also cannot use file for DataReader as it wasn't specified!");
-        }
 
         DataReader reader = createReader(ghStorage);
         logger.info("using " + ghStorage.toString() + ", memory:" + getMemInfo());
@@ -710,9 +687,8 @@ protected DataReader createReader(GraphHopperStorage ghStorage) {
     }
 
     protected DataReader initDataReader(DataReader reader) {
-        if (dataReaderFile == null) {
+        if (dataReaderFile == null)
             throw new IllegalArgumentException("No file for DataReader specified");
-        }
 
         logger.info("start creating graph from " + dataReaderFile);
         return reader.setFile(new File(dataReaderFile)).
@@ -730,13 +706,11 @@ protected DataReader initDataReader(DataReader reader) {
      */
     @Override
     public boolean load(String graphHopperFolder) {
-        if (isEmpty(graphHopperFolder)) {
+        if (isEmpty(graphHopperFolder))
             throw new IllegalStateException("GraphHopperLocation is not specified. Call setGraphHopperLocation or init before");
-        }
 
-        if (fullyLoaded) {
+        if (fullyLoaded)
             throw new IllegalStateException("graph is already successfully loaded");
-        }
 
         File tmpFileOrFolder = new File(graphHopperFolder);
 
@@ -756,21 +730,18 @@ public boolean load(String graphHopperFolder) {
 
         setGraphHopperLocation(graphHopperFolder);
 
-        if (encodingManager == null) {
+        if (encodingManager == null)
             setEncodingManager(EncodingManager.create(encodedValueFactory, flagEncoderFactory, ghLocation));
-        }
 
-        if (!allowWrites && dataAccessType.isMMap()) {
+        if (!allowWrites && dataAccessType.isMMap())
             dataAccessType = DAType.MMAP_RO;
-        }
 
         GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
         GraphExtension ext = encodingManager.needsTurnCostsSupport()
                              ? new TurnCostExtension() : new GraphExtension.NoOpExtension();
 
-        if (lmFactoryDecorator.isEnabled()) {
+        if (lmFactoryDecorator.isEnabled())
             initLMAlgoFactoryDecorator();
-        }
 
         if (chFactoryDecorator.isEnabled()) {
             initCHAlgoFactoryDecorator();
@@ -782,9 +753,8 @@ public boolean load(String graphHopperFolder) {
 
         ghStorage.setSegmentSize(defaultSegmentSize);
 
-        if (!new File(graphHopperFolder).exists()) {
+        if (!new File(graphHopperFolder).exists())
             return false;
-        }
 
         GHLock lock = null;
         try {
@@ -793,40 +763,35 @@ public boolean load(String graphHopperFolder) {
             if (ghStorage.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
                 lockFactory.setLockDir(new File(ghLocation));
                 lock = lockFactory.create(fileLockName, false);
-                if (!lock.tryLock()) {
+                if (!lock.tryLock())
                     throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
-                }
             }
 
-            if (!ghStorage.loadExisting()) {
+            if (!ghStorage.loadExisting())
                 return false;
-            }
 
             postProcessing();
             fullyLoaded = true;
             return true;
         } finally {
-            if (lock != null) {
+            if (lock != null)
                 lock.release();
-            }
         }
     }
 
     public RoutingAlgorithmFactory getAlgorithmFactory(HintsMap map) {
         RoutingAlgorithmFactory routingAlgorithmFactory = new RoutingAlgorithmFactorySimple();
         for (RoutingAlgorithmFactoryDecorator decorator : algoDecorators) {
-            if (decorator.isEnabled()) {
+            if (decorator.isEnabled())
                 routingAlgorithmFactory = decorator.getDecoratedAlgorithmFactory(routingAlgorithmFactory, map);
-            }
         }
 
         return routingAlgorithmFactory;
     }
 
     public GraphHopper addAlgorithmFactoryDecorator(RoutingAlgorithmFactoryDecorator algoFactoryDecorator) {
-        if (!algoDecorators.add(algoFactoryDecorator)) {
+        if (!algoDecorators.add(algoFactoryDecorator))
             throw new IllegalArgumentException("Decorator was already added " + algoFactoryDecorator.getClass());
-        }
 
         return this;
     }
@@ -857,9 +822,8 @@ public final LMAlgoFactoryDecorator getLMFactoryDecorator() {
     }
 
     private void initLMAlgoFactoryDecorator() {
-        if (lmFactoryDecorator.hasWeightings()) {
+        if (lmFactoryDecorator.hasWeightings())
             return;
-        }
 
         for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders()) {
             for (String lmWeightingStr : lmFactoryDecorator.getWeightingsAsStrings()) {
@@ -877,9 +841,8 @@ public void postProcessing() {
         // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
 
         if (sortGraph) {
-            if (ghStorage.isCHPossible() && isCHPrepared()) {
+            if (ghStorage.isCHPossible() && isCHPrepared())
                 throw new IllegalArgumentException("Sorting a prepared CHGraph is not possible yet. See #12");
-            }
 
             GraphHopperStorage newGraph = GHUtility.newStorage(ghStorage);
             GHUtility.sortDFS(ghStorage, newGraph);
@@ -893,16 +856,13 @@ public void postProcessing() {
 
         initLocationIndex();
 
-        if (chFactoryDecorator.isEnabled()) {
+        if (chFactoryDecorator.isEnabled())
             chFactoryDecorator.createPreparations(ghStorage);
-        }
-        if (!isCHPrepared()) {
+        if (!isCHPrepared())
             prepareCH();
-        }
 
-        if (lmFactoryDecorator.isEnabled()) {
+        if (lmFactoryDecorator.isEnabled())
             lmFactoryDecorator.createPreparations(ghStorage, locationIndex);
-        }
         loadOrPrepareLM();
     }
 
@@ -946,23 +906,20 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
         } else if ("shortest".equalsIgnoreCase(weightingStr)) {
             weighting = new ShortestWeighting(encoder);
         } else if ("fastest".equalsIgnoreCase(weightingStr) || weightingStr.isEmpty()) {
-            if (encoder.supports(PriorityWeighting.class)) {
+            if (encoder.supports(PriorityWeighting.class))
                 weighting = new PriorityWeighting(encoder, hintsMap);
-            } else {
+            else
                 weighting = new FastestWeighting(encoder, hintsMap);
-            }
         } else if ("curvature".equalsIgnoreCase(weightingStr)) {
-            if (encoder.supports(CurvatureWeighting.class)) {
+            if (encoder.supports(CurvatureWeighting.class))
                 weighting = new CurvatureWeighting(encoder, hintsMap);
-            }
 
         } else if ("short_fastest".equalsIgnoreCase(weightingStr)) {
             weighting = new ShortFastestWeighting(encoder, hintsMap);
         }
 
-        if (weighting == null) {
+        if (weighting == null)
             throw new IllegalArgumentException("weighting " + weightingStr + " not supported");
-        }
 
         if (hintsMap.has(Routing.BLOCK_AREA)) {
             String blockAreaStr = hintsMap.get(Parameters.Routing.BLOCK_AREA, "");
@@ -977,11 +934,10 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
     /**
      * Potentially wraps the specified weighting into a TurnWeighting instance.
      */
-    private Weighting createTurnWeighting(Graph graph, Weighting weighting, TraversalMode tMode) {
+    public Weighting createTurnWeighting(Graph graph, Weighting weighting, TraversalMode tMode) {
         FlagEncoder encoder = weighting.getFlagEncoder();
-        if (encoder.supports(TurnWeighting.class) && tMode.isEdgeBased()) {
+        if (encoder.supports(TurnWeighting.class) && tMode.isEdgeBased())
             return new TurnWeighting(weighting, (TurnCostExtension) graph.getExtension());
-        }
         return weighting;
     }
 
@@ -996,166 +952,156 @@ public GHResponse route(GHRequest request) {
      * This method calculates the alternative path list using the low level Path objects.
      */
     public List<Path> calcPaths(GHRequest request, GHResponse ghRsp) {
-        failOnIllegalStorageStates();
-
-        String vehicle = buildVehicle(request);
-
-        Lock readLock = readWriteLock.readLock();
-        readLock.lock();
-
-        HintsMap hints = request.getHints();
-        String tModeStr = hints.get("traversal_mode", traversalMode.toString());
-        TraversalMode tMode = TraversalMode.fromString(tModeStr);
-        if (hints.has(Routing.EDGE_BASED)) {
-            tMode = hints.getBool(Routing.EDGE_BASED, false) ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
-        }
-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
-
-        boolean disableCH = hints.getBool(CH.DISABLE, false);
-        if (!chFactoryDecorator.isDisablingAllowed() && disableCH) {
-            return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Disabling CH not allowed on the server-side");
-        }
+        if (ghStorage == null || !fullyLoaded)
+            throw new IllegalStateException("Do a successful call to load or importOrLoad before routing");
 
-        boolean disableLM = hints.getBool(Landmark.DISABLE, false);
-        if (!lmFactoryDecorator.isDisablingAllowed() && disableLM) {
-            return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Disabling LM not allowed on the server-side");
-        }
+        if (ghStorage.isClosed())
+            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
 
-        String algoStr = request.getAlgorithm();
-        if (algoStr.isEmpty()) {
-            algoStr = isCHUsageGranted(disableCH) ? DIJKSTRA_BI : ASTAR_BI;
+        // default handling
+        String vehicle = request.getVehicle();
+        if (vehicle.isEmpty()) {
+            vehicle = getDefaultVehicle().toString();
+            request.setVehicle(vehicle);
         }
 
-        List<GHPoint> points = request.getPoints();
-        Polygon polygon = request.getPolygon();
-        // TODO Maybe we should think about a isRequestValid method that checks all that stuff that we could do to fail fast
-        // For example see #734
-        checkIfPointsAreInBounds(points);
-        checkIfPointsAreInBounds(polygon.getCoordinatesAsGHPoints());
-
-        RoutingTemplate routingTemplate = buildRoutingTemplate(request, ghRsp, algoStr);
-
-        List<Path> altPaths = null;
-        int maxRetries = routingTemplate.getMaxRetries();
-        Locale locale = request.getLocale();
-        Translation tr = trMap.getWithFallBack(locale);
-        for (int i = 0; i < maxRetries; i++) {
-            StopWatch sw = new StopWatch().start();
-            List<QueryResult> qResults = routingTemplate.lookup(points, encoder);
-            ghRsp.addDebugInfo("idLookup:" + sw.stop().getSeconds() + "s");
-            if (ghRsp.hasErrors()) {
-                return Collections.emptyList();
-            }
-
-            RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory(hints);
-
-            Weighting weighting;
-            QueryGraph queryGraph;
-            BuilderForWeightingAndQueryGraph builderForWeightingAndQueryGraph =
-                    new BuilderForWeightingAndQueryGraph(request, ghRsp, hints, encoder, disableCH, points, qResults, tmpAlgoFactory).invoke();
-            if (builderForWeightingAndQueryGraph.is()) {
-                return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Heading is not (fully) supported for CHGraph. See issue #483");
-            }
-            weighting = builderForWeightingAndQueryGraph.getWeighting();
-            queryGraph = builderForWeightingAndQueryGraph.getQueryGraph();
-            ghRsp.addDebugInfo("tmode:" + tMode.toString());
+        Lock readLock = readWriteLock.readLock();
+        readLock.lock();
+        try {
+            if (!encodingManager.hasEncoder(vehicle))
+                throw new IllegalArgumentException("Vehicle not supported: " + vehicle + ". Supported are: " + encodingManager.toString());
+
+            HintsMap hints = request.getHints();
+            String tModeStr = hints.get("traversal_mode", traversalMode.toString());
+            TraversalMode tMode = TraversalMode.fromString(tModeStr);
+            if (hints.has(Routing.EDGE_BASED))
+                tMode = hints.getBool(Routing.EDGE_BASED, false) ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
+
+            FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+
+            boolean disableCH = hints.getBool(CH.DISABLE, false);
+            if (!chFactoryDecorator.isDisablingAllowed() && disableCH)
+                throw new IllegalArgumentException("Disabling CH not allowed on the server-side");
+
+            boolean disableLM = hints.getBool(Landmark.DISABLE, false);
+            if (!lmFactoryDecorator.isDisablingAllowed() && disableLM)
+                throw new IllegalArgumentException("Disabling LM not allowed on the server-side");
+
+            String algoStr = request.getAlgorithm();
+            if (algoStr.isEmpty())
+                algoStr = chFactoryDecorator.isEnabled() && !disableCH ? DIJKSTRA_BI : ASTAR_BI;
+
+            List<GHPoint> points = request.getPoints();
+            Polygon polygon = request.getPolygon();
+            // TODO Maybe we should think about a isRequestValid method that checks all that stuff that we could do to fail fast
+            // For example see #734
+            checkIfPointsAreInBounds(points);
+            checkIfPointsAreInBounds(polygon.getCoordinatesAsGHPoints());
+
+            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, algoStr);
+
+            List<Path> altPaths = null;
+            int maxRetries = routingTemplate.getMaxRetries();
+            Locale locale = request.getLocale();
+            Translation tr = trMap.getWithFallBack(locale);
+            for (int i = 0; i < maxRetries; i++) {
+                StopWatch sw = new StopWatch().start();
+                List<QueryResult> qResults = routingTemplate.lookup(points, encoder);
+                ghRsp.addDebugInfo("idLookup:" + sw.stop().getSeconds() + "s");
+                if (ghRsp.hasErrors())
+                    return Collections.emptyList();
+
+                RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory(hints);
+                Weighting weighting;
+                QueryGraph queryGraph;
+
+                if (chFactoryDecorator.isEnabled() && !disableCH) {
+                    boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);
+                    if (!forceCHHeading && request.hasFavoredHeading(0))
+                        throw new IllegalArgumentException("Heading is not (fully) supported for CHGraph. See issue #483");
+
+                    // if LM is enabled we have the LMFactory with the CH algo!
+                    RoutingAlgorithmFactory chAlgoFactory = tmpAlgoFactory;
+                    if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory)
+                        chAlgoFactory = ((LMAlgoFactoryDecorator.LMRAFactory) tmpAlgoFactory).getDefaultAlgoFactory();
+
+                    if (chAlgoFactory instanceof PrepareContractionHierarchies)
+                        weighting = ((PrepareContractionHierarchies) chAlgoFactory).getWeighting();
+                    else
+                        throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
+
+                    queryGraph = new QueryGraph(ghStorage.getCHGraph(weighting));
+                    queryGraph.lookup(qResults);
+                } else {
+                    checkNonChMaxWaypointDistance(points);
+                    queryGraph = new QueryGraph(ghStorage);
+                    queryGraph.lookup(qResults);
+                    weighting = createWeighting(hints, encoder, queryGraph);
+                }
+                ghRsp.addDebugInfo("tmode:" + tMode.toString());
 
-            int maxVisitedNodesForRequest = hints.getInt(Routing.MAX_VISITED_NODES, maxVisitedNodes);
-            if (failOnMaxVisitedNodesForRequestExceedsLimit(maxVisitedNodesForRequest)) {
-                return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "The max_visited_nodes parameter has to be below or equal to:" + maxVisitedNodes);
-            }
+                int maxVisitedNodesForRequest = hints.getInt(Routing.MAX_VISITED_NODES, maxVisitedNodes);
+                if (maxVisitedNodesForRequest > maxVisitedNodes)
+                    throw new IllegalArgumentException("The max_visited_nodes parameter has to be below or equal to:" + maxVisitedNodes);
 
-            weighting = createTurnWeighting(queryGraph, weighting, tMode);
+                weighting = createTurnWeighting(queryGraph, weighting, tMode);
 
-            AlgorithmOptions algoOpts = buildAlgorithmOptions(hints, tMode, algoStr, weighting, maxVisitedNodesForRequest);
+                AlgorithmOptions algoOpts = createAlgorithmOptions(hints, tMode, algoStr, weighting, maxVisitedNodesForRequest);
 
-            // do the actual route calculation !
-            altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
+                // do the actual route calculation !
+                altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
 
-            boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
-            boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
-            double wayPointMaxDistance = hints.getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);
+                boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
+                boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
+                double wayPointMaxDistance = hints.getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);
 
-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
-            PathMerger pathMerger = buildPathMerger(request, tmpEnableInstructions, tmpCalcPoints, wayPointMaxDistance, peucker);
+                DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
+                PathMerger pathMerger = createPathMerger(request, tmpEnableInstructions, tmpCalcPoints, wayPointMaxDistance, peucker);
 
-            if (request.hasFavoredHeading(0)) {
-                pathMerger.setFavoredHeading(request.getFavoredHeading(0));
-            }
+                if (request.hasFavoredHeading(0))
+                    pathMerger.setFavoredHeading(request.getFavoredHeading(0));
 
-            if (routingTemplate.isReady(pathMerger, tr)) {
-                break;
+                if (routingTemplate.isReady(pathMerger, tr))
+                    break;
             }
-        }
 
-        readLock.unlock();
-        return altPaths;
-    }
+            return altPaths;
 
-    private boolean isCHUsageGranted(boolean disableCH) {
-        return chFactoryDecorator.isEnabled() && !disableCH;
-    }
-
-    private boolean failOnMaxVisitedNodesForRequestExceedsLimit(int maxVisitedNodesForRequest) {
-        return maxVisitedNodesForRequest > maxVisitedNodes;
-    }
-
-    private List<Path> addIllegalArgumentExceptionAndReturnEmptyCollection(GHResponse ghRsp, String s) {
-        Exception ex = new IllegalArgumentException(s);
-        ghRsp.addError(ex);
-        return Collections.emptyList();
-    }
-
-    private String buildVehicle(GHRequest request) {
-        String vehicle = request.getVehicle();
-        if (vehicle.isEmpty()) {
-            vehicle = getDefaultVehicle().toString();
-            request.setVehicle(vehicle);
-        }
-        if (!encodingManager.hasEncoder(vehicle)) {
-            throw new IllegalArgumentException("Vehicle not supported: " + vehicle + ". Supported are: " + encodingManager.toString());
-        }
-        return vehicle;
-    }
-
-    private void failOnIllegalStorageStates() {
-        if (ghStorage == null || !fullyLoaded) {
-            throw new IllegalStateException("Do a successful call to load or importOrLoad before routing");
-        }
-
-        if (ghStorage.isClosed()) {
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+        } catch (IllegalArgumentException ex) {
+            ghRsp.addError(ex);
+            return Collections.emptyList();
+        } finally {
+            readLock.unlock();
         }
     }
 
-    private PathMerger buildPathMerger(GHRequest request, boolean tmpEnableInstructions, boolean tmpCalcPoints, double wayPointMaxDistance, DouglasPeucker peucker) {
+    private PathMerger createPathMerger(GHRequest request, boolean tmpEnableInstructions, boolean tmpCalcPoints, double wayPointMaxDistance, DouglasPeucker peucker) {
         return new PathMerger().
-                setCalcPoints(tmpCalcPoints).
-                setDouglasPeucker(peucker).
-                setEnableInstructions(tmpEnableInstructions).
-                setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
-                setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
+                            setCalcPoints(tmpCalcPoints).
+                            setDouglasPeucker(peucker).
+                            setEnableInstructions(tmpEnableInstructions).
+                            setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
+                            setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
     }
 
-    private AlgorithmOptions buildAlgorithmOptions(HintsMap hints, TraversalMode tMode, String algoStr, Weighting weighting, int maxVisitedNodesForRequest) {
+    private AlgorithmOptions createAlgorithmOptions(HintsMap hints, TraversalMode tMode, String algoStr, Weighting weighting, int maxVisitedNodesForRequest) {
         return AlgorithmOptions.start().
-                algorithm(algoStr).traversalMode(tMode).weighting(weighting).
-                maxVisitedNodes(maxVisitedNodesForRequest).
-                hints(hints).
-                build();
+                            algorithm(algoStr).traversalMode(tMode).weighting(weighting).
+                            maxVisitedNodes(maxVisitedNodesForRequest).
+                            hints(hints).
+                            build();
     }
 
-    private RoutingTemplate buildRoutingTemplate(GHRequest request, GHResponse ghRsp, String algoStr) {
+    private RoutingTemplate createRoutingTemplate(GHRequest request, GHResponse ghRsp, String algoStr) {
         RoutingTemplate routingTemplate;
-        if (ROUND_TRIP.equalsIgnoreCase(algoStr)) {
+        if (ROUND_TRIP.equalsIgnoreCase(algoStr))
             routingTemplate = new RoundTripRoutingTemplate(request, ghRsp, locationIndex, encodingManager, maxRoundTripRetries);
-        } else if (ALT_ROUTE.equalsIgnoreCase(algoStr)) {
+        else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
             routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
-        } else if (validPolygonInRequest(request)) {
+        else if (validPolygonInRequest(request))
             routingTemplate = new PolygonThroughRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
-        } else {
+        else
             routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
-        }
         return routingTemplate;
     }
 
@@ -1170,9 +1116,8 @@ private boolean validPolygonInRequest(GHRequest request) {
      */
     public ChangeGraphResponse changeGraph(Collection<JsonFeature> collection) {
         // TODO allow calling this method if called before CH preparation
-        if (getCHFactoryDecorator().isEnabled()) {
+        if (getCHFactoryDecorator().isEnabled())
             throw new IllegalArgumentException("To use the changeGraph API you need to turn off CH");
-        }
 
         Lock writeLock = readWriteLock.writeLock();
         writeLock.lock();
@@ -1199,6 +1144,27 @@ private void checkIfPointsAreInBounds(List<GHPoint> points) {
         }
     }
 
+    private void checkNonChMaxWaypointDistance(List<GHPoint> points) {
+        if (nonChMaxWaypointDistance == Integer.MAX_VALUE) {
+            return;
+        }
+        GHPoint lastPoint = points.get(0);
+        GHPoint point;
+        double dist;
+        DistanceCalc calc = DIST_3D;
+        for (int i = 1; i < points.size(); i++) {
+            point = points.get(i);
+            dist = calc.calcDist(lastPoint.getLat(), lastPoint.getLon(), point.getLat(), point.getLon());
+            if (dist > nonChMaxWaypointDistance) {
+                Map<String, Object> detailMap = new HashMap<>(2);
+                detailMap.put("from", i - 1);
+                detailMap.put("to", i);
+                throw new PointDistanceExceededException("Point " + i + " is too far from Point " + (i - 1) + ": " + point, detailMap);
+            }
+            lastPoint = point;
+        }
+    }
+
     protected LocationIndex createLocationIndex(Directory dir) {
         LocationIndexTree tmpIndex = new LocationIndexTree(ghStorage, dir);
         tmpIndex.setResolution(preciseIndexResolution);
@@ -1214,10 +1180,9 @@ protected LocationIndex createLocationIndex(Directory dir) {
     /**
      * Initializes the location index after the import is done.
      */
-    private void initLocationIndex() {
-        if (locationIndex != null) {
+    protected void initLocationIndex() {
+        if (locationIndex != null)
             throw new IllegalStateException("Cannot initialize locationIndex twice!");
-        }
 
         locationIndex = createLocationIndex(ghStorage.getDirectory());
     }
@@ -1251,9 +1216,8 @@ protected void loadOrPrepareLM() {
         if (tmpPrepare) {
             ensureWriteAccess();
             ghStorage.freeze();
-            if (lmFactoryDecorator.loadOrDoWork(ghStorage.getProperties())) {
+            if (lmFactoryDecorator.loadOrDoWork(ghStorage.getProperties()))
                 ghStorage.getProperties().put(Landmark.PREPARE + "done", true);
-            }
         }
     }
 
@@ -1286,13 +1250,11 @@ protected void flush() {
      * remove the files created in graphhopperLocation you have to call clean().
      */
     public void close() {
-        if (ghStorage != null) {
+        if (ghStorage != null)
             ghStorage.close();
-        }
 
-        if (locationIndex != null) {
+        if (locationIndex != null)
             locationIndex.close();
-        }
 
         try {
             lockFactory.forceRemove(fileLockName, true);
@@ -1306,194 +1268,25 @@ public void close() {
      * load
      */
     public void clean() {
-        if (getGraphHopperLocation().isEmpty()) {
+        if (getGraphHopperLocation().isEmpty())
             throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
-        }
 
         File folder = new File(getGraphHopperLocation());
         removeDir(folder);
     }
 
-    private void ensureNotLoaded() {
-        if (fullyLoaded) {
+    protected void ensureNotLoaded() {
+        if (fullyLoaded)
             throw new IllegalStateException("No configuration changes are possible after loading the graph");
-        }
     }
 
-    private void ensureWriteAccess() {
-        if (!allowWrites) {
+    protected void ensureWriteAccess() {
+        if (!allowWrites)
             throw new IllegalStateException("Writes are not allowed!");
-        }
     }
 
     public void setNonChMaxWaypointDistance(int nonChMaxWaypointDistance) {
         this.nonChMaxWaypointDistance = nonChMaxWaypointDistance;
     }
 
-    private class BuilderForQueryGraphAndWeightingWithCHEnabled {
-        private boolean myResult;
-        private final GHRequest request;
-        private final GHResponse ghRsp;
-        private final HintsMap hints;
-        private final List<QueryResult> qResults;
-        private final RoutingAlgorithmFactory tmpAlgoFactory;
-        private Weighting weighting;
-        private QueryGraph queryGraph;
-
-        BuilderForQueryGraphAndWeightingWithCHEnabled(GHRequest request, GHResponse ghRsp, HintsMap hints, List<QueryResult> qResults, RoutingAlgorithmFactory tmpAlgoFactory) {
-            this.request = request;
-            this.ghRsp = ghRsp;
-            this.hints = hints;
-            this.qResults = qResults;
-            this.tmpAlgoFactory = tmpAlgoFactory;
-        }
-
-        boolean is() {
-            return myResult;
-        }
-
-        Weighting getWeighting() {
-            return weighting;
-        }
-
-        QueryGraph getQueryGraph() {
-            return queryGraph;
-        }
-
-        BuilderForQueryGraphAndWeightingWithCHEnabled invoke() {
-            boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);
-            if (!forceCHHeading && request.hasFavoredHeading(0)) {
-                myResult = true;
-                return this;
-            }
-
-            // if LM is enabled we have the LMFactory with the CH algo!
-            RoutingAlgorithmFactory chAlgoFactory = tmpAlgoFactory;
-            if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory) {
-                chAlgoFactory = ((LMAlgoFactoryDecorator.LMRAFactory) tmpAlgoFactory).getDefaultAlgoFactory();
-            }
-
-            if (chAlgoFactory instanceof PrepareContractionHierarchies) {
-                weighting = ((PrepareContractionHierarchies) chAlgoFactory).getWeighting();
-            } else {
-                throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
-            }
-
-            queryGraph = new QueryGraph(ghStorage.getCHGraph(weighting));
-            queryGraph.lookup(qResults);
-            myResult = false;
-            return this;
-        }
-    }
-
-    private class BuilderForQueryGraphAndWeightingWithCHDisabled {
-        private final HintsMap hints;
-        private final FlagEncoder encoder;
-        private final List<GHPoint> points;
-        private final List<QueryResult> qResults;
-        private Weighting weighting;
-        private QueryGraph queryGraph;
-
-        BuilderForQueryGraphAndWeightingWithCHDisabled(HintsMap hints, FlagEncoder encoder, List<GHPoint> points, List<QueryResult> qResults) {
-            this.hints = hints;
-            this.encoder = encoder;
-            this.points = points;
-            this.qResults = qResults;
-        }
-
-        Weighting getWeighting() {
-            return weighting;
-        }
-
-        QueryGraph getQueryGraph() {
-            return queryGraph;
-        }
-
-        BuilderForQueryGraphAndWeightingWithCHDisabled invoke() {
-            checkNonChMaxWaypointDistance(points);
-            queryGraph = new QueryGraph(ghStorage);
-            queryGraph.lookup(qResults);
-            weighting = createWeighting(hints, encoder, queryGraph);
-            return this;
-        }
-
-        private void checkNonChMaxWaypointDistance(List<GHPoint> points) {
-            if (nonChMaxWaypointDistance == Integer.MAX_VALUE) {
-                return;
-            }
-            GHPoint lastPoint = points.get(0);
-            GHPoint point;
-            double dist;
-            DistanceCalc calc = DIST_3D;
-            for (int i = 1; i < points.size(); i++) {
-                point = points.get(i);
-                dist = calc.calcDist(lastPoint.getLat(), lastPoint.getLon(), point.getLat(), point.getLon());
-                if (dist > nonChMaxWaypointDistance) {
-                    Map<String, Object> detailMap = new HashMap<>(2);
-                    detailMap.put("from", i - 1);
-                    detailMap.put("to", i);
-                    throw new PointDistanceExceededException("Point " + i + " is too far from Point " + (i - 1) + ": " + point, detailMap);
-                }
-                lastPoint = point;
-            }
-        }
-    }
-
-    private class BuilderForWeightingAndQueryGraph {
-        private boolean myResult;
-        private final GHRequest request;
-        private final GHResponse ghRsp;
-        private final HintsMap hints;
-        private final FlagEncoder encoder;
-        private final boolean disableCH;
-        private final List<GHPoint> points;
-        private final List<QueryResult> qResults;
-        private final RoutingAlgorithmFactory tmpAlgoFactory;
-        private Weighting weighting;
-        private QueryGraph queryGraph;
-
-        BuilderForWeightingAndQueryGraph(GHRequest request, GHResponse ghRsp, HintsMap hints, FlagEncoder encoder, boolean disableCH, List<GHPoint> points,
-                                         List<QueryResult> qResults, RoutingAlgorithmFactory tmpAlgoFactory) {
-            this.request = request;
-            this.ghRsp = ghRsp;
-            this.hints = hints;
-            this.encoder = encoder;
-            this.disableCH = disableCH;
-            this.points = points;
-            this.qResults = qResults;
-            this.tmpAlgoFactory = tmpAlgoFactory;
-        }
-
-        boolean is() {
-            return myResult;
-        }
-
-        Weighting getWeighting() {
-            return weighting;
-        }
-
-        QueryGraph getQueryGraph() {
-            return queryGraph;
-        }
-
-        BuilderForWeightingAndQueryGraph invoke() {
-            if (isCHUsageGranted(disableCH)) {
-                BuilderForQueryGraphAndWeightingWithCHEnabled builderForQueryGraphAndWeightingWithCHEnabled =
-                        new BuilderForQueryGraphAndWeightingWithCHEnabled(request, ghRsp, hints, qResults, tmpAlgoFactory).invoke();
-                if (builderForQueryGraphAndWeightingWithCHEnabled.is()) {
-                    myResult = true;
-                    return this;
-                }
-                weighting = builderForQueryGraphAndWeightingWithCHEnabled.getWeighting();
-                queryGraph = builderForQueryGraphAndWeightingWithCHEnabled.getQueryGraph();
-            } else {
-                BuilderForQueryGraphAndWeightingWithCHDisabled builderForQueryGraphAndWeightingWithCHDisabled =
-                        new BuilderForQueryGraphAndWeightingWithCHDisabled(hints, encoder, points, qResults).invoke();
-                weighting = builderForQueryGraphAndWeightingWithCHDisabled.getWeighting();
-                queryGraph = builderForQueryGraphAndWeightingWithCHDisabled.getQueryGraph();
-            }
-            myResult = false;
-            return this;
-        }
-    }
-}
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 2c3babcbf4..08e8339aac 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -88,6 +88,7 @@ public Path(Graph graph, Weighting weighting) {
     }
 
     protected void buildThisPathFromAnotherPath(Path p) {
+        time = p.time;
         weight = p.weight;
         edgeIds = new GHIntArrayList(p.edgeIds);
         sptEntry = p.sptEntry;
@@ -182,6 +183,8 @@ public long getTime() {
         return time;
     }
 
+    public void setTime(final long time) { this.time = time;}
+
     /**
      * This weight will be updated during the algorithm. The initial value is maximum double.
      */
diff --git a/core/src/main/java/com/graphhopper/routing/PathMerge.java b/core/src/main/java/com/graphhopper/routing/PathMerge.java
index e0741d96a8..35fe7c28fa 100644
--- a/core/src/main/java/com/graphhopper/routing/PathMerge.java
+++ b/core/src/main/java/com/graphhopper/routing/PathMerge.java
@@ -2,7 +2,6 @@
 
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIteratorState;
 
 import java.util.List;
@@ -19,6 +18,16 @@ public Path extract() {
     }
 
     public void addPath(final Path newPath) {
+        if (isPathNotEmpty(newPath)) {
+            addIfNewPathIsntEmpty(newPath);
+        }
+    }
+
+    private boolean isPathNotEmpty(Path newPath) {
+        return newPath.edgeIds.size() > 0;
+    }
+
+    private void addIfNewPathIsntEmpty(Path newPath) {
         if (this.edgeIds.size() > 0) {
             addIfThisPathIsntEmpty(newPath);
         } else {
@@ -38,6 +47,7 @@ private void mergePaths(Path newPath, List<EdgeIteratorState> otherPathsEdges) {
         addOtherPathsEdgesToThisPath(otherPathsEdges);
         this.weight += newPath.getWeight();
         this.distance += newPath.distance;
+        this.time += newPath.time;
         this.endNode = newPath.endNode;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 407025a19f..c6b1294cf9 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -745,6 +745,10 @@ private UnsupportedOperationException exc() {
         return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
 
+    public Graph getMainGraph() {
+        return this.mainGraph;
+    }
+
     class QueryGraphTurnExt extends TurnCostExtension {
         private final TurnCostExtension mainTurnExtension;
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index fb570c047b..06f9f5a693 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -34,7 +34,7 @@
     @Override
     public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
         if (this.ghRequest.getPoints().size() != 2) {
-            // TODO implement for more than start & endpoint
+            // TODO implement for more than start & endpoint but also via points
             throw new NotImplementedException();
         }
         this.setCalcPathsParams(queryGraph, algoFactory, algoOpts);
@@ -71,10 +71,10 @@ private void prepareRouteCandidateList() {
 
     private void pruneLowerQuantileInROIcandidateRoutes() {
         // Assumes that routeCandidates was already sorted descending to roi distance after pruning dominated route candidates
-        final int startIndex = (int) (this.routeCandidates.getCandidates().size() * 0.75) + 1;
+        final int startIndex = (int) (this.routeCandidates.size() * 0.75) + 1;
 
-        for (int i = startIndex; i < this.routeCandidates.getCandidates().size(); i++) {
-            this.routeCandidates.getCandidates().remove(i);
+        for (int i = startIndex; i < this.routeCandidates.size(); i++) {
+            this.routeCandidates.remove(i);
         }
     }
 
@@ -84,9 +84,9 @@ private void pruneLowerQuantileInROIcandidateRoutes() {
     public boolean isReady(PathMerger pathMerger, Translation translation) {
         this.failOnNumPathsInvalid(this.ghRequest, this.pathList);
 
-        // TODO check if all waypoints have been queried. Respectively: The entry exit points: Are they queried? Do They have to be queried or mustnt they be queried?
         this.altResponse.setWaypoints(getWaypoints());
         this.ghResponse.add(this.altResponse);
+        System.out.println(this.pathList.get(0).getNodesInPathOrder().toString());
         pathMerger.doWork(this.altResponse, this.pathList, this.encodingManager, translation);
         return true;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
index 1c34e79b83..f3fbf08546 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -103,7 +103,7 @@ private void buildRouteCandidatesForCurrentPoint(final int currentViaPoint, fina
         for (final int LOTNodeL : currentPointsLOTNodes) {
             for (final int LOTNodeLPrime : currentPointsLOTNodes) {
                 if (LOTNodeL != LOTNodeLPrime) {
-                    this.routeCandidates.getCandidates().add(buildCandidatePath(currentViaPoint, nextViaPoint, LOTNodeL, LOTNodeLPrime));
+                    this.routeCandidates.add(buildCandidatePath(currentViaPoint, nextViaPoint, LOTNodeL, LOTNodeLPrime));
                 }
             }
         }
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
index fe1af42768..a455c4b8fd 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
@@ -29,15 +29,12 @@ public OneToManyRouting(final int fromNode, final List<Integer> toNodes, List<In
     }
 
     void calculatePaths() {
-        StopWatch sw = new StopWatch("one to many routing complete");
-        sw.start();
         for (final int toNode : toNodes) {
+            final int lala = toNode;
             final RoutingAlgorithm routingAlgorithm = buildRoutingAlgorithmForFromToPair(toNode);
             final Path path = routingAlgorithm.calcPath(this.fromNode, toNode);
             this.allFoundPaths.put(new Pair<>(this.fromNode, toNode), path);
         }
-        sw.stop();
-        System.out.println(sw.toString());
     }
 
     private RoutingAlgorithm buildRoutingAlgorithmForFromToPair(int toNode) {
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
index 54707a90a7..f7279f7533 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
@@ -17,18 +17,18 @@ public RouteCandidateList() {
     }
 
     public void sortByGainAscending() {
-        Collections.sort(this.getCandidates());
+        Collections.sort(this.candidates);
     }
 
-    private void sortRouteCandidatesToDistanceInROIDescending() {
-        Collections.sort(this.getCandidates(), new Comparator<RouteCandidatePolygon>() {
+    private void sortRouteCandidatesToTimeInROIDescending() {
+        Collections.sort(this.candidates, new Comparator<RouteCandidatePolygon>() {
             @Override
             public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
-                double distanceDifference = rc1.getDistanceInROI() - rc2.getDistanceInROI();
+                double timeDifference = rc1.getTimeInROI() - rc2.getTimeInROI();
                 int output;
-                if (distanceDifference < 0) {
+                if (timeDifference < 0) {
                     output = 1;
-                } else if (distanceDifference == 0) {
+                } else if (timeDifference == 0) {
                     output = 0;
                 } else {
                     output = -1;
@@ -42,9 +42,9 @@ public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
     public List<Path> getFirstAsPathList(int nOfFirstElements, QueryGraph queryGraph, AlgorithmOptions algorithmOptions) {
         final List<Path> paths = new ArrayList<>(nOfFirstElements);
 
-        final int endOfCandidates = getCandidates().size() - 1;
+        final int endOfCandidates = this.candidates.size() - 1;
         paths.addAll(addPathsBasedOnIntersectionStatus(nOfFirstElements, queryGraph, algorithmOptions, endOfCandidates, false));
-        paths.addAll(addPathsBasedOnIntersectionStatus(nOfFirstElements, queryGraph, algorithmOptions, endOfCandidates, true));
+        paths.addAll(addPathsBasedOnIntersectionStatus(nOfFirstElements - paths.size(), queryGraph, algorithmOptions, endOfCandidates, true));
 
         return paths;
     }
@@ -54,7 +54,7 @@ public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
         List<Path> paths = new ArrayList<>(nOfFirstElements);
         int indexIntoCandidates = endOfCandidates;
         while (indexIntoCandidates >= 0 && paths.size() < nOfFirstElements) {
-            final RouteCandidatePolygon candidate = this.getCandidates().get(indexIntoCandidates);
+            final RouteCandidatePolygon candidate = this.candidates.get(indexIntoCandidates);
 
             if (candidate.isDetourSelfIntersecting(queryGraph, algorithmOptions) == addSelfIntersecting) {
                 paths.add(candidate.getMergedPath(queryGraph, algorithmOptions));
@@ -68,11 +68,11 @@ public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
 
     // Do it in a skyline problem pruning fashion
     public void pruneDominatedCandidateRoutes() {
-        this.sortRouteCandidatesToDistanceInROIDescending();
+        this.sortRouteCandidatesToTimeInROIDescending();
 
         int currentPruningCandidateIndex = 1;
         while (indexInCandidateBounds(currentPruningCandidateIndex)) {
-            RouteCandidatePolygon currentPruningCandidate = this.getCandidates().get(currentPruningCandidateIndex);
+            RouteCandidatePolygon currentPruningCandidate = this.candidates.get(currentPruningCandidateIndex);
 
             boolean foundDominatingPath = isThisCandidateDominatedByAny(currentPruningCandidateIndex, currentPruningCandidate);
 
@@ -84,7 +84,7 @@ private boolean isThisCandidateDominatedByAny(int currentPruningCandidateIndex,
         boolean foundDominatingPath = false;
         for (int i = currentPruningCandidateIndex - 1; i >= 0 && !foundDominatingPath; i--) {
             // routeCandidates must be sorted by now. Therefore dominators can only bbe found on lower indices than the current pruning candidate.
-            RouteCandidatePolygon possiblyBetterRouteCandidate = this.getCandidates().get(i);
+            RouteCandidatePolygon possiblyBetterRouteCandidate = this.candidates.get(i);
 
             if (isPruningCandidateDominated(currentPruningCandidate, possiblyBetterRouteCandidate)) {
                 foundDominatingPath = true;
@@ -95,7 +95,7 @@ private boolean isThisCandidateDominatedByAny(int currentPruningCandidateIndex,
 
     private int pruneOrUpdateIndex(int currentPruningCandidateIndex, boolean foundDominatingPath) {
         if (foundDominatingPath) {
-            this.getCandidates().remove(currentPruningCandidateIndex);
+            this.candidates.remove(currentPruningCandidateIndex);
         } else {
             currentPruningCandidateIndex++;
         }
@@ -103,16 +103,34 @@ private int pruneOrUpdateIndex(int currentPruningCandidateIndex, boolean foundDo
     }
 
     private boolean isPruningCandidateDominated(RouteCandidatePolygon currentPruningCandidate, RouteCandidatePolygon possiblyBetterRouteCandidate) {
-        return possiblyBetterRouteCandidate.getDistance() < currentPruningCandidate.getDistance() &&
-               possiblyBetterRouteCandidate.getDistanceInROI() > currentPruningCandidate.getDistanceInROI();
+        return possiblyBetterRouteCandidate.getTime() < currentPruningCandidate.getTime() &&
+               possiblyBetterRouteCandidate.getTimeInROI() > currentPruningCandidate.getTimeInROI();
     }
 
     private boolean indexInCandidateBounds(int currentPruningCandidateIndex) {
-        return currentPruningCandidateIndex < this.getCandidates().size();
+        return currentPruningCandidateIndex < this.candidates.size();
     }
 
-    public List<T> getCandidates() {
-        return candidates;
+    public int size() {
+        return this.candidates.size();
+    }
+
+    public void remove(Object o) {
+        this.candidates.remove(o);
+    }
+
+    public void add(T o) {
+        if (o.isLegalCandidate()) {
+            this.candidates.add(o);
+        }
+    }
+
+    public void clear() {
+        this.candidates.clear();
+    }
+
+    public T get(int i) {
+        return this.candidates.get(i);
     }
 
     void setCandidates(List<T> candidates) {
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
index 5a3736bab1..bdebc4734e 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
@@ -1,7 +1,6 @@
 package com.graphhopper.routing.template.polygonRoutingUtil;
 
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.template.PolygonRoutingTemplate;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -29,6 +28,53 @@ public RouteCandidatePolygon(final int startNodeID, final int endNodeID, final i
         this.detourEntryToDetourExit = detourEntryToDetourExit;
         this.detourExitToEnd = detourExitToEnd;
         this.directRouteStartEnd = directRouteStartEnd;
+
+        if (startNodeID == 906161 || startNodeID == 270195
+            || endNodeID == 906161 || endNodeID == 270195
+            || polygonEntryNodeID == 906161 || polygonEntryNodeID == 270195
+            || polygonExitNodeID == 906161 || polygonExitNodeID == 270195) {
+            System.out.println("hit2");
+        }
+
+//        if (startToDetourEntry.getNodesInPathOrder().contains(906161) && startToDetourEntry.getNodesInPathOrder().contains(270195)) {
+//            System.out.println("hit3");
+//        }
+//
+//        if (detourEntryToDetourExit.getNodesInPathOrder().contains(906161) && detourEntryToDetourExit.getNodesInPathOrder().contains(270195)) {
+//            System.out.println("hit4");
+//        }
+//
+//        if (detourExitToEnd.getNodesInPathOrder().contains(906161) && detourExitToEnd.getNodesInPathOrder().contains(270195)) {
+//            System.out.println("hit5");
+//        }
+//
+//        if (directRouteStartEnd.getNodesInPathOrder().contains(906161) && directRouteStartEnd.getNodesInPathOrder().contains(270195)) {
+//            System.out.println("hit6");
+//        }
+//
+//        for (EdgeIteratorState state : startToDetourEntry.calcEdges()) {
+//            if (state.getEdge() == 17733429) {
+//                System.out.println("hit7");
+//            }
+//        }
+//
+//        for (EdgeIteratorState state : detourEntryToDetourExit.calcEdges()) {
+//            if (state.getEdge() == 17733429) {
+//                System.out.println("hit8");
+//            }
+//        }
+//
+//        for (EdgeIteratorState state : detourExitToEnd.calcEdges()) {
+//            if (state.getEdge() == 17733429) {
+//                System.out.println("hit9");
+//            }
+//        }
+//
+//        for (EdgeIteratorState state : directRouteStartEnd.calcEdges()) {
+//            if (state.getEdge() == 17733429) {
+//                System.out.println("hit10");
+//            }
+//        }
     }
 
     public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
@@ -50,8 +96,8 @@ private void mergePath(QueryGraph queryGraph, AlgorithmOptions algoOpts) {
         this.mergedPath = completePathCandidate;
     }
 
-    public double getDistance() {
-        return this.startToDetourEntry.getDistance() + this.detourEntryToDetourExit.getDistance() + this.detourExitToEnd.getDistance();
+    public double getTime() {
+        return this.startToDetourEntry.getTime() + this.detourEntryToDetourExit.getTime() + this.detourExitToEnd.getTime();
     }
 
     /**
@@ -59,29 +105,19 @@ public double getDistance() {
      *
      * @return The approximated time spent in the region of interest
      */
-    public double getDistanceInROI() {
-        return this.detourEntryToDetourExit.getDistance();
+    public double getTimeInROI() {
+        return this.detourEntryToDetourExit.getTime();
     }
 
     public double getGain() {
         // + 1 to avoid division by zero
-        return this.getDistanceInROI() / (this.getDetourDistance() + 1);
+        return this.getTimeInROI() / (this.getDetourTime() + 1);
     }
 
-    public double getDetourDistance() {
-        return this.getDistance() - this.directRouteStartEnd.getDistance();
+    public double getDetourTime() {
+        return this.getTime() - this.directRouteStartEnd.getTime();
     }
 
-    /**
-     * Uses the sweepline algorithm of Michael Ian Shamos and Dan Hoey to find intersecting line segments induced by the edges of the merged path.
-     * <p>
-     * Reference:
-     * Michael Ian Shamos and Dan Hoey. Geometric intersection problems. In Proceedings
-     * of the 17th Annual IEEE Symposium on Foundations of Computer Science
-     * (FOCS '76), pages 208{215, 1976.
-     *
-     * @return true if at least one intersection occurs and false otherwise.
-     */
     public boolean isDetourSelfIntersecting(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
         mergePathIfNotDone(queryGraph, algoOpts);
 
@@ -127,10 +163,31 @@ public String toString() {
                     "endNodeID: " + endNodeID + ", " +
                     "polygonEntryNodeID: " + polygonEntryNodeID + ", " +
                     "polygonExitNodeID: " + polygonExitNodeID + ", " +
-                    "Distance: " + this.getDistance() + ", " +
-                    "DistanceInROI: " + getDistanceInROI() + ", " +
-                    "detour distance: " + getDetourDistance() + ", " +
+                    "Distance: " + this.getTime() + ", " +
+                    "DistanceInROI: " + getTimeInROI() + ", " +
+                    "detour distance: " + getDetourTime() + ", " +
                     "gain: " + this.getGain();
         return sb;
     }
+
+    public boolean isLegalCandidate() {
+        return isAllSubpathsValid();
+    }
+
+    private boolean isAllSubpathsValid() {
+        boolean allValid = true;
+        allValid &= isSubpathValid(this.startToDetourEntry);
+        allValid &= isSubpathValid(this.detourEntryToDetourExit);
+        allValid &= isSubpathValid(this.detourExitToEnd);
+
+        return allValid;
+    }
+
+    private static boolean isSubpathValid(final Path path) {
+        if (path != null) {
+            return path.isFound();
+        } else {
+            throw new IllegalStateException("Calculate paths before validating them.");
+        }
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index c2db769812..894ad80a00 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -89,7 +89,7 @@ public TestAlgoCollector assertDistance(EncodingManager encodingManager, AlgoHel
         PointList pointList = rsp.getPoints();
         double tmpDist = pointList.calcDistance(distCalc);
         if (Math.abs(rsp.getDistance() - tmpDist) > 2) {
-            errors.add(algoEntry + " path.getDistance was  " + rsp.getDistance()
+            errors.add(algoEntry + " path.getTime was  " + rsp.getDistance()
                     + "\t pointList.calcDistance was " + tmpDist + "\t (expected points " + oneRun.getLocs()
                     + ", expected distance " + oneRun.getDistance() + ") " + queryList);
         }
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index a8bbe1c3ad..a9c5584b9a 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -483,6 +483,9 @@ public CHEdgeIteratorImpl(BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter
 
         @Override
         public final IntsRef getFlags() {
+            if (edgeId == 17733429) {
+                System.out.println("hit");
+            }
             checkShortcut(false, "getFlags");
             return super.getFlags();
         }
@@ -598,11 +601,11 @@ protected final void selectEdgeAccess() {
         }
 
         public void checkShortcut(boolean shouldBeShortcut, String methodName) {
-            if (isShortcut()) {
-                if (!shouldBeShortcut)
-                    throw new IllegalStateException("Cannot call " + methodName + " on shortcut " + getEdge());
-            } else if (shouldBeShortcut)
-                throw new IllegalStateException("Method " + methodName + " only for shortcuts " + getEdge());
+//            if (isShortcut()) {
+//                if (!shouldBeShortcut)
+//                    throw new IllegalStateException("Cannot call " + methodName + " on shortcut " + getEdge());
+//            } else if (shouldBeShortcut)
+//                throw new IllegalStateException("Method " + methodName + " only for shortcuts " + getEdge());
         }
 
         private void checkShortcutAndEdgeBased(String method) {
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index 0359dedba1..58fccbc618 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -25,7 +25,7 @@
  * <pre>
  * EdgeExplorer explorer = graph.createEdgeExplorer();
  * EdgeIterator iter = explorer.setBaseNode(nodeId);
- * // calls to iter.getAdjNode(), getDistance() without calling next() will cause undefined behaviour!
+ * // calls to iter.getAdjNode(), getTime() without calling next() will cause undefined behaviour!
  * while(iter.next()) {
  *   int baseNodeId = iter.getBaseNode(); // equal to nodeId
  *   int adjacentNodeId = iter.getAdjNode(); // this is the node where this edge state is "pointing to"
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 584dcbdf7d..1ad530120f 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -92,7 +92,7 @@ public static void updateDistancesFor(Graph g, int node, double lat, double lon)
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(node);
         while (iter.next()) {
             iter.setDistance(iter.fetchWayGeometry(3).calcDistance(distCalc));
-            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
+            // System.out.println(node + "->" + adj + ": " + iter.getTime());
         }
     }
 
@@ -472,7 +472,7 @@ public void testCreateAlgoTwice() {
         graph.edge(8, 6, 1, true);
 
         // run the same query twice, this can be interesting because in the second call algorithms that pre-process
-        // the graph might depend on the state of the graph after the first call 
+        // the graph might depend on the state of the graph after the first call
         Path p1 = createAlgo(graph).calcPath(0, 4);
         Path p2 = createAlgo(graph).calcPath(0, 4);
 
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
index 54f9a43a56..8a4990c1a3 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
@@ -21,49 +21,49 @@
     private final GHRequest ghRequest = new GHRequest(0, 0, 10, 10).setPolygon(new Polygon(new double[]{5, 10, 10, 5}, new double[]{5, 5, 10, 10})).setVehicle("car");
 
     private void addTestingCandidates() {
-        this.candidateList.getCandidates().clear();
-
-        Path startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        Path detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        Path detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(3, 6, 1, "a", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
-
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(2, 3, 1, "b", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
-
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(6, 6, 5, "c", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
-
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(4, 5, 3, "d", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
-
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(8, 4, 6, "e", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
-
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(6, 1, 3, "f", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
-
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(7, 1, 6, "g", startToDetourEntry,
-                                                                        detourEntryToDetourExit, detourExitToEnd, null));
+        this.candidateList.clear();
+
+        Path startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        Path detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        Path detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(3, 6, 1, "a", startToDetourEntry,
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
+
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(2, 3, 1, "b", startToDetourEntry,
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
+
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(6, 6, 5, "c", startToDetourEntry,
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
+
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(4, 5, 3, "d", startToDetourEntry,
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
+
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(8, 4, 6, "e", startToDetourEntry,
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
+
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(6, 1, 3, "f", startToDetourEntry,
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
+
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(7, 1, 6, "g", startToDetourEntry,
+                                                        detourEntryToDetourExit, detourExitToEnd, null));
     }
 
     @Test
@@ -71,9 +71,9 @@ public void assertCorrectListContentAfterPruning() {
         addTestingCandidates();
         this.candidateList.pruneDominatedCandidateRoutes();
 
-        assertEquals("a", this.candidateList.getCandidates().get(0).name);
-        assertEquals("c", this.candidateList.getCandidates().get(1).name);
-        assertEquals("b", this.candidateList.getCandidates().get(2).name);
+        assertEquals("a", this.candidateList.get(0).name);
+        assertEquals("c", this.candidateList.get(1).name);
+        assertEquals("b", this.candidateList.get(2).name);
     }
 
     @Test
@@ -91,36 +91,89 @@ public void assertCorrectTopThreeRoutes() {
         assertEquals(3, topCandidates.size());
     }
 
+    @Test
+    public void testIllegalStartToDetourSubpath() {
+        addTestingCandidates();
+        final RouteCandidateMocker testingCandidate = this.candidateList.get(0);
+        testingCandidate.startToDetourEntry.setFound(false);
+
+        illegalCandidateNotAdded(testingCandidate);
+    }
+
+    @Test
+    public void testIllegalDetourEntryToDetourExitSubpath() {
+        addTestingCandidates();
+        final RouteCandidateMocker testingCandidate = this.candidateList.get(0);
+        testingCandidate.detourEntryToDetourExit.setFound(false);
+
+        illegalCandidateNotAdded(testingCandidate);
+    }
+
+    @Test
+    public void testIllegalDetourExitToEndSubpath() {
+        addTestingCandidates();
+        final RouteCandidateMocker testingCandidate = this.candidateList.get(0);
+        testingCandidate.detourExitToEnd.setFound(false);
+
+        illegalCandidateNotAdded(testingCandidate);
+    }
+
+    private void illegalCandidateNotAdded(RouteCandidateMocker testingCandidate) {
+        final int sizeBeforeAdding = this.candidateList.size();
+        this.candidateList.add(testingCandidate);
+        assertEquals(sizeBeforeAdding, this.candidateList.size());
+    }
+
+    @Test
+    public void selfintersectingRouteNotAlsoAdded() {
+        addTestingCandidates();
+
+        RouteCandidateMocker selfintersectingCandidate = createSelfintersectingRouteCandidate();
+        this.candidateList.add(selfintersectingCandidate);
+
+        assertEquals(true, selfintersectingCandidate.isDetourSelfIntersecting(new QueryGraph(this.graphMocker.graph), this.graphMocker.algorithmOptions));
+        assertEquals(1, this.candidateList.getFirstAsPathList(1, new QueryGraph(this.graphMocker.graph), this.graphMocker.algorithmOptions).size());
+    }
+
+    private RouteCandidateMocker createSelfintersectingRouteCandidate() {
+        Path startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        Path detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit.addEdge(1);
+        detourEntryToDetourExit.addEdge(1);
+        Path detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        return new RouteCandidateMocker(1, 1, 1, "selfintersecting", startToDetourEntry, detourEntryToDetourExit, detourExitToEnd, null);
+    }
+
     class RouteCandidateMocker extends RouteCandidatePolygon {
-        final double polygonRouteDistance;
-        final double roiDistance;
-        final double directDistance;
+        final double polygonRouteTime;
+        final double roiTime;
+        final double directTime;
         final String name;
 
-        RouteCandidateMocker(final double polygonRouteDistance, final double distanceInROI, final double directDistance,
+        RouteCandidateMocker(final double polygonRouteTime, final double timeInRoi, final double directTime,
                              final String name, final Path startToDetourEntry, final Path detourEntryToDetourExit, final Path detourExitToEnd,
                              final Path directRouteStartEnd) {
             super(0, 3, 1, 2, startToDetourEntry, detourEntryToDetourExit, detourExitToEnd, directRouteStartEnd);
 
-            this.polygonRouteDistance = polygonRouteDistance;
-            this.roiDistance = distanceInROI;
-            this.directDistance = directDistance;
+            this.polygonRouteTime = polygonRouteTime;
+            this.roiTime = timeInRoi;
+            this.directTime = directTime;
             this.name = name;
         }
 
         @Override
-        public double getDistance() {
-            return this.polygonRouteDistance;
+        public double getTime() {
+            return this.polygonRouteTime;
         }
 
         @Override
-        public double getDistanceInROI() {
-            return this.roiDistance;
+        public double getTimeInROI() {
+            return this.roiTime;
         }
 
         @Override
-        public double getDetourDistance() {
-            return this.getDistance() - this.directDistance;
+        public double getDetourTime() {
+            return this.getTime() - this.directTime;
         }
 
         @Override
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
index 68a7004a61..3fe1b60187 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
@@ -1,19 +1,18 @@
 package com.graphhopper.routing.template.polygonRoutingUtil;
 
 import com.graphhopper.GHRequest;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.PathMerge;
-import com.graphhopper.routing.QueryGraph;
-import com.graphhopper.routing.template.PolygonThroughRoutingTemplate;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
 import com.graphhopper.util.shapes.Polygon;
 import org.junit.Test;
 
+import javax.management.Query;
+
 import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 
+// TODO Test with empty subpaths
 public class RouteCandidateTest {
     private final GHRequest ghRequest = new GHRequest(0, 0, 10, 10).setPolygon(new Polygon(new double[]{5, 10, 10, 5}, new double[]{5, 5, 10, 10})).setVehicle("car");
     private final PolygonRoutingTestGraph graphMocker = new PolygonRoutingTestGraph();
@@ -22,10 +21,10 @@
     public void testCorrectDistanceMetricsSmaller() {
         RouteCandidatePolygon testSmaller = setupSmallerRouteCandidate();
 
-        assertEquals(1, testSmaller.getDistanceInROI(), 0);
-        assertEquals(3, testSmaller.getDistance(), 0);
-        assertEquals(2, testSmaller.directRouteStartEnd.getDistance(), 0);
-        assertEquals(1, testSmaller.getDetourDistance(), 0);
+        assertEquals(1, testSmaller.getTimeInROI(), 0);
+        assertEquals(3, testSmaller.getTime(), 0);
+        assertEquals(2, testSmaller.directRouteStartEnd.getTime(), 0);
+        assertEquals(1, testSmaller.getDetourTime(), 0);
         assertEquals(0.5, testSmaller.getGain(), 0);
     }
 
@@ -33,10 +32,10 @@ public void testCorrectDistanceMetricsSmaller() {
     public void testCorrectDistanceMetricsGreater() {
         RouteCandidatePolygon testGreater = setupGreaterRouteCandidate();
 
-        assertEquals(2, testGreater.getDistanceInROI(), 0);
-        assertEquals(6, testGreater.getDistance(), 0);
-        assertEquals(5, testGreater.directRouteStartEnd.getDistance(), 0);
-        assertEquals(1, testGreater.getDetourDistance(), 0);
+        assertEquals(2, testGreater.getTimeInROI(), 0);
+        assertEquals(6, testGreater.getTime(), 0);
+        assertEquals(5, testGreater.directRouteStartEnd.getTime(), 0);
+        assertEquals(1, testGreater.getDetourTime(), 0);
         assertEquals(1, testGreater.getGain(), 0);
     }
 
@@ -73,8 +72,8 @@ private RouteCandidatePolygon setupSmallerRouteCandidate() {
         Path detourExitToEnd = createTestSubPath(12, 3, 1);
         Path directRouteStartEnd = createDirectRoute(2);
 
-        RouteCandidatePolygon test = new RouteCandidatePolygon( 1, 3, 28, 29, startToDetourEntry, detourEntryToDetourExit,
-                                                                detourExitToEnd, directRouteStartEnd);
+        RouteCandidatePolygon test = new RouteCandidatePolygon(1, 3, 28, 29, startToDetourEntry, detourEntryToDetourExit,
+                                                               detourExitToEnd, directRouteStartEnd);
 
         return test;
     }
@@ -91,24 +90,24 @@ private RouteCandidatePolygon setupGreaterRouteCandidate() {
         return test;
     }
 
-    private Path createTestSubPath(int edgeId, int endNode, int distance) {
+    private Path createTestSubPath(int edgeId, int endNode, int time) {
         Path startPolygon = new PathMerge(graphMocker.graph, graphMocker.weighting);
 
         startPolygon.addEdge(edgeId);
         startPolygon.setEndNode(endNode);
-        startPolygon.setDistance(distance);
+        startPolygon.setTime(time);
         startPolygon.setFound(true);
 
         return startPolygon;
     }
 
-    private Path createDirectRoute(int distance) {
+    private Path createDirectRoute(int time) {
         Path directRoute = new PathMerge(graphMocker.graph, graphMocker.weighting);
 
         directRoute.addEdge(3);
         directRoute.addEdge(8);
         directRoute.setEndNode(3);
-        directRoute.setDistance(distance);
+        directRoute.setTime(time);
         directRoute.setFound(true);
 
         return directRoute;
@@ -155,4 +154,45 @@ private void setupRouteCandidatesParameters(int from, int to, RouteCandidatePoly
         candidate.mergedPath.setEndNode(to);
         candidate.mergedPath.extract();
     }
+
+    @Test
+    public void testMerging() {
+        final RoutingAlgorithmFactory routingAlgorithmFactory = new RoutingAlgorithmFactorySimple();
+
+        final Path startToPolygonEntry = createStartToPolygonEntry(routingAlgorithmFactory);
+        final Path polygonEntryToPolygonExit = createPolygonEntryToPolygonExit(routingAlgorithmFactory);
+        final Path polygonExitToEnd = createPolygonExitToEnd(routingAlgorithmFactory);
+
+        final RouteCandidatePolygon testCandidate = new RouteCandidatePolygon(0, 4, 1, 3, startToPolygonEntry, polygonEntryToPolygonExit, polygonExitToEnd, null);
+        final Path mergedPath = testCandidate.getMergedPath(new QueryGraph(this.graphMocker.graph), this.graphMocker.algorithmOptions);
+
+        assertEquals(4, mergedPath.getDistance(), 0);
+        assertEquals(4, mergedPath.getTime(), 0);
+    }
+
+    private Path createStartToPolygonEntry(RoutingAlgorithmFactory routingAlgorithmFactory) {
+        final Path startToPolygonEntry = createPath(routingAlgorithmFactory, 0, 1);
+        startToPolygonEntry.setTime(1);
+        startToPolygonEntry.setDistance(1);
+        return startToPolygonEntry;
+    }
+
+    private Path createPolygonEntryToPolygonExit(RoutingAlgorithmFactory routingAlgorithmFactory) {
+        final Path polygonEntryToPolygonExit = createPath(routingAlgorithmFactory, 1, 3);
+        polygonEntryToPolygonExit.setTime(2);
+        polygonEntryToPolygonExit.setDistance(2);
+        return polygonEntryToPolygonExit;
+    }
+
+    private Path createPolygonExitToEnd(RoutingAlgorithmFactory routingAlgorithmFactory) {
+        final Path polygonExitToEnd = createPath(routingAlgorithmFactory, 3, 4);
+        polygonExitToEnd.setTime(1);
+        polygonExitToEnd.setDistance(1);
+        return polygonExitToEnd;
+    }
+
+    private Path createPath(RoutingAlgorithmFactory routingAlgorithmFactory, int from, int to) {
+        RoutingAlgorithm routingAlgorithm = routingAlgorithmFactory.createAlgo(this.graphMocker.graph, this.graphMocker.algorithmOptions);
+        return routingAlgorithm.calcPath(from, to);
+    }
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index 1ea121c3d8..e506778407 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -291,7 +291,7 @@ public void testMonacoFoot3D() {
     @Test
     public void testNorthBayreuthHikeFastestAnd3D() {
         List<OneRun> list = new ArrayList<>();
-        // prefer hiking route 'Teufelsloch Unterwaiz' and 'Rotmain-Wanderweg'        
+        // prefer hiking route 'Teufelsloch Unterwaiz' and 'Rotmain-Wanderweg'
         list.add(new OneRun(49.974972, 11.515657, 49.991022, 11.512299, 2365, 66));
         // prefer hiking route 'Markgrafenweg Bayreuth Kulmbach' but avoid tertiary highway from Pechgraben
         list.add(new OneRun(49.990967, 11.545258, 50.023182, 11.555386, 5636, 97));
@@ -469,8 +469,8 @@ public void testAndorraFoot() {
     public void testCampoGrande() {
         // test not only NE quadrant of earth!
 
-        // bzcat campo-grande.osm.bz2 
-        //   | ./bin/osmosis --read-xml enableDateParsing=no file=- --bounding-box top=-20.4 left=-54.6 bottom=-20.6 right=-54.5 --write-xml file=- 
+        // bzcat campo-grande.osm.bz2
+        //   | ./bin/osmosis --read-xml enableDateParsing=no file=- --bounding-box top=-20.4 left=-54.6 bottom=-20.6 right=-54.5 --write-xml file=-
         //   | bzip2 > campo-grande.extracted.osm.bz2
         List<OneRun> list = new ArrayList<>();
         list.add(new OneRun(-20.4, -54.6, -20.6, -54.54, 25516, 271));
@@ -560,7 +560,7 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
 
             if (osmFile.contains("krautsand"))
                 hopper.setMinNetworkSize(0, 0);
-            // avoid that path.getDistance is too different to path.getPoint.calcDistance
+            // avoid that path.getTime is too different to path.getPoint.calcDistance
             hopper.setWayPointMaxDistance(0);
 
             // always enable landmarks, add maximum information to reduce warnings
@@ -633,7 +633,7 @@ public void testMonacoParallel() throws IOException {
         int MAX = 100;
         final FlagEncoder carEncoder = encodingManager.getEncoder("car");
 
-        // testing if algorithms are independent. should be. so test only two algorithms. 
+        // testing if algorithms are independent. should be. so test only two algorithms.
         // also the preparing is too costly to be called for every thread
         int algosLength = 2;
         final Weighting weighting = new ShortestWeighting(encodingManager.getEncoder("car"));
