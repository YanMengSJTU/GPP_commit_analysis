diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/core/src/main/java/com/graphhopper/PathWrapper.java
index 2b82d6cd7c..968a5f6429 100644
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/core/src/main/java/com/graphhopper/PathWrapper.java
@@ -48,6 +48,7 @@
     private final List<Trip.Leg> legs = new ArrayList<>();
     private Map<String, List<PathDetail>> pathDetails = new HashMap<>();
     private BigDecimal fare;
+    private boolean impossible = false;
 
     /**
      * @return the description of this route alternative to make it meaningful for the user e.g. it
@@ -314,4 +315,12 @@ public void setFare(BigDecimal fare) {
     public BigDecimal getFare() {
         return fare;
     }
+
+    public boolean isImpossible() {
+        return impossible;
+    }
+
+    public void setImpossible(boolean impossible) {
+        this.impossible = impossible;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/Trip.java b/core/src/main/java/com/graphhopper/Trip.java
index 25611620ac..7c6866d6a0 100644
--- a/core/src/main/java/com/graphhopper/Trip.java
+++ b/core/src/main/java/com/graphhopper/Trip.java
@@ -40,21 +40,25 @@ public double getDistance() {
         public final Date arrivalTime;
         public final Date plannedArrivalTime;
         public final Date predictedArrivalTime;
+        public final boolean arrivalCancelled;
 
         public final Date departureTime;
         public final Date plannedDepartureTime;
         public final Date predictedDepartureTime;
+        public final boolean departureCancelled;
 
-        public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date plannedArrivalTime, Date predictedArrivalTime, Date departureTime, Date plannedDepartureTime, Date predictedDepartureTime) {
+        public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date plannedArrivalTime, Date predictedArrivalTime, boolean arrivalCancelled, Date departureTime, Date plannedDepartureTime, Date predictedDepartureTime, boolean departureCancelled) {
             this.stop_id = stop_id;
             this.stop_name = name;
             this.geometry = geometry;
             this.arrivalTime = arrivalTime;
             this.plannedArrivalTime = plannedArrivalTime;
             this.predictedArrivalTime = predictedArrivalTime;
+            this.arrivalCancelled = arrivalCancelled;
             this.departureTime = departureTime;
             this.plannedDepartureTime = plannedDepartureTime;
             this.predictedDepartureTime = predictedDepartureTime;
+            this.departureCancelled = departureCancelled;
         }
 
         @Override
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 8974379085..5bb818ae2c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -121,6 +121,10 @@ long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
         }
     }
 
+    public boolean isBlocked(EdgeIteratorState edge) {
+        return realtimeFeed.isBlocked(edge.getEdge());
+    }
+
     private long waitingTime(EdgeIteratorState edge, long earliestStartTime) {
         return flagEncoder.getTime(edge.getFlags()) * 1000 - millisOnTravelDay(edge, earliestStartTime);
     }
@@ -182,9 +186,6 @@ public boolean test(EdgeIteratorState edgeIterator) {
             if (!isValidOn(edgeIterator, label.currentTime)) {
                 return false;
             }
-            if (realtimeFeed.isBlocked(edgeIterator.getEdge())) {
-                return false;
-            }
             if (edgeType == GtfsStorage.EdgeType.WAIT_ARRIVAL && !reverse) {
                 return false;
             }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 6789d14835..2237d026cc 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -222,11 +222,23 @@ private void parseSolutionsAndAddToResponse(List<Label> solutions, PointList way
                     legs.addAll(walkPaths.get(egressNode(solution)).getLegs());
                 }
                 final PathWrapper pathWrapper = tripFromLabel.createPathWrapper(translation, waypoints, legs);
+                pathWrapper.setImpossible(isImpossible(solution));
                 // TODO: remove
                 pathWrapper.setTime((solution.currentTime - initialTime.toEpochMilli()) * (arriveBy ? -1 : 1));
                 response.add(pathWrapper);
             }
-            response.getAll().sort(Comparator.comparingDouble(PathWrapper::getTime));
+            Comparator<PathWrapper> c = Comparator.comparingInt(p -> (p.isImpossible() ? 1 : 0));
+            Comparator<PathWrapper> d = Comparator.comparingDouble(PathWrapper::getTime);
+            response.getAll().sort(c.thenComparing(d));
+        }
+
+        private boolean isImpossible(Label solution) {
+            for (Label i = solution; i != null; i = i.parent) {
+                if (i.impossible) {
+                    return true;
+                }
+            }
+            return false;
         }
 
         private int accessNode(Label solution) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 6514c8befa..a6d127a91a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -54,6 +54,7 @@
 import java.util.Map;
 import java.util.NavigableSet;
 import java.util.Optional;
+import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.stream.Collectors;
@@ -67,15 +68,19 @@
     private LocalDate endDate;
 
     static class TripWithStopTimes {
-        public TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay) {
+        public TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay, Set<Integer> cancelledArrivals, Set<Integer> cancelledDepartures) {
             this.trip = trip;
             this.stopTimes = stopTimes;
             this.validOnDay = validOnDay;
+            this.cancelledArrivals = cancelledArrivals;
+            this.cancelledDeparture = cancelledDepartures;
         }
 
         Trip trip;
         List<StopTime> stopTimes;
         BitSet validOnDay;
+        Set<Integer> cancelledArrivals;
+        Set<Integer> cancelledDeparture;
     }
 
     private static class EnterAndExitNodeIdWithStopId {
@@ -203,7 +208,7 @@ private void buildPtNetwork() {
                         }
                         ArrayList<StopTime> stopTimes = new ArrayList<>();
                         getInterpolatedStopTimesForTrip(trip.trip_id).forEach(stopTimes::add);
-                        return new TripWithStopTimes(trip, stopTimes, validOnDay);
+                        return new TripWithStopTimes(trip, stopTimes, validOnDay, Collections.emptySet(), Collections.emptySet());
                     })
                     .sorted(Comparator.comparingInt(trip -> trip.stopTimes.iterator().next().departure_time))
                     .collect(Collectors.toList());
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index 9268ed86f9..2968003086 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -74,9 +74,11 @@ public String toString() {
     final Long departureTime;
     final long walkTime;
 
+    final boolean impossible;
+
     final Label parent;
 
-    Label(long currentTime, int edgeId, int adjNode, int nTransfers, int nWalkDistanceConstraintViolations, double walkDistance, Long departureTime, long walkTime, Label parent) {
+    Label(long currentTime, int edgeId, int adjNode, int nTransfers, int nWalkDistanceConstraintViolations, double walkDistance, Long departureTime, long walkTime, boolean impossible, Label parent) {
         this.currentTime = currentTime;
         this.edge = edgeId;
         this.adjNode = adjNode;
@@ -85,6 +87,7 @@ public String toString() {
         this.walkDistanceOnCurrentLeg = walkDistance;
         this.departureTime = departureTime;
         this.walkTime = walkTime;
+        this.impossible = impossible;
         this.parent = parent;
     }
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index 4903f2a9a6..ab0fcdcaa6 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -65,7 +65,8 @@
         this.mindTransfers = mindTransfers;
         this.profileQuery = profileQuery;
 
-        queueComparator = Comparator.<Label>comparingLong(l2 -> currentTimeCriterion(l2))
+        queueComparator = Comparator.<Label>comparingLong(l2 -> l2.impossible ? 1 : 0)
+                .thenComparing(Comparator.comparingLong(l2 -> currentTimeCriterion(l2)))
                 .thenComparing(Comparator.comparingLong(l1 -> l1.nTransfers))
                 .thenComparing(Comparator.comparingLong(l1 -> l1.nWalkDistanceConstraintViolations))
                 .thenComparing(Comparator.comparingLong(l -> departureTimeCriterion(l) != null ? departureTimeCriterion(l) : 0));
@@ -89,7 +90,7 @@
             super(0, 0);
             this.to = to;
             targetLabels = new HashSet<>();
-            Label label = new Label(startTime, EdgeIterator.NO_EDGE, from, 0, 0, 0.0, null, 0, null);
+            Label label = new Label(startTime, EdgeIterator.NO_EDGE, from, 0, 0, 0.0, null, 0, false,null);
             fromMap.put(from, label);
             fromHeap.add(label);
             if (to == from) {
@@ -129,7 +130,7 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                     int nWalkDistanceConstraintViolations = Math.min(1, label.nWalkDistanceConstraintViolations + (
                             isTryingToReEnterPtAfterTransferWalking ? 1 : (label.walkDistanceOnCurrentLeg <= maxWalkDistancePerLeg && walkDistanceOnCurrentLeg > maxWalkDistancePerLeg ? 1 : 0)));
                     Set<Label> sptEntries = fromMap.get(edge.getAdjNode());
-                    Label nEdge = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, label);
+                    Label nEdge = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, label.impossible || explorer.isBlocked(edge), label);
                     if (isNotDominatedByAnyOf(nEdge, sptEntries) && isNotDominatedByAnyOf(nEdge, targetLabels)) {
                         removeDominated(nEdge, sptEntries);
                         if (to == edge.getAdjNode()) {
@@ -190,6 +191,8 @@ private boolean dominates(Label me, Label they) {
             return false;
         if (me.nWalkDistanceConstraintViolations  > they.nWalkDistanceConstraintViolations)
             return false;
+        if (me.impossible && !they.impossible)
+            return false;
 
         if (profileQuery) {
             if (me.departureTime != null && they.departureTime != null) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index 85b331fca5..6f4ace6570 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -48,8 +48,10 @@
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
+import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
 
@@ -271,7 +273,7 @@ public GraphExtension getExtension() {
                     BitSet validOnDay = new BitSet();
                     LocalDate startDate = feed.calculateStats().getStartDate();
                     validOnDay.set((int) DAYS.between(startDate, dateToChange));
-                    return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
+                    return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay, Collections.emptySet(), Collections.emptySet());
                 })
                 .forEach(trip -> gtfsReader.addTrips(ZoneId.of(agency.agency_timezone), Collections.singletonList(trip), 0));
         gtfsReader.wireUpStops();
@@ -303,6 +305,8 @@ boolean isBlocked(int edgeId) {
     public static GtfsReader.TripWithStopTimes toTripWithStopTimes(GTFSFeed feed, Agency agency, GtfsRealtime.TripUpdate tripUpdate) {
         logger.trace("{}", tripUpdate.getTrip());
         final List<StopTime> stopTimes = new ArrayList<>();
+        Set<Integer> cancelledArrivals = new HashSet<>();
+        Set<Integer> cancelledDepartures = new HashSet<>();
         Trip originalTrip = feed.trips.get(tripUpdate.getTrip().getTripId());
         Trip trip = new Trip();
         if (originalTrip != null) {
@@ -363,6 +367,10 @@ boolean isBlocked(int edgeId) {
                 time = updatedStopTime.departure_time;
                 stopTimes.add(updatedStopTime);
                 logger.trace("Number of stop times: {}", stopTimes.size());
+                if (stopTimeUpdate.getScheduleRelationship() == SKIPPED) {
+                    cancelledArrivals.add(stopTimeUpdate.getStopSequence());
+                    cancelledDepartures.add(stopTimeUpdate.getStopSequence());
+                }
             } else if (stopTimeUpdate.getScheduleRelationship() == NO_DATA) {
             } else if (tripUpdate.getTrip().getScheduleRelationship() == GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED) {
                 final StopTime stopTime = new StopTime();
@@ -381,7 +389,8 @@ boolean isBlocked(int edgeId) {
         }
         logger.trace("Number of stop times: {}", stopTimes.size());
         BitSet validOnDay = new BitSet(); // Not valid on any day. Just a template.
-        return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
+
+        return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay, cancelledArrivals, cancelledDepartures);
     }
 
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index baa450d90c..5ec37f6a23 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -199,6 +199,7 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
         private Optional<Instant> updatedArrival;
         private StopTime stopTime = null;
         private final GtfsReader.TripWithStopTimes tripUpdate;
+        private int stopSequence = 0;
 
         StopsFromBoardHopDwellEdges(String feedId, GtfsRealtime.TripDescriptor tripDescriptor) {
             this.tripDescriptor = tripDescriptor;
@@ -212,16 +213,16 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
         void next(Label.Transition t) {
             switch (t.edge.edgeType) {
                 case BOARD: {
-                    int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
+                    stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
                     stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
                     Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
                     Optional<Instant> updatedDeparture = getDepartureDelay(stopSequence).map(delay -> plannedDeparture.plus(delay, SECONDS));
                     Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, null, null, updatedDeparture.map(Date::from).orElse(Date.from(plannedDeparture)), Date.from(plannedDeparture), updatedDeparture.map(Date::from).orElse(null)));
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, null, null, isArrivalCancelled(stopSequence), updatedDeparture.map(Date::from).orElse(Date.from(plannedDeparture)), Date.from(plannedDeparture), updatedDeparture.map(Date::from).orElse(null), isDepartureCancelled(stopSequence)));
                     break;
                 }
                 case HOP: {
-                    int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
+                    stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
                     stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
                     arrivalTimeFromHopEdge = Instant.ofEpochMilli(t.label.currentTime);
                     updatedArrival = getArrivalDelay(stopSequence).map(delay -> arrivalTimeFromHopEdge.plus(delay, SECONDS));
@@ -231,7 +232,7 @@ void next(Label.Transition t) {
                     Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
                     Optional<Instant> updatedDeparture = getDepartureDelay(stopTime.stop_sequence).map(delay -> plannedDeparture.plus(delay, SECONDS));
                     Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), updatedArrival.map(Date::from).orElse(Date.from(arrivalTimeFromHopEdge)), Date.from(arrivalTimeFromHopEdge), updatedArrival.map(Date::from).orElse(null), updatedDeparture.map(Date::from).orElse(Date.from(plannedDeparture)), Date.from(plannedDeparture), updatedDeparture.map(Date::from).orElse(null)));
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), updatedArrival.map(Date::from).orElse(Date.from(arrivalTimeFromHopEdge)), Date.from(arrivalTimeFromHopEdge), updatedArrival.map(Date::from).orElse(null), isArrivalCancelled(stopSequence), updatedDeparture.map(Date::from).orElse(Date.from(plannedDeparture)), Date.from(plannedDeparture), updatedDeparture.map(Date::from).orElse(null), isDepartureCancelled(stopSequence)));
                     break;
                 }
                 default: {
@@ -250,6 +251,14 @@ void next(Label.Transition t) {
             }
         }
 
+        private boolean isArrivalCancelled(int stopSequence) {
+            if (tripUpdate != null) {
+                return tripUpdate.cancelledArrivals.contains(stopSequence);
+            } else {
+                return false;
+            }
+        }
+
         private Optional<Integer> getDepartureDelay(int stopSequence) {
             if (tripUpdate != null) {
                 int departure_time = tripUpdate.stopTimes.stream().filter(st -> st.stop_sequence == stopSequence).findFirst().orElseThrow(() -> new RuntimeException("Stop time not found.")).departure_time;
@@ -260,9 +269,17 @@ void next(Label.Transition t) {
             }
         }
 
+        private boolean isDepartureCancelled(int stopSequence) {
+            if (tripUpdate != null) {
+                return tripUpdate.cancelledDeparture.contains(stopSequence);
+            } else {
+                return false;
+            }
+        }
+
         void finish() {
             Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), updatedArrival.map(Date::from).orElse(Date.from(arrivalTimeFromHopEdge)), Date.from(arrivalTimeFromHopEdge), updatedArrival.map(Date::from).orElse(null), null, null, null));
+            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), updatedArrival.map(Date::from).orElse(Date.from(arrivalTimeFromHopEdge)), Date.from(arrivalTimeFromHopEdge), updatedArrival.map(Date::from).orElse(null), isArrivalCancelled(stopSequence),null, null, null, isDepartureCancelled(stopSequence)));
             for (Trip.Stop tripStop : stops) {
                 logger.trace("{}", tripStop);
             }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index be8b1476a6..61b2e9ed53 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -48,6 +48,8 @@
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
 import static com.graphhopper.reader.gtfs.GtfsHelper.time;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 public class RealtimeIT {
 
@@ -93,7 +95,6 @@ public void testSkipDepartureStop() {
 
         // I want to go at 6:44
         ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
         ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         // But the 6:00 departure of my line is going to skip my departure stop :-(
@@ -108,9 +109,13 @@ public void testSkipDepartureStop() {
                 .setScheduleRelationship(SKIPPED);
 
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
-        assertEquals(1, response.getAll().size());
+        assertEquals(2, response.getAll().size());
 
         assertEquals("I have to wait half an hour for the next one (and ride 5 minutes)", time(0, 35), response.getBest().getTime(), 0.1);
+
+        PathWrapper impossibleAlternative = response.getAll().get(1);
+        assertTrue(impossibleAlternative.isImpossible());
+        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(0).departureCancelled);
     }
 
     @Test
@@ -124,7 +129,6 @@ public void testSkipArrivalStop() {
 
         // I want to go at 6:44
         ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
         ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         // But the 6:00 departure of my line is going to skip my arrival stop :-(
@@ -139,9 +143,13 @@ public void testSkipArrivalStop() {
                 .setScheduleRelationship(SKIPPED);
 
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
-        assertEquals(1, response.getAll().size());
+        assertEquals(3, response.getAll().size());
 
         assertEquals("I have to continue to STAGECOACH and then go back one stop with the 07:00 bus.", time(0, 21), response.getBest().getTime(), 0.1);
+
+        PathWrapper impossibleAlternative = response.getAll().get(2);
+        assertTrue(impossibleAlternative.isImpossible());
+        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(1).arrivalCancelled);
     }
 
     @Test
@@ -155,7 +163,6 @@ public void testSkipTransferStop() {
 
         // I want to go at 6:44
         ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
         ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
@@ -170,9 +177,13 @@ public void testSkipTransferStop() {
                 .setScheduleRelationship(SKIPPED);
 
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
-        assertEquals(1, response.getAll().size());
+        assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will not call at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
+
+        PathWrapper impossibleAlternative = response.getAll().get(1);
+        assertTrue(impossibleAlternative.isImpossible());
+        assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(1)).stops.get(2).departureCancelled);
     }
 
     @Test @Ignore //Pending feature
@@ -377,5 +388,38 @@ public void testBlockTrips() {
         assertEquals("It takes", time(1,20), response.getBest().getTime());
     }
 
+    @Test
+    public void testBlockTripSkipsStop() {
+        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
+        feedMessageBuilder.addEntityBuilder()
+                .setId("1")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("AB1").setStartTime("00:00:00"))
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(2)
+                .setScheduleRelationship(SKIPPED);
+
+        final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
+        final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        GHResponse route = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
+
+        assertFalse(route.hasErrors());
+        assertEquals(2, route.getAll().size()); // I want to get the impossible route as well.
+        assertTrue(route.getAll().get(1).isImpossible());
+
+        // Note that my stop (BULLFROG), which is skipped, is a switch of "block legs", so even though it looks like I (impossibly) transfer there,
+        // this is not a real transfer. The bus drives through BULLFROG without stopping.
+        // Very untypical example, but seems correct.
+        Trip.PtLeg ptLeg = (Trip.PtLeg) route.getBest().getLegs().get(4);
+        assertEquals("I have to continue on AB1 which skips my stop, go all the way to the end, and ride back.", LocalDateTime.parse("2007-01-01T12:00:00").atZone(zoneId).toInstant(), ptLeg.stops.get(ptLeg.stops.size()-1).plannedArrivalTime.toInstant());
+        assertEquals("Using expected route", "BFC2", ptLeg.trip_id);
+    }
+
 
 }
\ No newline at end of file
