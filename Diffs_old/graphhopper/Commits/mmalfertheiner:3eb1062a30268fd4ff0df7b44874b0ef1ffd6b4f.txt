diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index ada6645c76..51df165c52 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -69,6 +69,7 @@
     private final double invPrecision = 1 / precision;
     private final int degree = 5;
     private boolean calcMean = false;
+    private boolean calcMedian = false;
     private boolean autoRemoveTemporary = true;
 
     @Override
@@ -77,6 +78,11 @@ public void setCalcMean( boolean eleCalcMean )
         calcMean = eleCalcMean;
     }
 
+    @Override
+    public void setCalcMedian( boolean calcMedian) {
+        this.calcMedian = calcMedian;
+    }
+
     /**
      * Creating temporary files can take a long time as we need to unpack tiff as well as to fill
      * our DataAccess object, so this option can be used to disable the default clear mechanism via
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
index 293b6a6e6d..0eca7d8f8d 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationProvider.java
@@ -55,6 +55,12 @@
      */
     void setCalcMean( boolean calcMean );
 
+    /**
+     * Configuration option to include surrounding elevation points when fetching the elevation. Has
+     * only an effect if called before the first getEle call. Turned off by default.
+     */
+    void setCalcMedian (boolean calcMedian);
+
     /**
      * Release resources.
      */
@@ -95,5 +101,10 @@ public void release()
         public void setCalcMean( boolean eleCalcMean )
         {
         }
+
+        @Override
+        public void setCalcMedian( boolean eleCalcMedian )
+        {
+        }
     };
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/Filter.java b/core/src/main/java/com/graphhopper/reader/dem/Filter.java
new file mode 100644
index 0000000000..6c0ba9e0c4
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/Filter.java
@@ -0,0 +1,7 @@
+package com.graphhopper.reader.dem;
+
+public interface Filter {
+
+    int apply();
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
index 3809f71c94..20c68e313c 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/HeightTile.java
@@ -43,6 +43,7 @@
     private final double lowerBound;
     private final double higherBound;
     private boolean calcMean;
+    private boolean calcMedian;
 
     public HeightTile( int minLat, int minLon, int width, double precision, int degree )
     {
@@ -62,6 +63,12 @@ public HeightTile setCalcMean( boolean b )
         return this;
     }
 
+    public HeightTile setCalcMedian( boolean b )
+    {
+        this.calcMedian = b;
+        return this;
+    }
+
     public HeightTile setSeaLevel( boolean b )
     {
         heights.setHeader(0, b ? 1 : 0);
@@ -120,6 +127,18 @@ public double getHeight( double lat, double lon )
                 value += includePoint(daPointer + 2 * width, counter);
         }
 
+        if (calcMedian){
+            //Filter filter = new MedianFilter(extractSurroundingPx(daPointer, value, lonSimilar, latSimilar));
+
+            double[] kernel = {0.125,0.125,0.125,0.125,0,0.125,0.125,0.125,0.125};
+            int[] px = extractSurroundingPx(daPointer, value, lonSimilar, latSimilar);
+            Filter filter = new LinearFilter(px, kernel);
+            System.out.print("Old value: " + value);
+            value = filter.apply();
+            System.out.print(", Median value: " + value + "\n");
+
+        }
+
         return (double) value / counter.get();
     }
 
@@ -133,6 +152,37 @@ private double includePoint( int pointer, AtomicInteger counter )
         return value;
     }
 
+    private int getAdjacentPx(int pointer, boolean exists) {
+
+        int value = -1;
+
+        if(exists) {
+            value = heights.getShort(pointer);
+
+            if (value == Short.MIN_VALUE)
+                value = 0;
+        }
+
+        return value;
+    }
+
+    private int[] extractSurroundingPx(int daPointer, int value, int lonSimilar, int latSimilar) {
+
+        int pixels[] = new int[9];
+        pixels[4] = value;
+
+        pixels[0] = getAdjacentPx((daPointer - 2 * width) - 2, lonSimilar > 0 && latSimilar > 0);
+        pixels[1] = getAdjacentPx(daPointer - 2 * width, latSimilar > 0);
+        pixels[2] = getAdjacentPx((daPointer - 2 * width) + 2, lonSimilar < width - 1 && latSimilar > 0);
+        pixels[3] = getAdjacentPx(daPointer - 2, lonSimilar > 0);
+        pixels[5] = getAdjacentPx(daPointer + 2, lonSimilar < width - 1);
+        pixels[6] = getAdjacentPx((daPointer + 2 * width) - 2, lonSimilar > 0 && latSimilar < width - 1);
+        pixels[7] = getAdjacentPx(daPointer + 2 * width, latSimilar < width - 1);
+        pixels[8] = getAdjacentPx((daPointer + 2 * width) + 2, lonSimilar < width - 1 && latSimilar < width - 1);
+
+        return pixels;
+    }
+
     public void toImage( String imageFile ) throws IOException
     {
         ImageIO.write(makeARGB(), "PNG", new File(imageFile));
diff --git a/core/src/main/java/com/graphhopper/reader/dem/LinearFilter.java b/core/src/main/java/com/graphhopper/reader/dem/LinearFilter.java
new file mode 100644
index 0000000000..110c5cc0f2
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/LinearFilter.java
@@ -0,0 +1,29 @@
+package com.graphhopper.reader.dem;
+
+
+public class LinearFilter implements Filter {
+
+    private int[] pixels;
+    private double[] kernel;
+
+    public LinearFilter(int[] px, double[] kernel) {
+        this.pixels = px;
+        this.kernel = kernel;
+    }
+
+
+    @Override
+    public int apply() {
+
+        double result = 0;
+
+        for(int i = 0; i < pixels.length; i++) {
+            result += pixels[i] * kernel[i];
+            System.out.println("Pixel: " + pixels[i]);
+            System.out.println("Kernel: " + kernel[i]);
+
+        }
+
+        return (int) result;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/MedianFilter.java b/core/src/main/java/com/graphhopper/reader/dem/MedianFilter.java
new file mode 100644
index 0000000000..c0ca5dd57c
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/MedianFilter.java
@@ -0,0 +1,24 @@
+package com.graphhopper.reader.dem;
+
+import java.util.Arrays;
+
+
+public class MedianFilter implements Filter {
+
+    private int[] pixels;
+
+    public MedianFilter(int[] px){
+        this.pixels = px;
+    }
+
+    @Override
+    public int apply() {
+
+        Arrays.sort(this.pixels);
+
+        int medianIndex = (int) (this.pixels.length / 2);
+
+        return this.pixels[medianIndex];
+
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index afa060296a..483e0b9978 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -54,6 +54,7 @@
     protected final double invPrecision = 1 / precision;
     // mirror: base = "http://mirror.ufs.ac.za/datasets/SRTM3/"
     private boolean calcMean = false;
+    private boolean calcMedian = false;
     protected String baseUrl;
 
     @Override
@@ -62,6 +63,10 @@ public void setCalcMean( boolean calcMean )
         this.calcMean = calcMean;
     }
 
+    @Override
+    public void setCalcMedian( boolean calcMedian) {
+        this.calcMedian = calcMedian;
+    }
 
     // use int key instead of string for lower memory usage
     protected int calcIntKey( double lat, double lon )
@@ -138,6 +143,7 @@ public double getEle( double lat, double lon )
             int minLon = down(lon);
             demProvider = new HeightTile(minLat, minLon, WIDTH, precision, 1);
             demProvider.setCalcMean(calcMean);
+            demProvider.setCalcMedian(calcMedian);
             cacheData.put(intKey, demProvider);
             DataAccess heights = getDirectory().find("dem" + intKey);
             demProvider.setHeights(heights);
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SouthTyrolProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SouthTyrolProvider.java
deleted file mode 100644
index 3de2b7f35c..0000000000
--- a/core/src/main/java/com/graphhopper/reader/dem/SouthTyrolProvider.java
+++ /dev/null
@@ -1,214 +0,0 @@
-package com.graphhopper.reader.dem;
-
-
-import com.graphhopper.storage.DAType;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.GHDirectory;
-import com.graphhopper.util.Helper;
-import org.apache.xmlgraphics.image.codec.tiff.TIFFDecodeParam;
-import org.apache.xmlgraphics.image.codec.tiff.TIFFImageDecoder;
-import org.apache.xmlgraphics.image.codec.util.SeekableStream;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.awt.image.Raster;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.HashMap;
-import java.util.Map;
-
-public class SouthTyrolProvider implements ElevationProvider{
-
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final Map<String, HeightTile> cacheData = new HashMap<String, HeightTile>();
-    private final int WIDTH = 5305;
-    private File cacheDir = new File("/tmp/southTyrol");
-    private Directory dir;
-    private DAType daType = DAType.MMAP;
-    final double precision = 1e7;
-    private final double invPrecision = 1 / precision;
-    private boolean calcMean = false;
-    private boolean autoRemoveTemporary = true;
-
-    private String dataFileName = "DTM-2p5m";
-
-    /**
-     * Creating temporary files can take a long time as we need to unpack tiff as well as to fill
-     * our DataAccess object, so this option can be used to disable the default clear mechanism via
-     * specifying 'false'.
-     */
-    public void setAutoRemoveTemporaryFiles( boolean autoRemoveTemporary )
-    {
-        this.autoRemoveTemporary = autoRemoveTemporary;
-    }
-
-    @Override
-    public double getEle(double lat, double lon) {
-
-        lat = (int) (lat * precision) / precision;
-        lon = (int) (lon * precision) / precision;
-
-        HeightTile demProvider = cacheData.get(dataFileName);
-
-        if(demProvider == null) {
-
-            if (!cacheDir.exists())
-                cacheDir.mkdirs();
-
-            int minLat = down(lat);
-            int minLon = down(lon);
-
-            demProvider = new HeightTile(minLat, minLon, WIDTH, precision, 1);
-            demProvider.setCalcMean(calcMean);
-
-            cacheData.put(dataFileName, demProvider);
-            DataAccess heights = getDirectory().find(dataFileName + ".gh");
-            demProvider.setHeights(heights);
-            boolean loadExisting = false;
-            try
-            {
-                loadExisting = heights.loadExisting();
-            } catch (Exception ex)
-            {
-                logger.warn("cannot load " + dataFileName + ", error:" + ex.getMessage());
-            }
-
-            if (!loadExisting){
-
-                String tifName = dataFileName + ".tif";
-                File file = new File(cacheDir, tifName);
-
-                // short == 2 bytes
-                heights.create(2 * WIDTH * WIDTH);
-
-                Raster raster;
-                SeekableStream ss = null;
-
-                try
-                {
-                    InputStream is = new FileInputStream(file);
-
-                    ss = SeekableStream.wrapInputStream(is, true);
-                    TIFFImageDecoder imageDecoder = new TIFFImageDecoder(ss, new TIFFDecodeParam());
-                    raster = imageDecoder.decodeAsRaster();
-                } catch (Exception e)
-                {
-                    throw new RuntimeException("Can't decode " + tifName, e);
-                } finally
-                {
-                    if (ss != null)
-                        Helper.close(ss);
-                }
-
-                // logger.info("start converting to our format");
-                final int height = raster.getHeight();
-                final int width = raster.getWidth();
-                int x = 0, y = 0;
-                try
-                {
-                    for (y = 0; y < height; y++)
-                    {
-                        for (x = 0; x < width; x++)
-                        {
-                            short val = (short) raster.getPixel(x, y, (int[]) null)[0];
-                            if (val < -1000 || val > 12000)
-                                val = Short.MIN_VALUE;
-
-                            heights.setShort(2 * (y * WIDTH + x), val);
-                        }
-                    }
-                    heights.flush();
-
-                } catch (Exception ex)
-                {
-                    throw new RuntimeException("Problem at x:" + x + ", y:" + y, ex);
-                }
-
-            }
-
-        }
-
-        if (demProvider.isSeaLevel())
-            return 0;
-
-        return demProvider.getHeight(lat, lon);
-    }
-
-    int down( double val )
-    {
-        int intVal = (int) val;
-        if (val >= 0 || intVal - val < invPrecision)
-            return intVal;
-        return intVal - 1;
-    }
-
-    private Directory getDirectory()
-    {
-        if (dir != null)
-            return dir;
-
-        return dir = new GHDirectory(cacheDir.getAbsolutePath(), daType);
-    }
-
-    @Override
-    public ElevationProvider setBaseURL(String baseURL) {
-        return null;
-    }
-
-    @Override
-    public ElevationProvider setCacheDir(File cacheDir) {
-        if (cacheDir.exists() && !cacheDir.isDirectory())
-            throw new IllegalArgumentException("Cache path has to be a directory");
-        try
-        {
-            this.cacheDir = cacheDir.getCanonicalFile();
-        } catch (IOException ex)
-        {
-            throw new RuntimeException(ex);
-        }
-        return this;
-    }
-
-    protected File getCacheDir()
-    {
-        return cacheDir;
-    }
-
-    @Override
-    public ElevationProvider setDAType(DAType daType) {
-        this.daType = daType;
-        return this;
-    }
-
-    @Override
-    public void setCalcMean(boolean calcMean) {
-        this.calcMean = calcMean;
-    }
-
-    @Override
-    public void release() {
-        cacheData.clear();
-
-        // for memory mapped type we create temporary unpacked files which should be removed
-        if (autoRemoveTemporary && dir != null)
-            dir.clear();
-    }
-
-    @Override
-    public String toString()
-    {
-        return "SouthTyrol";
-    }
-
-    public static void main(String[] args){
-
-        ElevationProvider elevationProvider = new SouthTyrolProvider();
-
-        System.out.println(elevationProvider.getEle(46.544167, 11.562222));
-
-    }
-
-}
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index b5aff65a8c..34d3f9fca3 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -182,6 +182,9 @@ void prepareAlgo()
         parts = Math.round(Math.sqrt(parts));
         deltaLat = (bounds.maxLat - bounds.minLat) / parts;
         deltaLon = (bounds.maxLon - bounds.minLon) / parts;
+
+        System.out.println("INFO parts: " + parts + ", deltaLat: " + deltaLat + ", deltaLon: " + deltaLon);
+
     }
 
     private LocationIndexTree initEntries( int[] entries )
