diff --git a/.travis.yml b/.travis.yml
index 3bf2a5c51a..f1e53db4fa 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -12,9 +12,9 @@ env:
 matrix:
   include:
     - jdk: openjdk8
-    - env: JDK='OpenJDK 12'
+    - env: JDK='OpenJDK 11'
       install: . ./install-jdk.sh -F 11 -C
-    - env: JDK='OpenJDK 13'
+    - env: JDK='OpenJDK 12'
       install: . ./install-jdk.sh -F 12 -C
     
 # avoid default dependency command for maven, 'true' means 'return true' and continue
diff --git a/android/app/build.gradle b/android/app/build.gradle
index fc4d4ea6ba..84be98bc17 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -42,14 +42,14 @@ dependencies {
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    implementation 'org.mapsforge:vtm:0.11.0'
-    implementation 'org.mapsforge:vtm-android:0.11.0'
-    implementation 'org.mapsforge:vtm-android:0.11.0:natives-armeabi-v7a'
-    implementation 'org.mapsforge:vtm-android:0.11.0:natives-arm64-v8a'
-    implementation 'org.mapsforge:vtm-android:0.11.0:natives-x86'
-    implementation 'org.mapsforge:vtm-android:0.11.0:natives-x86_64'
-    implementation 'org.mapsforge:vtm-jts:0.11.0'
-    implementation 'org.mapsforge:vtm-themes:0.11.0'
+    implementation 'org.mapsforge:vtm:0.11.1'
+    implementation 'org.mapsforge:vtm-android:0.11.1'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-armeabi-v7a'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-arm64-v8a'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-x86'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-x86_64'
+    implementation 'org.mapsforge:vtm-jts:0.11.1'
+    implementation 'org.mapsforge:vtm-themes:0.11.1'
     implementation 'com.caverock:androidsvg:1.3'
 
     implementation 'org.slf4j:slf4j-api:1.7.25'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index ade25517b7..de30b700e4 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -19,7 +19,7 @@
         <version>0.13-SNAPSHOT</version>
     </parent>
     <properties>
-        <vtm.version>0.11.0</vtm.version>
+        <vtm.version>0.11.1</vtm.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
diff --git a/android/build.gradle b/android/build.gradle
index ca48f6921f..6b199027f8 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.3.2'
+        classpath 'com.android.tools.build:gradle:3.4.0'
     }
 }
 
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index 4e974715fd..c4486d47dc 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/api/src/main/java/com/graphhopper/util/Instruction.java b/api/src/main/java/com/graphhopper/util/Instruction.java
index 921d2e3383..8e7612b951 100644
--- a/api/src/main/java/com/graphhopper/util/Instruction.java
+++ b/api/src/main/java/com/graphhopper/util/Instruction.java
@@ -18,7 +18,6 @@
 package com.graphhopper.util;
 
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
 public class Instruction {
@@ -127,24 +126,6 @@ public Instruction setTime(long time) {
         return this;
     }
 
-    /**
-     * Latitude of the location where this instruction should take place.
-     */
-    double getFirstLat() {
-        return points.getLatitude(0);
-    }
-
-    /**
-     * Longitude of the location where this instruction should take place.
-     */
-    double getFirstLon() {
-        return points.getLongitude(0);
-    }
-
-    double getFirstEle() {
-        return points.getElevation(0);
-    }
-
     /* This method returns the points associated to this instruction. Please note that it will not include the last point,
      * i.e. the first point of the next instruction object.
      */
@@ -156,43 +137,6 @@ public void setPoints(PointList points) {
         this.points = points;
     }
 
-    /**
-     * This method returns a list of gpx entries where the time (in time) is relative to the first
-     * which is 0. It does NOT contain the last point which is the first of the next instruction.
-     *
-     * @return the time offset to add for the next instruction
-     */
-    long fillGPXList(List<GPXEntry> list, long time,
-                     Instruction prevInstr, Instruction nextInstr, boolean firstInstr) {
-        checkOne();
-        int len = points.size();
-        long prevTime = time;
-        double lat = points.getLatitude(0);
-        double lon = points.getLongitude(0);
-        double ele = Double.NaN;
-        boolean is3D = points.is3D();
-        if (is3D)
-            ele = points.getElevation(0);
-
-        for (int i = 0; i < len; i++) {
-            list.add(new GPXEntry(lat, lon, ele, prevTime));
-
-            boolean last = i + 1 == len;
-            double nextLat = last ? nextInstr.getFirstLat() : points.getLatitude(i + 1);
-            double nextLon = last ? nextInstr.getFirstLon() : points.getLongitude(i + 1);
-            double nextEle = is3D ? (last ? nextInstr.getFirstEle() : points.getElevation(i + 1)) : Double.NaN;
-            if (is3D)
-                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, nextEle, lat, lon, ele) / distance);
-            else
-                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, lat, lon) / distance);
-
-            lat = nextLat;
-            lon = nextLon;
-            ele = nextEle;
-        }
-        return time + this.time;
-    }
-
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder();
@@ -209,7 +153,7 @@ public String toString() {
      * Return the direction like 'NE' based on the first tracksegment of the instruction. If
      * Instruction does not contain enough coordinate points, an empty string will be returned.
      */
-    String calcDirection(Instruction nextI) {
+    public String calcDirection(Instruction nextI) {
         double azimuth = calcAzimuth(nextI);
         if (Double.isNaN(azimuth))
             return "";
@@ -241,11 +185,6 @@ public double calcAzimuth(Instruction nextI) {
         return AC.calcAzimuth(lat, lon, nextLat, nextLon);
     }
 
-    void checkOne() {
-        if (points.size() < 1)
-            throw new IllegalStateException("Instruction must contain at least one point " + toString());
-    }
-
     /**
      * This method returns the length of an Instruction. The length of an instruction is defined by [the
      * index of the first point of the next instruction] - [the index of the first point of this instruction].
diff --git a/api/src/main/java/com/graphhopper/util/InstructionList.java b/api/src/main/java/com/graphhopper/util/InstructionList.java
index 5d9192e6be..69aafcad97 100644
--- a/api/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/api/src/main/java/com/graphhopper/util/InstructionList.java
@@ -17,9 +17,6 @@
  */
 package com.graphhopper.util;
 
-import java.text.DateFormat;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
 import java.util.*;
 
 /**
@@ -27,13 +24,6 @@
  */
 public class InstructionList extends AbstractList<Instruction> {
 
-    static String simpleXMLEscape(String str) {
-        // We could even use the 'more flexible' CDATA section but for now do the following. The 'and' could be important sometimes:
-        return str.replaceAll("&", "&amp;").
-                // but do not care for:
-                        replaceAll("[\\<\\>]", "_");
-    }
-
     private final List<Instruction> instructions;
     private final Translation tr;
 
@@ -71,211 +61,6 @@ public Instruction remove(int index) {
         return instructions.remove(index);
     }
 
-    public void replaceLast(Instruction instr) {
-        if (instructions.isEmpty())
-            throw new IllegalStateException("Cannot replace last instruction as list is empty");
-
-        instructions.set(instructions.size() - 1, instr);
-    }
-
-    public List<Map<String, Object>> createJson() {
-        List<Map<String, Object>> instrList = new ArrayList<>(instructions.size());
-        int pointsIndex = 0;
-        int counter = 0;
-        for (Instruction instruction : instructions) {
-            Map<String, Object> instrJson = new HashMap<>();
-            instrList.add(instrJson);
-
-            InstructionAnnotation ia = instruction.getAnnotation();
-            String text = instruction.getTurnDescription(tr);
-            if (Helper.isEmpty(text))
-                text = ia.getMessage();
-            instrJson.put("text", Helper.firstBig(text));
-            if (!ia.isEmpty()) {
-                instrJson.put("annotation_text", ia.getMessage());
-                instrJson.put("annotation_importance", ia.getImportance());
-            }
-
-            instrJson.put("street_name", instruction.getName());
-            instrJson.put("time", instruction.getTime());
-            instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
-            instrJson.put("sign", instruction.getSign());
-            instrJson.putAll(instruction.getExtraInfoJSON());
-
-            int tmpIndex = pointsIndex + instruction.getLength();
-            instrJson.put("interval", Arrays.asList(pointsIndex, tmpIndex));
-            pointsIndex = tmpIndex;
-
-            counter++;
-        }
-        return instrList;
-    }
-
-    /**
-     * @return This method returns a list of gpx entries where the time (in millis) is relative to
-     * the first which is 0.
-     */
-    public List<GPXEntry> createGPXList() {
-        if (isEmpty())
-            return Collections.emptyList();
-
-        List<GPXEntry> gpxList = new ArrayList<>();
-        long timeOffset = 0;
-        for (int i = 0; i < size() - 1; i++) {
-            Instruction prevInstr = (i > 0) ? get(i - 1) : null;
-            boolean instrIsFirst = prevInstr == null;
-            Instruction nextInstr = get(i + 1);
-            nextInstr.checkOne();
-            // current instruction does not contain last point which is equals to first point of next instruction:
-            timeOffset = get(i).fillGPXList(gpxList, timeOffset, prevInstr, nextInstr, instrIsFirst);
-        }
-        Instruction lastI = get(size() - 1);
-        if (lastI.points.size() != 1)
-            throw new IllegalStateException("Last instruction must have exactly one point but was " + lastI.points.size());
-        double lastLat = lastI.getFirstLat(), lastLon = lastI.getFirstLon(),
-                lastEle = lastI.getPoints().is3D() ? lastI.getFirstEle() : Double.NaN;
-        gpxList.add(new GPXEntry(lastLat, lastLon, lastEle, timeOffset));
-        return gpxList;
-    }
-
-    /**
-     * Creates the standard GPX string out of the points according to the schema found here:
-     * https://graphhopper.com/public/schema/gpx-1.1.xsd
-     * <p>
-     *
-     * @return string to be stored as gpx file
-     */
-    public String createGPX(String version) {
-        return createGPX("GraphHopper", new Date().getTime(), version);
-    }
-
-    public String createGPX(String trackName, long startTimeMillis, String version) {
-        boolean includeElevation = size() > 0 && get(0).getPoints().is3D();
-        return createGPX(trackName, startTimeMillis, includeElevation, true, true, true, version);
-    }
-
-    private void createWayPointBlock(StringBuilder output, Instruction instruction, DecimalFormat decimalFormat) {
-        output.append("\n<wpt ");
-        output.append("lat=\"").append(decimalFormat.format(instruction.getFirstLat()));
-        output.append("\" lon=\"").append(decimalFormat.format(instruction.getFirstLon())).append("\">");
-        String name;
-        if (instruction.getName().isEmpty())
-            name = instruction.getTurnDescription(tr);
-        else
-            name = instruction.getName();
-
-        output.append(" <name>").append(simpleXMLEscape(name)).append("</name>");
-        output.append("</wpt>");
-    }
-
-    public String createGPX(String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version) {
-        DateFormat formatter = Helper.createFormatter();
-
-        DecimalFormat decimalFormat = new DecimalFormat("#", DecimalFormatSymbols.getInstance(Locale.ROOT));
-        decimalFormat.setMinimumFractionDigits(1);
-        decimalFormat.setMaximumFractionDigits(6);
-        decimalFormat.setMinimumIntegerDigits(1);
-
-        String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
-                + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
-                + " creator=\"Graphhopper version " + version + "\" version=\"1.1\""
-                // This xmlns:gh acts only as ID, no valid URL necessary.
-                // Use a separate namespace for custom extensions to make basecamp happy.
-                + " xmlns:gh=\"https://graphhopper.com/public/schema/gpx/1.1\">"
-                + "\n<metadata>"
-                + "<copyright author=\"OpenStreetMap contributors\"/>"
-                + "<link href=\"http://graphhopper.com\">"
-                + "<text>GraphHopper GPX</text>"
-                + "</link>"
-                + "<time>" + formatter.format(startTimeMillis) + "</time>"
-                + "</metadata>";
-        StringBuilder gpxOutput = new StringBuilder(header);
-        if (!isEmpty()) {
-            if (withWayPoints) {
-                createWayPointBlock(gpxOutput, instructions.get(0), decimalFormat);   // Start
-                for (Instruction currInstr : instructions) {
-                    if ((currInstr.getSign() == Instruction.REACHED_VIA) // Via
-                            || (currInstr.getSign() == Instruction.FINISH)) // End
-                    {
-                        createWayPointBlock(gpxOutput, currInstr, decimalFormat);
-                    }
-                }
-            }
-            if (withRoute) {
-                gpxOutput.append("\n<rte>");
-                Instruction nextInstr = null;
-                for (Instruction currInstr : instructions) {
-                    if (null != nextInstr)
-                        createRteptBlock(gpxOutput, nextInstr, currInstr, decimalFormat);
-
-                    nextInstr = currInstr;
-                }
-                createRteptBlock(gpxOutput, nextInstr, null, decimalFormat);
-                gpxOutput.append("\n</rte>");
-            }
-        }
-        if (withTrack) {
-            gpxOutput.append("\n<trk><name>").append(trackName).append("</name>");
-
-            gpxOutput.append("<trkseg>");
-            for (GPXEntry entry : createGPXList()) {
-                gpxOutput.append("\n<trkpt lat=\"").append(decimalFormat.format(entry.getLat()));
-                gpxOutput.append("\" lon=\"").append(decimalFormat.format(entry.getLon())).append("\">");
-                if (includeElevation)
-                    gpxOutput.append("<ele>").append(Helper.round2(entry.getEle())).append("</ele>");
-                gpxOutput.append("<time>").append(formatter.format(startTimeMillis + entry.getTime())).append("</time>");
-                gpxOutput.append("</trkpt>");
-            }
-            gpxOutput.append("\n</trkseg>");
-            gpxOutput.append("\n</trk>");
-        }
-
-        // we could now use 'wpt' for via points
-        gpxOutput.append("\n</gpx>");
-        return gpxOutput.toString();
-    }
-
-    public void createRteptBlock(StringBuilder output, Instruction instruction, Instruction nextI, DecimalFormat decimalFormat) {
-        output.append("\n<rtept lat=\"").append(decimalFormat.format(instruction.getFirstLat())).
-                append("\" lon=\"").append(decimalFormat.format(instruction.getFirstLon())).append("\">");
-
-        if (!instruction.getName().isEmpty())
-            output.append("<desc>").append(simpleXMLEscape(instruction.getTurnDescription(tr))).append("</desc>");
-
-        output.append("<extensions>");
-        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
-        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
-
-        String direction = instruction.calcDirection(nextI);
-        if (!direction.isEmpty())
-            output.append("<gh:direction>").append(direction).append("</gh:direction>");
-
-        double azimuth = instruction.calcAzimuth(nextI);
-        if (!Double.isNaN(azimuth))
-            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
-
-        if (instruction instanceof RoundaboutInstruction) {
-            RoundaboutInstruction ri = (RoundaboutInstruction) instruction;
-
-            output.append("<gh:exit_number>").append(ri.getExitNumber()).append("</gh:exit_number>");
-        }
-
-        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
-        output.append("</extensions>");
-        output.append("</rtept>");
-    }
-
-    /**
-     * @return list of lat lon
-     */
-    List<List<Double>> createStartPoints() {
-        List<List<Double>> res = new ArrayList<>(instructions.size());
-        for (Instruction instruction : instructions) {
-            res.add(Arrays.asList(instruction.getFirstLat(), instruction.getFirstLon()));
-        }
-        return res;
-    }
-
     /**
      * This method is useful for navigation devices to find the next instruction for the specified
      * coordinate (e.g. the current position).
@@ -339,4 +124,8 @@ public Instruction find(double lat, double lon, double maxDistance) {
         return get(foundInstruction);
     }
 
+    public Translation getTr() {
+        return tr;
+    }
+
 }
diff --git a/api/src/main/java/com/graphhopper/util/PointList.java b/api/src/main/java/com/graphhopper/util/PointList.java
index 11ae6f155e..92b347dd2d 100644
--- a/api/src/main/java/com/graphhopper/util/PointList.java
+++ b/api/src/main/java/com/graphhopper/util/PointList.java
@@ -136,7 +136,7 @@ public int size() {
         }
 
         @Override
-        public GHPoint3D toGHPoint(int index) {
+        public GHPoint3D get(int index) {
             throw new UnsupportedOperationException("cannot access EMPTY PointList");
         }
 
@@ -571,7 +571,7 @@ public void parse2DJSON(String str) {
         }
     }
 
-    public GHPoint3D toGHPoint(int index) {
+    public GHPoint3D get(int index) {
         return new GHPoint3D(getLatitude(index), getLongitude(index), getElevation(index));
     }
 
@@ -594,7 +594,7 @@ public GHPoint3D next() {
                 if (counter >= getSize())
                     throw new NoSuchElementException();
 
-                GHPoint3D point = PointList.this.toGHPoint(counter);
+                GHPoint3D point = PointList.this.get(counter);
                 counter++;
                 return point;
             }
diff --git a/api/src/main/java/com/graphhopper/util/shapes/BBox.java b/api/src/main/java/com/graphhopper/util/shapes/BBox.java
index ed716f56d1..9a73055f9c 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
+import org.locationtech.jts.geom.Envelope;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -46,7 +47,7 @@
     public double maxEle;
 
     public BBox(double[] coords) {
-        this(coords[0],coords[2],coords[1],coords[3]);
+        this(coords[0], coords[2], coords[1], coords[3]);
     }
 
     public BBox(double minLon, double maxLon, double minLat, double maxLat) {
@@ -122,7 +123,7 @@ public void update(double lat, double lon, double elev) {
      * @return the intersecting BBox or null if not intersecting
      */
     public BBox calculateIntersection(BBox bBox) {
-        if (!this.intersect(bBox))
+        if (!this.intersects(bBox))
             return null;
 
         double minLon = Math.max(this.minLon, bBox.minLon);
@@ -139,11 +140,11 @@ public BBox clone() {
     }
 
     @Override
-    public boolean intersect(Shape s) {
+    public boolean intersects(Shape s) {
         if (s instanceof BBox) {
-            return intersect((BBox) s);
+            return intersects((BBox) s);
         } else if (s instanceof Circle) {
-            return ((Circle) s).intersect(this);
+            return ((Circle) s).intersects(this);
         }
 
         throw new UnsupportedOperationException("unsupported shape");
@@ -160,14 +161,24 @@ public boolean contains(Shape s) {
         throw new UnsupportedOperationException("unsupported shape");
     }
 
-    public boolean intersect(Circle s) {
-        return ((Circle) s).intersect(this);
+    public boolean intersects(Circle s) {
+        return s.intersects(this);
     }
 
-    public boolean intersect(BBox o) {
+    /**
+     * This method calculates if this BBox intersects with the specified BBox
+     */
+    public boolean intersects(double minLon, double maxLon, double minLat, double maxLat) {
+        return this.minLon < maxLon && this.minLat < maxLat && minLon < this.maxLon && minLat < this.maxLat;
+    }
+
+    /**
+     * This method calculates if this BBox intersects with the specified BBox
+     */
+    public boolean intersects(BBox o) {
         // return (o.minLon < minLon && o.maxLon > minLon || o.minLon < maxLon && o.minLon >= minLon)
         //  && (o.maxLat < maxLat && o.maxLat >= minLat || o.maxLat >= maxLat && o.minLat < maxLat);
-        return minLon < o.maxLon && minLat < o.maxLat && o.minLon < maxLon && o.minLat < maxLat;
+        return this.minLon < o.maxLon && this.minLat < o.maxLat && o.minLon < this.maxLon && o.minLat < this.maxLat;
     }
 
     @Override
@@ -272,6 +283,10 @@ public boolean isValid() {
         return list;
     }
 
+    public static BBox fromEnvelope(Envelope envelope) {
+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());
+    }
+
     /**
      * @return an estimated area in m^2 using the mean value of latitudes for longitude distance
      */
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Circle.java b/api/src/main/java/com/graphhopper/util/shapes/Circle.java
index 0bf6a57b80..bbb38ee334 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Circle.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Circle.java
@@ -73,14 +73,14 @@ private double normDist(double lat1, double lon1) {
     }
 
     @Override
-    public boolean intersect(Shape o) {
+    public boolean intersects(Shape o) {
         if (o instanceof Circle) {
-            return intersect((Circle) o);
+            return intersects((Circle) o);
         } else if (o instanceof BBox) {
-            return intersect((BBox) o);
+            return intersects((BBox) o);
         }
 
-        return o.intersect(this);
+        return o.intersects(this);
     }
 
     @Override
@@ -94,8 +94,8 @@ public boolean contains(Shape o) {
         throw new UnsupportedOperationException("unsupported shape");
     }
 
-    public boolean intersect(BBox b) {
-        // test top intersect
+    public boolean intersects(BBox b) {
+        // test top intersects
         if (lat > b.maxLat) {
             if (lon < b.minLon) {
                 return normDist(b.maxLat, b.minLon) <= normedDist;
@@ -106,7 +106,7 @@ public boolean intersect(BBox b) {
             return b.maxLat - bbox.minLat > 0;
         }
 
-        // test bottom intersect
+        // test bottom intersects
         if (lat < b.minLat) {
             if (lon < b.minLon) {
                 return normDist(b.minLat, b.minLon) <= normedDist;
@@ -117,7 +117,7 @@ public boolean intersect(BBox b) {
             return bbox.maxLat - b.minLat > 0;
         }
 
-        // test middle intersect
+        // test middle intersects
         if (lon < b.minLon) {
             return bbox.maxLon - b.minLon > 0;
         }
@@ -127,9 +127,9 @@ public boolean intersect(BBox b) {
         return true;
     }
 
-    public boolean intersect(Circle c) {
+    public boolean intersects(Circle c) {
         // necessary to improve speed?
-        if (!getBounds().intersect(c.getBounds())) {
+        if (!getBounds().intersects(c.getBounds())) {
             return false;
         }
 
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
index 52d94115e0..abf7c731cb 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
@@ -100,7 +100,7 @@ public boolean contains(GHPoint point) {
     }
 
     @Override
-    public boolean intersect(Shape o) {
+    public boolean intersects(Shape o) {
         throw new UnsupportedOperationException("Not supported yet.");
     }
 
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Shape.java b/api/src/main/java/com/graphhopper/util/shapes/Shape.java
index dd0f71e5f3..7962c67610 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Shape.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Shape.java
@@ -27,7 +27,7 @@
     /**
      * @return true if edges or areas of this and the specified shapes overlap
      */
-    boolean intersect(Shape o);
+    boolean intersects(Shape o);
 
     /**
      * @return true only if lat and lon are inside (or on the edge) of this shape
diff --git a/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
index dc77fb80d1..321e473b5f 100644
--- a/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
+++ b/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
@@ -71,18 +71,18 @@ public void testIntersect() {
         //
 
         // use ISO 19115 standard (minLon, maxLon followed by minLat(south!),maxLat)
-        assertTrue(new BBox(12, 15, 12, 15).intersect(new BBox(13, 14, 11, 16)));
-        // assertFalse(new BBox(15, 12, 12, 15).intersect(new BBox(16, 15, 11, 14)));
+        assertTrue(new BBox(12, 15, 12, 15).intersects(new BBox(13, 14, 11, 16)));
+        // assertFalse(new BBox(15, 12, 12, 15).intersects(new BBox(16, 15, 11, 14)));
 
         // DOES NOT WORK: use bottom to top coord for lat
-        // assertFalse(new BBox(6, 2, 11, 6).intersect(new BBox(5, 3, 12, 5)));
+        // assertFalse(new BBox(6, 2, 11, 6).intersects(new BBox(5, 3, 12, 5)));
         // so, use bottom-left and top-right corner!
-        assertTrue(new BBox(2, 6, 6, 11).intersect(new BBox(3, 5, 5, 12)));
+        assertTrue(new BBox(2, 6, 6, 11).intersects(new BBox(3, 5, 5, 12)));
 
         // DOES NOT WORK: use bottom to top coord for lat and right to left for lon
-        // assertFalse(new BBox(6, 11, 11, 6).intersect(new BBox(5, 10, 12, 7)));
+        // assertFalse(new BBox(6, 11, 11, 6).intersects(new BBox(5, 10, 12, 7)));
         // so, use bottom-right and top-left corner
-        assertTrue(new BBox(6, 11, 6, 11).intersect(new BBox(7, 10, 5, 12)));
+        assertTrue(new BBox(6, 11, 6, 11).intersects(new BBox(7, 10, 5, 12)));
     }
 
     @Test
@@ -109,37 +109,37 @@ public void testCalculateIntersection() {
     public void testBasicJavaOverload() {
         new BBox(2, 4, 0, 1) {
             @Override
-            public boolean intersect(Circle c) {
+            public boolean intersects(Circle c) {
                 assertTrue(true);
-                return super.intersect(c);
+                return super.intersects(c);
             }
 
             @Override
-            public boolean intersect(Shape c) {
+            public boolean intersects(Shape c) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect(BBox c) {
+            public boolean intersects(BBox c) {
                 assertTrue(false);
                 return true;
             }
-        }.intersect(new Circle(1, 2, 3) {
+        }.intersects(new Circle(1, 2, 3) {
             @Override
-            public boolean intersect(Circle c) {
+            public boolean intersects(Circle c) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect(Shape b) {
+            public boolean intersects(Shape b) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect(BBox b) {
+            public boolean intersects(BBox b) {
                 assertTrue(true);
                 return true;
             }
diff --git a/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java b/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
index 819a944be4..eaf6e18092 100644
--- a/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
+++ b/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
@@ -29,17 +29,17 @@
 public class CircleTest {
     @Test
     public void testIntersectCircleCircle() {
-        assertTrue(new Circle(0, 0, 80000).intersect(new Circle(1, 1, 80000)));
-        assertFalse(new Circle(0, 0, 75000).intersect(new Circle(1, 1, 80000)));
+        assertTrue(new Circle(0, 0, 80000).intersects(new Circle(1, 1, 80000)));
+        assertFalse(new Circle(0, 0, 75000).intersects(new Circle(1, 1, 80000)));
     }
 
     @Test
     public void testIntersectCircleBBox() {
-        assertTrue(new Circle(10, 10, 120000).intersect(new BBox(9, 11, 8, 9)));
-        assertTrue(new BBox(9, 11, 8, 9).intersect(new Circle(10, 10, 120000)));
+        assertTrue(new Circle(10, 10, 120000).intersects(new BBox(9, 11, 8, 9)));
+        assertTrue(new BBox(9, 11, 8, 9).intersects(new Circle(10, 10, 120000)));
 
-        assertFalse(new Circle(10, 10, 110000).intersect(new BBox(9, 11, 8, 9)));
-        assertFalse(new BBox(9, 11, 8, 9).intersect(new Circle(10, 10, 110000)));
+        assertFalse(new Circle(10, 10, 110000).intersects(new BBox(9, 11, 8, 9)));
+        assertFalse(new BBox(9, 11, 8, 9).intersects(new Circle(10, 10, 110000)));
     }
 
     @Test
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
index e88385a674..b6983df46e 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
@@ -225,7 +225,4 @@ protected static String encode(String str) {
         }
     }
 
-    public List<Throwable> readErrors(JsonNode json) {
-        return web.readErrors(json);
-    }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
index 43a219b736..d13d61a27b 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -4,6 +4,7 @@
 import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.fasterxml.jackson.databind.node.JsonNodeFactory;
 import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.jackson.PathWrapperDeserializer;
 import com.graphhopper.util.shapes.GHPoint;
 import okhttp3.OkHttpClient;
 import org.slf4j.Logger;
@@ -110,7 +111,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
 
             JsonNode responseJson = toJSON(postUrl, postResponseStr);
             if (responseJson.has("message")) {
-                matrixResponse.addErrors(readErrors(responseJson));
+                matrixResponse.addErrors(PathWrapperDeserializer.readErrors(objectMapper, responseJson));
                 return matrixResponse;
             }
             if (!responseJson.has("job_id")) {
@@ -139,7 +140,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
                 if (debug) {
                     logger.info(i + " GET URL:" + getUrl + ", response: " + getResponseStr);
                 }
-                matrixResponse.addErrors(readErrors(getResponseJson));
+                matrixResponse.addErrors(PathWrapperDeserializer.readErrors(objectMapper, getResponseJson));
                 if (matrixResponse.hasErrors()) {
                     break;
                 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
index 1761f05c59..38d56eaa72 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
@@ -1,6 +1,7 @@
 package com.graphhopper.api;
 
 import com.fasterxml.jackson.databind.JsonNode;
+import com.graphhopper.jackson.PathWrapperDeserializer;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
 import okhttp3.OkHttpClient;
@@ -99,7 +100,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
             String str = getJson(url);
             JsonNode getResponseJson = objectMapper.reader().readTree(str);
 
-            matrixResponse.addErrors(readErrors(getResponseJson));
+            matrixResponse.addErrors(PathWrapperDeserializer.readErrors(objectMapper, getResponseJson));
             if (!matrixResponse.hasErrors()) {
                 matrixResponse.addErrors(readUsableEntityError(outArraysList, getResponseJson));
             }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index 485da03c52..ec3b26430a 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.api;
 
-import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.GHRequest;
@@ -26,15 +25,17 @@
 import com.graphhopper.PathWrapper;
 import com.graphhopper.http.WebHelper;
 import com.graphhopper.jackson.Jackson;
-import com.graphhopper.util.*;
-import com.graphhopper.util.details.PathDetail;
-import com.graphhopper.util.exceptions.*;
+import com.graphhopper.jackson.PathWrapperDeserializer;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.GHPoint;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
 
-import java.util.*;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
 import static com.graphhopper.util.Helper.round6;
@@ -103,197 +104,6 @@ public OkHttpClient getDownloader() {
         return downloader;
     }
 
-    PathWrapper createPathWrapper(JsonNode path, boolean tmpElevation, boolean turnDescription) {
-        PathWrapper pathWrapper = new PathWrapper();
-        pathWrapper.addErrors(readErrors(path));
-        if (pathWrapper.hasErrors())
-            return pathWrapper;
-
-        if (path.has("snapped_waypoints")) {
-            String snappedPointStr = path.get("snapped_waypoints").asText();
-            PointList snappedPoints = WebHelper.decodePolyline(snappedPointStr, 5, tmpElevation);
-            pathWrapper.setWaypoints(snappedPoints);
-        }
-
-        if (path.has("ascend")) {
-            pathWrapper.setAscend(path.get("ascend").asDouble());
-        }
-        if (path.has("descend")) {
-            pathWrapper.setDescend(path.get("descend").asDouble());
-        }
-        if (path.has("weight")) {
-            pathWrapper.setRouteWeight(path.get("weight").asDouble());
-        }
-        if (path.has("description")) {
-            JsonNode descriptionNode = path.get("description");
-            if (descriptionNode.isArray()) {
-                List<String> description = new ArrayList<>(descriptionNode.size());
-                for (JsonNode descNode : descriptionNode) {
-                    description.add(descNode.asText());
-                }
-                pathWrapper.setDescription(description);
-            } else {
-                throw new IllegalStateException("Description has to be an array");
-            }
-        }
-
-        if (path.has("points")) {
-            String pointStr = path.get("points").asText();
-            PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
-            pathWrapper.setPoints(pointList);
-
-            if (path.has("instructions")) {
-                JsonNode instrArr = path.get("instructions");
-
-                InstructionList il = new InstructionList(null);
-                int viaCount = 1;
-                for (JsonNode jsonObj : instrArr) {
-                    double instDist = jsonObj.get("distance").asDouble();
-                    String text = turnDescription ? jsonObj.get("text").asText() : jsonObj.get("street_name").asText();
-                    long instTime = jsonObj.get("time").asLong();
-                    int sign = jsonObj.get("sign").asInt();
-                    JsonNode iv = jsonObj.get("interval");
-                    int from = iv.get(0).asInt();
-                    int to = iv.get(1).asInt();
-                    PointList instPL = new PointList(to - from, tmpElevation);
-                    for (int j = from; j <= to; j++) {
-                        instPL.add(pointList, j);
-                    }
-
-                    InstructionAnnotation ia = InstructionAnnotation.EMPTY;
-                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text")) {
-                        ia = new InstructionAnnotation(jsonObj.get("annotation_importance").asInt(), jsonObj.get("annotation_text").asText());
-                    }
-
-                    Instruction instr;
-                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT) {
-                        RoundaboutInstruction ri = new RoundaboutInstruction(sign, text, ia, instPL);
-
-                        if (jsonObj.has("exit_number")) {
-                            ri.setExitNumber(jsonObj.get("exit_number").asInt());
-                        }
-
-                        if (jsonObj.has("exited")) {
-                            if (jsonObj.get("exited").asBoolean())
-                                ri.setExited();
-                        }
-
-                        if (jsonObj.has("turn_angle")) {
-                            // TODO provide setTurnAngle setter
-                            double angle = jsonObj.get("turn_angle").asDouble();
-                            ri.setDirOfRotation(angle);
-                            ri.setRadian((angle < 0 ? -Math.PI : Math.PI) - angle);
-                        }
-
-                        instr = ri;
-                    } else if (sign == Instruction.REACHED_VIA) {
-                        ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
-                        tmpInstr.setViaCount(viaCount);
-                        viaCount++;
-                        instr = tmpInstr;
-                    } else if (sign == Instruction.FINISH) {
-                        instr = new FinishInstruction(text, instPL, 0);
-                    } else {
-                        instr = new Instruction(sign, text, ia, instPL);
-                        if (sign == Instruction.CONTINUE_ON_STREET) {
-                            if (jsonObj.has("heading")) {
-                                instr.setExtraInfo("heading", jsonObj.get("heading").asDouble());
-                            }
-                        }
-                    }
-
-                    // Usually, the translation is done from the routing service so just use the provided string
-                    // instead of creating a combination with sign and name etc.
-                    // This is called the turn description.
-                    // This can be changed by passing <code>turn_description=false</code>.
-                    if (turnDescription)
-                        instr.setUseRawName();
-
-                    instr.setDistance(instDist).setTime(instTime);
-                    il.add(instr);
-                }
-                pathWrapper.setInstructions(il);
-            }
-
-            if (path.has("details")) {
-                JsonNode details = path.get("details");
-                Map<String, List<PathDetail>> pathDetails = new HashMap<>(details.size());
-                Iterator<Map.Entry<String, JsonNode>> detailIterator = details.fields();
-                while (detailIterator.hasNext()) {
-                    Map.Entry<String, JsonNode> detailEntry = detailIterator.next();
-                    List<PathDetail> pathDetailList = new ArrayList<>();
-                    for (JsonNode pathDetail : detailEntry.getValue()) {
-                        PathDetail pd = objectMapper.convertValue(pathDetail, PathDetail.class);
-                        pathDetailList.add(pd);
-                    }
-                    pathDetails.put(detailEntry.getKey(), pathDetailList);
-                }
-                pathWrapper.addPathDetails(pathDetails);
-            }
-        }
-
-        double distance = path.get("distance").asDouble();
-        long time = path.get("time").asLong();
-        pathWrapper.setDistance(distance).setTime(time);
-        return pathWrapper;
-    }
-
-    // Credits to: http://stackoverflow.com/a/24012023/194609
-    private Map<String, Object> toMap(JsonNode object) {
-        return objectMapper.convertValue(object, new TypeReference<Map<String, Object>>() {
-        });
-    }
-
-    public List<Throwable> readErrors(JsonNode json) {
-        List<Throwable> errors = new ArrayList<>();
-        JsonNode errorJson;
-
-        if (json.has("message")) {
-            if (json.has("hints")) {
-                errorJson = json.get("hints");
-            } else {
-                // should not happen
-                errors.add(new RuntimeException(json.get("message").asText()));
-                return errors;
-            }
-        } else
-            return errors;
-
-        for (JsonNode error : errorJson) {
-            String exClass = "";
-            if (error.has("details"))
-                exClass = error.get("details").asText();
-
-            String exMessage = error.get("message").asText();
-
-            if (exClass.equals(UnsupportedOperationException.class.getName()))
-                errors.add(new UnsupportedOperationException(exMessage));
-            else if (exClass.equals(IllegalStateException.class.getName()))
-                errors.add(new IllegalStateException(exMessage));
-            else if (exClass.equals(RuntimeException.class.getName()))
-                errors.add(new DetailedRuntimeException(exMessage, toMap(error)));
-            else if (exClass.equals(IllegalArgumentException.class.getName()))
-                errors.add(new DetailedIllegalArgumentException(exMessage, toMap(error)));
-            else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
-                errors.add(new ConnectionNotFoundException(exMessage, toMap(error)));
-            } else if (exClass.equals(PointNotFoundException.class.getName())) {
-                int pointIndex = error.get("point_index").asInt();
-                errors.add(new PointNotFoundException(exMessage, pointIndex));
-            } else if (exClass.equals(PointOutOfBoundsException.class.getName())) {
-                int pointIndex = error.get("point_index").asInt();
-                errors.add(new PointOutOfBoundsException(exMessage, pointIndex));
-            } else if (exClass.isEmpty())
-                errors.add(new DetailedRuntimeException(exMessage, toMap(error)));
-            else
-                errors.add(new DetailedRuntimeException(exClass + " " + exMessage, toMap(error)));
-        }
-
-        if (json.has("message") && errors.isEmpty())
-            errors.add(new RuntimeException(json.get("message").asText()));
-
-        return errors;
-    }
-
     @Override
     public boolean load(String serviceUrl) {
         this.routeServiceUrl = serviceUrl;
@@ -358,7 +168,7 @@ public GHResponse route(GHRequest request) {
             JsonNode json = objectMapper.reader().readTree(rspBody.byteStream());
 
             GHResponse res = new GHResponse();
-            res.addErrors(readErrors(json));
+            res.addErrors(PathWrapperDeserializer.readErrors(objectMapper, json));
             if (res.hasErrors())
                 return res;
 
@@ -368,7 +178,7 @@ public GHResponse route(GHRequest request) {
             boolean tmpTurnDescription = request.getHints().getBool("turn_description", true);
 
             for (JsonNode path : paths) {
-                PathWrapper altRsp = createPathWrapper(path, tmpElevation, tmpTurnDescription);
+                PathWrapper altRsp = PathWrapperDeserializer.createPathWrapper(objectMapper, path, tmpElevation, tmpTurnDescription);
                 res.add(altRsp);
             }
 
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index 26b881e74c..8dad531807 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -5,6 +5,8 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.PathWrapper;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.jackson.PathWrapperDeserializer;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.RoundaboutInstruction;
@@ -87,7 +89,7 @@ public void testAlternativeRoute() {
         path = paths.get(0);
         isBetween(20, 30, path.getPoints().size());
         isBetween(800, 900, path.getDistance());
-        assertTrue("expected: " + path.getDescription().get(0), Arrays.asList("Jacobistraße", "Ludwig-Gercke-Straße", "Eichendorffplatz").contains(path.getDescription().get(0)));
+        assertTrue("expected: " + path.getDescription().get(0), Arrays.asList("Jacobistraße", "Bismarckstraße", "Ludwig-Gercke-Straße", "Eichendorffplatz").contains(path.getDescription().get(0)));
     }
 
     @Test
@@ -235,22 +237,6 @@ public void testExportWithoutTrack() {
         assertTrue(res.endsWith("</gpx>"));
     }
 
-    @Test
-    public void testCreateGPXFromInstructionList() {
-        GHRequest req = new GHRequest().
-                addPoint(new GHPoint(49.6724, 11.3494)).
-                addPoint(new GHPoint(49.6550, 11.4180));
-        req.getHints().put("elevation", false);
-        req.getHints().put("instructions", true);
-        req.getHints().put("calc_points", true);
-        GHResponse ghResponse = gh.route(req);
-        String gpx = ghResponse.getBest().getInstructions().createGPX("wurst");
-        assertTrue(gpx.contains("<gpx"));
-        assertTrue(gpx.contains("<rtept lat="));
-        assertTrue(gpx.contains("<trk><name>"));
-        assertTrue(gpx.endsWith("</gpx>"));
-    }
-
     void isBetween(double from, double to, double expected) {
         assertTrue("expected value " + expected + " was smaller than limit " + from, expected >= from);
         assertTrue("expected value " + expected + " was bigger than limit " + to, expected <= to);
@@ -307,8 +293,9 @@ protected String postJson(String url, JsonNode data) throws IOException {
     public void testUnknownInstructionSign() throws IOException {
         // Actual path for the request: point=48.354413%2C8.676335&point=48.35442%2C8.676345
         // Modified the sign though
-        JsonNode json = new ObjectMapper().readTree("{\"instructions\":[{\"distance\":1.073,\"sign\":741,\"interval\":[0,1],\"text\":\"Continue onto A 81\",\"time\":32,\"street_name\":\"A 81\"},{\"distance\":0,\"sign\":4,\"interval\":[1,1],\"text\":\"Finish!\",\"time\":0,\"street_name\":\"\"}],\"descend\":0,\"ascend\":0,\"distance\":1.073,\"bbox\":[8.676286,48.354446,8.676297,48.354453],\"weight\":0.032179,\"time\":32,\"points_encoded\":true,\"points\":\"gfcfHwq}s@}c~AAA?\",\"snapped_waypoints\":\"gfcfHwq}s@}c~AAA?\"}");
-        PathWrapper wrapper = new GraphHopperWeb().createPathWrapper(json, true, true);
+        ObjectMapper objectMapper = Jackson.newObjectMapper();
+        JsonNode json = objectMapper.readTree("{\"instructions\":[{\"distance\":1.073,\"sign\":741,\"interval\":[0,1],\"text\":\"Continue onto A 81\",\"time\":32,\"street_name\":\"A 81\"},{\"distance\":0,\"sign\":4,\"interval\":[1,1],\"text\":\"Finish!\",\"time\":0,\"street_name\":\"\"}],\"descend\":0,\"ascend\":0,\"distance\":1.073,\"bbox\":[8.676286,48.354446,8.676297,48.354453],\"weight\":0.032179,\"time\":32,\"points_encoded\":true,\"points\":\"gfcfHwq}s@}c~AAA?\",\"snapped_waypoints\":\"gfcfHwq}s@}c~AAA?\"}");
+        PathWrapper wrapper = PathWrapperDeserializer.createPathWrapper(objectMapper, json, true, true);
 
         assertEquals(741, wrapper.getInstructions().get(0).getSign());
         assertEquals("Continue onto A 81", wrapper.getInstructions().get(0).getName());
diff --git a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
index 8b342cd9ec..145fb56228 100644
--- a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
+++ b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
@@ -157,7 +157,7 @@ public void setMaxExplorationFactor(double explorationFactor) {
     public void setMaxPaths(int maxPaths) {
         this.maxPaths = maxPaths;
         if (this.maxPaths < 2)
-            throw new IllegalStateException("Use normal algorithm with less overhead instead if no alternatives are required");
+            throw new IllegalArgumentException("Use normal algorithm with less overhead instead if no alternatives are required");
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index ed8e6ec444..be54acba19 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -291,7 +291,7 @@ private double distanceOfSnappedPointToPillarNode(QueryResult o) {
                     }
                 });
 
-                GHPoint3D prevPoint = fullPL.toGHPoint(0);
+                GHPoint3D prevPoint = fullPL.get(0);
                 int adjNode = closestEdge.getAdjNode();
                 int origEdgeKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), false);
                 int origRevEdgeKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), true);
@@ -342,7 +342,7 @@ private double distanceOfSnappedPointToPillarNode(QueryResult o) {
                 if (addedEdges)
                     createEdges(origEdgeKey, origRevEdgeKey,
                             prevPoint, prevWayIndex, false,
-                            fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
+                            fullPL.get(fullPL.getSize() - 1), fullPL.getSize() - 2,
                             fullPL, closestEdge, virtNodeId - 1, adjNode);
 
                 return true;
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
index ce6135e1a8..cbefc3d8d1 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
@@ -172,6 +172,7 @@ private long findShortcuts(ShortcutHandler sch) {
                 continue;
 
             final double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
+            // this check is important to prevent calling calcMillis on inaccessible edges and also allows early exit
             if (Double.isInfinite(incomingEdgeWeight)) {
                 continue;
             }
@@ -360,7 +361,7 @@ public String toString() {
             else
                 str = from + "->";
 
-            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
+            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + "), dist: " + dist;
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index f47a6ea926..d2d38ab9c3 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -20,81 +20,29 @@
 import com.graphhopper.routing.PathBidirRef;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.storage.ShortcutUnpacker;
 import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
 
-import java.util.Locale;
-
-/**
- * Recursively unpack shortcuts.
- * <p>
- *
- * @author Peter Karich
- * @see PrepareContractionHierarchies
- */
 public class Path4CH extends PathBidirRef {
-    private final Graph routingGraph;
+    private final ShortcutUnpacker shortcutUnpacker;
 
-    public Path4CH(Graph routingGraph, Graph baseGraph, Weighting weighting) {
+    public Path4CH(Graph routingGraph, Graph baseGraph, final Weighting weighting) {
         super(baseGraph, weighting);
-        this.routingGraph = routingGraph;
+        this.shortcutUnpacker = new ShortcutUnpacker(routingGraph, new ShortcutUnpacker.Visitor() {
+            @Override
+            public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+                distance += edge.getDistance();
+                time += weighting.calcMillis(edge, reverse, EdgeIterator.NO_EDGE);
+                addEdge(edge.getEdge());
+            }
+        });
     }
 
     @Override
     protected final void processEdge(int edgeId, int endNode, int prevEdgeId) {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge(getEdge(edgeId, endNode), false);
-    }
-
-    private void expandEdge(CHEdgeIteratorState edge, boolean reverse) {
-        if (!edge.isShortcut()) {
-            distance += edge.getDistance();
-            time += weighting.calcMillis(edge, reverse, EdgeIterator.NO_EDGE);
-            addEdge(edge.getEdge());
-            return;
-        }
-        expandSkippedEdges(edge.getSkippedEdge1(), edge.getSkippedEdge2(), edge.getBaseNode(), edge.getAdjNode(), reverse);
-    }
-
-    private void expandSkippedEdges(int skippedEdge1, int skippedEdge2, int from, int to, boolean reverse) {
-        // for edge-based CH we need to take special care for loop shortcuts
-        if (from != to) {
-            // get properties like speed of the edge in the correct direction
-            if (reverseOrder == reverse) {
-                int tmp = from;
-                from = to;
-                to = tmp;
-            }
-            CHEdgeIteratorState sk2to = getEdge(skippedEdge2, to);
-            if (sk2to != null) {
-                expandEdge(sk2to, !reverseOrder);
-                expandEdge(getEdge(skippedEdge1, from), reverseOrder);
-            } else {
-                expandEdge(getEdge(skippedEdge1, to), !reverseOrder);
-                expandEdge(getEdge(skippedEdge2, from), reverseOrder);
-            }
-        } else {
-            CHEdgeIteratorState sk1 = getEdge(skippedEdge1, from);
-            CHEdgeIteratorState sk2 = getEdge(skippedEdge2, from);
-            if (sk1.getAdjNode() == sk1.getBaseNode() || sk2.getAdjNode() == sk2.getBaseNode()) {
-                // this is a loop where both skipped edges are loops. but this should never happen.
-                throw new IllegalStateException(String.format(Locale.ROOT,
-                        "error: detected edge where both skipped edges are loops. from: %d, to: %d, " +
-                                "skip-edge1: %d, skip-edge2: %d, reverse: %b", from, to, skippedEdge1, skippedEdge2, reverse));
-            }
-
-            if (!reverseOrder) {
-                expandEdge(sk1, !reverse);
-                expandEdge(sk2, reverse);
-            } else {
-                expandEdge(sk2, reverse);
-                expandEdge(sk1, !reverse);
-            }
-        }
-    }
-
-    private CHEdgeIteratorState getEdge(int edgeId, int adjNode) {
-        return (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(edgeId, adjNode);
+        shortcutUnpacker.visitOriginalEdges(edgeId, endNode, reverseOrder);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
index 7bcdda0fd4..92366a7798 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
@@ -49,8 +49,8 @@ public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrN
         if (reverse && !edgeState.getReverse(accessEnc) || !reverse && !edgeState.get(accessEnc))
             throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. " +
                     "(" + edgeState.getBaseNode() + " - " + edgeState.getAdjNode() + ") "
-                            + edgeState.fetchWayGeometry(3) + " " + edgeState.getDistance() + " "
-                            + "Reverse:" + reverse + ", fwd:" + edgeState.get(accessEnc) + ", bwd:" + edgeState.getReverse(accessEnc));
+                    + edgeState.fetchWayGeometry(3) + ", dist: " + edgeState.getDistance() + " "
+                    + "Reverse:" + reverse + ", fwd:" + edgeState.get(accessEnc) + ", bwd:" + edgeState.getReverse(accessEnc) + ", fwd-speed: " + edgeState.get(avSpeedEnc) + ", bwd-speed: " + edgeState.getReverse(avSpeedEnc));
 
         double speed = reverse ? edgeState.getReverse(avSpeedEnc) : edgeState.get(avSpeedEnc);
         if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
diff --git a/core/src/main/java/com/graphhopper/storage/ShortcutUnpacker.java b/core/src/main/java/com/graphhopper/storage/ShortcutUnpacker.java
new file mode 100644
index 0000000000..cf94ba55b6
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/ShortcutUnpacker.java
@@ -0,0 +1,97 @@
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+import java.util.Locale;
+
+/**
+ * Recursively unpack shortcuts.
+ * <p>
+ *
+ * @author Peter Karich
+ * @author easbar
+ * @see PrepareContractionHierarchies
+ */
+public class ShortcutUnpacker {
+    private final Graph graph;
+    private final Visitor visitor;
+    private boolean reverseOrder;
+
+    public ShortcutUnpacker(Graph graph, Visitor visitor) {
+        this.graph = graph;
+        this.visitor = visitor;
+    }
+
+    /**
+     * Finds an edge/shortcut with the given id and adjNode and calls the visitor for each original edge that is
+     * packed inside this shortcut (or if an original edge is given simply calls the visitor on it).
+     *
+     * @param reverseOrder if true the original edges will be traversed in reverse order
+     */
+    public void visitOriginalEdges(int edgeId, int adjNode, boolean reverseOrder) {
+        this.reverseOrder = reverseOrder;
+        CHEdgeIteratorState edge = getEdge(edgeId, adjNode);
+        if (edge == null) {
+            throw new IllegalArgumentException("Edge with id: " + edgeId + " does not exist or does not touch node " + adjNode);
+        }
+        expandEdge(edge, false);
+    }
+
+    private void expandEdge(CHEdgeIteratorState edge, boolean reverse) {
+        if (!edge.isShortcut()) {
+            // todo: should properly pass previous edge here. for example this is important for turn cost time evaluation
+            // with edge-based CH, #1585
+            visitor.visit(edge, reverse, EdgeIterator.NO_EDGE);
+            return;
+        }
+        expandSkippedEdges(edge.getSkippedEdge1(), edge.getSkippedEdge2(), edge.getBaseNode(), edge.getAdjNode(), reverse);
+    }
+
+    private void expandSkippedEdges(int skippedEdge1, int skippedEdge2, int from, int to, boolean reverse) {
+        // for edge-based CH we need to take special care for loop shortcuts
+        if (from == to) {
+            CHEdgeIteratorState sk1 = getEdge(skippedEdge1, from);
+            CHEdgeIteratorState sk2 = getEdge(skippedEdge2, from);
+            if (sk1.getAdjNode() == sk1.getBaseNode() || sk2.getAdjNode() == sk2.getBaseNode()) {
+                // this is a loop where both skipped edges are loops. but this should never happen.
+                throw new IllegalStateException(String.format(Locale.ROOT,
+                        "error: detected edge where both skipped edges are loops. from: %d, to: %d, " +
+                                "skip-edge1: %d, skip-edge2: %d, reverse: %b", from, to, skippedEdge1, skippedEdge2, reverse));
+            }
+
+            if (reverseOrder == reverse) {
+                expandEdge(sk1, !reverseOrder);
+                expandEdge(sk2, reverseOrder);
+            } else {
+                expandEdge(sk2, !reverseOrder);
+                expandEdge(sk1, reverseOrder);
+            }
+        } else {
+            // get properties like speed of the edge in the correct direction
+            if (reverseOrder != reverse) {
+                int tmp = from;
+                from = to;
+                to = tmp;
+            }
+            CHEdgeIteratorState sk2to = getEdge(skippedEdge2, to);
+            if (sk2to != null) {
+                expandEdge(getEdge(skippedEdge1, from), !reverseOrder);
+                expandEdge(sk2to, reverseOrder);
+            } else {
+                expandEdge(getEdge(skippedEdge2, from), !reverseOrder);
+                expandEdge(getEdge(skippedEdge1, to), reverseOrder);
+            }
+        }
+    }
+
+    private CHEdgeIteratorState getEdge(int edgeId, int adjNode) {
+        return (CHEdgeIteratorState) graph.getEdgeIteratorState(edgeId, adjNode);
+    }
+
+    public interface Visitor {
+        void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
index 005c2538a8..b44e2baea9 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
@@ -23,11 +23,11 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.Circle;
 
 /**
  * Very slow O(n) LocationIndex but no RAM/disc required.
- * <p>
  *
  * @author Peter Karich
  */
@@ -102,6 +102,11 @@ public QueryResult findClosest(double queryLat, double queryLon, EdgeFilter edge
         return res;
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+        throw new IllegalArgumentException("not implemented");
+    }
+
     @Override
     public LocationIndex create(long size) {
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
index 653f666a5c..6d822a44c3 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
@@ -23,6 +23,7 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
 
 /**
  * Same as full index but calculates distance to all edges too
@@ -125,6 +126,11 @@ public QueryResult findClosest(double queryLat, double queryLon, EdgeFilter filt
         return res;
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+        throw new IllegalArgumentException("not implemented");
+    }
+
     @Override
     public LocationIndex create(long size) {
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 2ae3f58ca0..59445254ac 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -337,6 +337,11 @@ protected boolean goFurther(int baseNode) {
         return res;
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+        throw new IllegalArgumentException("not implemented");
+    }
+
     public void goFurtherHook(int n) {
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index a95d49f0d7..0717446450 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -17,8 +17,13 @@
  */
 package com.graphhopper.storage.index;
 
+import com.carrotsearch.hppc.IntHashSet;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Storable;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.shapes.BBox;
 
 /**
  * Provides a way to map real world data "lat,lon" to internal ids/indices of a memory efficient graph
@@ -62,4 +67,56 @@
     LocationIndex setApproximation(boolean approxDist);
 
     void setSegmentSize(int bytes);
+
+    /**
+     * This method explores the nodes in this LocationIndex with the specified Visitor. It guarantees to visit all
+     * unique nodes included in the queryBBox but it could visit more.
+     */
+    void query(BBox queryBBox, Visitor function);
+
+    /**
+     * This interface allows to visit every node stored in the leafs of a LocationIndex.
+     */
+    abstract class Visitor {
+        public boolean isTileInfo() {
+            return false;
+        }
+
+        /**
+         * This method is called if isTileInfo is enabled.
+         */
+        public void onTile(BBox bbox, int depth) {
+        }
+
+        public abstract void onNode(int nodeId);
+    }
+
+    /**
+     * This abstract class allows to visit every edge from the stored nodes in the leafs of the tree for a requested
+     * area. It guarantees to visit all unique edges included in the queryBBox but it could be more.
+     */
+    abstract class EdgeVisitor extends Visitor {
+
+        private final IntHashSet edgeIds = new IntHashSet();
+        private final IntHashSet nodeIds = new IntHashSet();
+        private final EdgeExplorer edgeExplorer;
+
+        public EdgeVisitor(EdgeExplorer edgeExplorer) {
+            this.edgeExplorer = edgeExplorer;
+        }
+
+        public final void onNode(int nodeId) {
+            if (!nodeIds.add(nodeId))
+                return;
+
+            EdgeIterator iter = edgeExplorer.setBaseNode(nodeId);
+            while (iter.next()) {
+                if (!edgeIds.add(iter.getEdge()))
+                    continue;
+                onEdge(iter, nodeId, iter.getAdjNode());
+            }
+        }
+
+        public abstract void onEdge(EdgeIteratorState edge, int nodeA, int nodeB);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 7d4d374b48..1eb58fcc2d 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage.index;
 
 import com.carrotsearch.hppc.IntArrayList;
+import com.carrotsearch.hppc.IntHashSet;
 import com.carrotsearch.hppc.cursors.IntCursor;
 import com.carrotsearch.hppc.predicates.IntPredicate;
 import com.graphhopper.coll.GHBitSet;
@@ -29,18 +30,30 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.Shape;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.util.*;
 
 /**
- * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
- * <p>
- * All leafs are at the same depth, otherwise it is quite complicated to calculate the Bresenham
- * line for different resolutions, especially if a leaf node could be split into a tree-node and
- * resolution changes.
- * <p>
+ * This class implements a Quadtree to get the closest node or edge from GPS coordinates.
+ * The following properties are different to an ordinary implementation:
+ * <ol>
+ * <li>To reduce overall size it can use 16 instead of just 4 cell if required</li>
+ * <li>Still all leafs are at the same depth, otherwise it is too complicated to calculate the Bresenham line for different
+ * resolutions, especially if a leaf node could be split into a tree-node and resolution changes.</li>
+ * <li>To further reduce size this Quadtree avoids storing the bounding box of every cell and calculates this per request instead.</li>
+ * <li>To simplify this querying and avoid a slow down for the most frequent queries ala "lat,lon" it encodes the point
+ * into a reverse spatial key {@see SpatialKeyAlgo} and can the use the resulting raw bits as cell index to recurse
+ * into the subtrees. E.g. if there are 3 layers with 16, 4 and 4 cells each, then the reverse spatial key has
+ * three parts: 4 bits for the cellIndex into the 16 cells, 2 bits for the next layer and 2 bits for the last layer.
+ * It is the reverse spatial key and not the forward spatial key as we need the start of the index for the current
+ * layer at index 0</li>
+ * <li>An array structure (DataAccess) is internally used and stores the offset to the next cell.
+ * E.g. in case of 4 cells, the offset is 0,1,2 or 3. Except when the leaf-depth is reached, then the value
+ * is the number of node IDs stored in the cell or, if negative, just a single node ID.</li>
+ * </ol>
  *
  * @author Peter Karich
  */
@@ -84,7 +97,7 @@ public LocationIndexTree(Graph g, Directory dir) {
         if (g instanceof CHGraph)
             throw new IllegalArgumentException("Use base graph for LocationIndexTree instead of CHGraph");
 
-        MAGIC_INT = Integer.MAX_VALUE / 22316;
+        MAGIC_INT = Integer.MAX_VALUE / 22317;
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
         dataAccess = dir.find("location_index", DAType.getPreferredInt(dir.getDefaultType()));
@@ -145,9 +158,7 @@ void prepareAlgo() {
         tmp /= 4;
         while (tmp > 1) {
             int tmpNo;
-            if (tmp >= 64) {
-                tmpNo = 64;
-            } else if (tmp >= 16) {
+            if (tmp >= 16) {
                 tmpNo = 16;
             } else if (tmp >= 4) {
                 tmpNo = 4;
@@ -335,17 +346,19 @@ IntArrayList getEntries() {
         return IntArrayList.from(entries);
     }
 
-    // fill node IDs according to how they are stored
+    /**
+     * This method fills the set with stored node IDs from the given spatial key part (a latitude-longitude prefix).
+     */
     final void fillIDs(long keyPart, int intIndex, GHIntHashSet set, int depth) {
         long pointer = (long) intIndex << 2;
         if (depth == entries.length) {
-            int value = dataAccess.getInt(pointer);
-            if (value < 0) {
+            int nextIntPointer = dataAccess.getInt(pointer);
+            if (nextIntPointer < 0) {
                 // single data entries (less disc space)
-                set.add(-(value + 1));
+                set.add(-(nextIntPointer + 1));
             } else {
-                long max = (long) value * 4;
-                // leaf entry => value is maxPointer
+                long max = (long) nextIntPointer * 4;
+                // leaf entry => nextIntPointer is maxPointer
                 for (long leafIndex = pointer + 4; leafIndex < max; leafIndex += 4) {
                     set.add(dataAccess.getInt(leafIndex));
                 }
@@ -353,10 +366,10 @@ final void fillIDs(long keyPart, int intIndex, GHIntHashSet set, int depth) {
             return;
         }
         int offset = (int) (bitmasks[depth] & keyPart) << 2;
-        int value = dataAccess.getInt(pointer + offset);
-        if (value > 0) {
+        int nextIntPointer = dataAccess.getInt(pointer + offset);
+        if (nextIntPointer > 0) {
             // tree entry => negative value points to subentries
-            fillIDs(keyPart >>> shifts[depth], value, set, depth + 1);
+            fillIDs(keyPart >>> shifts[depth], nextIntPointer, set, depth + 1);
         }
     }
 
@@ -429,12 +442,76 @@ public double getDeltaLon() {
         return deltaLon;
     }
 
-    GHPoint getCenter(double lat, double lon) {
-        GHPoint query = new GHPoint(lat, lon);
-        long key = keyAlgo.encode(query);
-        GHPoint center = new GHPoint();
-        keyAlgo.decode(key, center);
-        return center;
+    public void query(BBox queryShape, final Visitor function) {
+        BBox bbox = graph.getBounds();
+        final IntHashSet set = new IntHashSet();
+        query(START_POINTER, queryShape,
+                bbox.minLat, bbox.minLon, bbox.maxLat - bbox.minLat, bbox.maxLon - bbox.minLon,
+                new Visitor() {
+                    @Override
+                    public boolean isTileInfo() {
+                        return function.isTileInfo();
+                    }
+
+                    @Override
+                    public void onTile(BBox bbox, int width) {
+                        function.onTile(bbox, width);
+                    }
+
+                    @Override
+                    public void onNode(int nodeId) {
+                        if (set.add(nodeId))
+                            function.onNode(nodeId);
+                    }
+                }, 0);
+    }
+
+    final void query(int intPointer, Shape queryBBox,
+                     double minLat, double minLon,
+                     double deltaLatPerDepth, double deltaLonPerDepth,
+                     Visitor function, int depth) {
+        long pointer = (long) intPointer << 2;
+        if (depth == entries.length) {
+            int nextIntPointer = dataAccess.getInt(pointer);
+            if (nextIntPointer < 0) {
+                // single data entries (less disc space)
+                function.onNode(-(nextIntPointer + 1));
+            } else {
+                long maxPointer = (long) nextIntPointer * 4;
+                // loop through every leaf entry => nextIntPointer is maxPointer
+                for (long leafPointer = pointer + 4; leafPointer < maxPointer; leafPointer += 4) {
+                    // we could read the whole info at once via getBytes instead of getInt
+                    function.onNode(dataAccess.getInt(leafPointer));
+                }
+            }
+            return;
+        }
+        int max = (1 << shifts[depth]);
+        int factor = max == 4 ? 2 : 4;
+        deltaLonPerDepth /= factor;
+        deltaLatPerDepth /= factor;
+        for (int cellIndex = 0; cellIndex < max; cellIndex++) {
+            int nextIntPointer = dataAccess.getInt(pointer + cellIndex * 4);
+            if (nextIntPointer <= 0)
+                continue;
+            // this bit magic does two things for the 4 and 16 tiles case:
+            // 1. it assumes the cellIndex is a reversed spatial key and so it reverses it
+            // 2. it picks every second bit (e.g. for just latitudes) and interprets the result as an integer
+            int latCount = max == 4 ? (cellIndex & 1) : (cellIndex & 1) * 2 + ((cellIndex & 4) == 0 ? 0 : 1);
+            int lonCount = max == 4 ? (cellIndex >> 1) : (cellIndex & 2) + ((cellIndex & 8) == 0 ? 0 : 1);
+            double tmpMinLon = minLon + deltaLonPerDepth * lonCount,
+                    tmpMinLat = minLat + deltaLatPerDepth * latCount;
+
+            BBox bbox = (queryBBox != null || function.isTileInfo()) ? new BBox(tmpMinLon, tmpMinLon + deltaLonPerDepth, tmpMinLat, tmpMinLat + deltaLatPerDepth) : null;
+            if (function.isTileInfo())
+                function.onTile(bbox, depth);
+            if (queryBBox == null || queryBBox.contains(bbox)) {
+                // fill without a restriction!
+                query(nextIntPointer, null, tmpMinLat, tmpMinLon, deltaLatPerDepth, deltaLonPerDepth, function, depth + 1);
+            } else if (queryBBox.intersects(bbox)) {
+                query(nextIntPointer, queryBBox, tmpMinLat, tmpMinLon, deltaLatPerDepth, deltaLonPerDepth, function, depth + 1);
+            }
+        }
     }
 
     /**
@@ -446,8 +523,8 @@ GHPoint getCenter(double lat, double lon) {
      * @return true if no further call of this method is required. False otherwise, ie. a next
      * iteration is necessary and no early finish possible.
      */
-    public final boolean findNetworkEntries(double queryLat, double queryLon,
-                                            GHIntHashSet foundEntries, int iteration) {
+    final boolean findNetworkEntries(double queryLat, double queryLon,
+                                     GHIntHashSet foundEntries, int iteration) {
         // find entries in border of searchbox
         for (int yreg = -iteration; yreg <= iteration; yreg++) {
             double subqueryLat = queryLat + yreg * deltaLat;
@@ -502,7 +579,7 @@ final double calcMinDistance(double queryLat, double queryLon, GHIntHashSet poin
         return min;
     }
 
-    public final void findNetworkEntriesSingleRegion(GHIntHashSet storedNetworkEntryIds, double queryLat, double queryLon) {
+    final void findNetworkEntriesSingleRegion(GHIntHashSet storedNetworkEntryIds, double queryLat, double queryLon) {
         long keyPart = createReverseKey(queryLat, queryLon);
         fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
     }
@@ -711,9 +788,6 @@ IntArrayList getResults() {
 
     // Space efficient sorted integer set. Suited for only a few entries.
     static class SortedIntSet extends IntArrayList {
-        public SortedIntSet() {
-        }
-
         public SortedIntSet(int capacity) {
             super(capacity);
         }
@@ -851,7 +925,7 @@ void addNode(InMemEntry entry, int nodeId, int depth, long keyPart, long key) {
 
         Collection<InMemEntry> getEntriesOf(int selectDepth) {
             List<InMemEntry> list = new ArrayList<>();
-            fillLayer(list, selectDepth, 0, ((InMemTreeEntry) root).getSubEntriesForDebug());
+            fillLayer(list, selectDepth, 0, root.getSubEntriesForDebug());
             return list;
         }
 
@@ -895,48 +969,48 @@ void print(InMemEntry e, StringBuilder sb, long key, int depth) {
         }
 
         // store and freezes tree
-        int store(InMemEntry entry, int intIndex) {
-            long refPointer = (long) intIndex * 4;
+        int store(InMemEntry entry, int intPointer) {
+            long pointer = (long) intPointer * 4;
             if (entry.isLeaf()) {
                 InMemLeafEntry leaf = ((InMemLeafEntry) entry);
                 IntArrayList entries = leaf.getResults();
                 int len = entries.size();
                 if (len == 0) {
-                    return intIndex;
+                    return intPointer;
                 }
                 size += len;
-                intIndex++;
+                intPointer++;
                 leafs++;
-                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
+                dataAccess.ensureCapacity((long) (intPointer + len + 1) * 4);
                 if (len == 1) {
                     // less disc space for single entries
-                    dataAccess.setInt(refPointer, -entries.get(0) - 1);
+                    dataAccess.setInt(pointer, -entries.get(0) - 1);
                 } else {
-                    for (int index = 0; index < len; index++, intIndex++) {
-                        dataAccess.setInt((long) intIndex * 4, entries.get(index));
+                    for (int index = 0; index < len; index++, intPointer++) {
+                        dataAccess.setInt((long) intPointer * 4, entries.get(index));
                     }
-                    dataAccess.setInt(refPointer, intIndex);
+                    dataAccess.setInt(pointer, intPointer);
                 }
             } else {
                 InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
                 int len = treeEntry.subEntries.length;
-                intIndex += len;
-                for (int subCounter = 0; subCounter < len; subCounter++, refPointer += 4) {
+                intPointer += len;
+                for (int subCounter = 0; subCounter < len; subCounter++, pointer += 4) {
                     InMemEntry subEntry = treeEntry.subEntries[subCounter];
                     if (subEntry == null) {
                         continue;
                     }
-                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
-                    int beforeIntIndex = intIndex;
-                    intIndex = store(subEntry, beforeIntIndex);
-                    if (intIndex == beforeIntIndex) {
-                        dataAccess.setInt(refPointer, 0);
+                    dataAccess.ensureCapacity((long) (intPointer + 1) * 4);
+                    int prevIntPointer = intPointer;
+                    intPointer = store(subEntry, prevIntPointer);
+                    if (intPointer == prevIntPointer) {
+                        dataAccess.setInt(pointer, 0);
                     } else {
-                        dataAccess.setInt(refPointer, beforeIntIndex);
+                        dataAccess.setInt(pointer, prevIntPointer);
                     }
                 }
             }
-            return intIndex;
+            return intPointer;
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 8faeec1bdf..f7cc55f642 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -108,7 +108,7 @@ public void doWork(PathWrapper altRsp, List<Path> paths, EncodingManager encodin
                     if (pathIndex + 1 < paths.size()) {
                         ViaInstruction newInstr = new ViaInstruction(fullInstructions.get(fullInstructions.size() - 1));
                         newInstr.setViaCount(pathIndex + 1);
-                        fullInstructions.replaceLast(newInstr);
+                        fullInstructions.set(fullInstructions.size() - 1, newInstr);
                     }
                 }
 
diff --git a/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
index 289ae68b1f..d0b3452fea 100644
--- a/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
@@ -27,10 +27,7 @@
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
@@ -111,6 +108,7 @@ public void testFindPathWithTurnCosts_bidirected_no_shortcuts() {
         // contraction yields no shortcuts
         setLevelEqualToNodeIdForAllNodes();
 
+        // note that we are using the shortest weighting but turn cost times are included whatsoever, see #1590
         testPathCalculation(0, 1, 40, IntArrayList.from(0, 2, 4, 6, 5, 3, 1));
         testPathCalculation(1, 0, 28, IntArrayList.from(1, 3, 5, 6, 4, 2, 0));
         testPathCalculation(4, 3, 23, IntArrayList.from(4, 6, 5, 3));
@@ -118,6 +116,79 @@ public void testFindPathWithTurnCosts_bidirected_no_shortcuts() {
         testPathCalculation(4, 4, 0, IntArrayList.from(4));
     }
 
+    @Test
+    public void testFindPathWithTurnCosts_loopShortcutBwdSearch() {
+        // the loop shortcut 4-4 will be encountered during the bwd search
+        //             3
+        //            / \
+        //           1   2
+        //            \ /
+        // 0 - 7 - 8 - 4 - 6 - 5
+        graph.edge(0, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(8, 4, 1, false);
+        graph.edge(4, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.edge(4, 6, 1, false);
+        graph.edge(6, 5, 1, false);
+        addRestriction(8, 4, 6);
+        addRestriction(8, 4, 2);
+        addRestriction(1, 4, 6);
+
+        graph.freeze();
+
+        // from contracting node 1
+        addShortcut(4, 3, 3, 4, 3, 4, 2);
+        // from contracting node 2
+        addShortcut(3, 4, 5, 6, 5, 6, 2);
+        // from contracting node 3
+        addShortcut(4, 4, 3, 6, 9, 10, 4);
+        // from contracting node 4
+        addShortcut(8, 4, 2, 6, 2, 11, 5);
+        addShortcut(8, 6, 2, 7, 12, 7, 6);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(0, 5, 9, IntArrayList.from(0, 7, 8, 4, 1, 3, 2, 4, 6, 5));
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_loopShortcutFwdSearch() {
+        // the loop shortcut 4-4 will be encountered during the fwd search
+        //         3
+        //        / \
+        //       1   2
+        //        \ /
+        // 5 - 6 - 4 - 7 - 8 - 0
+        graph.edge(5, 6, 1, false);
+        graph.edge(6, 4, 1, false);
+        graph.edge(4, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.edge(4, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(8, 0, 1, false);
+        addRestriction(6, 4, 7);
+        addRestriction(6, 4, 2);
+        addRestriction(1, 4, 7);
+        graph.freeze();
+
+        // from contracting node 1
+        addShortcut(4, 3, 2, 3, 2, 3, 2);
+        // from contracting node 2
+        addShortcut(3, 4, 4, 5, 4, 5, 2);
+        // from contracting node 3
+        addShortcut(4, 4, 2, 5, 9, 10, 4);
+        // from contracting node 4
+        addShortcut(6, 4, 1, 5, 1, 11, 5);
+        addShortcut(6, 7, 1, 6, 12, 6, 6);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(5, 0, 9, IntArrayList.from(5, 6, 4, 1, 3, 2, 4, 7, 8, 0));
+    }
+
     @Test
     public void testFindPathWithTurnCosts_directed_single_shortcut() {
         //    2     3
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index a25551e616..dab93e4429 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -87,20 +87,28 @@ public void testWayList() {
         // 0-1-2
         assertPList(Helper.createPointList(0, 0.1, 8, 1, 9, 1, 1, 0.1, 10, 1, 11, 1, 2, 0.1), path.calcPoints());
         InstructionList instr = path.calcInstructions(carManagerRoundabout, tr);
-        List<Map<String, Object>> res = instr.createJson();
-        Map<String, Object> tmp = res.get(0);
-        assertEquals(3000.0, tmp.get("distance"));
-        assertEquals(504000L, tmp.get("time"));
-        assertEquals("Continue", tmp.get("text"));
-        assertEquals("[0, 6]", tmp.get("interval").toString());
-
-        tmp = res.get(1);
-        assertEquals(0.0, tmp.get("distance"));
-        assertEquals(0L, tmp.get("time"));
-        assertEquals("Arrive at destination", tmp.get("text"));
-        assertEquals("[6, 6]", tmp.get("interval").toString());
-        int lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
-        assertEquals(path.calcPoints().size() - 1, lastIndex);
+        Instruction tmp = instr.get(0);
+        assertEquals(3000.0, tmp.getDistance(), 0.0);
+        assertEquals(504000L, tmp.getTime());
+        assertEquals("continue", tmp.getTurnDescription(tr));
+//        assertEquals("[0, 6]", tmp.get("interval").toString());
+        assertEquals(6, tmp.getLength());
+//        System.out.println(tmp.getPoints());
+
+
+        tmp = instr.get(1);
+        assertEquals(0.0, tmp.getDistance(), 0.0);
+        assertEquals(0L, tmp.getTime());
+        assertEquals("arrive at destination", tmp.getTurnDescription(tr));
+//        assertEquals("[6, 6]", tmp.get("interval").toString());
+        assertEquals(0, tmp.getLength());
+//        System.out.println(tmp.getPoints());
+
+        int acc = 0;
+        for (Instruction instruction : instr) {
+            acc += instruction.getLength();
+        }
+        assertEquals(path.calcPoints().size() - 1, acc);
 
         // force minor change for instructions
         edge2.setName("2");
@@ -114,21 +122,23 @@ public void testWayList() {
         path.setSPTEntry(e1);
         path.extract();
         instr = path.calcInstructions(carManagerRoundabout, tr);
-        res = instr.createJson();
-
-        tmp = res.get(0);
-        assertEquals(1000.0, tmp.get("distance"));
-        assertEquals(360000L, tmp.get("time"));
-        assertEquals("Continue", tmp.get("text"));
-        assertEquals("[0, 3]", tmp.get("interval").toString());
-
-        tmp = res.get(1);
-        assertEquals(2000.0, tmp.get("distance"));
-        assertEquals(144000L, tmp.get("time"));
-        assertEquals("Turn sharp right onto 2", tmp.get("text"));
-        assertEquals("[3, 6]", tmp.get("interval").toString());
-        lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
-        assertEquals(path.calcPoints().size() - 1, lastIndex);
+
+        tmp = instr.get(0);
+        assertEquals(1000.0, tmp.getDistance(), 0);
+        assertEquals(360000L, tmp.getTime());
+        assertEquals("continue", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+
+        tmp = instr.get(1);
+        assertEquals(2000.0, tmp.getDistance(), 0);
+        assertEquals(144000L, tmp.getTime());
+        assertEquals("turn sharp right onto 2", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+        acc = 0;
+        for (Instruction instruction : instr) {
+            acc += instruction.getLength();
+        }
+        assertEquals(path.calcPoints().size() - 1, acc);
 
         // now reverse order
         path = new Path(g, new FastestWeighting(encoder));
@@ -141,20 +151,22 @@ public void testWayList() {
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
 
         instr = path.calcInstructions(carManagerRoundabout, tr);
-        res = instr.createJson();
-        tmp = res.get(0);
-        assertEquals(2000.0, tmp.get("distance"));
-        assertEquals(144000L, tmp.get("time"));
-        assertEquals("Continue onto 2", tmp.get("text"));
-        assertEquals("[0, 3]", tmp.get("interval").toString());
-
-        tmp = res.get(1);
-        assertEquals(1000.0, tmp.get("distance"));
-        assertEquals(360000L, tmp.get("time"));
-        assertEquals("Turn sharp left", tmp.get("text"));
-        assertEquals("[3, 6]", tmp.get("interval").toString());
-        lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
-        assertEquals(path.calcPoints().size() - 1, lastIndex);
+        tmp = instr.get(0);
+        assertEquals(2000.0, tmp.getDistance(), 0);
+        assertEquals(144000L, tmp.getTime());
+        assertEquals("continue onto 2", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+
+        tmp = instr.get(1);
+        assertEquals(1000.0, tmp.getDistance(), 0);
+        assertEquals(360000L, tmp.getTime());
+        assertEquals("turn sharp left", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+        acc = 0;
+        for (Instruction instruction : instr) {
+            acc += instruction.getLength();
+        }
+        assertEquals(path.calcPoints().size() - 1, acc);
     }
 
     @Test
@@ -228,10 +240,10 @@ public void testCalcInstructionsRoundabout() {
             assertEquals("[1, 2, 3, 4, 5, 8]", p.calcNodes().toString());
             InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
             // Test instructions
-            List<String> tmpList = pick("text", wayList.createJson());
-            assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+            List<String> tmpList = getTurnDescriptions(wayList);
+            assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                     "At roundabout, take exit 3 onto 5-8",
-                    "Arrive at destination"),
+                    "arrive at destination"),
                     tmpList);
             // Test Radian
             double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
@@ -242,10 +254,10 @@ public void testCalcInstructionsRoundabout() {
             p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).
                     calcPath(1, 7);
             wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-            tmpList = pick("text", wayList.createJson());
-            assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+            tmpList = getTurnDescriptions(wayList);
+            assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                     "At roundabout, take exit 2 onto MainStreet 4 7",
-                    "Arrive at destination"),
+                    "arrive at destination"),
                     tmpList);
             // Test Radian
             delta = roundaboutGraph.getAngle(1, 2, 4, 7);
@@ -263,9 +275,9 @@ public void testCalcInstructionsRoundaboutBegin() {
                 .calcPath(2, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
+        List<String> tmpList = getTurnDescriptions(wayList);
         assertEquals(Arrays.asList("At roundabout, take exit 3 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
     }
 
@@ -279,10 +291,10 @@ public void testCalcInstructionsRoundaboutDirectExit() {
                 .calcPath(6, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 3-6",
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 3-6",
                 "At roundabout, take exit 3 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
         roundaboutGraph.inverse3to9();
     }
@@ -403,10 +415,10 @@ public void testCalcInstructionsRoundabout2() {
                 .calcPath(1, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                 "At roundabout, take exit 2 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
@@ -481,9 +493,9 @@ public void testCalcInstructionsRoundaboutIssue353() {
                 .calcPath(6, 11);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
+        List<String> tmpList = getTurnDescriptions(wayList);
         assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet 1 11",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
     }
 
@@ -497,10 +509,10 @@ public void testCalcInstructionsRoundaboutClockwise() {
                 .calcPath(1, 8);
         assertTrue(p.isFound());
         InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                 "At roundabout, take exit 1 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
@@ -868,11 +880,10 @@ public void testIgnoreInstructionsForSlightTurnWithOtherTurn() {
         assertEquals(2, wayList.size());
     }
 
-    List<String> pick(String key, List<Map<String, Object>> instructionJson) {
+    List<String> getTurnDescriptions(InstructionList instructionJson) {
         List<String> list = new ArrayList<>();
-
-        for (Map<String, Object> json : instructionJson) {
-            list.add(json.get(key).toString());
+        for (Instruction instruction : instructionJson) {
+            list.add(instruction.getTurnDescription(tr));
         }
         return list;
     }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index e31511b31b..076a51ec56 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -193,8 +193,8 @@ public void testMultipleVirtualNodes() {
         assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
         PointList pl = getPoints(queryGraph, 3, 1);
         assertEquals(2, pl.getSize());
-        assertEquals(new GHPoint(1.5, 1.5), pl.toGHPoint(0));
-        assertEquals(new GHPoint(1, 2.5), pl.toGHPoint(1));
+        assertEquals(new GHPoint(1.5, 1.5), pl.get(0));
+        assertEquals(new GHPoint(1, 2.5), pl.get(1));
 
         EdgeIteratorState edge = GHUtility.getEdge(queryGraph, 3, 1);
         assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 3));
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
index c4cda875c0..9b0c1f9d9c 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
@@ -607,6 +607,29 @@ public void testFindPath_bug2() {
         compareCHWithDijkstra(1000, contractionOrder);
     }
 
+    @Test
+    public void testFindPath_loop() {
+        //             3
+        //            / \
+        //           1   2
+        //            \ /
+        // 0 - 7 - 8 - 4 - 6 - 5
+        graph.edge(0, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(8, 4, 1, false);
+        graph.edge(4, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.edge(4, 6, 1, false);
+        graph.edge(6, 5, 1, false);
+        addRestriction(8, 4, 6);
+        graph.freeze();
+
+        RoutingAlgorithmFactory factory = prepareCH(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8));
+        compareCHQueryWithDijkstra(factory, 0, 5);
+    }
+
     @Test
     public void testFindPath_loopsMustAlwaysBeAccepted() {
         //     ---
diff --git a/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java b/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java
new file mode 100644
index 0000000000..cf7700f1fa
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java
@@ -0,0 +1,189 @@
+package com.graphhopper.storage;
+
+import com.carrotsearch.hppc.DoubleArrayList;
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.MotorcycleFlagEncoder;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class ShortcutUnpackerTest {
+
+    private FlagEncoder encoder;
+    private Weighting weighting;
+    private GraphHopperStorage graph;
+    private CHGraph chGraph;
+
+    @Before
+    public void init() {
+        // use motorcycle to be able to set different fwd/bwd speeds
+        encoder = new MotorcycleFlagEncoder(5, 5, 10);
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        weighting = new FastestWeighting(encoder);
+        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+        chGraph = graph.getGraph(CHGraph.class, weighting);
+    }
+
+    @Test
+    public void testUnpacking() {
+        // 0-1-2-3-4-5-6
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(4, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(5, 6, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+        chGraph.shortcut(0, 2, PrepareEncoder.getScFwdDir(), 2, 2, 0, 1);
+        chGraph.shortcut(2, 4, PrepareEncoder.getScFwdDir(), 2, 2, 2, 3);
+        chGraph.shortcut(4, 6, PrepareEncoder.getScFwdDir(), 2, 2, 4, 5);
+        chGraph.shortcut(2, 6, PrepareEncoder.getScFwdDir(), 2, 2, 7, 8);
+        chGraph.shortcut(0, 6, PrepareEncoder.getScFwdDir(), 2, 2, 6, 9);
+
+        {
+            // unpack the shortcut 0-6, traverse original edges in 'forward' order (from node 0 to 6)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor).visitOriginalEdges(10, 6, false);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 5, 6), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+        }
+
+        {
+            // unpack the shortcut 0-6, traverse original edges in 'backward' order (from node 6 to 0)
+            // note that traversing in backward order does not mean the original edges are read in reverse (e.g. fwd speed still applies)
+            // -> only the order of the original edges is reversed
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor).visitOriginalEdges(10, 6, true);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(6, 5, 4, 3, 2, 1), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+        }
+
+        {
+            // unpack the shortcut 6-0, traverse original edges in 'forward' order (from node 6 to 0)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor).visitOriginalEdges(10, 0, false);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.12, 0.12, 0.12, 0.12, 0.12, 0.12), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(120, 120, 120, 120, 120, 120), visitor.times);
+        }
+
+        {
+            // unpack the shortcut 6-0, traverse original edges in 'backward' order (from node 0 to 6)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor).visitOriginalEdges(10, 0, true);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.12, 0.12, 0.12, 0.12, 0.12, 0.12), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(120, 120, 120, 120, 120, 120), visitor.times);
+        }
+    }
+
+    @Test
+    public void loopShortcut() {
+        //     3
+        //    / \
+        //   2   4
+        //    \ /
+        // 0 - 1 - 5
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(4, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(1, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+        shortcut(1, 3, 2, 2, 1, 2, 1, 2);
+        shortcut(3, 1, 2, 2, 3, 4, 3, 4);
+        shortcut(1, 1, 4, 4, 6, 7, 1, 4);
+        shortcut(0, 1, 5, 5, 0, 8, 0, 4);
+        shortcut(0, 5, 6, 6, 9, 5, 0, 5);
+
+        {
+            // unpack the shortcut 0->5, traverse original edges in 'forward' order (from node 0 to 5)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor).visitOriginalEdges(10, 5, false);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 1, 5), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+        }
+
+        {
+            // unpack the shortcut 0->5, traverse original edges in 'backward' order (from node 5 to 0)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor).visitOriginalEdges(10, 5, true);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(5, 1, 4, 3, 2, 1), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+        }
+
+        {
+            // unpack the shortcut 5<-0, traverse original edges in 'forward' order (from node 5 to 0)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor).visitOriginalEdges(10, 0, false);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(1, 4, 3, 2, 1, 0), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.12, 0.12, 0.12, 0.12, 0.12, 0.12), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(120, 120, 120, 120, 120, 120), visitor.times);
+        }
+
+        {
+            // unpack the shortcut 5<-0, traverse original edges in 'backward' order (from node 0 to 5)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor).visitOriginalEdges(10, 0, true);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 1), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.12, 0.12, 0.12, 0.12, 0.12, 0.12), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(120, 120, 120, 120, 120, 120), visitor.times);
+        }
+    }
+
+    private void shortcut(int baseNode, int adjNode, double weight, double distance, int skip1, int skip2, int origFirst, int origLast) {
+        chGraph.shortcutEdgeBased(baseNode, adjNode, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2, origFirst, origLast);
+    }
+
+    private class TestVisitor implements ShortcutUnpacker.Visitor {
+        private final IntArrayList edgeIds = new IntArrayList();
+        private final IntArrayList adjNodes = new IntArrayList();
+        private final DoubleArrayList weights = new DoubleArrayList();
+        private final DoubleArrayList distances = new DoubleArrayList();
+        private final DoubleArrayList times = new DoubleArrayList();
+
+        @Override
+        public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+            edgeIds.add(edge.getEdge());
+            adjNodes.add(reverse ? edge.getBaseNode() : edge.getAdjNode());
+            weights.add(weighting.calcWeight(edge, reverse, prevOrNextEdgeId));
+            distances.add(edge.getDistance());
+            times.add(weighting.calcMillis(edge, reverse, prevOrNextEdgeId));
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index bc35fe84d8..729c4e255f 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -26,6 +26,7 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
@@ -34,8 +35,7 @@
 import java.util.Collections;
 import java.util.List;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
@@ -104,6 +104,22 @@ public void testSnappedPointAndGeometry() {
         assertEquals(new GHPoint(-0.441624, 0.317259), res.getSnappedPoint());
     }
 
+    @Test
+    public void testQuery() {
+        Graph graph = createTestGraph2();
+        LocationIndexTree index = createIndex(graph, 500);
+        final ArrayList set = new ArrayList();
+        index.query(new BBox(11.57314, 11.57614, 49.94553, 49.94853), new LocationIndex.Visitor() {
+            @Override
+            public void onNode(int nodeId) {
+                set.add(nodeId);
+            }
+        });
+        assertEquals(17, set.size());
+        assertTrue(set.containsAll(Arrays.asList(2, 3, 4, 5, 6)));
+        assertFalse(set.containsAll(Arrays.asList(17, 18, 25, 30)));
+    }
+
     @Test
     public void testInMemIndex() {
         Graph graph = createTestGraph(encodingManager);
@@ -196,11 +212,12 @@ public void testInMemIndex3() {
         LocationIndexTree index = createIndexNoPrepare(createTestGraph(encodingManager), 10000);
         index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
-        assertEquals(IntArrayList.from(new int[]{64, 4}), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{16, 4, 4}), index.getEntries());
 
-        assertEquals(33, inMemIndex.getEntriesOf(0).size());
-        assertEquals(69, inMemIndex.getEntriesOf(1).size());
-        assertEquals(0, inMemIndex.getEntriesOf(2).size());
+        assertEquals(13, inMemIndex.getEntriesOf(0).size());
+        assertEquals(33, inMemIndex.getEntriesOf(1).size());
+        assertEquals(69, inMemIndex.getEntriesOf(2).size());
+        assertEquals(0, inMemIndex.getEntriesOf(3).size());
 
         index.dataAccess.create(1024);
         inMemIndex.store(inMemIndex.root, LocationIndexTree.START_POINTER);
@@ -213,7 +230,7 @@ public void testInMemIndex3() {
     @Test
     public void testReverseSpatialKey() {
         LocationIndexTree index = createIndex(createTestGraph(encodingManager), 200);
-        assertEquals(IntArrayList.from(new int[]{64, 64, 64, 4}), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{16, 16, 16, 16, 4, 4}), index.getEntries());
 
         // 10111110111110101010
         String str44 = "00000000000000000000000000000000000000000000";
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 10dfee10f8..a6ab1e20aa 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.util;
 
 import com.carrotsearch.hppc.IntArrayList;
-import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
@@ -29,22 +28,13 @@
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.IntsRef;
 import com.graphhopper.storage.NodeAccess;
 import org.junit.Before;
 import org.junit.Test;
-import org.xml.sax.SAXException;
-
-import javax.xml.XMLConstants;
-import javax.xml.transform.Source;
-import javax.xml.transform.stream.StreamSource;
-import javax.xml.validation.Schema;
-import javax.xml.validation.SchemaFactory;
-import javax.xml.validation.Validator;
-import java.io.StringReader;
+
 import java.util.*;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
@@ -64,7 +54,18 @@ public void setUp() {
         roundaboutEnc = carManager.getBooleanEncodedValue(EncodingManager.ROUNDABOUT);
     }
 
-    @SuppressWarnings("unchecked")
+    private List<String> getTurnDescriptions(InstructionList instructionList) {
+        return getTurnDescriptions(instructionList, usTR);
+    }
+
+    private List<String> getTurnDescriptions(InstructionList instructionList, Translation tr) {
+        List<String> list = new ArrayList<>();
+        for (Instruction instruction : instructionList) {
+            list.add(instruction.getTurnDescription(tr));
+        }
+        return list;
+    }
+
     @Test
     public void testWayList() {
         Graph g = new GraphBuilder(carManager).create();
@@ -112,95 +113,49 @@ public void testWayList() {
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 10);
-        InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Turn left onto 7-8", "Arrive at destination"),
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(0, 10);
+        InstructionList wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 0-1", "turn right onto 1-4", "turn left onto 7-8", "arrive at destination"),
                 tmpList);
 
         wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.GERMAN));
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Dem Straßenverlauf von 0-1 folgen", "Rechts abbiegen auf 1-4", "Links abbiegen auf 7-8", "Ziel erreicht"),
+        tmpList = getTurnDescriptions(wayList, trMap.getWithFallBack(Locale.GERMAN));
+        assertEquals(Arrays.asList("dem Straßenverlauf von 0-1 folgen", "rechts abbiegen auf 1-4", "links abbiegen auf 7-8", "Ziel erreicht"),
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
 
-        List<GPXEntry> gpxes = wayList.createGPXList();
-        assertEquals(10, gpxes.size());
-        // check order of tower nodes        
-        assertEquals(1, gpxes.get(0).getLon(), 1e-6);
-        assertEquals(1.4, gpxes.get(gpxes.size() - 1).getLon(), 1e-6);
+        PointList points = p.calcPoints();
+        assertEquals(10, points.size());
+        // check order of tower nodes
+        assertEquals(1, points.getLon(0), 1e-6);
+        assertEquals(1.4, points.getLon(points.size() - 1), 1e-6);
 
-        // check order of pillar nodes        
-        assertEquals(1.15, gpxes.get(4).getLon(), 1e-6);
-        assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
-        assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
+        // check order of pillar nodes
+        assertEquals(1.15, points.getLon(4), 1e-6);
+        assertEquals(1.16, points.getLon(5), 1e-6);
 
         compare(Arrays.asList(asL(1.2d, 1.0d), asL(1.2d, 1.1), asL(1.0, 1.1), asL(1.1, 1.4)),
-                wayList.createStartPoints());
+                createStartPoints(wayList));
 
-        p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(6, 2);
+        p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
-        assertEquals(IntArrayList.from(new int[]{6, 7, 8, 5, 2}), p.calcNodes());
+        assertEquals(IntArrayList.from(6, 7, 8, 5, 2), p.calcNodes());
 
-        wayList = p.calcInstructions(roundaboutEnc, usTR);
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 6-7", "Turn left onto 5-8", "Arrive at destination"),
+        wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
+        tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 6-7", "turn left onto 5-8", "arrive at destination"),
                 tmpList);
 
         compare(Arrays.asList(asL(1d, 1d), asL(1d, 1.2), asL(1.2, 1.2)),
-                wayList.createStartPoints());
+                createStartPoints(wayList));
 
         // special case of identical start and end
-        p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 0);
-        wayList = p.calcInstructions(roundaboutEnc, usTR);
+        p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(0, 0);
+        wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
         assertEquals(1, wayList.size());
-        assertEquals("arrive at destination", wayList.get(0).getTurnDescription(usTR));
-    }
-
-    List<String> pick(String key, List<Map<String, Object>> instructionJson) {
-        List<String> list = new ArrayList<>();
-
-        for (Map<String, Object> json : instructionJson) {
-            list.add(json.get(key).toString());
-        }
-        return list;
-    }
-
-    List<List<Double>> createList(PointList pl, List<Integer> integs) {
-        List<List<Double>> list = new ArrayList<>();
-        for (int i : integs) {
-            List<Double> entryList = new ArrayList<>(2);
-            entryList.add(pl.getLatitude(i));
-            entryList.add(pl.getLongitude(i));
-            list.add(entryList);
-        }
-        return list;
-    }
-
-    void compare(List<List<Double>> expected, List<List<Double>> actual) {
-        for (int i = 0; i < expected.size(); i++) {
-            List<Double> e = expected.get(i);
-            List<Double> wasE = actual.get(i);
-            for (int j = 0; j < e.size(); j++) {
-                assertEquals("at index " + i + " value index " + j + " and value " + e + " vs " + wasE + "\n" + "Expected: " + expected + "\n" + "Actual: " + actual
-                        , e.get(j),
-                        wasE.get(j),
-                        1e-5d);
-            }
-        }
-    }
-
-    List<Double> asL(Double... list) {
-        return Arrays.asList(list);
-    }
-
-    double sumDistances(InstructionList il) {
-        double val = 0;
-        for (Instruction i : il) {
-            val += i.getDistance();
-        }
-        return val;
+        assertEquals("arrive at destination", wayList.get(0).getTurnDescription(trMap.getWithFallBack(Locale.US)));
     }
 
     @Test
@@ -229,14 +184,14 @@ public void testWayList2() {
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
 
         InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Arrive at destination"),
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 2-4", "turn slight right onto 3-4", "arrive at destination"),
                 tmpList);
 
         p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(roundaboutEnc, usTR);
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 3-4", "Keep right onto 4-5", "Arrive at destination"),
+        tmpList = getTurnDescriptions( wayList);
+        assertEquals(Arrays.asList("continue onto 3-4", "keep right onto 4-5", "arrive at destination"),
                 tmpList);
     }
 
@@ -267,176 +222,8 @@ public void testNoInstructionIfSameStreet() {
 
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
         InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto street", "Turn right onto street", "Arrive at destination"), tmpList);
-    }
-
-    @Test
-    public void testInstructionsWithTimeAndPlace() {
-        Graph g = new GraphBuilder(carManager).create();
-        //   n-4-5   (n: pillar node)
-        //   |
-        // 7-3-2-6
-        //     |
-        //     1
-        NodeAccess na = g.getNodeAccess();
-        na.setNode(1, 15.0, 10);
-        na.setNode(2, 15.1, 10);
-        na.setNode(3, 15.1, 9.9);
-        na.setNode(4, 15.2, 9.9);
-        na.setNode(5, 15.2, 10);
-        na.setNode(6, 15.1, 10.1);
-        na.setNode(7, 15.1, 9.8);
-
-        g.edge(1, 2, 7000, true).setName("1-2").setFlags(flagsForSpeed(carManager, 70));
-        g.edge(2, 3, 8000, true).setName("2-3").setFlags(flagsForSpeed(carManager, 80));
-        g.edge(2, 6, 10000, true).setName("2-6").setFlags(flagsForSpeed(carManager, 10));
-        g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
-        g.edge(3, 7, 10000, true).setName("3-7").setFlags(flagsForSpeed(carManager, 10));
-        g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
-
-        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
-        InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
-        assertEquals(4, wayList.size());
-
-        List<GPXEntry> gpxList = wayList.createGPXList();
-        assertEquals(34000, p.getDistance(), 1e-1);
-        assertEquals(34000, sumDistances(wayList), 1e-1);
-        assertEquals(5, gpxList.size());
-        assertEquals(1604120, p.getTime());
-        assertEquals(1604120, gpxList.get(gpxList.size() - 1).getTime());
-
-        assertEquals(Instruction.CONTINUE_ON_STREET, wayList.get(0).getSign());
-        assertEquals(15, wayList.get(0).getFirstLat(), 1e-3);
-        assertEquals(10, wayList.get(0).getFirstLon(), 1e-3);
-
-        assertEquals(Instruction.TURN_LEFT, wayList.get(1).getSign());
-        assertEquals(15.1, wayList.get(1).getFirstLat(), 1e-3);
-        assertEquals(10, wayList.get(1).getFirstLon(), 1e-3);
-
-        assertEquals(Instruction.TURN_RIGHT, wayList.get(2).getSign());
-        assertEquals(15.1, wayList.get(2).getFirstLat(), 1e-3);
-        assertEquals(9.9, wayList.get(2).getFirstLon(), 1e-3);
-
-        String gpxStr = wayList.createGPX("test", 0, Constants.VERSION);
-        verifyGPX(gpxStr);
-
-        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T00:00:00Z</time>"));
-        assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
-        assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
-        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
-        assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
-        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
-
-        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
-        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
-
-        assertFalse(gpxStr, gpxStr.contains("NaN"));
-    }
-
-    @Test
-    public void testCreateGPXIncludesRoundaboutExitNumber() {
-        InstructionList instructions = new InstructionList(usTR);
-
-        PointList pl = new PointList();
-        pl.add(52.555423473315, 13.43890086052345);
-        pl.add(52.555550691982, 13.43946393816465);
-        pl.add(52.555619423589, 13.43886994061328);
-        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
-                InstructionAnnotation.EMPTY, pl)
-                .setRadian(2.058006514284998d)
-                .setExitNumber(3)
-                .setExited();
-        instructions.add(instr);
-        instructions.add(new FinishInstruction(52.555619423589, 13.43886994061328, 0));
-
-        String gpxStr = instructions.createGPX("test", 0, true, true, false, false, Constants.VERSION);
-
-        assertTrue(gpxStr, gpxStr.contains("<gh:exit_number>3</gh:exit_number>"));
-        verifyGPX(gpxStr);
-    }
-
-    @Test
-    public void testCreateGPXCorrectFormattingSmallNumbers() {
-        InstructionList instructions = new InstructionList(usTR);
-
-        PointList pl = new PointList();
-        pl.add(0.000001, 0.000001);
-        pl.add(-0.000123, -0.000125);
-        Instruction instruction = new Instruction(0, "do it", null, pl);
-        instructions.add(instruction);
-        instructions.add(new FinishInstruction(0.000852, 0.000852, 0));
-
-        String gpxStr = instructions.createGPX("test", 0, true, true, true, true, Constants.VERSION);
-
-        assertFalse(gpxStr, gpxStr.contains("E-"));
-        assertTrue(gpxStr, gpxStr.contains("0.000001"));
-        assertTrue(gpxStr, gpxStr.contains("-0.000125"));
-        verifyGPX(gpxStr);
-    }
-
-    @Test
-    public void testCreateGPXWithEle() {
-        final List<GPXEntry> fakeList = new ArrayList<>();
-        fakeList.add(new GPXEntry(12, 13, 0));
-        fakeList.add(new GPXEntry(12.5, 13, 1000));
-        InstructionList il = new InstructionList(usTR) {
-            @Override
-            public List<GPXEntry> createGPXList() {
-                return fakeList;
-            }
-        };
-        String gpxStr = il.createGPX("test", 0, Constants.VERSION);
-        verifyGPX(gpxStr);
-        assertFalse(gpxStr, gpxStr.contains("NaN"));
-        assertFalse(gpxStr, gpxStr.contains("<ele>"));
-
-        fakeList.clear();
-        fakeList.add(new GPXEntry(12, 13, 11, 0));
-        fakeList.add(new GPXEntry(12.5, 13, 10, 1000));
-        gpxStr = il.createGPX("test", 0, true, true, true, true, Constants.VERSION);
-
-        assertTrue(gpxStr, gpxStr.contains("<ele>11.0</ele>"));
-        assertFalse(gpxStr, gpxStr.contains("NaN"));
-    }
-
-    @Test
-    public void testCreateGPX() {
-        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
-        InstructionList instructions = new InstructionList(usTR);
-        PointList pl = new PointList();
-        pl.add(49.942576, 11.580384);
-        pl.add(49.941858, 11.582422);
-        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
-
-        pl = new PointList();
-        pl.add(49.941575, 11.583501);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
-
-        pl = new PointList();
-        pl.add(49.941389, 11.584311);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
-        instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
-
-        List<GPXEntry> result = instructions.createGPXList();
-        assertEquals(5, result.size());
-
-        assertEquals(0, result.get(0).getTime());
-        assertEquals(10391, result.get(1).getTime());
-        assertEquals(15000, result.get(2).getTime());
-        assertEquals(19000, result.get(3).getTime());
-        assertEquals(22000, result.get(4).getTime());
-
-        verifyGPX(instructions.createGPX(Constants.VERSION));
-    }
-
-    private IntsRef flagsForSpeed(EncodingManager encodingManager, int speedKmPerHour) {
-        ReaderWay way = new ReaderWay(1);
-        way.setTag("highway", "motorway");
-        way.setTag("maxspeed", String.format("%d km/h", speedKmPerHour));
-        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
-        encodingManager.acceptWay(way, map);
-        return encodingManager.handleWayTags(way, map, 0);
+        List<String> tmpList = getTurnDescriptions( wayList);
+        assertEquals(Arrays.asList("continue onto street", "turn right onto street", "arrive at destination"), tmpList);
     }
 
     @Test
@@ -445,26 +232,6 @@ public void testEmptyList() {
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(roundaboutEnc, usTR);
         assertEquals(0, il.size());
-        assertEquals(0, il.createStartPoints().size());
-    }
-
-    public void verifyGPX(String gpx) {
-        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
-        Schema schema = null;
-        try {
-            Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
-            schema = schemaFactory.newSchema(schemaFile);
-
-            // using more schemas: http://stackoverflow.com/q/1094893/194609
-        } catch (SAXException e1) {
-            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
-        }
-        Validator validator = schema.newValidator();
-        try {
-            validator.validate(new StreamSource(new StringReader(gpx)));
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
     }
 
     @Test
@@ -506,10 +273,46 @@ public void testFind() {
         assertEquals("3-4", wayList.find(15.099, 9.9, 1000).getName());
     }
 
-    @Test
-    public void testXMLEscape_issue572() {
-        assertEquals("_", InstructionList.simpleXMLEscape("<"));
-        assertEquals("_blup_", InstructionList.simpleXMLEscape("<blup>"));
-        assertEquals("a&amp;b", InstructionList.simpleXMLEscape("a&b"));
+    private List<String> pick(String key, List<Map<String, Object>> instructionJson) {
+        List<String> list = new ArrayList<>();
+
+        for (Map<String, Object> json : instructionJson) {
+            list.add(json.get(key).toString());
+        }
+        return list;
     }
+
+    private void compare(List<List<Double>> expected, List<List<Double>> actual) {
+        for (int i = 0; i < expected.size(); i++) {
+            List<Double> e = expected.get(i);
+            List<Double> wasE = actual.get(i);
+            for (int j = 0; j < e.size(); j++) {
+                assertEquals("at index " + i + " value index " + j + " and value " + e + " vs " + wasE + "\n" + "Expected: " + expected + "\n" + "Actual: " + actual
+                        , e.get(j),
+                        wasE.get(j),
+                        1e-5d);
+            }
+        }
+    }
+
+    private List<Double> asL(Double... list) {
+        return Arrays.asList(list);
+    }
+
+    private static List<List<Double>> createStartPoints(List<Instruction> instructions) {
+        List<List<Double>> res = new ArrayList<>(instructions.size());
+        for (Instruction instruction : instructions) {
+            res.add(Arrays.asList(instruction.getPoints().getLatitude(0), instruction.getPoints().getLongitude(0)));
+        }
+        return res;
+    }
+
+    private double sumDistances(InstructionList il) {
+        double val = 0;
+        for (Instruction i : il) {
+            val += i.getDistance();
+        }
+        return val;
+    }
+
 }
diff --git a/reader-gtfs/pom.xml b/reader-gtfs/pom.xml
index bc9d5fdfd6..7341c2d144 100644
--- a/reader-gtfs/pom.xml
+++ b/reader-gtfs/pom.xml
@@ -21,6 +21,11 @@
             <artifactId>graphhopper-core</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-web-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>graphhopper-reader-osm</artifactId>
@@ -52,21 +57,19 @@
             <version>${slf4j.version}</version>
         </dependency>   
         <dependency>
-            <groupId>org.slf4j</groupId>
-            <artifactId>slf4j-log4j12</artifactId>
-            <version>${slf4j.version}</version>
-            <scope>test</scope>
+            <groupId>com.google.transit</groupId>
+            <artifactId>gtfs-realtime-bindings</artifactId>
+            <version>0.0.4</version>
         </dependency>
         <dependency>
-            <groupId>log4j</groupId>
-            <artifactId>log4j</artifactId>
-            <version>${log4j.version}</version>
-            <scope>test</scope>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-core</artifactId>
+            <version>${dropwizard.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.google.transit</groupId>
-            <artifactId>gtfs-realtime-bindings</artifactId>
-            <version>0.0.4</version>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-client</artifactId>
+            <version>${dropwizard.version}</version>
         </dependency>
 
         <dependency>
@@ -82,6 +85,12 @@
             <version>4.12</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-testing</artifactId>
+            <version>${dropwizard.version}</version>
+            <scope>test</scope>
+        </dependency>
         <dependency>
             <groupId>org.hamcrest</groupId>
             <artifactId>hamcrest-library</artifactId>
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/FeedConfiguration.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/FeedConfiguration.java
new file mode 100644
index 0000000000..4bab2c1be1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/FeedConfiguration.java
@@ -0,0 +1,63 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.google.transit.realtime.GtfsRealtime;
+
+import java.io.IOException;
+import java.net.URL;
+
+public class FeedConfiguration {
+
+    private URL url;
+    private String agencyId;
+    private String feedId;
+
+    @JsonProperty
+    public URL getUrl() {
+        return url;
+    }
+
+    @JsonProperty
+    public void setUrl(URL url) {
+        this.url = url;
+    }
+
+    @JsonProperty
+    public String getAgencyId() {
+        return agencyId;
+    }
+
+    @JsonProperty
+    public void setAgencyId(String agencyId) {
+        this.agencyId = agencyId;
+    }
+
+    @JsonProperty
+    public String getFeedId() {
+        return feedId;
+    }
+
+    @JsonProperty
+    public void setFeedId(String feedId) {
+        this.feedId = feedId;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundle.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundle.java
new file mode 100644
index 0000000000..a61fbd6c95
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundle.java
@@ -0,0 +1,52 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.graphhopper.reader.gtfs.RealtimeFeed;
+import io.dropwizard.ConfiguredBundle;
+import io.dropwizard.client.HttpClientBuilder;
+import io.dropwizard.setup.Bootstrap;
+import io.dropwizard.setup.Environment;
+import org.apache.http.client.HttpClient;
+import org.glassfish.hk2.utilities.binding.AbstractBinder;
+
+import javax.inject.Singleton;
+
+public class RealtimeBundle implements ConfiguredBundle<RealtimeBundleConfiguration> {
+
+    @Override
+    public void initialize(Bootstrap<?> bootstrap) {
+    }
+
+    @Override
+    public void run(RealtimeBundleConfiguration configuration, Environment environment) {
+        final HttpClient httpClient = new HttpClientBuilder(environment)
+                .using(configuration.gtfsrealtime().getHttpClientConfiguration())
+                .build("gtfs-realtime-feed-loader");
+        environment.jersey().register(new AbstractBinder() {
+            @Override
+            protected void configure() {
+                bind(httpClient).to(HttpClient.class);
+                bind(configuration).to(RealtimeBundleConfiguration.class);
+                bindFactory(RealtimeFeedLoadingCache.class, Singleton.class).to(RealtimeFeed.class);
+            }
+        });
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundleConfiguration.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundleConfiguration.java
new file mode 100644
index 0000000000..b772b43b9d
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundleConfiguration.java
@@ -0,0 +1,27 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import java.util.List;
+
+public interface RealtimeBundleConfiguration {
+
+    RealtimeConfiguration gtfsrealtime();
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeConfiguration.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeConfiguration.java
new file mode 100644
index 0000000000..cf22843005
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeConfiguration.java
@@ -0,0 +1,49 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.google.transit.realtime.GtfsRealtime;
+import io.dropwizard.client.HttpClientConfiguration;
+
+import javax.validation.Valid;
+import javax.validation.constraints.NotNull;
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+public class RealtimeConfiguration {
+
+    @Valid
+    @NotNull
+    @JsonProperty
+    private HttpClientConfiguration httpClient = new HttpClientConfiguration();
+
+    @JsonProperty
+    private List<FeedConfiguration> feeds = new ArrayList<>();
+
+    public List<FeedConfiguration> getFeeds() {
+        return feeds;
+    }
+
+    public HttpClientConfiguration getHttpClientConfiguration() {
+        return httpClient;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeFeedLoadingCache.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeFeedLoadingCache.java
new file mode 100644
index 0000000000..b1c0634243
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeFeedLoadingCache.java
@@ -0,0 +1,108 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import com.google.transit.realtime.GtfsRealtime;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.RealtimeFeed;
+import com.graphhopper.storage.GraphHopperStorage;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.glassfish.hk2.api.Factory;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+public class RealtimeFeedLoadingCache implements Factory<RealtimeFeed> {
+
+    private final HttpClient httpClient;
+    private final GraphHopperStorage graphHopperStorage;
+    private final GtfsStorage gtfsStorage;
+    private final PtFlagEncoder ptFlagEncoder;
+    private final RealtimeBundleConfiguration bundleConfiguration;
+    private final ExecutorService executor = Executors.newSingleThreadExecutor();
+    private final LoadingCache<String, RealtimeFeed> cache;
+
+    @Inject
+    RealtimeFeedLoadingCache(GraphHopperStorage graphHopperStorage, GtfsStorage gtfsStorage, PtFlagEncoder ptFlagEncoder, HttpClient httpClient, RealtimeBundleConfiguration bundleConfiguration) {
+        this.graphHopperStorage = graphHopperStorage;
+        this.gtfsStorage = gtfsStorage;
+        this.ptFlagEncoder = ptFlagEncoder;
+        this.bundleConfiguration = bundleConfiguration;
+        this.httpClient = httpClient;
+        this.cache = CacheBuilder.newBuilder()
+                .maximumSize(1)
+                .refreshAfterWrite(1, TimeUnit.MINUTES)
+                .build(new CacheLoader<String, RealtimeFeed>() {
+                    public RealtimeFeed load(String key) {
+                        return fetchFeedsAndCreateGraph();
+                    }
+
+                    @Override
+                    public ListenableFuture<RealtimeFeed> reload(String key, RealtimeFeed oldValue) {
+                        ListenableFutureTask<RealtimeFeed> task = ListenableFutureTask.create(() -> fetchFeedsAndCreateGraph());
+                        executor.execute(task);
+                        return task;
+                    }
+                });
+    }
+
+    @Override
+    public RealtimeFeed provide() {
+        try {
+            return cache.get("pups");
+        } catch (ExecutionException | RuntimeException e) {
+            e.printStackTrace();
+            return RealtimeFeed.empty(gtfsStorage);
+        }
+    }
+
+    @Override
+    public void dispose(RealtimeFeed instance) {
+
+    }
+
+    private RealtimeFeed fetchFeedsAndCreateGraph() {
+        Map<String, GtfsRealtime.FeedMessage> feedMessageMap = new HashMap<>();
+        for (FeedConfiguration configuration : bundleConfiguration.gtfsrealtime().getFeeds()) {
+            try {
+                GtfsRealtime.FeedMessage feedMessage = GtfsRealtime.FeedMessage.parseFrom(httpClient.execute(new HttpGet(configuration.getUrl().toURI())).getEntity().getContent());
+                feedMessageMap.put(configuration.getFeedId(), feedMessage);
+            } catch (IOException | URISyntaxException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return RealtimeFeed.fromProtobuf(graphHopperStorage, gtfsStorage, ptFlagEncoder, feedMessageMap);
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/ws/LocationConverterProvider.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/ws/LocationConverterProvider.java
new file mode 100644
index 0000000000..05de238812
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/ws/LocationConverterProvider.java
@@ -0,0 +1,57 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.ws;
+
+import com.graphhopper.MultiException;
+import com.graphhopper.reader.gtfs.GHLocation;
+
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ParamConverter;
+import javax.ws.rs.ext.ParamConverterProvider;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+public class LocationConverterProvider implements ParamConverterProvider {
+
+    @Override
+    public <T> ParamConverter<T> getConverter(Class<T> rawType, Type genericType, Annotation[] annotations) {
+        if (rawType.equals(GHLocation.class)) {
+            return new ParamConverter<T>() {
+                @Override
+                public T fromString(String value) {
+                    try {
+                        return (T) GHLocation.fromString(value);
+                    } catch (IllegalArgumentException ex) {
+                        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
+                                .entity(new MultiException(ex))
+                                .build());
+                    }
+                }
+
+                @Override
+                public String toString(T value) {
+                    return value.toString();
+                }
+            };
+        }
+        return null;
+    }
+}
+
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java
index 4226826eaf..fa317e8539 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java
@@ -21,6 +21,7 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.shapes.BBox;
 
 class EmptyLocationIndex implements LocationIndex {
     @Override
@@ -38,6 +39,10 @@ public QueryResult findClosest(double lat, double lon, EdgeFilter edgeFilter) {
         return new QueryResult(lat, lon);
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+    }
+
     @Override
     public LocationIndex setApproximation(boolean approxDist) {
         return this;
@@ -45,7 +50,6 @@ public LocationIndex setApproximation(boolean approxDist) {
 
     @Override
     public void setSegmentSize(int bytes) {
-
     }
 
     @Override
@@ -60,12 +64,10 @@ public LocationIndex create(long byteCount) {
 
     @Override
     public void flush() {
-
     }
 
     @Override
     public void close() {
-
     }
 
     @Override
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHLocation.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHLocation.java
new file mode 100644
index 0000000000..d2dc2c6719
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHLocation.java
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class GHLocation {
+
+    private static final Pattern PATTERN = Pattern.compile("^Stop\\((.*)\\)$");
+
+    public static GHLocation fromString(String s) {
+        final Matcher matcher = PATTERN.matcher(s);
+        if (matcher.find()) {
+            return new GHStationLocation(matcher.group(1));
+        } else {
+            return new GHPointLocation(GHPoint.fromString(s));
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHPointLocation.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHPointLocation.java
new file mode 100644
index 0000000000..ab64514de5
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHPointLocation.java
@@ -0,0 +1,34 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+public class GHPointLocation extends GHLocation {
+    public final GHPoint ghPoint;
+
+    public GHPointLocation(GHPoint ghPoint) {
+        this.ghPoint = ghPoint;
+    }
+
+    @Override
+    public String toString() {
+        return ghPoint.toString();
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHStationLocation.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHStationLocation.java
new file mode 100644
index 0000000000..29d47a06c1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHStationLocation.java
@@ -0,0 +1,27 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+public class GHStationLocation extends GHLocation {
+    public final String stop_id;
+
+    public GHStationLocation(String ghPoint) {
+        this.stop_id = ghPoint;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 2d6cdaa513..978b5770d4 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -18,13 +18,10 @@
 
 package com.graphhopper.reader.gtfs;
 
-import com.google.common.collect.ArrayListMultimap;
-import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -45,17 +42,12 @@
     private final GtfsStorage gtfsStorage;
     private final RealtimeFeed realtimeFeed;
     private final boolean reverse;
-    private final List<EdgeIteratorState> extraEdges = new ArrayList<>();
-    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
-    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
-    private final Graph graph;
     private final Weighting accessEgressWeighting;
     private final boolean walkOnly;
     private double walkSpeedKmH;
 
 
-    public GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, double walkSpeedKmh) {
-        this.graph = graph;
+    public GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, boolean walkOnly, double walkSpeedKmh) {
         this.accessEgressWeighting = accessEgressWeighting;
         DefaultEdgeFilter accessEgressIn = DefaultEdgeFilter.inEdges(accessEgressWeighting.getFlagEncoder());
         DefaultEdgeFilter accessEgressOut = DefaultEdgeFilter.outEdges(accessEgressWeighting.getFlagEncoder());
@@ -68,27 +60,15 @@ public GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
-        this.extraEdges.addAll(extraEdges);
-        for (VirtualEdgeIteratorState extraEdge : extraEdges) {
-            if (extraEdge == null) {
-                throw new RuntimeException();
-            }
-            extraEdgesBySource.put(extraEdge.getBaseNode(), extraEdge);
-            extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalEdgeKey(), extraEdge.getEdge(), extraEdge.getAdjNode(),
-                    extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3), false));
-        }
         this.walkOnly = walkOnly;
         this.walkSpeedKmH = walkSpeedKmh;
     }
 
     Stream<EdgeIteratorState> exploreEdgesAround(Label label) {
-        final List<VirtualEdgeIteratorState> extraEdges = reverse ? extraEdgesByDestination.get(label.adjNode) : extraEdgesBySource.get(label.adjNode);
-        return Stream.concat(
-                label.adjNode < graph.getNodes() ? mainEdgesAround(label) : Stream.empty(),
-                extraEdges.stream()).filter(new EdgeIteratorStatePredicate(label));
+        return allEdgesAround(label).filter(new EdgeIteratorStatePredicate(label));
     }
 
-    private Stream<EdgeIteratorState> mainEdgesAround(Label label) {
+    private Stream<EdgeIteratorState> allEdgesAround(Label label) {
         return StreamSupport.stream(new Spliterators.AbstractSpliterator<EdgeIteratorState>(0, 0) {
             EdgeIterator edgeIterator = edgeExplorer.setBaseNode(label.adjNode);
 
@@ -191,33 +171,6 @@ int calcNTransfers(EdgeIteratorState edge) {
         return edge.get(flagEncoder.getTransfersEnc());
     }
 
-    EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
-        if (edgeId == -1) {
-            throw new RuntimeException();
-        }
-        for (EdgeIteratorState extraEdge : extraEdges) {
-            if (extraEdge.getEdge() == edgeId) {
-                if (extraEdge.getAdjNode() != adjNode) {
-                    throw new IllegalStateException();
-                }
-                return extraEdge;
-            }
-        }
-        EdgeIteratorState edge = graph.getEdgeIteratorState(edgeId, adjNode);
-        if (edge.getAdjNode() != adjNode) {
-            throw new IllegalStateException();
-        }
-        return edge;
-    }
-
-    NodeAccess getNodeAccess() {
-        return graph.getNodeAccess();
-    }
-
-    public Graph getGraph() {
-        return graph;
-    }
-
     private class EdgeIteratorStatePredicate implements Predicate<EdgeIteratorState> {
         private final Label label;
         boolean foundEnteredTimeExpandedNetworkEdge;
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 9f497b0d8b..df65883599 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -20,8 +20,12 @@
 
 import com.conveyal.gtfs.GTFSFeed;
 import com.conveyal.gtfs.model.Transfer;
+import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.google.transit.realtime.GtfsRealtime;
-import com.graphhopper.*;
+import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.Trip;
+import com.graphhopper.http.WebHelper;
 import com.graphhopper.reader.osm.OSMReader;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
@@ -39,6 +43,9 @@
 import com.graphhopper.util.exceptions.PointNotFoundException;
 import com.graphhopper.util.shapes.GHPoint;
 
+import javax.inject.Inject;
+import javax.ws.rs.*;
+import javax.ws.rs.core.MediaType;
 import java.io.File;
 import java.io.IOException;
 import java.time.Instant;
@@ -48,9 +55,8 @@
 import java.util.stream.Stream;
 import java.util.zip.ZipFile;
 
-import static com.graphhopper.util.Parameters.PT.PROFILE_QUERY;
-
-public final class GraphHopperGtfs implements GraphHopperAPI {
+@Path("route")
+public final class GraphHopperGtfs {
 
     public static class Factory {
         private final TranslationMap translationMap;
@@ -67,7 +73,7 @@ private Factory(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphH
             this.gtfsStorage = gtfsStorage;
         }
 
-        public GraphHopperGtfs createWith(GtfsRealtime.FeedMessage realtimeFeed, String agencyId) {
+        public GraphHopperGtfs createWith(GtfsRealtime.FeedMessage realtimeFeed) {
             Map<String, GtfsRealtime.FeedMessage> realtimeFeeds = new HashMap<>();
             realtimeFeeds.put("gtfs_0", realtimeFeed);
             return new GraphHopperGtfs(flagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.fromProtobuf(graphHopperStorage, gtfsStorage, flagEncoder, realtimeFeeds));
@@ -103,8 +109,8 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final double walkSpeedKmH;
         private final double maxWalkDistancePerLeg;
         private final int blockedRouteTypes;
-        private final GHPoint enter;
-        private final GHPoint exit;
+        private final GHLocation enter;
+        private final GHLocation exit;
         private final Translation translation;
         private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>(realtimeFeed.getAdditionalEdges());
 
@@ -114,43 +120,58 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private GraphExplorer graphExplorer;
         private int visitedNodes;
 
-        RequestHandler(GHRequest request) {
-            maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, 1_000_000);
-            profileQuery = request.getHints().getBool(PROFILE_QUERY, false);
-            ignoreTransfers = request.getHints().getBool(Parameters.PT.IGNORE_TRANSFERS, profileQuery);
-            betaTransfers = request.getHints().getDouble("beta_transfers", 0.0);
-            betaWalkTime = request.getHints().getDouble("beta_walk_time", 1.0);
-            limitSolutions = request.getHints().getInt(Parameters.PT.LIMIT_SOLUTIONS, profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
-            final String departureTimeString = request.getHints().get(Parameters.PT.EARLIEST_DEPARTURE_TIME, "");
-            try {
-                initialTime = Instant.parse(departureTimeString);
-            } catch (DateTimeParseException e) {
-                throw new IllegalArgumentException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
-            }
-            arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
-            walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
-            blockedRouteTypes = request.getHints().getInt(Parameters.PT.BLOCKED_ROUTE_TYPES, 0);
+        RequestHandler(Request request) {
+            maxVisitedNodesForRequest = request.getMaxVisitedNodes();
+            profileQuery = request.isProfileQuery();
+            ignoreTransfers = Optional.ofNullable(request.getIgnoreTransfers()).orElse(request.isProfileQuery());
+            betaTransfers = request.getBetaTransfers();
+            betaWalkTime = request.getBetaWalkTime();
+            limitSolutions = Optional.ofNullable(request.getLimitSolutions()).orElse(profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
+            initialTime = request.getEarliestDepartureTime();
+            arriveBy = request.isArriveBy();
+            walkSpeedKmH = request.getWalkSpeedKmH();
+            blockedRouteTypes = request.getBlockedRouteTypes();
             translation = translationMap.getWithFallBack(request.getLocale());
             if (request.getPoints().size() != 2) {
                 throw new IllegalArgumentException("Exactly 2 points have to be specified, but was:" + request.getPoints().size());
             }
             enter = request.getPoints().get(0);
             exit = request.getPoints().get(1);
-            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, Integer.MAX_VALUE);
+            maxWalkDistancePerLeg = request.getMaxWalkDistancePerLeg();
         }
 
         GHResponse route() {
             StopWatch stopWatch = new StopWatch().start();
-
+            ArrayList<QueryResult> pointQueryResults = new ArrayList<>();
             ArrayList<QueryResult> allQueryResults = new ArrayList<>();
-
-            QueryResult source = findClosest(enter, 0);
-            QueryResult dest = findClosest(exit, 1);
-            allQueryResults.add(source);
-            allQueryResults.add(dest);
-            queryGraph.lookup(Arrays.asList(source, dest)); // modifies queryGraph, source and dest!
-
-            PointList startAndEndpoint = pointListFrom(Arrays.asList(source, dest));
+            PointList points = new PointList(2, false);
+            if (enter instanceof GHPointLocation) {
+                final QueryResult closest = findClosest(((GHPointLocation) enter).ghPoint, 0);
+                pointQueryResults.add(closest);
+                allQueryResults.add(closest);
+                points.add(closest.getSnappedPoint());
+            } else if (enter instanceof GHStationLocation) {
+                final String stop_id = ((GHStationLocation) enter).stop_id;
+                final int node = gtfsStorage.getStationNodes().get(stop_id);
+                final QueryResult station = new QueryResult(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+                station.setClosestNode(node);
+                allQueryResults.add(station);
+                points.add(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+            }
+            if (exit instanceof GHPointLocation) {
+                final QueryResult closest = findClosest(((GHPointLocation) exit).ghPoint, 1);
+                pointQueryResults.add(closest);
+                allQueryResults.add(closest);
+                points.add(closest.getSnappedPoint());
+            } else if (exit instanceof GHStationLocation) {
+                final String stop_id = ((GHStationLocation) exit).stop_id;
+                final int node = gtfsStorage.getStationNodes().get(stop_id);
+                final QueryResult station = new QueryResult(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+                station.setClosestNode(node);
+                allQueryResults.add(station);
+                points.add(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+            }
+            queryGraph.lookup(pointQueryResults); // modifies queryGraph and queryResults!
             response.addDebugInfo("idLookup:" + stopWatch.stop().getSeconds() + "s");
 
             int startNode;
@@ -163,7 +184,7 @@ GHResponse route() {
                 destNode = allQueryResults.get(1).getClosestNode();
             }
             List<List<Label.Transition>> solutions = findPaths(startNode, destNode);
-            parseSolutionsAndAddToResponse(solutions, startAndEndpoint);
+            parseSolutionsAndAddToResponse(solutions, points);
             return response;
         }
 
@@ -181,7 +202,7 @@ private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
 
         private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutions, PointList waypoints) {
             for (List<Label.Transition> solution : solutions) {
-                final List<Trip.Leg> legs = tripFromLabel.getTrip(translation, graphExplorer, accessEgressWeighting, solution);
+                final List<Trip.Leg> legs = tripFromLabel.getTrip(translation, queryGraph, accessEgressWeighting, solution);
                 final PathWrapper pathWrapper = tripFromLabel.createPathWrapper(translation, waypoints, legs);
                 pathWrapper.setImpossible(solution.stream().anyMatch(t -> t.label.impossible));
                 pathWrapper.setTime((solution.get(solution.size() - 1).label.currentTime - solution.get(0).label.currentTime));
@@ -194,7 +215,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
 
         private List<List<Label.Transition>> findPaths(int startNode, int destNode) {
             StopWatch stopWatch = new StopWatch().start();
-            final GraphExplorer accessEgressGraphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, !arriveBy, extraEdges, true, walkSpeedKmH);
+            final GraphExplorer accessEgressGraphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, !arriveBy, true, walkSpeedKmH);
             boolean reverse = !arriveBy;
             GtfsStorage.EdgeType edgeType = reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT;
             MultiCriteriaLabelSetting stationRouter = new MultiCriteriaLabelSetting(accessEgressGraphExplorer, flagEncoder, reverse, maxWalkDistancePerLeg, false, false, false, maxVisitedNodesForRequest, new ArrayList<>());
@@ -206,7 +227,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                 if (label.adjNode == startNode) {
                     stationLabels.add(label);
                     break;
-                } else if (label.edge != -1 && accessEgressGraphExplorer.getEdgeIteratorState(label.edge, label.parent.adjNode).get(flagEncoder.getTypeEnc()) == edgeType) {
+                } else if (label.edge != -1 && queryGraph.getEdgeIteratorState(label.edge, label.parent.adjNode).get(flagEncoder.getTypeEnc()) == edgeType) {
                     stationLabels.add(label);
                 }
             }
@@ -217,7 +238,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                 reverseSettledSet.put(stationLabel.adjNode, stationLabel);
             }
 
-            graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false, walkSpeedKmH);
+            graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, false, walkSpeedKmH);
             List<Label> discoveredSolutions = new ArrayList<>();
             final long smallestStationLabelWeight;
             MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, arriveBy, maxWalkDistancePerLeg, true, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest, discoveredSolutions);
@@ -258,12 +279,12 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
 
             List<List<Label.Transition>> pathsToStations = discoveredSolutions.stream()
                     .map(originalSolutions::get)
-                    .map(l -> new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(arriveBy, flagEncoder, graphExplorer, l)).collect(Collectors.toList());
+                    .map(l -> tripFromLabel.getTransitions(arriveBy, flagEncoder, queryGraph, l)).collect(Collectors.toList());
 
             List<List<Label.Transition>> paths = pathsToStations.stream().map(p -> {
                 if (arriveBy) {
                     List<Label.Transition> pp = new ArrayList<>(p.subList(1, p.size()));
-                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(0).label.adjNode));
+                    List<Label.Transition> pathFromStation = pathFromStation(reverseSettledSet.get(p.get(0).label.adjNode));
                     long diff = p.get(0).label.currentTime - pathFromStation.get(pathFromStation.size() - 1).label.currentTime;
                     List<Label.Transition> patchedPathFromStation = pathFromStation.stream().map(t -> {
                         return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
@@ -272,7 +293,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                     return pp;
                 } else {
                     List<Label.Transition> pp = new ArrayList<>(p);
-                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(p.size() - 1).label.adjNode));
+                    List<Label.Transition> pathFromStation = pathFromStation(reverseSettledSet.get(p.get(p.size() - 1).label.adjNode));
                     long diff = p.get(p.size() - 1).label.currentTime - pathFromStation.get(0).label.currentTime;
                     List<Label.Transition> patchedPathFromStation = pathFromStation.subList(1, pathFromStation.size()).stream().map(t -> {
                         return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
@@ -295,11 +316,12 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
             return paths;
         }
 
-        private List<Label.Transition> pathFromStation(GraphExplorer accessEgressGraphExplorer, Label l) {
-            return new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(!arriveBy, flagEncoder, accessEgressGraphExplorer, l);
+        private List<Label.Transition> pathFromStation(Label l) {
+            return tripFromLabel.getTransitions(!arriveBy, flagEncoder, queryGraph, l);
         }
     }
 
+    @Inject
     public GraphHopperGtfs(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphHopperStorage graphHopperStorage, LocationIndex locationIndex, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed) {
         this.flagEncoder = flagEncoder;
         this.accessEgressWeighting = new FastestWeighting(graphHopperStorage.getEncodingManager().getEncoder("foot"));
@@ -388,12 +410,36 @@ public static LocationIndex createOrLoadIndex(GHDirectory directory, GraphHopper
         return locationIndex;
     }
 
-    public boolean load(String graphHopperFolder) {
-        throw new IllegalStateException("We are always loaded, or we wouldn't exist.");
+    @GET
+    @Produces(MediaType.APPLICATION_JSON)
+    public ObjectNode route(@QueryParam("point") List<GHLocation> requestPoints,
+                            @QueryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME) String departureTimeString,
+                            @QueryParam("locale") String localeStr,
+                            @QueryParam(Parameters.PT.IGNORE_TRANSFERS) Boolean ignoreTransfers,
+                            @QueryParam(Parameters.PT.PROFILE_QUERY) Boolean profileQuery,
+                            @QueryParam(Parameters.PT.LIMIT_SOLUTIONS) Integer limitSolutions) {
+
+        if (departureTimeString == null) {
+            throw new BadRequestException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+        }
+        Instant departureTime;
+        try {
+            departureTime = Instant.parse(departureTimeString);
+        } catch (DateTimeParseException e) {
+            throw new BadRequestException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+        }
+
+        Request request = new Request(requestPoints, departureTime);
+        Optional.ofNullable(profileQuery).ifPresent(request::setProfileQuery);
+        Optional.ofNullable(ignoreTransfers).ifPresent(request::setIgnoreTransfers);
+        Optional.ofNullable(localeStr).ifPresent(s -> request.setLocale(Helper.getLocale(s)));
+        Optional.ofNullable(limitSolutions).ifPresent(request::setLimitSolutions);
+
+        GHResponse route = new RequestHandler(request).route();
+        return WebHelper.jsonObject(route, true, true, false, false, 0.0f);
     }
 
-    @Override
-    public GHResponse route(GHRequest request) {
+    public GHResponse route(Request request) {
         return new RequestHandler(request).route();
     }
 
@@ -421,7 +467,7 @@ public GHResponse route(GHRequest request) {
 
                     QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
                     queryGraph.lookup(Collections.emptyList());
-                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, false, Collections.emptyList(), true, 5.0);
+                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, false, true, 5.0);
 
                     MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, false, Double.MAX_VALUE, false, false, false, Integer.MAX_VALUE, new ArrayList<>());
                     Iterator<Label> iterator = router.calcLabels(fromnode, tonode, Instant.ofEpochMilli(0), 0).iterator();
@@ -444,12 +490,4 @@ public GHResponse route(GHRequest request) {
                 });
     }
 
-    private PointList pointListFrom(List<QueryResult> queryResults) {
-        PointList waypoints = new PointList(queryResults.size(), true);
-        for (QueryResult qr : queryResults) {
-            waypoints.add(qr.getSnappedPoint());
-        }
-        return waypoints;
-    }
-
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
index bee02ff8eb..68e43af17d 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
@@ -19,6 +19,7 @@
 
 import java.text.SimpleDateFormat;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.util.Date;
 import java.util.Locale;
 
@@ -47,7 +48,11 @@ public static int time(int hours, int minutes) {
     }
     
     public static int time(LocalDateTime localDateTime) {
-        return time(localDateTime.getHour(), localDateTime.getMinute(), 0);
+        return time(localDateTime.getHour(), localDateTime.getMinute(), localDateTime.getSecond());
+    }
+
+    public static int time(LocalTime localTime) {
+        return time(localTime.getHour(), localTime.getMinute(), localTime.getSecond());
     }
 
     public static LocalDateTime localDateTimeFromDate(Date date) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 2b0ce9a2ee..04ce0bf650 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -123,7 +123,10 @@ void connectStopsToStreetNetwork() {
                 } else {
                     streetNode = locationQueryResult.getClosestNode();
                 }
-                gtfsStorage.getStationNodes().put(stop.stop_id, streetNode);
+                Integer prev = gtfsStorage.getStationNodes().put(stop.stop_id, streetNode);
+                if (prev != null) {
+                    throw new RuntimeException("Duplicate stop id: "+stop.stop_id);
+                }
             }
         }
     }
@@ -658,7 +661,8 @@ private void insertOutboundTransfers(String toStopId, String toRouteId, int mini
 
     private String getRouteName(GTFSFeed feed, Trip trip) {
         Route route = feed.routes.get(trip.route_id);
-        return (route.route_long_name != null ? route.route_long_name : route.route_short_name) + " " + trip.trip_headsign;
+        String routePart = route != null ? (route.route_long_name != null ? route.route_long_name : route.route_short_name) : "extra";
+        return routePart + " " + trip.trip_headsign;
     }
 
     private void setEdgeTypeAndClearDistance(EdgeIteratorState edge, GtfsStorage.EdgeType edgeType) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index 03d92d02c8..d584c7020a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.reader.gtfs;
 
+import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
 
 import java.time.Instant;
@@ -63,20 +64,21 @@ public String toString() {
 
     public final long currentTime;
 
-    final int edge;
+    public final int edge;
     public final int adjNode;
 
-    final int nTransfers;
-    final int nWalkDistanceConstraintViolations;
+    public final int nTransfers;
+    public final int nWalkDistanceConstraintViolations;
 
-    final double walkDistanceOnCurrentLeg;
-    final Long departureTime;
-    final long walkTime;
+    public final double walkDistanceOnCurrentLeg;
+    public final Long departureTime;
+    public final long walkTime;
 
     final long residualDelay;
     final boolean impossible;
 
-    final Label parent;
+    public final Label parent;
+    public boolean deleted = false;
 
     Label(long currentTime, int edgeId, int adjNode, int nTransfers, int nWalkDistanceConstraintViolations, double walkDistance, Long departureTime, long walkTime, long residualDelay, boolean impossible, Label parent) {
         this.currentTime = currentTime;
@@ -97,7 +99,7 @@ public String toString() {
         return adjNode + " " + Instant.ofEpochMilli(currentTime) + " " + nTransfers + " " + nWalkDistanceConstraintViolations + " " +  (departureTime != null ? Instant.ofEpochMilli(departureTime) : "");
     }
 
-    static Iterable<Transition> reverseEdges(Label leaf, GraphExplorer graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
+    static Iterable<Transition> reverseEdges(Label leaf, Graph graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
         return new Iterable<Transition>() {
             @Override
             public Iterator<Transition> iterator() {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index d766040745..dce55a2d20 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -43,6 +43,10 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
 import java.time.*;
 import java.time.temporal.ChronoUnit;
 import java.util.*;
@@ -405,17 +409,28 @@ boolean isBlocked(int edgeId) {
     }
 
     public Optional<GtfsReader.TripWithStopTimes> getTripUpdate(GTFSFeed staticFeed, GtfsRealtime.TripDescriptor tripDescriptor, Label.Transition boardEdge, Instant boardTime) {
-        logger.trace("getTripUpdate {}", tripDescriptor);
-        if (!isThisRealtimeUpdateAboutThisLineRun(boardEdge.edge.edgeIteratorState, boardTime)) {
+        try {
+            logger.trace("getTripUpdate {}", tripDescriptor);
+            if (!isThisRealtimeUpdateAboutThisLineRun(boardEdge.edge.edgeIteratorState, boardTime)) {
+                return Optional.empty();
+            } else {
+                GtfsRealtime.TripDescriptor normalizedTripDescriptor = normalize(tripDescriptor);
+                return feedMessages.values().stream().flatMap(feedMessage -> feedMessage.getEntityList().stream()
+                        .filter(e -> e.hasTripUpdate())
+                        .map(e -> e.getTripUpdate())
+                        .filter(tu -> normalize(tu.getTrip()).equals(normalizedTripDescriptor))
+                        .map(tu -> toTripWithStopTimes(staticFeed, tu)))
+                        .findFirst();
+            }
+        } catch (RuntimeException e) {
+            feedMessages.forEach((name, feed) -> {
+                try (OutputStream s = new FileOutputStream(name+".gtfsdump")) {
+                    feed.writeTo(s);
+                } catch (IOException e1) {
+                    throw new RuntimeException();
+                }
+            });
             return Optional.empty();
-        } else {
-            GtfsRealtime.TripDescriptor normalizedTripDescriptor = normalize(tripDescriptor);
-            return feedMessages.values().stream().flatMap(feedMessage -> feedMessage.getEntityList().stream()
-                    .filter(e -> e.hasTripUpdate())
-                    .map(e -> e.getTripUpdate())
-                    .filter(tu -> normalize(tu.getTrip()).equals(normalizedTripDescriptor))
-                    .map(tu -> toTripWithStopTimes(staticFeed, tu)))
-                    .findFirst();
         }
     }
 
@@ -506,6 +521,9 @@ boolean isBlocked(int edgeId) {
                 stopTimes.add(stopTime);
                 logger.trace("Number of stop times: {}", stopTimes.size());
             } else {
+                // http://localhost:3000/route?point=45.51043713898763%2C-122.68381118774415&point=45.522104713562825%2C-122.6455307006836&weighting=fastest&pt.earliest_departure_time=2018-08-24T16%3A56%3A17Z&arrive_by=false&pt.max_walk_distance_per_leg=1000&pt.limit_solutions=5&locale=en-US&vehicle=pt&elevation=false&use_miles=false&points_encoded=false&pt.profile=true
+                // long query:
+                // http://localhost:3000/route?point=45.518526513612244%2C-122.68612861633302&point=45.52908004573869%2C-122.6862144470215&weighting=fastest&pt.earliest_departure_time=2018-08-24T16%3A51%3A20Z&arrive_by=false&pt.max_walk_distance_per_leg=10000&pt.limit_solutions=4&locale=en-US&vehicle=pt&elevation=false&use_miles=false&points_encoded=false&pt.profile=true
                 throw new RuntimeException();
             }
         }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Request.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Request.java
new file mode 100644
index 0000000000..c328a55d93
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Request.java
@@ -0,0 +1,152 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.time.Instant;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+
+public class Request {
+    private List<GHLocation> points;
+    private Instant earliestDepartureTime;
+    private int maxVisitedNodes = 1_000_000;
+    private boolean profileQuery;
+    private Boolean ignoreTransfers;
+    private double betaTransfers = 0.0;
+    private double betaWalkTime = 1.0;
+    private Integer limitSolutions;
+    private boolean arriveBy;
+    private double walkSpeedKmH = 5.0;
+    private int blockedRouteTypes;
+    private Locale locale = Helper.getLocale("en");
+    private double maxWalkDistancePerLeg = Integer.MAX_VALUE;
+
+    public Request(List<GHLocation> points, Instant departureTime) {
+        this.points = points;
+        this.earliestDepartureTime = departureTime;
+    }
+
+    public Request(double from_lat, double from_lon, double to_lat, double to_lon) {
+        this.points = Arrays.asList(new GHPointLocation(new GHPoint(from_lat, from_lon)), new GHPointLocation(new GHPoint(to_lat, to_lon)));
+    }
+
+    public int getMaxVisitedNodes() {
+        return maxVisitedNodes;
+    }
+
+    public void setMaxVisitedNodes(int maxVisitedNodes) {
+        this.maxVisitedNodes = maxVisitedNodes;
+    }
+
+    public boolean isProfileQuery() {
+        return profileQuery;
+    }
+
+    public void setProfileQuery(boolean profileQuery) {
+        this.profileQuery = profileQuery;
+    }
+
+    public Boolean getIgnoreTransfers() {
+        return ignoreTransfers;
+    }
+
+    public void setIgnoreTransfers(Boolean ignoreTransfers) {
+        this.ignoreTransfers = ignoreTransfers;
+    }
+
+    public double getBetaTransfers() {
+        return betaTransfers;
+    }
+
+    public void setBetaTransfers(double betaTransfers) {
+        this.betaTransfers = betaTransfers;
+    }
+
+    public double getBetaWalkTime() {
+        return betaWalkTime;
+    }
+
+    public void setBetaWalkTime(double betaWalkTime) {
+        this.betaWalkTime = betaWalkTime;
+    }
+
+    public Integer getLimitSolutions() {
+        return limitSolutions;
+    }
+
+    public void setLimitSolutions(Integer limitSolutions) {
+        this.limitSolutions = limitSolutions;
+    }
+
+    public Instant getEarliestDepartureTime() {
+        return earliestDepartureTime;
+    }
+
+    public void setEarliestDepartureTime(Instant earliestDepartureTime) {
+        this.earliestDepartureTime = earliestDepartureTime;
+    }
+
+    public boolean isArriveBy() {
+        return arriveBy;
+    }
+
+    public void setArriveBy(boolean arriveBy) {
+        this.arriveBy = arriveBy;
+    }
+
+    public double getWalkSpeedKmH() {
+        return walkSpeedKmH;
+    }
+
+    public void setWalkSpeedKmH(double walkSpeedKmH) {
+        this.walkSpeedKmH = walkSpeedKmH;
+    }
+
+    public int getBlockedRouteTypes() {
+        return blockedRouteTypes;
+    }
+
+    public void setBlockedRouteTypes(int blockedRouteTypes) {
+        this.blockedRouteTypes = blockedRouteTypes;
+    }
+
+    public Locale getLocale() {
+        return locale;
+    }
+
+    public void setLocale(Locale locale) {
+        this.locale = locale;
+    }
+
+    public List<GHLocation> getPoints() {
+        return points;
+    }
+
+    public double getMaxWalkDistancePerLeg() {
+        return maxWalkDistancePerLeg;
+    }
+
+    public void setMaxWalkDistancePerLeg(double maxWalkDistancePerLeg) {
+        this.maxWalkDistancePerLeg = maxWalkDistancePerLeg;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index dd602d699f..7749ac871c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -29,6 +29,7 @@
 import com.graphhopper.routing.InstructionsFromEdges;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
 import org.locationtech.jts.geom.Coordinate;
 import org.locationtech.jts.geom.Geometry;
@@ -60,11 +61,6 @@
         this.realtimeFeed = realtimeFeed;
     }
 
-    PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution, PointList waypoints) {
-        final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
-        return createPathWrapper(tr, waypoints, legs);
-    }
-
     PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg> legs) {
         if (legs.size() > 1 && legs.get(0) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg accessLeg = (Trip.WalkLeg) legs.get(0);
@@ -120,18 +116,13 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return path;
     }
 
-    List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution) {
-        List<Label.Transition> transitions = getTransitions(arriveBy, encoder, queryGraph, solution);
-        return getTrip(tr, queryGraph, weighting, transitions);
-    }
-
-    List<Trip.Leg> getTrip(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<Label.Transition> transitions) {
+    List<Trip.Leg> getTrip(Translation tr, Graph queryGraph, Weighting weighting, List<Label.Transition> transitions) {
         final List<List<Label.Transition>> partitions = getPartitions(transitions);
         final List<Trip.Leg> legs = getLegs(tr, queryGraph, weighting, partitions);
         return legs;
     }
 
-    List<Label.Transition> getTransitions(boolean arriveBy, PtFlagEncoder encoder, GraphExplorer queryGraph, Label solution) {
+    List<Label.Transition> getTransitions(boolean arriveBy, PtFlagEncoder encoder, Graph queryGraph, Label solution) {
         List<Label.Transition> transitions = new ArrayList<>();
         if (arriveBy) {
             reverseEdges(solution, queryGraph, encoder, false)
@@ -162,7 +153,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return partitions;
     }
 
-    private List<Trip.Leg> getLegs(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<List<Label.Transition>> partitions) {
+    private List<Trip.Leg> getLegs(Translation tr, Graph queryGraph, Weighting weighting, List<List<Label.Transition>> partitions) {
         return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, weighting, tr).stream()).collect(Collectors.toList());
     }
 
@@ -194,7 +185,7 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
                 arrivalPointList.add(arrivalStop.geometry.getY(), arrivalStop.geometry.getX());
                 Instruction arrivalInstruction = new Instruction(Instruction.PT_END_TRIP, arrivalStop.stop_name, InstructionAnnotation.EMPTY, arrivalPointList);
                 if (ptLeg.isInSameVehicleAsPrevious) {
-                    instructions.replaceLast(arrivalInstruction);
+                    instructions.set(instructions.size() - 1, arrivalInstruction);
                 } else {
                     instructions.add(arrivalInstruction);
                 }
@@ -330,7 +321,7 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
     // One could argue that one should never write a parser
     // by hand, because it is always ugly, but use a parser library.
     // The code would then read like a specification of what paths through the graph mean.
-    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, GraphExplorer graph, Weighting weighting, Translation tr) {
+    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, Graph graph, Weighting weighting, Translation tr) {
         if (path.size() <= 1) {
             return Collections.emptyList();
         }
@@ -379,7 +370,7 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
             return result;
         } else {
             InstructionList instructions = new InstructionList(tr);
-            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph.getGraph(),
+            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph,
                     weighting, weighting.getFlagEncoder(), weighting.getFlagEncoder().getBooleanEncodedValue(EncodingManager.ROUNDABOUT), graph.getNodeAccess(), tr, instructions);
             int prevEdgeId = -1;
             for (int i = 1; i < path.size(); i++) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
index 032292df9b..5f3605d915 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
@@ -18,6 +18,9 @@
 
 package com.graphhopper.reader.gtfs;
 
+import com.carrotsearch.hppc.IntObjectHashMap;
+import com.carrotsearch.hppc.IntObjectMap;
+import com.google.common.collect.ArrayListMultimap;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
@@ -30,34 +33,50 @@
 import com.graphhopper.storage.IntsRef;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
 
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.stream.IntStream;
+import java.util.stream.StreamSupport;
 
 public class WrapperGraph implements Graph {
 
-    private final Graph baseGraph;
-    private final List<VirtualEdgeIteratorState> extraEdges;
+    private final Graph mainGraph;
+    private final IntObjectMap<EdgeIteratorState> extraEdges = new IntObjectHashMap<>();
+    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
+    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
 
-    public WrapperGraph(Graph baseGraph, List<VirtualEdgeIteratorState> extraEdges) {
-        this.baseGraph = baseGraph;
-        this.extraEdges = extraEdges;
+
+    public WrapperGraph(Graph mainGraph, List<VirtualEdgeIteratorState> extraEdges) {
+        this.mainGraph = mainGraph;
+        extraEdges.forEach(e -> this.extraEdges.put(e.getEdge(), e));
+        for (VirtualEdgeIteratorState extraEdge : extraEdges) {
+            if (extraEdge == null) {
+                throw new RuntimeException();
+            }
+            extraEdgesBySource.put(extraEdge.getBaseNode(), extraEdge);
+            extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalEdgeKey(), extraEdge.getEdge(), extraEdge.getAdjNode(),
+                    extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3), true));
+        }
     }
 
     @Override
     public Graph getBaseGraph() {
-        return baseGraph;
+        return this;
     }
 
     @Override
     public int getNodes() {
         return IntStream.concat(
-                IntStream.of(baseGraph.getNodes() - 1),
-                extraEdges.stream().flatMapToInt(edge -> IntStream.of(edge.getBaseNode(), edge.getAdjNode())))
-                .max().getAsInt() + 1;
+                IntStream.of(mainGraph.getNodes() - 1),
+                StreamSupport.stream(extraEdges.values().spliterator(), false)
+                        .flatMapToInt(cursor -> IntStream.of(cursor.value.getBaseNode(), cursor.value.getAdjNode()))
+        ).max().getAsInt() + 1;
     }
 
     @Override
@@ -67,17 +86,17 @@ public int getEdges() {
 
     @Override
     public NodeAccess getNodeAccess() {
-        return baseGraph.getNodeAccess();
+        return mainGraph.getNodeAccess();
     }
 
     @Override
     public BBox getBounds() {
-        return baseGraph.getBounds();
+        return mainGraph.getBounds();
     }
 
     @Override
     public EdgeIteratorState edge(int a, int b) {
-        return baseGraph.getEdgeIteratorState(a, b);
+        throw new RuntimeException();
     }
 
     @Override
@@ -87,7 +106,12 @@ public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirecti
 
     @Override
     public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
-        return baseGraph.getEdgeIteratorState(edgeId, adjNode);
+        EdgeIteratorState edgeIteratorState = extraEdges.get(edgeId);
+        if (edgeIteratorState != null) {
+            return edgeIteratorState;
+        } else {
+            return mainGraph.getEdgeIteratorState(edgeId, adjNode);
+        }
     }
 
     @Override
@@ -96,8 +120,8 @@ public AllEdgesIterator getAllEdges() {
             @Override
             public int length() {
                 return IntStream.concat(
-                        IntStream.of(baseGraph.getAllEdges().length() - 1),
-                        extraEdges.stream().mapToInt(VirtualEdgeIteratorState::getEdge))
+                        IntStream.of(mainGraph.getAllEdges().length() - 1),
+                        StreamSupport.stream(extraEdges.values().spliterator(), false).mapToInt(cursor -> cursor.value.getEdge()))
                         .max().getAsInt() + 1;
             }
 
@@ -275,12 +299,235 @@ public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState e) {
 
     @Override
     public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
-        return baseGraph.createEdgeExplorer(filter);
+        EdgeExplorer baseGraphEdgeExplorer = mainGraph.createEdgeExplorer(filter);
+        return new EdgeExplorer() {
+            @Override
+            public EdgeIterator setBaseNode(int baseNode) {
+                final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+                extraEdges.addAll(extraEdgesBySource.get(baseNode));
+                extraEdges.addAll(extraEdgesByDestination.get(baseNode));
+                Iterator<VirtualEdgeIteratorState> iterator = extraEdges.iterator();
+                return new EdgeIterator() {
+
+                    EdgeIteratorState current = null;
+                    EdgeIterator baseGraphEdgeIterator = baseGraphIterator();
+                    private EdgeIterator baseGraphIterator() {
+                        if (baseNode < mainGraph.getNodes()) {
+                            return baseGraphEdgeExplorer.setBaseNode(baseNode);
+                        } else {
+                            return null;
+                        }
+                    }
+
+                    @Override
+                    public boolean next() {
+                        if (baseGraphEdgeIterator != null) {
+                            if (baseGraphEdgeIterator.next()) {
+                                current = baseGraphEdgeIterator;
+                                return true;
+                            } else {
+                                baseGraphEdgeIterator = null;
+                            }
+                        }
+                        while(iterator.hasNext()) {
+                            current = iterator.next();
+                            if (filter.accept(current)) {
+                                return true;
+                            }
+                        }
+                        return false;
+                    }
+
+                    @Override
+                    public int getEdge() {
+                        return current.getEdge();
+                    }
+
+                    @Override
+                    public int getOrigEdgeFirst() {
+                        return current.getOrigEdgeFirst();
+                    }
+
+                    @Override
+                    public int getOrigEdgeLast() {
+                        return current.getOrigEdgeLast();
+                    }
+
+                    @Override
+                    public int getBaseNode() {
+                        return current.getBaseNode();
+                    }
+
+                    @Override
+                    public int getAdjNode() {
+                        return current.getAdjNode();
+                    }
+
+                    @Override
+                    public PointList fetchWayGeometry(int mode) {
+                        return current.fetchWayGeometry(mode);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setWayGeometry(PointList list) {
+                        current.setWayGeometry(list);
+                        return this;
+                    }
+
+                    @Override
+                    public double getDistance() {
+                        return current.getDistance();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setDistance(double dist) {
+                        current.setDistance(dist);
+                        return this;
+                    }
+
+                    @Override
+                    public IntsRef getFlags() {
+                        return current.getFlags();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setFlags(IntsRef edgeFlags) {
+                        current.setFlags(edgeFlags);
+                        return this;
+                    }
+
+                    @Override
+                    public int getAdditionalField() {
+                        return current.getAdditionalField();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setAdditionalField(int value) {
+                        current.setAdditionalField(value);
+                        return this;
+                    }
+
+                    @Override
+                    public boolean get(BooleanEncodedValue property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public boolean getReverse(BooleanEncodedValue property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public int get(IntEncodedValue property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(IntEncodedValue property, int value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public int getReverse(IntEncodedValue property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public double get(DecimalEncodedValue property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(DecimalEncodedValue property, double value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public double getReverse(DecimalEncodedValue property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public <T extends Enum> T get(EnumEncodedValue<T> property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public String getName() {
+                        return current.getName();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setName(String name) {
+                        current.setName(name);
+                        return this;
+                    }
+
+                    @Override
+                    public EdgeIteratorState detach(boolean reverse) {
+                        return current.detach(reverse);
+                    }
+
+                    @Override
+                    public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState e) {
+                        return current.copyPropertiesFrom(e);
+                    }
+
+                    @Override
+                    public String toString() {
+                        return current.toString();
+                    }
+                };
+            }
+        };
     }
 
     @Override
     public EdgeExplorer createEdgeExplorer() {
-        return baseGraph.createEdgeExplorer();
+        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     @Override
@@ -290,11 +537,11 @@ public Graph copyTo(Graph g) {
 
     @Override
     public GraphExtension getExtension() {
-        return baseGraph.getExtension();
+        return mainGraph.getExtension();
     }
 
     @Override
     public int getOtherNode(int edge, int node) {
-        return baseGraph.getOtherNode(edge, node);
+        return mainGraph.getOtherNode(edge, node);
     }
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
index d2791b7f9c..97eaa2cf1d 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
@@ -18,9 +18,7 @@
 
 package com.graphhopper;
 
-import com.graphhopper.reader.gtfs.GraphHopperGtfs;
-import com.graphhopper.reader.gtfs.GtfsStorage;
-import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.*;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
@@ -28,6 +26,7 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -74,12 +73,12 @@ public static void close() {
     public void testRoute1() {
         final double FROM_LAT = 36.9010208, FROM_LON = -116.7659466;
         final double TO_LAT =  36.9059371, TO_LON = -116.7618071;
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,9,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,9,0,0).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index c089ae38b7..c35bbf9b46 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -21,6 +21,7 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.Request;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
@@ -29,7 +30,6 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
-import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.Assume;
 import org.junit.BeforeClass;
@@ -84,12 +84,12 @@ public static void close() {
     public void testRoute1() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -101,11 +101,11 @@ public void testRoute1() {
     public void testRoute1DoesNotGoAt654() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 54).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 54).atZone(zoneId).toInstant());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -117,13 +117,13 @@ public void testRoute1DoesNotGoAt654() {
     public void testRoute1GoesAt744() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.BLOCKED_ROUTE_TYPES, 1); // Blocking trams shouldn't matter, this is a bus.
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setBlockedRouteTypes(1); // Blocking trams shouldn't matter, this is a bus.
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -135,12 +135,12 @@ public void testRoute1GoesAt744() {
     public void testNoSolutionIfIDontLikeBusses() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.BLOCKED_ROUTE_TYPES, 8);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
+        ghRequest.setBlockedRouteTypes(8);
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -151,12 +151,12 @@ public void testNoSolutionIfIDontLikeBusses() {
     public void testRoute1ArriveBy() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 49).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 49).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
 
         GHResponse route = graphHopper.route(ghRequest);
 
@@ -170,13 +170,13 @@ public void testRoute1ArriveBy() {
     public void testRoute1ArriveBy2() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
         // Tests that it also works when the query arrival time is not exactly the scheduled arrival time of the solution
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 50).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 50).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
 
         GHResponse route = graphHopper.route(ghRequest);
 
@@ -191,14 +191,14 @@ public void testRoute1ArriveBy2() {
     public void testRoute1ProfileEarliestArrival() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 21);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setProfileQuery(true);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setLimitSolutions(21);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
@@ -216,14 +216,14 @@ public void testRoute1ProfileEarliestArrival() {
     public void testRoute1ProfileOvernight() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 23, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 21);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 23, 0).atZone(zoneId).toInstant());
+        ghRequest.setProfileQuery(true);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setLimitSolutions(21);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
@@ -241,15 +241,15 @@ public void testRoute1ProfileOvernight() {
     public void testRoute1ProfileLatestDeparture() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 13, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 4);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 13, 0).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
+        ghRequest.setProfileQuery(true);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setLimitSolutions(4);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
@@ -287,11 +287,11 @@ public void testRoute4() {
     public void testRoute5() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.toString(), route.hasErrors());
@@ -306,12 +306,12 @@ public void testRoute5() {
     public void testRoute5Arrival() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 8, 10).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 8, 10).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -333,12 +333,12 @@ public void testRouteWithLaterDepartureTime() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.914894, TO_LON = -116.76821; // NADAV stop
         // Missed the bus at 10 by one minute, will have to use the 10:30 one.
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 10, 1).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 10, 1).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -350,11 +350,11 @@ public void testRouteWithLaterDepartureTime() {
     public void testWeekendRouteWorksOnlyOnWeekend() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.641496, TO_LON = -116.40094; // AMV stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant()); // Monday morning
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant()); // Monday morning
 
 
         GHResponse route = graphHopper.route(ghRequest);
@@ -362,11 +362,11 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
         // On Mondays, there is only a complicated evening trip.
         assertEquals("Expected travel time == scheduled travel time", time(22, 0), route.getBest().getTime());
 
-        ghRequest = new GHRequest(
+        ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 6, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 0, 0).atZone(zoneId).toInstant());
         route = graphHopper.route(ghRequest);
         assertFalse(route.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(9, 0), route.getBest().getTime());
@@ -379,11 +379,11 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
     public void testBlockTrips() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.425288, TO_LON = -117.133162; // FUR_CREEK_RES stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 8, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 8, 0).atZone(zoneId).toInstant());
         GHResponse response = graphHopper.route(ghRequest);
         assertEquals("Only find one solution. If blocks wouldn't work, there would be two. (There is a slower alternative without transfer.)", 1, response.getAll().size());
         assertEquals("Expected travel time == scheduled travel time", time(1, 20), response.getBest().getTime());
@@ -396,11 +396,11 @@ public void testBlockTrips() {
     public void testBlockWithComplicatedValidityIntersections() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.641496, TO_LON = -116.40094; // AMV stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 18, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 18, 0).atZone(zoneId).toInstant());
         GHResponse response = graphHopper.route(ghRequest);
         PathWrapper mondayTrip = response.getBest();
         assertEquals("Monday trip has no transfers", 0, mondayTrip.getNumChanges());
@@ -409,7 +409,7 @@ public void testBlockWithComplicatedValidityIntersections() {
         assertEquals("FUNNY_BLOCK_BFC1", (((Trip.PtLeg) mondayTrip.getLegs().get(1)).trip_id));
         assertEquals("FUNNY_BLOCK_FCAMV1", (((Trip.PtLeg) mondayTrip.getLegs().get(2)).trip_id));
 
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 7, 18, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 7, 18, 0).atZone(zoneId).toInstant());
         response = graphHopper.route(ghRequest);
         PathWrapper sundayTrip = response.getBest();
         assertEquals("Sunday trip has no transfers", 0, sundayTrip.getNumChanges());
@@ -429,29 +429,29 @@ public void testTransferRules() {
         final double TO1_LAT = 36.641496, TO1_LON = -116.40094; // AMV stop
         final double TO2_LAT = 36.88108, TO2_LON = -116.81797; // BULLFROG stop
 
-        GHRequest request = new GHRequest(
+        Request request = new Request(
                 FROM_LAT, FROM_LON,
                 TO1_LAT, TO1_LON
         );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
+        request.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
 
         GHResponse response = graphHopper.route(request);
         assertEquals("Transfer rule: 11 minutes. Will miss connection, and be there at 14.", time(6, 30), response.getBest().getTime());
 
-        request = new GHRequest(
+        request = new Request(
                 FROM_LAT, FROM_LON,
                 TO2_LAT, TO2_LON
         );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
+        request.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
 
         response = graphHopper.route(request);
         assertEquals("Will still be there at 8:10 because there is a route-specific exception for this route.", time(0, 40), response.getBest().getTime());
 
-        request = new GHRequest(
+        request = new Request(
                 TO2_LAT, TO2_LON,
                 FROM_LAT, FROM_LON
         );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 6, 12, 5).atZone(zoneId).toInstant());
+        request.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 12, 5).atZone(zoneId).toInstant());
 
         response = graphHopper.route(request);
         assertEquals("Will take 1:15 because of a 'from route' exception with a longer transfer time.", time(1, 15), response.getBest().getTime());
@@ -459,12 +459,12 @@ public void testTransferRules() {
 
 
     private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double FROM_LAT, double FROM_LON, double TO_LAT, double TO_LON, int expectedWeight) {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -473,12 +473,12 @@ private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double FROM_LAT, do
     }
 
     private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double from_lon, double to_lat, double to_lon) {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 from_lat, from_lon,
                 to_lat, to_lon
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         GHResponse route = graphHopper.route(ghRequest);
         assertTrue(route.getAll().isEmpty());
@@ -488,14 +488,14 @@ private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double
     public void testTransferByArrival() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to be there at 7:20
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 7, 20).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 7, 20).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -506,11 +506,11 @@ public void testTransferByArrival() {
 
     @Test
     public void testCustomObjectiveFunction() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.868446, -116.784582,  // BEATTY_AIRPORT stop
                 36.425288, -117.133162       // FUR_CREEK_RES stop
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 14, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 14, 0, 0).atZone(zoneId).toInstant());
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -526,16 +526,16 @@ public void testCustomObjectiveFunction() {
         // Wiggle it by epsilon, and I should prefer one over the other.
         double betaTransfers = solutionWithoutTransfer.getTime() - solutionWithTransfer.getTime();
 
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.setIgnoreTransfers(true);
         // Well, not actually ignore them, but don't do multi-criteria search
 
-        ghRequest.getHints().put("beta_transfers", betaTransfers - 10);
+        ghRequest.setBetaTransfers(betaTransfers - 10);
         response = graphHopper.route(ghRequest);
 
         assertEquals("Get exactly one solution", 1, response.getAll().size());
         assertEquals("Prefer solution with transfers when I give the smaller beta", solutionWithTransfer.getTime(), response.getBest().getTime());
 
-        ghRequest.getHints().put("beta_transfers", betaTransfers + 10);
+        ghRequest.setBetaTransfers(betaTransfers + 10);
 
         response = graphHopper.route(ghRequest);
 
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index 3ef9c3bc70..7a9c7eb406 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -21,13 +21,13 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.Request;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -70,12 +70,12 @@ public static void close() {
 
     @Test
     public void testDepartureTimeOfAccessLegInProfileQuery() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setProfileQuery(true);
 
         GHResponse response = graphHopper.route(ghRequest);
         assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(243);
@@ -91,12 +91,12 @@ public void testDepartureTimeOfAccessLegInProfileQuery() {
 
     @Test
     public void testDepartureTimeOfAccessLeg() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put("beta_walk_time", 2.0); // I somewhat dislike walking
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setBetaWalkTime(2.0); // I somewhat dislike walking
 
         GHResponse response = graphHopper.route(ghRequest);
         assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(129);
@@ -121,7 +121,7 @@ public void testDepartureTimeOfAccessLeg() {
 
         // I like walking exactly as I like riding a bus (per travel time unit)
         // Now, the walk solution dominates, and we get no transit solution.
-        ghRequest.getHints().put("beta_walk_time", 1.0);
+        ghRequest.setBetaWalkTime(1.0);
         response = graphHopper.route(ghRequest);
         assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(138);
         assertThat(response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst()).isEmpty();
@@ -129,12 +129,12 @@ public void testDepartureTimeOfAccessLeg() {
 
     @Test
     public void testFastWalking() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setWalkSpeedKmH(50); // Yes, I can walk very fast, 50 km/h. Problem?
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -149,13 +149,13 @@ public void testFastWalking() {
 
     @Test
     public void testFastWalkingInProfileQuery() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setWalkSpeedKmH(50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.setProfileQuery(true);
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -170,24 +170,24 @@ public void testFastWalkingInProfileQuery() {
 
     @Test
     public void testProfileQueryDoesntEndPrematurely() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
         // Provoke a situation where solutions which are later dominated will be found early.
         // If everything is right, the n-th solution should be the same, no matter if I ask for n, or for n+m solutions.
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 1); // No, I cannot walk very fast, 1 km/h. Problem?
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.setWalkSpeedKmH(1); // No, I cannot walk very fast, 1 km/h. Problem?
+        ghRequest.setProfileQuery(true);
 
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 1);
+        ghRequest.setLimitSolutions(1);
         GHResponse response1 = graphHopper.route(ghRequest);
         assertThat(response1.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(142);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 3);
+        ghRequest.setLimitSolutions(3);
         GHResponse response3 = graphHopper.route(ghRequest);
         assertThat(response3.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(230);
         assertThat(response1.getAll().get(0).getTime()).isEqualTo(response3.getAll().get(0).getTime());
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 5);
+        ghRequest.setLimitSolutions(5);
         GHResponse response5 = graphHopper.route(ghRequest);
         assertThat(response5.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(334);
         assertThat(response3.getAll().get(2).getTime()).isEqualTo(response5.getAll().get(2).getTime());
@@ -195,13 +195,13 @@ public void testProfileQueryDoesntEndPrematurely() {
 
     @Test
     public void testHighDisutilityOfWalking() {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 36.91311729030539, -116.76769495010377,
                 36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
-        ghRequest.getHints().put("beta_walk_time", 20); // But I dislike walking a lot.
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setWalkSpeedKmH(50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.setBetaWalkTime(20); // But I dislike walking a lot.
 
         GHResponse response = graphHopper.route(ghRequest);
 
diff --git a/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java b/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java
new file mode 100644
index 0000000000..da31774cc7
--- /dev/null
+++ b/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java
@@ -0,0 +1,97 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper;
+
+import com.graphhopper.gtfs.ws.LocationConverterProvider;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.reader.gtfs.GraphHopperGtfs;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.Parameters;
+import io.dropwizard.testing.junit.ResourceTestRule;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+import javax.ws.rs.core.Response;
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collections;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public class PtRouteResourceIT {
+
+    private static final String GRAPH_LOC = "target/PtRouteResourceIT";
+    private static GraphHopperGtfs graphHopper;
+
+    static {
+        Helper.removeDir(new File(GRAPH_LOC));
+        final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
+        final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
+        final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
+
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(carFlagEncoder, ptFlagEncoder, footFlagEncoder), 8);
+        GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
+        GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
+        GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
+        LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
+        graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
+                .createWithoutRealtimeFeed();
+    }
+
+    @ClassRule
+    public static final ResourceTestRule resources = ResourceTestRule.builder()
+            .addProvider(new LocationConverterProvider())
+            .setMapper(Jackson.newObjectMapper())
+            .addResource(graphHopper)
+            .build();
+
+    @Test
+    public void testStationStationQuery() {
+        final Response response = resources.target("/route")
+                .queryParam("point", "Stop(NADAV)")
+                .queryParam("point", "Stop(NANAA)")
+                .queryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME, "2007-01-01T08:00:00Z")
+                .request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        GHResponse ghResponse = response.readEntity(GHResponse.class);
+        assertFalse(ghResponse.hasErrors());
+    }
+
+    @Test
+    public void testPointPointQuery() {
+        final Response response = resources.target("/route")
+                .queryParam("point","36.914893,-116.76821") // NADAV stop
+                .queryParam("point","36.914944,-116.761472") //NANAA stop
+                .queryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME, "2007-01-01T08:00:00Z")
+                .request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        GHResponse ghResponse = response.readEntity(GHResponse.class);
+        assertFalse(ghResponse.hasErrors());
+    }
+
+}
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 210475b25e..8940037718 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -22,6 +22,7 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.Request;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
@@ -29,20 +30,13 @@
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.File;
 import java.math.BigDecimal;
-import java.time.Duration;
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.LocalDateTime;
-import java.time.LocalTime;
-import java.time.ZoneId;
-import java.time.ZonedDateTime;
+import java.time.*;
 import java.util.Arrays;
 import java.util.Collections;
 
@@ -90,14 +84,14 @@ public static void close() {
     public void testSkipDepartureStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my departure stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -112,7 +106,7 @@ public void testSkipDepartureStop() {
                 .setStopSequence(3)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         PathWrapper possibleAlternative = response.getAll().stream().filter(a -> !a.isImpossible()).findFirst().get();
         assertFalse(((Trip.PtLeg) possibleAlternative.getLegs().get(0)).stops.get(0).departureCancelled);
@@ -127,14 +121,14 @@ public void testSkipDepartureStop() {
     public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be super-late :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -150,7 +144,7 @@ public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
                 .setStopSequence(3)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(3600).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
         PathWrapper best = response.getBest();
@@ -169,14 +163,14 @@ public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
     public void testCanUseDelayedTripWhenIAmLateToo() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be super-late :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -192,7 +186,7 @@ public void testCanUseDelayedTripWhenIAmLateToo() {
                 .setStopSequence(3)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(120).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         assertEquals("I am two minutes late for my bus, but the bus is two minutes late, too, so I catch it!", time(0, 5), response.getBest().getTime(), 0.1);
     }
@@ -201,14 +195,14 @@ public void testCanUseDelayedTripWhenIAmLateToo() {
     public void testSkipArrivalStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my arrival stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -223,7 +217,7 @@ public void testSkipArrivalStop() {
                 .setStopSequence(4)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(3, response.getAll().size());
 
         assertEquals("I have to continue to STAGECOACH and then go back one stop with the 07:00 bus.", time(0, 21), response.getBest().getTime(), 0.1);
@@ -237,14 +231,14 @@ public void testSkipArrivalStop() {
     public void testSkipTransferStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -259,7 +253,7 @@ public void testSkipTransferStop() {
                 .setStopSequence(5)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will not call at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
@@ -273,15 +267,15 @@ public void testSkipTransferStop() {
     public void testExtraTrip() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -319,7 +313,7 @@ public void testExtraTrip() {
 
         }
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         assertEquals("Luckily, there is an extra service directly from my stop to the airport, at 6:45, taking 30 minutes", time(0, 31), response.getBest().getTime(), 0.1);
@@ -333,15 +327,15 @@ public void testExtraTrip() {
     public void testExtraTripWorksOnlyOnSpecifiedDay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:45, but tomorrow
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,2,6,45).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,2,6,45).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
         feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
@@ -367,7 +361,7 @@ public void testExtraTripWorksOnlyOnSpecifiedDay() {
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).atZone(zoneId).toEpochSecond()));
 
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         assertEquals("There is an extra trip at 6:45 tomorrow, but that doesn't concern me today.", time(1, 5), response.getBest().getTime(), 0.1);
@@ -377,15 +371,15 @@ public void testExtraTripWorksOnlyOnSpecifiedDay() {
     public void testZeroDelay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         GHResponse responseWithoutRealtimeUpdate = graphHopperFactory.createWithoutRealtimeFeed().route(ghRequest);
 
@@ -401,7 +395,7 @@ public void testZeroDelay() {
                 .setScheduleRelationship(SCHEDULED)
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(0).build());
 
-        GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, responseWithRealtimeUpdate.getAll().size());
 
         Trip.PtLeg responseWithRealtimeUpdateBest = (Trip.PtLeg) responseWithRealtimeUpdate.getBest().getLegs().get(0);
@@ -417,16 +411,16 @@ public void testZeroDelay() {
     public void testDelayWithoutTransfer() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
         Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(initialTime);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // The 6:00 departure of my line is going to be late by 3 minutes
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -440,7 +434,7 @@ public void testDelayWithoutTransfer() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         assertEquals("My line run is 3 minutes late.", time(0, 8), response.getBest().getLegs().get(response.getBest().getLegs().size() - 1).getArrivalTime().toInstant().toEpochMilli() - initialTime.toEpochMilli(), 0.1);
@@ -451,16 +445,16 @@ public void testDelayWithoutTransfer() {
     public void testDelayFromBeginningWithoutTransfer() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
         Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(initialTime);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // The 6:00 departure of my line is going to be "late" by 0 minutes
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -476,7 +470,7 @@ public void testDelayFromBeginningWithoutTransfer() {
                 .setScheduleRelationship(SCHEDULED)
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         Trip.PtLeg ptLeg = ((Trip.PtLeg) response.getBest().getLegs().get(0));
@@ -488,13 +482,13 @@ public void testDelayFromBeginningWithoutTransfer() {
     public void testBlockTrips() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.425288, TO_LON = -117.133162; // FUR_CREEK_RES stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // My line does not stop at Bullfrog today. If this was a real transfer, I would not be
         // able to change lines there. But it is not a real transfer, so I can go on as planned.
@@ -508,7 +502,7 @@ public void testBlockTrips() {
                 .setStopSequence(2)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals("I can still use the AB1 trip", "AB1", (((Trip.PtLeg) response.getBest().getLegs().get(0)).trip_id));
         assertEquals("It takes", time(1,20), response.getBest().getTime());
     }
@@ -529,12 +523,12 @@ public void testBlockTripSkipsStop() {
 
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
-        GHResponse route = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        GHResponse route = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         assertFalse(route.hasErrors());
         assertTrue(route.getAll().get(route.getAll().size()-1).isImpossible());
@@ -551,14 +545,14 @@ public void testBlockTripSkipsStop() {
     public void testMissedTransferBecauseOfDelay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be 5 minutes late at my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -572,7 +566,7 @@ public void testMissedTransferBecauseOfDelay() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(300).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
@@ -587,14 +581,14 @@ public void testMissedTransferBecauseOfDelay() {
     public void testMissedTransferButExtraTripOnFirstLeg() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be 5 minutes late at my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -625,7 +619,7 @@ public void testMissedTransferButExtraTripOnFirstLeg() {
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toEpochSecond()))
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toEpochSecond()));
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 //        assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, but I won't be late because there's an extra trip.", time(0, 36), response.getBest().getTime(), 0.1);
@@ -635,14 +629,14 @@ public void testMissedTransferButExtraTripOnFirstLeg() {
     public void testMissedTransferButExtraTripOnSecondLeg() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be 5 minutes late at my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -673,7 +667,7 @@ public void testMissedTransferButExtraTripOnSecondLeg() {
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,20).atZone(zoneId).toEpochSecond()))
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,20).atZone(zoneId).toEpochSecond()));
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 //        assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, but I won't be late because there's an extra trip.", time(0, 36), response.getBest().getTime(), 0.1);
@@ -685,15 +679,15 @@ public void testMissedTransferButExtraTripOnSecondLeg() {
     public void testMissedTransferBecauseOfDelayBackwards() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to be there at 7:20
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,20).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,8,20).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -707,7 +701,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(300).build());
 
-        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId);
+        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build());
         GHResponse response = graphHopper.route(ghRequest);
         assertEquals(2, response.getAll().size());
 
@@ -719,7 +713,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
         assertEquals("Five minutes late", 300, Duration.between(delayedStop.plannedArrivalTime.toInstant(), delayedStop.predictedArrivalTime.toInstant()).getSeconds());
 
         // But when I ask about tomorrow, it works as planned
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,2,8,20).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,2,8,20).atZone(zoneId).toInstant());
         response = graphHopper.route(ghRequest);
         assertEquals(1, response.getAll().size());
 
@@ -732,11 +726,11 @@ public void testMissedTransferBecauseOfDelayBackwards() {
     public void testDelayAtEndForNonFrequencyBasedTrip() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
 
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
         feedMessageBuilder.setHeader(header());
@@ -749,7 +743,7 @@ public void testDelayAtEndForNonFrequencyBasedTrip() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(300).build());
 
-        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId);
+        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
index b8469c6382..5aba5806ed 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
@@ -34,6 +34,7 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.collection.IsEmptyIterable.emptyIterable;
@@ -54,17 +55,6 @@ public GraphExplorerTest() {
         encodingManager = EncodingManager.create(Arrays.asList(pt, foot), 8);
     }
 
-    @Test
-    public void testEverythingEmpty() {
-        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
-        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
-        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
-        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
-        assertThat((Iterable<EdgeIteratorState>) () -> testee.exploreEdgesAround(new Label(0, 0, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).iterator(),
-                emptyIterable());
-    }
-
     @Test
     public void testNonEmptyGraph() {
         GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
@@ -77,7 +67,9 @@ public void testNonEmptyGraph() {
         RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
         List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
 
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        QueryGraph queryGraph = new QueryGraph(graph);
+        queryGraph.lookup(Collections.emptyList());
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
 
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(d.toString()));
@@ -100,7 +92,10 @@ public void testExtraEdgesWithEmptyGraph() {
         g.set(foot.getAccessEnc(), true);
         extraEdges.add(g);
 
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
+        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
+        queryGraph.lookup(Collections.emptyList());
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(e.toString()));
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
@@ -133,13 +128,19 @@ public void testExtraEdgesWithNonEmptyGraph() {
         h.set(foot.getAccessEnc(), true);
         extraEdges.add(h);
 
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
-        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
-                contains(e.toString()));
-        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
-                contains(f.toString(), g.toString()));
-        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
-                contains(d.toString(), h.toString()));
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
+        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
+        queryGraph.lookup(Collections.emptyList());
+        GraphExplorer forward = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
+        assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("0->1"));
+        assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("1->2", "1->3"));
+        assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("0 4-5", "4->7"));
+        GraphExplorer backward = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, true, false, 5.0);
+        assertThat(() -> backward.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("1->0"));
     }
 
     @Test
@@ -196,7 +197,7 @@ public void testExtraEdgesWithNonEmptyGraphAndQueryGraph() {
         point2.calcSnappedPoint(new DistanceCalc2D());
         queryGraph.lookup(point1, point2);
 
-        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(e.toString()));
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index a55dded8c3..26a32040de 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -28,13 +28,11 @@
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.exceptions.PointDistanceExceededException;
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
 import org.junit.*;
 
 import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
 import static com.graphhopper.util.Parameters.Algorithms.*;
 import static org.junit.Assert.*;
@@ -101,33 +99,29 @@ public void testMonacoWithInstructions() {
         InstructionList il = arsp.getInstructions();
         assertEquals(21, il.size());
 
-        List<Map<String, Object>> resultJson = il.createJson();
         // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(4).get("text"));
-        assertEquals("Turn left", resultJson.get(5).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
-
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(96, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(178, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(13, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(42, (Double) resultJson.get(5).get("distance"), 1);
-
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(69, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(128, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(9, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(5).get("time") / 1000);
-
-        List<GPXEntry> list = arsp.getInstructions().createGPXList();
-        assertEquals(87, list.size());
-        final long lastEntryMillis = list.get(list.size() - 1).getTime();
-        final long totalResponseMillis = arsp.getTime();
-        assertEquals(totalResponseMillis, lastEntryMillis);
+        Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
+        assertEquals("continue onto Avenue des Guelfes", il.get(0).getTurnDescription(tr));
+        assertEquals("continue onto Avenue des Papalins", il.get(1).getTurnDescription(tr));
+        assertEquals("turn sharp right onto Quai Jean-Charles Rey", il.get(4).getTurnDescription(tr));
+        assertEquals("turn left", il.get(5).getTurnDescription(tr));
+        assertEquals("turn right onto Avenue Albert II", il.get(6).getTurnDescription(tr));
+
+        assertEquals(11, il.get(0).getDistance(), 1);
+        assertEquals(96, il.get(1).getDistance(), 1);
+        assertEquals(178, il.get(2).getDistance(), 1);
+        assertEquals(13, il.get(3).getDistance(), 1);
+        assertEquals(10, il.get(4).getDistance(), 1);
+        assertEquals(42, il.get(5).getDistance(), 1);
+
+        assertEquals(7, il.get(0).getTime() / 1000);
+        assertEquals(69, il.get(1).getTime() / 1000);
+        assertEquals(128, il.get(2).getTime() / 1000);
+        assertEquals(9, il.get(3).getTime() / 1000);
+        assertEquals(7, il.get(4).getTime() / 1000);
+        assertEquals(30, il.get(5).getTime() / 1000);
+
+        assertEquals(87, arsp.getPoints().size());
     }
 
     @Test
@@ -154,6 +148,7 @@ public void testUTurn() {
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(EncodingManager.create("car"));
         tmpHopper.importOrLoad();
+        Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
 
         GHRequest request = new GHRequest();
         //Force initial U-Turn
@@ -168,11 +163,10 @@ public void testUTurn() {
         InstructionList il = arsp.getInstructions();
         assertEquals(3, il.size());
 
-        List<Map<String, Object>> resultJson = il.createJson();
         // Initial U-turn
-        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(0).get("text"));
+        assertEquals("make a U-turn onto Avenue Princesse Grace", il.get(0).getTurnDescription(tr));
         // Second U-turn to get to destination
-        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(1).get("text"));
+        assertEquals("make a U-turn onto Avenue Princesse Grace", il.get(1).getTurnDescription(tr));
     }
 
     @Test
@@ -251,14 +245,14 @@ public void testPointHint() {
         req.setPointHints(new ArrayList<>(Arrays.asList("Laufamholzstraße, 90482, Nürnberg, Deutschland", "")));
         GHResponse rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        GHPoint snappedPoint = rsp.getBest().getWaypoints().toGHPoint(0);
+        GHPoint snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465686, snappedPoint.getLat(), .000001);
         assertEquals(11.154605, snappedPoint.getLon(), .000001);
 
         req.setPointHints(new ArrayList<>(Arrays.asList("", "")));
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        snappedPoint = rsp.getBest().getWaypoints().toGHPoint(0);
+        snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465502, snappedPoint.getLat(), .000001);
         assertEquals(11.154498, snappedPoint.getLon(), .000001);
 
@@ -266,7 +260,7 @@ public void testPointHint() {
         req.setPointHints(new ArrayList<>(Arrays.asList("xy", "")));
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        snappedPoint = rsp.getBest().getWaypoints().toGHPoint(0);
+        snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465502, snappedPoint.getLat(), .000001);
         assertEquals(11.154498, snappedPoint.getLon(), .000001);
     }
@@ -365,6 +359,7 @@ public void testNorthBayreuthBlockeEdges() {
 
     @Test
     public void testMonacoVia() {
+        Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
         GHResponse rsp = hopper.route(new GHRequest().
                 addPoint(new GHPoint(43.727687, 7.418737)).
                 addPoint(new GHPoint(43.74958, 7.436566)).
@@ -377,36 +372,35 @@ public void testMonacoVia() {
 
         InstructionList il = arsp.getInstructions();
         assertEquals(38, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(4).get("text"));
-        assertEquals("Turn left", resultJson.get(5).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
-
-        assertEquals("Waypoint 1", resultJson.get(20).get("text"));
-        assertEquals(Instruction.U_TURN_UNKNOWN, resultJson.get(21).get("sign"));
-
-        assertEquals("Continue onto Avenue Albert II", resultJson.get(31).get("text"));
-        assertEquals("Turn left", resultJson.get(32).get("text"));
-        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(33).get("text"));
-        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(34).get("text"));
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(36).get("text"));
-        assertEquals("Arrive at destination", resultJson.get(37).get("text"));
-
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(97, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(178, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(13, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(42, (Double) resultJson.get(5).get("distance"), 1);
-
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(69, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(128, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(9, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(5).get("time") / 1000);
+        assertEquals("continue onto Avenue des Guelfes", il.get(0).getTurnDescription(tr));
+        assertEquals("continue onto Avenue des Papalins", il.get(1).getTurnDescription(tr));
+        assertEquals("turn sharp right onto Quai Jean-Charles Rey", il.get(4).getTurnDescription(tr));
+        assertEquals("turn left", il.get(5).getTurnDescription(tr));
+        assertEquals("turn right onto Avenue Albert II", il.get(6).getTurnDescription(tr));
+
+        assertEquals("waypoint 1", il.get(20).getTurnDescription(tr));
+        assertEquals(Instruction.U_TURN_UNKNOWN, il.get(21).getSign());
+
+        assertEquals("continue onto Avenue Albert II", il.get(31).getTurnDescription(tr));
+        assertEquals("turn left", il.get(32).getTurnDescription(tr));
+        assertEquals("turn right onto Quai Jean-Charles Rey", il.get(33).getTurnDescription(tr));
+        assertEquals("turn sharp left onto Avenue des Papalins", il.get(34).getTurnDescription(tr));
+        assertEquals("continue onto Avenue des Guelfes", il.get(36).getTurnDescription(tr));
+        assertEquals("arrive at destination", il.get(37).getTurnDescription(tr));
+
+        assertEquals(11, il.get(0).getDistance(), 1);
+        assertEquals(97, il.get(1).getDistance(), 1);
+        assertEquals(178, il.get(2).getDistance(), 1);
+        assertEquals(13, il.get(3).getDistance(), 1);
+        assertEquals(10, il.get(4).getDistance(), 1);
+        assertEquals(42, il.get(5).getDistance(), 1);
+
+        assertEquals(7, il.get(0).getTime() / 1000);
+        assertEquals(69, il.get(1).getTime() / 1000);
+        assertEquals(128, il.get(2).getTime() / 1000);
+        assertEquals(9, il.get(3).getTime() / 1000);
+        assertEquals(7, il.get(4).getTime() / 1000);
+        assertEquals(30, il.get(5).getTime() / 1000);
 
         // special case of identical start and end point
         rsp = hopper.route(new GHRequest().
@@ -419,8 +413,8 @@ public void testMonacoVia() {
         assertEquals(0, arsp.getRouteWeight(), .1);
         assertEquals(1, arsp.getPoints().getSize());
         assertEquals(1, arsp.getInstructions().size());
-        assertEquals("Arrive at destination", arsp.getInstructions().createJson().get(0).get("text"));
-        assertEquals(Instruction.FINISH, arsp.getInstructions().createJson().get(0).get("sign"));
+        assertEquals("arrive at destination", arsp.getInstructions().get(0).getTurnDescription(tr));
+        assertEquals(Instruction.FINISH, arsp.getInstructions().get(0).getSign());
 
         rsp = hopper.route(new GHRequest().
                 addPoint(new GHPoint(43.727687, 7.418737)).
@@ -433,8 +427,8 @@ public void testMonacoVia() {
         assertEquals(0, arsp.getRouteWeight(), .1);
         assertEquals(1, arsp.getPoints().getSize());
         assertEquals(2, arsp.getInstructions().size());
-        assertEquals(Instruction.REACHED_VIA, arsp.getInstructions().createJson().get(0).get("sign"));
-        assertEquals(Instruction.FINISH, arsp.getInstructions().createJson().get(1).get("sign"));
+        assertEquals(Instruction.REACHED_VIA, arsp.getInstructions().get(0).getSign());
+        assertEquals(Instruction.FINISH, arsp.getInstructions().get(1).getSign());
     }
 
     @Test
@@ -611,15 +605,13 @@ public void testSRTMWithInstructions() throws Exception {
         assertEquals(99, arsp.getAscend(), 1e-1);
         assertEquals(150, arsp.getDescend(), 1e-1);
 
-        List<GPXEntry> list = arsp.getInstructions().createGPXList();
-        assertEquals(54, list.size());
-        final long lastEntryMillis = list.get(list.size() - 1).getTime();
-        assertEquals(new GPXEntry(43.73068455771767, 7.421283689825812, 62.0, 0), list.get(0));
-        assertEquals(new GPXEntry(43.727680946587874, 7.4191987684222065, 11.0, lastEntryMillis), list.get(list.size() - 1));
+        assertEquals(54, arsp.getPoints().size());
+        assertEquals(new GHPoint3D(43.73068455771767, 7.421283689825812, 62.0), arsp.getPoints().get(0));
+        assertEquals(new GHPoint3D(43.727680946587874, 7.4191987684222065, 11.0), arsp.getPoints().get(arsp.getPoints().size()-1));
 
-        assertEquals(62, il.createGPXList().get(0).getElevation(), 1e-2);
-        assertEquals(66, il.createGPXList().get(1).getElevation(), 1e-2);
-        assertEquals(52, il.createGPXList().get(10).getElevation(), 1e-2);
+        assertEquals(62, arsp.getPoints().get(0).getElevation(), 1e-2);
+        assertEquals(66, arsp.getPoints().get(1).getElevation(), 1e-2);
+        assertEquals(52, arsp.getPoints().get(10).getElevation(), 1e-2);
     }
 
     @Test
@@ -690,6 +682,7 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
                 setEncodingManager(EncodingManager.create(tmpImportVehicles)).
                 importOrLoad();
 
+        Translation tr = tmpHopper.getTranslationMap().getWithFallBack(Locale.US);
         GHResponse rsp = tmpHopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
                 setAlgorithm(ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
 
@@ -699,25 +692,24 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
 
         InstructionList il = arsp.getInstructions();
         assertEquals(24, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-
-        assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
-        assertEquals("get off the bike", resultJson.get(0).get("annotation_text"));
-        assertEquals(69.28, (Double) resultJson.get(0).get("heading"), .01);
-        assertEquals("Turn left onto Kirchengasse", resultJson.get(1).get("text"));
-        assertEquals("get off the bike", resultJson.get(1).get("annotation_text"));
-
-        assertEquals("Turn right onto Pfarrplatz", resultJson.get(2).get("text"));
-        assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
-        assertEquals("Keep left onto Hoher Markt", resultJson.get(5).get("text"));
-        assertEquals("Turn right onto Wegscheid", resultJson.get(7).get("text"));
-        assertEquals("Turn right onto Ringstraße, L73", resultJson.get(9).get("text"));
-        assertEquals("Keep left onto Eyblparkstraße", resultJson.get(10).get("text"));
-        assertEquals("Keep left onto Austraße", resultJson.get(11).get("text"));
-        assertEquals("Keep left onto Rechte Kremszeile", resultJson.get(12).get("text"));
+
+        assertEquals("continue onto Obere Landstraße", il.get(0).getTurnDescription(tr));
+        assertEquals("get off the bike", il.get(0).getAnnotation().getMessage());
+        assertEquals(69.28, (Double) il.get(0).getExtraInfoJSON().get("heading"), .01);
+        assertEquals("turn left onto Kirchengasse", il.get(1).getTurnDescription(tr));
+        assertEquals("get off the bike", il.get(1).getAnnotation().getMessage());
+
+        assertEquals("turn right onto Pfarrplatz", il.get(2).getTurnDescription(tr));
+        assertEquals("turn right onto Margarethenstraße", il.get(3).getTurnDescription(tr));
+        assertEquals("keep left onto Hoher Markt", il.get(5).getTurnDescription(tr));
+        assertEquals("turn right onto Wegscheid", il.get(7).getTurnDescription(tr));
+        assertEquals("turn right onto Ringstraße, L73", il.get(9).getTurnDescription(tr));
+        assertEquals("keep left onto Eyblparkstraße", il.get(10).getTurnDescription(tr));
+        assertEquals("keep left onto Austraße", il.get(11).getTurnDescription(tr));
+        assertEquals("keep left onto Rechte Kremszeile", il.get(12).getTurnDescription(tr));
         //..
-        assertEquals("Turn right onto Treppelweg", resultJson.get(19).get("text"));
-        assertEquals("cycleway", resultJson.get(19).get("annotation_text"));
+        assertEquals("turn right onto Treppelweg", il.get(19).getTurnDescription(tr));
+        assertEquals("cycleway", il.get(19).getAnnotation().getMessage());
     }
 
     @Test
@@ -1081,4 +1073,5 @@ public void testCHOnOffWithTurnCosts() {
         // just a quick check that we did not run the same algorithm twice
         assertNotEquals(rsp1.getHints().get("visited_nodes.sum", "_"), rsp2.getHints().get("visited_nodes.sum", "_"));
     }
+
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index a63e3378f4..31a5fed242 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -32,11 +32,10 @@
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.Instruction;
-import com.graphhopper.util.Parameters;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.util.*;
 import com.graphhopper.util.Parameters.Routing;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.After;
 import org.junit.Before;
@@ -44,10 +43,7 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
+import java.util.*;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -149,6 +145,60 @@ public void testLoadOSMNoCH() {
         gh.close();
     }
 
+    @Test
+    public void testQueryLocationIndexWithBBox() {
+        GraphHopper gh = new GraphHopperOSM().setStoreOnFlush(true).
+                setEncodingManager(EncodingManager.create("car")).
+                setCHEnabled(false).
+                setGraphHopperLocation("./target/monacotmp-gh").
+                setDataReaderFile("../core/files/monaco.osm.gz");
+        gh.importOrLoad();
+
+        final NodeAccess na = gh.getGraphHopperStorage().getNodeAccess();
+        final Collection<Integer> indexNodeList = new TreeSet<>();
+        LocationIndexTree index = (LocationIndexTree) gh.getLocationIndex();
+        final EdgeExplorer edgeExplorer = gh.getGraphHopperStorage().createEdgeExplorer();
+        final BBox bbox = new BBox(7.422, 7.429, 43.729, 43.734);
+        index.query(bbox, new LocationIndexTree.EdgeVisitor(edgeExplorer) {
+            @Override
+            public void onTile(BBox bbox, int width) {
+            }
+
+            @Override
+            public void onEdge(EdgeIteratorState edge, int nodeA, int nodeB) {
+                for (int i = 0; i < 2; i++) {
+                    int nodeId = i == 0 ? nodeA : nodeB;
+                    double lat = na.getLatitude(nodeId);
+                    double lon = na.getLongitude(nodeId);
+                    if (bbox.contains(lat, lon))
+                        indexNodeList.add(nodeId);
+                }
+            }
+        });
+
+        assertEquals(57, indexNodeList.size());
+        for (int nodeId : indexNodeList) {
+            if (!bbox.contains(na.getLatitude(nodeId), na.getLongitude(nodeId)))
+                fail("bbox " + bbox + " should contain " + nodeId);
+        }
+
+        final Collection<Integer> bfsNodeList = new TreeSet<>();
+        new BreadthFirstSearch() {
+            @Override
+            protected boolean goFurther(int nodeId) {
+                double lat = na.getLatitude(nodeId);
+                double lon = na.getLongitude(nodeId);
+                if (bbox.contains(lat, lon))
+                    bfsNodeList.add(nodeId);
+
+                return true;
+            }
+        }.start(edgeExplorer, index.findClosest(43.731, 7.425, EdgeFilter.ALL_EDGES).getClosestNode());
+
+        assertTrue("index size: " + indexNodeList.size() + ", bfs size: " + bfsNodeList.size(), indexNodeList.size() >= bfsNodeList.size());
+        assertTrue("index size: " + indexNodeList.size() + ", bfs size: " + bfsNodeList.size(), indexNodeList.containsAll(bfsNodeList));
+    }
+
     @Test
     public void testLoadingWithDifferentCHConfig_issue471() {
         // with CH should not be loadable without CH configured
@@ -301,9 +351,9 @@ public void testSortedGraph_noCH() {
                 setAlgorithm(DIJKSTRA_BI)).getBest();
         assertFalse(rsp.hasErrors());
         assertEquals(3, rsp.getPoints().getSize());
-        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().toGHPoint(0));
-        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().toGHPoint(1));
-        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().toGHPoint(2));
+        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().get(0));
+        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().get(1));
+        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().get(2));
 
         GHRequest req = new GHRequest(51.2492152, 9.4317166, 51.2, 9.4);
         boolean old = instance.getEncodingManager().isEnableInstructions();
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 725af9b51e..c2ccb46121 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -199,7 +199,7 @@ protected void paintComponent(Graphics g) {
             Random rand = new Random();
 
             @Override
-            public void paintComponent(Graphics2D g2) {
+            public void paintComponent(final Graphics2D g2) {
                 clearGraphics(g2);
                 int locs = graph.getNodes();
                 Rectangle d = getBounds();
@@ -275,13 +275,38 @@ public void paintComponent(Graphics2D g2) {
                     boolean fwd = edge.get(accessEnc);
                     boolean bwd = edge.getReverse(accessEnc);
                     float width = speed > 90 ? 1f : 0.8f;
-                    if (fwd && !bwd) {
-                        mg.plotDirectedEdge(g2, lat, lon, lat2, lon2, width);
-                    } else {
-                        mg.plotEdge(g2, lat, lon, lat2, lon2, width);
+                    PointList pl = edge.fetchWayGeometry(3);
+                    for (int i = 1; i < pl.size(); i++) {
+                        if (fwd && !bwd) {
+                            mg.plotDirectedEdge(g2, pl.getLatitude(i - 1), pl.getLongitude(i - 1), pl.getLatitude(i), pl.getLongitude(i), width);
+                        } else {
+                            mg.plotEdge(g2, pl.getLatitude(i - 1), pl.getLongitude(i - 1), pl.getLatitude(i), pl.getLongitude(i), width);
+                        }
                     }
                 }
 
+                index.query(graph.getBounds(), new LocationIndexTree.Visitor() {
+                    @Override
+                    public boolean isTileInfo() {
+                        return true;
+                    }
+
+                    @Override
+                    public void onTile(BBox bbox, int depth) {
+                        int width = Math.max(1, Math.min(4, 4 - depth));
+                        g2.setColor(Color.GRAY);
+                        mg.plotEdge(g2, bbox.minLat, bbox.minLon, bbox.minLat, bbox.maxLon, width);
+                        mg.plotEdge(g2, bbox.minLat, bbox.maxLon, bbox.maxLat, bbox.maxLon, width);
+                        mg.plotEdge(g2, bbox.maxLat, bbox.maxLon, bbox.maxLat, bbox.minLon, width);
+                        mg.plotEdge(g2, bbox.maxLat, bbox.minLon, bbox.minLat, bbox.minLon, width);
+                    }
+
+                    @Override
+                    public void onNode(int node) {
+                        // mg.plotNode(g2, node, Color.BLUE);
+                    }
+                });
+
                 g2.setColor(Color.WHITE);
                 g2.fillRect(0, 0, 1000, 20);
                 for (int i = 4; i < speedColors.length; i++) {
diff --git a/web-api/src/main/java/com/graphhopper/http/api/JsonErrorEntity.java b/web-api/src/main/java/com/graphhopper/http/api/JsonErrorEntity.java
new file mode 100644
index 0000000000..5391637a66
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/http/api/JsonErrorEntity.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http.api;
+
+import com.fasterxml.jackson.annotation.JsonValue;
+import com.fasterxml.jackson.databind.node.ArrayNode;
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.util.exceptions.GHException;
+
+import java.util.List;
+
+public class JsonErrorEntity {
+
+    private final List<Throwable> errors;
+
+    public JsonErrorEntity(List<Throwable> t) {
+        this.errors = t;
+    }
+
+    @JsonValue
+    ObjectNode jsonErrorResponse() {
+        ObjectNode json = JsonNodeFactory.instance.objectNode();
+        json.put("message", getMessage(errors.get(0)));
+        ArrayNode errorHintList = json.putArray("hints");
+        for (Throwable t : errors) {
+            ObjectNode error = errorHintList.addObject();
+            error.put("message", getMessage(t));
+            error.put("details", t.getClass().getName());
+            if (t instanceof GHException) {
+                ((GHException) t).getDetails().forEach(error::putPOJO);
+            }
+        }
+        return json;
+    }
+
+    private String getMessage(Throwable t) {
+        if (t.getMessage() == null)
+            return t.getClass().getSimpleName();
+        else
+            return t.getMessage();
+    }
+
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GHResponseDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/GHResponseDeserializer.java
new file mode 100644
index 0000000000..52057d0c89
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/GHResponseDeserializer.java
@@ -0,0 +1,42 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
+
+import java.io.IOException;
+
+public class GHResponseDeserializer extends JsonDeserializer<GHResponse> {
+    @Override
+    public GHResponse deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+        GHResponse ghResponse = new GHResponse();
+        JsonNode treeNode = p.readValueAsTree();
+        for (JsonNode path : treeNode.get("paths")) {
+            PathWrapper pathWrapper = ((ObjectMapper) p.getCodec()).convertValue(path, PathWrapper.class);
+            ghResponse.add(pathWrapper);
+        }
+        return ghResponse;
+    }
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
index c26a46e270..3c5ef5049d 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
@@ -1,7 +1,9 @@
 package com.graphhopper.jackson;
 
 import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.graphhopper.GHResponse;
 import com.graphhopper.MultiException;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.details.PathDetail;
@@ -11,6 +13,8 @@
 public class GraphHopperModule extends SimpleModule {
 
     public GraphHopperModule() {
+        addDeserializer(GHResponse.class, new GHResponseDeserializer());
+        addDeserializer(PathWrapper.class, new PathWrapperDeserializer());
         addDeserializer(BBox.class, new BBoxDeserializer());
         addSerializer(BBox.class, new BBoxSerializer());
         addDeserializer(GHPoint.class, new GHPointDeserializer());
diff --git a/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
index f584c82d15..92965c465f 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
@@ -3,13 +3,44 @@
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.databind.JsonSerializer;
 import com.fasterxml.jackson.databind.SerializerProvider;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.Instruction;
+import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.InstructionList;
 
 import java.io.IOException;
+import java.util.*;
 
 public class InstructionListSerializer extends JsonSerializer<InstructionList> {
     @Override
     public void serialize(InstructionList instructions, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
-        jsonGenerator.writeObject(instructions.createJson());
+        List<Map<String, Object>> instrList = new ArrayList<>(instructions.size());
+        int pointsIndex = 0;
+        for (Instruction instruction : instructions) {
+            Map<String, Object> instrJson = new HashMap<>();
+            instrList.add(instrJson);
+
+            InstructionAnnotation ia = instruction.getAnnotation();
+            String text = instruction.getTurnDescription(instructions.getTr());
+            if (Helper.isEmpty(text))
+                text = ia.getMessage();
+            instrJson.put("text", Helper.firstBig(text));
+            if (!ia.isEmpty()) {
+                instrJson.put("annotation_text", ia.getMessage());
+                instrJson.put("annotation_importance", ia.getImportance());
+            }
+
+            instrJson.put("street_name", instruction.getName());
+            instrJson.put("time", instruction.getTime());
+            instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
+            instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
+
+            int tmpIndex = pointsIndex + instruction.getLength();
+            instrJson.put("interval", Arrays.asList(pointsIndex, tmpIndex));
+            pointsIndex = tmpIndex;
+
+        }
+        jsonGenerator.writeObject(instrList);
     }
 }
diff --git a/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java
new file mode 100644
index 0000000000..6f782bff26
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java
@@ -0,0 +1,244 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.http.WebHelper;
+import com.graphhopper.util.*;
+import com.graphhopper.util.details.PathDetail;
+import com.graphhopper.util.exceptions.*;
+import org.locationtech.jts.geom.LineString;
+
+import java.io.IOException;
+import java.util.*;
+
+public class PathWrapperDeserializer extends JsonDeserializer<PathWrapper> {
+    @Override
+    public PathWrapper deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+        return createPathWrapper((ObjectMapper) p.getCodec(), p.readValueAsTree(), false, true);
+    }
+
+    public static PathWrapper createPathWrapper(ObjectMapper objectMapper, JsonNode path, boolean hasElevation, boolean turnDescription) {
+        PathWrapper pathWrapper = new PathWrapper();
+        pathWrapper.addErrors(readErrors(objectMapper, path));
+        if (pathWrapper.hasErrors())
+            return pathWrapper;
+
+        if (path.has("snapped_waypoints")) {
+            JsonNode snappedWaypoints = path.get("snapped_waypoints");
+            PointList snappedPoints = deserializePointList(objectMapper, snappedWaypoints, hasElevation);
+            pathWrapper.setWaypoints(snappedPoints);
+        }
+
+        if (path.has("ascend")) {
+            pathWrapper.setAscend(path.get("ascend").asDouble());
+        }
+        if (path.has("descend")) {
+            pathWrapper.setDescend(path.get("descend").asDouble());
+        }
+        if (path.has("weight")) {
+            pathWrapper.setRouteWeight(path.get("weight").asDouble());
+        }
+        if (path.has("description")) {
+            JsonNode descriptionNode = path.get("description");
+            if (descriptionNode.isArray()) {
+                List<String> description = new ArrayList<>(descriptionNode.size());
+                for (JsonNode descNode : descriptionNode) {
+                    description.add(descNode.asText());
+                }
+                pathWrapper.setDescription(description);
+            } else {
+                throw new IllegalStateException("Description has to be an array");
+            }
+        }
+
+        if (path.has("points")) {
+            final PointList pointList = deserializePointList(objectMapper, path.get("points"), hasElevation);
+            pathWrapper.setPoints(pointList);
+
+            if (path.has("instructions")) {
+                JsonNode instrArr = path.get("instructions");
+
+                InstructionList il = new InstructionList(null);
+                int viaCount = 1;
+                for (JsonNode jsonObj : instrArr) {
+                    double instDist = jsonObj.get("distance").asDouble();
+                    String text = turnDescription ? jsonObj.get("text").asText() : jsonObj.get("street_name").asText();
+                    long instTime = jsonObj.get("time").asLong();
+                    int sign = jsonObj.get("sign").asInt();
+                    JsonNode iv = jsonObj.get("interval");
+                    int from = iv.get(0).asInt();
+                    int to = iv.get(1).asInt();
+                    PointList instPL = new PointList(to - from, hasElevation);
+                    for (int j = from; j <= to; j++) {
+                        instPL.add(pointList, j);
+                    }
+
+                    InstructionAnnotation ia = InstructionAnnotation.EMPTY;
+                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text")) {
+                        ia = new InstructionAnnotation(jsonObj.get("annotation_importance").asInt(), jsonObj.get("annotation_text").asText());
+                    }
+
+                    Instruction instr;
+                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT) {
+                        RoundaboutInstruction ri = new RoundaboutInstruction(sign, text, ia, instPL);
+
+                        if (jsonObj.has("exit_number")) {
+                            ri.setExitNumber(jsonObj.get("exit_number").asInt());
+                        }
+
+                        if (jsonObj.has("exited")) {
+                            if (jsonObj.get("exited").asBoolean())
+                                ri.setExited();
+                        }
+
+                        if (jsonObj.has("turn_angle")) {
+                            // TODO provide setTurnAngle setter
+                            double angle = jsonObj.get("turn_angle").asDouble();
+                            ri.setDirOfRotation(angle);
+                            ri.setRadian((angle < 0 ? -Math.PI : Math.PI) - angle);
+                        }
+
+                        instr = ri;
+                    } else if (sign == Instruction.REACHED_VIA) {
+                        ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
+                        tmpInstr.setViaCount(viaCount);
+                        viaCount++;
+                        instr = tmpInstr;
+                    } else if (sign == Instruction.FINISH) {
+                        instr = new FinishInstruction(text, instPL, 0);
+                    } else {
+                        instr = new Instruction(sign, text, ia, instPL);
+                        if (sign == Instruction.CONTINUE_ON_STREET) {
+                            if (jsonObj.has("heading")) {
+                                instr.setExtraInfo("heading", jsonObj.get("heading").asDouble());
+                            }
+                        }
+                    }
+
+                    // Usually, the translation is done from the routing service so just use the provided string
+                    // instead of creating a combination with sign and name etc.
+                    // This is called the turn description.
+                    // This can be changed by passing <code>turn_description=false</code>.
+                    if (turnDescription)
+                        instr.setUseRawName();
+
+                    instr.setDistance(instDist).setTime(instTime);
+                    il.add(instr);
+                }
+                pathWrapper.setInstructions(il);
+            }
+
+            if (path.has("details")) {
+                JsonNode details = path.get("details");
+                Map<String, List<PathDetail>> pathDetails = new HashMap<>(details.size());
+                Iterator<Map.Entry<String, JsonNode>> detailIterator = details.fields();
+                while (detailIterator.hasNext()) {
+                    Map.Entry<String, JsonNode> detailEntry = detailIterator.next();
+                    List<PathDetail> pathDetailList = new ArrayList<>();
+                    for (JsonNode pathDetail : detailEntry.getValue()) {
+                        PathDetail pd = objectMapper.convertValue(pathDetail, PathDetail.class);
+                        pathDetailList.add(pd);
+                    }
+                    pathDetails.put(detailEntry.getKey(), pathDetailList);
+                }
+                pathWrapper.addPathDetails(pathDetails);
+            }
+        }
+
+        double distance = path.get("distance").asDouble();
+        long time = path.get("time").asLong();
+        pathWrapper.setDistance(distance).setTime(time);
+        return pathWrapper;
+    }
+
+    private static PointList deserializePointList(ObjectMapper objectMapper, JsonNode jsonNode, boolean hasElevation) {
+        PointList snappedPoints;
+        if (jsonNode.isTextual()) {
+            snappedPoints = WebHelper.decodePolyline(jsonNode.asText(), 5, hasElevation);
+        } else {
+            LineString lineString = objectMapper.convertValue(jsonNode, LineString.class);
+            snappedPoints = PointList.fromLineString(lineString);
+        }
+        return snappedPoints;
+    }
+
+    public static List<Throwable> readErrors(ObjectMapper objectMapper, JsonNode json) {
+        List<Throwable> errors = new ArrayList<>();
+        JsonNode errorJson;
+
+        if (json.has("message")) {
+            if (json.has("hints")) {
+                errorJson = json.get("hints");
+            } else {
+                // should not happen
+                errors.add(new RuntimeException(json.get("message").asText()));
+                return errors;
+            }
+        } else
+            return errors;
+
+        for (JsonNode error : errorJson) {
+            String exClass = "";
+            if (error.has("details"))
+                exClass = error.get("details").asText();
+
+            String exMessage = error.get("message").asText();
+
+            if (exClass.equals(UnsupportedOperationException.class.getName()))
+                errors.add(new UnsupportedOperationException(exMessage));
+            else if (exClass.equals(IllegalStateException.class.getName()))
+                errors.add(new IllegalStateException(exMessage));
+            else if (exClass.equals(RuntimeException.class.getName()))
+                errors.add(new DetailedRuntimeException(exMessage, toMap(objectMapper, error)));
+            else if (exClass.equals(IllegalArgumentException.class.getName()))
+                errors.add(new DetailedIllegalArgumentException(exMessage, toMap(objectMapper, error)));
+            else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
+                errors.add(new ConnectionNotFoundException(exMessage, toMap(objectMapper, error)));
+            } else if (exClass.equals(PointNotFoundException.class.getName())) {
+                int pointIndex = error.get("point_index").asInt();
+                errors.add(new PointNotFoundException(exMessage, pointIndex));
+            } else if (exClass.equals(PointOutOfBoundsException.class.getName())) {
+                int pointIndex = error.get("point_index").asInt();
+                errors.add(new PointOutOfBoundsException(exMessage, pointIndex));
+            } else if (exClass.isEmpty())
+                errors.add(new DetailedRuntimeException(exMessage, toMap(objectMapper, error)));
+            else
+                errors.add(new DetailedRuntimeException(exClass + " " + exMessage, toMap(objectMapper, error)));
+        }
+
+        if (json.has("message") && errors.isEmpty())
+            errors.add(new RuntimeException(json.get("message").asText()));
+
+        return errors;
+    }
+
+    // Credits to: http://stackoverflow.com/a/24012023/194609
+    private static Map<String, Object> toMap(ObjectMapper objectMapper, JsonNode object) {
+        return objectMapper.convertValue(object, new TypeReference<Map<String, Object>>() {
+        });
+    }
+
+}
diff --git a/api/src/main/java/com/graphhopper/util/GPXEntry.java b/web-api/src/main/java/com/graphhopper/util/gpx/GPXEntry.java
similarity index 52%
rename from api/src/main/java/com/graphhopper/util/GPXEntry.java
rename to web-api/src/main/java/com/graphhopper/util/gpx/GPXEntry.java
index 49a1e0a803..27847c1705 100644
--- a/api/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/web-api/src/main/java/com/graphhopper/util/gpx/GPXEntry.java
@@ -15,62 +15,55 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.util.gpx;
 
 import com.graphhopper.util.shapes.GHPoint;
-import com.graphhopper.util.shapes.GHPoint3D;
+
+import java.util.Objects;
 
 /**
  * @author Peter Karich
  */
-public class GPXEntry extends GHPoint3D {
-    private long time;
-
-    public GPXEntry(GHPoint p, long millis) {
-        this(p.lat, p.lon, millis);
-    }
-
-    public GPXEntry(double lat, double lon, long millis) {
-        super(lat, lon, Double.NaN);
-        this.time = millis;
-    }
+public class GPXEntry {
+    private GHPoint point;
+    private Long time;
 
-    public GPXEntry(double lat, double lon, double ele, long millis) {
-        super(lat, lon, ele);
-        this.time = millis;
+    public GPXEntry(GHPoint p) {
+        this.point = p;
     }
 
-    boolean is3D() {
-        return !Double.isNaN(ele);
+    public GPXEntry(GHPoint p, long time) {
+        this.point = p;
+        this.time = time;
     }
 
-    /**
-     * The time relative to the start time in milli seconds.
-     */
-    public long getTime() {
+    public Long getTime() {
         return time;
     }
 
-    public void setTime(long time) {
-        this.time = time;
+    public GHPoint getPoint() {
+        return point;
     }
 
     @Override
-    public int hashCode() {
-        return 59 * super.hashCode() + (int) (time ^ (time >>> 32));
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        GPXEntry gpxEntry = (GPXEntry) o;
+        return Objects.equals(point, gpxEntry.point) &&
+                Objects.equals(time, gpxEntry.time);
     }
 
     @Override
-    public boolean equals(Object obj) {
-        if (obj == null)
-            return false;
-
-        final GPXEntry other = (GPXEntry) obj;
-        return time == other.time && super.equals(obj);
+    public int hashCode() {
+        return Objects.hash(point, time);
     }
 
     @Override
     public String toString() {
-        return super.toString() + ", " + time;
+        return "GPXEntry{" +
+                "point=" + point +
+                ", time=" + time +
+                '}';
     }
 }
diff --git a/web-api/src/main/java/com/graphhopper/util/gpx/GpxFromInstructions.java b/web-api/src/main/java/com/graphhopper/util/gpx/GpxFromInstructions.java
new file mode 100644
index 0000000000..29522f0994
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/util/gpx/GpxFromInstructions.java
@@ -0,0 +1,173 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.util.gpx;
+
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint3D;
+
+import java.text.DateFormat;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+public class GpxFromInstructions {
+
+    static String simpleXMLEscape(String str) {
+        // We could even use the 'more flexible' CDATA section but for now do the following. The 'and' could be important sometimes:
+        return str.replaceAll("&", "&amp;").
+                // but do not care for:
+                        replaceAll("[\\<\\>]", "_");
+    }
+
+    public static List<GPXEntry> createGPXList(InstructionList instructions) {
+        List<GPXEntry> gpxList = new ArrayList<>();
+        long timeOffset = 0;
+        for (Instruction instruction : instructions) {
+            int i = 0;
+            for (GHPoint3D point : instruction.getPoints()) {
+                GPXEntry gpxEntry;
+                if (i == 0) {
+                    gpxEntry = new GPXEntry(point, timeOffset);
+                } else {
+                    // We don't have timestamps for pillar nodes
+                    gpxEntry = new GPXEntry(point);
+                }
+                gpxList.add(gpxEntry);
+                i++;
+            }
+            timeOffset = timeOffset + instruction.getTime();
+        }
+        return gpxList;
+    }
+
+    private static void createWayPointBlock(StringBuilder output, Instruction instruction, DecimalFormat decimalFormat, Translation tr) {
+        output.append("\n<wpt ");
+        output.append("lat=\"").append(decimalFormat.format(instruction.getPoints().getLatitude(0)));
+        output.append("\" lon=\"").append(decimalFormat.format(instruction.getPoints().getLongitude(0))).append("\">");
+        String name;
+        if (instruction.getName().isEmpty())
+            name = instruction.getTurnDescription(tr);
+        else
+            name = instruction.getName();
+
+        output.append(" <name>").append(simpleXMLEscape(name)).append("</name>");
+        output.append("</wpt>");
+    }
+
+    public static String createGPX(InstructionList instructions, String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version, Translation tr) {
+        DateFormat formatter = Helper.createFormatter();
+
+        DecimalFormat decimalFormat = new DecimalFormat("#", DecimalFormatSymbols.getInstance(Locale.ROOT));
+        decimalFormat.setMinimumFractionDigits(1);
+        decimalFormat.setMaximumFractionDigits(6);
+        decimalFormat.setMinimumIntegerDigits(1);
+
+        String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
+                + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
+                + " creator=\"Graphhopper version " + version + "\" version=\"1.1\""
+                // This xmlns:gh acts only as ID, no valid URL necessary.
+                // Use a separate namespace for custom extensions to make basecamp happy.
+                + " xmlns:gh=\"https://graphhopper.com/public/schema/gpx/1.1\">"
+                + "\n<metadata>"
+                + "<copyright author=\"OpenStreetMap contributors\"/>"
+                + "<link href=\"http://graphhopper.com\">"
+                + "<text>GraphHopper GPX</text>"
+                + "</link>"
+                + "<time>" + formatter.format(startTimeMillis) + "</time>"
+                + "</metadata>";
+        StringBuilder gpxOutput = new StringBuilder(header);
+        if (!instructions.isEmpty()) {
+            if (withWayPoints) {
+                createWayPointBlock(gpxOutput, instructions.get(0), decimalFormat, tr);   // Start
+                for (Instruction currInstr : instructions) {
+                    if ((currInstr.getSign() == Instruction.REACHED_VIA) // Via
+                            || (currInstr.getSign() == Instruction.FINISH)) // End
+                    {
+                        createWayPointBlock(gpxOutput, currInstr, decimalFormat, tr);
+                    }
+                }
+            }
+            if (withRoute) {
+                gpxOutput.append("\n<rte>");
+                Instruction nextInstr = null;
+                for (Instruction currInstr : instructions) {
+                    if (null != nextInstr)
+                        createRteptBlock(gpxOutput, nextInstr, currInstr, decimalFormat, tr);
+
+                    nextInstr = currInstr;
+                }
+                createRteptBlock(gpxOutput, nextInstr, null, decimalFormat, tr);
+                gpxOutput.append("\n</rte>");
+            }
+        }
+        if (withTrack) {
+            gpxOutput.append("\n<trk><name>").append(trackName).append("</name>");
+
+            gpxOutput.append("<trkseg>");
+            for (GPXEntry entry : createGPXList(instructions)) {
+                gpxOutput.append("\n<trkpt lat=\"").append(decimalFormat.format(entry.getPoint().getLat()));
+                gpxOutput.append("\" lon=\"").append(decimalFormat.format(entry.getPoint().getLon())).append("\">");
+                if (includeElevation)
+                    gpxOutput.append("<ele>").append(Helper.round2(((GHPoint3D) entry.getPoint()).getEle())).append("</ele>");
+                if (entry.getTime() != null)
+                    gpxOutput.append("<time>").append(formatter.format(startTimeMillis + entry.getTime())).append("</time>");
+                gpxOutput.append("</trkpt>");
+            }
+            gpxOutput.append("\n</trkseg>");
+            gpxOutput.append("\n</trk>");
+        }
+
+        // we could now use 'wpt' for via points
+        gpxOutput.append("\n</gpx>");
+        return gpxOutput.toString();
+    }
+
+    private static void createRteptBlock(StringBuilder output, Instruction instruction, Instruction nextI, DecimalFormat decimalFormat, Translation tr) {
+        output.append("\n<rtept lat=\"").append(decimalFormat.format(instruction.getPoints().getLatitude(0))).
+                append("\" lon=\"").append(decimalFormat.format(instruction.getPoints().getLongitude(0))).append("\">");
+
+        if (!instruction.getName().isEmpty())
+            output.append("<desc>").append(simpleXMLEscape(instruction.getTurnDescription(tr))).append("</desc>");
+
+        output.append("<extensions>");
+        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
+        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
+
+        String direction = instruction.calcDirection(nextI);
+        if (!direction.isEmpty())
+            output.append("<gh:direction>").append(direction).append("</gh:direction>");
+
+        double azimuth = instruction.calcAzimuth(nextI);
+        if (!Double.isNaN(azimuth))
+            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
+
+        if (instruction instanceof RoundaboutInstruction) {
+            RoundaboutInstruction ri = (RoundaboutInstruction) instruction;
+
+            output.append("<gh:exit_number>").append(ri.getExitNumber()).append("</gh:exit_number>");
+        }
+
+        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
+        output.append("</extensions>");
+        output.append("</rtept>");
+    }
+
+}
diff --git a/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java b/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
index e878add342..73f50ef9f7 100644
--- a/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
+++ b/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
@@ -1,19 +1,22 @@
 package com.graphhopper.util;
 
-import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.jackson.Jackson;
 import org.junit.Test;
 
+import java.io.IOException;
 import java.util.Collections;
 import java.util.Locale;
 import java.util.Map;
 
-import static org.junit.Assert.*;
+import static io.dropwizard.testing.FixtureHelpers.fixture;
+import static org.junit.Assert.assertEquals;
 
 public class InstructionListRepresentationTest {
 
     @Test
-    public void testRoundaboutJsonIntegrity() {
+    public void testRoundaboutJsonIntegrity() throws IOException {
+        ObjectMapper objectMapper = Jackson.newObjectMapper();
         InstructionList il = new InstructionList(usTR);
 
         PointList pl = new PointList();
@@ -27,27 +30,14 @@ public void testRoundaboutJsonIntegrity() {
                 .setExitNumber(2)
                 .setExited();
         il.add(instr);
-
-        Map<String, Object> json = il.createJson().get(0);
-        // assert that all information is present in map for JSON
-        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
-        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
-        assertEquals("2", json.get("exit_number").toString());
-        // assert that a valid JSON object can be written
-        assertNotNull(write(json));
+        assertEquals(objectMapper.readTree(fixture("fixtures/roundabout1.json")).toString(), objectMapper.valueToTree(il).toString());
     }
 
-    private String write(Map<String, Object> json) {
-        try {
-            return new ObjectMapper().writeValueAsString(json);
-        } catch (JsonProcessingException e) {
-            throw new RuntimeException(e);
-        }
-    }
 
     // Roundabout with unknown dir of rotation
     @Test
-    public void testRoundaboutJsonNaN() {
+    public void testRoundaboutJsonNaN() throws IOException {
+        ObjectMapper objectMapper = Jackson.newObjectMapper();
         InstructionList il = new InstructionList(usTR);
 
         PointList pl = new PointList();
@@ -60,15 +50,10 @@ public void testRoundaboutJsonNaN() {
                 .setExitNumber(2)
                 .setExited();
         il.add(instr);
-
-        Map<String, Object> json = il.createJson().get(0);
-        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
-        assertNull(json.get("turn_angle"));
-        // assert that a valid JSON object can be written
-        assertNotNull(write(json));
+        assertEquals(objectMapper.readTree(fixture("fixtures/roundabout2.json")).toString(), objectMapper.valueToTree(il).toString());
     }
 
-    static Translation usTR = new Translation() {
+    private static Translation usTR = new Translation() {
         @Override
         public String tr(String key, Object... params) {
             if (key.equals("roundabout_exit_onto"))
diff --git a/web-api/src/test/resources/fixtures/roundabout1.json b/web-api/src/test/resources/fixtures/roundabout1.json
new file mode 100644
index 0000000000..1502f85039
--- /dev/null
+++ b/web-api/src/test/resources/fixtures/roundabout1.json
@@ -0,0 +1,11 @@
+[ {
+    "exit_number" : 2,
+    "distance" : 0.0,
+    "sign" : 6,
+    "exited" : true,
+    "turn_angle" : -1.0,
+    "interval" : [ 0, 3 ],
+    "text" : "At roundabout, take exit 2 onto streetname",
+    "time" : 0,
+    "street_name" : "streetname"
+} ]
\ No newline at end of file
diff --git a/web-api/src/test/resources/fixtures/roundabout2.json b/web-api/src/test/resources/fixtures/roundabout2.json
new file mode 100644
index 0000000000..5139688ceb
--- /dev/null
+++ b/web-api/src/test/resources/fixtures/roundabout2.json
@@ -0,0 +1,10 @@
+[ {
+    "exit_number" : 2,
+    "distance" : 0.0,
+    "sign" : 6,
+    "exited" : true,
+    "interval" : [ 0, 3 ],
+    "text" : "At roundabout, take exit 2 onto streetname",
+    "time" : 0,
+    "street_name" : "streetname"
+} ]
\ No newline at end of file
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
index 9cecb8c603..6bbe30847b 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
@@ -37,7 +37,6 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
-import com.graphhopper.reader.gtfs.RealtimeFeed;
 import com.graphhopper.resources.*;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
@@ -215,22 +214,22 @@ private void runPtGraphHopper(CmdArgs configuration, Environment environment) {
                 configuration.has("datareader.file") ? Arrays.asList(configuration.get("datareader.file", "").split(",")) : Collections.emptyList());
         final TranslationMap translationMap = GraphHopperGtfs.createTranslationMap();
         final LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(ghDirectory, graphHopperStorage);
-        final GraphHopperAPI graphHopper = new GraphHopperGtfs(ptFlagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.empty(gtfsStorage));
         environment.jersey().register(new AbstractBinder() {
             @Override
             protected void configure() {
                 bind(configuration).to(CmdArgs.class);
-                bind(graphHopper).to(GraphHopperAPI.class);
                 bind(false).to(Boolean.class).named("hasElevation");
                 bind(locationIndex).to(LocationIndex.class);
                 bind(translationMap).to(TranslationMap.class);
                 bind(encodingManager).to(EncodingManager.class);
+                bind(ptFlagEncoder).to(PtFlagEncoder.class);
                 bind(graphHopperStorage).to(GraphHopperStorage.class);
+                bind(gtfsStorage).to(GtfsStorage.class);
                 bindFactory(RasterHullBuilderFactory.class).to(DelaunayTriangulationIsolineBuilder.class);
             }
         });
         environment.jersey().register(NearestResource.class);
-        environment.jersey().register(RouteResource.class);
+        environment.jersey().register(GraphHopperGtfs.class);
         environment.jersey().register(new PtIsochroneResource(gtfsStorage, encodingManager, graphHopperStorage, locationIndex));
         environment.jersey().register(I18NResource.class);
         environment.jersey().register(InfoResource.class);
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
index 4496fa7f4d..7c24ee5e15 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
@@ -31,7 +31,7 @@
 @Path("isochrone")
 public class IsochroneResource {
 
-    private static final Logger logger = LoggerFactory.getLogger(RouteResource.class);
+    private static final Logger logger = LoggerFactory.getLogger(IsochroneResource.class);
 
     private final GraphHopper graphHopper;
     private final EncodingManager encodingManager;
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
index 9a39461cdf..876199520d 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
@@ -22,7 +22,6 @@
 import com.graphhopper.json.geo.JsonFeature;
 import com.graphhopper.reader.gtfs.*;
 import com.graphhopper.routing.QueryGraph;
-import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
@@ -31,11 +30,10 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.locationtech.jts.geom.*;
-import org.locationtech.jts.index.strtree.STRtree;
 import org.locationtech.jts.triangulate.ConformingDelaunayTriangulator;
 import org.locationtech.jts.triangulate.ConstraintVertex;
 import org.locationtech.jts.triangulate.DelaunayTriangulationBuilder;
@@ -58,7 +56,6 @@
     private EncodingManager encodingManager;
     private GraphHopperStorage graphHopperStorage;
     private LocationIndex locationIndex;
-//    private final STRtree spatialIndex;
 
     private final Function<Label, Double> z = label -> (double) label.currentTime;
 
@@ -67,15 +64,6 @@ public PtIsochroneResource(GtfsStorage gtfsStorage, EncodingManager encodingMana
         this.encodingManager = encodingManager;
         this.graphHopperStorage = graphHopperStorage;
         this.locationIndex = locationIndex;
-//        spatialIndex = new STRtree();
-//        PtFlagEncoder ptFlagEncoder = (PtFlagEncoder) encodingManager.getEncoder("pt");
-//        AllEdgesIterator allEdges = graphHopperStorage.getAllEdges();
-//        while (allEdges.next()) {
-//            if (ptFlagEncoder.getEdgeType(allEdges.getFlags()) == GtfsStorage.EdgeType.HIGHWAY) {
-//                LineString geom = allEdges.fetchWayGeometry(3).toLineString(false);
-//                spatialIndex.insert(geom.getEnvelopeInternal(), allEdges.getEdge());
-//            }
-//        }
     }
 
     public static class Response {
@@ -114,7 +102,7 @@ public Response doGet(
         }
 
         PtFlagEncoder ptFlagEncoder = (PtFlagEncoder) encodingManager.getEncoder("pt");
-        GraphExplorer graphExplorer = new GraphExplorer(queryGraph, new FastestWeighting(encodingManager.getEncoder("foot")), ptFlagEncoder, gtfsStorage, RealtimeFeed.empty(gtfsStorage), reverseFlow, Collections.emptyList(), false, 5.0);
+        GraphExplorer graphExplorer = new GraphExplorer(queryGraph, new FastestWeighting(encodingManager.getEncoder("foot")), ptFlagEncoder, gtfsStorage, RealtimeFeed.empty(gtfsStorage), reverseFlow, false, 5.0);
         MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, ptFlagEncoder, reverseFlow, Double.MAX_VALUE, false, false, false, 1000000, Collections.emptyList());
 
         Map<Coordinate, Double> z1 = new HashMap<>();
@@ -133,17 +121,16 @@ public Response doGet(
             router.calcLabelsAndNeighbors(queryResult.getClosestNode(), -1, initialTime, blockedRouteTypes, sptVisitor, label -> label.currentTime <= targetZ);
             MultiPoint exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
 
-            // This is what we need to do once we can do bounding-box queries on our spatial index.
-            // Then it should be impossible for unreachable encroaching points to not be found.
-
-//            spatialIndex.query(exploredPointsAndNeighbors.getEnvelopeInternal(), edgeId -> {
-//                EdgeIteratorState e = graphHopperStorage.getEdgeIteratorState((int) edgeId, Integer.MIN_VALUE);
-//                Coordinate nodeCoordinate = new Coordinate(nodeAccess.getLongitude(e.getBaseNode()), nodeAccess.getLatitude(e.getBaseNode()));
-//                z1.merge(nodeCoordinate, Double.MAX_VALUE, Math::min);
-//                nodeCoordinate = new Coordinate(nodeAccess.getLongitude(e.getAdjNode()), nodeAccess.getLatitude(e.getAdjNode()));
-//                z1.merge(nodeCoordinate, Double.MAX_VALUE, Math::min);
-//            });
-//            exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
+            // Get at least all nodes within our bounding box (I think convex hull would be enough.)
+            // I think then we should have all possible encroaching points. (Proof needed.)
+            locationIndex.query(BBox.fromEnvelope(exploredPointsAndNeighbors.getEnvelopeInternal()), new LocationIndex.Visitor() {
+                @Override
+                public void onNode(int nodeId) {
+                    Coordinate nodeCoordinate = new Coordinate(nodeAccess.getLongitude(nodeId), nodeAccess.getLatitude(nodeId));
+                    z1.merge(nodeCoordinate, Double.MAX_VALUE, Math::min);
+                }
+            });
+            exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
 
             CoordinateList siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(exploredPointsAndNeighbors);
             List<ConstraintVertex> constraintVertices = new ArrayList<>();
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index 517bbb51ee..9521fa1e66 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -22,12 +22,9 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.MultiException;
 import com.graphhopper.http.WebHelper;
-import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.HintsMap;
-import com.graphhopper.util.Constants;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
+import com.graphhopper.util.gpx.GpxFromInstructions;
 import com.graphhopper.util.shapes.GHPoint;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -168,7 +165,8 @@ public Response doGet(
         }
 
         long time = timeString != null ? Long.parseLong(timeString) : System.currentTimeMillis();
-        return Response.ok(ghRsp.getBest().getInstructions().createGPX(trackName, time, enableElevation, withRoute, withTrack, withWayPoints, version), "application/gpx+xml").
+        InstructionList instructions = ghRsp.getBest().getInstructions();
+        return Response.ok(GpxFromInstructions.createGPX(instructions, trackName, time, enableElevation, withRoute, withTrack, withWayPoints, version, instructions.getTr()), "application/gpx+xml").
                 header("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
     }
 
diff --git a/web-bundle/src/test/java/com/graphhopper/util/gpx/GpxFromInstructionsTest.java b/web-bundle/src/test/java/com/graphhopper/util/gpx/GpxFromInstructionsTest.java
new file mode 100644
index 0000000000..bd7f3ea700
--- /dev/null
+++ b/web-bundle/src/test/java/com/graphhopper/util/gpx/GpxFromInstructionsTest.java
@@ -0,0 +1,243 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.util.gpx;
+
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.*;
+import org.junit.Before;
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+import javax.xml.XMLConstants;
+import javax.xml.transform.Source;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import javax.xml.validation.Validator;
+import java.io.StringReader;
+import java.util.*;
+
+import static org.junit.Assert.*;
+
+public class GpxFromInstructionsTest {
+
+    private EncodingManager carManager;
+    private FlagEncoder carEncoder;
+    private BooleanEncodedValue roundaboutEnc;
+    private TranslationMap trMap;
+
+    @Before
+    public void setUp() {
+        carEncoder = new CarFlagEncoder();
+        carManager = EncodingManager.create(carEncoder);
+        roundaboutEnc = carManager.getBooleanEncodedValue(EncodingManager.ROUNDABOUT);
+        trMap = new TranslationMap().doImport();
+    }
+
+    @Test
+    public void testInstructionsWithTimeAndPlace() {
+        Graph g = new GraphBuilder(carManager).create();
+        //   n-4-5   (n: pillar node)
+        //   |
+        // 7-3-2-6
+        //     |
+        //     1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(1, 15.0, 10);
+        na.setNode(2, 15.1, 10);
+        na.setNode(3, 15.1, 9.9);
+        na.setNode(4, 15.2, 9.9);
+        na.setNode(5, 15.2, 10);
+        na.setNode(6, 15.1, 10.1);
+        na.setNode(7, 15.1, 9.8);
+
+        g.edge(1, 2, 7000, true).setName("1-2").setFlags(flagsForSpeed(carManager, 70));
+        g.edge(2, 3, 8000, true).setName("2-3").setFlags(flagsForSpeed(carManager, 80));
+        g.edge(2, 6, 10000, true).setName("2-6").setFlags(flagsForSpeed(carManager, 10));
+        g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
+        g.edge(3, 7, 10000, true).setName("3-7").setFlags(flagsForSpeed(carManager, 10));
+        g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
+
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(1, 5);
+        InstructionList wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
+        PointList points = p.calcPoints();
+        assertEquals(4, wayList.size());
+
+        assertEquals(34000, p.getDistance(), 1e-1);
+        assertEquals(34000, sumDistances(wayList), 1e-1);
+        assertEquals(5, points.size());
+        assertEquals(1604120, p.getTime());
+
+        assertEquals(Instruction.CONTINUE_ON_STREET, wayList.get(0).getSign());
+        assertEquals(15, wayList.get(0).getPoints().getLatitude(0), 1e-3);
+        assertEquals(10, wayList.get(0).getPoints().getLongitude(0), 1e-3);
+
+        assertEquals(Instruction.TURN_LEFT, wayList.get(1).getSign());
+        assertEquals(15.1, wayList.get(1).getPoints().getLatitude(0), 1e-3);
+        assertEquals(10, wayList.get(1).getPoints().getLongitude(0), 1e-3);
+
+        assertEquals(Instruction.TURN_RIGHT, wayList.get(2).getSign());
+        assertEquals(15.1, wayList.get(2).getPoints().getLatitude(0), 1e-3);
+        assertEquals(9.9, wayList.get(2).getPoints().getLongitude(0), 1e-3);
+
+        String gpxStr = GpxFromInstructions.createGPX(wayList, "test", (long) 0, false, true, true, true, Constants.VERSION, trMap.getWithFallBack(Locale.US));
+        verifyGPX(gpxStr);
+        System.out.println(gpxStr);
+
+        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T00:00:00Z</time>"));
+        assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
+        assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
+        assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
+
+        assertFalse(gpxStr, gpxStr.contains("NaN"));
+    }
+
+    @Test
+    public void testCreateGPX() {
+        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
+        InstructionList instructions = new InstructionList(trMap.getWithFallBack(Locale.US));
+        PointList pl = new PointList();
+        pl.add(49.942576, 11.580384);
+        pl.add(49.941858, 11.582422);
+        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
+
+        pl = new PointList();
+        pl.add(49.941575, 11.583501);
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
+
+        pl = new PointList();
+        pl.add(49.941389, 11.584311);
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
+        instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
+
+        List<GPXEntry> result = GpxFromInstructions.createGPXList(instructions);
+        assertEquals(5, result.size());
+
+        assertEquals(0, result.get(0).getTime().longValue());
+        assertNull(result.get(1).getTime());
+        assertEquals(15000, result.get(2).getTime().longValue());
+        assertEquals(19000, result.get(3).getTime().longValue());
+        assertEquals(22000, result.get(4).getTime().longValue());
+
+        verifyGPX(GpxFromInstructions.createGPX(instructions, "GraphHopper", new Date().getTime(), false, true, true, true, Constants.VERSION, trMap.getWithFallBack(Locale.US)));
+    }
+
+    @Test
+    public void testCreateGPXIncludesRoundaboutExitNumber() {
+        InstructionList instructions = new InstructionList(trMap.getWithFallBack(Locale.US));
+
+        PointList pl = new PointList();
+        pl.add(52.555423473315, 13.43890086052345);
+        pl.add(52.555550691982, 13.43946393816465);
+        pl.add(52.555619423589, 13.43886994061328);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                InstructionAnnotation.EMPTY, pl)
+                .setRadian(2.058006514284998d)
+                .setExitNumber(3)
+                .setExited();
+        instructions.add(instr);
+        instructions.add(new FinishInstruction(52.555619423589, 13.43886994061328, 0));
+
+        String gpxStr = GpxFromInstructions.createGPX(instructions, "test", 0, true, true, false, false, Constants.VERSION, trMap.getWithFallBack(Locale.US));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:exit_number>3</gh:exit_number>"));
+        verifyGPX(gpxStr);
+    }
+
+    @Test
+    public void testCreateGPXCorrectFormattingSmallNumbers() {
+        InstructionList instructions = new InstructionList(trMap.getWithFallBack(Locale.US));
+
+        PointList pl = new PointList();
+        pl.add(0.000001, 0.000001);
+        pl.add(-0.000123, -0.000125);
+        Instruction instruction = new Instruction(0, "do it", null, pl);
+        instructions.add(instruction);
+        instructions.add(new FinishInstruction(0.000852, 0.000852, 0));
+
+        String gpxStr = GpxFromInstructions.createGPX(instructions, "test", 0, true, true, true, true, Constants.VERSION, trMap.getWithFallBack(Locale.US));
+
+        assertFalse(gpxStr, gpxStr.contains("E-"));
+        assertTrue(gpxStr, gpxStr.contains("0.000001"));
+        assertTrue(gpxStr, gpxStr.contains("-0.000125"));
+        verifyGPX(gpxStr);
+    }
+
+    @Test
+    public void testXMLEscape_issue572() {
+        assertEquals("_", GpxFromInstructions.simpleXMLEscape("<"));
+        assertEquals("_blup_", GpxFromInstructions.simpleXMLEscape("<blup>"));
+        assertEquals("a&amp;b", GpxFromInstructions.simpleXMLEscape("a&b"));
+    }
+
+    private IntsRef flagsForSpeed(EncodingManager encodingManager, int speedKmPerHour) {
+        ReaderWay way = new ReaderWay(1);
+        way.setTag("highway", "motorway");
+        way.setTag("maxspeed", String.format("%d km/h", speedKmPerHour));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        encodingManager.acceptWay(way, map);
+        return encodingManager.handleWayTags(way, map, 0);
+    }
+
+    private void verifyGPX(String gpx) {
+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+        Schema schema = null;
+        try {
+            Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
+            schema = schemaFactory.newSchema(schemaFile);
+
+            // using more schemas: http://stackoverflow.com/q/1094893/194609
+        } catch (SAXException e1) {
+            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
+        }
+        Validator validator = schema.newValidator();
+        try {
+            validator.validate(new StreamSource(new StringReader(gpx)));
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private double sumDistances(InstructionList il) {
+        double val = 0;
+        for (Instruction i : il) {
+            val += i.getDistance();
+        }
+        return val;
+    }
+
+}
diff --git a/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd b/web-bundle/src/test/resources/com/graphhopper/util/gpx/gpx-schema.xsd
similarity index 100%
rename from core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
rename to web-bundle/src/test/resources/com/graphhopper/util/gpx/gpx-schema.xsd
diff --git a/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java b/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java
new file mode 100644
index 0000000000..3cfa30059d
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java
@@ -0,0 +1,39 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+import com.graphhopper.http.api.JsonErrorEntity;
+import io.dropwizard.jersey.validation.ConstraintMessage;
+import io.dropwizard.jersey.validation.JerseyViolationException;
+
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import java.util.stream.Collectors;
+
+public class GHJerseyViolationExceptionMapper implements ExceptionMapper<JerseyViolationException> {
+    @Override
+    public Response toResponse(final JerseyViolationException e) {
+        return Response
+                .status(ConstraintMessage.determineStatus(e.getConstraintViolations(), e.getInvocable()))
+                .type(MediaType.APPLICATION_JSON)
+                .entity(new JsonErrorEntity(e.getConstraintViolations().stream().map(v -> new IllegalArgumentException(v.getMessage())).collect(Collectors.toList())))
+                .build();
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
index 601643b45d..b98b46a7a1 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
@@ -17,12 +17,15 @@
  */
 package com.graphhopper.http;
 
+import com.graphhopper.gtfs.dropwizard.RealtimeBundle;
 import com.graphhopper.http.cli.ImportCommand;
 import com.graphhopper.http.resources.RootResource;
 import io.dropwizard.Application;
 import io.dropwizard.bundles.assets.ConfiguredAssetsBundle;
+import io.dropwizard.client.HttpClientBuilder;
 import io.dropwizard.setup.Bootstrap;
 import io.dropwizard.setup.Environment;
+import org.apache.http.client.HttpClient;
 
 import javax.servlet.DispatcherType;
 import java.util.EnumSet;
@@ -36,12 +39,14 @@ public static void main(String[] args) throws Exception {
     @Override
     public void initialize(Bootstrap<GraphHopperServerConfiguration> bootstrap) {
         bootstrap.addBundle(new GraphHopperBundle());
+        bootstrap.addBundle(new RealtimeBundle());
         bootstrap.addBundle(new ConfiguredAssetsBundle("/assets/", "/maps/", "index.html"));
-        bootstrap.addCommand(new ImportCommand(bootstrap.getObjectMapper()));
+        bootstrap.addCommand(new ImportCommand());
     }
 
     @Override
-    public void run(GraphHopperServerConfiguration configuration, Environment environment) {
+    public void run(GraphHopperServerConfiguration configuration, Environment environment) throws Exception {
+        environment.jersey().register(new GHJerseyViolationExceptionMapper());
         environment.jersey().register(new RootResource());
         environment.servlets().addFilter("cors", CORSFilter.class).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
         environment.servlets().addFilter("ipfilter", new IPFilter(configuration.getGraphHopperConfiguration().get("jetty.whiteips", ""), configuration.getGraphHopperConfiguration().get("jetty.blackips", ""))).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java b/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java
index c786a4d37d..b09ab29897 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java
@@ -19,6 +19,9 @@
 package com.graphhopper.http;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
+import com.graphhopper.gtfs.dropwizard.RealtimeBundleConfiguration;
+import com.graphhopper.gtfs.dropwizard.FeedConfiguration;
+import com.graphhopper.gtfs.dropwizard.RealtimeConfiguration;
 import com.graphhopper.util.CmdArgs;
 import io.dropwizard.Configuration;
 import io.dropwizard.bundles.assets.AssetsBundleConfiguration;
@@ -26,8 +29,10 @@
 
 import javax.validation.Valid;
 import javax.validation.constraints.NotNull;
+import java.util.ArrayList;
+import java.util.List;
 
-public class GraphHopperServerConfiguration extends Configuration implements GraphHopperBundleConfiguration, AssetsBundleConfiguration {
+public class GraphHopperServerConfiguration extends Configuration implements GraphHopperBundleConfiguration, RealtimeBundleConfiguration, AssetsBundleConfiguration {
 
     @NotNull
     @JsonProperty
@@ -37,6 +42,9 @@
     @JsonProperty
     private final AssetsConfiguration assets = AssetsConfiguration.builder().build();
 
+    @JsonProperty
+    private final RealtimeConfiguration gtfsRealtime = new RealtimeConfiguration();
+
     public GraphHopperServerConfiguration() {
     }
 
@@ -49,4 +57,9 @@ public CmdArgs getGraphHopperConfiguration() {
     public AssetsConfiguration getAssetsConfiguration() {
         return assets;
     }
+
+    @Override
+    public RealtimeConfiguration gtfsrealtime() {
+        return gtfsRealtime;
+    }
 }
diff --git a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
index 8ce4b6e8c2..c2ec7c75f2 100644
--- a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
+++ b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
@@ -18,27 +18,47 @@
 
 package com.graphhopper.http.cli;
 
-import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.http.GraphHopperManaged;
 import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.reader.gtfs.GraphHopperGtfs;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.storage.GraphHopperStorage;
 import io.dropwizard.cli.ConfiguredCommand;
 import io.dropwizard.setup.Bootstrap;
 import net.sourceforge.argparse4j.inf.Namespace;
 
-public class ImportCommand extends ConfiguredCommand<GraphHopperServerConfiguration> {
+import java.util.Arrays;
+import java.util.Collections;
 
-    private final ObjectMapper objectMapper;
+public class ImportCommand extends ConfiguredCommand<GraphHopperServerConfiguration> {
 
-    public ImportCommand(ObjectMapper objectMapper) {
+    public ImportCommand() {
         super("import", "creates the graphhopper files used for later (faster) starts");
-        this.objectMapper = objectMapper;
     }
 
     @Override
-    protected void run(Bootstrap<GraphHopperServerConfiguration> bootstrap, Namespace namespace, GraphHopperServerConfiguration configuration) {
-        final GraphHopperManaged graphHopper = new GraphHopperManaged(configuration.getGraphHopperConfiguration(), objectMapper);
-        graphHopper.start();
-        graphHopper.stop();
+    protected void run(Bootstrap<GraphHopperServerConfiguration> bootstrap, Namespace namespace, GraphHopperServerConfiguration configuration) throws Exception {
+        if (configuration.getGraphHopperConfiguration().has("gtfs.file")) {
+            final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
+            final GHDirectory ghDirectory = GraphHopperGtfs.createGHDirectory(configuration.getGraphHopperConfiguration().get("graph.location", "target/tmp"));
+            final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
+            final EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder(), new CarFlagEncoder()), 12);
+            final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
+                    configuration.getGraphHopperConfiguration().has("gtfs.file") ? Arrays.asList(configuration.getGraphHopperConfiguration().get("gtfs.file", "").split(",")) : Collections.emptyList(),
+                    configuration.getGraphHopperConfiguration().has("datareader.file") ? Arrays.asList(configuration.getGraphHopperConfiguration().get("datareader.file", "").split(",")) : Collections.emptyList());
+            graphHopperStorage.close();
+        } else {
+            final GraphHopperManaged graphHopper = new GraphHopperManaged(configuration.getGraphHopperConfiguration(), bootstrap.getObjectMapper());
+            graphHopper.start();
+            graphHopper.stop();
+        }
+
     }
 
 }
diff --git a/web/src/test/java/com/graphhopper/http/resources/GpxTravelTimeConsistencyTest.java b/web/src/test/java/com/graphhopper/http/resources/GpxTravelTimeConsistencyTest.java
new file mode 100644
index 0000000000..8a05ff25b3
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/resources/GpxTravelTimeConsistencyTest.java
@@ -0,0 +1,78 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http.resources;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.util.gpx.GPXEntry;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.gpx.GpxFromInstructions;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public class GpxTravelTimeConsistencyTest {
+
+    public static final String DIR = "../core/files";
+    private static final String graphFileFoot = "target/gpxtraveltimeconsistency-it";
+    private static final String osmFile = DIR + "/monaco.osm.gz";
+    private static final String importVehicles = "foot";
+    private static GraphHopper hopper;
+
+    @BeforeClass
+    public static void beforeClass() {
+        Helper.removeDir(new File(graphFileFoot));
+        hopper = new GraphHopperOSM().
+                setOSMFile(osmFile).
+                setStoreOnFlush(true).
+                setCHEnabled(false).
+                setGraphHopperLocation(graphFileFoot).
+                setEncodingManager(EncodingManager.create(importVehicles)).
+                importOrLoad();
+    }
+
+    @Test
+    public void testGPXListTravelTimeConsistency() {
+        GHPoint routeStart = new GHPoint(43.727687, 7.418737);
+        GHPoint routeEnd = new GHPoint(43.74958, 7.436566);
+        GHRequest request = new GHRequest(routeStart, routeEnd);
+        request.setWeighting("fastest");
+        request.setVehicle("foot");
+        PathWrapper path = hopper.route(request).getBest();
+        List<GPXEntry> gpxList = GpxFromInstructions.createGPXList(path.getInstructions());
+        for(GPXEntry entry : gpxList) {
+            if (entry.getTime() != null ) {
+                GHRequest requestForWaypoint = new GHRequest(routeStart, entry.getPoint());
+                requestForWaypoint.setWeighting("fastest");
+                requestForWaypoint.setVehicle("foot");
+                PathWrapper partialPath = hopper.route(requestForWaypoint).getBest();
+                assertEquals("GPXListEntry timeStamp is expected to be the same as route duration.", partialPath.getTime(), entry.getTime().longValue());
+            }
+        }
+    }
+
+}
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
index 72e831b3cf..cd5ba49053 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
@@ -27,6 +27,7 @@
 import com.graphhopper.http.GraphHopperServerConfiguration;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.exceptions.PointOutOfBoundsException;
 import com.graphhopper.util.shapes.GHPoint;
@@ -159,12 +160,12 @@ public void testGraphHopperWeb() throws Exception {
         assertTrue("distance wasn't correct:" + arsp.getDistance(), arsp.getDistance() > 20000);
         assertTrue("distance wasn't correct:" + arsp.getDistance(), arsp.getDistance() < 21000);
 
-        List<Map<String, Object>> instructions = arsp.getInstructions().createJson();
+        InstructionList instructions = arsp.getInstructions();
         assertEquals(26, instructions.size());
-        assertEquals("Continue onto la Callisa", instructions.get(0).get("text"));
-        assertEquals("At roundabout, take exit 2", instructions.get(4).get("text"));
-        assertEquals(true, instructions.get(4).get("exited"));
-        assertEquals(false, instructions.get(24).get("exited"));
+        assertEquals("Continue onto la Callisa", instructions.get(0).getTurnDescription(null));
+        assertEquals("At roundabout, take exit 2", instructions.get(4).getTurnDescription(null));
+        assertEquals(true, instructions.get(4).getExtraInfoJSON().get("exited"));
+        assertEquals(false, instructions.get(24).getExtraInfoJSON().get("exited"));
     }
 
     @Test
