diff --git a/core/src/main/java/com/graphhopper/Trip.java b/core/src/main/java/com/graphhopper/Trip.java
index 4ed6b675e7..bc891342aa 100644
--- a/core/src/main/java/com/graphhopper/Trip.java
+++ b/core/src/main/java/com/graphhopper/Trip.java
@@ -12,25 +12,24 @@
     public static abstract class Leg {
         public final String type;
         public final String departureLocation;
-        public final Date departureTime;
         public final List<EdgeIteratorState> edges;
         public final Geometry geometry;
         public final double distance;
-        public final Date arrivalTime;
 
-        public Leg(String type, String departureLocation, Date departureTime, List<EdgeIteratorState> edges, Geometry geometry, double distance, Date arrivalTime) {
+        public Leg(String type, String departureLocation, List<EdgeIteratorState> edges, Geometry geometry, double distance) {
             this.type = type;
             this.departureLocation = departureLocation;
             this.edges = edges;
             this.geometry = geometry;
             this.distance = distance;
-            this.departureTime = departureTime;
-            this.arrivalTime = arrivalTime;
         }
 
         public double getDistance() {
             return distance;
         }
+
+        public abstract Date getDepartureTime();
+        public abstract Date getArrivalTime();
     }
 
     public static class Stop {
@@ -48,14 +47,38 @@ public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date
             this.arrivalTime = arrivalTime;
             this.departureTime = departureTime;
         }
+
+        @Override
+        public String toString() {
+            return "Stop{" +
+                    "stop_id='" + stop_id + '\'' +
+                    ", arrivalTime=" + arrivalTime +
+                    ", departureTime=" + departureTime +
+                    '}';
+        }
     }
     public static class WalkLeg extends Leg {
         public final InstructionList instructions;
+        private final Date departureTime;
+        private final Date arrivalTime;
 
         public WalkLeg(String departureLocation, Date departureTime, List<EdgeIteratorState> edges, Geometry geometry, double distance, InstructionList instructions, Date arrivalTime) {
-            super("walk", departureLocation, departureTime, edges, geometry, distance, arrivalTime);
+            super("walk", departureLocation, edges, geometry, distance);
             this.instructions = instructions;
+            this.departureTime = departureTime;
+            this.arrivalTime = arrivalTime;
         }
+
+        @Override
+        public Date getDepartureTime() {
+            return departureTime;
+        }
+
+        @Override
+        public Date getArrivalTime() {
+            return arrivalTime;
+        }
+
     }
     public static class PtLeg extends Leg {
         public final String feed_id;
@@ -66,8 +89,8 @@ public WalkLeg(String departureLocation, Date departureTime, List<EdgeIteratorSt
         public final String trip_id;
         public final String route_id;
 
-        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, String routeId, List<EdgeIteratorState> edges, Date departureTime, List<Stop> stops, double distance, long travelTime, Date arrivalTime, Geometry geometry) {
-            super("pt", stops.get(0).stop_name, departureTime, edges, geometry, distance, arrivalTime);
+        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, String routeId, List<EdgeIteratorState> edges, List<Stop> stops, double distance, long travelTime, Geometry geometry) {
+            super("pt", stops.get(0).stop_name, edges, geometry, distance);
             this.feed_id = feedId;
             this.isInSameVehicleAsPrevious = isInSameVehicleAsPrevious;
             this.trip_id = tripId;
@@ -77,6 +100,15 @@ public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, St
             this.stops = stops;
         }
 
+        @Override
+        public Date getDepartureTime() {
+            return stops.get(0).departureTime;
+        }
+
+        @Override
+        public Date getArrivalTime() {
+            return stops.get(stops.size()-1).arrivalTime;
+        }
     }
 
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index ec80420efc..501111d674 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -280,7 +280,7 @@ public GraphHopperGtfs(PtFlagEncoder flagEncoder, TranslationMap translationMap,
         this.locationIndex = locationIndex;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
-        this.tripFromLabel = new TripFromLabel(this.gtfsStorage);
+        this.tripFromLabel = new TripFromLabel(this.gtfsStorage, this.realtimeFeed);
     }
 
     public static GtfsStorage createGtfsStorage() {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 6eef12943f..570731ae4e 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -20,7 +20,13 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.conveyal.gtfs.GTFSFeed;
-import com.conveyal.gtfs.model.*;
+import com.conveyal.gtfs.model.Frequency;
+import com.conveyal.gtfs.model.Route;
+import com.conveyal.gtfs.model.Service;
+import com.conveyal.gtfs.model.Stop;
+import com.conveyal.gtfs.model.StopTime;
+import com.conveyal.gtfs.model.Transfer;
+import com.conveyal.gtfs.model.Trip;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.SetMultimap;
 import com.google.transit.realtime.GtfsRealtime;
@@ -39,9 +45,20 @@
 
 import java.time.LocalDate;
 import java.time.ZoneId;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.NavigableSet;
+import java.util.Optional;
+import java.util.SortedSet;
+import java.util.TreeSet;
 import java.util.stream.Collectors;
 
+import static com.conveyal.gtfs.model.Entity.Writer.convertToGtfsTime;
 import static java.time.temporal.ChronoUnit.DAYS;
 
 class GtfsReader {
@@ -50,14 +67,14 @@
     private LocalDate endDate;
 
     static class TripWithStopTimes {
-        public TripWithStopTimes(Trip trip, Iterable<StopTime> stopTimes, BitSet validOnDay) {
+        public TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay) {
             this.trip = trip;
             this.stopTimes = stopTimes;
             this.validOnDay = validOnDay;
         }
 
         Trip trip;
-        Iterable<StopTime> stopTimes;
+        List<StopTime> stopTimes;
         BitSet validOnDay;
     }
 
@@ -184,7 +201,9 @@ private void buildPtNetwork() {
                                 validOnDay.set((int) DAYS.between(startDate, date));
                             }
                         }
-                        return new TripWithStopTimes(trip, getInterpolatedStopTimesForTrip(trip.trip_id), validOnDay);
+                        ArrayList<StopTime> stopTimes = new ArrayList<>();
+                        getInterpolatedStopTimesForTrip(trip.trip_id).forEach(stopTimes::add);
+                        return new TripWithStopTimes(trip, stopTimes, validOnDay);
                     })
                     .sorted(Comparator.comparingInt(trip -> trip.stopTimes.iterator().next().departure_time))
                     .collect(Collectors.toList());
@@ -249,6 +268,10 @@ void wireUpStops() {
     void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
         List<Integer> arrivalNodes = new ArrayList<>();
         for (TripWithStopTimes trip : trips) {
+            GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder()
+                    .setTripId(trip.trip.trip_id)
+                    .setStartTime(convertToGtfsTime(time)).build();
+
             IntArrayList boardEdges = new IntArrayList();
             IntArrayList alightEdges = new IntArrayList();
             StopTime prev = null;
@@ -310,7 +333,7 @@ void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
                 setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
                 boardEdges.add(boardEdge.getEdge());
                 gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getExtraStrings().put(boardEdge.getEdge(), trip.trip.trip_id);
+                gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
                 boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
                 boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
 
@@ -323,7 +346,7 @@ void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
                 setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
                 alightEdges.add(alightEdge.getEdge());
                 gtfsStorage.getStopSequences().put(alightEdge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getExtraStrings().put(alightEdge.getEdge(), trip.trip.trip_id);
+                gtfsStorage.getTripDescriptors().put(alightEdge.getEdge(), tripDescriptor.toByteArray());
                 alightEdge.setFlags(encoder.setValidityId(alightEdge.getFlags(), validityId));
 //                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
 
@@ -337,11 +360,10 @@ void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
                 setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
                 dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
                 if (prev == null) {
-                    insertInboundBlockTransfers(arrivalNodes, trip.trip, departureNode, stopTime, stop, validityId);
+                    insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime, stop, validityId);
                 }
                 prev = stopTime;
             }
-            final GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder().setTripId(trip.trip.trip_id).setStartTime(Entity.Writer.convertToGtfsTime(time)).build();
             gtfsStorage.getBoardEdgesForTrip().put(tripDescriptor, boardEdges.toArray());
             gtfsStorage.getAlightEdgesForTrip().put(tripDescriptor, alightEdges.toArray());
             arrivalNodes.add(arrivalNode);
@@ -415,7 +437,7 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
         });
     }
 
-    private void insertInboundBlockTransfers(List<Integer> arrivalNodes, Trip trip, int departureNode, StopTime stopTime, Stop stop, int validityId) {
+    private void insertInboundBlockTransfers(List<Integer> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, StopTime stopTime, Stop stop, int validityId) {
         EdgeIteratorState edge;
         for (int lastTripArrivalNode : arrivalNodes) {
             int dwellTime = times.get(departureNode) - times.get(lastTripArrivalNode);
@@ -439,7 +461,7 @@ private void insertInboundBlockTransfers(List<Integer> arrivalNodes, Trip trip,
                 setEdgeType(edge, GtfsStorage.EdgeType.BOARD);
                 edge.setFlags(encoder.setValidityId(edge.getFlags(), validityId));
                 gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
-                gtfsStorage.getExtraStrings().put(edge.getEdge(), trip.trip_id);
+                gtfsStorage.getTripDescriptors().put(edge.getEdge(), tripDescriptor.toByteArray());
             }
         }
     }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
index 916af7c6cb..7b4ab0ee1c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
@@ -93,7 +93,7 @@ public int hashCode() {
 	private Map<Integer, Validity> validities;
 	private Bind.MapWithModificationListener<FeedIdWithTimezone, Integer> timeZones;
 	private Map<Integer, FeedIdWithTimezone> readableTimeZones;
-	private Map<Integer, String> extra;
+	private Map<Integer, byte[]> tripDescriptors;
 	private Map<Integer, Integer> stopSequences;
 	private Map<String, Fare> fares;
 	private Map<GtfsRealtime.TripDescriptor, int[]> boardEdgesForTrip;
@@ -186,7 +186,7 @@ private void init() {
 		Bind.mapInverse(this.timeZones, readableTimeZones);
 		this.readableTimeZones = Collections.unmodifiableMap(readableTimeZones);
 		this.validities = Collections.unmodifiableMap(reverseOperatingDayPatterns);
-		this.extra = data.getTreeMap("extra");
+		this.tripDescriptors = data.getTreeMap("tripDescriptors");
 		this.stopSequences = data.getTreeMap("stopSequences");
 		this.fares = data.getTreeMap("fares");
 		this.boardEdgesForTrip = data.getHashMap("boardEdgesForTrip");
@@ -259,8 +259,8 @@ public long getCapacity() {
 		return timeZones;
 	}
 
-	Map<Integer, String> getExtraStrings() {
-		return extra;
+	Map<Integer, byte[]> getTripDescriptors() {
+		return tripDescriptors;
 	}
 
 	Map<Integer, Integer> getStopSequences() {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index d308b2b238..a68cd1d6ac 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -35,8 +35,15 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
-
-import java.time.*;
+import org.mapdb.Fun;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.time.Duration;
+import java.time.Instant;
+import java.time.LocalDate;
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
 import java.time.temporal.ChronoUnit;
 import java.util.ArrayList;
 import java.util.BitSet;
@@ -44,22 +51,30 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
 
+import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.NO_DATA;
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
 import static java.time.temporal.ChronoUnit.DAYS;
 
 public class RealtimeFeed {
+    private static final Logger logger = LoggerFactory.getLogger(RealtimeFeed.class);
     private final IntHashSet blockedEdges;
-
     private final List<VirtualEdgeIteratorState> additionalEdges;
-
-    private RealtimeFeed(IntHashSet blockedEdges, List<VirtualEdgeIteratorState> additionalEdges) {
+    private final GtfsRealtime.FeedMessage feedMessage;
+    private final GTFSFeed staticFeed;
+    private final Agency agency;
+
+    private RealtimeFeed(GTFSFeed feed, Agency agency, GtfsRealtime.FeedMessage feedMessage, IntHashSet blockedEdges, List<VirtualEdgeIteratorState> additionalEdges) {
+        this.staticFeed = feed;
+        this.agency = agency;
+        this.feedMessage = feedMessage;
         this.blockedEdges = blockedEdges;
         this.additionalEdges = additionalEdges;
     }
 
     public static RealtimeFeed empty() {
-        return new RealtimeFeed(new IntHashSet(), Collections.emptyList());
+        return new RealtimeFeed(null, null, null, new IntHashSet(), Collections.emptyList());
     }
 
     public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtFlagEncoder encoder, GtfsRealtime.FeedMessage feedMessage) {
@@ -257,7 +272,7 @@ public GraphExtension getExtension() {
                 .forEach(trip -> gtfsReader.addTrips(ZoneId.of(agency.agency_timezone), Collections.singletonList(trip), 0));
         gtfsReader.wireUpStops();
         gtfsReader.connectStopsToStationNodes();
-        return new RealtimeFeed(blockedEdges, additionalEdges);
+        return new RealtimeFeed(feed, agency, feedMessage, blockedEdges, additionalEdges);
     }
 
     boolean isBlocked(int edgeId) {
@@ -268,7 +283,99 @@ boolean isBlocked(int edgeId) {
         return additionalEdges;
     }
 
-    public Optional<GtfsRealtime.TripUpdate> getTripUpdate(GtfsRealtime.TripDescriptor tripDescriptor) {
-        return Optional.empty();
+    public Optional<GtfsReader.TripWithStopTimes> getTripUpdate(GtfsRealtime.TripDescriptor tripDescriptor) {
+        if (feedMessage == null) {
+            return Optional.empty();
+        } else {
+            return feedMessage.getEntityList().stream()
+                    .filter(e -> e.hasTripUpdate())
+                    .map(e -> e.getTripUpdate())
+                    .filter(tu -> tu.getTrip().equals(tripDescriptor))
+                    .map(tu -> toTripWithStopTimes(staticFeed, agency, tu))
+                    .findFirst();
+        }
+    }
+
+    public static GtfsReader.TripWithStopTimes toTripWithStopTimes(GTFSFeed feed, Agency agency, GtfsRealtime.TripUpdate tripUpdate) {
+        logger.trace("{}", tripUpdate.getTrip());
+        final List<StopTime> stopTimes = new ArrayList<>();
+        Trip originalTrip = feed.trips.get(tripUpdate.getTrip().getTripId());
+        Trip trip = new Trip();
+        if (originalTrip != null) {
+            trip.trip_id = originalTrip.trip_id;
+            trip.route_id = originalTrip.route_id;
+        } else {
+            trip.trip_id = tripUpdate.getTrip().getTripId();
+            trip.route_id = tripUpdate.getTrip().getRouteId();
+        }
+        int delay = 0;
+        int time = -1;
+        List<GtfsRealtime.TripUpdate.StopTimeUpdate> stopTimeUpdateListWithSentinel = new ArrayList<>(tripUpdate.getStopTimeUpdateList());
+        Iterable<StopTime> interpolatedStopTimesForTrip;
+        try {
+            interpolatedStopTimesForTrip = feed.getInterpolatedStopTimesForTrip(tripUpdate.getTrip().getTripId());
+        } catch (GTFSFeed.FirstAndLastStopsDoNotHaveTimes firstAndLastStopsDoNotHaveTimes) {
+            throw new RuntimeException(firstAndLastStopsDoNotHaveTimes);
+        }
+        int stopSequenceCeiling = Math.max(stopTimeUpdateListWithSentinel.isEmpty() ? 0 : stopTimeUpdateListWithSentinel.get(stopTimeUpdateListWithSentinel.size() - 1).getStopSequence(),
+                StreamSupport.stream(interpolatedStopTimesForTrip.spliterator(), false).mapToInt(stopTime -> stopTime.stop_sequence).max().orElse(0)
+        ) + 1;
+        stopTimeUpdateListWithSentinel.add(GtfsRealtime.TripUpdate.StopTimeUpdate.newBuilder().setStopSequence(stopSequenceCeiling).setScheduleRelationship(NO_DATA).build());
+        for (GtfsRealtime.TripUpdate.StopTimeUpdate stopTimeUpdate : stopTimeUpdateListWithSentinel) {
+            int nextStopSequence = stopTimes.isEmpty() ? 1 : stopTimes.get(stopTimes.size()-1).stop_sequence+1;
+            for (int i=nextStopSequence; i<stopTimeUpdate.getStopSequence(); i++) {
+                StopTime previousOriginalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), i));
+                if (previousOriginalStopTime == null) {
+                    continue; // This can and does happen. Stop sequence numbers can be left out.
+                }
+                StopTime updatedPreviousStopTime = previousOriginalStopTime.clone();
+                updatedPreviousStopTime.arrival_time = Math.max(previousOriginalStopTime.arrival_time + delay, time);
+                logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", i, previousOriginalStopTime.arrival_time, updatedPreviousStopTime.arrival_time);
+                time = updatedPreviousStopTime.arrival_time;
+                updatedPreviousStopTime.departure_time = Math.max(previousOriginalStopTime.departure_time + delay, time);
+                logger.trace("stop_sequence {} scheduled departure {} updated departure {}", i, previousOriginalStopTime.departure_time, updatedPreviousStopTime.departure_time);
+                time = updatedPreviousStopTime.departure_time;
+                stopTimes.add(updatedPreviousStopTime);
+            }
+
+            final StopTime originalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), stopTimeUpdate.getStopSequence()));
+            if (originalStopTime != null) {
+                StopTime updatedStopTime = originalStopTime.clone();
+                if (stopTimeUpdate.getScheduleRelationship() == NO_DATA) {
+                    delay = 0;
+                }
+                if (stopTimeUpdate.hasArrival()) {
+                    delay = stopTimeUpdate.getArrival().getDelay();
+                }
+                updatedStopTime.arrival_time = Math.max(originalStopTime.arrival_time + delay, time);
+                logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", stopTimeUpdate.getStopSequence(), originalStopTime.arrival_time, updatedStopTime.arrival_time);
+                time = updatedStopTime.arrival_time;
+                if (stopTimeUpdate.hasDeparture()) {
+                    delay = stopTimeUpdate.getDeparture().getDelay();
+                }
+                updatedStopTime.departure_time = Math.max(originalStopTime.departure_time + delay, time);
+                logger.trace("stop_sequence {} scheduled departure {} updated departure {}", stopTimeUpdate.getStopSequence(), originalStopTime.departure_time, updatedStopTime.departure_time);
+                time = updatedStopTime.departure_time;
+                stopTimes.add(updatedStopTime);
+            } else if (stopTimeUpdate.getScheduleRelationship() == NO_DATA) {
+            } else if (tripUpdate.getTrip().getScheduleRelationship() == GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED) {
+                final StopTime stopTime = new StopTime();
+                stopTime.stop_sequence = stopTimeUpdate.getStopSequence();
+                stopTime.stop_id = stopTimeUpdate.getStopId();
+                stopTime.trip_id = trip.trip_id;
+                final ZonedDateTime arrival_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
+                stopTime.arrival_time = (int) Duration.between(arrival_time.truncatedTo(ChronoUnit.DAYS), arrival_time).getSeconds();
+                final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
+                stopTime.departure_time = (int) Duration.between(departure_time.truncatedTo(ChronoUnit.DAYS), departure_time).getSeconds();
+                System.out.println(delay);
+                stopTimes.add(stopTime);
+            } else {
+                throw new RuntimeException();
+            }
+        }
+        BitSet validOnDay = new BitSet(); // Not valid on any day. Just a template.
+        return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
     }
+
+
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 0afaaa4666..9afc2f8030 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -21,6 +21,8 @@
 import com.conveyal.gtfs.GTFSFeed;
 import com.conveyal.gtfs.model.Stop;
 import com.conveyal.gtfs.model.StopTime;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.PathWrapper;
 import com.graphhopper.Trip;
 import com.graphhopper.gtfs.fare.Fares;
@@ -31,6 +33,8 @@
 import com.vividsolutions.jts.geom.Geometry;
 import com.vividsolutions.jts.geom.GeometryFactory;
 import org.mapdb.Fun;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.time.Duration;
 import java.time.Instant;
@@ -40,9 +44,21 @@
 import java.util.stream.Stream;
 
 import static com.graphhopper.reader.gtfs.Label.reverseEdges;
+import static java.time.temporal.ChronoUnit.SECONDS;
 
 class TripFromLabel {
 
+    private static final Logger logger = LoggerFactory.getLogger(TripFromLabel.class);
+
+    private final GtfsStorage gtfsStorage;
+    private final RealtimeFeed realtimeFeed;
+    private final GeometryFactory geometryFactory = new GeometryFactory();
+
+    TripFromLabel(GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed) {
+        this.gtfsStorage = gtfsStorage;
+        this.realtimeFeed = realtimeFeed;
+    }
+
     PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
         final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
         return createPathWrapper(tr, waypoints, legs);
@@ -51,11 +67,11 @@ PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Trans
     PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg> legs) {
         if (legs.size() > 1 && legs.get(0) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg accessLeg = (Trip.WalkLeg) legs.get(0);
-            legs.set(0, new Trip.WalkLeg(accessLeg.departureLocation, new Date(legs.get(1).departureTime.getTime() - (accessLeg.arrivalTime.getTime() - accessLeg.departureTime.getTime())), accessLeg.edges, accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).departureTime));
+            legs.set(0, new Trip.WalkLeg(accessLeg.departureLocation, new Date(legs.get(1).getDepartureTime().getTime() - (accessLeg.getArrivalTime().getTime() - accessLeg.getDepartureTime().getTime())), accessLeg.edges, accessLeg.geometry, accessLeg.distance, accessLeg.instructions, legs.get(1).getDepartureTime()));
         }
         if (legs.size() > 1 && legs.get(legs.size()-1) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg egressLeg = (Trip.WalkLeg) legs.get(legs.size()-1);
-            legs.set(legs.size()-1, new Trip.WalkLeg(egressLeg.departureLocation, legs.get(legs.size()-2).arrivalTime, egressLeg.edges, egressLeg.geometry, egressLeg.distance, egressLeg.instructions, new Date(legs.get(legs.size()-2).arrivalTime.getTime() + (egressLeg.arrivalTime.getTime() - egressLeg.departureTime.getTime()))));
+            legs.set(legs.size()-1, new Trip.WalkLeg(egressLeg.departureLocation, legs.get(legs.size() - 2).getArrivalTime(), egressLeg.edges, egressLeg.geometry, egressLeg.distance, egressLeg.instructions, new Date(legs.get(legs.size() - 2).getArrivalTime().getTime() + (egressLeg.getArrivalTime().getTime() - egressLeg.getDepartureTime().getTime()))));
         }
 
         PathWrapper path = new PathWrapper();
@@ -71,7 +87,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         }
         path.setPoints(pointsList);
         path.setDistance(path.getLegs().stream().mapToDouble(Trip.Leg::getDistance).sum());
-        path.setTime((legs.get(legs.size()-1).arrivalTime.toInstant().toEpochMilli() - legs.get(0).departureTime.toInstant().toEpochMilli()));
+        path.setTime((legs.get(legs.size() - 1).getArrivalTime().toInstant().toEpochMilli() - legs.get(0).getDepartureTime().toInstant().toEpochMilli()));
         path.setNumChanges((int) path.getLegs().stream()
                 .filter(l -> l instanceof Trip.PtLeg)
                 .filter(l -> !((Trip.PtLeg) l).isInSameVehicleAsPrevious)
@@ -82,13 +98,13 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
                 .map(leg -> (Trip.PtLeg) leg)
                 .findFirst()
                 .ifPresent(firstPtLeg -> {
-                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.departureTime);
+                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.getDepartureTime());
                     path.getLegs().stream()
                             .filter(leg -> leg instanceof Trip.PtLeg)
                             .map(leg -> (Trip.PtLeg) leg)
                             .map(ptLeg -> {
                                 final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(ptLeg.feed_id);
-                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.trip_id).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.departureTime)).getSeconds(), gtfsFeed.stops.get(ptLeg.stops.get(0).stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
+                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.trip_id).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.getDepartureTime())).getSeconds(), gtfsFeed.stops.get(ptLeg.stops.get(0).stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
                             })
                             .forEach(faresTrip.segments::add);
                     Fares.cheapestFare(gtfsStorage.getFares(), faresTrip)
@@ -175,59 +191,81 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
 
     private class StopsFromBoardHopDwellEdges {
 
-        private final String tripId;
+        private final GtfsRealtime.TripDescriptor tripDescriptor;
         private final List<Trip.Stop> stops = new ArrayList<>();
         private final GTFSFeed gtfsFeed;
-        private long arrivalTimeFromHopEdge;
-        private Stop stop = null;
+        private Instant arrivalTimeFromHopEdge;
+        private Instant updatedArrival;
+        private StopTime stopTime = null;
+        private final GtfsReader.TripWithStopTimes tripUpdate;
 
-        StopsFromBoardHopDwellEdges(String feedId, String tripId) {
-            this.tripId = tripId;
+        StopsFromBoardHopDwellEdges(String feedId, GtfsRealtime.TripDescriptor tripDescriptor) {
+            this.tripDescriptor = tripDescriptor;
             this.gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedId);
+            this.tripUpdate = realtimeFeed.getTripUpdate(tripDescriptor).orElse(null);
         }
 
         void next(Label.Transition t) {
-            long departureTime;
             switch (t.edge.edgeType) {
-                case BOARD:
-                    stop = findStop(t);
-                    departureTime = t.label.currentTime;
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, Date.from(Instant.ofEpochMilli(departureTime))));
+                case BOARD: {
+                    int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
+                    stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
+                    Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
+                    Instant updatedDeparture = plannedDeparture.plus(getDepartureDelay(stopSequence), SECONDS);
+                    Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, Date.from(updatedDeparture)));
                     break;
-                case HOP:
-                    stop = findStop(t);
-                    arrivalTimeFromHopEdge = t.label.currentTime;
+                }
+                case HOP: {
+                    int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
+                    stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
+                    arrivalTimeFromHopEdge = Instant.ofEpochMilli(t.label.currentTime);
+                    updatedArrival = arrivalTimeFromHopEdge.plus(getArrivalDelay(stopSequence), SECONDS);
                     break;
-                case DWELL:
-                    departureTime = t.label.currentTime;
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), Date.from(Instant.ofEpochMilli(departureTime))));
+                }
+                case DWELL: {
+                    Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
+                    Instant updatedDeparture = plannedDeparture.plus(getDepartureDelay(stopTime.stop_sequence), SECONDS);
+                    Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(updatedArrival), Date.from(updatedDeparture)));
                     break;
-                default:
+                }
+                default: {
                     throw new RuntimeException();
+                }
+            }
+        }
+
+        private long getArrivalDelay(int stopSequence) {
+            if (tripUpdate != null) {
+                int arrival_time = tripUpdate.stopTimes.get(stopSequence - 1).arrival_time;
+                logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", stopSequence, stopTime.arrival_time, arrival_time);
+                return arrival_time - stopTime.arrival_time;
+            } else {
+                return 0;
             }
         }
 
-        private Stop findStop(Label.Transition t) {
-            int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
-            StopTime stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripId, stopSequence));
-            return gtfsFeed.stops.get(stopTime.stop_id);
+        private int getDepartureDelay(int stopSequence) {
+            if (tripUpdate != null) {
+                int departure_time = tripUpdate.stopTimes.get(stopSequence - 1).departure_time;
+                logger.trace("stop_sequence {} scheduled departure {} updated departure {}", stopSequence, stopTime.departure_time, departure_time);
+                return departure_time - stopTime.departure_time;
+            } else {
+                return 0;
+            }
         }
 
         void finish() {
-            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), null));
+            Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
+            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(updatedArrival), null));
+            for (Trip.Stop tripStop : stops) {
+                logger.trace("{}", tripStop);
+            }
         }
 
     }
 
-
-    private final GtfsStorage gtfsStorage;
-    private final GeometryFactory geometryFactory = new GeometryFactory();
-
-    TripFromLabel(GtfsStorage gtfsStorage) {
-
-        this.gtfsStorage = gtfsStorage;
-    }
-
     // We are parsing a string of edges into a hierarchical trip.
     // One could argue that one should never write a parser
     // by hand, because it is always ugly, but use a parser library.
@@ -254,25 +292,28 @@ void finish() {
                 }
                 if (EnumSet.of(GtfsStorage.EdgeType.TRANSFER, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK).contains(edge.edgeType)) {
                     Geometry lineString = lineStringFromEdges(partition);
-                    String tripId = gtfsStorage.getExtraStrings().get(partition.get(0).edge.edgeIteratorState.getEdge());
-                    final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripId);
+                    GtfsRealtime.TripDescriptor tripDescriptor;
+                    try {
+                        tripDescriptor = GtfsRealtime.TripDescriptor.parseFrom(gtfsStorage.getTripDescriptors().get(partition.get(0).edge.edgeIteratorState.getEdge()));
+                    } catch (InvalidProtocolBufferException e) {
+                        throw new RuntimeException(e);
+                    }
+                    final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripDescriptor);
                     partition.stream()
                             .filter(e -> EnumSet.of(GtfsStorage.EdgeType.HOP, GtfsStorage.EdgeType.BOARD, GtfsStorage.EdgeType.DWELL).contains(e.edge.edgeType))
                             .forEach(stopsFromBoardHopDwellEdges::next);
                     stopsFromBoardHopDwellEdges.finish();
                     List<Trip.Stop> stops = stopsFromBoardHopDwellEdges.stops;
 
-                    com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripId);
+                    com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripDescriptor.getTripId());
                     result.add(new Trip.PtLeg(
                             feedIdWithTimezone.feedId,partition.get(0).edge.nTransfers == 0,
-                            tripId,
+                            tripDescriptor.getTripId(),
                             trip.route_id,
                             edges(partition).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
-                            new Date(boardTime),
                             stops,
                             partition.stream().mapToDouble(t -> t.edge.distance).sum(),
                             path.get(i-1).label.currentTime - boardTime,
-                            new Date(path.get(i-1).label.currentTime),
                             lineString));
                     partition = null;
                 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index d94d1419e5..5d5ffbfc73 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -182,7 +182,7 @@ public void testRoute1ProfileEarliestArrival() {
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).getDepartureTime().toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "06:44", "07:14", "07:44", "08:14", "08:44", "08:54", "09:04", "09:14", "09:24", "09:34", "09:44", "09:54",
@@ -209,7 +209,7 @@ public void testRoute1ProfileLatestDeparture() {
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).getDepartureTime().toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "12:44", "12:14", "11:44", "11:14")
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index 676500e16b..f0200d359e 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -77,10 +77,10 @@ public void testDepartureTimeOfAccessLeg() {
 
         GHResponse response = graphHopper.route(ghRequest);
 
-        assertThat(response.getAll().get(0).getLegs().get(0).departureTime.toInstant().atZone(zoneId).toLocalTime())
+        assertThat(response.getAll().get(0).getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
                 .isEqualTo("06:41:06");
-        assertThat(response.getAll().get(0).getLegs().get(0).arrivalTime.toInstant())
-                .isEqualTo(response.getAll().get(0).getLegs().get(1).departureTime.toInstant());
+        assertThat(response.getAll().get(0).getLegs().get(0).getArrivalTime().toInstant())
+                .isEqualTo(response.getAll().get(0).getLegs().get(1).getDepartureTime().toInstant());
     }
 
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index aaeb991c45..e385c289df 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -30,7 +30,6 @@
 import com.graphhopper.util.Parameters;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -258,7 +257,7 @@ public void testZeroDelay() {
 //        assertEquals(responseWithoutRealtimeUpdateBest.toString(), responseWithRealtimeUpdateBest.toString());
     }
 
-    @Test @Ignore // Pending feature
+    @Test
     public void testDelayWithoutTransfer() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
@@ -268,11 +267,12 @@ public void testDelayWithoutTransfer() {
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
         ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
         ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
-        // The 6:00 departure of my line is going to be "late" by 0 minutes
+        // The 6:00 departure of my line is going to be late by 3 minutes
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
         feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
                 .setGtfsRealtimeVersion("1")
@@ -291,11 +291,11 @@ public void testDelayWithoutTransfer() {
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
-        assertEquals("My line run is 3 minutes late.", time(0, 8), response.getBest().getTime(), 0.1);
+        assertEquals("My line run is 3 minutes late.", time(0, 8), response.getBest().getLegs().get(response.getBest().getLegs().size() - 1).getArrivalTime().toInstant().toEpochMilli() - initialTime.toEpochMilli(), 0.1);
     }
 
 
-    @Test @Ignore // Pending feature
+    @Test
     public void testDelayFromBeginningWithoutTransfer() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
@@ -305,7 +305,8 @@ public void testDelayFromBeginningWithoutTransfer() {
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
         ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
         ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
 
@@ -328,7 +329,7 @@ public void testDelayFromBeginningWithoutTransfer() {
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
-        assertEquals("My line run is 3 minutes late.", time(0, 8), response.getBest().getTime(), 0.1);
+        assertEquals("My line run is 3 minutes late.", LocalDateTime.parse("2007-01-01T06:52:00").atZone(zoneId).toInstant(), response.getBest().getLegs().get(response.getBest().getLegs().size() - 1).getArrivalTime().toInstant());
     }
 
     @Test
