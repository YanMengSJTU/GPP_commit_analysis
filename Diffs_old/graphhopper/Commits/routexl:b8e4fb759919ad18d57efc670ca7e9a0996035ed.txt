diff --git a/.codeclimate.yml b/.codeclimate.yml
new file mode 100644
index 0000000000..d9d364d924
--- /dev/null
+++ b/.codeclimate.yml
@@ -0,0 +1,32 @@
+engines:
+  checkstyle:
+    enabled: true
+    checks:
+      com.puppycrawl.tools.checkstyle.checks.imports.AvoidStarImportCheck:
+        enabled: false
+      com.puppycrawl.tools.checkstyle.checks.imports.CustomImportOrderCheck:
+        enabled: false
+      com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck:
+        enabled: false
+      com.puppycrawl.tools.checkstyle.checks.naming.AbbreviationAsWordInNameCheck:
+        enabled: false
+      com.puppycrawl.tools.checkstyle.checks.whitespace.SeparatorWrapCheck:
+        enabled: false
+      com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck:
+        enabled: false
+      com.puppycrawl.tools.checkstyle.checks.blocks.NeedBracesCheck:
+        enabled: false
+  duplication:
+    enabled: true
+    config:
+      languages:
+      # it's not yet available for Java :)
+      - java
+  pmd:
+    enabled: true
+ratings:
+  paths:
+  - "**.java"
+exclude_paths:
+- "web/src/main/webapp/"
+- "**.js"
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index 31c8a43d4c..790cc30845 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -11,8 +11,6 @@ matrix:
       sudo: required
       dist: trusty
       group: edge
-  allow_failures:
-    - jdk: oraclejdk9
 
 env:
   global:
@@ -48,7 +46,7 @@ before_install:
 install: true
 
 script:
-  - mvn clean test verify -B
+  - mvn clean test verify checkstyle:check findbugs:check -B
 
 after_success:
   # deploy snapshot artifacts to maven central
@@ -61,7 +59,7 @@ after_success:
 
 notifications:
   email:
-    - github@graphhopper.com
+    - secure: l7/fjqL0c/9UcULXdhaKxsroZMg07nfNDiOHRBf7YKf8wrKdH52Z5kP7E10+a8iD/ieLD+ZaZPlom1bE7HymE1bVkp3d17Ezha47W5sdyOOb3NBDpg8olS4TkehOKo3AQhLXSfF6QGtipxY8Iy9QknXHngQOrcoGYiOlzCZ3BTQ=
 
 cache:
   directories:
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 88bc212d3d..aa23cb20cb 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -1,24 +1,30 @@
 # Contributors
 
-Most of the contributors are mentioned at Github as [Members](https://github.com/graphhopper?tab=members) or [Contributors](https://github.com/graphhopper/graphhopper/contributors). Here is a manual overview
+Most of the contributors are mentioned at Github as [Members](https://github.com/graphhopper?tab=members) or [Contributors](https://github.com/graphhopper/graphhopper/contributors). 
+
+Contributors that agree to the [project its CLA](https://www.graphhopper.com/individual-contributor-license-agreement/)
+state this as a comment via a separate, signed commit.
+
+Here is an overview:
 
  * ammagamma, improvements like #700, #703
  * AnahitaS, docs for Android, Android, Tomcat
  * andreaswolf, flag encoder versioning and more
  * agouge, discussion and API refactoring
  * b3nn0, Android improvements
- * boldtrn, motorcycle knowledge and many improvements like conditional tag parsing, round trips, ...
+ * boldtrn, one of the core developers with motorcycle knowledge :)
  * cgarreau, increase of routing success rate via subnetwork cleanup
  * ChristianSeitzer, motorcycle improvements
+ * ChristophKaser, agrees to the project's CLA, improved Android compatibility #1207
  * daisy1754, fixed usage of graphhopper.sh script
  * dardin88, instructions improved
  * dewos, web API bug fixes
  * devemux86, improvements regarding Android, GPX and more
- * edy, improvements regarding docker #849
- * elibar, fix for alternative route calculation
  * dos65, bug fixes in routing algo
  * drnextgis, ru translation and JS fixes
  * duongnt, fixes in storage
+ * edy, improvements regarding docker #849
+ * elibar, fix for alternative route calculation
  * fbonzon, several UI improvements like #615
  * florent-morel, improvements regarding fords, #320
  * fredao, translations 
@@ -38,8 +44,8 @@ Most of the contributors are mentioned at Github as [Members](https://github.com
  * NopMap, massive improvements regarding OSM, parsing and encoding, route relations
  * ocampana, initial implementation for instructions
  * PGWelch, shapefile reader #874
- * ratrun, route relations, GPX information, bike handling etc
  * rajanski, script to do routing via PostGIS
+ * ratrun, route relations, GPX information, bike handling etc
  * rodneyodonnell, improved dead end removal (PrepareRoutingSubnetworks) and fords
  * rodo, more descriptions
  * seeebiii, motorcycle improvements
diff --git a/android/app/build.gradle b/android/app/build.gradle
index d411152999..ba2fb0c0d6 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -1,8 +1,8 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 26
-    buildToolsVersion "26.0.0"
+    compileSdkVersion 27
+    buildToolsVersion "27.0.0"
 
     defaultConfig {
         applicationId "com.graphhopper.android"
@@ -35,24 +35,23 @@ configurations.all {
  **/
 
 dependencies {
-    compile(group: 'com.graphhopper', name: 'graphhopper-core', version: '0.10-SNAPSHOT') {
+    implementation(group: 'com.graphhopper', name: 'graphhopper-core', version: '0.10-SNAPSHOT') {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
        exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    compile 'org.mapsforge:vtm:0.8.0'
-    compile 'org.mapsforge:vtm-android:0.8.0'
-    compile 'org.mapsforge:vtm-android:0.8.0:natives-armeabi'
-    compile 'org.mapsforge:vtm-android:0.8.0:natives-armeabi-v7a'
-    compile 'org.mapsforge:vtm-android:0.8.0:natives-x86'
-    compile('org.mapsforge:vtm-jts:0.8.0') {
+    implementation 'org.mapsforge:vtm:0.8.0'
+    implementation 'org.mapsforge:vtm-android:0.8.0'
+    implementation 'org.mapsforge:vtm-android:0.8.0:natives-armeabi'
+    implementation 'org.mapsforge:vtm-android:0.8.0:natives-armeabi-v7a'
+    implementation 'org.mapsforge:vtm-android:0.8.0:natives-x86'
+    implementation('org.mapsforge:vtm-jts:0.8.0') {
         exclude group: 'com.vividsolutions', module: 'jts-core'
     }
-    compile 'org.mapsforge:vtm-themes:0.8.0'
-    compile 'com.caverock:androidsvg:1.2.2-beta-1'
-//    compile 'com.vividsolutions:jts-core:1.14.0'
+    implementation 'org.mapsforge:vtm-themes:0.8.0'
+    implementation 'com.caverock:androidsvg:1.2.2-beta-1'
 
-    compile 'org.slf4j:slf4j-api:1.7.25'
-    compile 'org.slf4j:slf4j-android:1.7.25'
+    implementation 'org.slf4j:slf4j-api:1.7.25'
+    implementation 'org.slf4j:slf4j-android:1.7.25'
 }
diff --git a/android/app/pom.xml b/android/app/pom.xml
index bd6c40948c..1ca4a99567 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -143,7 +143,7 @@
                 <configuration>
                     <sdk>
                         <!-- platform or api level (api level 8 = platform 2.2) -->                        
-                        <platform>25</platform>
+                        <platform>27</platform>
                     </sdk>
                     <deleteConflictingFiles>true</deleteConflictingFiles>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
diff --git a/android/app/project.properties b/android/app/project.properties
deleted file mode 100644
index 916037e334..0000000000
--- a/android/app/project.properties
+++ /dev/null
@@ -1,14 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-23
diff --git a/android/build.gradle b/android/build.gradle
index 6433c56194..42a1c7f0e4 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -1,15 +1,17 @@
 // Top-level build file where you can add configuration options common to all sub-projects/modules.
 buildscript {
     repositories {
+        google()
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.3'
+        classpath 'com.android.tools.build:gradle:3.0.0'
     }
 }
 
 allprojects {
     repositories {
+        google()
         jcenter()
         maven { url "https://oss.sonatype.org/content/groups/public/" }
     }
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index 47522179d5..cd201a3dc2 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Fri Mar 03 12:50:23 EET 2017
+#Thu Oct 26 11:57:58 EEST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
diff --git a/checkstyle.xml b/checkstyle.xml
new file mode 100644
index 0000000000..0899e38c9e
--- /dev/null
+++ b/checkstyle.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+        "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+        "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
+
+<module name="Checker">
+    <module name="TreeWalker">
+        <module name="LineLength">
+            <property name="max" value="500"/>
+        </module>
+    </module>
+</module>
\ No newline at end of file
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
index f395c044b4..a8f1e524e3 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -13,6 +13,7 @@
 import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 
 /**
  * @author Peter Karich
@@ -67,14 +68,23 @@ public MatrixResponse route(GHMRequest ghRequest) {
             outArrayListJson.add(str);
         }
 
-        // TODO allow elevation for full path
         boolean hasElevation = false;
-        requestJson.put("from_points", fromPointList);
-        requestJson.put("to_points", toPointList);
-        requestJson.put("out_arrays", outArrayListJson);
+        requestJson.putArray("from_points").addAll(fromPointList);
+        requestJson.putArray("to_points").addAll(toPointList);
+        requestJson.putArray("out_arrays").addAll(outArrayListJson);
         requestJson.put("vehicle", ghRequest.getVehicle());
         requestJson.put("elevation", hasElevation);
 
+        ObjectNode hintsObject = requestJson.putObject("hints");
+        Map<String, String> hintsMap = ghRequest.getHints().toMap();
+        for (String hintKey : hintsMap.keySet()) {
+            if (ignoreSet.contains(hintKey))
+                continue;
+
+            String hint = hintsMap.get(hintKey);
+            hintsObject.put(hintKey, hint);
+        }
+
         boolean withTimes = outArraysList.contains("times");
         boolean withDistances = outArraysList.contains("distances");
         boolean withWeights = outArraysList.contains("weights");
@@ -82,12 +92,11 @@ public MatrixResponse route(GHMRequest ghRequest) {
                 ghRequest.getFromPoints().size(),
                 ghRequest.getToPoints().size(), withTimes, withDistances, withWeights);
 
-        boolean debug = ghRequest.getHints().getBool("debug", false);
         String postUrl = buildURLNoHints("/calculate", ghRequest);
 
         try {
             String postResponseStr = postJson(postUrl, requestJson);
-
+            boolean debug = ghRequest.getHints().getBool("debug", false);
             if (debug) {
                 logger.info("POST URL:" + postUrl + ", request:" + requestJson + ", response: " + postResponseStr);
             }
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
index 5d255c3f3e..c92f3980cb 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -38,15 +38,15 @@ public void testMatrix() {
         }
 
         // ... only weight:
-        assertEquals(1685, res.getWeight(1, 2), 5);
+        assertEquals(1690, res.getWeight(1, 2), 10);
 
         req = AbstractGHMatrixWebTester.createRequest();
         req.addOutArray("weights");
         req.addOutArray("distances");
         res = ghMatrix.route(req);
 
-        assertEquals(9664, res.getDistance(1, 2), 20);
-        assertEquals(1685, res.getWeight(1, 2), 10);
+        assertEquals(9800, res.getDistance(1, 2), 50);
+        assertEquals(1695, res.getWeight(1, 2), 10);
     }
 
     @Test
@@ -69,6 +69,6 @@ public void testNxM_issue45() {
                 .addToPoints(Arrays.asList(new GHPoint(52.557151, 13.515244), new GHPoint(52.454545, 13.295517)));
 
         MatrixResponse res = ghMatrix.route(ghmRequest);
-        assertEquals(2436, res.getTime(0, 1) / 1000, 20);
+        assertEquals(2415, res.getTime(0, 1) / 1000, 20);
     }
 }
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index 241ad0f3ef..0b2814cd5b 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -8,6 +8,7 @@
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.RoundaboutInstruction;
+import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.exceptions.PointNotFoundException;
 import com.graphhopper.util.exceptions.PointOutOfBoundsException;
 import com.graphhopper.util.shapes.GHPoint;
@@ -16,6 +17,7 @@
 
 import java.io.IOException;
 import java.net.SocketTimeoutException;
+import java.util.List;
 
 import static org.junit.Assert.*;
 
@@ -49,7 +51,7 @@ public void testSimpleRoute() {
         assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
         PathWrapper alt = res.getBest();
         isBetween(200, 250, alt.getPoints().size());
-        isBetween(9900, 10300, alt.getDistance());
+        isBetween(11000, 12000, alt.getDistance());
 
         // change vehicle
         res = gh.route(new GHRequest(49.6724, 11.3494, 49.6550, 11.4180).
@@ -88,7 +90,7 @@ public void testNoPoints() {
         assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
         PathWrapper alt = res.getBest();
         assertEquals(0, alt.getPoints().size());
-        isBetween(9900, 10300, alt.getDistance());
+        isBetween(11000, 12000, alt.getDistance());
     }
 
     @Test
@@ -239,15 +241,15 @@ public void testMatrix() {
         }
 
         // ... only weight:
-        assertEquals(1685, res.getWeight(1, 2), 5);
+        assertEquals(1695, res.getWeight(1, 2), 5);
 
         req = AbstractGHMatrixWebTester.createRequest();
         req.addOutArray("weights");
         req.addOutArray("distances");
         res = ghMatrix.route(req);
 
-        assertEquals(9664, res.getDistance(1, 2), 20);
-        assertEquals(1685, res.getWeight(1, 2), 10);
+        assertEquals(9834, res.getDistance(1, 2), 20);
+        assertEquals(1695, res.getWeight(1, 2), 10);
     }
 
     @Test
@@ -260,4 +262,20 @@ public void testUnknownInstructionSign() throws IOException {
         assertEquals(741, wrapper.getInstructions().get(0).getSign());
         assertEquals("Continue onto A 81", wrapper.getInstructions().get(0).getName());
     }
+
+    @Test
+    public void testPathDetails() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.6724, 11.3494)).
+                addPoint(new GHPoint(49.6550, 11.4180));
+        req.getPathDetails().add("average_speed");
+        GHResponse res = gh.route(req);
+        assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
+        PathWrapper alt = res.getBest();
+        assertEquals(1, alt.getPathDetails().size());
+        List<PathDetail> details = alt.getPathDetails().get("average_speed");
+        assertFalse(details.isEmpty());
+        assertTrue((Double) details.get(0).getValue() > 20);
+        assertTrue((Double) details.get(0).getValue() < 70);
+    }
 }
diff --git a/core/files/berlin-siegessaeule.osm.gz b/core/files/berlin-siegessaeule.osm.gz
new file mode 100644
index 0000000000..c42854ccba
Binary files /dev/null and b/core/files/berlin-siegessaeule.osm.gz differ
diff --git a/core/files/travis-build.sh b/core/files/travis-build.sh
deleted file mode 100755
index 60b1deacce..0000000000
--- a/core/files/travis-build.sh
+++ /dev/null
@@ -1,27 +0,0 @@
-HOME=$(dirname $0)
-cd $HOME/../..
-
-# npm tests disabled due to #632
-# cd $HOME/../../web
-#
-# sudo chown -R $USER ~/.npm
-# npm install
-# npm test && npm run lint
-
-#modules="core web tools"
-#for module in $modules; do
-#  echo "====== INSTALL $module ====="
-#  mvn -pl $module clean install -DskipTests=true
-#  EXIT_VAL="$?"
-#  if [[ "x$EXIT_VAL" != "x0" ]]; then
-#    exit $EXIT_VAL
-#  fi
-#
-#  echo "====== TEST $module ====="
-#  # verify necessary for failsafe, otherwise it won't fail the build!?
-#  mvn -pl $module test failsafe:integration-test verify
-#  EXIT_VAL="$?"
-#  if [[ "x$EXIT_VAL" != "x0" ]]; then
-#    exit $EXIT_VAL
-#  fi
-#done
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index a0f422823b..2b74df151d 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -114,6 +114,7 @@
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private FlagEncoderFactory flagEncoderFactory = FlagEncoderFactory.DEFAULT;
     private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
+    private PathDetailsBuilderFactory pathBuilderFactory = new PathDetailsBuilderFactory();
 
     public GraphHopper() {
         chFactoryDecorator.setEnabled(true);
@@ -209,6 +210,15 @@ public GraphHopper setTraversalMode(TraversalMode traversalMode) {
         return this;
     }
 
+    public GraphHopper setPathDetailsBuilderFactory(PathDetailsBuilderFactory pathBuilderFactory) {
+        this.pathBuilderFactory = pathBuilderFactory;
+        return this;
+    }
+
+    public PathDetailsBuilderFactory getPathDetailsBuilderFactory() {
+        return pathBuilderFactory;
+    }
+
     /**
      * Configures the underlying storage and response to be used on a well equipped server. Result
      * also optimized for usage in the web module i.e. try reduce network IO.
@@ -911,7 +921,7 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
         if (hintsMap.has(Routing.BLOCK_AREA)) {
             String blockAreaStr = hintsMap.get(Parameters.Routing.BLOCK_AREA, "");
             GraphEdgeIdFinder.BlockArea blockArea = new GraphEdgeIdFinder(graph, locationIndex).
-                    parseBlockArea(blockAreaStr, new DefaultEdgeFilter(encoder));
+                    parseBlockArea(blockAreaStr, new DefaultEdgeFilter(encoder), hintsMap.getDouble("block_area.edge_id_max_area", 1000 * 1000));
             return new BlockAreaWeighting(weighting, blockArea);
         }
 
@@ -977,8 +987,7 @@ public GHResponse route(GHRequest request) {
 
             String algoStr = request.getAlgorithm();
             if (algoStr.isEmpty())
-                algoStr = chFactoryDecorator.isEnabled() && !disableCH &&
-                        !(lmFactoryDecorator.isEnabled() && !disableLM) ? DIJKSTRA_BI : ASTAR_BI;
+                algoStr = chFactoryDecorator.isEnabled() && !disableCH ? DIJKSTRA_BI : ASTAR_BI;
 
             List<GHPoint> points = request.getPoints();
             // TODO Maybe we should think about a isRequestValid method that checks all that stuff that we could do to fail fast
@@ -1051,14 +1060,13 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                 boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, enableInstructions);
                 boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
                 double wayPointMaxDistance = hints.getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);
-                PathDetailsBuilderFactory calculatorFactory = new PathDetailsBuilderFactory(request.getPathDetails(), encoder, weighting);
 
                 DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
                 PathMerger pathMerger = new PathMerger().
                         setCalcPoints(tmpCalcPoints).
                         setDouglasPeucker(peucker).
                         setEnableInstructions(tmpEnableInstructions).
-                        setPathDetailsBuilderFactory(calculatorFactory).
+                        setPathDetailsBuilders(pathBuilderFactory, request.getPathDetails()).
                         setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0);
 
                 if (routingTemplate.isReady(pathMerger, tr))
@@ -1105,7 +1113,7 @@ private void checkIfPointsAreInBounds(List<GHPoint> points) {
         for (int i = 0; i < points.size(); i++) {
             GHPoint point = points.get(i);
             if (!bounds.contains(point.getLat(), point.getLon())) {
-                throw new PointOutOfBoundsException("Point " + i + " is ouf of bounds: " + point, i);
+                throw new PointOutOfBoundsException("Point " + i + " is out of bounds: " + point, i);
             }
         }
     }
@@ -1178,7 +1186,7 @@ protected void prepareCH() {
      * For landmarks it is required to always call this method: either it creates the landmark data or it loads it.
      */
     protected void loadOrPrepareLM() {
-        boolean tmpPrepare = lmFactoryDecorator.isEnabled();
+        boolean tmpPrepare = lmFactoryDecorator.isEnabled() && !lmFactoryDecorator.getPreparations().isEmpty();
         if (tmpPrepare) {
             ensureWriteAccess();
             ghStorage.freeze();
diff --git a/core/src/main/java/com/graphhopper/PathWrapper.java b/core/src/main/java/com/graphhopper/PathWrapper.java
index 2b82d6cd7c..1664eef86a 100644
--- a/core/src/main/java/com/graphhopper/PathWrapper.java
+++ b/core/src/main/java/com/graphhopper/PathWrapper.java
@@ -254,6 +254,9 @@ public void addPathDetails(Map<String, List<PathDetail>> details) {
             throw new IllegalStateException("Details have to be the same size");
         }
         for (Map.Entry<String, List<PathDetail>> detailEntry : details.entrySet()) {
+            if (detailEntry.getValue().isEmpty())
+                throw new IllegalStateException("PathDetails " + detailEntry.getKey() + " must not be empty");
+
             if (this.pathDetails.containsKey(detailEntry.getKey())) {
                 List<PathDetail> pd = this.pathDetails.get(detailEntry.getKey());
                 PathMerger.merge(pd, detailEntry.getValue());
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java b/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java
new file mode 100644
index 0000000000..7dd9614470
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.ch.Path4CH;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+
+public class AStarBidirectionCH extends AStarBidirection {
+    public AStarBidirectionCH(Graph graph, Weighting weighting, TraversalMode traversalMode) {
+        super(graph, weighting, traversalMode);
+    }
+
+    @Override
+    protected void initCollections(int size) {
+        super.initCollections(Math.min(size, 2000));
+    }
+
+    @Override
+    protected boolean finished() {
+        // we need to finish BOTH searches for CH!
+        if (finishedFrom && finishedTo)
+            return true;
+
+        // changed finish condition for CH
+        return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+    }
+
+    @Override
+    protected Path createAndInitPath() {
+        bestPath = new Path4CH(graph, graph.getBaseGraph(), weighting);
+        return bestPath;
+    }
+
+    @Override
+    public String getName() {
+        return "astarbi|ch";
+    }
+
+    @Override
+    public String toString() {
+        return getName() + "|" + weighting;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index edece875d8..771b9b85fd 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
new file mode 100644
index 0000000000..ffe70dfc40
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
@@ -0,0 +1,95 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.carrotsearch.hppc.IntObjectMap;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+
+/**
+ * Uses a very simple version of stall-on-demand (SOD) for CH queries to prevent exploring nodes that can not be part
+ * of a shortest path. When a node that is about to be settled is stallable it is not expanded, but no further search
+ * for neighboring stallable nodes is performed.
+ *
+ * @author ammagamma
+ */
+public class DijkstraBidirectionCH extends DijkstraBidirectionCHNoSOD {
+    public DijkstraBidirectionCH(Graph graph, Weighting weighting, TraversalMode traversalMode) {
+        super(graph, weighting, traversalMode);
+    }
+
+    @Override
+    public boolean fillEdgesFrom() {
+        if (pqOpenSetFrom.isEmpty()) {
+            return false;
+        }
+        currFrom = pqOpenSetFrom.poll();
+        visitedCountFrom++;
+        if (entryIsStallable(currFrom, bestWeightMapFrom, inEdgeExplorer, false)) {
+            return true;
+        }
+        bestWeightMapOther = bestWeightMapTo;
+        fillEdges(currFrom, pqOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
+        return true;
+    }
+
+    @Override
+    public boolean fillEdgesTo() {
+        if (pqOpenSetTo.isEmpty()) {
+            return false;
+        }
+        currTo = pqOpenSetTo.poll();
+        visitedCountTo++;
+        if (entryIsStallable(currTo, bestWeightMapTo, outEdgeExplorer, true)) {
+            return true;
+        }
+        bestWeightMapOther = bestWeightMapFrom;
+        fillEdges(currTo, pqOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
+        return true;
+    }
+
+    @Override
+    public String getName() {
+        return "dijkstrabi|ch";
+    }
+
+    @Override
+    public String toString() {
+        return getName() + "|" + weighting;
+    }
+
+    private boolean entryIsStallable(SPTEntry entry, IntObjectMap<SPTEntry> bestWeightMap, EdgeExplorer edgeExplorer,
+                                     boolean reverse) {
+        // We check for all 'incoming' edges if we can prove that the current node (that is about to be settled) is 
+        // reached via a suboptimal path. We do this regardless of the CH level of the adjacent nodes.
+        EdgeIterator iter = edgeExplorer.setBaseNode(entry.adjNode);
+        while (iter.next()) {
+            int traversalId = traversalMode.createTraversalId(iter, reverse);
+            SPTEntry adjNode = bestWeightMap.get(traversalId);
+            if (adjNode != null &&
+                    adjNode.weight + weighting.calcWeight(iter, !reverse, entry.edge) < entry.weight) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java
new file mode 100644
index 0000000000..b810763ff8
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.ch.Path4CH;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+
+public class DijkstraBidirectionCHNoSOD extends DijkstraBidirectionRef {
+    public DijkstraBidirectionCHNoSOD(Graph graph, Weighting weighting, TraversalMode traversalMode) {
+        super(graph, weighting, traversalMode);
+    }
+
+    @Override
+    protected void initCollections(int size) {
+        super.initCollections(Math.min(size, 2000));
+    }
+
+    @Override
+    public boolean finished() {
+        // we need to finish BOTH searches for CH!
+        if (finishedFrom && finishedTo)
+            return true;
+
+        // changed also the final finish condition for CH
+        return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+    }
+
+    @Override
+    protected Path createAndInitPath() {
+        bestPath = new Path4CH(graph, graph.getBaseGraph(), weighting);
+        return bestPath;
+    }
+
+    @Override
+    public String getName() {
+        return "dijkstrabi|ch|no_sod";
+    }
+
+    @Override
+    public String toString() {
+        return getName() + "|" + weighting;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index c9ea680d54..3e122fad15 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -42,8 +42,8 @@
     protected SPTEntry currFrom;
     protected SPTEntry currTo;
     protected PathBidirRef bestPath;
-    private PriorityQueue<SPTEntry> pqOpenSetFrom;
-    private PriorityQueue<SPTEntry> pqOpenSetTo;
+    PriorityQueue<SPTEntry> pqOpenSetFrom;
+    PriorityQueue<SPTEntry> pqOpenSetTo;
     private boolean updateBestPath = true;
 
     public DijkstraBidirectionRef(Graph graph, Weighting weighting, TraversalMode tMode) {
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
index 85fc68c437..4278e995b7 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
@@ -315,13 +315,9 @@ private int getTurn(EdgeIteratorState edge, int baseNode, int prevNode, int adjN
                 }
 
                 if (otherDelta < delta) {
-                    // TODO Use keeps once we have a robust client
-                    //return Instruction.KEEP_LEFT;
-                    return Instruction.TURN_SLIGHT_LEFT;
+                    return Instruction.KEEP_LEFT;
                 } else {
-                    // TODO Use keeps once we have a robust client
-                    //return Instruction.KEEP_RIGHT;
-                    return Instruction.TURN_SLIGHT_RIGHT;
+                    return Instruction.KEEP_RIGHT;
                 }
 
 
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index a78619d396..f14fbc87cf 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -373,13 +373,13 @@ public InstructionList calcInstructions(final Translation tr) {
     /**
      * Calculates the PathDetails for this Path. This method will return fast, if there are no calculators.
      *
-     * @param pathBuilderFactory Generates the relevant PathBuilders, accepts null inputs
+     * @param pathBuilderFactory Generates the relevant PathBuilders
      * @return List of PathDetails for this Path
      */
-    public Map<String, List<PathDetail>> calcDetails(final PathDetailsBuilderFactory pathBuilderFactory, int previousIndex) {
-        if (!isFound() || pathBuilderFactory == null)
+    public Map<String, List<PathDetail>> calcDetails(List<String> requestedPathDetails, PathDetailsBuilderFactory pathBuilderFactory, int previousIndex) {
+        if (!isFound() || requestedPathDetails.isEmpty())
             return Collections.EMPTY_MAP;
-        List<PathDetailsBuilder> pathBuilders = pathBuilderFactory.createPathDetailsBuilders();
+        List<PathDetailsBuilder> pathBuilders = pathBuilderFactory.createPathDetailsBuilders(requestedPathDetails, encoder, weighting);
         if (pathBuilders.isEmpty())
             return Collections.EMPTY_MAP;
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 34eead5307..2701f7c3bd 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -647,9 +647,12 @@ public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
             AStarBidirection tmpAlgo = new AStarBidirectionCH(graph, prepareWeighting, traversalMode);
             tmpAlgo.setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
             algo = tmpAlgo;
-
         } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
-            algo = new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
+            if (opts.getHints().getBool("stall_on_demand", true)) {
+                algo = new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
+            } else {
+                algo = new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
+            }
         } else {
             throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies. Try with ch.disable=true");
         }
@@ -659,80 +662,6 @@ public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
         return algo;
     }
 
-    public static class AStarBidirectionCH extends AStarBidirection {
-        public AStarBidirectionCH(Graph graph, Weighting weighting, TraversalMode traversalMode) {
-            super(graph, weighting, traversalMode);
-        }
-
-        @Override
-        protected void initCollections(int size) {
-            super.initCollections(Math.min(size, 2000));
-        }
-
-        @Override
-        protected boolean finished() {
-            // we need to finish BOTH searches for CH!
-            if (finishedFrom && finishedTo)
-                return true;
-
-            // changed finish condition for CH
-            return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
-        }
-
-        @Override
-        protected Path createAndInitPath() {
-            bestPath = new Path4CH(graph, graph.getBaseGraph(), weighting);
-            return bestPath;
-        }
-
-        @Override
-        public String getName() {
-            return "astarbi|ch";
-        }
-
-        @Override
-        public String toString() {
-            return getName() + "|" + weighting;
-        }
-    }
-
-    public static class DijkstraBidirectionCH extends DijkstraBidirectionRef {
-        public DijkstraBidirectionCH(Graph graph, Weighting weighting, TraversalMode traversalMode) {
-            super(graph, weighting, traversalMode);
-        }
-
-        @Override
-        protected void initCollections(int size) {
-            super.initCollections(Math.min(size, 2000));
-        }
-
-        @Override
-        public boolean finished() {
-            // we need to finish BOTH searches for CH!
-            if (finishedFrom && finishedTo)
-                return true;
-
-            // changed also the final finish condition for CH
-            return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
-        }
-
-        @Override
-        protected Path createAndInitPath() {
-            bestPath = new Path4CH(graph, graph.getBaseGraph(), weighting);
-            return bestPath;
-        }
-
-        @Override
-        public String getName() {
-            return "dijkstrabi|ch";
-        }
-
-        @Override
-        public String toString() {
-            return getName() + "|" + weighting;
-        }
-    }
-
     @Override
     public String toString() {
         return "prepare|dijkstrabi|ch";
diff --git a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
index d778069318..31cfdac98f 100644
--- a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
@@ -67,13 +67,13 @@ public RoundTripRoutingTemplate(GHRequest request, GHResponse ghRsp, LocationInd
 
     @Override
     public List<QueryResult> lookup(List<GHPoint> points, FlagEncoder encoder) {
-        if (points.isEmpty())
-            throw new IllegalStateException("For round trip calculation one point is required");
+        if (points.size() != 1 || ghRequest.getPoints().size() != 1)
+            throw new IllegalArgumentException("For round trip calculation exactly one point is required");
         final double distanceInMeter = ghRequest.getHints().getDouble(RoundTrip.DISTANCE, 10000);
         final long seed = ghRequest.getHints().getLong(RoundTrip.SEED, 0L);
-        final double initialHeading = ghRequest.getHints().getDouble(RoundTrip.HEADING, Double.NaN);
-        final int roundTripPointCount = Math.min(20, ghRequest.getHints().getInt(Algorithms.ROUND_TRIP + ".points", 2 + (int) (distanceInMeter / 50000)));
-        final GHPoint start = ghRequest.getPoints().get(0);
+        double initialHeading = ghRequest.getFavoredHeading(0);
+        final int roundTripPointCount = Math.min(20, ghRequest.getHints().getInt(RoundTrip.POINTS, 2 + (int) (distanceInMeter / 50000)));
+        final GHPoint start = points.get(0);
 
         TourStrategy strategy = new MultiPointTour(new Random(seed), distanceInMeter, roundTripPointCount, initialHeading);
         queryResults = new ArrayList<>(2 + strategy.getNumberOfGeneratedPoints());
@@ -84,7 +84,7 @@ public RoundTripRoutingTemplate(GHRequest request, GHResponse ghRsp, LocationInd
 
         queryResults.add(startQR);
 
-        GHPoint last = points.get(0);
+        GHPoint last = start;
         for (int i = 0; i < strategy.getNumberOfGeneratedPoints(); i++) {
             double heading = strategy.getHeadingForIteration(i);
             QueryResult result = generateValidPoint(last, strategy.getDistanceForIteration(i), heading, edgeFilter);
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index c05d808239..54c4cf5a5e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -353,7 +353,7 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
             flags = handleSpeed(way, wayTypeSpeed, flags);
             flags = handleBikeRelated(way, flags, relationFlags > UNCHANGED.getValue());
 
-            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
             if (isRoundabout) {
                 flags = setBool(flags, K_ROUNDABOUT, true);
             }
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 3ab4c228bf..21e905b3bf 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -250,7 +250,7 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
 
             flags = setSpeed(flags, speed);
 
-            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
             if (isRoundabout)
                 flags = setBool(flags, K_ROUNDABOUT, true);
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
index 917d037475..a3b24989dd 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -377,7 +377,7 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
             flags = transportModeEncoder.setValue(flags, tmValue);
 
             // ROUNDABOUT
-            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
             if (isRoundabout)
                 flags = setBool(flags, K_ROUNDABOUT, true);
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 78228d56e0..a60e2ba439 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -296,7 +296,7 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
             }
             flags |= directionBitMask;
 
-            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
             if (isRoundabout)
                 flags = setBool(flags, K_ROUNDABOUT, true);
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
index 7716722de6..c7f489535d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -208,7 +208,7 @@ public long handleWayTags(ReaderWay way, long allowed, long priorityFromRelation
             if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
                 speed = 30;
 
-            boolean isRoundabout = way.hasTag("junction", "roundabout");
+            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
             if (isRoundabout)
                 flags = setBool(0, K_ROUNDABOUT, true);
 
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraph.java b/core/src/main/java/com/graphhopper/storage/CHGraph.java
index b1cad63628..48e8968451 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraph.java
@@ -37,7 +37,8 @@
     void setLevel(int nodeId, int level);
 
     /**
-     * @return the level of the specified node.
+     * @return the level of the specified node. The higher the more important the node is. Virtual nodes have the
+     * biggest level associated.
      */
     int getLevel(int nodeId);
 
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
index 747e1951d2..264488d649 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
@@ -124,9 +124,9 @@ final long setFlags_(long edgePointer, boolean reverse, long flags) {
      */
     final int internalEdgeAdd(int newEdgeId, int fromNodeId, int toNodeId) {
         writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        connectNewEdge(fromNodeId, newEdgeId);
+        connectNewEdge(fromNodeId, toNodeId, newEdgeId);
         if (fromNodeId != toNodeId)
-            connectNewEdge(toNodeId, newEdgeId);
+            connectNewEdge(toNodeId, fromNodeId, newEdgeId);
         return newEdgeId;
     }
 
@@ -147,11 +147,10 @@ final int getEdgeRef(int nodeThis, int nodeOther, long edgePointer) {
         return edges.getInt(_getLinkPosInEdgeArea(nodeThis, nodeOther, edgePointer));
     }
 
-    final void connectNewEdge(int fromNode, int newOrExistingEdge) {
+    final void connectNewEdge(int fromNode, int otherNode, int newOrExistingEdge) {
         int edge = getEdgeRef(fromNode);
         if (edge > EdgeIterator.NO_EDGE) {
             long edgePointer = toPointer(newOrExistingEdge);
-            int otherNode = getOtherNode(fromNode, edgePointer);
             long lastLink = _getLinkPosInEdgeArea(fromNode, otherNode, edgePointer);
             edges.setInt(lastLink, edge);
         }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
index b4819accfe..704933ab65 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
@@ -123,12 +123,11 @@ public void fillEdgeIDs(GHIntHashSet edgeIds, Geometry geometry, EdgeFilter filt
 
     /**
      * This method reads the blockAreaString and creates a Collection of Shapes or a set of found edges if area is small enough.
+     * @param useEdgeIdsUntilAreaSize until the specified area (specified in m²) use the findEdgesInShape method
      */
-    public BlockArea parseBlockArea(String blockAreaString, EdgeFilter filter) {
+    public BlockArea parseBlockArea(String blockAreaString, EdgeFilter filter, double useEdgeIdsUntilAreaSize) {
         final String objectSeparator = ";";
         final String innerObjSep = ",";
-        // use shapes if bigger than 1km^2
-        final double shapeArea = 1000 * 1000;
         BlockArea blockArea = new BlockArea(graph);
 
         // Add blocked circular areas or points
@@ -139,7 +138,7 @@ public BlockArea parseBlockArea(String blockAreaString, EdgeFilter filter) {
                 String[] splittedObject = objectAsString.split(innerObjSep);
                 if (splittedObject.length == 4) {
                     final BBox bbox = BBox.parseTwoPoints(objectAsString);
-                    if (bbox.calculateArea() > shapeArea)
+                    if (bbox.calculateArea() > useEdgeIdsUntilAreaSize)
                         blockArea.add(bbox);
                     else
                         findEdgesInShape(blockArea.blockedEdges, bbox, filter);
@@ -148,7 +147,7 @@ public BlockArea parseBlockArea(String blockAreaString, EdgeFilter filter) {
                     double lon = Double.parseDouble(splittedObject[1]);
                     int radius = Integer.parseInt(splittedObject[2]);
                     Circle circle = new Circle(lat, lon, radius);
-                    if (circle.calculateArea() > shapeArea) {
+                    if (circle.calculateArea() > useEdgeIdsUntilAreaSize) {
                         blockArea.add(circle);
                     } else {
                         findEdgesInShape(blockArea.blockedEdges, circle, filter);
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index e472d92716..190005af5f 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -227,7 +227,7 @@ public boolean loadExisting() {
         baseGraph.checkInit();
         if (properties.loadExisting()) {
             properties.checkVersions(false);
-            // check encoding for compatiblity
+            // check encoding for compatibility
             String flagEncodersStr = properties.get("graph.flag_encoders");
 
             if (!flagEncodersStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(flagEncodersStr)) {
@@ -299,7 +299,7 @@ public long getCapacity() {
 
     /**
      * Avoid that edges and nodes of the base graph are further modified. Necessary as hook for e.g.
-     * ch graphs on top to initilize themself
+     * ch graphs on top to initialize themselves
      */
     public synchronized void freeze() {
         if (!baseGraph.isFrozen())
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index aaffb8cf7a..9df8c7941b 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -262,15 +262,12 @@ public static Graph copyTo(Graph fromGraph, Graph toGraph) {
     }
 
     static Directory guessDirectory(GraphStorage store) {
-        String location = store.getDirectory().getLocation();
-        Directory outdir;
         if (store.getDirectory() instanceof MMapDirectory) {
             throw new IllegalStateException("not supported yet: mmap will overwrite existing storage at the same location");
-        } else {
-            boolean isStoring = ((GHDirectory) store.getDirectory()).isStoring();
-            outdir = new RAMDirectory(location, isStoring);
         }
-        return outdir;
+        String location = store.getDirectory().getLocation();
+        boolean isStoring = ((GHDirectory) store.getDirectory()).isStoring();
+        return new RAMDirectory(location, isStoring);
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index d4c4da0246..901576ec1e 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -374,15 +374,13 @@ public Object run() throws Exception {
                     if (Constants.JRE_IS_MINIMUM_JAVA9) {
                         // >=JDK9 class sun.misc.Unsafe { void invokeCleaner(ByteBuffer buf) }
                         final Class<?> unsafeClass = Class.forName("sun.misc.Unsafe");
-                        // we do not need to check for a specific class, we can call the Unsafe method with any buffer class
-                        MethodHandle unmapper = MethodHandles.lookup().findVirtual(unsafeClass, "invokeCleaner",
-                                MethodType.methodType(void.class, ByteBuffer.class));
                         // fetch the unsafe instance and bind it to the virtual MethodHandle
                         final Field f = unsafeClass.getDeclaredField("theUnsafe");
                         f.setAccessible(true);
                         final Object theUnsafe = f.get(null);
+                        final Method method = unsafeClass.getDeclaredMethod("invokeCleaner", ByteBuffer.class);
                         try {
-                            unmapper.bindTo(theUnsafe).invokeExact(buffer);
+                            method.invoke(theUnsafe, buffer);
                             return null;
                         } catch (Throwable t) {
                             throw new RuntimeException(t);
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index 45607268e7..992d74ca3b 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -23,6 +23,7 @@
 
 public class Instruction {
     public static final int UNKNOWN = -99;
+    public static final int KEEP_LEFT = -7;
     public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
@@ -35,7 +36,6 @@
     public static final int REACHED_VIA = 5;
     public static final int USE_ROUNDABOUT = 6;
     public static final int IGNORE = Integer.MIN_VALUE;
-    public static final int KEEP_LEFT = -7;
     public static final int KEEP_RIGHT = 7;
     public static final int PT_START_TRIP = 101;
     public static final int PT_TRANSFER = 102;
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index 69d25cc193..cd7ab45dc7 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -20,6 +20,8 @@
 import com.fasterxml.jackson.annotation.JsonValue;
 
 import java.text.DateFormat;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
 import java.util.*;
 
 /**
@@ -159,10 +161,10 @@ public String createGPX(String trackName, long startTimeMillis) {
         return createGPX(trackName, startTimeMillis, includeElevation, true, true, true);
     }
 
-    private void createWayPointBlock(StringBuilder output, Instruction instruction) {
+    private void createWayPointBlock(StringBuilder output, Instruction instruction, DecimalFormat decimalFormat) {
         output.append("\n<wpt ");
-        output.append("lat=\"").append(Helper.round6(instruction.getFirstLat()));
-        output.append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
+        output.append("lat=\"").append(decimalFormat.format(instruction.getFirstLat()));
+        output.append("\" lon=\"").append(decimalFormat.format(instruction.getFirstLon())).append("\">");
         String name;
         if (instruction.getName().isEmpty())
             name = instruction.getTurnDescription(tr);
@@ -176,6 +178,12 @@ private void createWayPointBlock(StringBuilder output, Instruction instruction)
     public String createGPX(String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints) {
         DateFormat formatter = Helper.createFormatter();
 
+        DecimalFormat decimalFormat = new DecimalFormat("#");
+        decimalFormat.setMinimumFractionDigits(1);
+        decimalFormat.setMaximumFractionDigits(6);
+        decimalFormat.setMinimumIntegerDigits(1);
+        decimalFormat.setDecimalFormatSymbols(DecimalFormatSymbols.getInstance(Locale.US));
+
         String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
                 + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
                 + " creator=\"Graphhopper version " + Constants.VERSION + "\" version=\"1.1\""
@@ -192,12 +200,12 @@ public String createGPX(String trackName, long startTimeMillis, boolean includeE
         StringBuilder gpxOutput = new StringBuilder(header);
         if (!isEmpty()) {
             if (withWayPoints) {
-                createWayPointBlock(gpxOutput, instructions.get(0));   // Start 
+                createWayPointBlock(gpxOutput, instructions.get(0), decimalFormat);   // Start
                 for (Instruction currInstr : instructions) {
                     if ((currInstr.getSign() == Instruction.REACHED_VIA) // Via
                             || (currInstr.getSign() == Instruction.FINISH)) // End
                     {
-                        createWayPointBlock(gpxOutput, currInstr);
+                        createWayPointBlock(gpxOutput, currInstr, decimalFormat);
                     }
                 }
             }
@@ -206,11 +214,11 @@ public String createGPX(String trackName, long startTimeMillis, boolean includeE
                 Instruction nextInstr = null;
                 for (Instruction currInstr : instructions) {
                     if (null != nextInstr)
-                        createRteptBlock(gpxOutput, nextInstr, currInstr);
+                        createRteptBlock(gpxOutput, nextInstr, currInstr, decimalFormat);
 
                     nextInstr = currInstr;
                 }
-                createRteptBlock(gpxOutput, nextInstr, null);
+                createRteptBlock(gpxOutput, nextInstr, null, decimalFormat);
                 gpxOutput.append("\n</rte>");
             }
         }
@@ -219,8 +227,8 @@ public String createGPX(String trackName, long startTimeMillis, boolean includeE
 
             gpxOutput.append("<trkseg>");
             for (GPXEntry entry : createGPXList()) {
-                gpxOutput.append("\n<trkpt lat=\"").append(Helper.round6(entry.getLat()));
-                gpxOutput.append("\" lon=\"").append(Helper.round6(entry.getLon())).append("\">");
+                gpxOutput.append("\n<trkpt lat=\"").append(decimalFormat.format(entry.getLat()));
+                gpxOutput.append("\" lon=\"").append(decimalFormat.format(entry.getLon())).append("\">");
                 if (includeElevation)
                     gpxOutput.append("<ele>").append(Helper.round2(entry.getEle())).append("</ele>");
                 gpxOutput.append("<time>").append(formatter.format(startTimeMillis + entry.getTime())).append("</time>");
@@ -235,9 +243,9 @@ public String createGPX(String trackName, long startTimeMillis, boolean includeE
         return gpxOutput.toString();
     }
 
-    public void createRteptBlock(StringBuilder output, Instruction instruction, Instruction nextI) {
-        output.append("\n<rtept lat=\"").append(Helper.round6(instruction.getFirstLat())).
-                append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
+    public void createRteptBlock(StringBuilder output, Instruction instruction, Instruction nextI, DecimalFormat decimalFormat) {
+        output.append("\n<rtept lat=\"").append(decimalFormat.format(instruction.getFirstLat())).
+                append("\" lon=\"").append(decimalFormat.format(instruction.getFirstLon())).append("\">");
 
         if (!instruction.getName().isEmpty())
             output.append("<desc>").append(simpleXMLEscape(instruction.getTurnDescription(tr))).append("</desc>");
@@ -254,6 +262,12 @@ public void createRteptBlock(StringBuilder output, Instruction instruction, Inst
         if (!Double.isNaN(azimuth))
             output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
 
+        if (instruction instanceof RoundaboutInstruction) {
+            RoundaboutInstruction ri = (RoundaboutInstruction) instruction;
+
+            output.append("<gh:exit_number>").append(ri.getExitNumber()).append("</gh:exit_number>");
+        }
+
         output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
         output.append("</extensions>");
         output.append("</rtept>");
diff --git a/core/src/main/java/com/graphhopper/util/Parameters.java b/core/src/main/java/com/graphhopper/util/Parameters.java
index 59b95e7c6d..bf112ad42d 100644
--- a/core/src/main/java/com/graphhopper/util/Parameters.java
+++ b/core/src/main/java/com/graphhopper/util/Parameters.java
@@ -82,7 +82,7 @@
         public static final class RoundTrip {
             public static final String DISTANCE = ROUND_TRIP + ".distance";
             public static final String SEED = ROUND_TRIP + ".seed";
-            public static final String HEADING = "heading";
+            public static final String POINTS = ROUND_TRIP + ".points";
             public static final String INIT_MAX_RETRIES = ROUTING_INIT_PREFIX + ROUND_TRIP + ".max_retries";
         }
     }
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 95e469c8b5..0f90371240 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -46,7 +46,8 @@
     private boolean simplifyResponse = true;
     private DouglasPeucker douglasPeucker = DP;
     private boolean calcPoints = true;
-    private PathDetailsBuilderFactory calculatorFactory;
+    private PathDetailsBuilderFactory pathBuilderFactory;
+    private List<String> requestedPathDetails = Collections.EMPTY_LIST;
 
     public PathMerger setCalcPoints(boolean calcPoints) {
         this.calcPoints = calcPoints;
@@ -58,8 +59,9 @@ public PathMerger setDouglasPeucker(DouglasPeucker douglasPeucker) {
         return this;
     }
 
-    public PathMerger setPathDetailsBuilderFactory(PathDetailsBuilderFactory calculatorFactory) {
-        this.calculatorFactory = calculatorFactory;
+    public PathMerger setPathDetailsBuilders(PathDetailsBuilderFactory pathBuilderFactory, List<String> requestedPathDetails) {
+        this.pathBuilderFactory = pathBuilderFactory;
+        this.requestedPathDetails = requestedPathDetails;
         return this;
     }
 
@@ -82,7 +84,7 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
 
         InstructionList fullInstructions = new InstructionList(tr);
         PointList fullPoints = PointList.EMPTY;
-        List<String> description = new ArrayList<String>();
+        List<String> description = new ArrayList<>();
         for (int pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
             Path path = paths.get(pathIndex);
             description.addAll(path.getDescription());
@@ -110,7 +112,7 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
                     fullPoints = new PointList(tmpPoints.size(), tmpPoints.is3D());
 
                 fullPoints.add(tmpPoints);
-                altRsp.addPathDetails(path.calcDetails(calculatorFactory, origPoints));
+                altRsp.addPathDetails(path.calcDetails(requestedPathDetails, pathBuilderFactory, origPoints));
                 origPoints += tmpPoints.size();
             }
 
diff --git a/core/src/main/java/com/graphhopper/util/PathSimplification.java b/core/src/main/java/com/graphhopper/util/PathSimplification.java
index 21826ec5ae..40aebf84b6 100644
--- a/core/src/main/java/com/graphhopper/util/PathSimplification.java
+++ b/core/src/main/java/com/graphhopper/util/PathSimplification.java
@@ -48,7 +48,11 @@ public PathSimplification(PathWrapper pathWrapper, DouglasPeucker douglasPeucker
 
         this.pathDetails = pathWrapper.getPathDetails();
         for (String name : pathDetails.keySet()) {
-            listsToSimplify.add(pathDetails.get(name));
+            List<PathDetail> pathDetailList = pathDetails.get(name);
+            if (pathDetailList.isEmpty())
+                throw new IllegalStateException("PathDetails " + name + " must not be empty");
+
+            listsToSimplify.add(pathDetailList);
         }
         this.douglasPeucker = douglasPeucker;
     }
@@ -135,6 +139,8 @@ public PointList simplify() {
                 prevPD = list.get(i);
             }
         }
+        // Make sure that the instruction references are not broken
+        pointList.makeImmutable();
         return pointList;
     }
 
@@ -155,7 +161,7 @@ private int getLength(Object o, int index) {
 
     private void reduceLength(Object o, int index, int startIndex, int newEndIndex) {
         if (o instanceof InstructionList) {
-            ((InstructionList) o).get(index).setPoints(this.pointList.copy(startIndex, newEndIndex));
+            ((InstructionList) o).get(index).setPoints(this.pointList.shallowCopy(startIndex, newEndIndex, false));
         } else if (o instanceof List) {
             PathDetail pd = ((List<PathDetail>) o).get(index);
             pd.setFirst(startIndex);
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index 112c7cfac4..e00b77fb94 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -25,7 +25,9 @@
 import java.util.*;
 
 /**
- * Slim list to store several points (without the need for a point object).
+ * Slim list to store several points (without the need for a point object). Be aware that the PointList is closely
+ * coupled with the {@link ShallowImmutablePointList} if you change it or extend it, you should make sure that your
+ * changes play well with the ShallowImmutablePointList to avoid unexpected issues.
  * <p>
  *
  * @author Peter Karich
@@ -138,12 +140,13 @@ public boolean is3D() {
         }
     };
     private final static DistanceCalc3D distCalc3D = Helper.DIST_3D;
-    private static String ERR_MSG = "Tried to access PointList with too big index!";
+    final static String ERR_MSG = "Tried to access PointList with too big index!";
     protected int size = 0;
     protected boolean is3D;
     private double[] latitudes;
     private double[] longitudes;
     private double[] elevations;
+    private boolean isImmutable = false;
 
     public PointList() {
         this(10, false);
@@ -185,6 +188,7 @@ public void setNode(int nodeId, double lat, double lon, double ele) {
     }
 
     public void set(int index, double lat, double lon, double ele) {
+        ensureMutability();
         if (index >= size)
             throw new ArrayIndexOutOfBoundsException("index has to be smaller than size " + size);
 
@@ -216,6 +220,7 @@ public void add(double lat, double lon) {
     }
 
     public void add(double lat, double lon, double ele) {
+        ensureMutability();
         int newSize = size + 1;
         incCap(newSize);
         latitudes[size] = lat;
@@ -242,6 +247,7 @@ public void add(GHPoint point) {
     }
 
     public void add(PointList points) {
+        ensureMutability();
         int newSize = size + points.getSize();
         incCap(newSize);
         for (int i = 0; i < points.getSize(); i++) {
@@ -259,11 +265,11 @@ public int size() {
     }
 
     public int getSize() {
-        return size;
+        return size();
     }
 
     public boolean isEmpty() {
-        return size == 0;
+        return size() == 0;
     }
 
     @Override
@@ -308,6 +314,7 @@ public double getEle(int index) {
     }
 
     public void reverse() {
+        ensureMutability();
         // in-place reverse
         int max = size / 2;
         for (int i = 0; i < max; i++) {
@@ -330,10 +337,12 @@ public void reverse() {
     }
 
     public void clear() {
+        ensureMutability();
         size = 0;
     }
 
     public void trimToSize(int newSize) {
+        ensureMutability();
         if (newSize > size)
             throw new IllegalArgumentException("new size needs be smaller than old size");
 
@@ -343,17 +352,17 @@ public void trimToSize(int newSize) {
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < size; i++) {
+        for (int i = 0; i < getSize(); i++) {
             if (i > 0)
                 sb.append(", ");
 
             sb.append('(');
-            sb.append(latitudes[i]);
+            sb.append(getLatitude(i));
             sb.append(',');
-            sb.append(longitudes[i]);
-            if (is3D) {
+            sb.append(getLongitude(i));
+            if (this.is3D()) {
                 sb.append(',');
-                sb.append(elevations[i]);
+                sb.append(getElevation(i));
             }
             sb.append(')');
         }
@@ -369,8 +378,8 @@ public String toString() {
 
     public List<Double[]> toGeoJson(boolean includeElevation) {
 
-        ArrayList<Double[]> points = new ArrayList<Double[]>(size);
-        for (int i = 0; i < size; i++) {
+        ArrayList<Double[]> points = new ArrayList<Double[]>(getSize());
+        for (int i = 0; i < getSize(); i++) {
             if (includeElevation)
                 points.add(new Double[]{
                         Helper.round6(getLongitude(i)), Helper.round6(getLatitude(i)),
@@ -396,61 +405,84 @@ public boolean equals(Object obj) {
         if (this.getSize() != other.getSize() || this.is3D() != other.is3D())
             return false;
 
-        for (int i = 0; i < size; i++) {
-            if (!NumHelper.equalsEps(latitudes[i], other.latitudes[i]))
+        for (int i = 0; i < size(); i++) {
+            if (!NumHelper.equalsEps(getLatitude(i), other.getLatitude(i)))
                 return false;
 
-            if (!NumHelper.equalsEps(longitudes[i], other.longitudes[i]))
+            if (!NumHelper.equalsEps(getLongitude(i), other.getLongitude(i)))
                 return false;
 
-            if (is3D && !NumHelper.equalsEps(elevations[i], other.elevations[i]))
+            if (this.is3D() && !NumHelper.equalsEps(getElevation(i), other.getElevation(i)))
                 return false;
         }
         return true;
     }
 
+    /**
+     * Clones this PointList. If this PointList was immutable, the cloned will be mutable. If this PointList was a
+     * ShallowImmutablePointList, the cloned PointList will be a regular PointList.
+     */
     public PointList clone(boolean reverse) {
-        PointList clonePL = new PointList(size, is3D);
-        if (is3D)
-            for (int i = 0; i < size; i++) {
-                clonePL.add(latitudes[i], longitudes[i], elevations[i]);
+        PointList clonePL = new PointList(getSize(), is3D());
+        if (is3D())
+            for (int i = 0; i < getSize(); i++) {
+                clonePL.add(getLatitude(i), getLongitude(i), getElevation(i));
             }
         else
-            for (int i = 0; i < size; i++) {
-                clonePL.add(latitudes[i], longitudes[i]);
+            for (int i = 0; i < getSize(); i++) {
+                clonePL.add(getLatitude(i), getLongitude(i));
             }
         if (reverse)
             clonePL.reverse();
         return clonePL;
     }
 
+    /**
+     * This method does a deep copy of this object for the specified range.
+     *
+     * @param from the copying of the old PointList starts at this index
+     * @param end  the copying of the old PointList ends at the index before (i.e. end is exclusive)
+     */
     public PointList copy(int from, int end) {
         if (from > end)
-            throw new IllegalArgumentException("from must be smaller or equals to end");
-        if (from < 0 || end > size)
-            throw new IllegalArgumentException("Illegal interval: " + from + ", " + end + ", size:" + size);
+            throw new IllegalArgumentException("from must be smaller or equal to end");
+        if (from < 0 || end > getSize())
+            throw new IllegalArgumentException("Illegal interval: " + from + ", " + end + ", size:" + getSize());
 
-        PointList copyPL = new PointList(size, is3D);
-        if (is3D)
+        PointList copyPL = new PointList(end - from, is3D());
+        if (is3D())
             for (int i = from; i < end; i++) {
-                copyPL.add(latitudes[i], longitudes[i], elevations[i]);
+                copyPL.add(getLatitude(i), getLongitude(i), getElevation(i));
             }
         else
             for (int i = from; i < end; i++) {
-                copyPL.add(latitudes[i], longitudes[i], Double.NaN);
+                copyPL.add(getLatitude(i), getLongitude(i), Double.NaN);
             }
 
         return copyPL;
     }
 
+    /**
+     * Create a shallow copy of this Pointlist from from to end, excluding end.
+     * <p>
+     * The <code>ensureConsistency</code> parameter makes this PointList immutable, so the shallow copy will stay
+     * consistent with this object. If you don't ensure the consistency it might happen that due to changes of this
+     * object, the shallow copy might contain incorrect or corrupt data.
+     */
+    public PointList shallowCopy(final int from, final int end, boolean ensureConsistency) {
+        if (ensureConsistency)
+            this.makeImmutable();
+        return new ShallowImmutablePointList(from, end, this);
+    }
+
     @Override
     public int hashCode() {
         int hash = 5;
-        for (int i = 0; i < latitudes.length; i++) {
-            hash = 73 * hash + (int) Math.round(latitudes[i] * 1000000);
-            hash = 73 * hash + (int) Math.round(longitudes[i] * 1000000);
+        for (int i = 0; i < getSize(); i++) {
+            hash = 73 * hash + (int) Math.round(getLatitude(i) * 1000000);
+            hash = 73 * hash + (int) Math.round(getLongitude(i) * 1000000);
         }
-        hash = 73 * hash + this.size;
+        hash = 73 * hash + this.getSize();
         return hash;
     }
 
@@ -459,18 +491,18 @@ public double calcDistance(DistanceCalc calc) {
         double prevLon = Double.NaN;
         double prevEle = Double.NaN;
         double dist = 0;
-        for (int i = 0; i < size; i++) {
+        for (int i = 0; i < size(); i++) {
             if (i > 0) {
-                if (is3D)
-                    dist += distCalc3D.calcDist(prevLat, prevLon, prevEle, latitudes[i], longitudes[i], elevations[i]);
+                if (is3D())
+                    dist += distCalc3D.calcDist(prevLat, prevLon, prevEle, getLat(i), getLon(i), getEle(i));
                 else
-                    dist += calc.calcDist(prevLat, prevLon, latitudes[i], longitudes[i]);
+                    dist += calc.calcDist(prevLat, prevLon, getLat(i), getLon(i));
             }
 
-            prevLat = latitudes[i];
-            prevLon = longitudes[i];
-            if (is3D)
-                prevEle = elevations[i];
+            prevLat = getLat(i);
+            prevLon = getLon(i);
+            if (is3D())
+                prevEle = getEle(i);
         }
         return dist;
     }
@@ -532,4 +564,22 @@ public static PointList from(LineString lineString) {
         }
         return pointList;
     }
+
+    public boolean isImmutable() {
+        return this.isImmutable;
+    }
+
+    /**
+     * Once immutable, there is no way to make this object mutable again. This is done to ensure the consistency of
+     * shallow copies. If you need to modify this object again, you have to create a deep copy of it.
+     */
+    public void makeImmutable() {
+        this.isImmutable = true;
+    }
+
+    private void ensureMutability() {
+        if (this.isImmutable()) {
+            throw new IllegalStateException("You cannot change an immutable PointList");
+        }
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java b/core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
new file mode 100644
index 0000000000..4f5b2f02cd
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
@@ -0,0 +1,161 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util;
+
+import java.util.List;
+
+/**
+ * This is a shallow copy of a PointList. This class can be used to create a memory efficient copy of a PointList.
+ * You have to be aware, that if the wrapped PointList changes, the shallow copy will change as well. This can lead to
+ * unexpected results. We recommend making the wrapped PointList immutable {@link PointList#makeImmutable()}.
+ *
+ * @author Robin Boldt
+ */
+public final class ShallowImmutablePointList extends PointList {
+
+    private final static String IMMUTABLE_ERR = "This class is immutable, you are not allowed to change it";
+
+    private final int fromOffset;
+    private final int toOffset;
+    private final PointList wrappedPointList;
+
+    public ShallowImmutablePointList(int fromOffset, int toOffset, PointList wrappedPointList) {
+        if (fromOffset > toOffset)
+            throw new IllegalArgumentException("from must be smaller or equal to end");
+        if (fromOffset < 0 || toOffset > wrappedPointList.getSize())
+            throw new IllegalArgumentException("Illegal interval: " + fromOffset + ", " + toOffset);
+        this.fromOffset = fromOffset;
+        this.toOffset = toOffset;
+        this.wrappedPointList = wrappedPointList;
+    }
+
+    @Override
+    public int size() {
+        return toOffset - fromOffset;
+    }
+
+    @Override
+    public int getSize() {
+        return size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    @Override
+    public double getLatitude(int index) {
+        if (index > getSize())
+            throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + getSize());
+        return wrappedPointList.getLatitude(fromOffset + index);
+    }
+
+    @Override
+    public double getLongitude(int index) {
+        if (index > getSize())
+            throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + getSize());
+        return wrappedPointList.getLongitude(fromOffset + index);
+    }
+
+    @Override
+    public double getElevation(int index) {
+        if (index > getSize())
+            throw new ArrayIndexOutOfBoundsException(ERR_MSG + " index:" + index + ", size:" + getSize());
+        return wrappedPointList.getElevation(fromOffset + index);
+    }
+
+    public void makeImmutable() {
+        this.wrappedPointList.makeImmutable();
+    }
+
+    @Override
+    public boolean isImmutable() {
+        return this.wrappedPointList.isImmutable();
+    }
+
+    /*
+    Wrapping Part
+     */
+
+    @Override
+    public boolean is3D() {
+        return wrappedPointList.is3D();
+    }
+
+    @Override
+    public int getDimension() {
+        return wrappedPointList.getDimension();
+    }
+
+
+    /*
+    Immutable forbidden part
+     */
+
+    @Override
+    public void ensureNode(int nodeId) {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+    @Override
+    public void setNode(int nodeId, double lat, double lon) {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+    @Override
+    public void setNode(int nodeId, double lat, double lon, double ele) {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+    @Override
+    public void set(int index, double lat, double lon, double ele) {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+    @Override
+    public void add(double lat, double lon, double ele) {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+    @Override
+    public void add(PointList points) {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+    @Override
+    public void reverse() {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+    @Override
+    public void trimToSize(int newSize) {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+    @Override
+    public void parse2DJSON(String str) {
+        throw new UnsupportedOperationException(IMMUTABLE_ERR);
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/util/details/AverageSpeedDetails.java b/core/src/main/java/com/graphhopper/util/details/AverageSpeedDetails.java
index 1b8b25ab19..d0d4257d1f 100644
--- a/core/src/main/java/com/graphhopper/util/details/AverageSpeedDetails.java
+++ b/core/src/main/java/com/graphhopper/util/details/AverageSpeedDetails.java
@@ -39,7 +39,7 @@ public AverageSpeedDetails(FlagEncoder encoder) {
 
     @Override
     public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
-        if (encoder.getSpeed(edge.getFlags()) != curAvgSpeed) {
+        if (Math.abs(encoder.getSpeed(edge.getFlags()) - curAvgSpeed) > 0.0001) {
             this.curAvgSpeed = this.encoder.getSpeed(edge.getFlags());
             return true;
         }
diff --git a/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java b/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java
index d7329a02b2..702319f920 100644
--- a/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java
+++ b/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java
@@ -32,17 +32,7 @@
  */
 public class PathDetailsBuilderFactory {
 
-    private final List<String> requestedPathDetails;
-    private final FlagEncoder encoder;
-    private final Weighting weighting;
-
-    public PathDetailsBuilderFactory(List<String> requestedPathDetails, FlagEncoder encoder, Weighting weighting) {
-        this.requestedPathDetails = requestedPathDetails;
-        this.encoder = encoder;
-        this.weighting = weighting;
-    }
-
-    public List<PathDetailsBuilder> createPathDetailsBuilders() {
+    public List<PathDetailsBuilder> createPathDetailsBuilders(List<String> requestedPathDetails, FlagEncoder encoder, Weighting weighting) {
         List<PathDetailsBuilder> builders = new ArrayList<>();
 
         if (requestedPathDetails.contains(AVERAGE_SPEED))
diff --git a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
index f3d10be780..d8bc4e4756 100644
--- a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
+++ b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
@@ -74,6 +74,6 @@ web.marker=Značka
 web.gh_offline_info=API GraphHopper je offline?
 web.refresh_button=Obnovit stránku
 web.server_status=Stav
-web.zoom_in=
-web.zoom_out=
+web.zoom_in=Přiblížit
+web.zoom_out=Oddálit
 web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/eo.txt b/core/src/main/resources/com/graphhopper/util/eo.txt
index 9ad695d19b..f18e6d98ce 100644
--- a/core/src/main/resources/com/graphhopper/util/eo.txt
+++ b/core/src/main/resources/com/graphhopper/util/eo.txt
@@ -1,18 +1,18 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-continue=pluigu
-continue_onto=pluigu laŭlonge de %1$s
-turn_left=turnu maldekstren
-turn_right=turnu dekstren
-turn_slight_left=turnetu maldekstren
-turn_slight_right=turnetu dekstren
-turn_sharp_left=turnegu maldekstren
-turn_sharp_right=turnegu dekstren
+continue=pluu
+continue_onto=pluu laŭlonge de %1$s
+turn_left=turniĝu maldekstren
+turn_right=turniĝu dekstren
+turn_slight_left=turniĝetu maldekstren
+turn_slight_right=turniĝetu dekstren
+turn_sharp_left=turniĝegu maldekstren
+turn_sharp_right=turniĝegu dekstren
 keep_left=veturu ĉe maldekstra flanko
 keep_right=veturu ĉe dekstra fllanko
 turn_onto=%1$s al %2$s
 u_turn=faru ĝiradon U-forma
-unknown=nekonata instrukcio '%1$s'
+unknown=nekonata instrukcio ‘%1$s’
 web.search_button=Serĉi
 web.from_hint=El
 web.via_hint=Tra
diff --git a/core/src/main/resources/com/graphhopper/util/fr_CH.txt b/core/src/main/resources/com/graphhopper/util/fr_CH.txt
index c24738bb15..8e0250b17c 100644
--- a/core/src/main/resources/com/graphhopper/util/fr_CH.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr_CH.txt
@@ -8,11 +8,11 @@ turn_slight_left=tournez légèrement à gauche
 turn_slight_right=tournez légèrement à droite
 turn_sharp_left=tournez fort à gauche
 turn_sharp_right=tournez fort à droite
-keep_left=
-keep_right=
+keep_left=restez sur la gauche
+keep_right=restez sur la droite
 turn_onto=%1$s sur %2$s
-u_turn=
-unknown=
+u_turn=faites demi-tour
+unknown=indication inconnue '%1$s'
 web.search_button=Rechercher
 web.from_hint=De
 web.via_hint=Via
@@ -20,8 +20,8 @@ web.to_hint=À
 web.more_button=plus
 web.gpx_export_button=Export GPX
 web.route_info=%1$s durera %2$s 
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=arrivée à %1$s avec %2$s changements (%3$s)
+web.pt_route_info_walking=arrivée à pied à %1$s (%2$s)
 web.locations_not_found=Calcul d'itinéraire impossible. Position(s) non trouvée(s) dans la zone.
 web.bike=Vélo
 web.racingbike=Vélo de course
@@ -56,10 +56,10 @@ roundabout_exit=Au giratoire, prenez la %1$s sortie
 roundabout_exit_onto=Au giratoire, prenez la %1$s sortie vers %2$s
 total_ascend=%1$s de dénivelé positif
 total_descend=%1$s de dénivelé négatif
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=cet itinéraire comprend un passage à gué
+pt_start_trip=montez dans %1$s
+pt_end_trip=descendez de %1$s
+pt_transfer_to=changez vers %1$s
 web.start_label=Départ
 web.intermediate_label=Point intermédiaire
 web.end_label=Arrivée
diff --git a/core/src/main/resources/com/graphhopper/util/fr_FR.txt b/core/src/main/resources/com/graphhopper/util/fr_FR.txt
index ba4e074d51..b44ef193e7 100644
--- a/core/src/main/resources/com/graphhopper/util/fr_FR.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr_FR.txt
@@ -8,11 +8,11 @@ turn_slight_left=tournez légèrement à gauche
 turn_slight_right=tournez légèrement à droite
 turn_sharp_left=tournez fort à gauche
 turn_sharp_right=tournez fort à droite
-keep_left=
-keep_right=
+keep_left=restez sur la gauche
+keep_right=restez sur la droite
 turn_onto=%1$s sur %2$s
-u_turn=
-unknown=
+u_turn=faites demi-tour
+unknown=indication inconnue '%1$s'
 web.search_button=Rechercher
 web.from_hint=De
 web.via_hint=Via
@@ -20,8 +20,8 @@ web.to_hint=À
 web.more_button=plus
 web.gpx_export_button=Export GPX
 web.route_info=%1$s durera %2$s 
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=arrivée à %1$s avec %2$s changements (%3$s)
+web.pt_route_info_walking=arrivée à pied à %1$s (%2$s)
 web.locations_not_found=Calcul d'itinéraire impossible. Position(s) non trouvée(s) dans la zone.
 web.bike=Vélo
 web.racingbike=Vélo de course
@@ -56,10 +56,10 @@ roundabout_exit=Au rond-point, prenez la %1$s sortie
 roundabout_exit_onto=Au rond-point, prenez la %1$s sortie vers %2$s
 total_ascend=%1$s de dénivelé positif
 total_descend=%1$s de dénivelé négatif
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=cet itinéraire comprend un passage à gué
+pt_start_trip=montez dans %1$s
+pt_end_trip=descendez de %1$s
+pt_transfer_to=changez vers %1$s
 web.start_label=Départ
 web.intermediate_label=Point intermédiaire
 web.end_label=Arrivée
diff --git a/core/src/main/resources/com/graphhopper/util/he.txt b/core/src/main/resources/com/graphhopper/util/he.txt
index 0046ef7509..6f18866aca 100644
--- a/core/src/main/resources/com/graphhopper/util/he.txt
+++ b/core/src/main/resources/com/graphhopper/util/he.txt
@@ -8,11 +8,11 @@ turn_slight_left=מעט שמאלה
 turn_slight_right=מעט ימינה
 turn_sharp_left=שמאלה בחדות
 turn_sharp_right=ימינה בחדות
-keep_left=
-keep_right=
+keep_left=להיצמד לשמאל
+keep_right=להיצמד לימין
 turn_onto=יש לפנות %1$s לתוך %2$s
-u_turn=
-unknown=
+u_turn=לבצע פניית פרסה
+unknown=שלט הנחייה לא מוכר '%1$s'
 web.search_button=חיפוש
 web.from_hint=מוצא
 web.via_hint=דרך
@@ -20,8 +20,8 @@ web.to_hint=יעד
 web.more_button=עוד
 web.gpx_export_button=ייצוא GPX
 web.route_info=%1$s ייקחו %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=מגיע ב־%1$s עם %2$s החלפות (%3$s)
+web.pt_route_info_walking=מגיע ב־%1$s עם הליכה (%3$s)
 web.locations_not_found=אין נתיב ישיר אל היעד. המיקום לא נמצא באזור.
 web.bike=אופניים
 web.racingbike=מסלולי אופניים
@@ -35,7 +35,7 @@ web.truck=משאית
 web.staticlink=קישור קבוע
 web.motorcycle=אופנוע
 via=דרך
-finish=סיימת!
+finish=הגעת ליעד
 hour_abbr=שע׳
 day_abbr=דק׳
 min_abbr=דקות
@@ -56,10 +56,10 @@ roundabout_exit=בכיכר, יש לצאת ביציאה %1$s
 roundabout_exit_onto=בכיכר, יש לצאת ביציאה %1$s לתוך %2$s
 total_ascend=עלייה כוללת של %1$s
 total_descend=ירידה כוללת של %1$s
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=יש מעבר מים לאורך הדרך
+pt_start_trip=יש להיכנס אל %1$s
+pt_end_trip=יש לצאת מ%1$s
+pt_transfer_to=להחליף ל%1$s
 web.start_label=התחלה
 web.intermediate_label=אמצע
 web.end_label=סוף
@@ -76,4 +76,4 @@ web.refresh_button=רענון הדף
 web.server_status=מצב
 web.zoom_in=התקרבות
 web.zoom_out=התרחקות
-web.drag_to_reorder=
+web.drag_to_reorder=יש לגרור כדי לסדר מחדש
diff --git a/core/src/main/resources/com/graphhopper/util/sl_SI.txt b/core/src/main/resources/com/graphhopper/util/sl_SI.txt
index b776a33f4a..cae4ead2bd 100644
--- a/core/src/main/resources/com/graphhopper/util/sl_SI.txt
+++ b/core/src/main/resources/com/graphhopper/util/sl_SI.txt
@@ -66,7 +66,7 @@ web.end_label=Končna točka
 web.set_start=Nastavi kot začetno točko
 web.set_intermediate=Nastavi kot vmesno točko
 web.set_end=Nastavi kot končno točko
-web.center_map=Premakni na srednino
+web.center_map=Premakni na sredino
 web.show_coords=Prikaži koordinate
 web.route=Pot
 web.delete_from_route=Izbriši iz poti
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
index 6f4e5544ec..6f7646a1b1 100644
--- a/core/src/main/resources/com/graphhopper/util/uk.txt
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -6,8 +6,8 @@ turn_left=Поверніть ліворуч
 turn_right=Поверніть праворуч
 turn_slight_left=Поверніть трохи лівіше
 turn_slight_right=Поверніть трохи правіше
-turn_sharp_left=Поверніть різко ліворуч
-turn_sharp_right=Поверніть різко праворуч
+turn_sharp_left=Різко поверніть ліворуч
+turn_sharp_right=Різко поверніть праворуч
 keep_left=
 keep_right=
 turn_onto=%1$s на „%2$s“
diff --git a/core/src/main/resources/com/graphhopper/util/zh_HK.txt b/core/src/main/resources/com/graphhopper/util/zh_HK.txt
index cfd1a7c02c..b9f7c630bc 100644
--- a/core/src/main/resources/com/graphhopper/util/zh_HK.txt
+++ b/core/src/main/resources/com/graphhopper/util/zh_HK.txt
@@ -53,7 +53,7 @@ unpaved=
 stopover=中途站 %1$s
 roundabout_enter=進入迴旋處
 roundabout_exit=使用 %1$s 出口離開迴旋處
-roundabout_exit_onto=使用 %1$s 出口離開迴旋處到 %2$s 
+roundabout_exit_onto=使用 %1$s 出口離開迴旋處到 %2$s
 total_ascend=總共上昇 %1$s
 total_descend=總共下降 %1$s
 way_contains_ford=
diff --git a/core/src/test/java/com/graphhopper/reader/PrinctonReader.java b/core/src/test/java/com/graphhopper/reader/PrincetonReader.java
similarity index 86%
rename from core/src/test/java/com/graphhopper/reader/PrinctonReader.java
rename to core/src/test/java/com/graphhopper/reader/PrincetonReader.java
index 13f3084157..126cbd97cd 100644
--- a/core/src/test/java/com/graphhopper/reader/PrinctonReader.java
+++ b/core/src/test/java/com/graphhopper/reader/PrincetonReader.java
@@ -25,20 +25,20 @@
 import java.io.InputStreamReader;
 
 /**
- * Data taken from here http://algs4.cs.princeton.edu/44sp/
- * <p>
+ * This reader implementation allows to read graph definitions from text files in the format used on
+ * http://algs4.cs.princeton.edu/44sp/.
  *
  * @author Peter Karich
  */
-public class PrinctonReader {
-    private Graph g;
+public class PrincetonReader {
+    private Graph graph;
     private InputStream is;
 
-    public PrinctonReader(Graph graph) {
-        g = graph;
+    public PrincetonReader(Graph graph) {
+        this.graph = graph;
     }
 
-    public PrinctonReader setStream(InputStream is) {
+    public PrincetonReader setStream(InputStream is) {
         this.is = is;
         return this;
     }
@@ -57,7 +57,7 @@ public void read() {
                 if (line == null)
                     throw new IllegalStateException("Cannot read line " + lineNo);
 
-                String args[] = line.split(" ");
+                String[] args = line.split(" ");
                 int from = -1;
                 int to = -1;
                 double dist = -1;
@@ -81,7 +81,7 @@ public void read() {
                     throw new RuntimeException("incorrect read!? from:" + from + ", to:" + to + ", dist:" + dist);
                 }
 
-                g.edge(from, to, dist, false);
+                graph.edge(from, to, dist, false);
             }
         } catch (Exception ex) {
             throw new RuntimeException("Problem in line " + lineNo, ex);
diff --git a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java b/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java
similarity index 86%
rename from core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
rename to core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java
index ac6d083f4b..0be5f184f0 100644
--- a/core/src/test/java/com/graphhopper/reader/PrinctonReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java
@@ -32,16 +32,18 @@
 import static org.junit.Assert.assertEquals;
 
 /**
+ * The data is taken from https://algs4.cs.princeton.edu/44sp/.
+ *
  * @author Peter Karich
  */
-public class PrinctonReaderTest {
+public class PrincetonReaderTest {
     private EncodingManager encodingManager = new EncodingManager("car");
     private EdgeFilter carOutEdges = new DefaultEdgeFilter(encodingManager.getEncoder("car"), false, true);
 
     @Test
     public void testRead() {
         Graph graph = new GraphBuilder(encodingManager).create();
-        new PrinctonReader(graph).setStream(PrinctonReader.class.getResourceAsStream("tinyEWD.txt")).read();
+        new PrincetonReader(graph).setStream(PrincetonReader.class.getResourceAsStream("tinyEWD.txt")).read();
         assertEquals(8, graph.getNodes());
         EdgeExplorer explorer = graph.createEdgeExplorer(carOutEdges);
         assertEquals(2, count(explorer.setBaseNode(0)));
@@ -51,7 +53,7 @@ public void testRead() {
     @Test
     public void testMediumRead() throws IOException {
         Graph graph = new GraphBuilder(encodingManager).create();
-        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream("mediumEWD.txt.gz"))).read();
+        new PrincetonReader(graph).setStream(new GZIPInputStream(PrincetonReader.class.getResourceAsStream("mediumEWD.txt.gz"))).read();
         assertEquals(250, graph.getNodes());
         EdgeExplorer explorer = graph.createEdgeExplorer(carOutEdges);
         assertEquals(13, count(explorer.setBaseNode(244)));
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
similarity index 61%
rename from core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
rename to core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
index f50a5b37fa..112c13e10b 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
@@ -15,9 +15,10 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.ch;
+package com.graphhopper.routing;
 
-import com.graphhopper.routing.*;
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
@@ -166,4 +167,106 @@ public void testBaseGraphMultipleVehicles() {
         assertEquals(p3.toString(), 12240 * 1000, p3.getTime());
         assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
     }
+
+    // 7------8------.---9----0
+    // |      | \    |   |
+    // 6------   |   |   |
+    // |      |  1   |   |
+    // 5------   |   |  /
+    // |  _,--|   2  | /
+    // |/         |  |/
+    // 4----------3--/
+    @Test
+    public void testStallingNodesReducesNumberOfVisitedNodes() {
+        GraphHopperStorage graph = createGHStorage(false);
+        graph.edge(8, 9, 100, false);
+        graph.edge(8, 3, 2, false);
+        graph.edge(8, 5, 1, false);
+        graph.edge(8, 6, 1, false);
+        graph.edge(8, 7, 1, false);
+        graph.edge(1, 2, 2, false);
+        graph.edge(1, 8, 1, false);
+        graph.edge(2, 3, 3, false);
+        for (int i = 3; i < 7; ++i) {
+            graph.edge(i, i + 1, 1, false);
+        }
+        graph.edge(9, 0, 1, false);
+        graph.edge(3, 9, 200, false);
+        CHGraph chGraph = graph.getGraph(CHGraph.class);
+
+        // explicitly set the node levels equal to the node ids
+        // the graph contraction with this ordering yields no shortcuts
+        for (int i = 0; i < 10; ++i) {
+            chGraph.setLevel(i, i);
+        }
+        graph.freeze();
+        RoutingAlgorithm algo = createCHAlgo(graph, chGraph, true, defaultOpts);
+        Path p = algo.calcPath(1, 0);
+        // node 3 will be stalled and nodes 4-7 won't be explored --> we visit 7 nodes
+        // note that node 9 will be visited by both forward and backward searches
+        assertEquals(7, algo.getVisitedNodes());
+        assertEquals(102, p.getDistance(), 1.e-3);
+        assertEquals(p.toString(), Helper.createTList(1, 8, 9, 0), p.calcNodes());
+
+        // without stalling we visit 11 nodes
+        RoutingAlgorithm algoNoSod = createCHAlgo(graph, chGraph, false, defaultOpts);
+        Path pNoSod = algoNoSod.calcPath(1, 0);
+        assertEquals(11, algoNoSod.getVisitedNodes());
+        assertEquals(102, pNoSod.getDistance(), 1.e-3);
+        assertEquals(pNoSod.toString(), Helper.createTList(1, 8, 9, 0), pNoSod.calcNodes());
+    }
+
+    // t(0)--slow->1--s(2)
+    //    \        |
+    //    fast     |
+    //      \--<---|
+    @Test
+    public void testDirectionDependentSpeedFwdSearch() {
+        runTestWithDirectionDependentEdgeSpeed(10, 20, 0, 2, Helper.createTList(0, 1, 2), new MotorcycleFlagEncoder());
+        runTestWithDirectionDependentEdgeSpeed(10, 20, 0, 2, Helper.createTList(0, 1, 2), new Bike2WeightFlagEncoder());
+    }
+
+    // s(0)--fast->1--t(2)
+    //    \        |
+    //    slow     |
+    //      \--<---|
+    @Test
+    public void testDirectionDependentSpeedBwdSearch() {
+        runTestWithDirectionDependentEdgeSpeed(20, 10, 2, 0, Helper.createTList(2, 1, 0), new MotorcycleFlagEncoder());
+        runTestWithDirectionDependentEdgeSpeed(20, 10, 2, 0, Helper.createTList(2, 1, 0), new Bike2WeightFlagEncoder());
+    }
+
+    private void runTestWithDirectionDependentEdgeSpeed(
+            int speed, int revSpeed, int from, int to, IntArrayList expectedPath, FlagEncoder encoder) {
+        EncodingManager encodingManager = new EncodingManager(encoder);
+        FastestWeighting weighting = new FastestWeighting(encoder);
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().weighting(weighting).build();
+        GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(weighting), false);
+        EdgeIteratorState edge = graph.edge(0, 1, 2, true);
+        long flags = edge.getFlags();
+        flags = encoder.setSpeed(flags, speed);
+        flags = encoder.setReverseSpeed(flags, revSpeed);
+        edge.setFlags(flags);
+        graph.edge(1, 2, 1, true);
+
+        CHGraph chGraph = graph.getGraph(CHGraph.class);
+        for (int i = 0; i < 3; ++i) {
+            chGraph.setLevel(i, i);
+        }
+        graph.freeze();
+
+        RoutingAlgorithm algo = createCHAlgo(graph, chGraph, true, algoOpts);
+        Path p = algo.calcPath(from, to);
+        assertEquals(3, p.getDistance(), 1.e-3);
+        assertEquals(p.toString(), expectedPath, p.calcNodes());
+    }
+
+    private RoutingAlgorithm createCHAlgo(GraphHopperStorage graph, CHGraph chGraph, boolean withSOD, AlgorithmOptions algorithmOptions) {
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
+                graph, chGraph, algorithmOptions.getWeighting(), TraversalMode.NODE_BASED);
+        if (!withSOD) {
+            algorithmOptions.getHints().put("stall_on_demand", false);
+        }
+        return ch.createAlgo(chGraph, algorithmOptions);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 2934af778a..c2df7a627d 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -284,7 +284,7 @@ public void testCalcAverageSpeedDetails() {
         Path p = new Dijkstra(pathDetailGraph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).calcPath(1, 5);
         assertTrue(p.isFound());
 
-        Map<String, List<PathDetail>> details = p.calcDetails(new PathDetailsBuilderFactory(Arrays.asList(new String[]{AVERAGE_SPEED}), encoder, new FastestWeighting(encoder)), 0);
+        Map<String, List<PathDetail>> details = p.calcDetails(Arrays.asList(new String[]{AVERAGE_SPEED}), new PathDetailsBuilderFactory(), 0);
         assertTrue(details.size() == 1);
 
         List<PathDetail> averageSpeedDetails = details.get(AVERAGE_SPEED);
@@ -306,7 +306,7 @@ public void testCalcStreetNameDetails() {
         Path p = new Dijkstra(pathDetailGraph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).calcPath(1, 5);
         assertTrue(p.isFound());
 
-        Map<String, List<PathDetail>> details = p.calcDetails(new PathDetailsBuilderFactory(Arrays.asList(new String[]{STREET_NAME}), encoder, new FastestWeighting(encoder)), 0);
+        Map<String, List<PathDetail>> details = p.calcDetails(Arrays.asList(new String[]{STREET_NAME}), new PathDetailsBuilderFactory(), 0);
         assertTrue(details.size() == 1);
 
         List<PathDetail> streetNameDetails = details.get(STREET_NAME);
@@ -330,7 +330,7 @@ public void testCalcEdgeIdDetails() {
         Path p = new Dijkstra(pathDetailGraph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).calcPath(1, 5);
         assertTrue(p.isFound());
 
-        Map<String, List<PathDetail>> details = p.calcDetails(new PathDetailsBuilderFactory(Arrays.asList(new String[]{EDGE_ID}), encoder, new FastestWeighting(encoder)), 0);
+        Map<String, List<PathDetail>> details = p.calcDetails(Arrays.asList(new String[]{EDGE_ID}), new PathDetailsBuilderFactory(), 0);
         assertTrue(details.size() == 1);
 
         List<PathDetail> edgeIdDetails = details.get(EDGE_ID);
@@ -353,7 +353,7 @@ public void testCalcTimeDetails() {
         Path p = new Dijkstra(pathDetailGraph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).calcPath(1, 5);
         assertTrue(p.isFound());
 
-        Map<String, List<PathDetail>> details = p.calcDetails(new PathDetailsBuilderFactory(Arrays.asList(new String[]{TIME}), encoder, new FastestWeighting(encoder)), 0);
+        Map<String, List<PathDetail>> details = p.calcDetails(Arrays.asList(new String[]{TIME}), new PathDetailsBuilderFactory(), 0);
         assertTrue(details.size() == 1);
 
         List<PathDetail> timeDetails = details.get(TIME);
@@ -538,7 +538,7 @@ public void testCalcInstructionForForkWithSameName() {
         InstructionList wayList = p.calcInstructions(tr);
 
         assertEquals(3, wayList.size());
-        assertEquals(-1, wayList.get(1).getSign());
+        assertEquals(-7, wayList.get(1).getSign());
     }
 
     @Test
@@ -565,7 +565,7 @@ public void testCalcInstructionContinueLeavingStreet() {
         InstructionList wayList = p.calcInstructions(tr);
 
         assertEquals(3, wayList.size());
-        assertEquals(-1, wayList.get(1).getSign());
+        assertEquals(-7, wayList.get(1).getSign());
     }
 
     @Test
@@ -645,7 +645,7 @@ public void testCalcInstructionsForSlightTurnWithOtherSlightTurn() {
         // Contain start, turn, and finish instruction
         assertEquals(3, wayList.size());
         // Assert turn right
-        assertEquals(1, wayList.get(1).getSign());
+        assertEquals(7, wayList.get(1).getSign());
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 8763da972b..31375af0b1 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -18,7 +18,7 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.GraphHopper;
-import com.graphhopper.reader.PrinctonReader;
+import com.graphhopper.reader.PrincetonReader;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.HintsMap;
@@ -130,7 +130,7 @@ public void testPerformance() throws IOException {
         final GraphHopperStorage graph = new GraphBuilder(eManager).create();
 
         String bigFile = "10000EWD.txt.gz";
-        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile))).read();
+        new PrincetonReader(graph).setStream(new GZIPInputStream(PrincetonReader.class.getResourceAsStream(bigFile))).read();
         GraphHopper hopper = new GraphHopper() {
             {
                 setCHEnabled(false);
diff --git a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
index 602d6374fb..7632ef9c2d 100644
--- a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
@@ -23,17 +23,20 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
+import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static org.junit.Assert.assertEquals;
 
@@ -45,13 +48,63 @@
     private final EncodingManager em = new EncodingManager(carFE);
     // TODO private final TraversalMode tMode = TraversalMode.EDGE_BASED_2DIR;
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
+    private final GHPoint ghPoint1 = new GHPoint(0, 0);
+    private final GHPoint ghPoint2 = new GHPoint(1, 1);
+
+    @Test(expected = IllegalArgumentException.class)
+    public void lookup_throwsIfNumberOfGivenPointsNotOne() {
+        RoundTripRoutingTemplate routingTemplate = new RoundTripRoutingTemplate(
+                new GHRequest(Collections.singletonList(ghPoint1)), new GHResponse(), null, 1);
+        routingTemplate.lookup(Arrays.asList(ghPoint1, ghPoint2), carFE);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void lookup_throwsIfNumberOfPointsInRequestNotOne() {
+        RoundTripRoutingTemplate routingTemplate = new RoundTripRoutingTemplate(
+                new GHRequest(Arrays.asList(ghPoint1, ghPoint2)), new GHResponse(), null, 1);
+        routingTemplate.lookup(Collections.singletonList(ghPoint1), carFE);
+    }
+
+    @Test
+    public void testLookupAndCalcPaths_simpleSquareGraph() {
+        Graph g = createSquareGraph();
+        // start at node 0 and head south, make sure the round trip is long enough to reach most southern node 6
+        GHPoint start = new GHPoint(1, -1);
+        double heading = 180.0;
+        int numPoints = 2;
+        double roundTripDistance = 670000;
+
+        GHRequest ghRequest =
+                new GHRequest(Collections.singletonList(start), Collections.singletonList(heading));
+        ghRequest.getHints().put(Parameters.Algorithms.RoundTrip.POINTS, numPoints);
+        ghRequest.getHints().put(Parameters.Algorithms.RoundTrip.DISTANCE, roundTripDistance);
+        LocationIndex locationIndex = new LocationIndexTree(g, new RAMDirectory()).prepareIndex();
+        RoundTripRoutingTemplate routingTemplate =
+                new RoundTripRoutingTemplate(ghRequest, new GHResponse(), locationIndex, 1);
+        List<QueryResult> stagePoints = routingTemplate.lookup(ghRequest.getPoints(), carFE);
+        assertEquals(3, stagePoints.size());
+        assertEquals(0, stagePoints.get(0).getClosestNode());
+        assertEquals(6, stagePoints.get(1).getClosestNode());
+        assertEquals(0, stagePoints.get(2).getClosestNode());
+
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(stagePoints);
+        Weighting weighting = new FastestWeighting(carFE);
+        List<Path> paths = routingTemplate.calcPaths(
+                queryGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
+        // make sure the resulting paths are connected and form a round trip starting and ending at the start node 0
+        assertEquals(2, paths.size());
+        assertEquals(Helper.createTList(0, 7, 6, 5), paths.get(0).calcNodes());
+        assertEquals(Helper.createTList(5, 4, 3, 2, 1, 0), paths.get(1).calcNodes());
+    }
 
     @Test
     public void testCalcRoundTrip() throws Exception {
         Weighting weighting = new FastestWeighting(carFE);
         Graph g = createTestGraph(true);
 
-        RoundTripRoutingTemplate rTripRouting = new RoundTripRoutingTemplate(new GHRequest(), new GHResponse(), null, 1);
+        RoundTripRoutingTemplate rTripRouting =
+                new RoundTripRoutingTemplate(new GHRequest(), new GHResponse(), null, 1);
 
         LocationIndex locationIndex = new LocationIndexTree(g, new RAMDirectory()).prepareIndex();
         QueryResult qr4 = locationIndex.findClosest(0.05, 0.25, EdgeFilter.ALL_EDGES);
@@ -64,7 +117,8 @@ public void testCalcRoundTrip() throws Exception {
         QueryGraph qGraph = new QueryGraph(g);
         qGraph.lookup(qr4, qr5);
         rTripRouting.setQueryResults(Arrays.asList(qr5, qr4, qr5));
-        List<Path> paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
+        List<Path> paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(),
+                new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         assertEquals(2, paths.size());
         assertEquals(Helper.createTList(5, 6, 3, 4), paths.get(0).calcNodes());
         assertEquals(Helper.createTList(4, 8, 7, 6, 5), paths.get(1).calcNodes());
@@ -72,7 +126,8 @@ public void testCalcRoundTrip() throws Exception {
         qGraph = new QueryGraph(g);
         qGraph.lookup(qr4, qr6);
         rTripRouting.setQueryResults(Arrays.asList(qr6, qr4, qr6));
-        paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(), new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
+        paths = rTripRouting.calcPaths(qGraph, new RoutingAlgorithmFactorySimple(),
+                new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         assertEquals(2, paths.size());
         assertEquals(Helper.createTList(6, 3, 4), paths.get(0).calcNodes());
         assertEquals(Helper.createTList(4, 8, 7, 6), paths.get(1).calcNodes());
@@ -81,4 +136,28 @@ public void testCalcRoundTrip() throws Exception {
     private Graph createTestGraph(boolean fullGraph) {
         return new AlternativeRouteTest(tMode).createTestGraph(fullGraph, em);
     }
+
+    private Graph createSquareGraph() {
+        // simple square
+        //  1 | 0 1 2      
+        //  0 | 7   3
+        // -1 | 6 5 4 
+        // ---|------
+        //    |-1 0 1
+        GraphHopperStorage graph =
+                new GraphHopperStorage(new RAMDirectory(), em, false, new GraphExtension.NoOpExtension());
+        graph.create(1000);
+        for (int i = 0; i < 8; ++i) {
+            graph.edge(i, (i + 1) % 8, 1, true);
+        }
+        updateDistancesFor(graph, 0, 1, -1);
+        updateDistancesFor(graph, 1, 1, 0);
+        updateDistancesFor(graph, 2, 1, 1);
+        updateDistancesFor(graph, 3, 0, 1);
+        updateDistancesFor(graph, 4, -1, 1);
+        updateDistancesFor(graph, 5, -1, 0);
+        updateDistancesFor(graph, 6, -1, -1);
+        updateDistancesFor(graph, 7, 0, -1);
+        return graph;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index e3d7e35df6..3d3b0c247b 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -291,6 +291,12 @@ public void testHandleWayTags() {
         way.setTag("highway", "tertiary");
         long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
         assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+
+        way.clearTags();
+        way.setTag("junction", "circular");
+        way.setTag("highway", "tertiary");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 9e656ed086..43f2b7aeef 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -373,6 +373,14 @@ public void testRoundabout() {
         assertTrue(encoder.isForward(flags));
         assertFalse(encoder.isBackward(flags));
         assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+
+        way.clearTags();
+        way.setTag("highway", "motorway");
+        way.setTag("junction", "circular");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
index 2db0b2f654..aa7c72207c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
@@ -141,6 +141,16 @@ public void testFord() {
         assertTrue(encoder.getAnnotation(edge.getFlags(), TranslationMapTest.SINGLETON.get("en")).getMessage().contains("ford"));
     }
 
+    @Test
+    public void testCircularJunction() {
+        ReaderWay osmWay = new ReaderWay(0);
+        osmWay.setTag("highway", "unclassified");
+        osmWay.setTag("junction", "circular");
+        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
+        assertTrue(encoder.isRoundabout(edge));
+    }
+
     @Test
     public void testHighwaySpeed() {
         Map<String, Double> map = new LinkedHashMap<>();
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 4e6a073211..5ebab08cd3 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -368,6 +368,15 @@ public void handleWayTagsRoundabout() {
         assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
+    @Test
+    public void handleWayTagsCircularJunction() {
+        ReaderWay way = new ReaderWay(1);
+        way.setTag("junction", "circular");
+        way.setTag("highway", "tertiary");
+        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+    }
+
     public void testFord() {
         // by default deny access through fords!
         ReaderNode node = new ReaderNode(1, -1, -1);
diff --git a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 8e84e1cd61..7ed2d3e0ce 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -134,6 +134,41 @@ public void testHandleWayTags() {
         assertEquals(20, encoder.getReverseSpeed(result), .1);
     }
 
+    @Test
+    public void testRoundabout() {
+        long flags = encoder.setAccess(0, true, true);
+        long resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, true);
+        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
+
+        resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, false);
+        assertFalse(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
+
+        ReaderWay way = new ReaderWay(1);
+        way.setTag("highway", "motorway");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        assertFalse(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+
+        way.setTag("junction", "roundabout");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+
+        way.clearTags();
+        way.setTag("highway", "motorway");
+        way.setTag("junction", "circular");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+    }
+
     @Test
     public void testSetSpeed0_issue367() {
         long flags = encoder.setProperties(10, true, true);
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index 0a2e98f8df..c8f6d44f8e 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -36,7 +36,7 @@
 
 /**
  * Abstract test class to be extended for implementations of the Graph interface. Graphs
- * implementing GraphStorage should extend GraphStorageTest instead.
+ * implementing GraphStorage should extend {@link GraphHopperStorageTest} instead.
  * <p>
  *
  * @author Peter Karich
diff --git a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
index ca84b73727..d9114eb994 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
@@ -62,7 +62,7 @@ public void testParseStringHints() {
                 .prepareIndex();
 
         GraphEdgeIdFinder graphFinder = new GraphEdgeIdFinder(graph, locationIndex);
-        GraphEdgeIdFinder.BlockArea blockArea = graphFinder.parseBlockArea("0.01,0.005,1", new DefaultEdgeFilter(encoder));
+        GraphEdgeIdFinder.BlockArea blockArea = graphFinder.parseBlockArea("0.01,0.005,1", new DefaultEdgeFilter(encoder), 1000 * 1000);
 
         GHIntHashSet blockedEdges = new GHIntHashSet();
         blockedEdges.add(0);
@@ -72,7 +72,7 @@ public void testParseStringHints() {
 
         // big area converts into shapes
         graphFinder = new GraphEdgeIdFinder(graph, locationIndex);
-        blockArea = graphFinder.parseBlockArea("0,0,1000", new DefaultEdgeFilter(encoder));
+        blockArea = graphFinder.parseBlockArea("0,0,1000", new DefaultEdgeFilter(encoder), 1000 * 1000);
         blockedEdges.clear();
         assertEquals(blockedEdges, blockArea.blockedEdges);
         blockedShapes.add(new Circle(0, 0, 1000));
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index 3c110ecf1e..200806f488 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -56,7 +56,7 @@ public void testCannotBeLoadedWithNormalGraphHopperStorageClass() {
         graph = new GraphBuilder(encodingManager).setLocation(defaultGraphLoc).setMmap(false).setStore(true).create();
         try {
             graph.loadExisting();
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
         }
 
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index e5f1f3fb1a..244d3c5cf2 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -233,7 +233,7 @@ public void testWayList2() {
         p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(usTR);
         tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 3-4", "Turn slight right onto 4-5", "Arrive at destination"),
+        assertEquals(Arrays.asList("Continue onto 3-4", "Keep right onto 4-5", "Arrive at destination"),
                 tmpList);
     }
 
@@ -387,6 +387,47 @@ public void testRoundaboutJsonNaN() {
         assertNotNull(write(json));
     }
 
+    @Test
+    public void testCreateGPXIncludesRoundaboutExitNumber() {
+        InstructionList instructions = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.555423473315, 13.43890086052345);
+        pl.add(52.555550691982, 13.43946393816465);
+        pl.add(52.555619423589, 13.43886994061328);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                InstructionAnnotation.EMPTY, pl)
+                .setRadian(2.058006514284998d)
+                .setExitNumber(3)
+                .setExited();
+        instructions.add(instr);
+        instructions.add(new FinishInstruction(52.555619423589, 13.43886994061328, 0));
+
+        String gpxStr = instructions.createGPX("test", 0, true, true, false, false);
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:exit_number>3</gh:exit_number>"));
+        verifyGPX(gpxStr);
+    }
+
+    @Test
+    public void testCreateGPXCorrectFormattingSmallNumbers() {
+        InstructionList instructions = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(0.000001, 0.000001);
+        pl.add(-0.000123, -0.000125);
+        Instruction instruction = new Instruction(0, "do it", null, pl);
+        instructions.add(instruction);
+        instructions.add(new FinishInstruction(0.000852, 0.000852, 0));
+
+        String gpxStr = instructions.createGPX("test", 0, true, true, true, true);
+
+        assertFalse(gpxStr, gpxStr.contains("E-"));
+        assertTrue(gpxStr, gpxStr.contains("0.000001"));
+        assertTrue(gpxStr, gpxStr.contains("-0.000125"));
+        verifyGPX(gpxStr);
+    }
+
     @Test
     public void testCreateGPXWithEle() {
         final List<GPXEntry> fakeList = new ArrayList<GPXEntry>();
diff --git a/core/src/test/java/com/graphhopper/util/PathSimplificationTest.java b/core/src/test/java/com/graphhopper/util/PathSimplificationTest.java
index 51ba0f6707..c0d012518d 100644
--- a/core/src/test/java/com/graphhopper/util/PathSimplificationTest.java
+++ b/core/src/test/java/com/graphhopper/util/PathSimplificationTest.java
@@ -25,7 +25,6 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
@@ -137,7 +136,7 @@ public void testScenario() {
         // Path is: [0 0-1, 3 1-4, 6 4-7, 9 7-8, 11 8-9, 10 9-10]
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 10);
         InstructionList wayList = p.calcInstructions(usTR);
-        Map<String, List<PathDetail>> details = p.calcDetails(new PathDetailsBuilderFactory(Arrays.asList(DETAILS.AVERAGE_SPEED), carEncoder, new FastestWeighting(carEncoder)), 0);
+        Map<String, List<PathDetail>> details = p.calcDetails(Arrays.asList(DETAILS.AVERAGE_SPEED), new PathDetailsBuilderFactory(), 0);
 
         PathWrapper pathWrapper = new PathWrapper();
         pathWrapper.setInstructions(wayList);
@@ -155,6 +154,11 @@ public void testScenario() {
 
         assertEquals(numberOfPoints, pathWrapper.getPoints().size());
 
+        pathWrapper = new PathWrapper();
+        pathWrapper.setInstructions(wayList);
+        pathWrapper.addPathDetails(details);
+        pathWrapper.setPoints(p.calcPoints());
+
         douglasPeucker.setMaxDistance(100000000);
         ps = new PathSimplification(pathWrapper, douglasPeucker, true);
         ps.simplify();
diff --git a/core/src/test/java/com/graphhopper/util/PointListTest.java b/core/src/test/java/com/graphhopper/util/PointListTest.java
index fa1c91c7ad..beaa879c1e 100644
--- a/core/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/core/src/test/java/com/graphhopper/util/PointListTest.java
@@ -20,7 +20,11 @@
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
+import java.util.Arrays;
+
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
@@ -95,4 +99,126 @@ public void testIterable() {
             assertEquals(counter, point.getLat(), 0.1);
         }
     }
+
+    @Test
+    public void testCopy_issue1166() {
+        PointList list = new PointList(20, false);
+        for (int i = 0; i < 10; i++) {
+            list.add(1, i);
+        }
+        assertEquals(10, list.getSize());
+        assertEquals(20, list.getCapacity());
+
+        PointList copy = list.copy(9, 10);
+        assertEquals(1, copy.getSize());
+        assertEquals(1, copy.getCapacity());
+        assertEquals(9, copy.getLongitude(0), .1);
+    }
+
+    @Test
+    public void testShallowCopy() {
+        PointList pl1 = new PointList(100, true);
+        for (int i = 0; i < 1000; i++) {
+            pl1.add(i, i, 0);
+        }
+
+        PointList pl2 = pl1.shallowCopy(100, 600, false);
+        assertEquals(500, pl2.size());
+        for (int i = 0; i < pl2.size(); i++) {
+            assertEquals(pl1.getLat(i + 100), pl2.getLat(i), .01);
+        }
+
+        // If you change the original PointList the shallow copy changes as well
+        pl1.set(100, 0, 0, 0);
+        assertEquals(0, pl2.getLat(0), .01);
+
+        // Create a shallow copy of the shallow copy
+        PointList pl3 = pl2.shallowCopy(0, 100, true);
+        // If we create a safe shallow copy of pl2, we have to make pl1 immutable
+        assertTrue(pl1.isImmutable());
+        assertEquals(100, pl3.size());
+        for (int i = 0; i < pl3.size(); i++) {
+            assertEquals(pl2.getLon(i), pl3.getLon(i), .01);
+        }
+
+        PointList pl4 = pl1.shallowCopy(0, pl1.size(), false);
+        assertTrue(pl1.equals(pl4));
+
+        PointList pl5 = pl1.shallowCopy(100, 600, false);
+        assertTrue(pl2.equals(pl5));
+
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testImmutable() {
+        PointList pl = new PointList();
+        pl.makeImmutable();
+        pl.add(0, 0, 0);
+    }
+
+    @Test()
+    public void testToString() {
+        PointList pl = new PointList(3, true);
+        pl.add(0, 0, 0);
+        pl.add(1, 1, 1);
+        pl.add(2, 2, 2);
+
+        assertEquals("(0.0,0.0,0.0), (1.0,1.0,1.0), (2.0,2.0,2.0)", pl.toString());
+        assertEquals("(1.0,1.0,1.0), (2.0,2.0,2.0)", pl.shallowCopy(1, 3, false).toString());
+    }
+
+    @Test()
+    public void testClone() {
+        PointList pl = new PointList(3, true);
+        pl.add(0, 0, 0);
+        pl.add(1, 1, 1);
+        pl.add(2, 2, 2);
+
+        PointList shallowPl = pl.shallowCopy(1, 3, false);
+        PointList clonedPl = shallowPl.clone(false);
+
+        assertEquals(shallowPl, clonedPl);
+        clonedPl.setNode(0, 5, 5, 5);
+        assertNotEquals(shallowPl, clonedPl);
+    }
+
+    @Test()
+    public void testCopyOfShallowCopy() {
+        PointList pl = new PointList(3, true);
+        pl.add(0, 0, 0);
+        pl.add(1, 1, 1);
+        pl.add(2, 2, 2);
+
+        PointList shallowPl = pl.shallowCopy(1, 3, false);
+        PointList copiedPl = shallowPl.copy(0, 2);
+
+        assertEquals(shallowPl, copiedPl);
+        copiedPl.setNode(0, 5, 5, 5);
+        assertNotEquals(shallowPl, copiedPl);
+    }
+
+    @Test()
+    public void testCalcDistanceOfShallowCopy() {
+        PointList pl = new PointList(3, true);
+        pl.add(0, 0, 0);
+        pl.add(1, 1, 1);
+        pl.add(2, 2, 2);
+
+        PointList shallowPl = pl.shallowCopy(1, 3, false);
+        PointList clonedPl = shallowPl.clone(false);
+        assertEquals(clonedPl.calcDistance(Helper.DIST_EARTH), shallowPl.calcDistance(Helper.DIST_EARTH), .01);
+    }
+
+    @Test()
+    public void testToGeoJson() {
+        PointList pl = new PointList(3, true);
+        pl.add(0, 0, 0);
+        pl.add(1, 1, 1);
+        pl.add(2, 2, 2);
+
+        assertEquals(3, pl.toGeoJson(true).size());
+        assertEquals(2, pl.shallowCopy(1, 3, false).toGeoJson(true).size());
+    }
+
+
 }
diff --git a/docs/core/technical.md b/docs/core/technical.md
index 3e168b6a37..558b1b030c 100644
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -60,7 +60,7 @@ An algorithm needs the path extraction: from the shortest-path-tree one needs to
 can be determined. For bidirectional algorithms this is a bit more complicated and done in PathBidirRef. 
 For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teaching/EfficientRoutePlanningSS2012)
  we use the _CHGraph_ which additionally holds shortcuts. While path extraction we need to identify those
- shortcuts and get the edges recursivly, this is done in Path4CH.
+ shortcuts and get the edges recursively, this is done in Path4CH.
 
 ## 3.1 Base Graph
 
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index 4b3aec4aef..8d50f43698 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -26,6 +26,7 @@ debug            | false   | If true, the output will be formated.
 calc_points      | true    | If the points for the route should be calculated at all printing out only distance and time.
 type             | json    | Specifies the resulting format of the route, for `json` the content type will be application/json. Other possible format options: <br> `jsonp` you'll need to provide the callback function via the callback parameter. The content type will be application/javascript<br> `gpx`, the content type will be application/gpx+xml, see below for more parameters.
 point_hint       | -       | Optional parameter. Specifies a hint for each `point` parameter to prefer a certain street for the closest location lookup. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
+details          | -       | Optional parameter. You can request additional details for the route: `average_speed`, `street_name`, `edge_id`, and `time`. The returned format for one details is `[fromRef, toRef, value]`. The `ref` references the points of the response.
 
 ### GPX
 
@@ -58,7 +59,7 @@ weighting        | `fastest`  | Which kind of 'best' route calculation you need.
 edge_traversal   |`false`     | Use `true` if you want to consider turn restrictions for bike and motor vehicles. Keep in mind that the response time is roughly 2 times slower.
 algorithm        |`astarbi`   | The algorithm to calculate the route. Other options are `dijkstra`, `astar`, `astarbi`, `alternative_route` and `round_trip`
 block_area       | -          | Block road access via a point with the format `latitude,longitude` or an area defined by a circle `lat,lon,radius` or a rectangle `lat1,lon1,lat2,lon2`. Separate multiple areas with a semicolon `;`.
-heading          | NaN        | Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points. In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree. This parameter also influences the tour generated with `algorithm=round_trip` and force the initial direction.
+heading          | NaN        | Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points. In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree. This parameter also influences the tour generated with `algorithm=round_trip` and forces the initial direction.
 heading_penalty  | 120        | Penalty for omitting a specified heading. The penalty corresponds to the accepted time delay in seconds in comparison to the route without a heading.
 pass_through     | `false`    | If `true` u-turns are avoided at via-points with regard to the `heading_penalty`.
 round_trip.distance                 | 10000 | If `algorithm=round_trip` this parameter configures approximative length of the resulting round trip
@@ -89,7 +90,7 @@ paths[0].instructions[0].street_name          | The name of the street to turn o
 paths[0].instructions[0].distance             | The distance for this instruction, in meter
 paths[0].instructions[0].time                 | The duration for this instruction, in ms
 paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
-paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
+paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. 2 for a right turn.<br>KEEP_LEFT=-7<br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>REACHED_VIA = 5<br>USE_ROUNDABOUT = 6<br>KEEP_RIGHT=7<br>implement some default for all other
 paths[0].instructions[0].annotation_text      | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
 paths[0].instructions[0].annotation_importance| [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
 paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
@@ -160,6 +161,9 @@ paths[0].instructions[0].turn_angle           | [optional] Only available for US
     ],
     "points": "oxg_Iy|ppAl@wCdE}LfFsN|@_Ej@eEtAaMh@sGVuDNcDb@{PFyGdAi]FoC?q@sXQ_@?",
     "points_encoded": true,
+    "details":{
+        "street_name":[[0,1,"Rue Principale"],[1,13,"D19E"],[13,18,"D19"],..]
+    },
     "time": 129290
   }]
 }
diff --git a/findbugs-exclude.xml b/findbugs-exclude.xml
new file mode 100644
index 0000000000..7c021c200f
--- /dev/null
+++ b/findbugs-exclude.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<FindBugsFilter>
+    <!-- documentation about findbug's rule match clauses can be found here:
+         http://findbugs.sourceforge.net/manual/filter.html -->
+</FindBugsFilter>
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index f481a8d9cf..3e82c5cf15 100644
--- a/pom.xml
+++ b/pom.xml
@@ -136,21 +136,28 @@
                 <artifactId>maven-jar-plugin</artifactId>
                 <version>3.0.2</version>
             </plugin>
-            <!-- example https://github.com/tananaev/traccar/blob/master/checkstyle.xml
+            <!-- example https://github.com/tananaev/traccar/blob/master/checkstyle.xml -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-checkstyle-plugin</artifactId>
                 <version>2.17</version>
                 <configuration>
                     <configLocation>checkstyle.xml</configLocation>
+                    <failsOnError>true</failsOnError>
+                    <consoleOutput>true</consoleOutput>
+                    <linkXRef>false</linkXRef>
                 </configuration>
             </plugin>
-            -->
 
             <plugin>
                 <groupId>org.codehaus.mojo</groupId>
                 <artifactId>findbugs-maven-plugin</artifactId>
-                <version>3.0.4</version>
+                <version>3.0.5</version>
+                <configuration>
+                    <maxRank>4</maxRank>
+                    <failOnError>true</failOnError>
+                    <excludeFilterFile>findbugs-exclude.xml</excludeFilterFile>
+                </configuration>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 6904e8ec9e..8974379085 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -19,7 +19,6 @@
 package com.graphhopper.reader.gtfs;
 
 import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.FluentIterable;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.storage.Graph;
@@ -32,10 +31,11 @@
 import java.time.Instant;
 import java.time.ZoneId;
 import java.time.temporal.ChronoUnit;
-import java.util.Iterator;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Spliterators;
 import java.util.function.Consumer;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
@@ -48,15 +48,14 @@
     private final boolean reverse;
     private final PtTravelTimeWeighting weighting;
     private final PointList extraNodes;
-    private final List<VirtualEdgeIteratorState> extraEdges;
+    private final List<EdgeIteratorState> extraEdges = new ArrayList<>();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
     private final Graph graph;
     private final boolean walkOnly;
-    private final boolean profileQuery;
 
 
-    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, PointList extraNodes, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, boolean profileQuery) {
+    GraphExplorer(Graph graph, PtTravelTimeWeighting weighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, PointList extraNodes, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly) {
         this.graph = graph;
         this.edgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, reverse, !reverse));
         this.flagEncoder = flagEncoder;
@@ -65,64 +64,31 @@
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
         this.extraNodes = extraNodes;
-        this.extraEdges = extraEdges;
+        this.extraEdges.addAll(extraEdges);
         for (VirtualEdgeIteratorState extraEdge : extraEdges) {
+            if (extraEdge == null) {
+                throw new RuntimeException();
+            }
             extraEdgesBySource.put(extraEdge.getBaseNode(), extraEdge);
-            extraEdgesByDestination.put(extraEdge.getAdjNode(), (VirtualEdgeIteratorState) extraEdge.detach(true));
+            extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalTraversalKey(), extraEdge.getEdge(), extraEdge.getAdjNode(), extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3)));
         }
         this.walkOnly = walkOnly;
-        this.profileQuery = profileQuery;
     }
 
     Stream<EdgeIteratorState> exploreEdgesAround(Label label) {
         final List<VirtualEdgeIteratorState> extraEdges = reverse ? extraEdgesByDestination.get(label.adjNode) : extraEdgesBySource.get(label.adjNode);
         return Stream.concat(
                 label.adjNode < graph.getNodes() ? mainEdgesAround(label) : Stream.empty(),
-                extraEdges.stream());
+                extraEdges.stream()).filter(new EdgeIteratorStatePredicate(label));
     }
 
-    Stream<EdgeIteratorState> mainEdgesAround(Label label) {
+    private Stream<EdgeIteratorState> mainEdgesAround(Label label) {
         return StreamSupport.stream(new Spliterators.AbstractSpliterator<EdgeIteratorState>(0, 0) {
-            boolean foundEnteredTimeExpandedNetworkEdge = false;
             EdgeIterator edgeIterator = edgeExplorer.setBaseNode(label.adjNode);
 
             @Override
             public boolean tryAdvance(Consumer<? super EdgeIteratorState> action) {
-                while (edgeIterator.next()) {
-                    final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
-                    if (walkOnly && edgeType != GtfsStorage.EdgeType.HIGHWAY && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
-                        continue;
-                    }
-                    if (profileQuery && (edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT)) {
-                        continue;
-                    }
-                    if (!isValidOn(edgeIterator, label.currentTime)) {
-                        continue;
-                    }
-                    if (realtimeFeed.isBlocked(edgeIterator.getEdge())) {
-                        continue;
-                    }
-                    if (edgeType == GtfsStorage.EdgeType.WAIT_ARRIVAL && !reverse) {
-                        continue;
-                    }
-                    if (edgeType == GtfsStorage.EdgeType.WAIT && reverse) {
-                        continue;
-                    }
-                    if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
-                        if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
-                            continue;
-                        } else {
-                            if (foundEnteredTimeExpandedNetworkEdge) {
-                                continue;
-                            } else {
-                                foundEnteredTimeExpandedNetworkEdge = true;
-                            }
-                        }
-                    } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
-                        if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
-                            continue;
-                        }
-                    }
+                if (edgeIterator.next()) {
                     action.accept(edgeIterator);
                     return true;
                 }
@@ -181,19 +147,66 @@ private boolean isValidOn(EdgeIteratorState edge, long instant) {
         }
     }
 
-    public EdgeIteratorState getEdgeIteratorState(int edge, int adjNode) {
-        if (edge == -1) {
-            return extraEdges.iterator().next();
-        } else {
-            return graph.getEdgeIteratorState(edge, adjNode);
+    EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
+        if (edgeId == -1) {
+            throw new RuntimeException();
         }
+        return extraEdges.stream()
+                .filter(edge -> edge.getEdge() == edgeId)
+                .findFirst().orElseGet(() -> graph.getEdgeIteratorState(edgeId, adjNode));
     }
 
-    public NodeAccess getNodeAccess() {
+    NodeAccess getNodeAccess() {
         return graph.getNodeAccess();
     }
 
     public Graph getGraph() {
         return graph;
     }
+
+    private class EdgeIteratorStatePredicate implements Predicate<EdgeIteratorState> {
+        private final Label label;
+        boolean foundEnteredTimeExpandedNetworkEdge;
+
+        EdgeIteratorStatePredicate(Label label) {
+            this.label = label;
+            foundEnteredTimeExpandedNetworkEdge = false;
+        }
+
+        @Override
+        public boolean test(EdgeIteratorState edgeIterator) {
+            final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
+            if (walkOnly && edgeType != GtfsStorage.EdgeType.HIGHWAY && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
+                return false;
+            }
+            if (!isValidOn(edgeIterator, label.currentTime)) {
+                return false;
+            }
+            if (realtimeFeed.isBlocked(edgeIterator.getEdge())) {
+                return false;
+            }
+            if (edgeType == GtfsStorage.EdgeType.WAIT_ARRIVAL && !reverse) {
+                return false;
+            }
+            if (edgeType == GtfsStorage.EdgeType.WAIT && reverse) {
+                return false;
+            }
+            if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
+                if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
+                    return false;
+                } else {
+                    if (foundEnteredTimeExpandedNetworkEdge) {
+                        return false;
+                    } else {
+                        foundEnteredTimeExpandedNetworkEdge = true;
+                    }
+                }
+            } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
+                if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 1b26bca02f..ec80420efc 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -62,7 +62,7 @@ private Factory(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphH
         }
 
         public GraphHopperGtfs createWith(GtfsRealtime.FeedMessage realtimeFeed) {
-            return new GraphHopperGtfs(flagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.fromProtobuf(gtfsStorage, realtimeFeed));
+            return new GraphHopperGtfs(flagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.fromProtobuf(graphHopperStorage, gtfsStorage, flagEncoder, realtimeFeed));
         }
 
         public GraphHopperGtfs createWithoutRealtimeFeed() {
@@ -97,12 +97,13 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final GHPoint enter;
         private final GHPoint exit;
         private final Translation translation;
-        private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>(realtimeFeed.getAdditionalEdges());
         private final PointList extraNodes = new PointList();
         private final Map<Integer, PathWrapper> walkPaths = new HashMap<>();
 
         private final GHResponse response = new GHResponse();
-        private final QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
+        private final Graph graphWithExtraEdges = new WrapperGraph(graphHopperStorage, extraEdges);
+        private QueryGraph queryGraph = new QueryGraph(graphWithExtraEdges);
         private GraphExplorer graphExplorer;
 
         RequestHandler(GHRequest request) {
@@ -163,32 +164,36 @@ GHResponse route() {
         }
 
         private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint ghPoint, ArrayList<QueryResult> allQueryResults) {
-            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, reverse, new PointList(), Collections.emptyList(), true, false);
+            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, reverse, new PointList(), extraEdges, true);
 
             extraNodes.add(ghPoint);
 
-            int newNode = graphHopperStorage.getNodes() + 1000 + index;
+            int nextNodeId = graphHopperStorage.getNodes() + 10000 + index; // FIXME: A number bigger than the number of nodes QueryGraph adds
+            int nextEdgeId = graphWithExtraEdges.getAllEdges().getMaxId() + 100; // FIXME: A number bigger than the number of edges QueryGraph adds
+
             final List<Label> stationNodes = findStationNodes(graphExplorer, allQueryResults.get(index).getClosestNode(), reverse);
             for (Label stationNode : stationNodes) {
                 final PathWrapper pathWrapper = stationNode.parent.parent != null ?
                         tripFromLabel.parseSolutionIntoPath(reverse, flagEncoder, translation, graphExplorer, weighting, stationNode.parent, new PointList()) :
                         new PathWrapper();
                 final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(stationNode.edge,
-                        -1, reverse ? stationNode.adjNode : newNode, reverse ? newNode : stationNode.adjNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
+                        nextEdgeId++, reverse ? stationNode.adjNode : nextNodeId, reverse ? nextNodeId : stationNode.adjNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
                 final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(stationNode.edge,
-                        -1, reverse ? newNode : stationNode.adjNode, reverse ? stationNode.adjNode : newNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
+                        nextEdgeId++, reverse ? nextNodeId : stationNode.adjNode, reverse ? stationNode.adjNode : nextNodeId, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
                 newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setEdgeType(newEdge.getFlags(), reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT));
                 final long time = pathWrapper.getTime() / 1000;
                 newEdge.setFlags(((PtFlagEncoder) weighting.getFlagEncoder()).setTime(newEdge.getFlags(), time));
                 reverseNewEdge.setFlags(newEdge.getFlags());
                 newEdge.setReverseEdge(reverseNewEdge);
+                reverseNewEdge.setReverseEdge(newEdge);
                 newEdge.setDistance(pathWrapper.getDistance());
                 extraEdges.add(newEdge);
+                extraEdges.add(reverseNewEdge);
                 walkPaths.put(stationNode.adjNode, pathWrapper);
             }
 
             final QueryResult virtualNode = new QueryResult(ghPoint.getLat(), ghPoint.getLon());
-            virtualNode.setClosestNode(newNode);
+            virtualNode.setClosestNode(nextNodeId);
             allQueryResults.set(index, virtualNode);
         }
 
@@ -198,7 +203,6 @@ private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint
             final Stream<Label> labels = router.calcLabels(node, -1, initialTime);
             return labels
                     .filter(current -> current.edge != -1 && flagEncoder.getEdgeType(graphExplorer.getEdgeIteratorState(current.edge, current.adjNode).getFlags()) == edgeType)
-//                    .limit(limitSolutions)
                     .collect(Collectors.toList());
         }
 
@@ -249,7 +253,7 @@ private int egressNode(Label solution) {
 
         private List<Label> findPaths(int startNode, int destNode) {
             StopWatch stopWatch = new StopWatch().start();
-            graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraNodes, extraEdges, false, profileQuery);
+            graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraNodes, extraEdges, false);
             MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, arriveBy, maxWalkDistancePerLeg, maxTransferDistancePerLeg, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
             final Stream<Label> labels = router.calcLabels(startNode, destNode, initialTime);
             List<Label> solutions = labels
@@ -327,7 +331,7 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
                 walkNetworkIndex = new EmptyLocationIndex();
             }
             for (int i = 0; i < id; i++) {
-                new GtfsReader("gtfs_" + i, graphHopperStorage, walkNetworkIndex).readGraph();
+                new GtfsReader("gtfs_" + i, graphHopperStorage, ptFlagEncoder, walkNetworkIndex).readGraph();
             }
             graphHopperStorage.flush();
             return graphHopperStorage;
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 33a66522c7..6eef12943f 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -25,7 +25,7 @@
 import com.google.common.collect.SetMultimap;
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -46,6 +46,21 @@
 
 class GtfsReader {
 
+    private LocalDate startDate;
+    private LocalDate endDate;
+
+    static class TripWithStopTimes {
+        public TripWithStopTimes(Trip trip, Iterable<StopTime> stopTimes, BitSet validOnDay) {
+            this.trip = trip;
+            this.stopTimes = stopTimes;
+            this.validOnDay = validOnDay;
+        }
+
+        Trip trip;
+        Iterable<StopTime> stopTimes;
+        BitSet validOnDay;
+    }
+
     private static class EnterAndExitNodeIdWithStopId {
         final String stopId;
         final Collection<Integer> enterNodeIds;
@@ -60,10 +75,12 @@ private EnterAndExitNodeIdWithStopId(Collection<Integer> enterNodeIds, String st
 
     private static class TimelineNodeIdWithTripId {
         final String tripId;
+        final String routeId;
         final int timelineNodeId;
 
-        private TimelineNodeIdWithTripId(int timelineNodeId, String tripId) {
+        private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String routeId) {
             this.tripId = tripId;
+            this.routeId = routeId;
             this.timelineNodeId = timelineNodeId;
         }
     }
@@ -77,12 +94,12 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId) {
         SINGLE_FREQUENCY.headway_secs = 1;
     }
 
-    private final GraphHopperStorage graph;
+    private final Graph graph;
     private final LocationIndex walkNetworkIndex;
     private final GtfsStorage gtfsStorage;
 
     private final DistanceCalc distCalc = Helper.DIST_EARTH;
-    private Transfers transfers;
+    private final Transfers transfers;
     private final NodeAccess nodeAccess;
     private final String id;
     private int i;
@@ -93,21 +110,28 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId) {
     private Collection<EnterAndExitNodeIdWithStopId> stopEnterAndExitNodes = new ArrayList<>();
     private final PtFlagEncoder encoder;
 
-    GtfsReader(String id, GraphHopperStorage ghStorage, LocationIndex walkNetworkIndex) {
+    GtfsReader(String id, Graph graph, PtFlagEncoder encoder, LocationIndex walkNetworkIndex) {
         this.id = id;
-        this.graph = ghStorage;
-        this.gtfsStorage = (GtfsStorage) ghStorage.getExtension();
-        this.nodeAccess = ghStorage.getNodeAccess();
+        this.graph = graph;
+        this.gtfsStorage = (GtfsStorage) graph.getExtension();
+        this.nodeAccess = graph.getNodeAccess();
         this.walkNetworkIndex = walkNetworkIndex;
-        this.encoder = (PtFlagEncoder) graph.getEncodingManager().getEncoder("pt");
+        this.encoder = encoder;
+        this.feed = this.gtfsStorage.getGtfsFeeds().get(id);
+        this.transfers = new Transfers(feed);
+        this.i = graph.getNodes();
+        this.startDate = feed.calculateStats().getStartDate();
+        this.endDate = feed.calculateStats().getEndDate();
+        this.gtfsStorage.getFares().putAll(feed.fares);
     }
 
-    public void readGraph() {
-        feed = this.gtfsStorage.getGtfsFeeds().get(id);
-        transfers = new Transfers(feed);
-        gtfsStorage.getFares().putAll(feed.fares);
-        i = graph.getNodes();
+    void readGraph() {
         buildPtNetwork();
+        connectStopsToStreetNetwork();
+        connectStopsToStationNodes();
+    }
+
+    void connectStopsToStreetNetwork() {
         EdgeFilter filter = new EverythingButPt(encoder);
         for (EnterAndExitNodeIdWithStopId entry : stopEnterAndExitNodes) {
             Stop stop = feed.stops.get(entry.stopId);
@@ -120,6 +144,14 @@ public void readGraph() {
             } else {
                 streetNode = locationQueryResult.getClosestNode();
             }
+            gtfsStorage.getStationNodes().put(entry.stopId, streetNode);
+        }
+    }
+
+    void connectStopsToStationNodes() {
+        for (EnterAndExitNodeIdWithStopId entry : stopEnterAndExitNodes) {
+            Stop stop = feed.stops.get(entry.stopId);
+            int streetNode = gtfsStorage.getStationNodes().get(entry.stopId);
             for (Integer enterNodeId : entry.enterNodeIds) {
                 EdgeIteratorState entryEdge = graph.edge(streetNode, enterNodeId, 0.0, false);
                 setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
@@ -130,13 +162,10 @@ public void readGraph() {
                 setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
                 exitEdge.setName(stop.stop_name);
             }
-            gtfsStorage.getStationNodes().put(entry.stopId, streetNode);
         }
     }
 
     private void buildPtNetwork() {
-        LocalDate startDate = feed.calculateStats().getStartDate();
-        LocalDate endDate = feed.calculateStats().getEndDate();
         HashMultimap<String, Trip> blockTrips = HashMultimap.create();
         for (Trip trip : feed.trips.values()) {
             if (trip.block_id != null) {
@@ -146,18 +175,8 @@ private void buildPtNetwork() {
             }
         }
         blockTrips.asMap().values().forEach(unsortedTrips -> {
-            ArrayList<Trip> trips = new ArrayList<>(unsortedTrips);
-            trips.sort(Comparator.comparingInt(trip -> getInterpolatedStopTimesForTrip(trip.trip_id).iterator().next().departure_time));
-            if (trips.stream().map(trip -> feed.getFrequencies(trip.trip_id)).distinct().count() != 1) {
-                throw new RuntimeException("Found a block with frequency-based trips. Not supported.");
-            }
-            Collection<Frequency> frequencies = feed.getFrequencies(trips.iterator().next().trip_id);
-            for (Frequency frequency : (frequencies.isEmpty() ? Collections.singletonList(SINGLE_FREQUENCY) : frequencies)) {
-                for (int time = frequency.start_time; time < frequency.end_time; time += frequency.headway_secs) {
-                    List<Integer> arrivalNodes = new ArrayList<>();
-                    IntArrayList boardEdges = new IntArrayList();
-                    IntArrayList alightEdges = new IntArrayList();
-                    for (Trip trip : trips) {
+            List<TripWithStopTimes> trips = unsortedTrips.stream()
+                    .map(trip -> {
                         Service service = feed.services.get(trip.service_id);
                         BitSet validOnDay = new BitSet((int) DAYS.between(startDate, endDate));
                         for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {
@@ -165,139 +184,167 @@ private void buildPtNetwork() {
                                 validOnDay.set((int) DAYS.between(startDate, date));
                             }
                         }
-                        ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(trip.route_id).agency_id).agency_timezone);
-                        StopTime prev = null;
-                        int arrivalNode = -1;
-                        int departureNode = -1;
-                        for (StopTime stopTime : getInterpolatedStopTimesForTrip(trip.trip_id)) {
-                            Stop stop = feed.stops.get(stopTime.stop_id);
-                            arrivalNode = i++;
-                            nodeAccess.setNode(arrivalNode, stop.stop_lat, stop.stop_lon);
-                            nodeAccess.setAdditionalNodeField(arrivalNode, NodeType.INTERNAL_PT.ordinal());
-                            times.put(arrivalNode, stopTime.arrival_time + time);
-                            if (prev != null) {
-                                Stop fromStop = feed.stops.get(prev.stop_id);
-                                double distance = distCalc.calcDist(
-                                        fromStop.stop_lat,
-                                        fromStop.stop_lon,
-                                        stop.stop_lat,
-                                        stop.stop_lon);
-                                EdgeIteratorState edge = graph.edge(
-                                        departureNode,
-                                        arrivalNode,
-                                        distance,
-                                        false);
-                                edge.setName(stop.stop_name);
-                                setEdgeType(edge, GtfsStorage.EdgeType.HOP);
-                                edge.setFlags(encoder.setTime(edge.getFlags(), stopTime.arrival_time - prev.departure_time));
-                                gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
-                            }
-                            final int departureTimelineNode = i++;
-                            nodeAccess.setNode(departureTimelineNode, stop.stop_lat, stop.stop_lon);
-                            nodeAccess.setAdditionalNodeField(departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
-                            times.put(departureTimelineNode, stopTime.departure_time + time);
-                            departureTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(departureTimelineNode, trip.trip_id));
-                            final int arrivalTimelineNode = i++;
-                            nodeAccess.setNode(arrivalTimelineNode, stop.stop_lat, stop.stop_lon);
-                            nodeAccess.setAdditionalNodeField(arrivalTimelineNode, NodeType.INTERNAL_PT.ordinal());
-                            times.put(arrivalTimelineNode, stopTime.arrival_time + time);
-                            arrivalTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(arrivalTimelineNode, trip.trip_id));
-                            departureNode = i++;
-                            nodeAccess.setNode(departureNode, stop.stop_lat, stop.stop_lon);
-                            nodeAccess.setAdditionalNodeField(departureNode, NodeType.INTERNAL_PT.ordinal());
-                            times.put(departureNode, stopTime.departure_time + time);
-                            int dayShift = stopTime.departure_time / (24 * 60 * 60);
-                            GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(validOnDay, dayShift), zoneId, startDate);
-                            int validityId;
-                            if (gtfsStorage.getOperatingDayPatterns().containsKey(validOn)) {
-                                validityId = gtfsStorage.getOperatingDayPatterns().get(validOn);
-                            } else {
-                                validityId = gtfsStorage.getOperatingDayPatterns().size();
-                                gtfsStorage.getOperatingDayPatterns().put(validOn, validityId);
-                            }
-
-                            EdgeIteratorState boardEdge = graph.edge(
-                                    departureTimelineNode,
-                                    departureNode,
-                                    0.0,
-                                    false);
-                            boardEdge.setName(getRouteName(feed, trip));
-                            setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
-                            boardEdges.add(boardEdge.getEdge());
-                            gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
-                            gtfsStorage.getExtraStrings().put(boardEdge.getEdge(), trip.trip_id);
-                            boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
-                            boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
-
-                            EdgeIteratorState alightEdge = graph.edge(
-                                    arrivalNode,
-                                    arrivalTimelineNode,
-                                    0.0,
-                                    false);
-                            alightEdge.setName(getRouteName(feed, trip));
-                            setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
-                            alightEdges.add(alightEdge.getEdge());
-                            gtfsStorage.getStopSequences().put(alightEdge.getEdge(), stopTime.stop_sequence);
-                            gtfsStorage.getExtraStrings().put(alightEdge.getEdge(), trip.trip_id);
-                            alightEdge.setFlags(encoder.setValidityId(alightEdge.getFlags(), validityId));
-//                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
-
-
-                            EdgeIteratorState dwellEdge = graph.edge(
-                                    arrivalNode,
-                                    departureNode,
-                                    0.0,
-                                    false);
-                            dwellEdge.setName(getRouteName(feed, trip));
-                            setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
-                            dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
-                            if (prev == null) {
-                                insertInboundBlockTransfers(arrivalNodes, trip, departureNode, stopTime, stop, validityId);
-                            }
-                            prev = stopTime;
-                        }
-                        final GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder().setTripId(trip.trip_id).setStartTime(Entity.Writer.convertToGtfsTime(time)).build();
-                        gtfsStorage.getBoardEdgesForTrip().put(tripDescriptor, boardEdges.toArray());
-                        gtfsStorage.getAlightEdgesForTrip().put(tripDescriptor, alightEdges.toArray());
-                        arrivalNodes.add(arrivalNode);
-                    }
+                        return new TripWithStopTimes(trip, getInterpolatedStopTimesForTrip(trip.trip_id), validOnDay);
+                    })
+                    .sorted(Comparator.comparingInt(trip -> trip.stopTimes.iterator().next().departure_time))
+                    .collect(Collectors.toList());
+            if (trips.stream().map(trip -> feed.getFrequencies(trip.trip.trip_id)).distinct().count() != 1) {
+                throw new RuntimeException("Found a block with frequency-based trips. Not supported.");
+            }
+            ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(trips.iterator().next().trip.route_id).agency_id).agency_timezone);
+            Collection<Frequency> frequencies = feed.getFrequencies(trips.iterator().next().trip.trip_id);
+            for (Frequency frequency : (frequencies.isEmpty() ? Collections.singletonList(SINGLE_FREQUENCY) : frequencies)) {
+                for (int time = frequency.start_time; time < frequency.end_time; time += frequency.headway_secs) {
+                    addTrips(zoneId, trips, time);
                 }
             }
         });
 
+        wireUpStops();
+    }
+
+    void wireUpStops() {
         for (Stop stop : feed.stops.values()) {
             if (stop.location_type == 0) { // Only stops. Not interested in parent stations for now.
-                final Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = arrivalTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> feed.trips.get(t.tripId).route_id));
-
                 List<Integer> stopExitNodeIds = new ArrayList<>();
-                arrivalTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                    int stopExitNode = i-1;
-                    nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
-                    stopExitNodeIds.add(stopExitNode);
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
-                    timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
-                            .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
-                    wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
-                });
 
+                if (arrivalTimelineNodes.containsKey(stop.stop_id)) {
+                    final Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = arrivalTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
 
+                    arrivalTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
+                        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+                        int stopExitNode = i-1;
+                        nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
+                        stopExitNodeIds.add(stopExitNode);
+                        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
+                        timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
+                                .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
+                        wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
+                    });
 
-                final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> feed.trips.get(t.tripId).route_id));
-
+                }
                 List<Integer> stopEnterNodeIds = new ArrayList<>();
-                departureTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                    int stopEnterNode = i-1;
-                    nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
-                    stopEnterNodeIds.add(stopEnterNode);
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
-                    timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
-                            .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
-                    wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
-                });
+
+                if (departureTimelineNodes.containsKey(stop.stop_id)) {
+                    final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
+
+                    departureTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
+                        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+                        int stopEnterNode = i-1;
+                        nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
+                        stopEnterNodeIds.add(stopEnterNode);
+                        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
+                        timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
+                                .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
+                        wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
+                    });
+                }
+
                 stopEnterAndExitNodes.add(new EnterAndExitNodeIdWithStopId(stopEnterNodeIds, stop.stop_id, stopExitNodeIds));
+
+            }
+        }
+    }
+
+    void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time) {
+        List<Integer> arrivalNodes = new ArrayList<>();
+        for (TripWithStopTimes trip : trips) {
+            IntArrayList boardEdges = new IntArrayList();
+            IntArrayList alightEdges = new IntArrayList();
+            StopTime prev = null;
+            int arrivalNode = -1;
+            int departureNode = -1;
+            for (StopTime stopTime : trip.stopTimes) {
+                Stop stop = feed.stops.get(stopTime.stop_id);
+                arrivalNode = i++;
+                nodeAccess.setNode(arrivalNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(arrivalNode, NodeType.INTERNAL_PT.ordinal());
+                times.put(arrivalNode, stopTime.arrival_time + time);
+                if (prev != null) {
+                    Stop fromStop = feed.stops.get(prev.stop_id);
+                    double distance = distCalc.calcDist(
+                            fromStop.stop_lat,
+                            fromStop.stop_lon,
+                            stop.stop_lat,
+                            stop.stop_lon);
+                    EdgeIteratorState edge = graph.edge(
+                            departureNode,
+                            arrivalNode,
+                            distance,
+                            false);
+                    edge.setName(stop.stop_name);
+                    setEdgeType(edge, GtfsStorage.EdgeType.HOP);
+                    edge.setFlags(encoder.setTime(edge.getFlags(), stopTime.arrival_time - prev.departure_time));
+                    gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
+                }
+                final int departureTimelineNode = i++;
+                nodeAccess.setNode(departureTimelineNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
+                times.put(departureTimelineNode, stopTime.departure_time + time);
+                departureTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(departureTimelineNode, trip.trip.trip_id, trip.trip.route_id));
+                final int arrivalTimelineNode = i++;
+                nodeAccess.setNode(arrivalTimelineNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(arrivalTimelineNode, NodeType.INTERNAL_PT.ordinal());
+                times.put(arrivalTimelineNode, stopTime.arrival_time + time);
+                arrivalTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(arrivalTimelineNode, trip.trip.trip_id, trip.trip.route_id));
+                departureNode = i++;
+                nodeAccess.setNode(departureNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(departureNode, NodeType.INTERNAL_PT.ordinal());
+                times.put(departureNode, stopTime.departure_time + time);
+                int dayShift = stopTime.departure_time / (24 * 60 * 60);
+                GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(trip.validOnDay, dayShift), zoneId, startDate);
+                int validityId;
+                if (gtfsStorage.getOperatingDayPatterns().containsKey(validOn)) {
+                    validityId = gtfsStorage.getOperatingDayPatterns().get(validOn);
+                } else {
+                    validityId = gtfsStorage.getOperatingDayPatterns().size();
+                    gtfsStorage.getOperatingDayPatterns().put(validOn, validityId);
+                }
+
+                EdgeIteratorState boardEdge = graph.edge(
+                        departureTimelineNode,
+                        departureNode,
+                        0.0,
+                        false);
+                boardEdge.setName(getRouteName(feed, trip.trip));
+                setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
+                boardEdges.add(boardEdge.getEdge());
+                gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
+                gtfsStorage.getExtraStrings().put(boardEdge.getEdge(), trip.trip.trip_id);
+                boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
+                boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
+
+                EdgeIteratorState alightEdge = graph.edge(
+                        arrivalNode,
+                        arrivalTimelineNode,
+                        0.0,
+                        false);
+                alightEdge.setName(getRouteName(feed, trip.trip));
+                setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
+                alightEdges.add(alightEdge.getEdge());
+                gtfsStorage.getStopSequences().put(alightEdge.getEdge(), stopTime.stop_sequence);
+                gtfsStorage.getExtraStrings().put(alightEdge.getEdge(), trip.trip.trip_id);
+                alightEdge.setFlags(encoder.setValidityId(alightEdge.getFlags(), validityId));
+//                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
+
+
+                EdgeIteratorState dwellEdge = graph.edge(
+                        arrivalNode,
+                        departureNode,
+                        0.0,
+                        false);
+                dwellEdge.setName(getRouteName(feed, trip.trip));
+                setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
+                dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
+                if (prev == null) {
+                    insertInboundBlockTransfers(arrivalNodes, trip.trip, departureNode, stopTime, stop, validityId);
+                }
+                prev = stopTime;
             }
+            final GtfsRealtime.TripDescriptor tripDescriptor = GtfsRealtime.TripDescriptor.newBuilder().setTripId(trip.trip.trip_id).setStartTime(Entity.Writer.convertToGtfsTime(time)).build();
+            gtfsStorage.getBoardEdgesForTrip().put(tripDescriptor, boardEdges.toArray());
+            gtfsStorage.getAlightEdgesForTrip().put(tripDescriptor, alightEdges.toArray());
+            arrivalNodes.add(arrivalNode);
         }
     }
 
@@ -407,7 +454,7 @@ private void insertInboundBlockTransfers(List<Integer> arrivalNodes, Trip trip,
 
     private void insertInboundTransfers(String fromStopId, String from_route_id, int minimumTransferTime, SortedSet<Fun.Tuple2<Integer, Integer>> toStopTimelineNode) {
         for (TimelineNodeIdWithTripId entry : arrivalTimelineNodes.get(fromStopId)) {
-            if (from_route_id == null || from_route_id.equals(feed.trips.get(entry.tripId).route_id)) {
+            if (from_route_id == null || from_route_id.equals(entry.routeId)) {
                 int arrivalTime = times.get(entry.timelineNodeId);
                 SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = toStopTimelineNode.tailSet(new Fun.Tuple2<>(arrivalTime + minimumTransferTime, -1));
                 if (!tailSet.isEmpty()) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index a15134a09e..4903f2a9a6 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -35,6 +35,7 @@
  *
  * @author Michael Zilske
  * @author Peter Karich
+ * @author Wesam Herbawi
  */
 class MultiCriteriaLabelSetting {
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index e5dc9416f8..9119b9e35a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -19,22 +19,50 @@
 package com.graphhopper.reader.gtfs;
 
 import com.carrotsearch.hppc.IntHashSet;
+import com.carrotsearch.hppc.IntIntHashMap;
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.model.StopTime;
+import com.conveyal.gtfs.model.Trip;
 import com.google.transit.realtime.GtfsRealtime;
+import com.graphhopper.routing.VirtualEdgeIteratorState;
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+
+import java.time.*;
+import java.time.temporal.ChronoUnit;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
 
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
+import static java.time.temporal.ChronoUnit.DAYS;
 
 public class RealtimeFeed {
     private final IntHashSet blockedEdges;
 
-    private RealtimeFeed(IntHashSet blockedEdges) {
+    private final List<VirtualEdgeIteratorState> additionalEdges;
+
+    private RealtimeFeed(IntHashSet blockedEdges, List<VirtualEdgeIteratorState> additionalEdges) {
         this.blockedEdges = blockedEdges;
+        this.additionalEdges = additionalEdges;
     }
 
     public static RealtimeFeed empty() {
-        return new RealtimeFeed(new IntHashSet());
+        return new RealtimeFeed(new IntHashSet(), Collections.emptyList());
     }
 
-    public static RealtimeFeed fromProtobuf(GtfsStorage staticGtfs, GtfsRealtime.FeedMessage feedMessage) {
+    public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtFlagEncoder encoder, GtfsRealtime.FeedMessage feedMessage) {
+        String feedKey = "gtfs_0"; //FIXME
+        GTFSFeed feed = staticGtfs.getGtfsFeeds().get(feedKey);
         final IntHashSet blockedEdges = new IntHashSet();
         feedMessage.getEntityList().stream()
             .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
@@ -50,10 +78,190 @@ public static RealtimeFeed fromProtobuf(GtfsStorage staticGtfs, GtfsRealtime.Fee
                             blockedEdges.add(leaveEdges[skippedStopSequenceNumber]);
                         });
             });
-        return new RealtimeFeed(blockedEdges);
+        final List<VirtualEdgeIteratorState> additionalEdges = new ArrayList<>();
+        final Graph overlayGraph = new Graph() {
+            int nNodes = 0;
+            int firstEdge = graph.getAllEdges().getMaxId()+1;
+            final NodeAccess nodeAccess = new NodeAccess() {
+                IntIntHashMap additionalNodeFields = new IntIntHashMap();
+
+                @Override
+                public int getAdditionalNodeField(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public void setAdditionalNodeField(int nodeId, int additionalValue) {
+                    additionalNodeFields.put(nodeId, additionalValue);
+                }
+
+                @Override
+                public boolean is3D() {
+                    return false;
+                }
+
+                @Override
+                public int getDimension() {
+                    return 0;
+                }
+
+                @Override
+                public void ensureNode(int nodeId) {
+
+                }
+
+                @Override
+                public void setNode(int nodeId, double lat, double lon) {
+
+                }
+
+                @Override
+                public void setNode(int nodeId, double lat, double lon, double ele) {
+
+                }
+
+                @Override
+                public double getLatitude(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getLat(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getLongitude(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getLon(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getElevation(int nodeId) {
+                    return 0;
+                }
+
+                @Override
+                public double getEle(int nodeId) {
+                    return 0;
+                }
+            };
+            @Override
+            public Graph getBaseGraph() {
+                return null;
+            }
+
+            @Override
+            public int getNodes() {
+                return graph.getNodes() + nNodes;
+            }
+
+            @Override
+            public NodeAccess getNodeAccess() {
+                return nodeAccess;
+            }
+
+            @Override
+            public BBox getBounds() {
+                return null;
+            }
+
+            @Override
+            public EdgeIteratorState edge(int a, int b) {
+                return null;
+            }
+
+            @Override
+            public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
+                int edge = firstEdge++;
+                final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(-1,
+                        edge, a, b, 0,0, "", new PointList());
+                final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(-1,
+                        edge, b, a, 0,0, "", new PointList());
+
+                newEdge.setReverseEdge(reverseNewEdge);
+                reverseNewEdge.setReverseEdge(newEdge);
+                additionalEdges.add(newEdge);
+//                additionalEdges.add(reverseNewEdge); //FIXME
+                return newEdge;
+            }
+
+            @Override
+            public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
+                return null;
+            }
+
+            @Override
+            public AllEdgesIterator getAllEdges() {
+                return null;
+            }
+
+            @Override
+            public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
+                return null;
+            }
+
+            @Override
+            public EdgeExplorer createEdgeExplorer() {
+                return null;
+            }
+
+            @Override
+            public Graph copyTo(Graph g) {
+                return null;
+            }
+
+            @Override
+            public GraphExtension getExtension() {
+                return staticGtfs;
+            }
+        };
+        final GtfsReader gtfsReader = new GtfsReader(feedKey, overlayGraph, encoder, null);
+        Instant timestamp = Instant.ofEpochSecond(feedMessage.getHeader().getTimestamp());
+        LocalDate dateToChange = timestamp.atZone(ZoneId.of(feed.agency.values().iterator().next().agency_timezone)).toLocalDate(); //FIXME
+
+        feedMessage.getEntityList().stream()
+                .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
+                .map(GtfsRealtime.FeedEntity::getTripUpdate)
+                .filter(tripUpdate -> tripUpdate.getTrip().getScheduleRelationship() == GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED)
+                .map(tripUpdate -> {
+                    Trip trip = new Trip();
+                    trip.trip_id = tripUpdate.getTrip().getTripId();
+                    trip.route_id = tripUpdate.getTrip().getRouteId();
+                    final List<StopTime> stopTimes = tripUpdate.getStopTimeUpdateList().stream()
+                            .map(stopTimeUpdate -> {
+                                final StopTime stopTime = new StopTime();
+                                stopTime.stop_sequence = stopTimeUpdate.getStopSequence();
+                                stopTime.stop_id = stopTimeUpdate.getStopId();
+                                stopTime.trip_id = trip.trip_id;
+                                final ZonedDateTime arrival_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of("America/Los_Angeles"));
+                                stopTime.arrival_time = (int) Duration.between(arrival_time.truncatedTo(ChronoUnit.DAYS), arrival_time).getSeconds();
+                                final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of("America/Los_Angeles"));
+                                stopTime.departure_time = (int) Duration.between(departure_time.truncatedTo(ChronoUnit.DAYS), departure_time).getSeconds();
+                                return stopTime;
+                            })
+                            .collect(Collectors.toList());
+                    BitSet validOnDay = new BitSet();
+                    LocalDate startDate = feed.calculateStats().getStartDate();
+                    validOnDay.set((int) DAYS.between(startDate, dateToChange));
+                    return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
+                })
+                .forEach(trip -> gtfsReader.addTrips(ZoneId.systemDefault(), Collections.singletonList(trip), 0));
+        gtfsReader.wireUpStops();
+        gtfsReader.connectStopsToStationNodes();
+        return new RealtimeFeed(blockedEdges, additionalEdges);
     }
 
     boolean isBlocked(int edgeId) {
         return blockedEdges.contains(edgeId);
     }
+
+    List<VirtualEdgeIteratorState> getAdditionalEdges() {
+        return additionalEdges;
+    }
+
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 708383f909..0afaaa4666 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -26,7 +26,6 @@
 import com.graphhopper.gtfs.fare.Fares;
 import com.graphhopper.routing.InstructionsFromEdges;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
 import com.vividsolutions.jts.geom.Coordinate;
 import com.vividsolutions.jts.geom.Geometry;
@@ -297,7 +296,7 @@ void finish() {
                     edges(path).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
                     lineStringFromEdges(path),
                     edges(path).mapToDouble(edgeLabel -> edgeLabel.distance).sum(),
-                    instructions.stream().collect(Collectors.toCollection(() -> new InstructionList(tr))),
+                    instructions,
                     Date.from(arrivalTime)));
         }
     }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
new file mode 100644
index 0000000000..189cbbe679
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
@@ -0,0 +1,211 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.routing.VirtualEdgeIteratorState;
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+
+import java.util.List;
+import java.util.stream.IntStream;
+
+public class WrapperGraph implements Graph {
+
+    private final Graph baseGraph;
+    private final List<VirtualEdgeIteratorState> extraEdges;
+
+    public WrapperGraph(Graph baseGraph, List<VirtualEdgeIteratorState> extraEdges) {
+        this.baseGraph = baseGraph;
+        this.extraEdges = extraEdges;
+    }
+
+    @Override
+    public Graph getBaseGraph() {
+        return baseGraph;
+    }
+
+    @Override
+    public int getNodes() {
+        return IntStream.concat(
+                IntStream.of(baseGraph.getNodes()-1),
+                extraEdges.stream().flatMapToInt(edge -> IntStream.of(edge.getBaseNode(), edge.getAdjNode())))
+                .max().getAsInt()+1;
+    }
+
+    @Override
+    public NodeAccess getNodeAccess() {
+        return baseGraph.getNodeAccess();
+    }
+
+    @Override
+    public BBox getBounds() {
+        return baseGraph.getBounds();
+    }
+
+    @Override
+    public EdgeIteratorState edge(int a, int b) {
+        return baseGraph.getEdgeIteratorState(a, b);
+    }
+
+    @Override
+    public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
+        throw new RuntimeException();
+    }
+
+    @Override
+    public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
+        return baseGraph.getEdgeIteratorState(edgeId, adjNode);
+    }
+
+    @Override
+    public AllEdgesIterator getAllEdges() {
+        return new AllEdgesIterator() {
+            @Override
+            public int getMaxId() {
+                return IntStream.concat(
+                        IntStream.of(baseGraph.getAllEdges().getMaxId()),
+                        extraEdges.stream().mapToInt(VirtualEdgeIteratorState::getEdge))
+                        .max().getAsInt();
+            }
+
+            @Override
+            public boolean next() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int getEdge() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int getBaseNode() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int getAdjNode() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public PointList fetchWayGeometry(int mode) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setWayGeometry(PointList list) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public double getDistance() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setDistance(double dist) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public long getFlags() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setFlags(long flags) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int getAdditionalField() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setAdditionalField(int value) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean isForward(FlagEncoder encoder) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean isBackward(FlagEncoder encoder) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean getBool(int key, boolean _default) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public String getName() {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setName(String name) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState detach(boolean reverse) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState copyPropertiesTo(EdgeIteratorState e) {
+                throw new UnsupportedOperationException();
+            }
+        };
+    }
+
+    @Override
+    public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
+        return baseGraph.createEdgeExplorer(filter);
+    }
+
+    @Override
+    public EdgeExplorer createEdgeExplorer() {
+        return baseGraph.createEdgeExplorer();
+    }
+
+    @Override
+    public Graph copyTo(Graph g) {
+        throw new RuntimeException();
+    }
+
+    @Override
+    public GraphExtension getExtension() {
+        return baseGraph.getExtension();
+    }
+}
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 208699dbe4..47bc982462 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -33,12 +33,11 @@
 import org.junit.Test;
 
 import java.io.File;
-import java.time.Instant;
-import java.time.LocalDateTime;
-import java.time.ZoneId;
+import java.time.*;
 import java.util.Arrays;
 import java.util.Collections;
 
+import static com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED;
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SKIPPED;
 import static com.graphhopper.reader.gtfs.GtfsHelper.time;
 import static org.junit.Assert.assertEquals;
@@ -85,9 +84,9 @@ public void testSkipDepartureStop() {
 
         // But the 6:00 departure of my line is going to skip my departure stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("wurst"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
         feedMessageBuilder.addEntityBuilder()
-                .setId("pups")
+                .setId("1")
                 .getTripUpdateBuilder()
                 .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
                 .addStopTimeUpdateBuilder()
@@ -116,9 +115,9 @@ public void testSkipArrivalStop() {
 
         // But the 6:00 departure of my line is going to skip my arrival stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("wurst"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
         feedMessageBuilder.addEntityBuilder()
-                .setId("pups")
+                .setId("1")
                 .getTripUpdateBuilder()
                 .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
                 .addStopTimeUpdateBuilder()
@@ -147,9 +146,9 @@ public void testSkipTransferStop() {
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("wurst"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
         feedMessageBuilder.addEntityBuilder()
-                .setId("pups")
+                .setId("1")
                 .getTripUpdateBuilder()
                 .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
                 .addStopTimeUpdateBuilder()
@@ -162,6 +161,59 @@ public void testSkipTransferStop() {
         assertEquals("The 6:44 bus will not call at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
     }
 
+    @Test
+    public void testExtraTrip() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+
+        // I want to go at 6:44
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+
+        // But the 6:00 departure of my line is going to skip my transfer stop :-(
+        final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
+                .setGtfsRealtimeVersion("1")
+                .setTimestamp(ZonedDateTime.of(LocalDate.of(2007,1,1), LocalTime.of(0,0), zoneId).toEpochSecond()));
+
+
+        feedMessageBuilder.addEntityBuilder()
+                .setId("1")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("CITY2").setStartTime("06:00:00"))
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(5)
+                .setScheduleRelationship(SKIPPED);
+
+        final GtfsRealtime.TripUpdate.Builder extraTripUpdate = feedMessageBuilder.addEntityBuilder()
+                .setId("2")
+                .getTripUpdateBuilder()
+                .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setScheduleRelationship(ADDED).setTripId("EXTRA").setRouteId("CITY").setStartTime("06:45:00"));
+        extraTripUpdate
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(1)
+                .setStopId("NADAV")
+                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).atZone(zoneId).toEpochSecond()))
+                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).atZone(zoneId).toEpochSecond()));
+        extraTripUpdate
+                .addStopTimeUpdateBuilder()
+                .setStopSequence(2)
+                .setStopId("BEATTY_AIRPORT")
+                .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).atZone(zoneId).toEpochSecond()))
+                .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).atZone(zoneId).toEpochSecond()));
+
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
+        assertEquals(1, response.getAll().size());
+
+        assertEquals("Luckily, there is an extra service directly from my stop to the airport, at 6:45, taking 30 minutes", time(0, 31), response.getBest().getTime(), 0.1);
+    }
+
+
     @Test
     public void testBlockTrips() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
@@ -177,9 +229,9 @@ public void testBlockTrips() {
         // My line does not stop at Bullfrog today. If this was a real transfer, I would not be
         // able to change lines there. But it is not a real transfer, so I can go on as planned.
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
-        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("wurst"));
+        feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder().setGtfsRealtimeVersion("1"));
         feedMessageBuilder.addEntityBuilder()
-                .setId("pups")
+                .setId("1")
                 .getTripUpdateBuilder()
                 .setTrip(GtfsRealtime.TripDescriptor.newBuilder().setTripId("AB1").setStartTime("00:00:00"))
                 .addStopTimeUpdateBuilder()
diff --git a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java b/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
index cb31c43956..33cc90ea75 100644
--- a/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
+++ b/reader-json/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupHelper.java
@@ -3,6 +3,7 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.json.GHJsonFactory;
 import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.routing.lm.LandmarkStorage;
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.FlagEncoderFactory;
@@ -11,12 +12,15 @@
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupBuilder;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.PMap;
+import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.BBox;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.io.FileReader;
 import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
 
 /**
  * Helper class to build the spatial rule index
@@ -27,7 +31,7 @@
 
     private static final Logger logger = LoggerFactory.getLogger(SpatialRuleLookupHelper.class);
 
-    public static void buildAndInjectSpatialRuleIntoGH(GraphHopper graphHopper, CmdArgs args){
+    public static void buildAndInjectSpatialRuleIntoGH(GraphHopper graphHopper, CmdArgs args) {
         String spatialRuleLocation = args.get("spatial_rules.location", "");
         if (!spatialRuleLocation.isEmpty()) {
             try {
@@ -52,4 +56,14 @@ public FlagEncoder createFlagEncoder(String name, PMap configuration) {
         }
     }
 
+    public static JsonFeatureCollection createLandmarkSplittingFeatureCollection(String location) {
+        try {
+            Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
+            return new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class);
+        } catch (IOException e) {
+            logger.error("Problem while reading border map GeoJSON. Skipping this.", e);
+        }
+        return null;
+    }
+
 }
diff --git a/reader-osm/pom.xml b/reader-osm/pom.xml
index e323f00cbf..5d560fa97a 100644
--- a/reader-osm/pom.xml
+++ b/reader-osm/pom.xml
@@ -25,7 +25,7 @@
         <dependency>
             <groupId>org.openstreetmap.osmosis</groupId>
             <artifactId>osmosis-osm-binary</artifactId>
-            <version>0.45</version>
+            <version>0.46</version>
         </dependency>
         <!-- 
         <dependency>
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java
index 0c8e47ff70..13fd33146c 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/GraphHopperOSM.java
@@ -18,15 +18,32 @@
 package com.graphhopper.reader.osm;
 
 import com.graphhopper.GraphHopper;
+import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.reader.DataReader;
+import com.graphhopper.routing.lm.PrepareLandmarks;
+import com.graphhopper.routing.util.spatialrules.*;
 import com.graphhopper.storage.GraphHopperStorage;
 
+import java.util.List;
+
 /**
  * This class is the simplified entry to all functionality if you import from OpenStreetMap data.
  *
  * @author Peter Karich
  */
 public class GraphHopperOSM extends GraphHopper {
+
+    private final JsonFeatureCollection landmarkSplittingFeatureCollection;
+
+    public GraphHopperOSM() {
+        this(null);
+    }
+
+    public GraphHopperOSM(JsonFeatureCollection landmarkSplittingFeatureCollection) {
+        super();
+        this.landmarkSplittingFeatureCollection = landmarkSplittingFeatureCollection;
+    }
+
     @Override
     protected DataReader createReader(GraphHopperStorage ghStorage) {
         return initDataReader(new OSMReader(ghStorage));
@@ -44,4 +61,32 @@ public GraphHopperOSM setOSMFile(String osmFileStr) {
         super.setDataReaderFile(osmFileStr);
         return this;
     }
+
+    @Override
+    protected void loadOrPrepareLM() {
+        if (!getLMFactoryDecorator().isEnabled() || getLMFactoryDecorator().getPreparations().isEmpty())
+            return;
+
+        if (landmarkSplittingFeatureCollection != null && !landmarkSplittingFeatureCollection.getFeatures().isEmpty()) {
+            SpatialRuleLookup ruleLookup = SpatialRuleLookupBuilder.buildIndex(landmarkSplittingFeatureCollection, "area", new SpatialRuleLookupBuilder.SpatialRuleFactory() {
+                @Override
+                public SpatialRule createSpatialRule(final String id, List<Polygon> polygons) {
+                    return new DefaultSpatialRule() {
+                        @Override
+                        public String getId() {
+                            return id;
+                        }
+                    }.setBorders(polygons);
+                }
+            });
+            for (PrepareLandmarks prep : getLMFactoryDecorator().getPreparations()) {
+                // the ruleLookup splits certain areas from each other but avoids making this a permanent change so that other algorithms still can route through these regions.
+                if (ruleLookup != null && ruleLookup.size() > 0) {
+                    prep.setSpatialRuleLookup(ruleLookup);
+                }
+            }
+        }
+
+        super.loadOrPrepareLM();
+    }
 }
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index f194d8bef9..9621b33e92 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -51,12 +51,12 @@
  * This class parses an OSM xml or pbf file and creates a graph from it. It does so in a two phase
  * parsing processes in order to reduce memory usage compared to a single parsing processing.
  * <p>
- * 1. a) Reads ways from OSM file and stores all associated node ids in osmNodeIdToIndexMap. If a
+ * 1. a) Reads ways from OSM file and stores all associated node ids in {@link #osmNodeIdToInternalNodeMap}. If a
  * node occurs once it is a pillar node and if more it is a tower node, otherwise
- * osmNodeIdToIndexMap returns EMPTY.
+ * {@link #osmNodeIdToInternalNodeMap} returns EMPTY.
  * <p>
  * 1. b) Reads relations from OSM file. In case that the relation is a route relation, it stores
- * specific relation attributes required for routing into osmWayIdToRouteWeigthMap for all the ways
+ * specific relation attributes required for routing into {@link #osmWayIdToRouteWeightMap} for all the ways
  * of the relation.
  * <p>
  * 2.a) Reads nodes from OSM file and stores lat+lon information either into the intermediate
@@ -64,7 +64,7 @@
  * graphStorage via setLatitude/setLongitude. It can also happen that a pillar node needs to be
  * transformed into a tower node e.g. via barriers or different speed values for one way.
  * <p>
- * 2.b) Reads ways OSM file and creates edges while calculating the speed etc from the OSM tags.
+ * 2.b) Reads ways from OSM file and creates edges while calculating the speed etc from the OSM tags.
  * When creating an edge the pillar node information from the intermediate data structure will be
  * stored in the way geometry of that edge.
  * <p>
@@ -263,7 +263,7 @@ private void writeOsm2Graph(File osmFile) {
             while ((item = in.getNext()) != null) {
                 switch (item.getType()) {
                     case ReaderElement.NODE:
-                        if (nodeFilter.get(item.getId()) != -1) {
+                        if (nodeFilter.get(item.getId()) != EMPTY_NODE) {
                             processNode((ReaderNode) item);
                         }
                         break;
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index 0b6b0282ad..938ca0d7a3 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -661,12 +661,12 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
 
         assertEquals("Turn right onto Pfarrplatz", resultJson.get(2).get("text"));
         assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
-        assertEquals("Turn slight left onto Hoher Markt", resultJson.get(5).get("text"));
+        assertEquals("Keep left onto Hoher Markt", resultJson.get(5).get("text"));
         assertEquals("Turn right onto Wegscheid", resultJson.get(7).get("text"));
         assertEquals("Turn right onto Ringstraße, L73", resultJson.get(9).get("text"));
-        assertEquals("Turn slight left onto Eyblparkstraße", resultJson.get(10).get("text"));
-        assertEquals("Turn slight left onto Austraße", resultJson.get(11).get("text"));
-        assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(12).get("text"));
+        assertEquals("Keep left onto Eyblparkstraße", resultJson.get(10).get("text"));
+        assertEquals("Keep left onto Austraße", resultJson.get(11).get("text"));
+        assertEquals("Keep left onto Rechte Kremszeile", resultJson.get(12).get("text"));
         //..
         assertEquals("Turn right onto Treppelweg", resultJson.get(19).get("text"));
         assertEquals("cycleway", resultJson.get(19).get("annotation_text"));
@@ -712,6 +712,33 @@ public void testRoundaboutInstructionsWithCH() {
         assertEquals(2, ((RoundaboutInstruction) arsp.getInstructions().get(1)).getExitNumber());
     }
 
+    @Test
+    public void testCircularJunctionInstructionsWithCH() {
+        String tmpOsmFile = DIR + "/berlin-siegessaeule.osm.gz";
+        String tmpVehicle = "car";
+        String tmpImportVehicles = "car,bike";
+        String tmpWeightCalcStr = "fastest";
+
+        GraphHopper tmpHopper = new GraphHopperOSM().
+                setOSMFile(tmpOsmFile).
+                setStoreOnFlush(true).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        assertEquals(tmpVehicle, tmpHopper.getDefaultVehicle().toString());
+
+        assertEquals(2, tmpHopper.getCHFactoryDecorator().getPreparations().size());
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(52.513505,13.350443, 52.513505,13.350245)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+
+        Instruction instr = rsp.getBest().getInstructions().get(1);
+        assertTrue(instr instanceof RoundaboutInstruction);
+        assertEquals(5, ((RoundaboutInstruction) instr).getExitNumber());
+    }
+
+
     @Test
     public void testMultipleVehiclesWithCH() {
         String tmpOsmFile = DIR + "/monaco.osm.gz";
@@ -806,10 +833,9 @@ private void executeCHFootRoute() {
     @Test
     public void testRoundTour() {
         GHRequest rq = new GHRequest().
-                addPoint(new GHPoint(43.741069, 7.426854)).
+                addPoint(new GHPoint(43.741069, 7.426854), 50).
                 setVehicle(vehicle).setWeighting("fastest").
                 setAlgorithm(ROUND_TRIP);
-        rq.getHints().put(RoundTrip.HEADING, 50);
         rq.getHints().put(RoundTrip.DISTANCE, 1000);
         rq.getHints().put(RoundTrip.SEED, 0);
 
diff --git a/tools/src/main/java/com/graphhopper/tools/Import.java b/tools/src/main/java/com/graphhopper/tools/Import.java
index 7854e9fd76..84c1571919 100644
--- a/tools/src/main/java/com/graphhopper/tools/Import.java
+++ b/tools/src/main/java/com/graphhopper/tools/Import.java
@@ -18,18 +18,33 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.GraphHopper;
+import com.graphhopper.json.GHJsonFactory;
+import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.routing.lm.LandmarkStorage;
 import com.graphhopper.spatialrules.SpatialRuleLookupHelper;
 import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Parameters;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
 
 /**
  * @author Peter Karich
  */
 public class Import {
+    private static final Logger logger = LoggerFactory.getLogger(Import.class);
+
     public static void main(String[] strs) throws Exception {
         CmdArgs args = CmdArgs.read(strs);
         args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
-        GraphHopper hopper = new GraphHopperOSM();
+        GraphHopper hopper = new GraphHopperOSM(
+                SpatialRuleLookupHelper.createLandmarkSplittingFeatureCollection(args.get(Parameters.Landmark.PREPARE + "split_area_location", ""))
+        );
         SpatialRuleLookupHelper.buildAndInjectSpatialRuleIntoGH(hopper, args);
         hopper.init(args);
         hopper.importOrLoad();
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index d178122a26..7ec739bcea 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -48,6 +48,8 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
+
 /**
  * @author Peter Karich
  */
@@ -115,14 +117,14 @@ protected DataReader importData() throws IOException {
             GHBitSet allowedEdges = printGraphDetails(g, vehicleStr);
             printMiscUnitPerfTests(g, isCH, encoder, count * 100, allowedEdges);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
-            printTimeOfRouteQuery(hopper, isCH, isLM, count / 20, "routing", vehicleStr, true, -1);
+            printTimeOfRouteQuery(hopper, isCH, isLM, count / 20, "routing", vehicleStr, true, -1, true);
 
             if (hopper.getLMFactoryDecorator().isEnabled()) {
                 System.gc();
                 isLM = true;
                 int activeLMCount = 12;
                 for (; activeLMCount > 3; activeLMCount -= 4) {
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count / 4, "routingLM" + activeLMCount, vehicleStr, true, activeLMCount);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count / 4, "routingLM" + activeLMCount, vehicleStr, true, activeLMCount, true);
                 }
 
                 // compareRouting(hopper, vehicleStr, count / 5);
@@ -130,13 +132,13 @@ protected DataReader importData() throws IOException {
 
             if (hopper.getCHFactoryDecorator().isEnabled()) {
                 isCH = true;
-
+//                compareCHWithAndWithoutSOD(hopper, vehicleStr, count/5);
                 if (hopper.getLMFactoryDecorator().isEnabled()) {
                     isLM = true;
                     System.gc();
                     // try just one constellation, often ~4-6 is best
                     int lmCount = 5;
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCHLM" + lmCount, vehicleStr, true, lmCount);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCHLM" + lmCount, vehicleStr, true, lmCount, true);
                 }
 
                 isLM = false;
@@ -145,8 +147,9 @@ protected DataReader importData() throws IOException {
                 CHGraph lg = g.getGraph(CHGraph.class, weighting);
                 fillAllowedEdges(lg.getAllEdges(), allowedEdges);
                 printMiscUnitPerfTests(lg, isCH, encoder, count * 100, allowedEdges);
-                printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH", vehicleStr, true, -1);
-                printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_instr", vehicleStr, false, -1);
+                printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH", vehicleStr, true, -1, true);
+                printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_sod", vehicleStr, true, -1, false);
+                printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_instr", vehicleStr, false, -1, true);
             }
             logger.info("store into " + propLocation);
         } catch (Exception ex) {
@@ -322,9 +325,59 @@ private void compareRouting(final GraphHopper hopper, String vehicle, int count)
         }
     }
 
+    private void compareCHWithAndWithoutSOD(final GraphHopper hopper, String vehicle, int count) {
+        logger.info("Comparing " + count + " routes for CH with and without stall on demand." +
+                " Differences will be printed to stderr.");
+        final Random rand = new Random(seed);
+        final Graph g = hopper.getGraphHopperStorage();
+        final NodeAccess na = g.getNodeAccess();
+
+        for (int i = 0; i < count; i++) {
+            int from = rand.nextInt(maxNode);
+            int to = rand.nextInt(maxNode);
+
+            double fromLat = na.getLatitude(from);
+            double fromLon = na.getLongitude(from);
+            double toLat = na.getLatitude(to);
+            double toLon = na.getLongitude(to);
+            GHRequest sodReq = new GHRequest(fromLat, fromLon, toLat, toLon).
+                    setWeighting("fastest").
+                    setVehicle(vehicle).
+                    setAlgorithm(DIJKSTRA_BI);
+
+            GHRequest noSodReq = new GHRequest(fromLat, fromLon, toLat, toLon).
+                    setWeighting("fastest").
+                    setVehicle(vehicle).
+                    setAlgorithm(DIJKSTRA_BI);
+            noSodReq.getHints().put("stall_on_demand", false);
+
+            GHResponse sodRsp = hopper.route(sodReq);
+            GHResponse noSodRsp = hopper.route(noSodReq);
+
+            String locStr = " iteration " + i + ". " + fromLat + "," + fromLon + " -> " + toLat + "," + toLon;
+            if (sodRsp.hasErrors()) {
+                if (noSodRsp.hasErrors()) {
+                    logger.info("Error with and without SOD");
+                    continue;
+                } else {
+                    logger.error("Error with SOD but not without SOD" + locStr);
+                    continue;
+                }
+            }
+            String infoStr =
+                    " weight:" + noSodRsp.getBest().getRouteWeight() + ", original: " + sodRsp.getBest().getRouteWeight()
+                            + " distance:" + noSodRsp.getBest().getDistance() + ", original: " + sodRsp.getBest().getDistance()
+                            + " time:" + Helper.round2(noSodRsp.getBest().getTime() / 1000) + ", original: " + Helper.round2(sodRsp.getBest().getTime() / 1000)
+                            + " points:" + noSodRsp.getBest().getPoints().size() + ", original: " + sodRsp.getBest().getPoints().size();
+
+            if (Math.abs(1 - noSodRsp.getBest().getRouteWeight() / sodRsp.getBest().getRouteWeight()) > 0.000001)
+                logger.error("Too big weight difference for SOD. " + locStr + infoStr);
+        }
+    }
+
     private void printTimeOfRouteQuery(final GraphHopper hopper, final boolean ch, final boolean lm,
                                        int count, String prefix, final String vehicle,
-                                       final boolean withInstructions, final int activeLandmarks) {
+                                       final boolean withInstructions, final int activeLandmarks, final boolean sod) {
         final Graph g = hopper.getGraphHopperStorage();
         final AtomicLong maxDistance = new AtomicLong(0);
         final AtomicLong minDistance = new AtomicLong(Long.MAX_VALUE);
@@ -355,6 +408,7 @@ public int doCalc(boolean warmup, int run) {
                         setVehicle(vehicle);
 
                 req.getHints().put(CH.DISABLE, !ch).
+                        put("stall_on_demand", sod).
                         put(Landmark.DISABLE, !lm).
                         put(Landmark.ACTIVE_COUNT, activeLandmarks).
                         put("instructions", withInstructions);
@@ -412,8 +466,11 @@ else if (!rsp.getErrors().get(0).getMessage().toLowerCase().contains("not found"
 
         count -= failedCount.get();
 
-        // if using none-bidirectional algorithm make sure you exclude CH routing
-        final String algoStr = ch ? Algorithms.DIJKSTRA_BI : Algorithms.ASTAR_BI;
+        // if using non-bidirectional algorithm make sure you exclude CH routing
+        String algoStr = ch ? Algorithms.DIJKSTRA_BI : Algorithms.ASTAR_BI;
+        if (ch && !sod) {
+            algoStr += "_no_sod";
+        }
         put(prefix + ".guessed_algorithm", algoStr);
         put(prefix + ".failed_count", failedCount.get());
         put(prefix + ".distance_min", minDistance.get());
diff --git a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
index 02aa88ae36..543526958c 100644
--- a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
+++ b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
@@ -125,11 +125,11 @@ public void plotNode(Graphics2D g2, int loc, Color c) {
 
 
     public void plotNode(Graphics2D g2, int loc, Color c, int size) {
-        plotNode(g2, loc, c, size);
+        plotNode(g2, loc, c, size, "");
     }
 
     public void plotNode(Graphics2D g2, int loc, Color c, int size, String text) {
-        plotNode(g2, na, loc, c, 4, "");
+        plotNode(g2, na, loc, c, size, "");
     }
 
     public void plotNode(Graphics2D g2, NodeAccess na, int loc, Color c, int size, String text) {
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 44a94e10af..1e549e0b0f 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -97,7 +97,7 @@ public MiniGraphUI(GraphHopper hopper, boolean debug) {
             final RoutingAlgorithmFactory tmpFactory = hopper.getAlgorithmFactory(map);
             algoFactory = new RoutingAlgorithmFactory() {
 
-                class TmpAlgo extends PrepareContractionHierarchies.DijkstraBidirectionCH implements DebugAlgo {
+                class TmpAlgo extends DijkstraBidirectionCH implements DebugAlgo {
                     private final GraphicsWrapper mg;
                     private Graphics2D g2;
 
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
index 23658883b3..c1329ba70e 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
@@ -68,43 +68,9 @@ protected void configure() {
     @Provides
     @Singleton
     GraphHopper createGraphHopper(CmdArgs args) {
-        GraphHopper graphHopper = new GraphHopperOSM() {
-            @Override
-            protected void loadOrPrepareLM() {
-                if (!getLMFactoryDecorator().isEnabled() || getLMFactoryDecorator().getPreparations().isEmpty())
-                    return;
-
-                try {
-                    String location = args.get(Parameters.Landmark.PREPARE + "split_area_location", "");
-                    Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
-                    JsonFeatureCollection jsonFeatureCollection = new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class);
-                    if (!jsonFeatureCollection.getFeatures().isEmpty()) {
-                        SpatialRuleLookup ruleLookup = SpatialRuleLookupBuilder.buildIndex(jsonFeatureCollection, "area", new SpatialRuleLookupBuilder.SpatialRuleFactory() {
-                            @Override
-                            public SpatialRule createSpatialRule(String id, List<Polygon> polygons) {
-                                return new DefaultSpatialRule() {
-                                    @Override
-                                    public String getId() {
-                                        return id;
-                                    }
-                                }.setBorders(polygons);
-                            }
-                        });
-                        for (PrepareLandmarks prep : getLMFactoryDecorator().getPreparations()) {
-                            // the ruleLookup splits certain areas from each other but avoids making this a permanent change so that other algorithms still can route through these regions.
-                            if (ruleLookup != null && ruleLookup.size() > 0) {
-                                prep.setSpatialRuleLookup(ruleLookup);
-                            }
-                        }
-                    }
-                } catch (IOException ex) {
-                    logger.error("Problem while reading border map GeoJSON. Skipping this.", ex);
-                }
-
-                super.loadOrPrepareLM();
-            }
-        }.forServer();
-
+        GraphHopper graphHopper = new GraphHopperOSM(
+                SpatialRuleLookupHelper.createLandmarkSplittingFeatureCollection(args.get(Parameters.Landmark.PREPARE + "split_area_location", ""))
+        ).forServer();
         SpatialRuleLookupHelper.buildAndInjectSpatialRuleIntoGH(graphHopper, args);
 
         graphHopper.init(args);
diff --git a/web/src/main/webapp/css/style.css b/web/src/main/webapp/css/style.css
index 3c8e742745..1b7ea19d39 100644
--- a/web/src/main/webapp/css/style.css
+++ b/web/src/main/webapp/css/style.css
@@ -50,7 +50,7 @@ body {
 }
 
 .pointInput {
-    width: 220px;
+    width: 215px;
     float: left;
 }
 
@@ -79,6 +79,7 @@ body {
 }
 
 .time_input {
+    display: none;
     float: right;
     padding-right: 20px;
 }
@@ -196,6 +197,7 @@ body {
     clear: both;
 }
 #hosting {
+    clear: both;
     display: none;
     /* float: left;*/
     padding-top: 4px;
diff --git a/web/src/main/webapp/img/direction-icons.svg b/web/src/main/webapp/img/direction-icons.svg
new file mode 100644
index 0000000000..a4a51d0f8f
--- /dev/null
+++ b/web/src/main/webapp/img/direction-icons.svg
@@ -0,0 +1,421 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="210mm"
+   height="297mm"
+   id="svg2"
+   version="1.1"
+   inkscape:version="0.91 r13725"
+   inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
+   inkscape:export-xdpi="134.39999"
+   inkscape:export-ydpi="134.39999"
+   sodipodi:docname="left.svg">
+  <defs
+     id="defs4">
+    <marker
+       inkscape:stockid="Arrow2Send"
+       orient="auto"
+       refY="0.0"
+       refX="0.0"
+       id="Arrow2Send"
+       style="overflow:visible;">
+      <path
+         id="path3792"
+         style="fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round;"
+         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z "
+         transform="scale(0.3) rotate(180) translate(-2.3,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Mend"
+       orient="auto"
+       refY="0.0"
+       refX="0.0"
+       id="Arrow2Mend"
+       style="overflow:visible;">
+      <path
+         id="path3786"
+         style="fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round;"
+         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z "
+         transform="scale(0.6) rotate(180) translate(0,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Lend"
+       orient="auto"
+       refY="0.0"
+       refX="0.0"
+       id="Arrow2Lend"
+       style="overflow:visible;">
+      <path
+         id="path3780"
+         style="fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round;"
+         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z "
+         transform="scale(1.1) rotate(180) translate(1,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Send"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Send-5"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path3792-3"
+         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Send"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Send-6"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path3792-33"
+         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Send"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Send-9"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path3792-8"
+         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Send"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="Arrow2Send-7"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path3792-85"
+         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Send"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="marker3862"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path3864"
+         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
+    </marker>
+    <marker
+       inkscape:stockid="Arrow2Send"
+       orient="auto"
+       refY="0"
+       refX="0"
+       id="marker3866"
+       style="overflow:visible">
+      <path
+         inkscape:connector-curvature="0"
+         id="path3868"
+         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
+         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
+    </marker>
+  </defs>
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="2.8"
+     inkscape:cx="107.42943"
+     inkscape:cy="956.50972"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     inkscape:window-width="1920"
+     inkscape:window-height="1025"
+     inkscape:window-x="0"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Ebene 1"
+     inkscape:groupmode="layer"
+     id="layer1">
+    <g
+       id="g3936"
+       style="fill:#454545;fill-opacity:1">
+      <path
+         style="font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-indent:0;text-align:start;text-decoration:none;line-height:normal;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;text-anchor:start;baseline-shift:baseline;color:#000000;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.50000000000000000;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate;font-family:Sans;-inkscape-font-specification:Sans"
+         d="m 33.0625,53.25 a 3.750375,3.750375 0 0 0 -1.375,0.34375 L 8.5625,63.875 11.625,70.71875 29.46875,62.78125 29.625,88.6875 37.125,88.65625 36.9375,57 a 3.750375,3.750375 0 0 0 -3.875,-3.75 z"
+         id="path2985"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/sharp_left.png"
+         inkscape:export-xdpi="158.22"
+         inkscape:export-ydpi="158.22" />
+      <path
+         d="M 26.968872,69.717593 0.83438412,71.461948 19.61278,53.201989 c -1.416083,6.473329 1.575601,13.134518 7.356092,16.515604 z"
+         style="fill-rule:evenodd;stroke-width:0.62500000000000000;stroke-linejoin:round;fill:#454545;fill-opacity:1"
+         id="path3942"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/sharp_left.png"
+         inkscape:export-xdpi="158.22"
+         inkscape:export-ydpi="158.22" />
+    </g>
+    <g
+       id="g3928"
+       style="fill:#454545;fill-opacity:1">
+      <path
+         style="font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-indent:0;text-align:start;text-decoration:none;line-height:normal;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;text-anchor:start;baseline-shift:baseline;color:#000000;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.5;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate;font-family:Sans;-inkscape-font-specification:Sans"
+         d="m 63.65625,9.15625 -27.125,0.28125 0.09375,7.5 23.34375,-0.25 0.15625,25.90625 7.5,-0.03125 L 67.4375,12.875 C 67.42101,10.911541 65.619711,9.140016 63.65625,9.15625 z"
+         id="path2985-5"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/left.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cccccccc" />
+      <path
+         d="M 51.117055,24.124359 26.443245,13.334742 50.933347,2.0455451 C 47.060409,7.4223129 47.157235,18.723836 51.117055,24.124359 z"
+         style="fill:#454545;fill-opacity:1;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         id="path3934"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/left.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cccc" />
+    </g>
+    <g
+       id="g3920"
+       style="fill:#454545;fill-opacity:1">
+      <path
+         style="font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-indent:0;text-align:start;text-decoration:none;line-height:normal;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;text-anchor:start;baseline-shift:baseline;color:#000000;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.50000000000000000;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate;font-family:Sans;-inkscape-font-specification:Sans"
+         d="M 82.21875,-43.8125 76.0625,-39.53125 90.53125,-18.75 90.6875,1.75 98.1875,1.6875 98.03125,-20 a 3.750375,3.750375 0 0 0 -0.6875,-2.09375 l -15.125,-21.71875 z"
+         id="path2985-2"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_left.png"
+         inkscape:export-xdpi="111.38422"
+         inkscape:export-ydpi="111.38422" />
+      <path
+         d="m 79.961103,-24.623612 -6.631353,-25.339285 21.467558,15.006605 c -6.62416,-0.172588 -12.60334,4.019192 -14.836205,10.33268 z"
+         style="fill-rule:evenodd;stroke-width:0.62500000000000000;stroke-linejoin:round;fill:#454545;fill-opacity:1"
+         id="path3926"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_left.png"
+         inkscape:export-xdpi="111.38422"
+         inkscape:export-ydpi="111.38422" />
+    </g>
+    <g
+       id="g3912"
+       style="fill:#454545;fill-opacity:1">
+      <path
+         style="font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-indent:0;text-align:start;text-decoration:none;line-height:normal;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;text-anchor:start;baseline-shift:baseline;color:#000000;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.50000000000000000;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate;font-family:Sans;-inkscape-font-specification:Sans"
+         d="M 200.625,53.28125 A 3.750375,3.750375 0 0 0 197.1875,57 L 197,88.6875 l 7.5,0.03125 0.15625,-25.9375 L 222.5,70.75 l 3.0625,-6.84375 -23.125,-10.3125 a 3.750375,3.750375 0 0 0 -1.8125,-0.3125 z"
+         id="path2985-57"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/sharp_right.png"
+         inkscape:export-xdpi="159.82001"
+         inkscape:export-ydpi="159.82001" />
+      <path
+         d="m 214.53892,53.152176 18.77839,18.259957 -26.13449,-1.744353 c 5.75912,-3.277477 8.70946,-9.957081 7.3561,-16.515604 z"
+         style="fill-rule:evenodd;stroke-width:0.62500000000000000;stroke-linejoin:round;fill:#454545;fill-opacity:1"
+         id="path3918"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/sharp_right.png"
+         inkscape:export-xdpi="159.82001"
+         inkscape:export-ydpi="159.82001" />
+    </g>
+    <g
+       id="g3896"
+       style="fill:#454545;fill-opacity:1">
+      <path
+         style="font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-indent:0;text-align:start;text-decoration:none;line-height:normal;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;text-anchor:start;baseline-shift:baseline;color:#000000;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.50000000000000000;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate;font-family:Sans;-inkscape-font-specification:Sans"
+         d="m 151.875,-43.78125 -15.09375,21.6875 a 3.750375,3.750375 0 0 0 -0.6875,2.125 l -0.15625,21.65625 7.5,0.0625 0.15625,-20.5 14.4375,-20.75 -6.15625,-4.28125 z"
+         id="path2985-2-5"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_right.png"
+         inkscape:export-xdpi="111.33009"
+         inkscape:export-ydpi="111.33009" />
+      <path
+         d="m 139.26593,-34.981469 21.46757,-15.0066 -6.63136,25.339284 c -2.13513,-6.272998 -8.14018,-10.427639 -14.83621,-10.332684 z"
+         style="fill-rule:evenodd;stroke-width:0.62500000000000000;stroke-linejoin:round;fill:#454545;fill-opacity:1"
+         id="path3902"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_right.png"
+         inkscape:export-xdpi="111.33009"
+         inkscape:export-ydpi="111.33009" />
+    </g>
+    <g
+       transform="matrix(-1,0,0,1,227.22453,1.4547068)"
+       id="g3928-3"
+       style="fill:#454545;fill-opacity:1">
+      <path
+         style="font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-indent:0;text-align:start;text-decoration:none;line-height:normal;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;text-anchor:start;baseline-shift:baseline;color:#000000;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.5;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate;font-family:Sans;-inkscape-font-specification:Sans"
+         d="m 63.65625,9.15625 -27.125,0.28125 0.09375,7.5 23.34375,-0.25 0.15625,25.90625 7.5,-0.03125 L 67.4375,12.875 C 67.42101,10.911541 65.619711,9.140016 63.65625,9.15625 z"
+         id="path2985-5-8"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cccccccc" />
+      <path
+         d="M 51.117055,24.124359 26.443245,13.334742 50.933347,2.0455451 C 47.060409,7.4223129 47.157235,18.723836 51.117055,24.124359 z"
+         style="fill:#454545;fill-opacity:1;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         id="path3934-8"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cccc" />
+    </g>
+    <rect
+       style="fill:none;fill-opacity:1;stroke:#000000;stroke-opacity:1;stroke-width:0.101;stroke-miterlimit:4;stroke-dasharray:none"
+       id="rect4276"
+       width="57.85714"
+       height="61.42857"
+       x="57.5"
+       y="79.147926"
+       inkscape:export-filename="/home/peter/Documents/quell/graphhopper/web/src/main/webapp/img/transfer_to.png"
+       inkscape:export-xdpi="70"
+       inkscape:export-ydpi="70" />
+    <g
+       transform="matrix(-0.75288337,-0.88637697,-0.64661773,1.0320448,139.41548,125.89179)"
+       id="g3928-3-3"
+       style="fill:#454545;fill-opacity:1"
+       inkscape:export-filename="/home/peter/Documents/quell/graphhopper/web/src/main/webapp/img/transfer_to.png"
+       inkscape:export-xdpi="70"
+       inkscape:export-ydpi="70">
+      <path
+         style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:Sans;-inkscape-font-specification:Sans;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;display:inline;overflow:visible;visibility:visible;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.5;marker:none;enable-background:accumulate"
+         d="m 36.53125,9.4375 0.09375,7.5 c 0,0 15.27268,0.396364 21.125441,6.151959 5.852761,5.755595 0.313457,17.041996 0.313457,17.041996 L 67.625,42.5625 c 0,0 2.810106,-16.136548 -2.120571,-23.026497 C 59.722211,11.456143 43.621291,9.3639857 36.53125,9.4375 Z"
+         id="path2985-5-8-6"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cczccsc" />
+      <path
+         d="M 53.953299,30.423141 24.292139,12.525415 51.617519,1.2489354 C 42.5147,9.4011194 43.849385,21.129946 53.953299,30.423141 Z"
+         style="fill:#454545;fill-opacity:1;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         id="path3934-8-7"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/right.png"
+         inkscape:export-xdpi="140.92999"
+         inkscape:export-ydpi="140.92999"
+         sodipodi:nodetypes="cccc" />
+    </g>
+    <circle
+       style="fill:#454545;fill-opacity:1"
+       id="path4244-3-5"
+       cx="65.984802"
+       cy="128.64793"
+       inkscape:export-filename="/home/peter/Documents/quell/graphhopper/web/src/main/webapp/img/transfer_to.png"
+       inkscape:export-xdpi="70"
+       inkscape:export-ydpi="70"
+       r="8.2142859" />
+    <circle
+       style="fill:#454545;fill-opacity:1"
+       id="path4244-3-5-2"
+       cx="106.07143"
+       cy="128.79079"
+       inkscape:export-filename="/home/peter/Documents/quell/graphhopper/web/src/main/webapp/img/transfer_to.png"
+       inkscape:export-xdpi="70"
+       inkscape:export-ydpi="70"
+       r="8.2142859" />
+    <g
+       transform="translate(44.878785,186.48123)"
+       id="g3896-3"
+       style="fill:#454545;fill-opacity:1">
+      <path
+         style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:Sans;-inkscape-font-specification:Sans;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;display:inline;overflow:visible;visibility:visible;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.5;marker:none;enable-background:accumulate"
+         d="m 151.875,-43.78125 -15.09375,21.6875 a 3.750375,3.750375 0 0 0 -0.6875,2.125 l -0.15625,21.65625 7.5,0.0625 0.15625,-20.5 14.4375,-20.75 -6.15625,-4.28125 z"
+         id="path2985-2-5-6"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_right.png"
+         inkscape:export-xdpi="111.33009"
+         inkscape:export-ydpi="111.33009" />
+      <path
+         d="m 139.26593,-34.981469 21.46757,-15.0066 -6.63136,25.339284 c -2.13513,-6.272998 -8.14018,-10.427639 -14.83621,-10.332684 z"
+         style="fill:#454545;fill-opacity:1;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         id="path3902-7"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_right.png"
+         inkscape:export-xdpi="111.33009"
+         inkscape:export-ydpi="111.33009" />
+    </g>
+    <path
+       inkscape:export-ydpi="111.33009"
+       inkscape:export-xdpi="111.33009"
+       inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_right.png"
+       inkscape:connector-curvature="0"
+       id="path2985-2-5-6-3"
+       d="m 187.73946,187.46171 c -0.29079,-21.60561 2.82368,-24.68941 -11.81123,-45.19825 l -5.53521,4.22349 c 13.38965,18.0529 10.73771,18.20147 11.07454,40.96696 z"
+       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:Sans;-inkscape-font-specification:Sans;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;display:inline;overflow:visible;visibility:visible;fill:none;fill-opacity:1;stroke:#454545;stroke-width:1.50225437;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker:none;enable-background:accumulate"
+       sodipodi:nodetypes="ccccc" />
+    <g
+       transform="matrix(-1,0,0,1,286.80079,186.55715)"
+       id="g3896-3-6"
+       style="fill:#454545;fill-opacity:1">
+      <path
+         style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:Sans;-inkscape-font-specification:Sans;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;display:inline;overflow:visible;visibility:visible;fill:#454545;fill-opacity:1;stroke:none;stroke-width:7.5;marker:none;enable-background:accumulate"
+         d="m 151.875,-43.78125 -15.09375,21.6875 a 3.750375,3.750375 0 0 0 -0.6875,2.125 l -0.15625,21.65625 7.5,0.0625 0.15625,-20.5 14.4375,-20.75 -6.15625,-4.28125 z"
+         id="path2985-2-5-6-2"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_right.png"
+         inkscape:export-xdpi="111.33009"
+         inkscape:export-ydpi="111.33009" />
+      <path
+         d="m 139.26593,-34.981469 21.46757,-15.0066 -6.63136,25.339284 c -2.13513,-6.272998 -8.14018,-10.427639 -14.83621,-10.332684 z"
+         style="fill:#454545;fill-opacity:1;fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
+         id="path3902-7-9"
+         inkscape:connector-curvature="0"
+         inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_right.png"
+         inkscape:export-xdpi="111.33009"
+         inkscape:export-ydpi="111.33009" />
+    </g>
+    <path
+       inkscape:export-ydpi="111.33009"
+       inkscape:export-xdpi="111.33009"
+       inkscape:export-filename="/home/peterk/Dokumente/quell/graphstuff/graphhopper/web/src/main/webapp/img/slight_right.png"
+       inkscape:connector-curvature="0"
+       id="path2985-2-5-6-3-1"
+       d="m 143.94012,187.53763 c 0.29079,-21.60561 -2.82368,-24.68941 11.81123,-45.19825 l 5.53521,4.22349 c -13.38965,18.0529 -10.73771,18.20147 -11.07454,40.96696 z"
+       style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:Sans;-inkscape-font-specification:Sans;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;letter-spacing:normal;word-spacing:normal;text-transform:none;direction:ltr;block-progression:tb;writing-mode:lr-tb;baseline-shift:baseline;text-anchor:start;display:inline;overflow:visible;visibility:visible;fill:none;fill-opacity:1;stroke:#454545;stroke-width:1.50225437;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker:none;enable-background:accumulate"
+       sodipodi:nodetypes="ccccc" />
+  </g>
+</svg>
diff --git a/web/src/main/webapp/img/keep_left.png b/web/src/main/webapp/img/keep_left.png
new file mode 100644
index 0000000000..b098f1f279
Binary files /dev/null and b/web/src/main/webapp/img/keep_left.png differ
diff --git a/web/src/main/webapp/img/keep_right.png b/web/src/main/webapp/img/keep_right.png
new file mode 100644
index 0000000000..3809d8518f
Binary files /dev/null and b/web/src/main/webapp/img/keep_right.png differ
diff --git a/web/src/main/webapp/index.html b/web/src/main/webapp/index.html
index e17c856721..5166b1533f 100644
--- a/web/src/main/webapp/index.html
+++ b/web/src/main/webapp/index.html
@@ -45,7 +45,7 @@
         </form>
         <div id="export-link" class="left"><a href="/maps"><img src='img/link.png'></a></div>
         <div id="gpxExportButton"><a href=""><img alt="gpx" src='img/gpx.png'></a></div>
-        <div id="hosting">Powered by <a href='https://graphhopper.com/#directions-api'>GraphHopper API</a></div>
+        <div id="hosting">Powered by <a href='https://www.graphhopper.com/products/'>GraphHopper API</a></div>
     </div>
     <div class="clear"></div>
     <div id="info" class="small_text">
diff --git a/web/src/main/webapp/js/graphhopper/GHRequest.js b/web/src/main/webapp/js/graphhopper/GHRequest.js
index a53821e53b..1376308e5f 100644
--- a/web/src/main/webapp/js/graphhopper/GHRequest.js
+++ b/web/src/main/webapp/js/graphhopper/GHRequest.js
@@ -185,7 +185,9 @@ GHRequest.prototype.createPointParams = function (useRawInput) {
         point = this.route.getIndex(i);
         if (i > 0)
             str += "&";
-        if (useRawInput)
+        if (typeof point.input == 'undefined')
+            str += "point=";
+        else if (useRawInput)
             str += "point=" + encodeURIComponent(point.input);
         else
             str += "point=" + encodeURIComponent(point.toString());
diff --git a/web/src/main/webapp/js/main-template.js b/web/src/main/webapp/js/main-template.js
index 7a61046dcb..d4c1466116 100644
--- a/web/src/main/webapp/js/main-template.js
+++ b/web/src/main/webapp/js/main-template.js
@@ -137,8 +137,8 @@ $(document).ready(function (e) {
                     if (vehicles.length > 0)
                         ghRequest.initVehicle(vehicles[0]);
 
-                    if (!ghRequest.isPublicTransit())
-                        $(".time_input").hide();
+                    if (ghRequest.isPublicTransit())
+                        $(".time_input").show();
 
                     var hiddenVehicles = [];
                     for (var i in vehicles) {
@@ -297,6 +297,7 @@ function checkInput() {
         var index = $(this).parent().data('index');
         ghRequest.route.removeSingle(index);
         mapLayer.clearLayers();
+        checkInput();
         routeLatLng(ghRequest, false);
     };
 
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 557dcc68b8..f46845ee7f 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -46,11 +46,10 @@ var ensureOneCheckboxSelected=function(){$("#gpx_route").change(function(){$(thi
 function round(t,n){return void 0===n&&(n=1e6),Math.round(t*n)/n}var GHInput=function(t){this.set(t)};GHInput.isObject=function(t){var n=Object.prototype.toString.call(t);return"[object object]"===n.toLowerCase()},GHInput.isString=function(t){var n=Object.prototype.toString.call(t);return"[object string]"===n.toLowerCase()},GHInput.prototype.isResolved=function(){return!isNaN(this.lat)&&!isNaN(this.lng)},GHInput.prototype.setCoord=function(t,n){this.lat=round(t),this.lng=round(n),this.input=this.toString()},GHInput.prototype.setUnresolved=function(){this.lat=void 0,this.lng=void 0},GHInput.prototype.set=function(t){if(this.input=t,GHInput.isObject(t))this.setCoord(t.lat,t.lng);else if(GHInput.isString(t)){var n=t.indexOf(",");n>=0?(this.lat=round(parseFloat(t.substr(0,n))),this.lng=round(parseFloat(t.substr(n+1))),this.isResolved()?this.input=this.toString():this.setUnresolved()):this.setUnresolved()}},GHInput.prototype.toString=function(){if(void 0!==this.lat&&void 0!==this.lng)return this.lat+","+this.lng},module.exports=GHInput;
 
 },{}],13:[function(require,module,exports){
-var GHRoute=require("./GHRoute.js"),GHInput=require("./GHInput.js"),graphhopperTools=require("./tools.js");Function.prototype.bind||(Function.prototype.bind=function(t){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var e=Array.prototype.slice.call(arguments,1),i=this,o=function(){},s=function(){return i.apply(this instanceof o&&t?this:t,e.concat(Array.prototype.slice.call(arguments)))};return o.prototype=this.prototype,s.prototype=new o,s});var GHRequest=function(t,e){this.host=t,this.route=new GHRoute(new GHInput,new GHInput),this.from=this.route.first(),this.to=this.route.last(),this.features={},this.do_zoom=!0,this.useMiles=!1,this.dataType="json",this.api_params={locale:"en",vehicle:"car",weighting:"fastest",elevation:!1,key:e,pt:{}},this.route.addListener("route.add",function(t){this.to=this.route.last()}.bind(this)),this.route.addListener("route.remove",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.move",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.reverse",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this))};GHRequest.prototype.init=function(t){for(var e in t)if("point"!==e&&"mathRandom"!==e&&"do_zoom"!==e&&"layer"!==e&&"use_miles"!==e){var i=t[e];"false"===i?i=!1:"true"===i&&(i=!0),this.api_params[e]=i}"do_zoom"in t&&(this.do_zoom=t.do_zoom),"use_miles"in t&&(this.useMiles=t.use_miles),this.api_params.elevation=!1;var o=this.features[this.api_params.vehicle];if(o&&o.elevation&&("elevation"in t?this.api_params.elevation=t.elevation:this.api_params.elevation=!0),t.q){var s=t.q;t.point||(t.point=[]);var r=s.indexOf("from:"),a=s.indexOf("to:");if(r>=0&&a>=0)r<a?(t.point.push(s.substring(r+5,a).trim()),t.point.push(s.substring(a+3).trim())):(t.point.push(s.substring(a+3,r).trim()),t.point.push(s.substring(r+5).trim()));else for(var n=s.split("p:"),p=0;p<n.length;p++){var u=n[p].trim();0!==u.length&&t.point.push(u)}}},GHRequest.prototype.setEarliestDepartureTime=function(t){this.api_params.pt.earliest_departure_time=t},GHRequest.prototype.getEarliestDepartureTime=function(){if(this.api_params.pt.earliest_departure_time)return this.api_params.pt.earliest_departure_time},GHRequest.prototype.initVehicle=function(t){this.api_params.vehicle=t;var e=this.features[t];e&&e.elevation?this.api_params.elevation=!0:this.api_params.elevation=!1},GHRequest.prototype.hasElevation=function(){return this.api_params.elevation},GHRequest.prototype.getVehicle=function(){return this.api_params.vehicle},GHRequest.prototype.isPublicTransit=function(){return"pt"===this.getVehicle()},GHRequest.prototype.createGeocodeURL=function(t,e){var i=this.host;t&&(i=t);var o=this.createPath(i+"/geocode?limit=6&type="+this.dataType);if(e>=0&&e<this.route.size()){var s=this.route.getIndex(e);s.isResolved()&&(o+="&point="+s.lat+","+s.lng)}return o},GHRequest.prototype.createURL=function(){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type="+this.dataType)},GHRequest.prototype.createGPXURL=function(t,e,i){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type=gpx&gpx.route="+t+"&gpx.track="+e+"&gpx.waypoints="+i)},GHRequest.prototype.createHistoryURL=function(){var t={key:!0};return this.createPath("?"+this.createPointParams(!0),t)+"&use_miles="+!!this.useMiles},GHRequest.prototype.createPointParams=function(t){var e,i,o,s="";for(i=0,o=this.route.size();i<o;i++)e=this.route.getIndex(i),i>0&&(s+="&"),s+=t?"point="+encodeURIComponent(e.input):"point="+encodeURIComponent(e.toString());return s},GHRequest.prototype.createPath=function(t,e){for(var i in this.api_params)if(!e||!e[i]){var o=this.api_params[i];t+=this.flatParameter(i,o)}return t},GHRequest.prototype.flatParameter=function(t,e){if(GHRoute.isObject(e)){var i="",o=Object.keys(e);for(var s in o){var r=o[s];i+=this.flatParameter(t+"."+r,e[r])}return i}if(GHRoute.isArray(e)){var i="",o=e;for(var s in o)i+=this.flatParameter(t,o[s]);return i}return"&"+encodeURIComponent(t)+"="+encodeURIComponent(e)},GHRequest.prototype.doRequest=function(t,e){var i=this;$.ajax({timeout:3e4,url:t,success:function(t){if(t.paths)for(var o=0;o<t.paths.length;o++){var s=t.paths[o];if(s.points_encoded){var r=graphhopperTools.decodePath(s.points,i.hasElevation());s.points={type:"LineString",coordinates:r};var a=graphhopperTools.decodePath(s.snapped_waypoints,i.hasElevation());s.snapped_waypoints={type:"MultiPoint",coordinates:a}}}e(t)},error:function(i){var o,s="API did not respond! ";if(i&&i.responseText&&i.responseText.indexOf("{")>=0)o=JSON.parse(i.responseText);else if(i&&i.statusText&&"OK"!==i.statusText){s+=i.statusText;var r="Error for "+t;o={message:s,hints:[{message:s,details:r}]}}console.log(s+" "+JSON.stringify(i)),e(o)},type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.getInfo=function(){var t=this.host+"/info?type="+this.dataType+"&key="+this.getKey();return $.ajax({url:t,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.setLocale=function(t){t&&(this.api_params.locale=t)},GHRequest.prototype.getKey=function(){return this.api_params.key},GHRequest.prototype.fetchTranslationMap=function(t){t||(t="");var e=this.host+"/i18n/"+t+"?type="+this.dataType+"&key="+this.getKey();return $.ajax({url:e,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},module.exports=GHRequest;
+var GHRoute=require("./GHRoute.js"),GHInput=require("./GHInput.js"),graphhopperTools=require("./tools.js");Function.prototype.bind||(Function.prototype.bind=function(t){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var e=Array.prototype.slice.call(arguments,1),i=this,o=function(){},s=function(){return i.apply(this instanceof o&&t?this:t,e.concat(Array.prototype.slice.call(arguments)))};return o.prototype=this.prototype,s.prototype=new o,s});var GHRequest=function(t,e){this.host=t,this.route=new GHRoute(new GHInput,new GHInput),this.from=this.route.first(),this.to=this.route.last(),this.features={},this.do_zoom=!0,this.useMiles=!1,this.dataType="json",this.api_params={locale:"en",vehicle:"car",weighting:"fastest",elevation:!1,key:e,pt:{}},this.route.addListener("route.add",function(t){this.to=this.route.last()}.bind(this)),this.route.addListener("route.remove",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.move",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.reverse",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this))};GHRequest.prototype.init=function(t){for(var e in t)if("point"!==e&&"mathRandom"!==e&&"do_zoom"!==e&&"layer"!==e&&"use_miles"!==e){var i=t[e];"false"===i?i=!1:"true"===i&&(i=!0),this.api_params[e]=i}"do_zoom"in t&&(this.do_zoom=t.do_zoom),"use_miles"in t&&(this.useMiles=t.use_miles),this.api_params.elevation=!1;var o=this.features[this.api_params.vehicle];if(o&&o.elevation&&("elevation"in t?this.api_params.elevation=t.elevation:this.api_params.elevation=!0),t.q){var s=t.q;t.point||(t.point=[]);var r=s.indexOf("from:"),a=s.indexOf("to:");if(r>=0&&a>=0)r<a?(t.point.push(s.substring(r+5,a).trim()),t.point.push(s.substring(a+3).trim())):(t.point.push(s.substring(a+3,r).trim()),t.point.push(s.substring(r+5).trim()));else for(var n=s.split("p:"),p=0;p<n.length;p++){var u=n[p].trim();0!==u.length&&t.point.push(u)}}},GHRequest.prototype.setEarliestDepartureTime=function(t){this.api_params.pt.earliest_departure_time=t},GHRequest.prototype.getEarliestDepartureTime=function(){if(this.api_params.pt.earliest_departure_time)return this.api_params.pt.earliest_departure_time},GHRequest.prototype.initVehicle=function(t){this.api_params.vehicle=t;var e=this.features[t];e&&e.elevation?this.api_params.elevation=!0:this.api_params.elevation=!1},GHRequest.prototype.hasElevation=function(){return this.api_params.elevation},GHRequest.prototype.getVehicle=function(){return this.api_params.vehicle},GHRequest.prototype.isPublicTransit=function(){return"pt"===this.getVehicle()},GHRequest.prototype.createGeocodeURL=function(t,e){var i=this.host;t&&(i=t);var o=this.createPath(i+"/geocode?limit=6&type="+this.dataType);if(e>=0&&e<this.route.size()){var s=this.route.getIndex(e);s.isResolved()&&(o+="&point="+s.lat+","+s.lng)}return o},GHRequest.prototype.createURL=function(){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type="+this.dataType)},GHRequest.prototype.createGPXURL=function(t,e,i){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type=gpx&gpx.route="+t+"&gpx.track="+e+"&gpx.waypoints="+i)},GHRequest.prototype.createHistoryURL=function(){var t={key:!0};return this.createPath("?"+this.createPointParams(!0),t)+"&use_miles="+!!this.useMiles},GHRequest.prototype.createPointParams=function(t){var e,i,o,s="";for(i=0,o=this.route.size();i<o;i++)e=this.route.getIndex(i),i>0&&(s+="&"),s+="undefined"==typeof e.input?"point=":t?"point="+encodeURIComponent(e.input):"point="+encodeURIComponent(e.toString());return s},GHRequest.prototype.createPath=function(t,e){for(var i in this.api_params)if(!e||!e[i]){var o=this.api_params[i];t+=this.flatParameter(i,o)}return t},GHRequest.prototype.flatParameter=function(t,e){if(GHRoute.isObject(e)){var i="",o=Object.keys(e);for(var s in o){var r=o[s];i+=this.flatParameter(t+"."+r,e[r])}return i}if(GHRoute.isArray(e)){var i="",o=e;for(var s in o)i+=this.flatParameter(t,o[s]);return i}return"&"+encodeURIComponent(t)+"="+encodeURIComponent(e)},GHRequest.prototype.doRequest=function(t,e){var i=this;$.ajax({timeout:3e4,url:t,success:function(t){if(t.paths)for(var o=0;o<t.paths.length;o++){var s=t.paths[o];if(s.points_encoded){var r=graphhopperTools.decodePath(s.points,i.hasElevation());s.points={type:"LineString",coordinates:r};var a=graphhopperTools.decodePath(s.snapped_waypoints,i.hasElevation());s.snapped_waypoints={type:"MultiPoint",coordinates:a}}}e(t)},error:function(i){var o,s="API did not respond! ";if(i&&i.responseText&&i.responseText.indexOf("{")>=0)o=JSON.parse(i.responseText);else if(i&&i.statusText&&"OK"!==i.statusText){s+=i.statusText;var r="Error for "+t;o={message:s,hints:[{message:s,details:r}]}}console.log(s+" "+JSON.stringify(i)),e(o)},type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.getInfo=function(){var t=this.host+"/info?type="+this.dataType+"&key="+this.getKey();return $.ajax({url:t,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.setLocale=function(t){t&&(this.api_params.locale=t)},GHRequest.prototype.getKey=function(){return this.api_params.key},GHRequest.prototype.fetchTranslationMap=function(t){t||(t="");var e=this.host+"/i18n/"+t+"?type="+this.dataType+"&key="+this.getKey();return $.ajax({url:e,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},module.exports=GHRequest;
 
 },{"./GHInput.js":12,"./GHRoute.js":14,"./tools.js":15}],14:[function(require,module,exports){
 var GHInput=require("./GHInput.js"),GHroute=function(){var t=Object.create(Array.prototype);return t=Array.apply(t,arguments)||t,GHroute.injectClassMethods(t),t._listeners={},t};GHroute.injectClassMethods=function(t){for(var e in GHroute.prototype)GHroute.prototype.hasOwnProperty(e)&&(t[e]=GHroute.prototype[e]);return t},GHroute.fromArray=function(t){var e=GHroute.apply(null,t);return e},GHroute.isArray=function(t){var e=Object.prototype.toString.call(t);return"[object array]"===e.toLowerCase()},GHroute.isObject=function(t){var e=Object.prototype.toString.call(t);return"[object object]"===e.toLowerCase()},GHroute.prototype={first:function(){return this.getIndex(0)},last:function(){return this.getIndex(this.length-1)},getIndex:function(t){return t=isNaN(t)?0:t,this[t]instanceof GHInput&&this[t]},getIndexByCoord:function(t){var e,r,i,n=!1,o=new GHInput(t);for(r=0,i=this.length;r<i;r++)if(e=this[r],e.toString()===o.toString()){n=r;break}return n},getIndexFromCoord:function(t){return this.getIndex(this.getIndexByCoord(t))},size:function(){return this.length},add:function(t,e){if(GHroute.isArray(t)){for(var r=0;r<t.length;r++)Array.prototype.push.call(this,t[r]instanceof GHInput?t[r]:new GHInput(t[r])),void 0!==e?(this.move(-1,e,!0),e++):e=this.lenght-1,this.fire("route.add",{point:this[e],to:e});return this}return Array.prototype.push.call(this,t instanceof GHInput?t:new GHInput(t)),void 0!==e?this.move(-1,e,!0):e=this.lenght-1,this.fire("route.add",{point:this[e],to:e}),this[e]},removeSingle:function(t){var e=!1;return isNaN(t)||t>=this.length||void 0===this[t]?(t instanceof GHInput&&(t=t.toString()),e=this.getIndexByCoord(t)):e=t,e!==!1&&this.remove(e),this},remove:function(t,e){var r=e||1;return Array.prototype.splice.call(this,t,r),1===this.length&&Array.prototype.push.call(this,new GHInput),this.fire("route.remove",{from:t,to:r}),this},addAll:function(){for(var t=0;t<arguments.length;t++)this.add(arguments[t]);return this},set:function(t,e,r){if(t instanceof GHInput)this[e]=t;else{if(!(this[e]instanceof GHInput))return!!r&&this.add(t,e);this[e].set(t)}return this.fire("route.set",{point:this[e],to:e}),this[e]},move:function(t,e,r){for(;t<0;)t+=this.length;for(;e<0;)e+=this.length;if(e>=this.length)for(var i=e-this.length;i--+1;)Array.prototype.push.call(this,void 0);return Array.prototype.splice.call(this,e,0,Array.prototype.splice.call(this,t,1)[0]),r||this.fire("route.move",{old_index:t,new_index:e}),this},reverse:function(){return Array.prototype.reverse.call(this),this.fire("route.reverse",{}),this},isResolved:function(){for(var t=0,e=this.length;t<e;t++){var r=this[t];if(!r.isResolved())return!1}return!0},addListener:function(t,e){return"undefined"==typeof this._listeners[t]&&(this._listeners[t]=[]),this._listeners[t].push(e),this},fire:function(t,e){if("string"==typeof t&&(t={type:t}),"object"==typeof e)for(var r in e)t[r]=e[r];if(t.route||(t.route=this),!t.type)throw new Error("Event object missing 'type' property.");if(this._listeners[t.type]instanceof Array)for(var i=this._listeners[t.type],n=0,o=i.length;n<o;n++)i[n].call(this,t)},removeListener:function(t,e){if(this._listeners[t]instanceof Array)for(var r=this._listeners[t],i=0,n=r.length;i<n;i++)if(r[i]===e){r.splice(i,1);break}}},module.exports=GHroute;
-
 },{"./GHInput.js":12}],15:[function(require,module,exports){
 var decodePath=function(e,d){for(var o=e.length,r=0,a=[],h=0,t=0,c=0;r<o;){var l,v=0,i=0;do l=e.charCodeAt(r++)-63,i|=(31&l)<<v,v+=5;while(l>=32);var u=1&i?~(i>>1):i>>1;h+=u,v=0,i=0;do l=e.charCodeAt(r++)-63,i|=(31&l)<<v,v+=5;while(l>=32);var n=1&i?~(i>>1):i>>1;if(t+=n,d){v=0,i=0;do l=e.charCodeAt(r++)-63,i|=(31&l)<<v,v+=5;while(l>=32);var s=1&i?~(i>>1):i>>1;c+=s,a.push([1e-5*t,1e-5*h,c/100])}else a.push([1e-5*t,1e-5*h])}return a};module.exports.decodePath=decodePath;
 },{}],16:[function(require,module,exports){
@@ -75,7 +74,7 @@ L.NumberedDivIcon=L.Icon.extend({options:{iconUrl:"./img/marker_hole.png",number
 
 },{}],22:[function(require,module,exports){
 (function (global){
-function initFromParams(e,t){ghRequest.init(e);var o=new Flatpickr(document.getElementById("input_date_0"),{defaultDate:new Date,allowInput:!0,minuteIncrement:15,time_24hr:!0,enableTime:!0});ghRequest.getEarliestDepartureTime()&&o.setDate(ghRequest.getEarliestDepartureTime());var r,a=0;if(e.point)for(var n=0;n<e.point.length;n++)""!==e.point[n]&&(a++,r=n);var s=e.point&&a>=2;s?resolveCoords(e.point,t):e.point&&1===a&&(ghRequest.route.set(e.point[r],r,!0),resolveIndex(r).done(function(){mapLayer.focus(ghRequest.route.getIndex(r),15,r)}))}function resolveCoords(e,t){for(var o=0,r=e.length;o<r;o++){var a=e[o],n=ghRequest.route.getIndex(o);n&&a===n.input&&n.isResolved()||ghRequest.route.set(a,o,!0)}checkInput(),ghRequest.route.isResolved()?(resolveAll(),routeLatLng(ghRequest,t)):$.when.apply($,resolveAll()).done(function(){routeLatLng(ghRequest,t)})}function getToFrom(e){return 0===e?FROM:e===ghRequest.route.size()-1?TO:-1}function checkInput(){var e=$("#pointTemplate").html(),t=ghRequest.route.size();$("#locationpoints > div.pointDiv").length>t&&$("#locationpoints > div.pointDiv:gt("+(t-1)+")").remove(),$("#locationpoints .pointDelete").off();for(var o=function(){var e=$(this).parent().data("index");ghRequest.route.removeSingle(e),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)},r=0;r<t;r++){var a=$("#locationpoints > div.pointDiv").eq(r);0===a.length&&($("#locationpoints > div.pointAdd").before(translate.nanoTemplate(e,{id:r})),a=$("#locationpoints > div.pointDiv").eq(r));var n=getToFrom(r);if(a.data("index",r),a.find(".pointFlag").attr("src",n===FROM?"img/marker-small-green.png":n===TO?"img/marker-small-red.png":"img/marker-small-blue.png"),t>2?a.find(".pointDelete").click(o).prop("disabled",!1).removeClass("ui-state-disabled"):a.find(".pointDelete").prop("disabled",!0).addClass("ui-state-disabled"),autocomplete.showListForIndex(ghRequest,routeIfAllResolved,r),translate.isI18nIsInitialized()){var s=a.find(".pointInput");0===r?$(s).attr("placeholder",translate.tr("from_hint")):r===t-1?$(s).attr("placeholder",translate.tr("to_hint")):$(s).attr("placeholder",translate.tr("via_hint"))}}}function setToStart(e){var t=e.relatedTarget.getLatLng(),o=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(o,0),routeIfAllResolved()}function setToEnd(e){var t=e.relatedTarget.getLatLng(),o=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(o,-1),routeIfAllResolved()}function setStartCoord(e){ghRequest.route.set(e.latlng.wrap(),0),resolveFrom(),routeIfAllResolved()}function setIntermediateCoord(e){var t=mapLayer.getSubLayers("route"),o=t.map(function(e){return{coordinates:e.getLatLngs(),wayPoints:e.feature.properties.snapped_waypoints.coordinates.map(function(e){return L.latLng(e[1],e[0])})}}),r=routeManipulation.getIntermediatePointIndex(o,e.latlng);ghRequest.route.add(e.latlng.wrap(),r),resolveIndex(r),routeIfAllResolved()}function deleteCoord(e){var t=e.relatedTarget.getLatLng();ghRequest.route.removeSingle(t),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)}function setEndCoord(e){var t=ghRequest.route.size()-1;ghRequest.route.set(e.latlng.wrap(),t),resolveTo(),routeIfAllResolved()}function routeIfAllResolved(e){return!!ghRequest.route.isResolved()&&(routeLatLng(ghRequest,e),!0)}function setFlag(e,t){if(e.lat){var o=getToFrom(t),r=mapLayer.createMarker(t,e,setToEnd,setToStart,deleteCoord,ghRequest);r._openPopup=r.openPopup,r.openPopup=function(){var e,t=this.getLatLng(),o=ghRequest.route.getIndexFromCoord(t);if(o.resolvedList&&o.resolvedList[0]&&o.resolvedList[0].locationDetails){var r=o.resolvedList[0].locationDetails;e=format.formatAddress(r),this._popup.setContent(e).update()}this._openPopup()};var a={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:setToStart,index:1};o===-1&&r.options.contextmenuItems.push(a),r.on("dragend",function(e){mapLayer.clearLayers();var o=e.target.getLatLng();autocomplete.hide(),ghRequest.route.getIndex(t).setCoord(o.lat,o.lng),resolveIndex(t),ghRequest.do_zoom=!1,routeLatLng(ghRequest,!1)})}}function resolveFrom(){return resolveIndex(0)}function resolveTo(){return resolveIndex(ghRequest.route.size()-1)}function resolveIndex(e){return setFlag(ghRequest.route.getIndex(e),e),0===e?ghRequest.to.isResolved()?mapLayer.setDisabledForMapsContextMenu("start",!1):mapLayer.setDisabledForMapsContextMenu("start",!0):e===ghRequest.route.size()-1&&(ghRequest.from.isResolved()?mapLayer.setDisabledForMapsContextMenu("end",!1):mapLayer.setDisabledForMapsContextMenu("end",!0)),nominatim.resolve(e,ghRequest.route.getIndex(e))}function resolveAll(){for(var e=[],t=0,o=ghRequest.route.size();t<o;t++)e[t]=resolveIndex(t);return ghRequest.isPublicTransit()&&ghRequest.setEarliestDepartureTime(moment($("#input_date_0").val(),"YYYY-MM-DD HH:mm").toISOString()),e}function flagAll(){for(var e=0,t=ghRequest.route.size();e<t;e++)setFlag(ghRequest.route.getIndex(e),e)}function routeLatLng(e,t){var o=e.do_zoom;e.do_zoom=!0;var r=e.createHistoryURL()+"&layer="+tileLayers.activeLayerName;if(!t&&History.enabled){var a=urlTools.parseUrl(r);return console.log(a),a.do_zoom=o,a.mathRandom=Math.random(),void History.pushState(a,messages.browserTitle,r)}var n=$("#info");n.empty(),n.show();var s=$("<div class='route_results'/>");n.append(s),mapLayer.clearElevation(),mapLayer.clearLayers(),flagAll(),mapLayer.setDisabledForMapsContextMenu("intermediate",!1),$("#vehicles button").removeClass("selectvehicle"),$("button#"+e.getVehicle().toLowerCase()).addClass("selectvehicle");var i=e.createURL();s.html('<img src="img/indicator.gif"/> Search Route ...'),e.doRequest(i,function(t){function a(e,t,o,r,a,n){return function(){var i=e[t];mapLayer.eachLayer(function(e){if(e.setStyle){var t=e.feature===i;e.setStyle(t?d:c),t&&(L.Browser.ie||L.Browser.opera||e.bringToFront())}}),a&&(mapLayer.clearElevation(),mapLayer.addElevation(i,n)),l.find("li").removeClass("current"),s.find("div").removeClass("current"),o.addClass("current"),r.addClass("current")}}if(s.html(""),t.message){var n=t.message;if(console.log(n),t.hints)for(var i=0;i<t.hints.length;i++)s.append("<div class='error'>"+t.hints[i].message+"</div>");else s.append("<div class='error'>"+n+"</div>")}else{var l=$("<ul id='route_result_tabs'/>");t.paths.length>1&&(s.append(l),s.append("<div class='clear'/>"));var u,p={color:"#00cc33",weight:5,opacity:.6},d={color:"#00cc33",weight:6,opacity:.8},c={color:"darkgray",weight:6,opacity:.8},g=[],m=function(e){return function(){mapLayer.updateScale(e),ghRequest.useMiles=e,resolveAll(),routeLatLng(ghRequest)}};if(t.paths.length>0&&t.paths[0].points_order){mapLayer.clearLayers();for(var h=t.paths[0].points_order,v=0;v<h.length;v++)setFlag(ghRequest.route.getIndex(h[v]),v)}for(var f=0;f<t.paths.length;f++){var q=$("<li>").append(f+1+"<img class='alt_route_img' src='img/alt_route.png'/>");0===f&&(u=q),l.append(q);var y=t.paths[f],b=0===f?p:c,R={type:"Feature",geometry:y.points,properties:{style:b,name:"route",snapped_waypoints:y.snapped_waypoints}};g.push(R),mapLayer.addDataToRoutingLayer(R);var x=$("<div class='route_result_tab'>");s.append(x),q.click(a(g,f,q,x,e.hasElevation(),e.useMiles));var _=$("<div class='route_description'>");y.description&&y.description.length>0&&(_.text(y.description),_.append("<br/>"));var I,w=translate.createDistanceString(y.distance,e.useMiles);if(e.isPublicTransit()){var T=moment(ghRequest.getEarliestDepartureTime()).add(y.time,"milliseconds").format("LT");I=y.transfers>=0?translate.tr("pt_route_info",[T,y.transfers,w]):translate.tr("pt_route_info_walking",[T,w])}else{var C=translate.createTimeString(y.time);I=translate.tr("route_info",[w,C])}_.append(I);var k=$("<button class='plain_text_button "+(e.useMiles?"gray":"")+"'>");k.text(translate.tr2("km_abbr")),k.click(m(!1));var M=$("<button class='plain_text_button "+(e.useMiles?"":"gray")+"'>");M.text(translate.tr2("mi_abbr")),M.click(m(!0));var F=$("<span style='float: right;'>");if(F.append(k),F.append("|"),F.append(M),_.append(F),e.hasElevation()&&_.append(translate.createEleInfoString(y.ascend,y.descend,e.useMiles)),_.append($("<div style='clear:both'/>")),x.append(_),y.instructions){var j=require("./instructions.js");x.append(j.create(mapLayer,y,r,e))}var D=y.details;if(D&&e.api_params.debug)for(var S in D)for(var A=D[S],v=0;v<A.length;v++){var z=A[v],E=z[0],P=z[2],H=y.points.coordinates[E];L.marker([H[1],H[0]],{icon:L.icon({iconUrl:"./img/marker-small-blue.png",iconSize:[15,15]}),draggable:!0}).addTo(mapLayer.getRoutingLayer()).bindPopup(S+":"+P)}}u.click(),mapLayer.adjustMapSize();var B=t.paths[0];if(B.bbox&&o){var G=B.bbox[0],O=B.bbox[1],V=B.bbox[2],U=B.bbox[3],Y=new L.LatLngBounds(new L.LatLng(O,G),new L.LatLng(U,V));mapLayer.fitMapToBounds(Y)}$(".defaulting").each(function(e,t){$(t).css("color","black")})}})}function mySubmit(){var e,t,o,r=[],a=!0,n=$("#locationpoints > div.pointDiv > input.pointInput"),s=n.size;if($.each(n,function(n){0===n?(e=$(this).val(),e!==translate.tr("from_hint")&&""!==e?r.push(e):a=!1):n===s-1?(t=$(this).val(),t!==translate.tr("to_hint")&&""!==t?r.push(t):a=!1):(o=$(this).val(),o!==translate.tr("via_hint")&&""!==o?r.push(o):a=!1)}),a&&e!==translate.tr("from_hint"))return t===translate.tr("to_hint")?(ghRequest.from.setStr(e),void $.when(resolveFrom()).done(function(){mapLayer.focus(ghRequest.from,null,0)})):void(a&&resolveCoords(r))}function isProduction(){return host.indexOf("graphhopper.com")>0}global.d3=require("d3");var Flatpickr=require("flatpickr"),L=require("leaflet");require("leaflet-contextmenu"),require("leaflet-loading");var moment=require("moment");require("./lib/leaflet.elevation-0.0.4.min.js"),require("./lib/leaflet_numbered_markers.js"),global.jQuery=require("jquery"),global.$=global.jQuery,require("./lib/jquery-ui-custom-1.12.0.min.js"),require("./lib/jquery.history.js"),require("./lib/jquery.autocomplete.js");var ghenv=require("./config/options.js").options;console.log(ghenv.environment);var GHInput=require("./graphhopper/GHInput.js"),GHRequest=require("./graphhopper/GHRequest.js"),host=ghenv.routing.host;host||(host=""===location.port?location.protocol+"//"+location.hostname:location.protocol+"//"+location.hostname+":"+location.port);var AutoComplete=require("./autocomplete.js");if("development"===ghenv.environment)var autocomplete=AutoComplete.prototype.createStub();else var autocomplete=new AutoComplete(ghenv.geocoding.host,ghenv.geocoding.api_key);var mapLayer=require("./map.js"),nominatim=require("./nominatim.js"),routeManipulation=require("./routeManipulation.js"),gpxExport=require("./gpxexport.js"),messages=require("./messages.js"),translate=require("./translate.js"),format=require("./tools/format.js"),urlTools=require("./tools/url.js"),vehicleTools=require("./tools/vehicle.js"),tileLayers=require("./config/tileLayers.js"),debug=!1,ghRequest=new GHRequest(host,ghenv.routing.api_key),bounds={},metaVersionInfo;global.window&&(window.log=function(){log.history=log.history||[],log.history.push(arguments),this.console&&debug&&console.log(Array.prototype.slice.call(arguments))}),$(document).ready(function(e){jQuery.support.cors=!0,gpxExport.addGpxExport(ghRequest),isProduction()&&$("#hosting").show();var t=window.History;t.enabled&&t.Adapter.bind(window,"statechange",function(){var e=t.getState();console.log(e),initFromParams(e.data,!0)}),$("#locationform").submit(function(e){e.preventDefault(),mySubmit()});var o=urlTools.parseUrlWithHisto();$.when(ghRequest.fetchTranslationMap(o.locale),ghRequest.getInfo()).then(function(e,t){function r(e,t){var o=$("<button class='vehicle-btn' title='"+translate.tr(e)+"'/>");return t&&o.hide(),o.attr("id",e),o.html("<img src='img/"+e+".png' alt='"+translate.tr(e)+"'></img>"),o.click(function(){ghRequest.initVehicle(e),resolveAll(),routeLatLng(ghRequest)}),o}var a=e[0];autocomplete.setLocale(a.locale),ghRequest.setLocale(a.locale),translate.init(a);var n=t[0],s=n.bbox;bounds.initialized=!0,bounds.minLon=s[0],bounds.minLat=s[1],bounds.maxLon=s[2],bounds.maxLat=s[3],nominatim.setBounds(bounds);var i=$("#vehicles");if(n.features){ghRequest.features=n.features;var l={car:1,foot:2,bike:3,motorcycle:1e4},u=o.vehicle&&(!l[o.vehicle]||l[o.vehicle]>3),p=vehicleTools.getSortedVehicleKeys(n.features,l);p.length>0&&ghRequest.initVehicle(p[0]),ghRequest.isPublicTransit()||$(".time_input").hide();var d=[];for(var c in p){var g=r(p[c].toLowerCase(),!u&&c>2);i.append(g),c>2&&d.push(g)}if(!u&&p.length>3){var m=$("<a id='more-vehicle-btn'> ...</a>").click(function(){m.hide();for(var e in d)d[e].show()});i.append($("<a class='vehicle-info-link' href='https://graphhopper.com/api/1/docs/supported-vehicle-profiles/'>?</a>")),i.append(m)}}metaVersionInfo=messages.extractMetaVersionInfo(n),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,o.layer,o.use_miles),initFromParams(o,!0),checkInput()},function(e){console.log(e),$("#error").html('GraphHopper API offline? <a href="http://graphhopper.com/maps">Refresh</a><br/>Status: '+e.statusText+"<br/>"+host),bounds={minLon:-180,minLat:-90,maxLon:180,maxLat:90},nominatim.setBounds(bounds),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,o.layer,o.use_miles)}),$(window).resize(function(){mapLayer.adjustMapSize()}),$("#locationpoints").sortable({items:".pointDiv",cursor:"n-resize",containment:"parent",handle:".pointFlag",update:function(e,t){var o=$(t.item[0]).data("index");sortable_items=$("#locationpoints > div.pointDiv"),$(sortable_items).each(function(e){var t=$(this).data("index");if(o===t)return ghRequest.route.move(t,e),routeIfAllResolved()||checkInput(),!1})}}),$("#locationpoints > div.pointAdd").click(function(){ghRequest.route.add(new GHInput),checkInput()}),checkInput()});var FROM="from",TO="to";module.exports.setFlag=setFlag;
+function initFromParams(e,t){ghRequest.init(e);var o=new Flatpickr(document.getElementById("input_date_0"),{defaultDate:new Date,allowInput:!0,minuteIncrement:15,time_24hr:!0,enableTime:!0});ghRequest.getEarliestDepartureTime()&&o.setDate(ghRequest.getEarliestDepartureTime());var r,a=0;if(e.point)for(var n=0;n<e.point.length;n++)""!==e.point[n]&&(a++,r=n);var s=e.point&&a>=2;s?resolveCoords(e.point,t):e.point&&1===a&&(ghRequest.route.set(e.point[r],r,!0),resolveIndex(r).done(function(){mapLayer.focus(ghRequest.route.getIndex(r),15,r)}))}function resolveCoords(e,t){for(var o=0,r=e.length;o<r;o++){var a=e[o],n=ghRequest.route.getIndex(o);n&&a===n.input&&n.isResolved()||ghRequest.route.set(a,o,!0)}checkInput(),ghRequest.route.isResolved()?(resolveAll(),routeLatLng(ghRequest,t)):$.when.apply($,resolveAll()).done(function(){routeLatLng(ghRequest,t)})}function getToFrom(e){return 0===e?FROM:e===ghRequest.route.size()-1?TO:-1}function checkInput(){var e=$("#pointTemplate").html(),t=ghRequest.route.size();$("#locationpoints > div.pointDiv").length>t&&$("#locationpoints > div.pointDiv:gt("+(t-1)+")").remove(),$("#locationpoints .pointDelete").off();for(var o=function(){var e=$(this).parent().data("index");ghRequest.route.removeSingle(e),mapLayer.clearLayers(),checkInput(),routeLatLng(ghRequest,!1)},r=0;r<t;r++){var a=$("#locationpoints > div.pointDiv").eq(r);0===a.length&&($("#locationpoints > div.pointAdd").before(translate.nanoTemplate(e,{id:r})),a=$("#locationpoints > div.pointDiv").eq(r));var n=getToFrom(r);if(a.data("index",r),a.find(".pointFlag").attr("src",n===FROM?"img/marker-small-green.png":n===TO?"img/marker-small-red.png":"img/marker-small-blue.png"),t>2?a.find(".pointDelete").click(o).prop("disabled",!1).removeClass("ui-state-disabled"):a.find(".pointDelete").prop("disabled",!0).addClass("ui-state-disabled"),autocomplete.showListForIndex(ghRequest,routeIfAllResolved,r),translate.isI18nIsInitialized()){var s=a.find(".pointInput");0===r?$(s).attr("placeholder",translate.tr("from_hint")):r===t-1?$(s).attr("placeholder",translate.tr("to_hint")):$(s).attr("placeholder",translate.tr("via_hint"))}}}function setToStart(e){var t=e.relatedTarget.getLatLng(),o=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(o,0),routeIfAllResolved()}function setToEnd(e){var t=e.relatedTarget.getLatLng(),o=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(o,-1),routeIfAllResolved()}function setStartCoord(e){ghRequest.route.set(e.latlng.wrap(),0),resolveFrom(),routeIfAllResolved()}function setIntermediateCoord(e){var t=mapLayer.getSubLayers("route"),o=t.map(function(e){return{coordinates:e.getLatLngs(),wayPoints:e.feature.properties.snapped_waypoints.coordinates.map(function(e){return L.latLng(e[1],e[0])})}}),r=routeManipulation.getIntermediatePointIndex(o,e.latlng);ghRequest.route.add(e.latlng.wrap(),r),resolveIndex(r),routeIfAllResolved()}function deleteCoord(e){var t=e.relatedTarget.getLatLng();ghRequest.route.removeSingle(t),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)}function setEndCoord(e){var t=ghRequest.route.size()-1;ghRequest.route.set(e.latlng.wrap(),t),resolveTo(),routeIfAllResolved()}function routeIfAllResolved(e){return!!ghRequest.route.isResolved()&&(routeLatLng(ghRequest,e),!0)}function setFlag(e,t){if(e.lat){var o=getToFrom(t),r=mapLayer.createMarker(t,e,setToEnd,setToStart,deleteCoord,ghRequest);r._openPopup=r.openPopup,r.openPopup=function(){var e,t=this.getLatLng(),o=ghRequest.route.getIndexFromCoord(t);if(o.resolvedList&&o.resolvedList[0]&&o.resolvedList[0].locationDetails){var r=o.resolvedList[0].locationDetails;e=format.formatAddress(r),this._popup.setContent(e).update()}this._openPopup()};var a={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:setToStart,index:1};o===-1&&r.options.contextmenuItems.push(a),r.on("dragend",function(e){mapLayer.clearLayers();var o=e.target.getLatLng();autocomplete.hide(),ghRequest.route.getIndex(t).setCoord(o.lat,o.lng),resolveIndex(t),ghRequest.do_zoom=!1,routeLatLng(ghRequest,!1)})}}function resolveFrom(){return resolveIndex(0)}function resolveTo(){return resolveIndex(ghRequest.route.size()-1)}function resolveIndex(e){return setFlag(ghRequest.route.getIndex(e),e),0===e?ghRequest.to.isResolved()?mapLayer.setDisabledForMapsContextMenu("start",!1):mapLayer.setDisabledForMapsContextMenu("start",!0):e===ghRequest.route.size()-1&&(ghRequest.from.isResolved()?mapLayer.setDisabledForMapsContextMenu("end",!1):mapLayer.setDisabledForMapsContextMenu("end",!0)),nominatim.resolve(e,ghRequest.route.getIndex(e))}function resolveAll(){for(var e=[],t=0,o=ghRequest.route.size();t<o;t++)e[t]=resolveIndex(t);return ghRequest.isPublicTransit()&&ghRequest.setEarliestDepartureTime(moment($("#input_date_0").val(),"YYYY-MM-DD HH:mm").toISOString()),e}function flagAll(){for(var e=0,t=ghRequest.route.size();e<t;e++)setFlag(ghRequest.route.getIndex(e),e)}function routeLatLng(e,t){var o=e.do_zoom;e.do_zoom=!0;var r=e.createHistoryURL()+"&layer="+tileLayers.activeLayerName;if(!t&&History.enabled){var a=urlTools.parseUrl(r);return console.log(a),a.do_zoom=o,a.mathRandom=Math.random(),void History.pushState(a,messages.browserTitle,r)}var n=$("#info");n.empty(),n.show();var s=$("<div class='route_results'/>");n.append(s),mapLayer.clearElevation(),mapLayer.clearLayers(),flagAll(),mapLayer.setDisabledForMapsContextMenu("intermediate",!1),$("#vehicles button").removeClass("selectvehicle"),$("button#"+e.getVehicle().toLowerCase()).addClass("selectvehicle");var i=e.createURL();s.html('<img src="img/indicator.gif"/> Search Route ...'),e.doRequest(i,function(t){function a(e,t,o,r,a,n){return function(){var i=e[t];mapLayer.eachLayer(function(e){if(e.setStyle){var t=e.feature===i;e.setStyle(t?d:c),t&&(L.Browser.ie||L.Browser.opera||e.bringToFront())}}),a&&(mapLayer.clearElevation(),mapLayer.addElevation(i,n)),l.find("li").removeClass("current"),s.find("div").removeClass("current"),o.addClass("current"),r.addClass("current")}}if(s.html(""),t.message){var n=t.message;if(console.log(n),t.hints)for(var i=0;i<t.hints.length;i++)s.append("<div class='error'>"+t.hints[i].message+"</div>");else s.append("<div class='error'>"+n+"</div>")}else{var l=$("<ul id='route_result_tabs'/>");t.paths.length>1&&(s.append(l),s.append("<div class='clear'/>"));var u,p={color:"#00cc33",weight:5,opacity:.6},d={color:"#00cc33",weight:6,opacity:.8},c={color:"darkgray",weight:6,opacity:.8},g=[],m=function(e){return function(){mapLayer.updateScale(e),ghRequest.useMiles=e,resolveAll(),routeLatLng(ghRequest)}};if(t.paths.length>0&&t.paths[0].points_order){mapLayer.clearLayers();for(var h=t.paths[0].points_order,v=0;v<h.length;v++)setFlag(ghRequest.route.getIndex(h[v]),v)}for(var f=0;f<t.paths.length;f++){var q=$("<li>").append(f+1+"<img class='alt_route_img' src='img/alt_route.png'/>");0===f&&(u=q),l.append(q);var y=t.paths[f],b=0===f?p:c,R={type:"Feature",geometry:y.points,properties:{style:b,name:"route",snapped_waypoints:y.snapped_waypoints}};g.push(R),mapLayer.addDataToRoutingLayer(R);var x=$("<div class='route_result_tab'>");s.append(x),q.click(a(g,f,q,x,e.hasElevation(),e.useMiles));var I=$("<div class='route_description'>");y.description&&y.description.length>0&&(I.text(y.description),I.append("<br/>"));var _,w=translate.createDistanceString(y.distance,e.useMiles);if(e.isPublicTransit()){var T=moment(ghRequest.getEarliestDepartureTime()).add(y.time,"milliseconds").format("LT");_=y.transfers>=0?translate.tr("pt_route_info",[T,y.transfers,w]):translate.tr("pt_route_info_walking",[T,w])}else{var C=translate.createTimeString(y.time);_=translate.tr("route_info",[w,C])}I.append(_);var k=$("<button class='plain_text_button "+(e.useMiles?"gray":"")+"'>");k.text(translate.tr2("km_abbr")),k.click(m(!1));var M=$("<button class='plain_text_button "+(e.useMiles?"":"gray")+"'>");M.text(translate.tr2("mi_abbr")),M.click(m(!0));var F=$("<span style='float: right;'>");if(F.append(k),F.append("|"),F.append(M),I.append(F),e.hasElevation()&&I.append(translate.createEleInfoString(y.ascend,y.descend,e.useMiles)),I.append($("<div style='clear:both'/>")),x.append(I),y.instructions){var j=require("./instructions.js");x.append(j.create(mapLayer,y,r,e))}var D=y.details;if(D&&e.api_params.debug)for(var S in D)for(var A=D[S],v=0;v<A.length;v++){var z=A[v],E=z[0],P=z[2],H=y.points.coordinates[E];L.marker([H[1],H[0]],{icon:L.icon({iconUrl:"./img/marker-small-blue.png",iconSize:[15,15]}),draggable:!0}).addTo(mapLayer.getRoutingLayer()).bindPopup(S+":"+P)}}u.click(),mapLayer.adjustMapSize();var B=t.paths[0];if(B.bbox&&o){var G=B.bbox[0],O=B.bbox[1],V=B.bbox[2],U=B.bbox[3],Y=new L.LatLngBounds(new L.LatLng(O,G),new L.LatLng(U,V));mapLayer.fitMapToBounds(Y)}$(".defaulting").each(function(e,t){$(t).css("color","black")})}})}function mySubmit(){var e,t,o,r=[],a=!0,n=$("#locationpoints > div.pointDiv > input.pointInput"),s=n.size;if($.each(n,function(n){0===n?(e=$(this).val(),e!==translate.tr("from_hint")&&""!==e?r.push(e):a=!1):n===s-1?(t=$(this).val(),t!==translate.tr("to_hint")&&""!==t?r.push(t):a=!1):(o=$(this).val(),o!==translate.tr("via_hint")&&""!==o?r.push(o):a=!1)}),a&&e!==translate.tr("from_hint"))return t===translate.tr("to_hint")?(ghRequest.from.setStr(e),void $.when(resolveFrom()).done(function(){mapLayer.focus(ghRequest.from,null,0)})):void(a&&resolveCoords(r))}function isProduction(){return host.indexOf("graphhopper.com")>0}global.d3=require("d3");var Flatpickr=require("flatpickr"),L=require("leaflet");require("leaflet-contextmenu"),require("leaflet-loading");var moment=require("moment");require("./lib/leaflet.elevation-0.0.4.min.js"),require("./lib/leaflet_numbered_markers.js"),global.jQuery=require("jquery"),global.$=global.jQuery,require("./lib/jquery-ui-custom-1.12.0.min.js"),require("./lib/jquery.history.js"),require("./lib/jquery.autocomplete.js");var ghenv=require("./config/options.js").options;console.log(ghenv.environment);var GHInput=require("./graphhopper/GHInput.js"),GHRequest=require("./graphhopper/GHRequest.js"),host=ghenv.routing.host;host||(host=""===location.port?location.protocol+"//"+location.hostname:location.protocol+"//"+location.hostname+":"+location.port);var AutoComplete=require("./autocomplete.js");if("development"===ghenv.environment)var autocomplete=AutoComplete.prototype.createStub();else var autocomplete=new AutoComplete(ghenv.geocoding.host,ghenv.geocoding.api_key);var mapLayer=require("./map.js"),nominatim=require("./nominatim.js"),routeManipulation=require("./routeManipulation.js"),gpxExport=require("./gpxexport.js"),messages=require("./messages.js"),translate=require("./translate.js"),format=require("./tools/format.js"),urlTools=require("./tools/url.js"),vehicleTools=require("./tools/vehicle.js"),tileLayers=require("./config/tileLayers.js"),debug=!1,ghRequest=new GHRequest(host,ghenv.routing.api_key),bounds={},metaVersionInfo;global.window&&(window.log=function(){log.history=log.history||[],log.history.push(arguments),this.console&&debug&&console.log(Array.prototype.slice.call(arguments))}),$(document).ready(function(e){jQuery.support.cors=!0,gpxExport.addGpxExport(ghRequest),isProduction()&&$("#hosting").show();var t=window.History;t.enabled&&t.Adapter.bind(window,"statechange",function(){var e=t.getState();console.log(e),initFromParams(e.data,!0)}),$("#locationform").submit(function(e){e.preventDefault(),mySubmit()});var o=urlTools.parseUrlWithHisto();$.when(ghRequest.fetchTranslationMap(o.locale),ghRequest.getInfo()).then(function(e,t){function r(e,t){var o=$("<button class='vehicle-btn' title='"+translate.tr(e)+"'/>");return t&&o.hide(),o.attr("id",e),o.html("<img src='img/"+e+".png' alt='"+translate.tr(e)+"'></img>"),o.click(function(){ghRequest.initVehicle(e),resolveAll(),routeLatLng(ghRequest)}),o}var a=e[0];autocomplete.setLocale(a.locale),ghRequest.setLocale(a.locale),translate.init(a);var n=t[0],s=n.bbox;bounds.initialized=!0,bounds.minLon=s[0],bounds.minLat=s[1],bounds.maxLon=s[2],bounds.maxLat=s[3],nominatim.setBounds(bounds);var i=$("#vehicles");if(n.features){ghRequest.features=n.features;var l={car:1,foot:2,bike:3,motorcycle:1e4},u=o.vehicle&&(!l[o.vehicle]||l[o.vehicle]>3),p=vehicleTools.getSortedVehicleKeys(n.features,l);p.length>0&&ghRequest.initVehicle(p[0]),ghRequest.isPublicTransit()&&$(".time_input").show();var d=[];for(var c in p){var g=r(p[c].toLowerCase(),!u&&c>2);i.append(g),c>2&&d.push(g)}if(!u&&p.length>3){var m=$("<a id='more-vehicle-btn'> ...</a>").click(function(){m.hide();for(var e in d)d[e].show()});i.append($("<a class='vehicle-info-link' href='https://graphhopper.com/api/1/docs/supported-vehicle-profiles/'>?</a>")),i.append(m)}}metaVersionInfo=messages.extractMetaVersionInfo(n),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,o.layer,o.use_miles),initFromParams(o,!0),checkInput()},function(e){console.log(e),$("#error").html('GraphHopper API offline? <a href="http://graphhopper.com/maps">Refresh</a><br/>Status: '+e.statusText+"<br/>"+host),bounds={minLon:-180,minLat:-90,maxLon:180,maxLat:90},nominatim.setBounds(bounds),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,o.layer,o.use_miles)}),$(window).resize(function(){mapLayer.adjustMapSize()}),$("#locationpoints").sortable({items:".pointDiv",cursor:"n-resize",containment:"parent",handle:".pointFlag",update:function(e,t){var o=$(t.item[0]).data("index");sortable_items=$("#locationpoints > div.pointDiv"),$(sortable_items).each(function(e){var t=$(this).data("index");if(o===t)return ghRequest.route.move(t,e),routeIfAllResolved()||checkInput(),!1})}}),$("#locationpoints > div.pointAdd").click(function(){ghRequest.route.add(new GHInput),checkInput()}),checkInput()});var FROM="from",TO="to";module.exports.setFlag=setFlag;
 }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
 },{"./autocomplete.js":8,"./config/options.js":9,"./config/tileLayers.js":10,"./gpxexport.js":11,"./graphhopper/GHInput.js":12,"./graphhopper/GHRequest.js":13,"./instructions.js":16,"./lib/jquery-ui-custom-1.12.0.min.js":17,"./lib/jquery.autocomplete.js":18,"./lib/jquery.history.js":19,"./lib/leaflet.elevation-0.0.4.min.js":20,"./lib/leaflet_numbered_markers.js":21,"./map.js":23,"./messages.js":24,"./nominatim.js":25,"./routeManipulation.js":26,"./tools/format.js":27,"./tools/url.js":29,"./tools/vehicle.js":30,"./translate.js":31,"d3":1,"flatpickr":2,"jquery":3,"leaflet":6,"leaflet-contextmenu":4,"leaflet-loading":5,"moment":7}],23:[function(require,module,exports){
 function adjustMapSize(){var e=$("#map"),t=$(window).width()-280;t<400?(t=400,e.attr("style","position: relative; float: right;")):e.attr("style","position: absolute; right: 0;");var a=$(window).height();a<500&&(a=500),e.width(t).height(a),$("#input").height(a);var n=a-60-$("#input_header").height()-$("#footer").height()-$(".route_description").height(),o=$("#route_result_tabs li").height();isNaN(o)||(n-=o),$(".instructions_info").css("max-height",n)}function initMap(e,t,a,n,o,r){adjustMapSize();var i=tileLayers.selectLayer(o);defaultContextmenuItems=[{separator:!0,index:10},{text:translate.tr("show_coords"),callback:function(e){alert(e.latlng.lat+","+e.latlng.lng)},index:11},{text:translate.tr("center_map"),callback:function(e){map.panTo(e.latlng)},index:12}],map=L.map("map",{layers:[i],minZoom:2,contextmenu:!0,contextmenuItems:defaultContextmenuItems,zoomControl:!1,loadingControl:!1});var l={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:t,index:0},m={text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:a,disabled:!0,index:1},s={text:translate.tr("set_end"),icon:"./img/marker-small-red.png",callback:n,index:2};menuStart=map.contextmenu.insertItem(l,l.index),menuIntermediate=map.contextmenu.insertItem(m,m.index),menuEnd=map.contextmenu.insertItem(s,s.index);var u=new L.Control.Zoom({position:"topleft",zoomInTitle:translate.tr("zoom_in"),zoomOutTitle:translate.tr("zoom_out")}).addTo(map);new L.Control.loading({zoomControl:u}).addTo(map),L.control.layers(tileLayers.getAvailableTileLayers()).addTo(map),map.on("baselayerchange",function(e){e.name&&(tileLayers.activeLayerName=e.name,$("#export-link a").attr("href",function(e,t){return t.replace(/(layer=)([\w\s]+)/,"$1"+tileLayers.activeLayerName)}))}),scaleControl=L.control.scale(r?{metric:!1}:{imperial:!1}).addTo(map),map.fitBounds(new L.LatLngBounds(new L.LatLng(e.minLat,e.minLon),new L.LatLng(e.maxLat,e.maxLon))),map.attributionControl.setPrefix(!1);var d={color:"black",weight:2,opacity:.3},c={type:"Feature",geometry:{type:"LineString",coordinates:[[e.minLon,e.minLat],[e.maxLon,e.minLat],[e.maxLon,e.maxLat],[e.minLon,e.maxLat],[e.minLon,e.minLat]]}};e.initialized&&L.geoJson(c,{style:d}).addTo(map),routingLayer=L.geoJson().addTo(map),routingLayer.options={style:function(e){return e.properties&&e.properties.style},contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("route"),disabled:!0,index:0},{text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:a,index:1}]),contextmenuInheritItems:!1}}function focus(e,t,a){e.lat&&e.lng&&(t||(t=11),routingLayer.clearLayers(),map.setView(new L.LatLng(e.lat,e.lng),t),mainTemplate.setFlag(e,a))}function getToFrom(e,t){return 0===e?FROM:e===t.route.size()-1?TO:-1}var mainTemplate=require("./main-template.js"),tileLayers=require("./config/tileLayers.js"),translate=require("./translate.js"),routingLayer,map,menuStart,menuIntermediate,menuEnd,elevationControl=null,defaultContextmenuItems;module.exports.clearLayers=function(){routingLayer.clearLayers()},module.exports.getRoutingLayer=function(){return routingLayer},module.exports.getSubLayers=function(e){var t=routingLayer.getLayers();return t.filter(function(t){return t.feature&&t.feature.properties&&t.feature.properties.name===e})},module.exports.addDataToRoutingLayer=function(e){routingLayer.addData(e)},module.exports.eachLayer=function(e){routingLayer.eachLayer(e)},module.exports.setDisabledForMapsContextMenu=function(e,t){"start"===e&&map.contextmenu.setDisabled(menuStart,t),"end"===e&&map.contextmenu.setDisabled(menuEnd,t),"intermediate"===e&&map.contextmenu.setDisabled(menuIntermediate,t)},module.exports.fitMapToBounds=function(e){map.fitBounds(e,{padding:[42,42]})},module.exports.removeLayerFromMap=function(e){map.removeLayer(e)},module.exports.focus=focus,module.exports.initMap=initMap,module.exports.adjustMapSize=adjustMapSize,module.exports.addElevation=function(e,t){null===elevationControl&&(elevationControl=L.control.elevation({position:"bottomright",theme:"white-theme",width:450,height:125,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:2,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1}),elevationControl.addTo(map)),elevationControl.options.imperial=t,elevationControl.addData(e)},module.exports.clearElevation=function(){elevationControl&&elevationControl.clear()},module.exports.getMap=function(){return map},module.exports.updateScale=function(e){if(null!==scaleControl){scaleControl.remove();var t=e?{metric:!1}:{imperial:!1};scaleControl=L.control.scale(t).addTo(map)}};var FROM="from",TO="to",iconFrom=L.icon({iconUrl:"./img/marker-icon-green.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]}),iconTo=L.icon({iconUrl:"./img/marker-icon-red.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]});module.exports.createMarker=function(e,t,a,n,o,r){var i=getToFrom(e,r);return L.marker([t.lat,t.lng],{icon:i===FROM?iconFrom:i===TO?iconTo:new L.NumberedDivIcon({number:e}),draggable:!0,contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("marker")+" "+(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e),disabled:!0,index:0},{text:translate.tr(i!==TO?"set_end":"set_start"),icon:i!==TO?"./img/marker-small-red.png":"./img/marker-small-green.png",callback:i!==TO?a:n,index:2},{text:translate.tr("delete_from_route"),callback:o,disabled:i!==-1&&2===r.route.size(),index:3}]),contextmenuInheritItems:!1}).addTo(routingLayer).bindPopup(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e)};
@@ -94,6 +93,7 @@ function insComma(o,t){return o.length>0?o+", "+t:t}function formatLocationEntry
 
 },{}],28:[function(require,module,exports){
 module.exports.getCenter=function(n){var o={lat:0,lng:0};return n.initialized&&(o.lat=(n.minLat+n.maxLat)/2,o.lng=(n.minLon+n.maxLon)/2),o},module.exports.floor=function(n,o){return o||(o=1e6),Math.floor(n*o)/o},module.exports.round=function(n,o){return void 0===o&&(o=1e6),Math.round(n*o)/o};
+
 },{}],29:[function(require,module,exports){
 function parseUrlWithHisto(){return parseUrl(window.location.hash?window.location.hash:window.location.search)}function parseUrl(r){var e=r.indexOf("?");e>=0&&(r=r.substring(e+1));for(var t={},a=r.split("&"),n=0;n<a.length;n++){var o=a[n].indexOf("=");if(!(o<0)){var i=a[n].substring(0,o),s=a[n].substring(o+1);s=decodeURIComponent(s.replace(/\+/g," ")),mergeParamIntoObject(t,i,s)}}return t}function mergeParamIntoObject(r,e,t){var a=e.indexOf(".");if(a<0){if("undefined"==typeof r[e]&&"heading"!==e&&"point"!==e&&"details"!==e)"true"===t?t=!0:"false"===t&&(t=!1),r[e]=t;else{var n=r[e];isArray(n)?n.push(t):n?r[e]=[n,t]:r[e]=[t]}return r}var o=e.substring(0,a),i=e.substring(a+1),n=r[o];return n||(n={}),r[o]=mergeParamIntoObject(n,i,t),r}var isArray=function(r){var e=Object.prototype.toString.call(r);return"[object array]"===e.toLowerCase()};module.exports.parseUrl=parseUrl,module.exports.mergeParamIntoObject=mergeParamIntoObject,module.exports.parseUrlWithHisto=parseUrlWithHisto;
 
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java
index 36ee7842d7..66dad8c6ba 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java
@@ -63,11 +63,22 @@ public void setUp() {
     }
 
     @Test
-    public void testSimpleQuery() throws Exception {
+    public void testQueries() throws Exception {
         JsonNode json = query("point=55.99022,29.129734&point=56.001069,29.150848", 200);
         JsonNode path = json.get("paths").get(0);
         double distance = path.get("distance").asDouble();
         assertEquals("distance wasn't correct:" + distance, 1870, distance, 100);
+
+        json = query("point=55.99022,29.129734&point=56.001069,29.150848&ch.disable=true", 200);
+        distance = json.get("paths").get(0).get("distance").asDouble();
+        assertEquals("distance wasn't correct:" + distance, 1870, distance, 100);
+
+        GraphHopper hopper = getInstance(GraphHopper.class);
+        hopper.getLMFactoryDecorator().setDisablingAllowed(true);
+        json = query("point=55.99022,29.129734&point=56.001069,29.150848&ch.disable=true&lm.disable=true", 200);
+        distance = json.get("paths").get(0).get("distance").asDouble();
+        assertEquals("distance wasn't correct:" + distance, 1870, distance, 100);
+        hopper.getLMFactoryDecorator().setDisablingAllowed(false);
     }
 
     @Test
