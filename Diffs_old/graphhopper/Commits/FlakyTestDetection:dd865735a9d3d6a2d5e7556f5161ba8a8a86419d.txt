diff --git a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
index 747e1951d2..264488d649 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
@@ -124,9 +124,9 @@ final long setFlags_(long edgePointer, boolean reverse, long flags) {
      */
     final int internalEdgeAdd(int newEdgeId, int fromNodeId, int toNodeId) {
         writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        connectNewEdge(fromNodeId, newEdgeId);
+        connectNewEdge(fromNodeId, toNodeId, newEdgeId);
         if (fromNodeId != toNodeId)
-            connectNewEdge(toNodeId, newEdgeId);
+            connectNewEdge(toNodeId, fromNodeId, newEdgeId);
         return newEdgeId;
     }
 
@@ -147,11 +147,10 @@ final int getEdgeRef(int nodeThis, int nodeOther, long edgePointer) {
         return edges.getInt(_getLinkPosInEdgeArea(nodeThis, nodeOther, edgePointer));
     }
 
-    final void connectNewEdge(int fromNode, int newOrExistingEdge) {
+    final void connectNewEdge(int fromNode, int otherNode, int newOrExistingEdge) {
         int edge = getEdgeRef(fromNode);
         if (edge > EdgeIterator.NO_EDGE) {
             long edgePointer = toPointer(newOrExistingEdge);
-            int otherNode = getOtherNode(fromNode, edgePointer);
             long lastLink = _getLinkPosInEdgeArea(fromNode, otherNode, edgePointer);
             edges.setInt(lastLink, edge);
         }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index e472d92716..190005af5f 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -227,7 +227,7 @@ public boolean loadExisting() {
         baseGraph.checkInit();
         if (properties.loadExisting()) {
             properties.checkVersions(false);
-            // check encoding for compatiblity
+            // check encoding for compatibility
             String flagEncodersStr = properties.get("graph.flag_encoders");
 
             if (!flagEncodersStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(flagEncodersStr)) {
@@ -299,7 +299,7 @@ public long getCapacity() {
 
     /**
      * Avoid that edges and nodes of the base graph are further modified. Necessary as hook for e.g.
-     * ch graphs on top to initilize themself
+     * ch graphs on top to initialize themselves
      */
     public synchronized void freeze() {
         if (!baseGraph.isFrozen())
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index aaffb8cf7a..9df8c7941b 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -262,15 +262,12 @@ public static Graph copyTo(Graph fromGraph, Graph toGraph) {
     }
 
     static Directory guessDirectory(GraphStorage store) {
-        String location = store.getDirectory().getLocation();
-        Directory outdir;
         if (store.getDirectory() instanceof MMapDirectory) {
             throw new IllegalStateException("not supported yet: mmap will overwrite existing storage at the same location");
-        } else {
-            boolean isStoring = ((GHDirectory) store.getDirectory()).isStoring();
-            outdir = new RAMDirectory(location, isStoring);
         }
-        return outdir;
+        String location = store.getDirectory().getLocation();
+        boolean isStoring = ((GHDirectory) store.getDirectory()).isStoring();
+        return new RAMDirectory(location, isStoring);
     }
 
     /**
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index 0a2e98f8df..c8f6d44f8e 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -36,7 +36,7 @@
 
 /**
  * Abstract test class to be extended for implementations of the Graph interface. Graphs
- * implementing GraphStorage should extend GraphStorageTest instead.
+ * implementing GraphStorage should extend {@link GraphHopperStorageTest} instead.
  * <p>
  *
  * @author Peter Karich
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index 3c110ecf1e..200806f488 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -56,7 +56,7 @@ public void testCannotBeLoadedWithNormalGraphHopperStorageClass() {
         graph = new GraphBuilder(encodingManager).setLocation(defaultGraphLoc).setMmap(false).setStore(true).create();
         try {
             graph.loadExisting();
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
         }
 
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index f194d8bef9..9621b33e92 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -51,12 +51,12 @@
  * This class parses an OSM xml or pbf file and creates a graph from it. It does so in a two phase
  * parsing processes in order to reduce memory usage compared to a single parsing processing.
  * <p>
- * 1. a) Reads ways from OSM file and stores all associated node ids in osmNodeIdToIndexMap. If a
+ * 1. a) Reads ways from OSM file and stores all associated node ids in {@link #osmNodeIdToInternalNodeMap}. If a
  * node occurs once it is a pillar node and if more it is a tower node, otherwise
- * osmNodeIdToIndexMap returns EMPTY.
+ * {@link #osmNodeIdToInternalNodeMap} returns EMPTY.
  * <p>
  * 1. b) Reads relations from OSM file. In case that the relation is a route relation, it stores
- * specific relation attributes required for routing into osmWayIdToRouteWeigthMap for all the ways
+ * specific relation attributes required for routing into {@link #osmWayIdToRouteWeightMap} for all the ways
  * of the relation.
  * <p>
  * 2.a) Reads nodes from OSM file and stores lat+lon information either into the intermediate
@@ -64,7 +64,7 @@
  * graphStorage via setLatitude/setLongitude. It can also happen that a pillar node needs to be
  * transformed into a tower node e.g. via barriers or different speed values for one way.
  * <p>
- * 2.b) Reads ways OSM file and creates edges while calculating the speed etc from the OSM tags.
+ * 2.b) Reads ways from OSM file and creates edges while calculating the speed etc from the OSM tags.
  * When creating an edge the pillar node information from the intermediate data structure will be
  * stored in the way geometry of that edge.
  * <p>
@@ -263,7 +263,7 @@ private void writeOsm2Graph(File osmFile) {
             while ((item = in.getNext()) != null) {
                 switch (item.getType()) {
                     case ReaderElement.NODE:
-                        if (nodeFilter.get(item.getId()) != -1) {
+                        if (nodeFilter.get(item.getId()) != EMPTY_NODE) {
                             processNode((ReaderNode) item);
                         }
                         break;
