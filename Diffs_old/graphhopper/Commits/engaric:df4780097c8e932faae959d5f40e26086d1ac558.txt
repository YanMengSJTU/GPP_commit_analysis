diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 66b26d64dc..8a15f986a8 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -66,7 +66,6 @@
     private double defaultWeightLimit = Double.MAX_VALUE;
     private boolean simplifyResponse = true;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
-    private String defaultVehicleStr;
     private RoutingAlgorithmFactory algoFactory;
     // for index
     private LocationIndex locationIndex;
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index 5e98e3ca80..800bc7c14d 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -17,6 +17,9 @@
  */
 package com.graphhopper.util;
 
+import static java.lang.Math.cos;
+import static java.lang.Math.toRadians;
+
 /**
  * Calculates the angle of a turn, defined by three points. The fast atan2 method is from Jim Shima,
  * 1999, http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization
@@ -58,7 +61,8 @@ static final double atan2( double y, double x )
      */
     public double calcOrientation( double lat1, double lon1, double lat2, double lon2 )
     {
-        return atan2((lat2 - lat1), (lon2 - lon1));
+        double shrinkFactor = cos(toRadians((lat1 + lat2) / 2));
+        return Math.atan2((lat2 - lat1), shrinkFactor * (lon2 - lon1));
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 7e21bb6055..3502bb7a85 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -133,15 +133,16 @@ public double calcNormalizedEdgeDistanceNew( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg, boolean reduceToSegment )
     {
-        double shrink_factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
+
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * shrink_factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * shrink_factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * shrink_factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double delta_lon = b_lon - a_lon;
         double delta_lat = b_lat - a_lat;
@@ -168,7 +169,7 @@ else if (factor < 0)
         // x,y is projection of r onto segment a-b
         double c_lon = a_lon + factor * delta_lon;
         double c_lat = a_lat + factor * delta_lat;
-        return calcNormalizedDist(c_lat, c_lon / shrink_factor, r_lat_deg, r_lon_deg);
+        return calcNormalizedDist(c_lat, c_lon / shrinkFactor, r_lat_deg, r_lon_deg);
     }
 
     @Override
@@ -176,15 +177,15 @@ public GHPoint calcCrossingPointToEdge( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg )
     {
-        double shrink_factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * shrink_factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * shrink_factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * shrink_factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double delta_lon = b_lon - a_lon;
         double delta_lat = b_lat - a_lat;
@@ -211,7 +212,7 @@ else if (factor < 0)
         // x,y is projection of r onto segment a-b
         double c_lon = a_lon + factor * delta_lon;
         double c_lat = a_lat + factor * delta_lat;
-        return new GHPoint(c_lat, c_lon / shrink_factor);
+        return new GHPoint(c_lat, c_lon / shrinkFactor);
     }
 
     @Override
@@ -219,15 +220,15 @@ public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg )
     {
-        double factor = cos((toRadians(a_lat_deg) + toRadians(b_lat_deg)) / 2);
+        double shrinkFactor = cos(toRadians((a_lat_deg + b_lat_deg) / 2));
         double a_lat = a_lat_deg;
-        double a_lon = a_lon_deg * factor;
+        double a_lon = a_lon_deg * shrinkFactor;
 
         double b_lat = b_lat_deg;
-        double b_lon = b_lon_deg * factor;
+        double b_lon = b_lon_deg * shrinkFactor;
 
         double r_lat = r_lat_deg;
-        double r_lon = r_lon_deg * factor;
+        double r_lon = r_lon_deg * shrinkFactor;
 
         double ar_x = r_lon - a_lon;
         double ar_y = r_lat - a_lat;
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index 078a50ecd6..feef36b489 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -219,8 +219,9 @@ String calcDirection( Instruction nextI )
     }
 
     /**
-     * Return the azimuth in degree based on the first tracksegment of the instruction. If
-     * Instruction does not contain enough coordinate points, an empty string will be returned.
+     * Return the azimuth in degree based on the first tracksegment of this instruction. If this
+     * instruction contains less than 2 points then NaN will be returned or the specified
+     * instruction will be used if that is the finish instruction.
      */
     public double calcAzimuth( Instruction nextI )
     {
diff --git a/core/src/test/java/com/graphhopper/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
index 5377cf06ae..0d74a52e0b 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -94,7 +94,7 @@ public void testMonacoWithInstructions() throws Exception
         List<Map<String, Object>> resultJson = il.createJson();
         // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
         assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
         assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
         assertEquals("Turn left", resultJson.get(3).get("text"));
         assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
@@ -136,7 +136,7 @@ public void testMonacoVia()
         assertEquals(26, il.size());
         List<Map<String, Object>> resultJson = il.createJson();
         assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
         assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
         assertEquals("Turn left", resultJson.get(3).get("text"));
         assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
@@ -147,7 +147,7 @@ public void testMonacoVia()
         assertEquals("Turn left", resultJson.get(21).get("text"));
         assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
         assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
-        assertEquals("Turn slight right onto Avenue des Guelfes", resultJson.get(24).get("text"));
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(24).get("text"));
         assertEquals("Finish!", resultJson.get(25).get("text"));
 
         assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
@@ -225,8 +225,8 @@ public void testSRTMWithInstructions() throws Exception
                 str.substring(0, 662));
 
         assertEquals("(43.727778875703635,7.418772930326453,11.0), (43.72768239068275,7.419007064826944,11.0), "
-                + "(43.727680946587874,7.4191987684222065,11.0)",
-                str.substring(str.length() - 133));
+                + "(43.727680946587874,7.419198768422206,11.0)",
+                str.substring(str.length() - 132));
 
         List<GPXEntry> list = rsp.getInstructions().createGPXList();
         assertEquals(60, list.size());
@@ -267,17 +267,17 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo()
 
         assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
         assertEquals("get off the bike", resultJson.get(0).get("annotation_text"));
-        assertEquals("Turn sharp left onto Kirchengasse", resultJson.get(1).get("text"));
+        assertEquals("Turn left onto Kirchengasse", resultJson.get(1).get("text"));
         assertEquals("get off the bike", resultJson.get(1).get("annotation_text"));
 
-        assertEquals("Turn sharp right onto Pfarrplatz", resultJson.get(2).get("text"));
+        assertEquals("Turn right onto Pfarrplatz", resultJson.get(2).get("text"));
         assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
-        assertEquals("Turn left onto Hoher Markt", resultJson.get(4).get("text"));
-        assertEquals("Turn slight right onto Wegscheid", resultJson.get(5).get("text"));
+        assertEquals("Turn slight left onto Hoher Markt", resultJson.get(4).get("text"));
+        assertEquals("Turn right onto Wegscheid", resultJson.get(5).get("text"));
         assertEquals("Turn slight left onto Untere Landstraße", resultJson.get(6).get("text"));
         assertEquals("Turn right onto Ringstraße, L73", resultJson.get(7).get("text"));
         assertEquals("Continue onto Eyblparkstraße", resultJson.get(8).get("text"));
-        assertEquals("Continue onto Austraße", resultJson.get(9).get("text"));
+        assertEquals("Turn slight left onto Austraße", resultJson.get(9).get("text"));
         assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
         //..
         assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
@@ -314,7 +314,7 @@ public void testRoundaboutInstructionsWithCH()
                 .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
         assertEquals(1, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
 
-        rsp = tmpHopper.route(new GHRequest(43.735817,7.417096, 43.735666,7.416587)
+        rsp = tmpHopper.route(new GHRequest(43.735817, 7.417096, 43.735666, 7.416587)
                 .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
         assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
     }
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
index e47b52da9d..f41b24ae4b 100644
--- a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
+++ b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -31,11 +31,15 @@
     @Test
     public void testOrientation()
     {
-        assertEquals(90.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 0)), 0.001);
-        assertEquals(45.0, Math.toDegrees(ac.calcOrientation(0, 0, 10, 10)), 0.001);
-        assertEquals(0.0, Math.toDegrees(ac.calcOrientation(0, 0, 0, 10)), 0.001);
-        assertEquals(-45.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, 10)), 0.001);
-        assertEquals(-135.0, Math.toDegrees(ac.calcOrientation(0, 0, -10, -10)), 0.001);
+        assertEquals(90.0, Math.toDegrees(ac.calcOrientation(0, 0, 1, 0)), 0.01);
+        assertEquals(45.0, Math.toDegrees(ac.calcOrientation(0, 0, 1, 1)), 0.01);
+        assertEquals(0.0, Math.toDegrees(ac.calcOrientation(0, 0, 0, 1)), 0.01);
+        assertEquals(-45.0, Math.toDegrees(ac.calcOrientation(0, 0, -1, 1)), 0.01);
+        assertEquals(-135.0, Math.toDegrees(ac.calcOrientation(0, 0, -1, -1)), 0.01);
+
+        // is symetric?
+        assertEquals(90 - 32.76, Math.toDegrees(ac.calcOrientation(49.942, 11.580, 49.944, 11.582)), 0.01);
+        assertEquals(-90 - 32.76, Math.toDegrees(ac.calcOrientation(49.944, 11.582, 49.942, 11.580)), 0.01);
     }
 
     @Test
@@ -51,19 +55,19 @@ public void testAlignOrientation()
     public void testCombined()
     {
         double orientation = ac.calcOrientation(52.414918, 13.244221, 52.415333, 13.243595);
-        assertEquals(146.5, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+        assertEquals(132.7, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
 
         orientation = ac.calcOrientation(52.414918, 13.244221, 52.414573, 13.243627);
-        assertEquals(-149.7, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+        assertEquals(-136.38, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
     }
 
     @Test
     public void testCalcAzimuth()
     {
-        assertEquals(45.0, ac.calcAzimuth(0, 0, 10, 10), 0.001);
-        assertEquals(90.0, ac.calcAzimuth(0, 0, 0, 10), 0.001);
-        assertEquals(180.0, ac.calcAzimuth(0, 0, -10, 0), 0.001);
-        assertEquals(270.0, ac.calcAzimuth(0, 0, 0, -10), 0.001);
+        assertEquals(45.0, ac.calcAzimuth(0, 0, 1, 1), 0.001);
+        assertEquals(90.0, ac.calcAzimuth(0, 0, 0, 1), 0.001);
+        assertEquals(180.0, ac.calcAzimuth(0, 0, -1, 0), 0.001);
+        assertEquals(270.0, ac.calcAzimuth(0, 0, 0, -1), 0.001);
         assertEquals(0.0, ac.calcAzimuth(49.942, 11.580, 49.944, 11.580), 0.001);
     }
 
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index f65170813b..70d8a5f83a 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -46,7 +46,7 @@ public void testCalcAzimuthAndGetDirection()
         p2.add(49.944, 11.582);
         Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2);
 
-        assertEquals(45, i2.calcAzimuth(null), .1);
+        assertEquals(32.76, i2.calcAzimuth(null), .1);
         assertEquals("NE", i2.calcDirection(null));
 
         PointList p3 = new PointList();
