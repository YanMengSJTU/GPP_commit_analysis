diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index c9f087d245..f8017dabfd 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -21,6 +21,7 @@
 import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.dem.CGIARProvider;
 import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.reader.dem.LowPrecisionSRTMProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
@@ -541,7 +542,7 @@ public GraphHopper init( CmdArgs args )
         ElevationProvider tmpProvider = ElevationProvider.NOOP;
         if (eleProviderStr.equalsIgnoreCase("srtm"))
         {
-            tmpProvider = new SRTMProvider();
+            tmpProvider = new LowPrecisionSRTMProvider();
         } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
         {
             CGIARProvider cgiarProvider = new CGIARProvider();
diff --git a/core/src/main/java/com/graphhopper/reader/dem/HighPrecisionSRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/HighPrecisionSRTMProvider.java
new file mode 100644
index 0000000000..b140296426
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/HighPrecisionSRTMProvider.java
@@ -0,0 +1,90 @@
+/*
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.storage.*;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.Downloader;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.io.*;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Elevation data from NASA (SRTM). Downloaded from http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/
+ * <p/>
+ * Important information about SRTM: the coordinates of the lower-left corner of tile N40W118 are 40
+ * degrees north latitude and 118 degrees west longitude. To be more exact, these coordinates refer
+ * to the geometric center of the lower left sample, which in the case of SRTM3 data will be about
+ * 90 meters in extent.
+ * <p/>
+ *
+ * @author Peter Karich
+ */
+public class HighPrecisionSRTMProvider extends SRTMProvider
+{
+    public static void main(String[] args) throws IOException
+    {
+        HighPrecisionSRTMProvider provider = new HighPrecisionSRTMProvider();
+        // 1046
+        System.out.println(provider.getEle(47.468668, 14.575127));
+        // 1113
+        System.out.println(provider.getEle(47.467753, 14.573911));
+
+        // 1946
+        System.out.println(provider.getEle(46.468835, 12.578777));
+
+        // 845
+        System.out.println(provider.getEle(48.469123, 9.576393));
+
+        // 1113 vs new:
+        provider.setCalcMean(true);
+        System.out.println(provider.getEle(47.467753, 14.573911));
+    }
+
+
+    public HighPrecisionSRTMProvider()
+    {
+        WIDTH = 3601;
+        baseUrl = "http://e4ftl01.cr.usgs.gov/SRTM/SRTMGL1.003/2000.02.11/";
+    }
+
+
+    String getFileString(double lat, double lon)
+    {
+        int minLat = Math.abs(down(lat));
+        int minLon = Math.abs(down(lon));
+
+        return String.format("%s%02d%s%03d.SRTMGL1",
+                (lat >= 0) ? "N" : "S",
+                minLat,
+                (lon >= 0) ? "E" : "W",
+                minLon
+        );
+    }
+
+    @Override
+    public String toString()
+    {
+        return "HighPrecisionSRTM";
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/reader/dem/LowPrecisionSRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/LowPrecisionSRTMProvider.java
new file mode 100644
index 0000000000..e4a4d2e636
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/dem/LowPrecisionSRTMProvider.java
@@ -0,0 +1,116 @@
+package com.graphhopper.reader.dem;
+
+import com.graphhopper.util.Helper;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+public class LowPrecisionSRTMProvider extends SRTMProvider
+{
+    private final TIntObjectHashMap<String> areas = new TIntObjectHashMap<String>();
+
+    public static void main( String[] args ) throws IOException
+    {
+        SRTMProvider provider = new LowPrecisionSRTMProvider();
+        // 1046
+        System.out.println(provider.getEle(47.468668, 14.575127));
+        // 1113
+        System.out.println(provider.getEle(47.467753, 14.573911));
+
+        // 1946
+        System.out.println(provider.getEle(46.468835, 12.578777));
+
+        // 845
+        System.out.println(provider.getEle(48.469123, 9.576393));
+
+        // 1113 vs new:
+        provider.setCalcMean(true);
+        System.out.println(provider.getEle(47.467753, 14.573911));
+    }
+
+    public LowPrecisionSRTMProvider()
+    {
+        WIDTH = 1201;
+        baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
+        // move to explicit calls?
+        init();
+    }
+
+    /**
+     * The URLs are a bit ugly and so we need to find out which area name a certain lat,lon
+     * coordinate has.
+     */
+    private SRTMProvider init()
+    {
+        try
+        {
+            String strs[] =
+                    {
+                            "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
+                    };
+            for (String str : strs)
+            {
+                InputStream is = getClass().getResourceAsStream(str + "_names.txt");
+                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
+                {
+                    int lat = Integer.parseInt(line.substring(1, 3));
+                    if (line.substring(0, 1).charAt(0) == 'S')
+                        lat = -lat;
+
+                    int lon = Integer.parseInt(line.substring(4, 7));
+                    if (line.substring(3, 4).charAt(0) == 'W')
+                        lon = -lon;
+
+                    int intKey = calcIntKey(lat, lon);
+                    String key = areas.put(intKey, str);
+                    if (key != null)
+                        throw new IllegalStateException("do not overwrite existing! key " + intKey + " " + key + " vs. " + str);
+                }
+            }
+            return this;
+        } catch (Exception ex)
+        {
+            throw new IllegalStateException("Cannot load area names from classpath", ex);
+        }
+    }
+
+    String getFileString( double lat, double lon )
+    {
+        int intKey = calcIntKey(lat, lon);
+        String str = areas.get(intKey);
+        if (str == null)
+            return null;
+
+        int minLat = Math.abs(down(lat));
+        int minLon = Math.abs(down(lon));
+        str += "/";
+        if (lat >= 0)
+            str += "N";
+        else
+            str += "S";
+
+        if (minLat < 10)
+            str += "0";
+        str += minLat;
+
+        if (lon >= 0)
+            str += "E";
+        else
+            str += "W";
+
+        if (minLon < 10)
+            str += "0";
+        if (minLon < 100)
+            str += "0";
+        str += minLon;
+        return str;
+    }
+
+    @Override
+    public String toString()
+    {
+        return "SRTM";
+    }
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
index 2c98e431dd..afa060296a 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/SRTMProvider.java
@@ -21,88 +21,40 @@
 import com.graphhopper.storage.*;
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Downloader;
-import com.graphhopper.util.Helper;
 import gnu.trove.map.hash.TIntObjectHashMap;
-
 import java.io.*;
 import java.net.SocketTimeoutException;
 import java.util.zip.ZipInputStream;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Elevation data from NASA (SRTM).
- * <p/>
+ * Elevation data from NASA (SRTM). Downloaded from http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/
+ * <p>
  * Important information about SRTM: the coordinates of the lower-left corner of tile N40W118 are 40
  * degrees north latitude and 118 degrees west longitude. To be more exact, these coordinates refer
  * to the geometric center of the lower left sample, which in the case of SRTM3 data will be about
  * 90 meters in extent.
- * <p/>
+ * <p>
  * @author Peter Karich
  */
-public class SRTMProvider implements ElevationProvider
+public abstract class SRTMProvider implements ElevationProvider
 {
-    public static void main( String[] args ) throws IOException
-    {
-
-        SRTMProvider provider = new SRTMProvider();
-        // SET Calc mean true
-        provider.setCalcMean(true);
-        //Klausen
-        System.out.println(provider.getEle(46.6399956, 11.566211));
-
-        //Seis
-        System.out.println(provider.getEle(46.544837, 11.562284));
-
-                // 1046
-        /*System.out.println(provider.getEle(47.468668, 14.575127));
-        // 1113
-        System.out.println(provider.getEle(47.467753, 14.573911));
-
-        // 1946
-        System.out.println(provider.getEle(46.468835, 12.578777));
-
-        // 845
-        System.out.println(provider.getEle(48.469123, 9.576393));
-
-        */
-                // SET Calc mean true
-                provider.setCalcMean(false);
-        // 1046
-        //System.out.println(provider.getEle(47.468668, 14.575127));
-        // 1113
-        //System.out.println(provider.getEle(47.467753, 14.573911));
-
-        // 1946
-        //System.out.println(provider.getEle(46.468835, 12.578777));
-
-        // 845
-        //System.out.println(provider.getEle(48.469123, 9.576393));
-    }
 
     private static final BitUtil BIT_UTIL = BitUtil.BIG;
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final int WIDTH = 1201;
+    protected int WIDTH;
     private Directory dir;
     private DAType daType = DAType.MMAP;
     private Downloader downloader = new Downloader("GraphHopper SRTMReader").setTimeout(10000);
     private File cacheDir = new File("/tmp/srtm");
     // use a map as an array is not quite useful if we want to hold only parts of the world
-    private final TIntObjectHashMap<HeightTile> cacheData = new TIntObjectHashMap<HeightTile>();
-    private final TIntObjectHashMap<String> areas = new TIntObjectHashMap<String>();
-    private final double precision = 1e7;
-    private final double invPrecision = 1 / precision;
-    // possible alternatives see #451
-    // http://mirror.ufs.ac.za/datasets/SRTM3/
-    private String baseUrl = "http://dds.cr.usgs.gov/srtm/version2_1/SRTM3/";
+    protected final TIntObjectHashMap<HeightTile> cacheData = new TIntObjectHashMap<HeightTile>();
+    protected final double precision = 1e7;
+    protected final double invPrecision = 1 / precision;
+    // mirror: base = "http://mirror.ufs.ac.za/datasets/SRTM3/"
     private boolean calcMean = false;
-
-    public SRTMProvider()
-    {
-        // move to explicit calls?
-        init();
-    }
+    protected String baseUrl;
 
     @Override
     public void setCalcMean( boolean calcMean )
@@ -110,46 +62,9 @@ public void setCalcMean( boolean calcMean )
         this.calcMean = calcMean;
     }
 
-    /**
-     * The URLs are a bit ugly and so we need to find out which area name a certain lat,lon
-     * coordinate has.
-     */
-    private SRTMProvider init()
-    {
-        try
-        {
-            String strs[] =
-                    {
-                            "Africa", "Australia", "Eurasia", "Islands", "North_America", "South_America"
-                    };
-            for (String str : strs)
-            {
-                InputStream is = getClass().getResourceAsStream(str + "_names.txt");
-                for (String line : Helper.readFile(new InputStreamReader(is, Helper.UTF_CS)))
-                {
-                    int lat = Integer.parseInt(line.substring(1, 3));
-                    if (line.substring(0, 1).charAt(0) == 'S')
-                        lat = -lat;
-
-                    int lon = Integer.parseInt(line.substring(4, 7));
-                    if (line.substring(3, 4).charAt(0) == 'W')
-                        lon = -lon;
-
-                    int intKey = calcIntKey(lat, lon);
-                    String key = areas.put(intKey, str);
-                    if (key != null)
-                        throw new IllegalStateException("do not overwrite existing! key " + intKey + " " + key + " vs. " + str);
-                }
-            }
-            return this;
-        } catch (Exception ex)
-        {
-            throw new IllegalStateException("Cannot load area names from classpath", ex);
-        }
-    }
 
     // use int key instead of string for lower memory usage
-    private int calcIntKey( double lat, double lon )
+    protected int calcIntKey( double lat, double lon )
     {
         // we could use LinearKeyAlgo but this is simpler as we only need integer precision:
         return (down(lat) + 90) * 1000 + down(lon) + 180;
@@ -201,37 +116,7 @@ int down( double val )
         return intVal - 1;
     }
 
-    String getFileString( double lat, double lon )
-    {
-        int intKey = calcIntKey(lat, lon);
-        String str = areas.get(intKey);
-        if (str == null)
-            return null;
-
-        int minLat = Math.abs(down(lat));
-        int minLon = Math.abs(down(lon));
-        str += "/";
-        if (lat >= 0)
-            str += "N";
-        else
-            str += "S";
-
-        if (minLat < 10)
-            str += "0";
-        str += minLat;
-
-        if (lon >= 0)
-            str += "E";
-        else
-            str += "W";
-
-        if (minLon < 10)
-            str += "0";
-        if (minLon < 100)
-            str += "0";
-        str += minLon;
-        return str;
-    }
+    abstract String getFileString(double lat, double lon);
 
     @Override
     public double getEle( double lat, double lon )
@@ -257,6 +142,7 @@ public double getEle( double lat, double lon )
             DataAccess heights = getDirectory().find("dem" + intKey);
             demProvider.setHeights(heights);
             boolean loadExisting = false;
+
             try
             {
                 loadExisting = heights.loadExisting();
@@ -271,49 +157,9 @@ public double getEle( double lat, double lon )
                 heights.create(bytes.length);
                 try
                 {
-                    String zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
-                    File file = new File(cacheDir, new File(zippedURL).getName());
-                    InputStream is;
-                    // get zip file if not already in cacheDir - unzip later and in-memory only!
-                    if (!file.exists())
-                    {
-                        for (int i = 0; i < 3; i++)
-                        {
-                            try
-                            {
-                                downloader.downloadFile(zippedURL, file.getAbsolutePath());
-                                break;
-                            } catch (SocketTimeoutException ex)
-                            {
-                                // just try again after a little nap
-                                Thread.sleep(2000);
-                                continue;
-                            } catch (FileNotFoundException ex)
-                            {
-                                // now try different URL (without point!), necessary if mirror is used
-                                zippedURL = baseUrl + "/" + fileDetails + "hgt.zip";
-                                continue;
-                            }
-                        }
-                    }
-
-                    is = new FileInputStream(file);
-                    ZipInputStream zis = new ZipInputStream(is);
-                    zis.getNextEntry();
-                    BufferedInputStream buff = new BufferedInputStream(zis);
-                    int len;
-                    while ((len = buff.read(bytes)) > 0)
-                    {
-                        for (int bytePos = 0; bytePos < len; bytePos += 2)
-                        {
-                            short val = BIT_UTIL.toShort(bytes, bytePos);
-                            if (val < -1000 || val > 12000)
-                                val = Short.MIN_VALUE;
+                    File file = downloadFile(fileDetails);
 
-                            heights.setShort(bytePos, val);
-                        }
-                    }
-                    heights.flush();
+                    processFile(heights, bytes, file);
 
                     // demProvider.toImage("x" + file.getName() + ".png");
                     // TODO remove hgt and zip?
@@ -327,6 +173,57 @@ public double getEle( double lat, double lon )
         return demProvider.getHeight(lat, lon);
     }
 
+    private File downloadFile(String fileDetails) throws IOException, InterruptedException {
+        String zippedURL = baseUrl + fileDetails + ".hgt.zip";
+        File file = new File(cacheDir, new File(zippedURL).getName());
+
+        // get zip file if not already in cacheDir - unzip later and in-memory only!
+        if (!file.exists())
+        {
+            for (int i = 0; i < 3; i++)
+            {
+                try
+                {
+                    downloader.downloadFile(zippedURL, file.getAbsolutePath());
+                    break;
+                } catch (SocketTimeoutException ex)
+                {
+                    // just try again after a little nap
+                    Thread.sleep(2000);
+                    continue;
+                } catch (FileNotFoundException ex)
+                {
+                    // now try different URL (with point!), necessary if mirror is used
+                    zippedURL = baseUrl + "/" + fileDetails + ".hgt.zip";
+                    continue;
+                }
+            }
+        }
+        return file;
+    }
+
+    private void processFile(DataAccess heights, byte[] bytes, File file) throws IOException {
+        InputStream is;
+
+        is = new FileInputStream(file);
+        ZipInputStream zis = new ZipInputStream(is);
+        zis.getNextEntry();
+        BufferedInputStream buff = new BufferedInputStream(zis);
+        int len;
+        while ((len = buff.read(bytes)) > 0)
+        {
+            for (int bytePos = 0; bytePos < len; bytePos += 2)
+            {
+                short val = BIT_UTIL.toShort(bytes, bytePos);
+                if (val < -1000 || val > 12000)
+                    val = Short.MIN_VALUE;
+
+                heights.setShort(bytePos, val);
+            }
+        }
+        heights.flush();
+    }
+
     @Override
     public void release()
     {
@@ -337,12 +234,6 @@ public void release()
             dir.clear();
     }
 
-    @Override
-    public String toString()
-    {
-        return "SRTM";
-    }
-
     private Directory getDirectory()
     {
         if (dir != null)
diff --git a/core/src/test/java/com/graphhopper/GraphHopperIT.java b/core/src/test/java/com/graphhopper/GraphHopperIT.java
index 9c26d7f776..e6d6673585 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper;
 
+import com.graphhopper.reader.dem.LowPrecisionSRTMProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
@@ -230,7 +231,7 @@ public void testSRTMWithInstructions() throws Exception
                 setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager(importVehicles));
 
-        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
+        tmpHopper.setElevationProvider(new LowPrecisionSRTMProvider().setCacheDir(new File("./files/")));
         tmpHopper.importOrLoad();
 
         GHResponse rsp = tmpHopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index dd643722af..bf9221c59d 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -19,6 +19,7 @@
 
 import static org.junit.Assert.*;
 
+import com.graphhopper.reader.dem.LowPrecisionSRTMProvider;
 import gnu.trove.list.TLongList;
 
 import java.io.File;
@@ -686,7 +687,7 @@ public void testReadEleFromDataProvider()
     {
         GraphHopper hopper = new GraphHopperTest("test-osm5.xml");
         // get N10E046.hgt.zip
-        ElevationProvider provider = new SRTMProvider();
+        ElevationProvider provider = new LowPrecisionSRTMProvider();
         provider.setCacheDir(new File("./files"));
         hopper.setElevationProvider(provider);
         hopper.importOrLoad();
diff --git a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
index 30f2439d3a..9d4daec343 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/SRTMProviderTest.java
@@ -40,7 +40,7 @@
     @Before
     public void setUp()
     {
-        instance = new SRTMProvider();
+        instance = new LowPrecisionSRTMProvider();
     }
 
     @After
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index addcbcddfc..43016f4f74 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.reader.dem.LowPrecisionSRTMProvider;
 import com.graphhopper.routing.util.TestAlgoCollector;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.PrinctonReader;
@@ -539,7 +540,7 @@ Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
                     setGraphHopperLocation(graphFile).
                     setEncodingManager(new EncodingManager(importVehicles));
             if (is3D)
-                hopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files")));
+                hopper.setElevationProvider(new LowPrecisionSRTMProvider().setCacheDir(new File("./files")));
 
             hopper.importOrLoad();
 
