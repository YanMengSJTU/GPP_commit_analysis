diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 4b586d0beb..6e7509b121 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -28,6 +28,7 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+import gnu.trove.iterator.TIntIterator;
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.procedure.TIntProcedure;
 import gnu.trove.set.hash.TIntHashSet;
@@ -598,8 +599,84 @@ final long createReverseKey( long key )
     {
         return BitUtil.BIG.reverse(key, keyAlgo.getBits());
     }
+    
+    
+    protected TIntHashSet findNetworkEntries( double queryLat, double queryLon)
+    {
+        TIntHashSet resultEntries = new TIntHashSet(); 
+        TIntHashSet foundEntries = new TIntHashSet();
+
+        int maxiteration = 32;
+        for (int iteration = 0; iteration < maxiteration; iteration++)
+        {
+
+            // find entries in border of searchbox
+            for (int yreg = -iteration; yreg <= iteration; yreg++)
+            {
+                double subqueryLat = queryLat + yreg * deltaLat;
+                double subqueryLonA = queryLon - iteration * deltaLon;
+                double subqueryLonB = queryLon + iteration * deltaLon;
+                foundEntries.addAll(findNetworkEntriesSingleRegion(subqueryLat, subqueryLonA));
+                foundEntries.addAll(findNetworkEntriesSingleRegion(subqueryLat, subqueryLonB));
+
+            }
+            for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++)
+            {
+                double subqueryLon = queryLon + xreg * deltaLon;
+                double subqueryLatA = queryLat - iteration * deltaLat;
+                double subqueryLatB = queryLat + iteration * deltaLat;
+                foundEntries.addAll(findNetworkEntriesSingleRegion(subqueryLatA, subqueryLon));
+                foundEntries.addAll(findNetworkEntriesSingleRegion(subqueryLatB, subqueryLon));
+            }
+
+          // filter entries, to get only those which are located in a circle
+            if (iteration > 0) // filter only, when scope was already expanded
+            {  
+                double mindelta = (deltaLat < deltaLon) ? deltaLat : deltaLon;
+                double radius = mindelta * (iteration + 0.5);
+                resultEntries = circleFilter(foundEntries, radius, queryLat, queryLon);
+            } else {
+                resultEntries = foundEntries;
+            }
+
+            // Good if something was found. Else repeat whole proces with wider search area. 
+            if (resultEntries.size() > 0)
+            {
+                break;
+            }
+        }
+        return resultEntries;
+    }
+
+    protected TIntHashSet circleFilter( TIntHashSet input, double radius, double queryLat, double queryLon )
+    {
+        TIntHashSet output = new TIntHashSet();
+          //double mindelta = (deltaLat < deltaLon) ? deltaLat : deltaLon;
+        //double radius = mindelta * (iteration + 0.5);
+
+        TIntIterator itr = input.iterator();
+        while (itr.hasNext())
+        {
+            int element = itr.next();
+            double eLat = nodeAccess.getLat(element);
+            double eLon = nodeAccess.getLon(element);
+            if (insideCircle(eLat - queryLat, eLon - queryLon, radius))
+            {
+                output.add(element);
+            }
+        }
+        return output;
+    }
+
+    /**
+     * Quick test if coordinate x|y is inside a circle with certain radius (inclusive border)
+     */
+    private boolean insideCircle( double x, double y, double radius )
+    {
+        return (x * x + y * y) <= (radius * radius);
+    }
 
-    protected TIntHashSet findNetworkEntries( double queryLat, double queryLon )
+    protected TIntHashSet findNetworkEntriesSingleRegion( double queryLat, double queryLon )
     {
         TIntHashSet storedNetworkEntryIds = new TIntHashSet();
         if (regionSearch)
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index 863278f7a5..81933c26b5 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -305,6 +305,51 @@ public boolean accept( EdgeIteratorState iter )
             }
         }).getClosestNode());
     }
+    
+    @Test
+    public void testCircleFilter()
+    {
+        Graph graph = createGraph(encodingManager);
+        NodeAccess na = graph.getNodeAccess();
+        // inside
+        na.setNode(0, 20.0, 10.0);  // center
+        na.setNode(1, 10.0, 10.0);
+        na.setNode(2, 20.0, -5.0);
+        na.setNode(3, 30.0, 20.0);
+
+        // border
+        na.setNode(4, 0.0, 10.0);
+
+        // outside
+        na.setNode(5, 0.0, 0.0);
+        na.setNode(6, 20.0, -15.0);
+        na.setNode(7, 40.0, 0.0);
+        na.setNode(8, 40.0, 30.0);
+
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+
+        TIntHashSet in = new TIntHashSet();
+        in.add(0);
+        in.add(1);
+        in.add(2);
+        in.add(3);
+        in.add(4);
+        in.add(5);
+        in.add(6);
+        in.add(7);
+        in.add(8);
+
+        TIntHashSet out = index.circleFilter(in, 20.0, 20.0, 10.0);
+        assertTrue(out.contains(0));
+        assertTrue(out.contains(1));
+        assertTrue(out.contains(2));
+        assertTrue(out.contains(3));
+        assertTrue(out.contains(4));
+        assertFalse(out.contains(5));
+        assertFalse(out.contains(6));
+        assertFalse(out.contains(7));
+        assertFalse(out.contains(8));
+    }
 
     // see testgraph2.jpg
     Graph createTestGraph2()
@@ -400,5 +445,5 @@ Graph createTestGraph2()
         graph.edge(27, 33, 10, true);
         graph.edge(28, 34, 10, true);
         return graph;
-    }
+    }   
 }
