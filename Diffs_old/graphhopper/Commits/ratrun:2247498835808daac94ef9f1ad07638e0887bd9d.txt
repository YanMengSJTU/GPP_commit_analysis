diff --git a/config-example.properties b/config-example.properties
index 28b6d902bc..e8e9dbc509 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -61,6 +61,7 @@ prepare.min_network_size=200
 prepare.min_one_way_network_size=200
 
 
+
 ##### Routing #####
 
 
@@ -92,8 +93,10 @@ routing.non_ch.max_waypoint_distance = 1000000
 # block_area=lat1,lon1,lat2,lon2
 
 
+
 ##### Web #####
 
+
 # if you want to support jsonp response type you need to add it explicitly here. By default it is disabled for stronger security.
 # web.jsonp_allowed=true
 
@@ -112,3 +115,18 @@ graph.dataaccess=RAM_STORE
 
 # Sort the graph after import to make requests roughly ~10% faster. Note that this requires significantly more RAM on import.
 # graph.do_sort=true
+
+
+
+##### Spatial Rules #####
+# Spatial Rules require some configuration and only work with the DataFlagEncoder.
+
+
+# Spatial Rules require you to provide Polygons in which the rules are enforced
+# The line below contains the default location for these rules
+# spatial_rules.location=web/src/main/resources/com/graphhopper/spatialrules/countries.geo.json
+
+# You can define the maximum BBox for which spatial rules are loaded.
+# You might want to do this if you are only importing a small area and don't need rules for other countries.
+# Having less rules, might result in a smaller graph. The line below contains the world-wide bounding box, uncomment and adapt to your need.
+# spatial_rules.max_bbox=-180,180,-90,90
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index f92fb0770c..5eae88eb2c 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -497,6 +497,10 @@ public GraphHopper setFlagEncoderFactory(FlagEncoderFactory factory) {
         return this;
     }
 
+    public FlagEncoderFactory getFlagEncoderFactory() {
+        return this.flagEncoderFactory;
+    }
+
     /**
      * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
      * args) ala CmdArgs.read(args) or via configuration file ala
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
index a25951c919..e42a356e1c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -19,10 +19,7 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.util.spatialrules.AccessValue;
-import com.graphhopper.routing.util.spatialrules.SpatialRule;
-import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
-import com.graphhopper.routing.util.spatialrules.TransportationMode;
+import com.graphhopper.routing.util.spatialrules.*;
 import com.graphhopper.routing.weighting.GenericWeighting;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
@@ -89,8 +86,7 @@
     private boolean storeWeight = false;
     private boolean storeWidth = false;
     private EncodedValue spatialEncoder;
-    private int spatialRules = 0;
-    private SpatialRuleLookup spatialRuleLookup;
+    private SpatialRuleLookup spatialRuleLookup = SpatialRuleLookup.EMPTY;
 
     public DataFlagEncoder() {
         this(5, 5, 0);
@@ -104,7 +100,6 @@ public DataFlagEncoder(PMap properties) {
         this.setStoreHeight(properties.getBool("store_height", false));
         this.setStoreWeight(properties.getBool("store_weight", false));
         this.setStoreWidth(properties.getBool("store_width", false));
-        this.setSpatialRules(properties.getInt("spatial_rules", 0));
     }
 
     public DataFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
@@ -216,12 +211,10 @@ public int defineWayBits(int index, int shift) {
         accessEncoder = new EncodedValue("access car", shift, 3, 1, 1, 4, true);
         shift += accessEncoder.getBits();
 
-        if (spatialRules > 0) {
-            int tmpMax = spatialRules + 1;
-            int bits = 32 - Integer.numberOfLeadingZeros(tmpMax);
-            spatialEncoder = new EncodedValue("spatial_location", shift, bits, 1, 1, tmpMax, true);
-            shift += spatialEncoder.getBits();
-        }
+        int tmpMax = spatialRuleLookup.size()-1;
+        int bits = 32 - Integer.numberOfLeadingZeros(tmpMax);
+        spatialEncoder = new EncodedValue("spatial_location", shift, bits, 1, 0, tmpMax, true);
+        shift += spatialEncoder.getBits();
 
         return shift;
     }
@@ -272,7 +265,7 @@ int getAccessValue(ReaderWay way) {
             }
         }
 
-        if (isSpatialRuleLookupEnabled() && accessValue == 0) {
+        if (accessValue == 0) {
             // TODO Fix transportation mode when adding other forms of transportation
             switch (getSpatialRule(way).getAccessValue(way.getTag("highway", ""), TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE)) {
                 case ACCESSIBLE:
@@ -324,7 +317,7 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
 
             // MAXSPEED
             double maxSpeed = parseSpeed(way.getTag("maxspeed"));
-            if (isSpatialRuleLookupEnabled() && maxSpeed < 0) {
+            if (maxSpeed < 0) {
                 // TODO What if no maxspeed is set, but only forward and backward, and both are higher than the usually allowed?
                 maxSpeed = getSpatialRule(way).getMaxSpeed(way.getTag("highway", ""), maxSpeed);
             }
@@ -411,13 +404,10 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
 
             flags = accessEncoder.setValue(flags, getAccessValue(way));
 
-
-            if (isSpatialRuleLookupEnabled()) {
-                GHPoint estimatedCenter = way.getTag("estimated_center", null);
-                if (estimatedCenter != null) {
-                    SpatialRule rule = spatialRuleLookup.lookupRule(estimatedCenter);
-                    flags = spatialEncoder.setValue(flags, spatialRuleLookup.getSpatialId(rule));
-                }
+            GHPoint estimatedCenter = way.getTag("estimated_center", null);
+            if (estimatedCenter != null) {
+                SpatialRule rule = spatialRuleLookup.lookupRule(estimatedCenter);
+                flags = spatialEncoder.setValue(flags, spatialRuleLookup.getSpatialId(rule));
             }
 
             return flags;
@@ -426,17 +416,6 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
         }
     }
 
-    private boolean isSpatialRuleLookupEnabled() {
-        if (spatialRules > 0) {
-            if (spatialRuleLookup == null)
-                throw new IllegalStateException("This encoder was asked to store spatial IDs for every edge, " +
-                        "but no spatial lookup was specified");
-
-            return true;
-        }
-        return false;
-    }
-
     private SpatialRule getSpatialRule(ReaderWay way) {
         GHPoint estmCentre = way.getTag("estimated_center", null);
         if (estmCentre != null) {
@@ -831,16 +810,7 @@ public boolean isStoreWidth() {
     }
 
 
-    public DataFlagEncoder setSpatialRules(int rules) {
-        this.spatialRules = rules;
-        return this;
-    }
-
     public DataFlagEncoder setSpatialRuleLookup(SpatialRuleLookup spatialRuleLookup) {
-        if (spatialRuleLookup.size() != spatialRules)
-            throw new IllegalArgumentException("You have to configure the encoder to accept the identical amount of rules " +
-                    "that the spatial rule lookup has (" + spatialRuleLookup.size() + ") but it was " + spatialRules);
-
         this.spatialRuleLookup = spatialRuleLookup;
         return this;
     }
@@ -860,8 +830,7 @@ protected String getPropertiesString() {
         return super.getPropertiesString() +
                 "|store_height=" + storeHeight +
                 "|store_weight=" + storeWeight +
-                "|store_width=" + storeWidth +
-                "|spatial_rules=" + spatialRules;
+                "|store_width=" + storeWidth;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/DefaultSpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java
similarity index 91%
rename from core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/DefaultSpatialRule.java
rename to core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java
index 9d0fd60fad..b1b1b1bed8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/DefaultSpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java
@@ -15,11 +15,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util.spatialrules.countries;
-
-import com.graphhopper.routing.util.spatialrules.AbstractSpatialRule;
-import com.graphhopper.routing.util.spatialrules.AccessValue;
-import com.graphhopper.routing.util.spatialrules.TransportationMode;
+package com.graphhopper.routing.util.spatialrules;
 
 /**
  * Default implementation for the SpatialRule that contains the current default values
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java
index 1ff54e349e..8d4bfc9c6d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java
@@ -53,16 +53,6 @@
      */
     List<Polygon> getBorders();
 
-    /**
-     * Set the borders in which the SpatialRule is valid
-     */
-    SpatialRule setBorders(List<Polygon> borders);
-
-    /**
-     * Add a polygon to the borders in which the SpatialRule is valid
-     */
-    SpatialRule addBorder(Polygon polygon);
-
     /**
      * Returns the id for this rule, e.g. the ISO name of the country. The id has to be unique.
      */
@@ -81,7 +71,7 @@ public AccessValue getAccessValue(String highwayTag, TransportationMode transpor
 
         @Override
         public String getId() {
-            return "";
+            return "SpatialRule.EMPTY";
         }
 
         @Override
@@ -89,16 +79,6 @@ public String getId() {
             throw new IllegalArgumentException("Empty rule does not have borders");
         }
 
-        @Override
-        public SpatialRule setBorders(List<Polygon> borders) {
-            throw new IllegalArgumentException("Empty rule cannot have borders");
-        }
-
-        @Override
-        public SpatialRule addBorder(Polygon polygon) {
-            throw new IllegalArgumentException("Empty rule cannot have borders");
-        }
-
         @Override
         public String toString() {
             return "SpatialRule.EMPTY";
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleContainer.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleContainer.java
index 8b2a445dd4..29f8eba3de 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleContainer.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleContainer.java
@@ -26,7 +26,7 @@
  */
 class SpatialRuleContainer {
 
-    protected final Set<SpatialRule> rules = new LinkedHashSet<>();
+    final Set<SpatialRule> rules = new LinkedHashSet<>();
 
     public SpatialRuleContainer addRule(SpatialRule spatialRule) {
         rules.add(spatialRule);
@@ -38,7 +38,7 @@ public SpatialRuleContainer addRules(Collection<SpatialRule> rules) {
         return this;
     }
 
-    public Collection<SpatialRule> getRules() {
+    Collection<SpatialRule> getRules() {
         return rules;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java
index 1d5aa162c4..4f66a68b31 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java
@@ -43,24 +43,46 @@
      */
     SpatialRule lookupRule(GHPoint point);
 
-    /**
-     * Add a rule to the lookup.
-     */
-    void addRule(SpatialRule rule);
-
     /**
      * This method returns an identification number from 0 to size (exclusive) for the specified rule.
-     * The id is fix for a given set of SpatialRules. When the set of rules is modified, the id might change.
+     * The id is fix for a given set of SpatialRules.
      */
     int getSpatialId(SpatialRule rule);
 
     /**
-     * Returns the outer bounds of the spatial lookup.
+     * @return the number of rules added to this lookup.
      */
-    BBox getBounds();
+    int size();
 
     /**
-     * @return the number of rules added to this lookup.
+     * @return the bounds of the SpatialRuleLookup
      */
-    int size();
+    BBox getBounds();
+
+    SpatialRuleLookup EMPTY = new SpatialRuleLookup() {
+        @Override
+        public SpatialRule lookupRule(double lat, double lon) {
+            return SpatialRule.EMPTY;
+        }
+
+        @Override
+        public SpatialRule lookupRule(GHPoint point) {
+            return SpatialRule.EMPTY;
+        }
+
+        @Override
+        public int getSpatialId(SpatialRule rule) {
+            return 0;
+        }
+
+        @Override
+        public int size() {
+            return 1;
+        }
+
+        @Override
+        public BBox getBounds() {
+            return new BBox(-180, 180, -90, 90);
+        }
+    };
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
index 398a70bafb..c43771be9b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
@@ -28,7 +28,7 @@
  *
  * @author Robin Boldt
  */
-class SpatialRuleLookupArray implements SpatialRuleLookup {
+public class SpatialRuleLookupArray implements SpatialRuleLookup {
 
     // resolution in full decimal degrees
     private final double resolution;
@@ -44,19 +44,23 @@
     private final List<SpatialRule> singleRules = new ArrayList<>();
 
     /**
-     * @param bounds     the outer bounds for the Lookup
+     * @param spatialRules     the spatial rules
      * @param resolution of the array in decimal degrees, see: https://en.wikipedia.org/wiki/Decimal_degrees
      *                   The downside of using decimal degrees is that this is not fixed to a certain m range as
      * @param exact      if exact it will also perform a polygon contains for border tiles, might fail for small holes
      *                   in the Polygon that are not represented in the tile array.
+     * @param bounds create the SpatialRuleLookup for the given BBox
      */
-    SpatialRuleLookupArray(BBox bounds, double resolution, boolean exact) {
-        if (bounds == null)
-            throw new IllegalArgumentException("BBox cannot be null");
+    public SpatialRuleLookupArray(List<SpatialRule> spatialRules, double resolution, boolean exact, BBox bounds) {
+
+        if(!bounds.isValid())
+            throw new IllegalStateException("Bounds are not valid: "+bounds);
+
+        this.bounds = bounds;
+
         if (resolution < 1e-100)
             throw new IllegalArgumentException("resolution cannot be that high " + resolution);
 
-        this.bounds = bounds;
         this.resolution = resolution;
         this.checkDiff = (resolution / 2) - (resolution / 10);
         this.exact = exact;
@@ -78,6 +82,10 @@ public SpatialRuleContainer addRules(Collection<SpatialRule> rules) {
                 throw new IllegalArgumentException("Cannot add to empty rule container");
             }
         });
+
+        for (SpatialRule spatialRule : spatialRules) {
+            addRuleInternal(spatialRule);
+        }
     }
 
     private int getNumberOfYGrids() {
@@ -115,7 +123,7 @@ public SpatialRule lookupRule(double lat, double lon) {
         return SpatialRule.EMPTY;
     }
 
-    protected int getRuleContainerIndex(int xIndex, int yIndex) {
+    private int getRuleContainerIndex(int xIndex, int yIndex) {
         if (xIndex < 0 || xIndex >= lookupArray.length) {
             return EMPTY_RULE_INDEX;
         }
@@ -128,7 +136,7 @@ protected int getRuleContainerIndex(int xIndex, int yIndex) {
     /**
      * Might fail for small holes that do not occur in the array
      */
-    protected boolean isBorderTile(int xIndex, int yIndex, int ruleIndex) {
+    private boolean isBorderTile(int xIndex, int yIndex, int ruleIndex) {
         for (int i = -1; i < 2; i++) {
             for (int j = -1; j < 2; j++) {
                 if (i != xIndex && j != yIndex)
@@ -145,15 +153,18 @@ public SpatialRule lookupRule(GHPoint point) {
     }
 
     private int getXIndexForLon(double lon) {
+        if(lon < bounds.minLon)
+            return 0;
         return (int) Math.floor(Math.abs(lon - bounds.minLon) / resolution);
     }
 
     private int getYIndexForLat(double lat) {
+        if(lat < bounds.minLat)
+            return 0;
         return (int) Math.floor(Math.abs(lat - bounds.minLat) / resolution);
     }
 
-    @Override
-    public void addRule(SpatialRule rule) {
+    private void addRuleInternal(SpatialRule rule) {
         if (rule == null)
             throw new IllegalArgumentException("rule cannot be null");
 
@@ -201,7 +212,7 @@ private void addSingleRule(SpatialRule rule) {
         singleRules.add(rule);
     }
 
-    public SpatialRule getSpatialRule(int id) {
+    SpatialRule getSpatialRule(int id) {
         if (id < 0 || id >= ruleContainers.size())
             throw new IllegalArgumentException("SpatialRuleId " + id + " is illegal");
 
@@ -214,7 +225,7 @@ public SpatialRule getSpatialRule(int id) {
     /**
      * This method adds the container if no such rule container exists in this lookup and returns the index otherwise.
      */
-    int addRuleContainer(SpatialRuleContainer container) {
+    private int addRuleContainer(SpatialRuleContainer container) {
         int newIndex = this.ruleContainers.indexOf(container);
         if (newIndex >= 0)
             return newIndex;
@@ -261,4 +272,5 @@ public int size() {
     public BBox getBounds() {
         return bounds;
     }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
deleted file mode 100644
index 9e347a32de..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util.spatialrules;
-
-import com.graphhopper.json.geo.Geometry;
-import com.graphhopper.json.geo.JsonFeature;
-import com.graphhopper.json.geo.JsonFeatureCollection;
-import com.graphhopper.routing.util.spatialrules.countries.DefaultSpatialRule;
-import com.graphhopper.util.shapes.BBox;
-
-import java.util.*;
-
-/**
- * Creates a SpatialRuleLookup for a certain set of predefined areas.
- *
- * @author Robin Boldt
- */
-public class SpatialRuleLookupBuilder {
-
-    public interface SpatialRuleFactory {
-        /**
-         * This method creates a SpatialRule out of the provided polygons indicating the 'border'.
-         */
-        SpatialRule createSpatialRule(String id, final List<Polygon> polygons);
-    }
-
-    public static class SpatialRuleListFactory implements SpatialRuleFactory {
-        private final Map<String, SpatialRule> ruleMap;
-
-        public SpatialRuleListFactory(SpatialRule... rules) {
-            this(Arrays.asList(rules));
-        }
-
-        public SpatialRuleListFactory(List<SpatialRule> rules) {
-            ruleMap = new HashMap<>(rules.size());
-            for (SpatialRule rule : rules) {
-                ruleMap.put(rule.getId(), rule);
-            }
-        }
-
-        @Override
-        public SpatialRule createSpatialRule(String id, final List<Polygon> polygons) {
-            if (id == null)
-                throw new IllegalArgumentException("ID cannot be null to find a SpatialRule");
-
-            SpatialRule spatialRule = ruleMap.get(id);
-            if (spatialRule != null) {
-                spatialRule.setBorders(polygons);
-                return spatialRule;
-            }
-            return SpatialRule.EMPTY;
-        }
-    }
-
-    public static class SpatialRuleDefaultFactory implements SpatialRuleFactory {
-        @Override
-        public SpatialRule createSpatialRule(final String id, final List<Polygon> polygons) {
-            return new DefaultSpatialRule() {
-                @Override
-                public String getId() {
-                    return id;
-                }
-            }.setBorders(polygons);
-        }
-    }
-
-    public SpatialRuleLookup build(List<SpatialRule> rules, JsonFeatureCollection jsonFeatureCollection,
-                                   BBox bounds, double resolution, boolean exact) {
-        return build("ISO_A3", new SpatialRuleListFactory(rules), jsonFeatureCollection, bounds, resolution, exact);
-    }
-
-    /**
-     * This method connects the rules with the jsonFeatureCollection via their ISO_A3 property and the rules its
-     * getId method.
-     *
-     * @param jsonProperty the key that should be used to fetch the ID that is passed to SpatialRuleFactory#createSpatialRule
-     * @return the index or null if the specified bounds does not intersect with the calculated ones from the rules.
-     */
-    public SpatialRuleLookup build(String jsonProperty, SpatialRuleFactory ruleFactory, JsonFeatureCollection jsonFeatureCollection,
-                                   BBox bounds, double resolution, boolean exact) {
-
-        // TODO filter out polyons that don't intersect with the given BBox, will be implicitly done later anyway
-        BBox polygonBounds = BBox.createInverse(false);
-        List<SpatialRule> rules = new ArrayList<>();
-        Set<String> ids = new HashSet<>();
-        int unknownCounter = 0;
-        for (JsonFeature jsonFeature : jsonFeatureCollection.getFeatures()) {
-            Geometry geometry = jsonFeature.getGeometry();
-            if (!geometry.isPolygon())
-                continue;
-
-            List<Polygon> borders = geometry.asPolygon().getPolygons();
-            String id = (String) jsonFeature.getProperty(jsonProperty);
-            if (id == null || id.isEmpty()) {
-                id = "_unknown_id_" + unknownCounter;
-                unknownCounter++;
-            }
-
-            if (ids.contains(id))
-                throw new RuntimeException("The id " + id + " was already used. Either leave the json property '" + jsonProperty + "' empty or use an unique id.");
-
-            ids.add(id);
-            SpatialRule spatialRule = ruleFactory.createSpatialRule(id, borders);
-            if (spatialRule == SpatialRule.EMPTY)
-                continue;
-
-            rules.add(spatialRule);
-
-            for (Polygon polygon : borders) {
-                polygonBounds.update(polygon.getMinLat(), polygon.getMinLon());
-                polygonBounds.update(polygon.getMaxLat(), polygon.getMaxLon());
-            }
-        }
-
-        if (rules.isEmpty())
-            return null;
-
-        if (!polygonBounds.isValid()) {
-            throw new IllegalStateException("No associated polygons found in JsonFeatureCollection for rules " + rules);
-        }
-
-        // Only create a SpatialRuleLookup if there are rules defined in the given bounds
-        BBox calculatedBounds = polygonBounds.calculateIntersection(bounds);
-        if (calculatedBounds == null)
-            return null;
-
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(calculatedBounds, resolution, exact);
-        for (SpatialRule spatialRule : rules) {
-            spatialRuleLookup.addRule(spatialRule);
-        }
-        return spatialRuleLookup;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java
index 709a16af24..3af5b87f03 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing.util.spatialrules.countries;
 
 import com.graphhopper.routing.util.spatialrules.AccessValue;
+import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
 import com.graphhopper.routing.util.spatialrules.TransportationMode;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java
index 8a9b344b90..210ab08706 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing.util.spatialrules.countries;
 
 import com.graphhopper.routing.util.spatialrules.AccessValue;
+import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
 import com.graphhopper.routing.util.spatialrules.TransportationMode;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index a4e4523cc7..6919569073 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -122,7 +122,7 @@ public BBox calculateIntersection(BBox bBox) {
             return null;
 
         double minLon = Math.max(this.minLon, bBox.minLon);
-        double maxLon = Math.min(this.maxLat, bBox.maxLat);
+        double maxLon = Math.min(this.maxLon, bBox.maxLon);
         double minLat = Math.max(this.minLat, bBox.minLat);
         double maxLat = Math.min(this.maxLat, bBox.maxLat);
 
@@ -308,4 +308,23 @@ public static BBox parseTwoPoints(String objectAsString) {
 
         return new BBox(minLon, maxLon, minLat, maxLat);
     }
+
+    /**
+     * This method creates a BBox out of a string in format lon1,lon2,lat1,lat2
+     */
+    public static BBox parseBBoxString(String objectAsString) {
+        String[] splittedObject = objectAsString.split(",");
+
+        if (splittedObject.length != 4)
+            throw new IllegalArgumentException("BBox should have 4 parts but was " + objectAsString);
+
+        double minLon = Double.parseDouble(splittedObject[0]);
+        double maxLon = Double.parseDouble(splittedObject[1]);
+
+        double minLat = Double.parseDouble(splittedObject[2]);
+        double maxLat = Double.parseDouble(splittedObject[3]);
+
+        return new BBox(minLon, maxLon, minLat, maxLat);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
index 451b0182cf..f0cbca58db 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
@@ -19,9 +19,9 @@
 
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
 import com.graphhopper.routing.util.spatialrules.SpatialRule;
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
-import com.graphhopper.routing.util.spatialrules.countries.DefaultSpatialRule;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
@@ -206,23 +206,19 @@ public SpatialRule lookupRule(GHPoint point) {
                 return lookupRule(point.lat, point.lon);
             }
 
-            @Override
-            public void addRule(SpatialRule rule) {
-            }
-
             @Override
             public int getSpatialId(SpatialRule rule) {
                 throw new IllegalStateException();
             }
 
             @Override
-            public BBox getBounds() {
-                throw new IllegalStateException();
+            public int size() {
+                return 2;
             }
 
             @Override
-            public int size() {
-                return 2;
+            public BBox getBounds() {
+                return new BBox(-180,180,-90,90);
             }
         };
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
index 66032dba84..2db0b2f654 100644
--- a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
@@ -2,13 +2,10 @@
 
 import java.util.*;
 
-import com.graphhopper.json.geo.GeoJsonPolygon;
-import com.graphhopper.json.geo.Geometry;
-import com.graphhopper.json.geo.JsonFeature;
-import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
-import com.graphhopper.routing.util.spatialrules.*;
 import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
+import com.graphhopper.util.PMap;
+import com.graphhopper.routing.util.spatialrules.*;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
@@ -327,20 +324,46 @@ public void stringToTonsException() {
 
     @Test
     public void testSpatialId() {
-        List<SpatialRule> rules = Collections.<SpatialRule>singletonList(new GermanySpatialRule());
-        final BBox bbox = new BBox(0, 1, 0, 1);
-        JsonFeatureCollection jsonFeatures = new JsonFeatureCollection() {
+        final GermanySpatialRule germany = new GermanySpatialRule();
+        germany.setBorders(Collections.singletonList(new Polygon(new double[]{0, 0, 1, 1}, new double[]{0, 1, 1, 0})));
+
+        SpatialRuleLookup index = new SpatialRuleLookup() {
+            @Override
+            public SpatialRule lookupRule(double lat, double lon) {
+                for (Polygon polygon : germany.getBorders()) {
+                    if (polygon.contains(lat, lon)) {
+                        return germany;
+                    }
+                }
+                return SpatialRule.EMPTY;
+            }
+
+            @Override
+            public SpatialRule lookupRule(GHPoint point) {
+                return lookupRule(point.lat, point.lon);
+            }
+
+            @Override
+            public int getSpatialId(SpatialRule rule) {
+                if (germany.equals(rule)) {
+                    return 1;
+                } else {
+                    return 0;
+                }
+            }
+
             @Override
-            public List<JsonFeature> getFeatures() {
-                Geometry geometry = new GeoJsonPolygon().addPolygon(new Polygon(new double[]{0, 0, 1, 1}, new double[]{0, 1, 1, 0}));
-                Map<String, Object> properties = new HashMap<>();
-                properties.put("ISO_A3", "DEU");
-                return Collections.singletonList(new JsonFeature("x", "Polygon", bbox, geometry, properties));
+            public int size() {
+                return 2;
+            }
+
+            @Override
+            public BBox getBounds() {
+                return new BBox(-180, 180, -90, 90);
             }
         };
 
-        SpatialRuleLookup index = new SpatialRuleLookupBuilder().build(rules, jsonFeatures, bbox, 1, false);
-        DataFlagEncoder encoder = new DataFlagEncoder(new PMap().put("spatial_rules", index.size()));
+        DataFlagEncoder encoder = new DataFlagEncoder(new PMap());
         encoder.setSpatialRuleLookup(index);
         EncodingManager em = new EncodingManager(encoder);
 
@@ -385,4 +408,5 @@ public void testSpatialId() {
         assertEquals(5, encoder.getMaxspeed(e3, -1, false), .1);
         assertEquals(-1, encoder.getMaxspeed(e4, -1, false), .1);
     }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
index 97fee8c55e..86fcb38564 100644
--- a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
@@ -1,10 +1,12 @@
 package com.graphhopper.routing.util.spatialrules;
 
-import com.graphhopper.routing.util.spatialrules.countries.AustriaSpatialRule;
-import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
 import com.graphhopper.util.shapes.BBox;
+import org.junit.Assert;
 import org.junit.Test;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -15,14 +17,26 @@
 
     @Test
     public void testSpatialLookup() {
-        SpatialRuleLookupArray lookup = new SpatialRuleLookupArray(new BBox(1, 2, 1, 2), 1, false);
-        SpatialRule germanyRule = new GermanySpatialRule().addBorder(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}));
-        lookup.addRule(germanyRule);
-        SpatialRule austriaRule = new AustriaSpatialRule().addBorder(new Polygon(new double[]{5, 5, 6, 6}, new double[]{5, 6, 6, 5}));
-        lookup.addRule(austriaRule);
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        SpatialRule germany = new DefaultSpatialRule() {
+            @Override
+            public String getId() {
+                return "DEU";
+            }
+        }.addBorder(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}));
+        spatialRules.add(germany);
+        SpatialRule austria = new DefaultSpatialRule() {
+            @Override
+            public String getId() {
+                return "AUT";
+            }
+        }.addBorder(new Polygon(new double[]{5, 5, 6, 6}, new double[]{5, 6, 6, 5}));
+        spatialRules.add(austria);
+
+        SpatialRuleLookupArray lookup = new SpatialRuleLookupArray(spatialRules, 1, false, new BBox(1, 2, 1, 2));
 
         SpatialRule rule = lookup.lookupRule(1.5, 1.5);
-        assertEquals(germanyRule, rule);
+        assertEquals(germany, rule);
         assertEquals("DEU", rule.getId());
         int id = lookup.getSpatialId(rule);
         assertTrue(id > 0);
@@ -31,23 +45,25 @@ public void testSpatialLookup() {
 
     @Test
     public void testSmallScenario() {
-        BBox bounds = new BBox(1, 4, 1, 4);
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(bounds, 1, false);
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}), "1"));
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 3.6, 3.6}, new double[]{3, 4, 4, 3}), "2"));
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}), "1"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 3.6, 3.6}, new double[]{3, 4, 4, 3}), "2"));
+
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, false, new BBox(1, 4, 1, 4));
+
+        Assert.assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
         assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 3.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        // Not in the second Polygon anymore, but due to the resolution of 1, this should be still match the rule
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(3.9, 3.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
         assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(2.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
     }
 
     @Test
     public void testExact() {
-        BBox bounds = new BBox(1, 4, 1, 4);
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(bounds, 1, true);
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}), "1"));
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 3.6, 3.6}, new double[]{3, 4, 4, 3}), "2"));
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 2, 2}, new double[]{1, 2, 2, 1}), "1"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 3.6, 3.6}, new double[]{3, 4, 4, 3}), "2"));
+
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, true, new BBox(1, 4, 1, 4));
+
         assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
         assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 3.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
         // Not in the second Polygon anymore
@@ -57,12 +73,20 @@ public void testExact() {
 
     @Test
     public void testExactCountry() {
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(new BBox(-180, 180, -90, 90), .1, true);
+        List<SpatialRule> spatialRules = new ArrayList<>();
 
         // Taken from here: https://github.com/johan/world.geo.json/blob/master/countries/DEU.geo.json
         String germanPolygonJson = "[9.921906,54.983104],[9.93958,54.596642],[10.950112,54.363607],[10.939467,54.008693],[11.956252,54.196486],[12.51844,54.470371],[13.647467,54.075511],[14.119686,53.757029],[14.353315,53.248171],[14.074521,52.981263],[14.4376,52.62485],[14.685026,52.089947],[14.607098,51.745188],[15.016996,51.106674],[14.570718,51.002339],[14.307013,51.117268],[14.056228,50.926918],[13.338132,50.733234],[12.966837,50.484076],[12.240111,50.266338],[12.415191,49.969121],[12.521024,49.547415],[13.031329,49.307068],[13.595946,48.877172],[13.243357,48.416115],[12.884103,48.289146],[13.025851,47.637584],[12.932627,47.467646],[12.62076,47.672388],[12.141357,47.703083],[11.426414,47.523766],[10.544504,47.566399],[10.402084,47.302488],[9.896068,47.580197],[9.594226,47.525058],[8.522612,47.830828],[8.317301,47.61358],[7.466759,47.620582],[7.593676,48.333019],[8.099279,49.017784],[6.65823,49.201958],[6.18632,49.463803],[6.242751,49.902226],[6.043073,50.128052],[6.156658,50.803721],[5.988658,51.851616],[6.589397,51.852029],[6.84287,52.22844],[7.092053,53.144043],[6.90514,53.482162],[7.100425,53.693932],[7.936239,53.748296],[8.121706,53.527792],[8.800734,54.020786],[8.572118,54.395646],[8.526229,54.962744],[9.282049,54.830865],[9.921906,54.983104]";
         Polygon germanPolygon = parsePolygonString(germanPolygonJson);
-        spatialRuleLookup.addRule(new GermanySpatialRule().addBorder(germanPolygon));
+
+        spatialRules.add(new DefaultSpatialRule(){
+            @Override
+            public String getId() {
+                return "DEU";
+            }
+        }.addBorder(germanPolygon));
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, .1, true, new BBox(-180, 180, -90, 90));
+
 
         // Far from the border of Germany, in Germany
         assertEquals("DEU", spatialRuleLookup.lookupRule(48.777106, 9.180769).getId());
@@ -70,9 +94,9 @@ public void testExactCountry() {
         assertEquals("DEU", spatialRuleLookup.lookupRule(50.636710, 12.514561).getId());
 
         // Far from the border of Germany, not in Germany
-        assertEquals("", spatialRuleLookup.lookupRule(48.029533, 7.250122).getId());
-        assertEquals("", spatialRuleLookup.lookupRule(51.694467, 15.209218).getId());
-        assertEquals("", spatialRuleLookup.lookupRule(47.283669, 11.167381).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(48.029533, 7.250122).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(51.694467, 15.209218).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(47.283669, 11.167381).getId());
 
         // Close to the border of Germany, in Germany - Whereas the borders are defined by the GeoJson above and do not strictly follow the acutal border
         assertEquals("DEU", spatialRuleLookup.lookupRule(50.017714, 12.356129).getId());
@@ -82,23 +106,32 @@ public void testExactCountry() {
         assertEquals("DEU", spatialRuleLookup.lookupRule(47.557166, 9.738343).getId());
 
         // Close to the border of Germany, not in Germany
-        assertEquals("", spatialRuleLookup.lookupRule(50.025342, 12.386262).getId());
-        assertEquals("", spatialRuleLookup.lookupRule(49.932900, 6.174023).getId());
-        assertEquals("", spatialRuleLookup.lookupRule(47.547463, 9.741948).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(50.025342, 12.386262).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(49.932900, 6.174023).getId());
+        assertEquals("SpatialRule.EMPTY", spatialRuleLookup.lookupRule(47.547463, 9.741948).getId());
     }
 
     @Test
     public void testExactAdjacentBorder() {
-        BBox bounds = new BBox(1, 4, 1, 4);
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(bounds, 1, true);
+        List<SpatialRule> spatialRules = new ArrayList<>();
         // Two rules that divide the tile in half
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1, 1, 1.5, 1.5}, new double[]{1, 2, 2, 1}), "top"));
-        spatialRuleLookup.addRule(getSpatialRule(new Polygon(new double[]{1.5, 1.5, 2, 2}, new double[]{1, 2, 2, 1}), "bottom"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 1.5, 1.5}, new double[]{1, 2, 2, 1}), "top"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1.5, 1.5, 2, 2}, new double[]{1, 2, 2, 1}), "bottom"));
+
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, true, new BBox(1, 4, 1, 4));
 
         assertEquals("top", spatialRuleLookup.lookupRule(1.4, 1.5).getId());
         assertEquals("bottom", spatialRuleLookup.lookupRule(1.6, 1.5).getId());
     }
 
+    @Test
+    public void testSmallBoundsBigPolygon() {
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{-100, -100, 100, 100}, new double[]{-100, 100, 100, -100}), "big"));
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, true, new BBox(1, 2, 1, 2));
+        assertEquals("big", spatialRuleLookup.lookupRule(1.5, 1.5).getId());
+    }
+
     private Polygon parsePolygonString(String polygonString) {
         String[] germanPolygonArr = polygonString.split("\\],\\[");
         double[] lats = new double[germanPolygonArr.length];
@@ -116,7 +149,7 @@ private Polygon parsePolygonString(String polygonString) {
     }
 
     private SpatialRule getSpatialRule(Polygon p, final String name) {
-        SpatialRule rule = new AbstractSpatialRule() {
+        AbstractSpatialRule rule = new AbstractSpatialRule() {
             @Override
             public double getMaxSpeed(String highwayTag, double _default) {
                 return _default;
diff --git a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
index a316f68243..22462771ed 100644
--- a/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
+++ b/core/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
@@ -97,6 +97,12 @@ public void testCalculateIntersection() {
         //No intersection
         b2 = new BBox(100, 200, 100, 200);
         assertNull(b1.calculateIntersection(b2));
+
+        //Real Example
+        b1 = new BBox(8.8591,9.9111,48.3145,48.8518);
+        b2 = new BBox(5.8524,17.1483,46.3786,55.0653);
+
+        assertEquals(b1, b1.calculateIntersection(b2));
     }
 
     @Test
@@ -146,4 +152,9 @@ public void testParseTwoPoints() {
         // stable parsing, i.e. if first point is in north or south it does not matter:
         assertEquals(new BBox(2, 4, 1, 3), BBox.parseTwoPoints("3,2,1,4"));
     }
+
+    @Test
+    public void testParseBBoxString() {
+        assertEquals(new BBox(2, 4, 1, 3), BBox.parseBBoxString("2,4,1,3"));
+    }
 }
diff --git a/docs/core/spatial_rules.md b/docs/core/spatial_rules.md
new file mode 100644
index 0000000000..8616d4d16e
--- /dev/null
+++ b/docs/core/spatial_rules.md
@@ -0,0 +1,22 @@
+# Spatial Rules
+
+Spatial rules allow you to create rules for certain areas. One famous example is that `highway=track` should be accessible 
+in Austria, whereas it should be marked as `access=destination`. Other examples are different max speeds for different
+countries. More information on different road rules can be found in the OSM wiki. The article about different 
+[accessibilities](https://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Access-Restrictions) and about different 
+[speeds](https://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed#Motorcar).
+
+## Enabling Rules
+
+I you have a working GraphHopper setup it is easy to enable Spatial Rules, **but they only work the DataFlagEncoder**.
+We provide a set of approximate country borders, within the GraphHopper repository. If you need exact borders you can
+get the exact borders from [here](https://github.com/datasets/geo-countries). Go to your `config.properties` and
+uncommend the line: `spatial_rules.location` and point it to where your rules are. You need to re-import your graph after 
+that.
+
+## Creating Rules
+
+Writing your own rules is simple. If you write a rule for a country that is not provided in GraphHopper yet, we'd love
+if you would contribute your rules. You can have a look at the [GermanySpatialRule](https://github.com/graphhopper/graphhopper/blob/master/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java).
+Create something similar for your contry. After that you have to extend the [CountriesSpatialRuleFactory](https://github.com/graphhopper/graphhopper/blob/master/web/src/main/java/com/graphhopper/spatialrules/CountriesSpatialRuleFactory.java) 
+to match your country code. 
\ No newline at end of file
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
index d2059e767b..bc2c3db0d2 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
@@ -20,6 +20,8 @@
 import com.google.inject.AbstractModule;
 import com.google.inject.Provides;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.spatialrules.SpatialRuleLookupBuilder;
+import com.graphhopper.spatialrules.CountriesSpatialRuleFactory;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.json.GHJson;
 import com.graphhopper.json.GHJsonBuilder;
@@ -29,13 +31,16 @@
 import com.graphhopper.routing.lm.PrepareLandmarks;
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.FlagEncoderFactory;
+import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
+import com.graphhopper.routing.util.spatialrules.Polygon;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
 import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
-import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupBuilder;
-import com.graphhopper.routing.util.spatialrules.countries.AustriaSpatialRule;
-import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.PMap;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.TranslationMap;
 import com.graphhopper.util.shapes.BBox;
@@ -48,7 +53,7 @@
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Reader;
-import java.util.Arrays;
+import java.util.List;
 
 public class GraphHopperModule extends AbstractModule {
     protected final CmdArgs args;
@@ -79,11 +84,22 @@ protected void loadOrPrepareLM() {
                     Reader reader = location.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream()) : new FileReader(location);
                     JsonFeatureCollection jsonFeatureCollection = new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class);
                     if (!jsonFeatureCollection.getFeatures().isEmpty()) {
-                        SpatialRuleLookup ruleLookup = new SpatialRuleLookupBuilder().build("country",
-                                new SpatialRuleLookupBuilder.SpatialRuleDefaultFactory(), jsonFeatureCollection,
-                                getGraphHopperStorage().getBounds(), 0.1, true);
+                        SpatialRuleLookup ruleLookup = SpatialRuleLookupBuilder.buildIndex(jsonFeatureCollection, "country", new SpatialRuleLookupBuilder.SpatialRuleFactory() {
+                            @Override
+                            public SpatialRule createSpatialRule(String id, List<Polygon> polygons) {
+                                return new DefaultSpatialRule() {
+                                    @Override
+                                    public String getId() {
+                                        return id;
+                                    }
+                                };
+                            }
+                        });
                         for (PrepareLandmarks prep : getLMFactoryDecorator().getPreparations()) {
-                            prep.setSpatialRuleLookup(ruleLookup);
+                            // the ruleLookup splits certain areas from each other but avoids making this a permanent change so that other algorithms still can route through these regions.
+                            if (ruleLookup != null && ruleLookup.size() > 0) {
+                                prep.setSpatialRuleLookup(ruleLookup);
+                            }
                         }
                     }
                 } catch (IOException ex) {
@@ -92,32 +108,35 @@ protected void loadOrPrepareLM() {
 
                 super.loadOrPrepareLM();
             }
-        }.forServer().init(args);
+        }.forServer();
+
+        String spatialRuleLocation = args.get("spatial_rules.location", "");
+        if (!spatialRuleLocation.isEmpty()) {
+            try {
+                final BBox maxBounds = BBox.parseBBoxString(args.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
+                final FileReader reader = new FileReader(spatialRuleLocation);
+                final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), maxBounds);
+                logger.info("Set spatial rule lookup with " + index.size() + " rules");
+                final FlagEncoderFactory oldFEF = graphHopper.getFlagEncoderFactory();
+                graphHopper.setFlagEncoderFactory(new FlagEncoderFactory() {
+                    @Override
+                    public FlagEncoder createFlagEncoder(String name, PMap configuration) {
+                        if (name.equals(GENERIC)) {
+                            return new DataFlagEncoder(configuration).setSpatialRuleLookup(index);
+                        }
 
-        String location = args.get("spatial_rules.location", "");
-        if (!location.isEmpty()) {
-            if (!graphHopper.getEncodingManager().supports(("generic"))) {
-                logger.warn("spatial_rules.location was specified but 'generic' encoder is missing to utilize the index");
-            } else
-                try {
-                    SpatialRuleLookup spatialRuleLookup = buildSpatialRuleLookup(new FileReader(location), graphHopper.getGraphHopperStorage().getBounds());
-                    logger.info("Set spatial rule lookup with " + spatialRuleLookup.size() + " rules");
-                    ((DataFlagEncoder) graphHopper.getEncodingManager().getEncoder("generic")).setSpatialRuleLookup(spatialRuleLookup);
-                } catch (IOException ex) {
-                    throw new RuntimeException(ex);
-                }
+                        return oldFEF.createFlagEncoder(name, configuration);
+                    }
+                });
+            } catch (IOException ex) {
+                throw new RuntimeException(ex);
+            }
         }
 
+        graphHopper.init(args);
         return graphHopper;
     }
 
-    static SpatialRuleLookup buildSpatialRuleLookup(Reader reader, BBox graphBBox) {
-        GHJson ghJson = new GHJsonBuilder().create();
-        JsonFeatureCollection jsonFeatureCollection = ghJson.fromJson(reader, JsonFeatureCollection.class);
-        return new SpatialRuleLookupBuilder().build(Arrays.asList(new GermanySpatialRule(), new AustriaSpatialRule()),
-                jsonFeatureCollection, graphBBox, 1, true);
-    }
-
     @Provides
     @Singleton
     TranslationMap getTranslationMap(GraphHopper graphHopper) {
diff --git a/web/src/main/java/com/graphhopper/spatialrules/CountriesSpatialRuleFactory.java b/web/src/main/java/com/graphhopper/spatialrules/CountriesSpatialRuleFactory.java
new file mode 100644
index 0000000000..9c34934934
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/spatialrules/CountriesSpatialRuleFactory.java
@@ -0,0 +1,26 @@
+package com.graphhopper.spatialrules;
+
+import com.graphhopper.routing.util.spatialrules.Polygon;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
+import com.graphhopper.routing.util.spatialrules.countries.AustriaSpatialRule;
+import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
+import com.graphhopper.spatialrules.SpatialRuleLookupBuilder;
+
+import java.util.List;
+
+public class CountriesSpatialRuleFactory implements SpatialRuleLookupBuilder.SpatialRuleFactory {
+    @Override
+    public SpatialRule createSpatialRule(String id, List<Polygon> polygons) {
+        switch (id) {
+            case "AUT":
+                AustriaSpatialRule austriaSpatialRule = new AustriaSpatialRule();
+                austriaSpatialRule.setBorders(polygons);
+                return austriaSpatialRule;
+            case "DEU":
+                GermanySpatialRule germanySpatialRule = new GermanySpatialRule();
+                germanySpatialRule.setBorders(polygons);
+                return germanySpatialRule;
+        }
+        return SpatialRule.EMPTY;
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java b/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
new file mode 100644
index 0000000000..cccb0a3d5a
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
@@ -0,0 +1,77 @@
+package com.graphhopper.spatialrules;
+
+import com.graphhopper.json.geo.JsonFeature;
+import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.routing.util.spatialrules.Polygon;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
+import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
+import com.graphhopper.routing.util.spatialrules.SpatialRuleLookupArray;
+import com.graphhopper.util.shapes.BBox;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.*;
+
+public class SpatialRuleLookupBuilder {
+
+    public interface SpatialRuleFactory {
+        SpatialRule createSpatialRule(String id, final List<Polygon> polygons);
+    }
+
+    private static final Logger logger = LoggerFactory.getLogger(SpatialRuleLookupBuilder.class);
+
+    /**
+     * Builds a SpatialRuleLookup by passing the provided JSON features into the provided
+     * SpatialRuleFactory and collecting all the SpatialRule instances that it returns,
+     * ignoring when it returns SpatialRule.EMPTY.
+     *
+     * See {@link SpatialRuleLookup} and {@link SpatialRule}.
+     *
+     * @param jsonFeatureCollection a feature collection
+     * @param jsonIdField the name of a property in that feature collection which serves as an id
+     * @param spatialRuleFactory a factory which is called with all the (id, geometry) pairs.
+     *                           It should provide a SpatialRule for each id it knows about,
+     *                           and SpatialRule.EMPTY otherwise.
+     * @param maxBBox limit the maximum BBox of the SpatialRuleLookup to the given BBox
+     * @return the fully constructed SpatialRuleLookup.
+     */
+    public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureCollection, String jsonIdField, SpatialRuleFactory spatialRuleFactory, BBox maxBBox) {
+        BBox polygonBounds = BBox.createInverse(false);
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        for (JsonFeature jsonFeature : jsonFeatureCollection.getFeatures()) {
+            String id = (String) jsonFeature.getProperty(jsonIdField);
+            List<Polygon> borders = jsonFeature.getGeometry().asPolygon().getPolygons();
+            SpatialRule spatialRule = spatialRuleFactory.createSpatialRule(id, borders);
+            if (spatialRule != SpatialRule.EMPTY) {
+                spatialRules.add(spatialRule);
+                for (Polygon polygon : spatialRule.getBorders()) {
+                    polygonBounds.update(polygon.getMinLat(), polygon.getMinLon());
+                    polygonBounds.update(polygon.getMaxLat(), polygon.getMaxLon());
+                }
+            }
+        }
+
+        if (!polygonBounds.isValid()) {
+            return SpatialRuleLookup.EMPTY;
+        }
+
+        BBox calculatedBounds = polygonBounds.calculateIntersection(maxBBox);
+        if (calculatedBounds == null)
+            return SpatialRuleLookup.EMPTY;
+
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 0.1, true, calculatedBounds);
+
+        logger.info("Created the SpatialRuleLookup with the following rules: " + Arrays.toString(spatialRules.toArray()));
+
+        return spatialRuleLookup;
+    }
+
+    /**
+     * Wrapper Method for {@link SpatialRuleLookupBuilder#buildIndex(JsonFeatureCollection, String, SpatialRuleFactory, BBox)}.
+     * This method simply passes a world-wide BBox, this won't limit the SpatialRuleLookup.
+     */
+    public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureCollection, String jsonIdField, SpatialRuleFactory spatialRuleFactory) {
+        return buildIndex(jsonFeatureCollection, jsonIdField, spatialRuleFactory, new BBox(-180, 180, -90, 90));
+    }
+
+}
diff --git a/web/src/main/resources/com/graphhopper/http/README.MD b/web/src/main/resources/com/graphhopper/spatialrules/README.MD
similarity index 100%
rename from web/src/main/resources/com/graphhopper/http/README.MD
rename to web/src/main/resources/com/graphhopper/spatialrules/README.MD
diff --git a/web/src/main/resources/com/graphhopper/http/countries.geo.json b/web/src/main/resources/com/graphhopper/spatialrules/countries.geo.json
similarity index 100%
rename from web/src/main/resources/com/graphhopper/http/countries.geo.json
rename to web/src/main/resources/com/graphhopper/spatialrules/countries.geo.json
diff --git a/web/src/test/java/com/graphhopper/http/SpatialRuleLookupBuilderTest.java b/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
similarity index 65%
rename from web/src/test/java/com/graphhopper/http/SpatialRuleLookupBuilderTest.java
rename to web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
index f55b3a6eb1..78bbd010ba 100644
--- a/web/src/test/java/com/graphhopper/http/SpatialRuleLookupBuilderTest.java
+++ b/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
@@ -15,18 +15,23 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.http;
+package com.graphhopper.spatialrules;
 
-import com.graphhopper.routing.util.spatialrules.*;
+import com.graphhopper.json.GHJsonBuilder;
+import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.routing.util.spatialrules.AccessValue;
+import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
+import com.graphhopper.routing.util.spatialrules.TransportationMode;
 import com.graphhopper.util.shapes.BBox;
 import org.junit.Test;
 
-import java.io.*;
+import java.io.InputStreamReader;
+import java.io.Reader;
 
 import static junit.framework.TestCase.assertFalse;
+import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 
 /**
  * @author Robin Boldt
@@ -35,8 +40,8 @@
 
     @Test
     public void testIndex() {
-        Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = GraphHopperModule.buildSpatialRuleLookup(reader, new BBox(-180, 180, -90, 90));
+        Reader reader = new InputStreamReader(CountriesSpatialRuleFactory.class.getResourceAsStream("countries.geo.json"));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory());
 
         // Berlin
         assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(52.5243700, 13.4105300).getAccessValue("track", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
@@ -55,7 +60,7 @@ public void testIndex() {
     @Test
     public void testBounds() {
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = GraphHopperModule.buildSpatialRuleLookup(reader, new BBox(-180, 180, -90, 90));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, 180, -90, 90));
         BBox almostWorldWide = new BBox(-179, 179, -89, 89);
 
         // Might fail if a polygon is defined outside the above coordinates
@@ -64,19 +69,21 @@ public void testBounds() {
 
     @Test
     public void testIntersection() {
-        /*
-            We are creating a BBox smaller than Germany. We have the German Spatial rule activated by default.
-            So the BBox should not contain a Point lying somewhere close in Germany.
-         */
+                /*
+             We are creating a BBox smaller than Germany. We have the German Spatial rule activated by default.
+             So the BBox should not contain a Point lying somewhere close in Germany.
+          */
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = GraphHopperModule.buildSpatialRuleLookup(reader, new BBox(9, 10, 51, 52));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(9, 10, 51, 52));
         assertFalse("BBox seems to be incorrectly contracted", spatialRuleLookup.getBounds().contains(49.9, 8.9));
     }
 
     @Test
     public void testNoIntersection() {
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = GraphHopperModule.buildSpatialRuleLookup(reader, new BBox(-180, -179, -90, -89));
-        assertNull(spatialRuleLookup);
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonBuilder().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, -179, -90, -89));
+        assertEquals(SpatialRuleLookup.EMPTY, spatialRuleLookup);
     }
+
+
 }
