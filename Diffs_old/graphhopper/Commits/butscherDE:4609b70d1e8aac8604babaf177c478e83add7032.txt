diff --git a/api/src/main/java/com/graphhopper/GHRequest.java b/api/src/main/java/com/graphhopper/GHRequest.java
index d618c8cafd..80a9c54c46 100644
--- a/api/src/main/java/com/graphhopper/GHRequest.java
+++ b/api/src/main/java/com/graphhopper/GHRequest.java
@@ -97,6 +97,7 @@ public GHRequest(GHPoint startPlace, GHPoint endPlace, double startHeading, doub
         favoredHeadings.add(startHeading);
         validateAzimuthValue(endHeading);
         favoredHeadings.add(endHeading);
+        this.polygon = new Polygon(new double[] {}, new double[] {});
     }
 
     public GHRequest(GHPoint startPlace, GHPoint endPlace) {
@@ -121,6 +122,7 @@ public GHRequest(List<GHPoint> points, List<Double> favoredHeadings) {
         }
         this.points = points;
         this.favoredHeadings = favoredHeadings;
+        this.polygon = new Polygon(new double[] {}, new double[] {});
     }
 
     /**
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
index 3c0fac3d04..de28c78e29 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
@@ -44,9 +44,7 @@ public Polygon(double[] lat, double[] lon, double growFactor) {
         if (lat.length != lon.length) {
             throw new IllegalArgumentException("Points must be of equal length but was " + lat.length + " vs. " + lon.length);
         }
-        if (lat.length == 0) {
-            throw new IllegalArgumentException("Points must not be empty");
-        }
+
         this.lat = lat;
         this.lon = lon;
 
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index fa12469ddd..f89f347258 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -55,6 +55,7 @@
 import com.graphhopper.util.shapes.Polygon;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
 import java.io.File;
 import java.io.IOException;
@@ -791,7 +792,7 @@ public boolean load(String graphHopperFolder) {
 
         GHLock lock = null;
         try {
-            // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
+            // create locks only if writes are allowed, if they are not allowed a lock cannot be created
             // (e.g. on a read only filesystem locks would fail)
             if (ghStorage.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
                 lockFactory.setLockDir(new File(ghLocation));
@@ -1034,9 +1035,7 @@ public GHResponse route(GHRequest request) {
         // TODO Maybe we should think about a isRequestValid method that checks all that stuff that we could do to fail fast
         // For example see #734
         checkIfPointsAreInBounds(points);
-        if (polygon != null) {
-            checkIfPointsAreInBounds(polygon.getCoordinatesAsGHPoints());
-        }
+        checkIfPointsAreInBounds(polygon.getCoordinatesAsGHPoints());
 
         RoutingTemplate routingTemplate = buildRoutingTemplate(request, ghRsp, algoStr);
 
@@ -1075,7 +1074,7 @@ public GHResponse route(GHRequest request) {
             AlgorithmOptions algoOpts = buildAlgorithmOptions(hints, tMode, algoStr, weighting, maxVisitedNodesForRequest);
 
             // do the actual route calculation !
-            altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
+            altPaths = routePointsAndPolygons(routingTemplate, tmpAlgoFactory, queryGraph, algoOpts);
 
             boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
             boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
@@ -1099,6 +1098,118 @@ public GHResponse route(GHRequest request) {
 
     }
 
+    private List<Path> routePointsAndPolygons(RoutingTemplate routingTemplate, RoutingAlgorithmFactory tmpAlgoFactory, QueryGraph queryGraph, AlgorithmOptions algoOpts) {
+        List<Path> altPaths;
+
+        if (routingTemplate.getGhRequest().getPolygon().size() <= 0) {
+            altPaths = routeWithoutPolygon(routingTemplate, tmpAlgoFactory, queryGraph, algoOpts);
+        } else {
+            altPaths = routeWithPolygon(routingTemplate, tmpAlgoFactory, queryGraph, algoOpts);
+        }
+        return altPaths;
+    }
+
+    private List<Path> routeWithPolygon(RoutingTemplate routingTemplate, RoutingAlgorithmFactory tmpAlgoFactory, QueryGraph queryGraph, AlgorithmOptions algoOpts) {
+        List<QueryResult> additionalPoints = this.findViaPointsToFullfillPolygonOrientedRouting(routingTemplate);
+
+        throw new NotImplementedException();
+    }
+
+    private List<QueryResult> findViaPointsToFullfillPolygonOrientedRouting(RoutingTemplate routingTemplate) {
+        List<Integer> nodesInPolygon = getNodesInPolygon(routingTemplate);
+        List<Integer> polygonEntryExitPoints = findPolygonEntryExitPoints(nodesInPolygon);
+        List<Integer> subgraphNodes = nodeUnion(nodesInPolygon, polygonEntryExitPoints);
+        List<Integer> pathSkeleton = calculatePathSkeleton(subgraphNodes);
+
+        throw new NotImplementedException();
+    }
+
+    private List<Integer> nodeUnion(List<Integer> nodesInPolygon, List<Integer> polygonEntryExitPoints) {
+        List<Integer> subgraphNodes = new ArrayList<>(nodesInPolygon.size() + polygonEntryExitPoints.size());
+        subgraphNodes.addAll(nodesInPolygon);
+        subgraphNodes.addAll(polygonEntryExitPoints);
+        return subgraphNodes;
+    }
+
+    /**
+     * According to Prof. Storandts paper Region-Aware Route Planning Definition 2.
+     *
+     * @param subGraphNodes nodes that induce a subgraph.
+     * @return A reduced set of nodes that induce the path skeleton subgraph.
+     */
+    private List<Integer> calculatePathSkeleton(final List<Integer>  subGraphNodes) {
+        throw new NotImplementedException();
+    }
+
+    private List<Integer> findPolygonEntryExitPoints(final List<Integer> nodesInPolygon) {
+        final List<Integer> entryExitPoints = new LinkedList<>();
+        final EdgeExplorer edgeExplorer = ghStorage.getBaseGraph().createEdgeExplorer();
+
+        addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(nodesInPolygon, entryExitPoints, edgeExplorer);
+
+        return entryExitPoints;
+    }
+
+    private void addAllNodesNotInPolygonButDirectlyAccessibleFromThereToEntryExitPoints(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeExplorer edgeExplorer) {
+        for (int node : nodesInPolygon) {
+            final EdgeIterator edgeIterator = edgeExplorer.setBaseNode(node);
+
+            do {
+                addToEntryExitIfNotExistentAndNotInPolygon(nodesInPolygon, entryExitPoints, edgeIterator);
+            } while (edgeIterator.next());
+        }
+    }
+
+    private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPolygon, List<Integer> entryExitPoints, EdgeIterator edgeIterator) {
+        final int adjacentNode = edgeIterator.getAdjNode();
+        if (!nodesInPolygon.contains(adjacentNode) && !entryExitPoints.contains(adjacentNode)) {
+            entryExitPoints.add(adjacentNode);
+        }
+    }
+
+    private List<Integer> filterOutNodesNotInPolygon(final List<Integer> nodes, final Polygon polygon) {
+        final List<Integer> filterResult = new LinkedList<>();
+
+        while (!nodes.isEmpty()) {
+            filterNextNode(nodes, polygon, filterResult);
+        }
+
+        return filterResult;
+    }
+
+    private void filterNextNode(List<Integer> nodes, Polygon polygon, List<Integer> filterResult) {
+        int nodeToFilter = popNode(nodes);
+        final NodeAccess nodeAccess = ghStorage.getNodeAccess();
+        final double lat = nodeAccess.getLat(nodeToFilter);
+        final double lon = nodeAccess.getLon(nodeToFilter);
+
+        if (polygon.contains(lat, lon)) {
+            filterResult.add(nodeToFilter);
+        }
+    }
+
+    private int popNode(List<Integer> nodes) {
+        final int nodeToFilter = nodes.get(0);
+        nodes.remove(0);
+        return nodeToFilter;
+    }
+
+    private List<Integer> getNodesInPolygon(RoutingTemplate routingTemplate) {
+        final Polygon polygon = routingTemplate.getGhRequest().getPolygon();
+        final NodeAccess nodeAccess = this.ghStorage.getNodeAccess();
+
+        BBox minimumPolygonBoundingBox = BBox.createMinimalBoundingBoxFromPolygon(polygon);
+        final NodesInPolygonFindingVisitor visitor =new NodesInPolygonFindingVisitor(polygon, nodeAccess);
+        this.locationIndex.query(minimumPolygonBoundingBox, visitor);
+        return visitor.getNodesInPolygon();
+    }
+
+    private List<Path> routeWithoutPolygon(RoutingTemplate routingTemplate, RoutingAlgorithmFactory tmpAlgoFactory, QueryGraph queryGraph, AlgorithmOptions algoOpts) {
+        List<Path> altPaths;
+        altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
+        return altPaths;
+    }
+
     private boolean isCHUsageGranted(boolean disableCH) {
         return chFactoryDecorator.isEnabled() && !disableCH;
     }
@@ -1497,4 +1608,27 @@ BuilderForWeightingAndQueryGraph invoke() {
             return this;
         }
     }
+
+    private class NodesInPolygonFindingVisitor extends LocationIndex.Visitor {
+        private final List<Integer> nodesInPolygon = new LinkedList<>();
+        private final Polygon polygon;
+        private final NodeAccess nodeAccess;
+
+        public NodesInPolygonFindingVisitor(final Polygon polygon, final NodeAccess nodeAccess) {
+            this.polygon = polygon;
+            this.nodeAccess = nodeAccess;
+        }
+
+        @Override
+        public void onNode(int nodeId) {
+            final double lat = nodeAccess.getLat(nodeId);
+            final double lon = nodeAccess.getLon(nodeId);
+
+            if (polygon.contains(lat, lon)) {
+                this.nodesInPolygon.add(nodeId);
+            }
+        }
+
+        public List<Integer> getNodesInPolygon() { return this.nodesInPolygon; }
+    };
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
index ddd3f66bf3..ccde7e1831 100644
--- a/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
@@ -60,7 +60,7 @@ public AlternativeRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, Locatio
 
     @Override
     public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
-        boolean withViaTurnPenalty = ghRequest.getHints().getBool(Routing.PASS_THROUGH, false);
+        boolean withViaTurnPenalty = getGhRequest().getHints().getBool(Routing.PASS_THROUGH, false);
         if (withViaTurnPenalty)
             throw new IllegalArgumentException("Alternative paths and " + PASS_THROUGH + " at the same time is currently not supported");
 
@@ -72,7 +72,7 @@ public boolean isReady(PathMerger pathMerger, Translation tr) {
         if (pathList.isEmpty())
             throw new RuntimeException("Empty paths for alternative route calculation not expected");
 
-        // if alternative route calculation was done then create the responses from single paths        
+        // if alternative route calculation was done then create the responses from single paths
         PointList wpList = getWaypoints();
         altResponse.setWaypoints(wpList);
         ghResponse.add(altResponse);
diff --git a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
index 82ad1044a2..9f9fcfbc5d 100644
--- a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
@@ -70,12 +70,12 @@ public RoundTripRoutingTemplate(GHRequest request, GHResponse ghRsp, LocationInd
 
     @Override
     public List<QueryResult> lookup(List<GHPoint> points, FlagEncoder encoder) {
-        if (points.size() != 1 || ghRequest.getPoints().size() != 1)
+        if (points.size() != 1 || getGhRequest().getPoints().size() != 1)
             throw new IllegalArgumentException("For round trip calculation exactly one point is required");
-        final double distanceInMeter = ghRequest.getHints().getDouble(RoundTrip.DISTANCE, 10000);
-        final long seed = ghRequest.getHints().getLong(RoundTrip.SEED, 0L);
-        double initialHeading = ghRequest.getFavoredHeading(0);
-        final int roundTripPointCount = Math.min(20, ghRequest.getHints().getInt(RoundTrip.POINTS, 2 + (int) (distanceInMeter / 50000)));
+        final double distanceInMeter = getGhRequest().getHints().getDouble(RoundTrip.DISTANCE, 10000);
+        final long seed = getGhRequest().getHints().getLong(RoundTrip.SEED, 0L);
+        double initialHeading = getGhRequest().getFavoredHeading(0);
+        final int roundTripPointCount = Math.min(20, getGhRequest().getHints().getInt(RoundTrip.POINTS, 2 + (int) (distanceInMeter / 50000)));
         final GHPoint start = points.get(0);
 
         TourStrategy strategy = new MultiPointTour(new Random(seed), distanceInMeter, roundTripPointCount, initialHeading);
@@ -181,4 +181,9 @@ public int getMaxRetries() {
         // with potentially retrying, including generating new route points, for now disabled
         return 1;
     }
+
+    @Override
+    public GHRequest getGhRequest() {
+        return ghRequest;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java
index a3a073fa96..709e5b629f 100644
--- a/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/RoutingTemplate.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.template;
 
+import com.graphhopper.GHRequest;
 import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.QueryGraph;
@@ -57,4 +58,6 @@
      * This method returns the maximum number of full retries of these 3 steps
      */
     int getMaxRetries();
+
+    public GHRequest getGhRequest();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
index bf6c7cdaab..93e83cb4e4 100644
--- a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
@@ -43,7 +43,7 @@
  * @author Peter Karich
  */
 public class ViaRoutingTemplate extends AbstractRoutingTemplate implements RoutingTemplate {
-    protected final GHRequest ghRequest;
+    private final GHRequest ghRequest;
     protected final GHResponse ghResponse;
     protected final PathWrapper altResponse = new PathWrapper();
     private final LocationIndex locationIndex;
@@ -64,16 +64,17 @@ public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex l
             throw new IllegalArgumentException("At least 2 points have to be specified, but was:" + points.size());
 
         EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
-        EdgeFilter strictEdgeFilter = !ghRequest.hasSnapPreventions() ? edgeFilter : new SnapPreventionEdgeFilter(edgeFilter,
-                encoder.getEnumEncodedValue(RoadClass.KEY, RoadClass.class),
-                encoder.getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class), ghRequest.getSnapPreventions());
+        EdgeFilter strictEdgeFilter = !getGhRequest().hasSnapPreventions() ? edgeFilter : new SnapPreventionEdgeFilter(edgeFilter,
+                                                                                                                       encoder.getEnumEncodedValue(RoadClass.KEY, RoadClass.class),
+                                                                                                                       encoder.getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class), getGhRequest()
+                                                                                                                               .getSnapPreventions());
         queryResults = new ArrayList<>(points.size());
         for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
             GHPoint point = points.get(placeIndex);
             QueryResult qr = null;
-            if (ghRequest.hasPointHints())
-                qr = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(strictEdgeFilter, ghRequest.getPointHints().get(placeIndex)));
-            else if (ghRequest.hasSnapPreventions())
+            if (getGhRequest().hasPointHints())
+                qr = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(strictEdgeFilter, getGhRequest().getPointHints().get(placeIndex)));
+            else if (getGhRequest().hasSnapPreventions())
                 qr = locationIndex.findClosest(point.lat, point.lon, strictEdgeFilter);
             if (qr == null || !qr.isValid())
                 qr = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
@@ -89,15 +90,15 @@ else if (ghRequest.hasSnapPreventions())
     @Override
     public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
         long visitedNodesSum = 0L;
-        boolean viaTurnPenalty = ghRequest.getHints().getBool(Routing.PASS_THROUGH, false);
-        int pointCounts = ghRequest.getPoints().size();
+        boolean viaTurnPenalty = getGhRequest().getHints().getBool(Routing.PASS_THROUGH, false);
+        int pointCounts = getGhRequest().getPoints().size();
         pathList = new ArrayList<>(pointCounts - 1);
         QueryResult fromQResult = queryResults.get(0);
         StopWatch sw;
         for (int placeIndex = 1; placeIndex < pointCounts; placeIndex++) {
             if (placeIndex == 1) {
                 // enforce start direction
-                queryGraph.enforceHeading(fromQResult.getClosestNode(), ghRequest.getFavoredHeading(0), false);
+                queryGraph.enforceHeading(fromQResult.getClosestNode(), getGhRequest().getFavoredHeading(0), false);
             } else if (viaTurnPenalty) {
                 // enforce straight start after via stop
                 Path prevRoute = pathList.get(placeIndex - 2);
@@ -110,7 +111,7 @@ else if (ghRequest.hasSnapPreventions())
             QueryResult toQResult = queryResults.get(placeIndex);
 
             // enforce end direction
-            queryGraph.enforceHeading(toQResult.getClosestNode(), ghRequest.getFavoredHeading(placeIndex), true);
+            queryGraph.enforceHeading(toQResult.getClosestNode(), getGhRequest().getFavoredHeading(placeIndex), true);
 
             sw = new StopWatch().start();
             RoutingAlgorithm algo = algoFactory.createAlgo(queryGraph, algoOpts);
@@ -127,7 +128,7 @@ else if (ghRequest.hasSnapPreventions())
             int idx = 0;
             for (Path path : tmpPathList) {
                 if (path.getTime() < 0)
-                    throw new RuntimeException("Time was negative " + path.getTime() + " for index " + idx + ". Please report as bug and include:" + ghRequest);
+                    throw new RuntimeException("Time was negative " + path.getTime() + " for index " + idx + ". Please report as bug and include:" + getGhRequest());
 
                 pathList.add(path);
                 debug += ", " + path.getDebugInfo();
@@ -155,8 +156,8 @@ else if (ghRequest.hasSnapPreventions())
 
     @Override
     public boolean isReady(PathMerger pathMerger, Translation tr) {
-        if (ghRequest.getPoints().size() - 1 != pathList.size())
-            throw new RuntimeException("There should be exactly one more points than paths. points:" + ghRequest.getPoints().size() + ", paths:" + pathList.size());
+        if (getGhRequest().getPoints().size() - 1 != pathList.size())
+            throw new RuntimeException("There should be exactly one more points than paths. points:" + getGhRequest().getPoints().size() + ", paths:" + pathList.size());
 
         altResponse.setWaypoints(getWaypoints());
         ghResponse.add(altResponse);
@@ -168,4 +169,8 @@ public boolean isReady(PathMerger pathMerger, Translation tr) {
     public int getMaxRetries() {
         return 1;
     }
+
+    public GHRequest getGhRequest() {
+        return ghRequest;
+    }
 }
