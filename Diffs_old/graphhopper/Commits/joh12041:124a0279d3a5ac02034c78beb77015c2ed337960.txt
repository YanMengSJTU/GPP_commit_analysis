diff --git a/core/src/main/java/com/graphhopper/routing/ksp/DijkstraKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/DijkstraKSP.java
new file mode 100644
index 0000000000..76876ca81e
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ksp/DijkstraKSP.java
@@ -0,0 +1,108 @@
+package com.graphhopper.routing.ksp;
+
+/**
+ * Created by brandonsmock on 6/1/15.
+ */
+import java.util.*;
+
+public final class DijkstraKSP {
+
+    private DijkstraKSP() {}
+
+    public static ShortestPathTreeKSP shortestPathTree(GraphKSP graph, String sourceLabel) throws Exception {
+        HashMap<String,NodeKSP> nodes = graph.getNodes();
+        if (!nodes.containsKey(sourceLabel))
+            throw new Exception("Source node not found in graph.");
+        ShortestPathTreeKSP predecessorTree = new ShortestPathTreeKSP(sourceLabel);
+        Set<DijkstraNodeKSP> visited = new HashSet<DijkstraNodeKSP>();
+        PriorityQueue<DijkstraNodeKSP> pq = new PriorityQueue<DijkstraNodeKSP>();
+        for (String nodeLabel:nodes.keySet()) {
+            DijkstraNodeKSP newNode = new DijkstraNodeKSP(nodeLabel);
+            newNode.setDist(Double.MAX_VALUE);
+            newNode.setDepth(Integer.MAX_VALUE);
+            predecessorTree.add(newNode);
+        }
+        DijkstraNodeKSP sourceNode = predecessorTree.getNodes().get(predecessorTree.getRoot());
+        sourceNode.setDist(0);
+        sourceNode.setDepth(0);
+        pq.add(sourceNode);
+
+        int count = 0;
+        while (!pq.isEmpty()) {
+            DijkstraNodeKSP current = pq.poll();
+            String currLabel = current.getLabel();
+            visited.add(current);
+            count++;
+            HashMap<String, Double> neighbors = nodes.get(currLabel).getNeighbors();
+            for (String currNeighborLabel:neighbors.keySet()) {
+                DijkstraNodeKSP neighborNode = predecessorTree.getNodes().get(currNeighborLabel);
+                Double currDistance = neighborNode.getDist();
+                Double newDistance = current.getDist() + nodes.get(currLabel).getNeighbors().get(currNeighborLabel);
+                if (newDistance < currDistance) {
+                    DijkstraNodeKSP neighbor = predecessorTree.getNodes().get(currNeighborLabel);
+
+                    pq.remove(neighbor);
+                    neighbor.setDist(newDistance);
+                    neighbor.setDepth(current.getDepth() + 1);
+                    neighbor.setParent(currLabel);
+                    pq.add(neighbor);
+                }
+            }
+        }
+
+        return predecessorTree;
+    }
+
+    public static PathKSP shortestPath(GraphKSP graph, String sourceLabel, String targetLabel) throws Exception {
+        //if (!nodes.containsKey(sourceLabel))
+        //    throw new Exception("Source node not found in graph.");
+        HashMap<String,NodeKSP> nodes = graph.getNodes();
+        ShortestPathTreeKSP predecessorTree = new ShortestPathTreeKSP(sourceLabel);
+        PriorityQueue<DijkstraNodeKSP> pq = new PriorityQueue<DijkstraNodeKSP>();
+        for (String nodeLabel:nodes.keySet()) {
+            DijkstraNodeKSP newNode = new DijkstraNodeKSP(nodeLabel);
+            newNode.setDist(Double.MAX_VALUE);
+            newNode.setDepth(Integer.MAX_VALUE);
+            predecessorTree.add(newNode);
+        }
+        DijkstraNodeKSP sourceNode = predecessorTree.getNodes().get(predecessorTree.getRoot());
+        sourceNode.setDist(0);
+        sourceNode.setDepth(0);
+        pq.add(sourceNode);
+
+        int count = 0;
+        while (!pq.isEmpty()) {
+            DijkstraNodeKSP current = pq.poll();
+            String currLabel = current.getLabel();
+            if (currLabel.equals(targetLabel)) {
+                PathKSP shortestPath = new PathKSP();
+                String currentN = targetLabel;
+                String parentN = predecessorTree.getParentOf(currentN);
+                while (parentN != null) {
+                    shortestPath.addFirst(new EdgeKSP(parentN,currentN,nodes.get(parentN).getNeighbors().get(currentN)));
+                    currentN = parentN;
+                    parentN = predecessorTree.getParentOf(currentN);
+                }
+                return shortestPath;
+            }
+            count++;
+            HashMap<String, Double> neighbors = nodes.get(currLabel).getNeighbors();
+            for (String currNeighborLabel:neighbors.keySet()) {
+                DijkstraNodeKSP neighborNode = predecessorTree.getNodes().get(currNeighborLabel);
+                Double currDistance = neighborNode.getDist();
+                Double newDistance = current.getDist() + nodes.get(currLabel).getNeighbors().get(currNeighborLabel);
+                if (newDistance < currDistance) {
+                    DijkstraNodeKSP neighbor = predecessorTree.getNodes().get(currNeighborLabel);
+
+                    pq.remove(neighbor);
+                    neighbor.setDist(newDistance);
+                    neighbor.setDepth(current.getDepth() + 1);
+                    neighbor.setParent(currLabel);
+                    pq.add(neighbor);
+                }
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/DijkstraNodeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/DijkstraNodeKSP.java
new file mode 100644
index 0000000000..83cc38fe74
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ksp/DijkstraNodeKSP.java
@@ -0,0 +1,80 @@
+package com.graphhopper.routing.ksp;
+
+import java.util.HashMap;
+import java.util.Set;
+
+/**
+ * Created by brandonsmock on 6/6/15.
+ */
+public class DijkstraNodeKSP extends NodeKSP implements Comparable<DijkstraNodeKSP> {
+    private double dist = Double.MAX_VALUE;
+    private int depth;
+
+    public DijkstraNodeKSP(double dist) {
+        super();
+        this.dist = dist;
+    }
+
+    public DijkstraNodeKSP(String label) {
+        super(label);
+        this.dist = 0.0;
+    }
+
+    public DijkstraNodeKSP(String label, double dist) {
+        super(label);
+        this.dist = dist;
+    }
+
+    public DijkstraNodeKSP(String label, double dist, int depth, String parent) {
+        super(label);
+        this.dist = dist;
+        this.depth = depth;
+        super.addEdge(parent,0.0);
+    }
+
+    public double getDist() {
+        return dist;
+    }
+
+    public void setDist(double dist) {
+        this.dist = dist;
+    }
+
+    public int getDepth() {
+        return depth;
+    }
+
+    public void setDepth(int depth) {
+        this.depth = depth;
+    }
+
+    public void setParent(String parent) {
+        super.neighbors = new HashMap<String, Double>();
+        super.neighbors.put(parent,0.0);
+    }
+
+    public String getParent() {
+        Set<String> neighborLabels = super.neighbors.keySet();
+        if (neighborLabels.size() > 1) {
+            return null;
+        }
+        if (neighborLabels.size() < 1) {
+            return null;
+        }
+        return super.neighbors.keySet().iterator().next();
+    }
+
+    public int compareTo(DijkstraNodeKSP comparedNode) {
+        double distance1 = this.dist;
+        double distance2 = comparedNode.getDist();
+        if (distance1 == distance2)
+            return 0;
+        if (distance1 > distance2)
+            return 1;
+        return -1;
+    }
+
+    public boolean equals(DijkstraNodeKSP comparedNode) {
+        return this.getLabel().equals(comparedNode.getLabel());
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/EdgeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/EdgeKSP.java
new file mode 100644
index 0000000000..23c9532686
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ksp/EdgeKSP.java
@@ -0,0 +1,79 @@
+package com.graphhopper.routing.ksp;
+
+/**
+ * The Edge class implements standard properties and methods for a weighted edge in a directed graph.
+ *
+ * Created by Brandon Smock on 6/19/15.
+ */
+public class EdgeKSP implements Cloneable {
+    private String fromNode;
+    private String toNode;
+    private double weight;
+
+    public EdgeKSP() {
+        this.fromNode = null;
+        this.toNode = null;
+        this.weight = Double.MAX_VALUE;
+    }
+
+    public EdgeKSP(String fromNode, String toNode, double weight) {
+        this.fromNode = fromNode;
+        this.toNode = toNode;
+        this.weight = weight;
+    }
+
+    public String getFromNode() {
+        return fromNode;
+    }
+
+    public void setFromNode(String fromNode) {
+        this.fromNode = fromNode;
+    }
+
+    public String getToNode() {
+        return toNode;
+    }
+
+    public void setToNode(String toNode) {
+        this.toNode = toNode;
+    }
+
+    public double getWeight() {
+        return weight;
+    }
+
+    public void setWeight(double weight) {
+        this.weight = weight;
+    }
+
+    public EdgeKSP clone() {
+        return new EdgeKSP(fromNode, toNode, weight);
+    }
+
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("(");
+        sb.append(fromNode);
+        sb.append(",");
+        sb.append(toNode);
+        sb.append("){");
+        sb.append(weight);
+        sb.append("}");
+
+        return sb.toString();
+    }
+
+    public boolean equals(EdgeKSP edge2) {
+        if (hasSameEndpoints(edge2) && weight == edge2.getWeight())
+            return true;
+
+        return false;
+    }
+
+    public boolean hasSameEndpoints(EdgeKSP edge2) {
+        if (fromNode.equals(edge2.getFromNode()) && toNode.equals(edge2.getToNode()))
+            return true;
+
+        return false;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/GraphKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/GraphKSP.java
new file mode 100644
index 0000000000..21aac6af19
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ksp/GraphKSP.java
@@ -0,0 +1,247 @@
+package com.graphhopper.routing.ksp;
+
+/**
+ * The Graph class implements a weighted, directed graph using an adjacency list representation.
+ *
+ * Created by brandonsmock on 6/1/15.
+ */
+
+import java.io.*;
+import java.util.*;
+
+public class GraphKSP {
+    private HashMap<String,NodeKSP> nodes;
+
+    public GraphKSP() {
+        nodes = new HashMap<String,NodeKSP>();
+    }
+
+    public GraphKSP(String filename) {
+        this();
+        readFromFile(filename);
+    }
+
+    public GraphKSP(HashMap<String,NodeKSP> nodes) {
+        this.nodes = nodes;
+    }
+
+    public int numNodes() {
+        return nodes.size();
+    }
+
+    public int numEdges() {
+        int edgeCount = 0;
+        for (NodeKSP node : nodes.values()) {
+            edgeCount += node.getEdges().size();
+        }
+        return edgeCount;
+    }
+
+    public void addNode(String label) {
+        if (!nodes.containsKey(label))
+            nodes.put(label,new NodeKSP(label));
+    }
+
+    public void addNode(NodeKSP node) {
+        String label = node.getLabel();
+        if (!nodes.containsKey(label))
+            nodes.put(label,node);
+    }
+
+    public void addEdge(String label1, String label2, Double weight) {
+        if (!nodes.containsKey(label1))
+            addNode(label1);
+        if (!nodes.containsKey(label2))
+            addNode(label2);
+        nodes.get(label1).addEdge(label2,weight);
+    }
+
+    public void addEdge(EdgeKSP edge) {
+        addEdge(edge.getFromNode(),edge.getToNode(),edge.getWeight());
+    }
+
+    public void addEdges(List<EdgeKSP> edges) {
+        for (EdgeKSP edge : edges) {
+            addEdge(edge);
+        }
+    }
+
+    public EdgeKSP removeEdge(String label1, String label2) {
+        if (nodes.containsKey(label1)) {
+            double weight = nodes.get(label1).removeEdge(label2);
+            if (weight != Double.MAX_VALUE) {
+                return new EdgeKSP(label1, label2, weight);
+            }
+        }
+
+        return null;
+    }
+
+    public double getEdgeWeight(String label1, String label2) {
+        if (nodes.containsKey(label1)) {
+            NodeKSP node1 = nodes.get(label1);
+            if (node1.getNeighbors().containsKey(label2)) {
+                return node1.getNeighbors().get(label2);
+            }
+        }
+
+        return Double.MAX_VALUE;
+    }
+
+    public HashMap<String,NodeKSP> getNodes() {
+        return nodes;
+    }
+
+    public List<EdgeKSP> getEdgeList() {
+        List<EdgeKSP> edgeList = new LinkedList<EdgeKSP>();
+
+        for (NodeKSP node : nodes.values()) {
+            edgeList.addAll(node.getEdges());
+        }
+
+        return edgeList;
+    }
+
+    public Set<String> getNodeLabels() {
+        return nodes.keySet();
+    }
+
+    public NodeKSP getNode(String label) {
+        return nodes.get(label);
+    }
+
+    public List<EdgeKSP> removeNode(String label) {
+        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
+        if (nodes.containsKey(label)) {
+            NodeKSP node = nodes.remove(label);
+            edges.addAll(node.getEdges());
+            edges.addAll(removeEdgesToNode(label));
+        }
+
+        return edges;
+    }
+
+    public List<EdgeKSP> removeEdgesToNode(String label) {
+        List<EdgeKSP> edges = new LinkedList<EdgeKSP>();
+        for (NodeKSP node : nodes.values()) {
+            if (node.getAdjacencyList().contains(label)) {
+                double weight = node.removeEdge(label);
+                edges.add(new EdgeKSP(node.getLabel(),label,weight));
+            }
+        }
+        return edges;
+    }
+
+
+
+    public GraphKSP transpose() {
+        HashMap<String,NodeKSP> newNodes = new HashMap<String, NodeKSP>();
+
+        Iterator<String> it = nodes.keySet().iterator();
+        while (it.hasNext()) {
+            String nodeLabel = it.next();
+            newNodes.put(nodeLabel,new NodeKSP(nodeLabel));
+        }
+
+        it = nodes.keySet().iterator();
+        while (it.hasNext()) {
+            String nodeLabel = it.next();
+            NodeKSP node = nodes.get(nodeLabel);
+            Set<String> adjacencyList = node.getAdjacencyList();
+            Iterator<String> alIt = adjacencyList.iterator();
+            HashMap<String, Double> neighbors = node.getNeighbors();
+            while (alIt.hasNext()) {
+                String neighborLabel = alIt.next();
+                newNodes.get(neighborLabel).addEdge(nodeLabel,neighbors.get(neighborLabel));
+            }
+        }
+
+        return new GraphKSP(newNodes);
+    }
+
+    public void clear() {
+        nodes = new HashMap<String,NodeKSP>();
+    }
+
+    public void readFromFile(String fileName) {
+        try {
+            BufferedReader in = new BufferedReader(new FileReader(fileName));
+
+            String line = in.readLine();
+
+            while (line != null) {
+                String[] edgeDescription = line.split("\\s");
+                if (edgeDescription.length == 3) {
+                    addEdge(edgeDescription[0],edgeDescription[1],Double.parseDouble(edgeDescription[2]));
+                    //addEdge(edgeDescription[1],edgeDescription[0],Double.parseDouble(edgeDescription[2]));
+                }
+                line = in.readLine();
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public String toString() {
+        StringBuilder graphStringB = new StringBuilder();
+        Iterator<String> it = nodes.keySet().iterator();
+        while (it.hasNext()) {
+            String nodeLabel = it.next();
+            graphStringB.append(nodeLabel.toString());
+            graphStringB.append(": {");
+            NodeKSP node = nodes.get(nodeLabel);
+            Set<String> adjacencyList = node.getAdjacencyList();
+            Iterator<String> alIt = adjacencyList.iterator();
+            HashMap<String, Double> neighbors = node.getNeighbors();
+            while (alIt.hasNext()) {
+                String neighborLabel = alIt.next();
+                graphStringB.append(neighborLabel.toString());
+                graphStringB.append(": ");
+                graphStringB.append(neighbors.get(neighborLabel));
+                if (alIt.hasNext())
+                    graphStringB.append(", ");
+            }
+            graphStringB.append("}");
+            graphStringB.append("\n");
+        }
+
+        return graphStringB.toString();
+    }
+
+    public void graphToFile(String filename) {
+        BufferedWriter writer = null;
+        try {
+            File subgraphFile = new File(filename);
+
+            // This will output the full path where the file will be written to...
+            System.out.println(subgraphFile.getCanonicalPath());
+
+            writer = new BufferedWriter(new FileWriter(subgraphFile));
+            writer.write(Integer.toString(nodes.size()) + "\n\n");
+
+            Iterator<NodeKSP> it = nodes.values().iterator();
+            while (it.hasNext()) {
+                NodeKSP node = it.next();
+                String nodeLabel = node.getLabel();
+                if (nodes.containsKey(nodeLabel)) {
+                    HashMap<String,Double> neighbors = node.getNeighbors();
+                    Iterator<String> it2 = neighbors.keySet().iterator();
+                    while (it2.hasNext()) {
+                        String nodeLabel2 = it2.next();
+                        if (nodes.containsKey(nodeLabel2)) {
+                            writer.write(nodeLabel + " " + nodeLabel2 + " " + neighbors.get(nodeLabel2) + "\n");
+                        }
+                    }
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            try {
+                // Close the writer regardless of what happens...
+                writer.close();
+            } catch (Exception e) {
+            }
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/NodeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/NodeKSP.java
new file mode 100644
index 0000000000..ded61bf24d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ksp/NodeKSP.java
@@ -0,0 +1,91 @@
+package com.graphhopper.routing.ksp;
+
+/**
+ * The Node class implements a node in a directed graph keyed on a label of type String, with adjacency lists for
+ * representing edges.
+ *
+ * Created by brandonsmock on 5/31/15.
+ */
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Set;
+
+public class NodeKSP {
+    protected String label;
+    protected HashMap<String,Double> neighbors; // adjacency list, with HashMap for each edge weight
+
+    public NodeKSP() {
+        neighbors = new HashMap();
+    }
+
+    public NodeKSP(String label) {
+        this.label = label;
+        neighbors = new HashMap();
+    }
+
+    public String getLabel() {
+        return label;
+    }
+
+    public void setLabel(String label) {
+        this.label = label;
+    }
+
+    public HashMap<String, Double> getNeighbors() {
+        return neighbors;
+    }
+
+    public void setNeighbors(HashMap<String, Double> neighbors) {
+        this.neighbors = neighbors;
+    }
+
+    public void addEdge(String toNodeLabel,Double weight) {
+        neighbors.put(toNodeLabel, weight);
+    }
+
+    public double removeEdge(String toNodeLabel) {
+        if (neighbors.containsKey(toNodeLabel)) {
+            double weight = neighbors.get(toNodeLabel);
+            neighbors.remove(toNodeLabel);
+            return weight;
+        }
+
+        return Double.MAX_VALUE;
+    }
+
+    public Set<String> getAdjacencyList() {
+        return neighbors.keySet();
+    }
+
+    public LinkedList<EdgeKSP> getEdges() {
+        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
+        for (String toNodeLabel : neighbors.keySet()) {
+            edges.add(new EdgeKSP(label,toNodeLabel,neighbors.get(toNodeLabel)));
+        }
+
+        return edges;
+    }
+    
+    public String toString() {
+        StringBuilder nodeStringB = new StringBuilder();
+        nodeStringB.append(label);
+        nodeStringB.append(": {");
+        Set<String> adjacencyList = this.getAdjacencyList();
+        Iterator<String> alIt = adjacencyList.iterator();
+        HashMap<String, Double> neighbors = this.getNeighbors();
+        while (alIt.hasNext()) {
+            String neighborLabel = alIt.next();
+            nodeStringB.append(neighborLabel.toString());
+            nodeStringB.append(": ");
+            nodeStringB.append(neighbors.get(neighborLabel));
+            if (alIt.hasNext())
+                nodeStringB.append(", ");
+        }
+        nodeStringB.append("}");
+        nodeStringB.append("\n");
+
+        return nodeStringB.toString();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/PathKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/PathKSP.java
new file mode 100644
index 0000000000..e4a917814f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ksp/PathKSP.java
@@ -0,0 +1,216 @@
+package com.graphhopper.routing.ksp;
+
+import java.util.*;
+
+/**
+ * The Path class implements a path in a weighted, directed graph as a sequence of Edges.
+ *
+ * Created by Brandon Smock on 6/18/15.
+ */
+public class PathKSP implements Cloneable, Comparable<PathKSP> {
+    private LinkedList<EdgeKSP> edges;
+    private double totalCost;
+
+    public PathKSP() {
+        edges = new LinkedList<EdgeKSP>();
+        totalCost = 0;
+    }
+
+    public PathKSP(double totalCost) {
+        edges = new LinkedList<EdgeKSP>();
+        this.totalCost = totalCost;
+    }
+
+    public PathKSP(LinkedList<EdgeKSP> edges) {
+        this.edges = edges;
+        totalCost = 0;
+        for (EdgeKSP edge : edges) {
+            totalCost += edge.getWeight();
+        }
+    }
+
+    public PathKSP(LinkedList<EdgeKSP> edges, double totalCost) {
+        this.edges = edges;
+        this.totalCost = totalCost;
+    }
+
+    public LinkedList<EdgeKSP> getEdges() {
+        return edges;
+    }
+
+    public void setEdges(LinkedList<EdgeKSP> edges) {
+        this.edges = edges;
+    }
+
+    public List<String> getNodes() {
+        LinkedList<String> nodes = new LinkedList<String>();
+
+        for (EdgeKSP edge : edges) {
+            nodes.add(edge.getFromNode());
+        }
+
+        EdgeKSP lastEdge = edges.getLast();
+        if (lastEdge != null) {
+            nodes.add(lastEdge.getToNode());
+        }
+
+        return nodes;
+    }
+
+    public double getTotalCost() {
+        return totalCost;
+    }
+
+    public void setTotalCost(double totalCost) {
+        this.totalCost = totalCost;
+    }
+
+    public void addFirstNode(String nodeLabel) {
+        String firstNode = edges.getFirst().getFromNode();
+        edges.addFirst(new EdgeKSP(nodeLabel, firstNode,0));
+    }
+
+    public void addFirst(EdgeKSP edge) {
+        edges.addFirst(edge);
+        totalCost += edge.getWeight();
+    }
+
+    public void add(EdgeKSP edge) {
+        edges.add(edge);
+        totalCost += edge.getWeight();
+    }
+
+    public void addLastNode(String nodeLabel) {
+        String lastNode = edges.getLast().getToNode();
+        edges.addLast(new EdgeKSP(lastNode, nodeLabel,0));
+    }
+
+    public int size() {
+        return edges.size();
+    }
+
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        int numEdges = edges.size();
+        sb.append(totalCost);
+        sb.append(": [");
+        if (numEdges > 0) {
+            for (int i = 0; i < edges.size(); i++) {
+                sb.append(edges.get(i).getFromNode().toString());
+                sb.append("-");
+            }
+
+            sb.append(edges.getLast().getToNode().toString());
+        }
+        sb.append("]");
+        return sb.toString();
+    }
+
+/*    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Path path = (Path) o;
+
+        if (Double.compare(path.totalCost, totalCost) != 0) return false;
+        if (!edges.equals(path.edges)) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result;
+        long temp;
+        result = edges.hashCode();
+        temp = Double.doubleToLongBits(totalCost);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        return result;
+    }*/
+
+    public boolean equals(PathKSP path2) {
+        if (path2 == null)
+            return false;
+
+        LinkedList<EdgeKSP> edges2 = path2.getEdges();
+
+        int numEdges1 = edges.size();
+        int numEdges2 = edges2.size();
+
+        if (numEdges1 != numEdges2) {
+            return false;
+        }
+
+        for (int i = 0; i < numEdges1; i++) {
+            EdgeKSP edge1 = edges.get(i);
+            EdgeKSP edge2 = edges2.get(i);
+            if (!edge1.getFromNode().equals(edge2.getFromNode()))
+                return false;
+            if (!edge1.getToNode().equals(edge2.getToNode()))
+                return false;
+        }
+
+        return true;
+    }
+
+    public int compareTo(PathKSP path2) {
+        double path2Cost = path2.getTotalCost();
+        if (totalCost == path2Cost)
+            return 0;
+        if (totalCost > path2Cost)
+            return 1;
+        return -1;
+    }
+
+    public PathKSP clone() {
+        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
+
+        for (EdgeKSP edge : this.edges) {
+            edges.add(edge.clone());
+        }
+
+        return new PathKSP(edges);
+    }
+
+    public PathKSP shallowClone() {
+        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
+
+        for (EdgeKSP edge : this.edges) {
+            edges.add(edge);
+        }
+
+        return new PathKSP(edges,this.totalCost);
+    }
+
+    public PathKSP cloneTo(int i) {
+        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
+        int l = this.edges.size();
+        if (i > l)
+            i = l;
+
+        //for (Edge edge : this.edges.subList(0,i)) {
+        for (int j = 0; j < i; j++) {
+            edges.add(this.edges.get(j).clone());
+        }
+
+        return new PathKSP(edges);
+    }
+
+    public PathKSP cloneFrom(int i) {
+        LinkedList<EdgeKSP> edges = new LinkedList<EdgeKSP>();
+
+        for (EdgeKSP edge : this.edges.subList(i,this.edges.size())) {
+            edges.add(edge.clone());
+        }
+
+        return new PathKSP(edges);
+    }
+
+    public void addPath(PathKSP p2) {
+        // ADD CHECK TO SEE THAT PATH P2'S FIRST NODE IS SAME AS THIS PATH'S LAST NODE
+
+        this.edges.addAll(p2.getEdges());
+        this.totalCost += p2.getTotalCost();
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/ShortestPathTreeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/ShortestPathTreeKSP.java
new file mode 100644
index 0000000000..7a105d415d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ksp/ShortestPathTreeKSP.java
@@ -0,0 +1,55 @@
+package com.graphhopper.routing.ksp;
+
+import java.util.HashMap;
+
+/**
+ * Created by brandonsmock on 6/8/15.
+ */
+public class ShortestPathTreeKSP {
+    private HashMap<String,DijkstraNodeKSP> nodes;
+    private final String root;
+
+    public ShortestPathTreeKSP() {
+        this.nodes = new HashMap<String, DijkstraNodeKSP>();
+        this.root = "";
+    }
+
+    public ShortestPathTreeKSP(String root) {
+        this.nodes = new HashMap<String, DijkstraNodeKSP>();
+        this.root = root;
+    }
+
+    public HashMap<String, DijkstraNodeKSP> getNodes() {
+        return nodes;
+    }
+
+    public void setNodes(HashMap<String, DijkstraNodeKSP> nodes) {
+        this.nodes = nodes;
+    }
+
+    public String getRoot() {
+        return root;
+    }
+
+    public void add(DijkstraNodeKSP newNode) {
+        nodes.put(newNode.getLabel(),newNode);
+    }
+
+    public void setParentOf(String node, String parent) {
+//        if (parent != null && !nodes.containsKey(parent)) {
+//            System.out.println("Warning: parent node not present in tree.");
+//        }
+        if (!nodes.containsKey(node))
+            nodes.put(node,new DijkstraNodeKSP(node));
+
+        nodes.get(node).setParent(parent);
+
+    }
+
+    public String getParentOf(String node) {
+        if (nodes.containsKey(node))
+            return nodes.get(node).getParent();
+        else
+            return null;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ksp/WeightedEdgeKSP.java b/core/src/main/java/com/graphhopper/routing/ksp/WeightedEdgeKSP.java
new file mode 100644
index 0000000000..49e120b569
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ksp/WeightedEdgeKSP.java
@@ -0,0 +1,58 @@
+package edu.ufl.cise.bsmock.graph;
+
+/**
+ * The WeightedEdge class implements standard properties and methods for a weighted edge in a directed graph.
+ *
+ * Created by Brandon Smock on 6/6/15.
+ */
+public class WeightedEdge implements Comparable<WeightedEdge> {
+    private String sourceLabel;
+    private String targetLabel;
+    private double edgeWeight = 0.0;
+
+    public WeightedEdge(String targetLabel, double edgeWeight) {
+        this.targetLabel = targetLabel;
+        this.edgeWeight = edgeWeight;
+    }
+
+    public WeightedEdge(String sourceLabel, String targetLabel, double edgeWeight) {
+        this.sourceLabel = sourceLabel;
+        this.targetLabel = targetLabel;
+        this.edgeWeight = edgeWeight;
+    }
+
+    public String getSourceLabel() {
+        return sourceLabel;
+    }
+
+    public void setSourceLabel(String sourceLabel) {
+        this.sourceLabel = sourceLabel;
+    }
+
+    public String getTargetLabel() {
+        return targetLabel;
+    }
+
+    public void setTargetLabel(String targetLabel) {
+        this.targetLabel = targetLabel;
+    }
+
+    public double getEdgeWeight() {
+        return edgeWeight;
+    }
+
+    public void setEdgeWeight(double edgeWeight) {
+        this.edgeWeight = edgeWeight;
+    }
+
+    public int compareTo(WeightedEdge comparedObject) {
+        double weight1 = this.getEdgeWeight();
+        double weight2 = comparedObject.getEdgeWeight();
+
+        if (weight1 == weight2)
+            return 0;
+        if (weight1 > weight2)
+            return 1;
+        return -1;
+    }
+}
