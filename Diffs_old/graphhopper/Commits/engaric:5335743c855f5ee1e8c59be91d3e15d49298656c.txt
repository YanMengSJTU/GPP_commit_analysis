diff --git a/acceptancetesting/src/test/cucumber/Routing-Errors.feature b/acceptancetesting/src/test/cucumber/Routing-Errors.feature
index 69b9218807..908554559f 100644
--- a/acceptancetesting/src/test/cucumber/Routing-Errors.feature
+++ b/acceptancetesting/src/test/cucumber/Routing-Errors.feature
@@ -10,12 +10,11 @@ Feature: Verify Error Messages from a routing service
       | pointA              | pointB              |
       | 50.729961,-3.524853 | 50.723364,-3.523895 |
     And I have vehicle as "car"
-    And I have avoidances as ""
     And I have weighting as "fastest"
-    And I have locale as "en_US"
+    And I have locale as "en_GB"
     And I have debug as "true"
     And I have points_encoded as "true"
-    And I have points_calc as "true"
+    And I have calc_points as "true"
     And I have instructions as "true"
     And I have algorithm as "astar"
     And I have type as "json"
@@ -24,7 +23,7 @@ Feature: Verify Error Messages from a routing service
     Then I should be able to verify the http statuscode as "200"
     Then I should be able to verify the waypoints on the route map:
       | wayPointIndex | waypointco          | waypointdesc                | azimuth | direction | time | distance | avoidance |
-      | 2             | 50.729205,-3.523206 | Turn right onto WELL STREET | 210.0   | SW        | 4050 | 112.5    |           |
+      | 2             | 50.729205,-3.523206 | Turn right onto WELL STREET | 210.0   | SW        | 9001 | 112.5    |           |
 
   # Parameter :  point
   @ErrorMessages
@@ -41,8 +40,8 @@ Feature: Verify Error Messages from a routing service
     Then I should be able to verify the statuscode as "<statusCode>"
 
     Examples: 
-      | vehicleType | avoidances | routeType | responseFormat | errorMessage                                     | statusCode |
-      | car         |            | fastest   | json           | At least 2 points has to be specified, but was:1 | 400        |
+      | vehicleType | avoidances | routeType | responseFormat | errorMessage                   | statusCode |
+      | car         |            | fastest   | json           | No vehicle parameter provided. | 400        |
 
   @ErrorMessages
   Scenario Outline: Incorrect Parameter Value "point"
@@ -348,7 +347,6 @@ Feature: Verify Error Messages from a routing service
       | pointA              | pointB              |
       | 50.729961,-3.524853 | 50.723364,-3.523895 |
     And I have vehicle as "car"
-    And I have avoidances as ""
     And I have weighting as "fastest"
     And I have locale as "<locale>"
     And I have debug as "true"
@@ -400,7 +398,6 @@ Feature: Verify Error Messages from a routing service
       | pointA              | pointB              |
       | 50.729961,-3.524853 | 50.723364,-3.523895 |
     And I have vehicle as "car"
-    And I have avoidances as ""
     And I have weighting as "fastest"
     And I have locale as "en_US"
     And I have debug as "true"
@@ -426,7 +423,6 @@ Feature: Verify Error Messages from a routing service
       | pointA              | pointB              |
       | 50.729961,-3.524853 | 50.723364,-3.523895 |
     And I have vehicle as "car"
-    And I have avoidances as ""
     And I have weighting as "fastest"
     And I have locale as "en_US"
     And I have debug as "<debug>"
@@ -450,12 +446,11 @@ Feature: Verify Error Messages from a routing service
       | pointA              | pointB              |
       | 50.729961,-3.524853 | 50.723364,-3.523895 |
     And I have vehicle as "car"
-    And I have avoidances as ""
     And I have weighting as "fastest"
     And I have locale as "en_US"
     And I have debug as "true"
     And I have points_encoded as "true"
-    And I have points_calc as "<points_calc>"
+    And I have calc_points as "<points_calc>"
     And I have instructions as "true"
     And I have algorithm as "astar"
     And I have type as "json"
@@ -474,7 +469,6 @@ Feature: Verify Error Messages from a routing service
       | pointA              | pointB              |
       | 50.729961,-3.524853 | 50.723364,-3.523895 |
     And I have vehicle as "car"
-    And I have avoidances as ""
     And I have weighting as "fastest"
     And I have locale as "en_US"
     And I have debug as "true"
@@ -498,7 +492,6 @@ Feature: Verify Error Messages from a routing service
       | pointA              | pointB              |
       | 50.729961,-3.524853 | 50.723364,-3.523895 |
     And I have vehicle as "car"
-    And I have avoidances as ""
     And I have weighting as "fastest"
     And I have locale as "en_US"
     And I have debug as "true"
@@ -522,7 +515,6 @@ Feature: Verify Error Messages from a routing service
       | pointA              | pointB              |
       | 50.729961,-3.524853 | 50.723364,-3.523895 |
     And I have vehicle as "car"
-    And I have avoidances as ""
     And I have weighting as "fastest"
     And I have locale as "en_US"
     And I have debug as "true"
diff --git a/acceptancetesting/src/test/cucumber/Routing-Exeter-Smoke.feature b/acceptancetesting/src/test/cucumber/Routing-Exeter-Smoke.feature
index 116704b635..db2d34a895 100644
--- a/acceptancetesting/src/test/cucumber/Routing-Exeter-Smoke.feature
+++ b/acceptancetesting/src/test/cucumber/Routing-Exeter-Smoke.feature
@@ -6,17 +6,17 @@ Feature: Smoke Tests: Verify a route from A to B
   #Error Messages
   #Successful request
   @ErrorMessages @Smoke
+
   Scenario: Successful request with all parameters
     Given I have route point as
       | pointA              | pointB              |
       | 50.729961,-3.524853 | 50.723364,-3.523895 |
     And I have vehicle as "car"
-    And I have avoidances as ""
     And I have weighting as "fastest"
-    And I have locale as "en_US"
+    And I have locale as "en_GB"
     And I have debug as "true"
     And I have points_encoded as "true"
-    And I have points_calc as "true"
+    And I have calc_points as "true"
     And I have instructions as "true"
     And I have algorithm as "astar"
     And I have type as "json"
@@ -25,7 +25,7 @@ Feature: Smoke Tests: Verify a route from A to B
     Then I should be able to verify the http statuscode as "200"
     Then I should be able to verify the waypoints on the route map:
       | wayPointIndex | waypointco          | waypointdesc                | azimuth | direction | time | distance | avoidance |
-      | 2             | 50.729205,-3.523206 | Turn right onto WELL STREET | 210.0   | SW        | 4050 | 112.5    |           |
+      | 2             | 50.729205,-3.523206 | Turn right onto WELL STREET | 210.0   | SW        | 9001 | 112.5    |           |
 
   # Parameter :  vehicle
   @ErrorMessages @Smoke
diff --git a/acceptancetesting/src/test/cucumber/Routing-PeakDistrict-Smoke.feature b/acceptancetesting/src/test/cucumber/Routing-PeakDistrict-Smoke.feature
index 86000b6846..1f1a913275 100644
--- a/acceptancetesting/src/test/cucumber/Routing-PeakDistrict-Smoke.feature
+++ b/acceptancetesting/src/test/cucumber/Routing-PeakDistrict-Smoke.feature
@@ -1,4 +1,4 @@
-Feature: Smoke Tests- Peak District: Verify a route from A to B
+Feature: Smoke Tests- Peak District: Verify Error Messsage for a route from A to B
    As a user
    I want to get a route from location A to location B using the routing service
    And route should be the fastest route and contain the waypoints,restrictions,time and other instructions
@@ -8,15 +8,14 @@ Feature: Smoke Tests- Peak District: Verify a route from A to B
   @ErrorMessages @Smoke
   Scenario: Successful request with all parameters
     Given I have route point as
-      | pointA              | pointB              |
-      | 53.298525,-1.679533 | 53.203145,-1.799292 |
+      | pointA              | pointB             |
+      | 53.176062,-1.871472 | 53.154773,-1.77272 |
     And I have vehicle as "foot"
-    And I have avoidances as ""
     And I have weighting as "fastest"
-    And I have locale as "en_US"
+    And I have locale as "en_GB"
     And I have debug as "true"
     And I have points_encoded as "true"
-    And I have points_calc as "true"
+    And I have calc_points as "true"
     And I have instructions as "true"
     And I have algorithm as "astar"
     And I have type as "json"
@@ -24,8 +23,8 @@ Feature: Smoke Tests- Peak District: Verify a route from A to B
     Then I should be able to verify the http response message as "OK"
     Then I should be able to verify the http statuscode as "200"
     Then I should be able to verify the waypoints on the route map:
-      | wayPointIndex | waypointco          | waypointdesc                | azimuth | direction | time | distance | avoidance |
-      | 2             | 50.729205,-3.523206 | Turn right onto WELL STREET | 210.0   | SW        | 4050 | 112.5    |           |
+      | wayPointIndex | waypointco          | waypointdesc        | azimuth | direction | time   | distance | avoidance |
+      | 4             | 53.173017,-1.868287 | continue onto Route | 117.0   | SE        | 132624 | 184.2    |           |
 
   # Parameter :  vehicle
   @ErrorMessages @Smoke
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index fafb5e55e0..5c2b18e3d6 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -19,3 +19,5 @@ for tr in $translations; do
   echo -e '# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh\n' > $destination/$tr.txt
   tail -n+5 "$file" | cut -s -f1,$INDEX --output-delimiter='=' >> $destination/$tr.txt
 done
+
+cp $destination/en_US.txt $destination/en_GB.txt
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java b/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java
index eb4aebbed7..150c8b7b69 100755
--- a/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/itn/OsItnReader.java
@@ -51,6 +51,7 @@
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.osgb.AbstractOsReader;
 import com.graphhopper.reader.osgb.hn.OsHnReader;
+import com.graphhopper.reader.osgb.roadclassification.RoadClassification;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -801,9 +802,11 @@ private void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
             // We have at least one bit set so create tags for the set
             // attributes
             if ((attributeBits & ATTRIBUTE_BIT_FORD) != 0) {
+            	System.err.println("FORD_NBIT");
                 way.setTag(OSITNElement.TAG_VALUE_CLASSIFICATION_FORD, "yes");
             }
             if ((attributeBits & ATTRIBUTE_BIT_GATE) != 0) {
+            	System.err.println("GATE_NBIT");
                 way.setTag("barrier", OSITNElement.TAG_VALUE_CLASSIFICATION_GATE);
             }
             if ((attributeBits & ATTRIBUTE_BIT_LEVEL_CROSSING) != 0) {
@@ -832,17 +835,8 @@ private void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
             way.setTag("highway", wayType);
         }
         String wayEnvironment = getWayEnvironment(way.getId());
-        if (null != wayEnvironment && !way.hasTag("environment")) {
-
-            String nature = way.getTag("nature");
-            if (!Helper.isEmpty(nature))
-            {
-                wayEnvironment += ":"+nature;
-            }
-
-            //            System.out.println(">>>>>>>>>>>>>>>> Way " + wayOsmId + " is in environment " + wayEnvironment );
-            way.setTag("environment", wayEnvironment);
-        }
+        RoadClassification lookup = RoadClassification.lookup(wayEnvironment);
+        lookup.applyWayAttribute(way);
 
         String wayDirection = getWayRoadDirection(way.getId());
         // If the way is ONEWAY then set the direction
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/roadclassification/RoadClassification.java b/core/src/main/java/com/graphhopper/reader/osgb/roadclassification/RoadClassification.java
index 49277b52e4..b714f0062c 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/roadclassification/RoadClassification.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/roadclassification/RoadClassification.java
@@ -6,7 +6,13 @@
 
 public enum RoadClassification 
 {
-	NULLCLASSIFICATION(null),
+	NULLCLASSIFICATION(null) {
+		@Override
+		public void applyWayAttribute( RoutingElement way )
+		{
+			//nullop
+		}
+	},
 	ALLEY(new Alley()),
 	AROAD(new ARoad()),
 	BROAD(new BRoad()),
@@ -41,10 +47,9 @@ public void applyWayAttribute(RoutingElement way )
     public static RoadClassification lookup(String dataName) {
     	try {
     		RoadClassification valueOf = RoadClassification.valueOf(dataName.replace(" ", "").replace("–", "").toUpperCase());
-    		System.err.println("Search:" + dataName + " Found:" + valueOf.toString());
     		return valueOf;
     	}
-    	catch (IllegalArgumentException iae) {
+    	catch (IllegalArgumentException | NullPointerException e) {
     		return NULLCLASSIFICATION;
     	}
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java
new file mode 100644
index 0000000000..56da0dca36
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoder.java
@@ -0,0 +1,63 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.Way;
+
+public class EmergencyVehicleFlagEncoder extends CarFlagEncoder
+{
+	private EncodedValue startStopEncoder;
+
+	public EmergencyVehicleFlagEncoder( String entryVal )
+	{
+		super(entryVal);
+		restrictedValues.clear();
+	}
+
+	@Override
+	public String toString()
+	{
+		return "emv";
+	}
+
+	@Override
+	public long acceptWay( Way way )
+	{
+		if(way.hasTag("motorcar", "no")) 
+			return 0; 
+	    return super.acceptWay(way);
+	}
+	
+	@Override
+	public long getLong( long flags, int key )
+	{
+	    if(key==100) 
+	    	return startStopEncoder.getValue(flags);
+		return super.getLong(flags, key);
+	}
+	
+	@Override
+	public long handleWayTags( Way way, long allowed, long relationFlags )
+	{
+	    long superHandled =  super.handleWayTags(way, allowed, relationFlags);
+	    System.err.println("SUPER"+ superHandled);
+	    return superHandled |= startStopEncoder.setValue(superHandled, way.hasTag("access", "no")?1:0);
+	}
+	
+	/**
+     * Define the place of the speedBits in the edge flags for car.
+     */
+    @Override
+    public int defineWayBits( int index, int shift )
+    {
+        // first two bits are reserved for route handling in superclass
+        shift = super.defineWayBits(index, shift);
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"), 
+                                              maxPossibleSpeed);
+        shift += speedEncoder.getBits();
+        
+        startStopEncoder = new EncodedValue("StartStop", shift, 1, 1, 0, 1, true);
+        shift += startStopEncoder.getBits();
+        
+        return shift;
+    }
+	
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 6f002c31f3..cd1939c471 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -51,6 +51,7 @@
 public class EncodingManager
 {
 	public static final String CAR = "car";
+	public static final String EMV = "emv";
 	public static final String BIKE = "bike";
 	public static final String BIKE2 = "bike2";
 	public static final String RACINGBIKE = "racingbike";
@@ -161,6 +162,9 @@ public int getBytesForFlags()
 			AbstractFlagEncoder fe;
 			if (entry.equals(CAR))
 				fe = new CarFlagEncoder(entryVal);
+			
+			else if (entry.equals(EMV))
+				fe = new EmergencyVehicleFlagEncoder(entryVal);
 
 			else if (entry.equals(BIKE))
 				fe = new BikeFlagEncoder(entryVal);
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index ff6aa8c358..cf56e8ffd7 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -44,7 +44,7 @@
 	public static final List<String> LOCALES = Arrays.asList("bg", "ca", "cz", "de_DE", "el",
 	        "en_US", "es", "fa", "fil", "fi", "fr", "gl", "he", "hu_HU", "it", "ja", "ne", "nl",
 	        "pl_PL", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk", "vi_VI",
-	        "zh_CN");
+	        "zh_CN", "en_GB");
 	private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
 	/**
diff --git a/core/src/main/resources/com/graphhopper/util/en_GB.txt b/core/src/main/resources/com/graphhopper/util/en_GB.txt
new file mode 100644
index 0000000000..08eaab2637
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/en_GB.txt
@@ -0,0 +1,46 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=continue
+continue_onto=continue onto %1$s
+turn_left=turn left
+turn_right=turn right
+turn_slight_left=turn slight left
+turn_slight_right=turn slight right
+turn_sharp_left=turn sharp left
+turn_sharp_right=turn sharp right
+turn_onto=%1$s onto %2$s
+web.searchButton=Search
+web.fromHint=From
+web.viaHint=Via
+web.toHint=To
+web.moreButton=more
+web.gpxExportButton=GPX export
+web.routeInfo=%1$s will take %2$s
+web.locationsNotFound=Routing not possible. Location(s) not found in the area.
+web.bike=Bike
+web.racingbike=Racingbike
+web.mtb=Mountainbike
+web.car=Car
+web.foot=Foot
+web.emv=Emergency
+web.staticlink=static link
+web.motorcycle=Motorcycle
+via=via
+finish=Finish!
+hourAbbr=h
+dayAbbr=d
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=road
+off_bike=get off the bike
+cycleway=cycleway
+way=way
+paved=paved
+unpaved=unpaved
+stopover=stopover %1$s
+roundaboutEnter=Enter roundabout
+roundaboutExit=At roundabout, take exit %1$s
+roundaboutExitOnto=At roundabout, take exit %1$s onto %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index c886850443..08eaab2637 100644
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -22,6 +22,7 @@ web.racingbike=Racingbike
 web.mtb=Mountainbike
 web.car=Car
 web.foot=Foot
+web.emv=Emergency
 web.staticlink=static link
 web.motorcycle=Motorcycle
 via=via
diff --git a/core/src/test/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoderTest.java
new file mode 100644
index 0000000000..c25c4aadc5
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/EmergencyVehicleFlagEncoderTest.java
@@ -0,0 +1,582 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+
+import com.graphhopper.reader.OSMNode;
+import com.graphhopper.reader.OSMWay;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class EmergencyVehicleFlagEncoderTest
+{
+    private final EncodingManager em = new EncodingManager("EMV,BIKE",8);
+    private final EmergencyVehicleFlagEncoder encoder = (EmergencyVehicleFlagEncoder) em.getEncoder("EMV");
+    
+    @Test
+    public void testAccess()
+    {
+        OSMWay way = new OSMWay(1);
+        assertFalse(encoder.acceptWay(way) > 0);
+        way.setTag("highway", "service");
+        assertTrue(encoder.acceptWay(way) > 0);
+        way.setTag("access", "no");
+        assertTrue(encoder.acceptWay(way) > 0);
+        
+        way.setTag("access", "private");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("motorcar", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        // for now allow grade1+2+3 for every country, see #253
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("tracktype", "grade2");
+        assertTrue(encoder.acceptWay(way) > 0);
+        way.setTag("tracktype", "grade4");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "no");
+        way.setTag("motorcar", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "service");
+        way.setTag("access", "delivery");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("highway", "unclassified");
+        way.setTag("ford", "yes");
+        assertFalse(encoder.acceptWay(way) > 0);
+        way.setTag("motorcar", "yes");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("route", "ferry");
+        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.isFerry(encoder.acceptWay(way)));
+        way.setTag("motorcar", "no");
+        assertFalse(encoder.acceptWay(way) > 0);
+
+        way.clearTags();
+        way.setTag("route", "ferry");
+        way.setTag("foot", "yes");
+        assertFalse(encoder.acceptWay(way) > 0);
+        assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+    }
+    
+    @Test 
+    public void testStartStopOnlySections() 
+    {
+    	 OSMWay way = new OSMWay(1);
+         way.setTag("highway", "tertiary");
+         int key = 100;
+         
+         assertEquals("tertiary should be accesible unless stated otherwise", 0, (encoder.getLong(encoder.handleWayTags(way, 0L, 0L), key )));
+         
+         way.setTag("access", "no");
+         assertEquals("tertiary with no access should only be accessible as a start or end point", 1, (encoder.getLong(encoder.handleWayTags(way, 0L, 0L), key )));
+         
+         way.setTag("access", "private");
+         assertEquals("tertiary with private access (publically accessible) should always be vaid for emergencies", 0, (encoder.getLong(encoder.handleWayTags(way, 0L, 0L), key )));
+    }
+    
+    @Test
+    public void testOneway()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "primary");
+        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.setTag("oneway", "yes");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:forward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertFalse(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        way.clearTags();
+
+        way.setTag("highway", "tertiary");
+        way.setTag("vehicle:backward", "no");
+        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        way.clearTags();
+    }
+
+    @Test
+    public void testMilitaryAccess()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("access", "military");
+        assertTrue(encoder.acceptWay(way) > 0);
+    }
+
+    @Test
+    public void testSetAccess()
+    {
+        assertTrue(encoder.isForward(encoder.setProperties(0, true, true)));
+        assertTrue(encoder.isBackward(encoder.setProperties(0, true, true)));
+
+        assertTrue(encoder.isForward(encoder.setProperties(0, true, false)));
+        assertFalse(encoder.isBackward(encoder.setProperties(0, true, false)));
+
+        assertFalse(encoder.isForward(encoder.setProperties(0, false, true)));
+        assertTrue(encoder.isBackward(encoder.setProperties(0, false, true)));
+
+        assertTrue(encoder.isForward(encoder.flagsDefault(true, true)));
+        assertTrue(encoder.isBackward(encoder.flagsDefault(true, true)));
+
+        assertTrue(encoder.isForward(encoder.flagsDefault(true, false)));
+        assertFalse(encoder.isBackward(encoder.flagsDefault(true, false)));
+
+        long flags = encoder.flagsDefault(true, true);
+        // disable access
+        assertFalse(encoder.isForward(encoder.setAccess(flags, false, false)));
+        assertFalse(encoder.isBackward(encoder.setAccess(flags, false, false)));
+    }
+
+    @Test
+    public void testMaxSpeed()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "trunk");
+        way.setTag("maxspeed", "500");
+        long allowed = encoder.acceptWay(way);
+        long encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "primary");
+        way.setTag("maxspeed:backward", "10");
+        way.setTag("maxspeed:forward", "20");
+        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(10, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "primary");
+        way.setTag("maxspeed:forward", "20");
+        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "primary");
+        way.setTag("maxspeed:backward", "20");
+        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
+        assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+    }
+
+    @Test
+    public void testSpeed()
+    {
+        // limit bigger than default road speed
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "trunk");
+        way.setTag("maxspeed", "110");
+        long allowed = encoder.acceptWay(way);
+        long encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "residential");
+        way.setTag("surface", "cobblestone");
+        allowed = encoder.acceptWay(way);
+        encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(30, encoder.getSpeed(encoded), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        allowed = encoder.acceptWay(way);
+        encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(15, encoder.getSpeed(encoded), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "track");
+        way.setTag("tracktype", "grade1");
+        allowed = encoder.acceptWay(way);
+        encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+
+        try
+        {
+            encoder.setSpeed(0, -1);
+            assertTrue(false);
+        } catch (IllegalArgumentException ex)
+        {
+        }
+    }
+    
+    @Test
+    public void testMaxSpeedType()
+    {
+        // limit bigger than default road speed
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "primary");
+        way.setTag("maxspeed:type", "GB:nsl_dual");
+        long allowed = encoder.acceptWay(way);
+        long encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(truncateSpeedToMax(), encoder.getSpeed(encoded), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "secondary");
+        way.setTag("maxspeed:type", "GB:nsl_single");
+        allowed = encoder.acceptWay(way);
+        encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(factorSpeed(CarFlagEncoder.SIXTY_MPH_IN_KPH), encoder.getSpeed(encoded), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "motorway");
+        way.setTag("maxspeed:type", "GB:motorway");
+        allowed = encoder.acceptWay(way);
+        encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(truncateSpeedToMax(), encoder.getSpeed(encoded), 1e-1);
+
+        way.clearTags();
+        way.setTag("highway", "secondary");
+        way.setTag("maxspeed", "30 mph");
+        way.setTag("maxspeed:type", "GB:nsl_single");
+        allowed = encoder.acceptWay(way);
+        encoded = encoder.handleWayTags(way, allowed, 0);
+        assertEquals(factorSpeed(CarFlagEncoder.THIRTY_MPH_IN_KPH), encoder.getSpeed(encoded), 1e-1);
+
+        try
+        {
+            encoder.setSpeed(0, -1);
+            assertTrue(false);
+        } catch (IllegalArgumentException ex)
+        {
+        }
+    }
+
+	private int truncateSpeedToMax()
+    {
+	    int factorSpeed = factorSpeed(CarFlagEncoder.SEVENTY_MPH_IN_KPH);
+		return factorSpeed>encoder.maxPossibleSpeed?encoder.maxPossibleSpeed:factorSpeed;
+    }
+
+	private int factorSpeed(int speed )
+    {
+	    return Math.round(speed/5)*5;
+    }
+
+    @Test
+    public void testSetSpeed()
+    {
+        assertEquals(10, encoder.getSpeed(encoder.setSpeed(0, 10)), 1e-1);
+    }
+
+    @Test
+    public void testRoundabout()
+    {
+        long flags = encoder.setAccess(0, true, true);
+        long resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, true);
+        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
+
+        resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, false);
+        assertFalse(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
+        assertTrue(encoder.isForward(resFlags));
+        assertTrue(encoder.isBackward(resFlags));
+
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "motorway");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isForward(flags));
+        assertTrue(encoder.isBackward(flags));
+        assertFalse(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+
+        way.setTag("junction", "roundabout");
+        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
+        assertTrue(encoder.isForward(flags));
+        assertFalse(encoder.isBackward(flags));
+        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+    }
+
+    @Test
+    public void testRailway()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "secondary");
+        way.setTag("railway", "rail");
+        // disallow rail
+        assertTrue(encoder.acceptWay(way) == 0);
+
+        way.clearTags();
+        way.setTag("highway", "path");
+        way.setTag("railway", "abandoned");
+        assertTrue(encoder.acceptWay(way) == 0);
+
+        // on disallowed highway, railway is allowed, sometimes incorrectly mapped
+        way.setTag("highway", "track");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        // this is fully okay as sometimes old rails are on the road
+        way.setTag("highway", "primary");
+        way.setTag("railway", "historic");
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way.setTag("motorcar", "no");
+        assertTrue(encoder.acceptWay(way) == 0);
+
+        way = new OSMWay(1);
+        way.setTag("highway", "secondary");
+        way.setTag("railway", "tram");
+        // but allow tram to be on the same way
+        assertTrue(encoder.acceptWay(way) > 0);
+
+        way = new OSMWay(1);
+        way.setTag("route", "shuttle_train");
+        way.setTag("motorcar", "yes");
+        way.setTag("bicycle", "no");
+        way.setTag("duration", "35");
+        way.setTag("estimated_distance", 50000);
+        // accept
+        assertTrue(encoder.acceptWay(way) > 0);
+        // calculate speed from estimated_distance and duration
+        assertEquals(60, encoder.getSpeed(encoder.handleFerryTags(way, 20, 30, 40)), 1e-1);
+    }
+
+    @Test
+    public void testSwapDir()
+    {
+        long swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, true));
+        assertTrue(encoder.isForward(swappedFlags));
+        assertTrue(encoder.isBackward(swappedFlags));
+
+        swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, false));
+
+        assertFalse(encoder.isForward(swappedFlags));
+        assertTrue(encoder.isBackward(swappedFlags));
+
+        assertEquals(0, encoder.reverseFlags(0));
+    }
+
+    @Test
+    public void testBarrierAccess()
+    {
+        OSMNode node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "lift_gate");
+        node.setTag("access", "yes");
+        // no barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "lift_gate");
+        node.setTag("bicycle", "yes");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "lift_gate");
+        node.setTag("access", "yes");
+        node.setTag("bicycle", "yes");
+        // should this be a barrier for motorcars too?
+        // assertTrue(encoder.handleNodeTags(node) > 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "lift_gate");
+        node.setTag("access", "no");
+        node.setTag("motorcar", "yes");
+        // no barrier!
+        assertTrue(encoder.handleNodeTags(node) == 0);
+
+        node = new OSMNode(1, -1, -1);
+        node.setTag("barrier", "bollard");
+        // barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        // ignore other access tags for absolute barriers!
+        node.setTag("motorcar", "yes");
+        // still barrier!
+        assertTrue(encoder.handleNodeTags(node) > 0);
+    }
+
+    @Test
+    public void testTurnFlagEncoding_noCosts()
+    {
+        FlagEncoder tmpEnc = new CarFlagEncoder(8, 5, 0);
+        EncodingManager em = new EncodingManager(tmpEnc);
+
+        long flags_r0 = tmpEnc.getTurnFlags(true, 0);
+        long flags_0 = tmpEnc.getTurnFlags(false, 0);
+
+        long flags_r20 = tmpEnc.getTurnFlags(true, 0);
+        long flags_20 = tmpEnc.getTurnFlags(false, 20);
+
+        assertEquals(0, tmpEnc.getTurnCost(flags_r0), 1e-1);
+        assertEquals(0, tmpEnc.getTurnCost(flags_0), 1e-1);
+
+        assertEquals(0, tmpEnc.getTurnCost(flags_r20), 1e-1);
+        assertEquals(0, tmpEnc.getTurnCost(flags_20), 1e-1);
+
+        assertFalse(tmpEnc.isTurnRestricted(flags_r0));
+        assertFalse(tmpEnc.isTurnRestricted(flags_0));
+
+        assertFalse(tmpEnc.isTurnRestricted(flags_r20));
+        assertFalse(tmpEnc.isTurnRestricted(flags_20));
+    }
+
+    @Test
+    public void testTurnFlagEncoding_withCosts()
+    {
+        FlagEncoder tmpEncoder = new CarFlagEncoder(8, 5, 127);
+        EncodingManager em = new EncodingManager(tmpEncoder);
+
+        long flags_r0 = tmpEncoder.getTurnFlags(true, 0);
+        long flags_0 = tmpEncoder.getTurnFlags(false, 0);
+        assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r0)));
+        assertEquals(0, tmpEncoder.getTurnCost(flags_0), 1e-1);
+        assertTrue(tmpEncoder.isTurnRestricted(flags_r0));
+        assertFalse(tmpEncoder.isTurnRestricted(flags_0));
+
+        long flags_r20 = tmpEncoder.getTurnFlags(true, 0);
+        long flags_20 = tmpEncoder.getTurnFlags(false, 20);
+        assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r20)));
+        assertEquals(20, tmpEncoder.getTurnCost(flags_20), 1e-1);
+        assertTrue(tmpEncoder.isTurnRestricted(flags_r20));
+        assertFalse(tmpEncoder.isTurnRestricted(flags_20));
+
+        long flags_r220 = tmpEncoder.getTurnFlags(true, 0);
+        try
+        {
+            tmpEncoder.getTurnFlags(false, 220);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+        assertTrue(Double.isInfinite(tmpEncoder.getTurnCost(flags_r220)));
+        assertTrue(tmpEncoder.isTurnRestricted(flags_r220));
+    }
+
+    @Test
+    public void testMaxValue()
+    {
+        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        EncodingManager em = new EncodingManager(instance);
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "motorway_link");
+        way.setTag("maxspeed", "60 mph");
+        long flags = instance.handleWayTags(way, 1, 0);
+
+        // double speed = AbstractFlagEncoder.parseSpeed("60 mph");
+        // => 96.56 * 0.9 => 86.9
+        assertEquals(86.9, instance.getSpeed(flags), 1e-1);
+        flags = instance.reverseFlags(flags);
+        assertEquals(86.9, instance.getSpeed(flags), 1e-1);
+        
+        // test that maxPossibleValue  is not exceeded
+        way = new OSMWay(2);
+        way.setTag("highway", "motorway_link");
+        way.setTag("maxspeed", "70 mph");
+        flags = instance.handleWayTags(way, 1, 0);
+        assertEquals(100, instance.getSpeed(flags), 1e-1);
+    }
+
+    @Test
+    public void testRegisterOnlyOnceAllowed()
+    {
+        CarFlagEncoder instance = new CarFlagEncoder(8, 0.5, 0);
+        EncodingManager em = new EncodingManager(instance);
+        try
+        {
+            em = new EncodingManager(instance);
+            assertTrue(false);
+        } catch (IllegalStateException ex)
+        {
+        }
+    }
+
+    @Test
+    public void testSetToMaxSpeed()
+    {
+        OSMWay way = new OSMWay(12);
+        way.setTag("maxspeed", "90");
+        assertEquals(90, encoder.getMaxSpeed(way), 1e-2);
+    }
+
+    @Test
+    public void testFordAccess()
+    {
+        OSMNode node = new OSMNode(0, 0.0, 0.0);
+        node.setTag("ford", "yes");
+
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "unclassified");
+        way.setTag("ford", "yes");
+
+        // Node and way are initially blocking
+        assertTrue(encoder.isBlockFords());
+        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.handleNodeTags(node) > 0);
+
+        try
+        {
+            // Now they are passable
+            encoder.setBlockFords(false);
+            assertTrue(encoder.acceptWay(way) > 0);
+            assertFalse(encoder.handleNodeTags(node) > 0);
+        } finally
+        {
+            encoder.setBlockFords(true);
+        }
+    }
+
+    @Test
+    public void testCombination()
+    {
+        OSMWay way = new OSMWay(123);
+        way.setTag("highway", "cycleway");
+        way.setTag("sac_scale", "hiking");        
+
+        long flags = em.acceptWay(way);
+        long edgeFlags = em.handleWayTags(way, flags, 0);
+        assertFalse(encoder.isBackward(edgeFlags));
+        assertFalse(encoder.isForward(edgeFlags));
+        assertTrue(em.getEncoder("bike").isBackward(edgeFlags));
+        assertTrue(em.getEncoder("bike").isForward(edgeFlags));
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/ApiResource.java b/web/src/main/java/com/graphhopper/http/ApiResource.java
index a924dffbc7..65e744a26a 100644
--- a/web/src/main/java/com/graphhopper/http/ApiResource.java
+++ b/web/src/main/java/com/graphhopper/http/ApiResource.java
@@ -4,15 +4,16 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.servlet.http.HttpServletRequest;
 
 public enum ApiResource
 {
 	ROUTE("route", new String[] { "point", "vehicle" }, new String[] { "point", "vehicle",
-	        "locale", "instructions", "weighting", "algorithm", "points_encoded", "debug",
-	        "pretty", "calc_points", "type", "avoidances" }), NEAREST("nearest",
-	        new String[] { "point" }, new String[] { "point" }), INFO("info", new String[] {},
-	        new String[] {});
+			"locale", "instructions", "weighting", "algorithm", "points_encoded", "debug",
+			"pretty", "calc_points", "type", "avoidances" }), NEAREST("nearest",
+					new String[] { "point" }, new String[] { "point" }), INFO("info", new String[] {},
+							new String[] {});
 
 	public String[] getMandatoryValues()
 	{
@@ -52,7 +53,7 @@ private ApiResource( String resourceName, String[] mandatoryValues, String[] val
 	 * @throws NoSuchParameterException
 	 */
 	public void checkAllRequestParameters( HttpServletRequest request )
-	        throws MissingParameterException, NoSuchParameterException, InvalidParameterException
+			throws MissingParameterException, NoSuchParameterException, InvalidParameterException
 	{
 		// Check if the mandatory parameter exists in the request
 		String value = this.getMandatoryValues()[0];
@@ -104,11 +105,11 @@ private void checkValidParameters( HttpServletRequest request ) throws NoSuchPar
 		Map<String, String[]> parameterMap = request.getParameterMap();
 		for (Map.Entry<String, String[]> entry : parameterMap.entrySet())
 		{
-			String parameterName = entry.getKey().toLowerCase();
-			if (!list.contains(parameterName))
+			String name = entry.getKey().toLowerCase();
+			if (!list.contains(name))
 			{
-				throw new NoSuchParameterException(getInvalidPara​meterMessage(parameterName,
-				        this.getResourceName(), this.getValidValues()));
+				String msg = getInvalidPara​meterMessage(name, getResourceName(), getValidValues());
+				throw new NoSuchParameterException(msg);
 			}
 		}
 	}
@@ -122,12 +123,12 @@ private void checkValidParameters( HttpServletRequest request ) throws NoSuchPar
 	 * @return message String
 	 */
 	private String getInvalidPara​meterMessage( String invalid, String parameter,
-	        String[] validValues )
+			String[] validValues )
 	{
 		StringBuilder sb = new StringBuilder();
 
 		sb.append("Parameter ").append(invalid).append(" is not a valid parameter for resource ")
-		        .append(parameter).append(". Valid parameters for requested resource are ");
+		.append(parameter).append(". Valid parameters for requested resource are ");
 
 		List<String> validList = Arrays.asList(validValues);
 		for (String valid : validList)
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index d0aa9dd79c..698a32ef23 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -41,6 +41,7 @@
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamResult;
 
+import org.eclipse.jetty.http.HttpStatus;
 import org.json.JSONObject;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
@@ -82,7 +83,7 @@
 
 	@Override
 	public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
-	        throws ServletException, IOException
+			throws ServletException, IOException
 	{
 
 		List<GHPoint> infoPoints = getPoints(httpReq, "point");
@@ -93,10 +94,10 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
 		boolean enableElevation = getBooleanParam(httpReq, "elevation", false);
 		boolean pointsEncoded = getBooleanParam(httpReq, "points_encoded", true);
 
-		String vehicleStr = getParam(httpReq, "vehicle", "car");
+		String vehicleStr = getParam(httpReq, "vehicle", null);
 		String weighting = getParam(httpReq, "weighting", "fastest");
-		String algoStr = getParam(httpReq, "algorithm", "");
-		String localeStr = getParam(httpReq, "locale", "en");
+		String algoStr = getParam(httpReq, "algorithm", null);
+		String localeStr = getParam(httpReq, "locale", "en").replace('-', '_');
 
 		StopWatch sw = new StopWatch().start();
 		GHResponse ghRsp = null;
@@ -115,52 +116,55 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
 			// coordinates
 
 			if (!new CaseInsensitiveStringListValidator()
-			        .isValid(localeStr, TranslationMap.LOCALES))
+			.isValid(localeStr, TranslationMap.LOCALES))
 			{
 				String errMesg = buildErrorMessageString(localeStr, "locale",
-				        TranslationMap.LOCALES);
-				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg.toString()));
-			} else if (!new CaseInsensitiveStringListValidator().isValid(algoStr,
-			        AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI, AlgorithmOptions.DIJKSTRA,
-			        AlgorithmOptions.DIJKSTRA_BI, AlgorithmOptions.DIJKSTRA_ONE_TO_MANY))
+						TranslationMap.LOCALES);
+				ghRsp = new GHResponse()
+				        .addError(new InvalidParameterException(errMesg.toString()));
+			} else if (null != algoStr
+			        && !new CaseInsensitiveStringListValidator().isValid(algoStr,
+			                AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
+			                AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
+			                AlgorithmOptions.DIJKSTRA_ONE_TO_MANY))
 			{
 				String errMesg = buildErrorMessageString(algoStr, "algorithm",
-				        AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
-				        AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
-				        AlgorithmOptions.DIJKSTRA_ONE_TO_MANY);
-				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+						AlgorithmOptions.ASTAR, AlgorithmOptions.ASTAR_BI,
+						AlgorithmOptions.DIJKSTRA, AlgorithmOptions.DIJKSTRA_BI,
+						AlgorithmOptions.DIJKSTRA_ONE_TO_MANY);
+				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (!new BooleanValidator().isValid(instructionsString))
 			{
 				String errMesg = buildBooleanErrorMessageString(instructionsString, "instructions");
-				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (!new BooleanValidator().isValid(pointsEncodedString))
 			{
 				String errMesg = buildBooleanErrorMessageString(pointsEncodedString,
-				        "points_encoded");
-				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+						"points_encoded");
+				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (!new BooleanValidator().isValid(calcPointsString))
 			{
 				String errMesg = buildBooleanErrorMessageString(calcPointsString, "calc_points");
-				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (!new BooleanValidator().isValid(debugString))
 			{
 				String errMesg = buildBooleanErrorMessageString(debugString, "debug");
-				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (!new BooleanValidator().isValid(prettyString))
 			{
 				String errMesg = buildBooleanErrorMessageString(prettyString, "pretty");
-				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (!hopper.getEncodingManager().supports(vehicleStr))
 			{
 				String supported = hopper.getGraph().getEncodingManager().toString();
 				String errMesg = String.format(
-				        "Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr,
-				        supported);
-				ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg));
+						"Vehicle %s is not a valid vehicle. Valid vehicles are %s", vehicleStr,
+						supported);
+				ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg));
 			} else if (enableElevation && !hopper.hasElevation())
 			{
-				ghRsp = new GHResponse().addError(new IllegalArgumentException(
-				        "Elevation not supported!"));
+				ghRsp = new GHResponse().addError(new InvalidParameterException(
+						"Elevation not supported!"));
 			} else
 			{
 				FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
@@ -168,14 +172,13 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
 				// Lots of lovely braces. I will tidy this up next week... promise!
 				if (avoidancesString != null)
 				{
-					System.out.println("Avoidances for " + algoVehicle);
 					List<String> allowedAvoidances = new ArrayList<>();
 					// Check Avoidances
 					if (algoVehicle instanceof AbstractFlagEncoder)
 					{
 						AbstractFlagEncoder abstractFlagEncoder = (AbstractFlagEncoder) algoVehicle;
 						List<EncoderDecorator> encoderDecorators = abstractFlagEncoder
-						        .getEncoderDecorators();
+								.getEncoderDecorators();
 						if (encoderDecorators != null)
 						{
 							for (EncoderDecorator encoderDecorator : encoderDecorators)
@@ -184,18 +187,22 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
 								{
 									AbstractAvoidanceDecorator abstractAvoidanceDecorator = (AbstractAvoidanceDecorator) encoderDecorator;
 									allowedAvoidances.addAll(Arrays
-									        .asList(abstractAvoidanceDecorator
-									                .getEdgeAttributesOfInterestNames()));
+											.asList(abstractAvoidanceDecorator
+													.getEdgeAttributesOfInterestNames()));
 								}
 							}
 						}
 					}
-					if (!allowedAvoidances.contains(avoidancesString))
+					String avoidanceArray[] = avoidancesString.split(",");
+					for (String avoidance : avoidanceArray)
 					{
-						String errMesg = buildErrorMessageString(avoidancesString, "avoidances",
-						        allowedAvoidances);
-						ghRsp = new GHResponse().addError(new IllegalArgumentException(errMesg
-						        .toString()));
+						if (!allowedAvoidances.contains(avoidance.trim()))
+						{
+							String errMesg = buildErrorMessageString(avoidance, "avoidances",
+							        allowedAvoidances);
+							ghRsp = new GHResponse().addError(new InvalidParameterException(errMesg
+							        .toString()));
+						}
 					}
 				}
 
@@ -205,9 +212,9 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
 
 					initHints(request, httpReq.getParameterMap());
 					request.setVehicle(algoVehicle.toString()).setWeighting(weighting)
-					        .setAlgorithm(algoStr).setLocale(localeStr).getHints()
-					        .put("calcPoints", calcPoints).put("instructions", enableInstructions)
-					        .put("wayPointMaxDistance", minPathPrecision);
+					.setAlgorithm(algoStr).setLocale(localeStr).getHints()
+					.put("calcPoints", calcPoints).put("instructions", enableInstructions)
+					.put("wayPointMaxDistance", minPathPrecision);
 					ghRsp = hopper.route(request);
 				}
 			}
@@ -217,16 +224,16 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
 		}
 		float took = sw.stop().getSeconds();
 		String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " "
-		        + httpReq.getHeader("User-Agent");
+				+ httpReq.getHeader("User-Agent");
 		String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
-		        + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
+				+ took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
 
 		if (ghRsp.hasErrors())
 			logger.error(logStr + ", errors:" + ghRsp.getErrors());
 		else
 			logger.info(logStr + ", distance: " + ghRsp.getDistance() + ", time:"
-			        + Math.round(ghRsp.getTime() / 60000f) + "min, points:"
-			        + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
+					+ Math.round(ghRsp.getTime() / 60000f) + "min, points:"
+					+ ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
 
 		if (writeGPX)
 		{
@@ -243,12 +250,12 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
 			if (!"json".equalsIgnoreCase(type) || (!"jsonp".equalsIgnoreCase(type) && jsonpAllowed))
 			{
 				String errorMessage = type
-				        + " is not a valid value for parameter type. Valid values are ";
+						+ " is not a valid value for parameter type. Valid values are ";
 				errorMessage += jsonpAllowed ? "JSON, GPX or JSONP." : "GPX or JSON.";
-				ghRsp.addError(new IllegalArgumentException(errorMessage));
+				ghRsp.addError(new InvalidParameterException(errorMessage));
 			}
 			Map<String, Object> map = createJson(ghRsp, calcPoints, pointsEncoded, enableElevation,
-			        enableInstructions);
+					enableInstructions);
 			Object infoMap = map.get("info");
 			if (infoMap != null)
 				((Map) infoMap).put("took", Math.round(took * 1000));
@@ -264,21 +271,21 @@ public void doGet( HttpServletRequest httpReq, HttpServletResponse httpRes )
 	private String buildBooleanErrorMessageString( String paramValue, String paramName )
 	{
 		return buildErrorMessageString(paramValue, paramName,
-		        Arrays.asList(new String[] { Boolean.TRUE.toString(), Boolean.FALSE.toString() }));
+				Arrays.asList(new String[] { Boolean.TRUE.toString(), Boolean.FALSE.toString() }));
 	}
 
 	private String buildErrorMessageString( String paramValue, String paramName,
-	        String... validValues )
+			String... validValues )
 	{
 		return buildErrorMessageString(paramValue, paramName, Arrays.asList(validValues));
 	}
 
 	private String buildErrorMessageString( String paramValue, String paramName,
-	        List<String> validValues )
+			List<String> validValues )
 	{
 		StringBuilder errMesg = new StringBuilder(paramValue)
-		        .append(" is not a valid value for parameter ").append(paramName)
-		        .append(". Valid values are ");
+		.append(" is not a valid value for parameter ").append(paramName)
+		.append(". Valid values are ");
 		for (int i = 0; i < validValues.size(); i++)
 		{
 			String validStr = validValues.get(i);
@@ -296,7 +303,7 @@ private String buildErrorMessageString( String paramValue, String paramName,
 	}
 
 	protected String createGPXString( HttpServletRequest req, HttpServletResponse res,
-	        GHResponse rsp )
+			GHResponse rsp )
 	{
 		boolean includeElevation = getBooleanParam(req, "elevation", false);
 		res.setCharacterEncoding("UTF-8");
@@ -357,8 +364,8 @@ String errorsToXML( List<Throwable> list )
 	}
 
 	protected Map<String, Object> createJson( GHResponse rsp, boolean calcPoints,
-	        boolean pointsEncoded, boolean includeElevation, boolean enableInstructions )
-	{
+			boolean pointsEncoded, boolean includeElevation, boolean enableInstructions )
+			{
 		Map<String, Object> json = new HashMap<String, Object>();
 
 		if (rsp.hasErrors())
@@ -367,7 +374,13 @@ String errorsToXML( List<Throwable> list )
 			json.put("error", map);
 			Throwable throwable = rsp.getErrors().get(0);
 			map.put("message", throwable.getMessage());
-			map.put("statuscode", ((APIException) throwable).getStatusCode().toString());
+			String statusCode = "" + HttpStatus.BAD_REQUEST_400;
+			if (throwable instanceof APIException)
+			{
+				statusCode = ((APIException) throwable).getStatusCode().toString();
+				logger.error("Unhandled exception, defaulting it to 400");
+			}
+			map.put("statuscode", statusCode);
 			List<Map<String, String>> list = new ArrayList<Map<String, String>>();
 			for (Throwable t : rsp.getErrors())
 			{
@@ -400,7 +413,7 @@ String errorsToXML( List<Throwable> list )
 				{
 					BBox maxBounds = hopper.getGraph().getBounds();
 					BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon,
-					        maxBounds.minLat, maxBounds.maxLat);
+							maxBounds.minLat, maxBounds.maxLat);
 					jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
 				}
 
@@ -415,7 +428,7 @@ String errorsToXML( List<Throwable> list )
 			json.put("paths", Collections.singletonList(jsonPath));
 		}
 		return json;
-	}
+			}
 
 	protected Object createPoints( PointList points, boolean pointsEncoded, boolean includeElevation )
 	{
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index f47267d105..406a13c6a1 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -22,7 +22,9 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+
 import java.util.List;
+
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -116,9 +118,14 @@ public GHResponse route( GHRequest request )
                     + "&instructions=" + tmpInstructions
                     + "&points_encoded=true"
                     + "&calc_points=" + tmpCalcPoints
-                    + "&algo=" + request.getAlgorithm()
-                    + "&locale=" + request.getLocale().toString()
-                    + "&elevation=" + tmpElevation;
+                    + "&locale=" + request.getLocale().toString();
+            String algorithm = request.getAlgorithm();
+			if(algorithm!=null  && algorithm.trim().length()>0) {
+            	url += "&algorithm=" + algorithm;
+            }
+            if (tmpElevation) {
+            	url += "&elevation=" + tmpElevation;
+            }
 
             if (!request.getVehicle().isEmpty())
                 url += "&vehicle=" + request.getVehicle();
diff --git a/web/src/main/webapp/.ebextensions/server-update.config b/web/src/main/webapp/.ebextensions/server-update.config
index f41799db91..6e3bea96e4 100644
--- a/web/src/main/webapp/.ebextensions/server-update.config
+++ b/web/src/main/webapp/.ebextensions/server-update.config
@@ -1,5 +1,5 @@
 files:
-    "/download.sh" :
+    "/download-post-deploy.sh" :
         owner: root
         group: root
         mode: "000755"
@@ -7,14 +7,14 @@ files:
             #!/bin/bash
             
             # Remove the existing env_vars.sh so it can be replaced
-            /opt/elasticbeanstalk/hooks/appdeploy/post/99_update_osplaces_key.sh
+            rm /opt/elasticbeanstalk/hooks/appdeploy/post/99_post_deploy.sh
             
             # Download the file in a location and name that will get executed AFTER the container_commands have been executed and the application deployed 
-            AWS_SECRET_ACCESS_KEY=${AWS_SECRET_KEY} aws s3 cp --region eu-west-1 s3://${CONFIG_BUCKET}/env_vars.sh /opt/elasticbeanstalk/hooks/appdeploy/post/99_update_osplaces_key.sh
+            AWS_SECRET_ACCESS_KEY=${AWS_SECRET_KEY} aws s3 cp --region eu-west-1 s3://${CONFIG_BUCKET}/post_deploy.sh /opt/elasticbeanstalk/hooks/appdeploy/post/99_post_deploy.sh
             
-            more /opt/elasticbeanstalk/hooks/appdeploy/post/99_update_osplaces_key.sh
+            #more /opt/elasticbeanstalk/hooks/appdeploy/post/99_post_deploy.sh
             
-            chmod a+x /opt/elasticbeanstalk/hooks/appdeploy/post/99_update_osplaces_key.sh
+            chmod a+x /opt/elasticbeanstalk/hooks/appdeploy/post/99_post_deploy.sh
                         
     "/extract.sh" :
         owner: root
@@ -24,8 +24,8 @@ files:
             #!/bin/bash
             # Remove the existing config.properties so it can be replaced
             rm -f /config.properties
-            #fetch the preingested routing data
-            AWS_SECRET_ACCESS_KEY=${AWS_SECRET_KEY} aws s3 cp --region eu-west-1 s3://${CONFIG_BUCKET}/${ROUTING_ARCHIVE} .
+            #fetch the preingested routing data to /
+            AWS_SECRET_ACCESS_KEY=${AWS_SECRET_KEY} aws s3 cp --region eu-west-1 s3://${CONFIG_BUCKET}/${ROUTING_ARCHIVE} /
             #fetch applicatio config file
             AWS_SECRET_ACCESS_KEY=${AWS_SECRET_KEY} aws s3 cp --region eu-west-1 s3://${CONFIG_BUCKET}/${ROUTING_CONFIG} /config.properties
             
@@ -34,10 +34,14 @@ files:
             rm -rf ${graphhopper_graph_location}
 
             # Extract the route data
-            tar xvjf ${ROUTING_ARCHIVE} -C /
+            ROUTING_ARCHIVE_FILE=`basename ${ROUTING_ARCHIVE}` 
+            tar xvjf /${ROUTING_ARCHIVE_FILE} -C /
+
+            rm /${ROUTING_ARCHIVE_FILE}
 
             # Change the owner to tomcat
-            chown -R tomcat:tomcat ${graphhopper_graph_location}
+            chown -R tomcat:tomcat ${graphhopper_graph_location}            
+
             
 commands:
     01-install-awscli:
@@ -48,7 +52,7 @@ commands:
 
 container_commands:
     03-download-env-vars:
-        command: /download.sh
+        command: /download-post-deploy.sh
     04-download-s3-asset-and-extract:
         command: /extract.sh 
     
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index 47e3a09ad5..5e8c5d4535 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -412,7 +412,7 @@ GHRequest.prototype.createURL = function () {
 };
 
 GHRequest.prototype.createGPXURL = function () {
-    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=gpx);
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=gpx");
 };
 
 GHRequest.prototype.createHistoryURL = function () {
diff --git a/web/src/test/java/com/graphhopper/http/ApiResourceTest.java b/web/src/test/java/com/graphhopper/http/ApiResourceTest.java
new file mode 100644
index 0000000000..9d3d055224
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/ApiResourceTest.java
@@ -0,0 +1,126 @@
+package com.graphhopper.http;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.when;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.runners.MockitoJUnitRunner;
+
+//The values of parameters are immaterial, there are only two classes of equivalence: [nullPointer] and [nonNullString].
+//One distinguishes between 'thenReturn(null)' and 'thenReturn(*nonNullString*)' only.
+
+@RunWith(MockitoJUnitRunner.class)
+public class ApiResourceTest
+{
+
+	@Mock
+	HttpServletRequest request;
+
+	ApiResource apiResource = ApiResource.ROUTE;
+
+	@Test
+	public void testPointIsMandatoryParam() throws NoSuchParameterException,
+	        InvalidParameterException
+	{
+		when(request.getParameterMap()).thenReturn(Collections.<String, String[]> emptyMap());
+		try
+		{
+			apiResource.checkAllRequestParameters(request);
+			fail("No exception thrown");
+		} catch (MissingParameterException mpe)
+		{
+			assertEquals("No point parameter provided.", mpe.getMessage());
+		}
+	}
+
+	@Test
+	public void testVehicleIsMandatoryParam() throws NoSuchParameterException,
+	        InvalidParameterException
+	{
+		Map<String, String[]> paramWithPoint = new HashMap<>();
+		paramWithPoint.put("point", new String[] { "testval" });
+		when(request.getParameterMap()).thenReturn(paramWithPoint);
+		try
+		{
+			apiResource.checkAllRequestParameters(request);
+			fail("No exception thrown");
+		} catch (MissingParameterException mpe)
+		{
+			assertEquals("No vehicle parameter provided.", mpe.getMessage());
+		}
+	}
+
+	@Test
+	public void testAllMandatoryAndAllValidParameters()
+	{
+		Map<String, String[]> allParameters = new HashMap<>();
+		// mandatory
+		allParameters.put("point", new String[] { "0" });
+		allParameters.put("vehicle", new String[] { "car" });
+		// valid
+		allParameters.put("locale", new String[] { "x" });
+		allParameters.put("instructions", new String[] { "x" });
+		allParameters.put("weighting", new String[] { "x" });
+		allParameters.put("algorithm", new String[] { "x" });
+		allParameters.put("points_encoded", new String[] { "x" });
+		allParameters.put("debug", new String[] { "x" });
+		allParameters.put("pretty", new String[] { "x" });
+		allParameters.put("calc_points", new String[] { "x" });
+		allParameters.put("type", new String[] { "x" });
+		allParameters.put("avoidances", new String[] { "x" });
+		when(request.getParameterMap()).thenReturn(allParameters);
+		try
+		{
+			apiResource.checkAllRequestParameters(request);
+		} catch (MissingParameterException | NoSuchParameterException | InvalidParameterException e)
+		{
+			fail(e.getMessage());
+		}
+
+	}
+
+	@Test
+	public void testAllMandatoryAllValidParametersAndIncorrectOnes()
+	{
+		Map<String, String[]> allParameters = new HashMap<>();
+		// mandatory
+		allParameters.put("point", new String[] { "0" });
+		allParameters.put("vehicle", new String[] { "car" });
+		// valid
+		allParameters.put("locale", new String[] { "x" });
+		allParameters.put("instructions", new String[] { "x" });
+		allParameters.put("weighting", new String[] { "x" });
+		allParameters.put("algorithm", new String[] { "x" });
+		allParameters.put("points_encoded", new String[] { "x" });
+		allParameters.put("debug", new String[] { "x" });
+		allParameters.put("pretty", new String[] { "x" });
+		allParameters.put("calc_points", new String[] { "x" });
+		allParameters.put("type", new String[] { "x" });
+		allParameters.put("avoidances", new String[] { "x" });
+		// incorrect
+		allParameters.put("bogus", new String[] { "x" });
+		when(request.getParameterMap()).thenReturn(allParameters);
+		try
+		{
+			apiResource.checkAllRequestParameters(request);
+		} catch (MissingParameterException | InvalidParameterException exception)
+		{
+			fail(exception.getMessage());
+		} catch (NoSuchParameterException e)
+		{
+			assertEquals(
+			        "Parameter bogus is not a valid parameter for resource route. Valid parameters for requested resource are point, vehicle, locale, instructions, weighting, algorithm, points_encoded, debug, pretty, calc_points, type, avoidances.",
+			        e.getMessage());
+		}
+	}
+
+}
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 638f07eab7..795b4c3091 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -59,7 +59,7 @@ public void setUp()
     @Test
     public void testBasicQuery() throws Exception
     {
-        JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128", 200);
+        JSONObject json = query("point=42.554851,1.536198&point=42.510071,1.548128&vehicle=car&locale=en_US", 200);
         JSONObject infoJson = json.getJSONObject("info");
         assertFalse(infoJson.has("errors"));
         JSONObject path = json.getJSONArray("paths").getJSONObject(0);
@@ -71,7 +71,7 @@ public void testBasicQuery() throws Exception
     @Test
     public void testJsonRounding() throws Exception
     {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false", 200);
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&vehicle=car&locale=en_US", 200);
         JSONObject cson = json.getJSONArray("paths").getJSONObject(0).getJSONObject("points");
         assertTrue("unexpected precision!", cson.toString().contains("[1.536374,42.554839]"));
     }
@@ -79,9 +79,9 @@ public void testJsonRounding() throws Exception
     @Test
     public void testFailIfElevationRequestedButNotIncluded() throws Exception
     {
-        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true", 400);
-        assertTrue(json.has("message"));
-        assertEquals("Elevation not supported!", json.get("message"));
+        JSONObject json = query("point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true&vehicle=car&locale=en_US", 400);
+        assertTrue(json.has("error"));
+        assertEquals("Elevation not supported!", json.get("error"));
         assertEquals("Elevation not supported!", json.getJSONArray("hints").getJSONObject(0).getString("message"));
     }
 
@@ -90,7 +90,10 @@ public void testGraphHopperWeb() throws Exception
     {
         GraphHopperAPI hopper = new GraphHopperWeb();
         assertTrue(hopper.load(getTestRouteAPIUrl()));
-        GHResponse rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128));
+        GHRequest request = new GHRequest(42.554851, 1.536198, 42.510071, 1.548128);
+        request.setVehicle("car");
+        request.setLocale("en_US");
+		GHResponse rsp = hopper.route(request);
         assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 9000);
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 9500);
@@ -98,7 +101,7 @@ public void testGraphHopperWeb() throws Exception
         rsp = hopper.route(new GHRequest().
                 addPoint(new GHPoint(42.554851, 1.536198)).
                 addPoint(new GHPoint(42.531896, 1.553278)).
-                addPoint(new GHPoint(42.510071, 1.548128)));
+                addPoint(new GHPoint(42.510071, 1.548128)).setVehicle("car").setLocale("en_US"));
         assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 20000);
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() < 21000);
@@ -147,7 +150,7 @@ public void testGraphHopperWebRealExceptions()
     @Test
     public void testGPX() throws Exception
     {
-        String str = queryString("point=42.554851,1.536198&point=42.510071,1.548128&type=gpx", 200);
+        String str = queryString("point=42.554851,1.536198&point=42.510071,1.548128&type=gpx&vehicle=car&locale=en_US", 200);
         assertTrue(str.contains("<gh:distance>115.1</gh:distance>"));
         assertTrue(str.contains("<trkpt lat=\"42.554839\" lon=\"1.536374\"><time>"));
     }
@@ -155,10 +158,10 @@ public void testGPX() throws Exception
     @Test
     public void testGPXWithError() throws Exception
     {
-        String str = queryString("point=42.554851,1.536198&type=gpx", 400);
+        String str = queryString("point=42.554851,1.536198&type=gpx&vehicle=car&locale=en_US", 400);
         assertFalse(str, str.contains("<html>"));
         assertFalse(str, str.contains("{"));
         assertTrue("Expected error but was: " + str, str.contains("<message>At least 2 points has to be specified, but was:1</message>"));
-        assertTrue("Expected error but was: " + str, str.contains("<hints><error details=\"java"));
+        assertTrue("Expected error but was: " + str, str.contains("<hints>"));
     }
 }
