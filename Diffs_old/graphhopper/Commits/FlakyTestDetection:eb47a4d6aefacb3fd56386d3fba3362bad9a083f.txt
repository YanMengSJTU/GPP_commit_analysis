diff --git a/client-hc/pom.xml b/client-hc/pom.xml
new file mode 100644
index 0000000000..4335aa22d6
--- /dev/null
+++ b/client-hc/pom.xml
@@ -0,0 +1,130 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~  Licensed to GraphHopper GmbH under one or more contributor
+  ~  license agreements. See the NOTICE file distributed with this work for
+  ~  additional information regarding copyright ownership.
+  ~
+  ~  GraphHopper GmbH licenses this file to you under the Apache License,
+  ~  Version 2.0 (the "License"); you may not use this file except in
+  ~  compliance with the License. You may obtain a copy of the License at
+  ~
+  ~       http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~  Unless required by applicable law or agreed to in writing, software
+  ~  distributed under the License is distributed on an "AS IS" BASIS,
+  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  See the License for the specific language governing permissions and
+  ~  limitations under the License.
+  -->
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.graphhopper</groupId>
+    <artifactId>directions-api-client-hc</artifactId>
+    <version>0.10-SNAPSHOT</version>
+    <packaging>jar</packaging>
+    <name>GraphHopper Directions API hand-crafted Java Client. For the Matrix and Routing API only</name>
+     
+    <parent>
+        <groupId>com.graphhopper</groupId>
+        <artifactId>graphhopper-parent</artifactId>
+        <version>0.10-SNAPSHOT</version>
+    </parent>  
+    
+    <properties>
+        <slf4j.version>1.7.21</slf4j.version>        
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+    </properties>
+    
+    <dependencies>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-core</artifactId>
+            <version>${project.parent.version}</version>
+            <exclusions>
+                <!-- We cannot yet exclude this as e.g. Helper class uses trove classes
+                     and Helper is used e.g. in PointList
+                <exclusion>
+                    <groupId>net.sf.trove4j</groupId>
+                    <artifactId>trove4j</artifactId>
+                </exclusion>
+                -->
+                <exclusion>
+                    <groupId>org.apache.xmlgraphics</groupId>
+                    <artifactId>xmlgraphics-commons</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+            <!-- TODO how to sync with GH? -->
+            <version>2.8.4</version>
+        </dependency>
+
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>okhttp</artifactId>
+            <version>3.8.0</version>
+        </dependency>
+        
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-api</artifactId>
+            <version>${slf4j.version}</version>
+        </dependency>   
+        
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-log4j12</artifactId>
+            <version>${slf4j.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>log4j</groupId>
+            <artifactId>log4j</artifactId>
+            <version>1.2.17</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.12</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.3</version>
+                <configuration>
+                    <compilerArgument>-XDignore.symbol.file</compilerArgument>
+                    <fork>true</fork>
+                    <source>1.7</source>
+                    <target>1.7</target>
+                </configuration>
+            </plugin>
+            
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-failsafe-plugin</artifactId>
+                <version>2.19.1</version>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>integration-test</goal>
+                            <goal>verify</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>        
+    </build>
+        
+</project>
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
new file mode 100644
index 0000000000..cb8fb0b731
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
@@ -0,0 +1,98 @@
+package com.graphhopper.api;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * @author Peter Karich
+ */
+public class GHMRequest extends GHRequest {
+
+    private List<GHPoint> fromPoints;
+    private List<GHPoint> toPoints;
+    boolean identicalLists = true;
+    private final Set<String> outArrays = new HashSet<String>(5);
+
+    public GHMRequest() {
+        this(10);
+    }
+
+    public GHMRequest(int size) {
+        super(0);
+        fromPoints = new ArrayList<GHPoint>(size);
+        toPoints = new ArrayList<GHPoint>(size);
+    }
+
+    /**
+     * Currently: weights, times, distances and paths possible. Where paths is
+     * the most expensive to calculate and limited to maximum 10*10 points (via
+     * API end point).
+     */
+    public GHMRequest addOutArray(String type) {
+        outArrays.add(type);
+        return this;
+    }
+
+    public Set<String> getOutArrays() {
+        return outArrays;
+    }
+
+    public GHMRequest addAllPoints(List<GHPoint> points) {
+        for (GHPoint p : points) {
+            addPoint(p);
+        }
+        return this;
+    }
+
+    @Override
+    public List<GHPoint> getPoints() {
+        throw new IllegalStateException("use getFromPlaces or getToPlaces");
+    }
+
+    public List<GHPoint> getFromPoints() {
+        return fromPoints;
+    }
+
+    public List<GHPoint> getToPoints() {
+        return toPoints;
+    }
+
+    /**
+     * This methods adds the places as 'from' and 'to' place to the request.
+     */
+    @Override
+    public GHMRequest addPoint(GHPoint point) {
+        fromPoints.add(point);
+        toPoints.add(point);
+        return this;
+    }
+
+    public GHMRequest addFromPoint(GHPoint point) {
+        fromPoints.add(point);
+        identicalLists = false;
+        return this;
+    }
+
+    public GHMRequest addFromPoints(List<GHPoint> points) {
+        fromPoints = points;
+        identicalLists = false;
+        return this;
+    }
+
+    public GHMRequest addToPoint(GHPoint point) {
+        toPoints.add(point);
+        identicalLists = false;
+        return this;
+    }
+
+    public GHMRequest addToPoints(List<GHPoint> points) {
+        toPoints = points;
+        identicalLists = false;
+        return this;
+    }
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMResponse.java b/client-hc/src/main/java/com/graphhopper/api/GHMResponse.java
new file mode 100644
index 0000000000..b60c21a2c2
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMResponse.java
@@ -0,0 +1,31 @@
+package com.graphhopper.api;
+
+import com.graphhopper.GHResponse;
+
+/**
+ * @author Peter Karich
+ */
+public class GHMResponse extends GHResponse {
+
+    private final int fromIndex;
+    private final int toIndex;
+    private final boolean identicalStartAndEnd;
+
+    public GHMResponse(int fromIndex, int toIndex, boolean identicalStartAndEnd) {
+        this.fromIndex = fromIndex;
+        this.toIndex = toIndex;
+        this.identicalStartAndEnd = identicalStartAndEnd;
+    }
+
+    public boolean isIdenticalStartAndEnd() {
+        return identicalStartAndEnd;
+    }
+
+    public int getFromIndex() {
+        return fromIndex;
+    }
+
+    public int getToIndex() {
+        return toIndex;
+    }
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
new file mode 100644
index 0000000000..5ddffeb716
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
@@ -0,0 +1,225 @@
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.util.Helper;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+
+import java.io.IOException;
+import java.net.URLEncoder;
+import java.util.*;
+import java.util.concurrent.TimeUnit;
+
+import static com.graphhopper.api.GraphHopperMatrixWeb.*;
+
+/**
+ * @author Peter Karich
+ */
+public abstract class GHMatrixAbstractRequester {
+
+    private GraphHopperWeb web = new GraphHopperWeb();
+    protected final ObjectMapper objectMapper;
+    protected final Set<String> ignoreSet = new HashSet<String>(10);
+    protected final String serviceUrl;
+    private OkHttpClient downloader;
+
+    public GHMatrixAbstractRequester() {
+        this("https://graphhopper.com/api/1/matrix");
+    }
+
+    public GHMatrixAbstractRequester(String serviceUrl) {
+        this(serviceUrl, new OkHttpClient.Builder().
+                connectTimeout(5, TimeUnit.SECONDS).
+                readTimeout(5, TimeUnit.SECONDS).build());
+    }
+
+    public GHMatrixAbstractRequester(String serviceUrl, OkHttpClient downloader) {
+        if (serviceUrl.endsWith("/")) {
+            serviceUrl = serviceUrl.substring(0, serviceUrl.length() - 1);
+        }
+        this.downloader = downloader;
+        this.serviceUrl = serviceUrl;
+
+        ignoreSet.add("key");
+        ignoreSet.add("service_url");
+        this.objectMapper = new ObjectMapper();
+    }
+
+    public abstract MatrixResponse route(GHMRequest request);
+
+    public GHMatrixAbstractRequester setDownloader(OkHttpClient downloader) {
+        this.downloader = downloader;
+        return this;
+    }
+
+    public OkHttpClient getDownloader() {
+        return downloader;
+    }
+
+    protected String getJson(String url) throws IOException {
+        Request okRequest = new Request.Builder().url(url).build();
+        ResponseBody body = downloader.newCall(okRequest).execute().body();
+        String str = body.string();
+        body.close();
+        return str;
+    }
+
+    protected String postJson(String url, JsonNode data) throws IOException {
+        Request okRequest = new Request.Builder().url(url).post(RequestBody.create(MT_JSON, data.toString())).build();
+        ResponseBody body = downloader.newCall(okRequest).execute().body();
+        String str = body.string();
+        body.close();
+        return str;
+    }
+
+    protected JsonNode toJSON(String url, String str) {
+        try {
+            return objectMapper.readTree(str);
+        } catch (Exception ex) {
+            throw new RuntimeException("Cannot parse json " + str + " from " + url);
+        }
+    }
+
+    public List<Throwable> readUsableEntityError(List<String> outArraysList, JsonNode solution) {
+        boolean readWeights = outArraysList.contains("weights") && solution.has("weights");
+        boolean readDistances = outArraysList.contains("distances") && solution.has("distances");
+        boolean readTimes = outArraysList.contains("times") && solution.has("times");
+
+        if (!readWeights && !readDistances && !readTimes) {
+            return Collections.<Throwable>singletonList(new RuntimeException("Cannot find usable entity like weights, distances or times in JSON"));
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    public void fillResponseFromJson(MatrixResponse matrixResponse, String responseAsString) throws IOException {
+        fillResponseFromJson(matrixResponse, objectMapper.reader().readTree(responseAsString));
+    }
+
+    protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode solution) {
+        final boolean readWeights = solution.has("weights");
+        final boolean readDistances = solution.has("distances");
+        final boolean readTimes = solution.has("times");
+
+        int fromCount = 0;
+        JsonNode weightsArray = null;
+        if (readWeights) {
+            weightsArray = solution.get("weights");
+            fromCount = checkArraySizes("weights", weightsArray.size());
+        }
+        JsonNode timesArray = null;
+        if (readTimes) {
+            timesArray = solution.get("times");
+            fromCount = checkArraySizes("times", timesArray.size(), weightsArray);
+        }
+        JsonNode distancesArray = null;
+        if (readDistances) {
+            distancesArray = solution.get("distances");
+            fromCount = checkArraySizes("distances", distancesArray.size(), weightsArray, timesArray);
+        }
+
+        for (int fromIndex = 0; fromIndex < fromCount; fromIndex++) {
+            int toCount = 0;
+            JsonNode weightsFromArray = null;
+            double[] weights = null;
+            if (readWeights) {
+                weightsFromArray = weightsArray.get(fromIndex);
+                weights = new double[weightsFromArray.size()];
+                toCount = checkArraySizes("weights", weightsFromArray.size());
+            }
+
+            JsonNode timesFromArray = null;
+            long[] times = null;
+            if (readTimes) {
+                timesFromArray = timesArray.get(fromIndex);
+                times = new long[timesFromArray.size()];
+                toCount = checkArraySizes("times", timesFromArray.size(), weightsFromArray);
+            }
+
+            JsonNode distancesFromArray = null;
+            int[] distances = null;
+            if (readDistances) {
+                distancesFromArray = distancesArray.get(fromIndex);
+                distances = new int[distancesFromArray.size()];
+                toCount = checkArraySizes("distances", distancesFromArray.size(), weightsFromArray, timesFromArray);
+            }
+
+            for (int toIndex = 0; toIndex < toCount; toIndex++) {
+                if (readWeights) {
+                    weights[toIndex] = weightsFromArray.get(toIndex).asDouble();
+                }
+
+                if (readTimes) {
+                    times[toIndex] = timesFromArray.get(toIndex).asLong() * 1000;
+                }
+
+                if (readDistances) {
+                    distances[toIndex] = (int) Math.round(distancesFromArray.get(toIndex).asDouble());
+                }
+            }
+
+            if (readWeights) {
+                matrixResponse.setWeightRow(fromIndex, weights);
+            }
+
+            if (readTimes) {
+                matrixResponse.setTimeRow(fromIndex, times);
+            }
+
+            if (readDistances) {
+                matrixResponse.setDistanceRow(fromIndex, distances);
+            }
+        }
+    }
+
+    private static int checkArraySizes(String msg, int len, JsonNode... arrays) {
+        for (JsonNode other : arrays) {
+            if (len <= 0)
+                throw new IllegalArgumentException("Size " + len + " of '" + msg + "' array is too small");
+
+            if (other != null && len != other.size())
+                throw new IllegalArgumentException("Size " + len + " of '" + msg + "' array is has to be equal to other arrays but wasn't");
+        }
+        return len;
+    }
+
+    protected String buildURLNoHints(String path, GHMRequest ghRequest) {
+        // allow per request service URLs
+        String tmpServiceURL = ghRequest.getHints().get(SERVICE_URL, serviceUrl);
+        String url = tmpServiceURL;
+        url += path + "?";
+
+        String key = ghRequest.getHints().get(KEY, "");
+        if (!Helper.isEmpty(key)) {
+            url += "key=" + key;
+        }
+        return url;
+    }
+
+    protected String buildURL(String path, GHMRequest ghRequest) {
+        String url = buildURLNoHints(path, ghRequest);
+        for (Map.Entry<String, String> entry : ghRequest.getHints().toMap().entrySet()) {
+            if (ignoreSet.contains(entry.getKey())) {
+                continue;
+            }
+
+            url += "&" + encode(entry.getKey()) + "=" + encode(entry.getValue());
+        }
+        return url;
+    }
+
+    protected static String encode(String str) {
+        try {
+            return URLEncoder.encode(str, "UTF-8");
+        } catch (Exception ex) {
+            return str;
+        }
+    }
+
+    public List<Throwable> readErrors(JsonNode json) {
+        return web.readErrors(json);
+    }
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
new file mode 100644
index 0000000000..f395c044b4
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -0,0 +1,172 @@
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.node.ArrayNode;
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.util.shapes.GHPoint;
+import okhttp3.OkHttpClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author Peter Karich
+ */
+public class GHMatrixBatchRequester extends GHMatrixAbstractRequester {
+    final JsonNodeFactory factory = JsonNodeFactory.instance;
+    private final Logger logger = LoggerFactory.getLogger(getClass());
+    private int maxIterations = 100;
+    private long sleepAfterGET = 1000;
+
+    public GHMatrixBatchRequester() {
+        super();
+    }
+
+    public GHMatrixBatchRequester(String serviceUrl) {
+        super(serviceUrl);
+    }
+
+    public GHMatrixBatchRequester(String serviceUrl, OkHttpClient client) {
+        super(serviceUrl, client);
+    }
+
+    /**
+     * Internal parameter. Increase only if you have very large matrices.
+     */
+    public GHMatrixBatchRequester setMaxIterations(int maxIterations) {
+        this.maxIterations = maxIterations;
+        return this;
+    }
+
+    /**
+     * Internal parameter. Increase only if you have very large matrices.
+     */
+    public GHMatrixBatchRequester setSleepAfterGET(long sleepAfterGETMillis) {
+        this.sleepAfterGET = sleepAfterGETMillis;
+        return this;
+    }
+
+    @Override
+    public MatrixResponse route(GHMRequest ghRequest) {
+        ObjectNode requestJson = factory.objectNode();
+        ArrayNode fromPointList = createPointList(ghRequest.getFromPoints());
+        ArrayNode toPointList = createPointList(ghRequest.getToPoints());
+
+        List<String> outArraysList = new ArrayList<>(ghRequest.getOutArrays());
+        if (outArraysList.isEmpty()) {
+            outArraysList.add("weights");
+        }
+
+        ArrayNode outArrayListJson = factory.arrayNode(outArraysList.size());
+        for (String str : outArraysList) {
+            outArrayListJson.add(str);
+        }
+
+        // TODO allow elevation for full path
+        boolean hasElevation = false;
+        requestJson.put("from_points", fromPointList);
+        requestJson.put("to_points", toPointList);
+        requestJson.put("out_arrays", outArrayListJson);
+        requestJson.put("vehicle", ghRequest.getVehicle());
+        requestJson.put("elevation", hasElevation);
+
+        boolean withTimes = outArraysList.contains("times");
+        boolean withDistances = outArraysList.contains("distances");
+        boolean withWeights = outArraysList.contains("weights");
+        final MatrixResponse matrixResponse = new MatrixResponse(
+                ghRequest.getFromPoints().size(),
+                ghRequest.getToPoints().size(), withTimes, withDistances, withWeights);
+
+        boolean debug = ghRequest.getHints().getBool("debug", false);
+        String postUrl = buildURLNoHints("/calculate", ghRequest);
+
+        try {
+            String postResponseStr = postJson(postUrl, requestJson);
+
+            if (debug) {
+                logger.info("POST URL:" + postUrl + ", request:" + requestJson + ", response: " + postResponseStr);
+            }
+
+            JsonNode responseJson = toJSON(postUrl, postResponseStr);
+            if (responseJson.has("message")) {
+                matrixResponse.addError(new RuntimeException(responseJson.get("message").asText()));
+                return matrixResponse;
+            }
+            if (!responseJson.has("job_id")) {
+                throw new IllegalStateException("Response should contain job_id but was "
+                        + postResponseStr + ", json:" + requestJson + ",url:" + postUrl);
+            }
+
+            final String id = responseJson.get("job_id").asText();
+            int i = 0;
+            for (; i < maxIterations; i++) {
+                // SLEEP a bit and GET solution
+                if (sleepAfterGET > 0) {
+                    Thread.sleep(sleepAfterGET);
+                }
+                String getUrl = buildURLNoHints("/solution/" + id, ghRequest);
+
+                String getResponseStr;
+                try {
+                    getResponseStr = getJson(getUrl);
+                } catch (SocketTimeoutException ex) {
+                    // if timeout exception try once again:
+                    getResponseStr = getJson(getUrl);
+                }
+
+                JsonNode getResponseJson = toJSON(getUrl, getResponseStr);
+                if (debug) {
+                    logger.info(i + " GET URL:" + getUrl + ", response: " + getResponseStr);
+                }
+                matrixResponse.addErrors(readErrors(getResponseJson));
+                if (matrixResponse.hasErrors()) {
+                    break;
+                }
+                String status = getResponseJson.get("status").asText();
+
+                if ("processing".equals(status) || "waiting".equals(status)) {
+                    continue;
+                }
+
+                if ("finished".equals(status)) {
+                    JsonNode solution = getResponseJson.get("solution");
+                    matrixResponse.addErrors(readUsableEntityError(outArraysList, solution));
+                    if (!matrixResponse.hasErrors())
+                        fillResponseFromJson(matrixResponse, solution);
+
+                    break;
+                }
+
+                matrixResponse.addError(new RuntimeException("Status not supported: " + status + " - illegal JSON format?"));
+                break;
+            }
+
+            if (i >= maxIterations) {
+                throw new IllegalStateException("Maximum number of iterations reached " + maxIterations + ", increasing should only be necessary for big matrices. For smaller ones this is a bug, please contact us");
+            }
+
+        } catch (InterruptedException ex) {
+            throw new RuntimeException(ex);
+        } catch (IOException ex) {
+            throw new RuntimeException(ex);
+        }
+
+        return matrixResponse;
+    }
+
+    protected final ArrayNode createPointList(List<GHPoint> list) {
+        ArrayNode outList = factory.arrayNode(list.size()); // new ArrayList<>(list.size())
+        for (GHPoint p : list) {
+            ArrayNode entry = factory.arrayNode(2);
+            entry.add(p.lon);
+            entry.add(p.lat);
+            outList.add(entry);
+        }
+        return outList;
+    }
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
new file mode 100644
index 0000000000..f535934f84
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
@@ -0,0 +1,107 @@
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
+import okhttp3.OkHttpClient;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * @author Peter Karich
+ */
+public class GHMatrixSyncRequester extends GHMatrixAbstractRequester {
+
+    public GHMatrixSyncRequester() {
+        super();
+        initIgnore();
+    }
+
+    public GHMatrixSyncRequester(String serviceUrl, OkHttpClient client) {
+        super(serviceUrl, client);
+        initIgnore();
+    }
+
+    public GHMatrixSyncRequester(String serviceUrl) {
+        super(serviceUrl, new OkHttpClient.Builder().
+                connectTimeout(15, TimeUnit.SECONDS).
+                readTimeout(15, TimeUnit.SECONDS).build());
+        initIgnore();
+    }
+
+    private void initIgnore() {
+        ignoreSet.add("vehicle");
+        ignoreSet.add("point");
+        ignoreSet.add("from_point");
+        ignoreSet.add("to_point");
+        ignoreSet.add("add_array");
+    }
+
+    @Override
+    public MatrixResponse route(GHMRequest ghRequest) {
+        String pointsStr;
+        if (ghRequest.identicalLists) {
+            pointsStr = createPointQuery(ghRequest.getFromPoints(), "point");
+        } else {
+            pointsStr = createPointQuery(ghRequest.getFromPoints(), "from_point");
+            pointsStr += "&" + createPointQuery(ghRequest.getToPoints(), "to_point");
+        }
+
+        String outArrayStr = "";
+        List<String> outArraysList = new ArrayList<>(ghRequest.getOutArrays());
+        if (outArraysList.isEmpty()) {
+            outArraysList.add("weights");
+        }
+
+        for (String type : outArraysList) {
+            if (!type.isEmpty()) {
+                outArrayStr += "&";
+            }
+
+            outArrayStr += "out_array=" + type;
+        }
+
+        String url = buildURL("", ghRequest);
+        url += "&" + pointsStr + "&" + outArrayStr + "&vehicle=" + ghRequest.getVehicle();
+
+        boolean withTimes = outArraysList.contains("times");
+        boolean withDistances = outArraysList.contains("distances");
+        boolean withWeights = outArraysList.contains("weights");
+        MatrixResponse matrixResponse = new MatrixResponse(
+                ghRequest.getFromPoints().size(),
+                ghRequest.getToPoints().size(), withTimes, withDistances, withWeights);
+
+        try {
+            String str = getJson(url);
+            JsonNode getResponseJson = objectMapper.reader().readTree(str);
+
+            matrixResponse.addErrors(readErrors(getResponseJson));
+            if (!matrixResponse.hasErrors()) {
+                matrixResponse.addErrors(readUsableEntityError(outArraysList, getResponseJson));
+            }
+
+            if (!matrixResponse.hasErrors())
+                fillResponseFromJson(matrixResponse, getResponseJson);
+
+        } catch (IOException ex) {
+            throw new RuntimeException(ex);
+        }
+
+        return matrixResponse;
+    }
+
+    private String createPointQuery(List<GHPoint> list, String pointName) {
+        String pointsStr = "";
+        for (GHPoint p : list) {
+            if (!pointsStr.isEmpty()) {
+                pointsStr += "&";
+            }
+
+            pointsStr += pointName + "=" + encode(Helper.round6(p.lat) + "," + Helper.round6(p.lon));
+        }
+        return pointsStr;
+    }
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java
new file mode 100644
index 0000000000..59a9684da6
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java
@@ -0,0 +1,136 @@
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author Peter Karich
+ */
+public class GoogleMatrixSyncRequester extends GHMatrixAbstractRequester {
+
+    public GoogleMatrixSyncRequester() {
+        super();
+        initIgnore();
+    }
+
+    public GoogleMatrixSyncRequester(String serviceUrl) {
+        super(serviceUrl);
+        initIgnore();
+    }
+
+    private void initIgnore() {
+        ignoreSet.add("mode");
+        ignoreSet.add("units");
+        ignoreSet.add("destinations");
+        ignoreSet.add("origins");
+        ignoreSet.add("mode");
+    }
+
+    @Override
+    public MatrixResponse route(GHMRequest ghRequest) {
+        String pointsStr;
+
+        pointsStr = createGoogleQuery(ghRequest.getFromPoints(), "origins");
+        pointsStr += "&" + createGoogleQuery(ghRequest.getToPoints(), "destinations");
+
+        List<String> outArraysList = new ArrayList<>(ghRequest.getOutArrays());
+        if (outArraysList.isEmpty()) {
+            // different default as google does not support weights
+            outArraysList.add("distances");
+            outArraysList.add("times");
+        }
+
+        // do not do the mapping here!
+        // bicycling -> bike, car -> car, walking -> foot
+        //
+        String url = buildURL("", ghRequest);
+        url += "&" + pointsStr + "&mode=" + ghRequest.getVehicle();
+
+        boolean withTimes = outArraysList.contains("times");
+        boolean withDistances = outArraysList.contains("distances");
+        boolean withWeights = outArraysList.contains("weights");
+        if (withWeights) {
+            throw new UnsupportedOperationException("Google Matrix API does not include weights");
+        }
+
+        MatrixResponse matrixResponse = new MatrixResponse(
+                ghRequest.getFromPoints().size(),
+                ghRequest.getToPoints().size(), withTimes, withDistances, false);
+
+        try {
+            String str = getJson(url);
+            JsonNode getResponseJson = objectMapper.reader().readTree(str);
+            fillResponseFromJson(matrixResponse, getResponseJson);
+
+        } catch (IOException ex) {
+            throw new RuntimeException(ex);
+        }
+
+        return matrixResponse;
+    }
+
+    private String createGoogleQuery(List<GHPoint> list, String pointName) {
+        String pointsStr = "";
+        for (GHPoint p : list) {
+            if (!pointsStr.isEmpty()) {
+                pointsStr += "|";
+            }
+
+            pointsStr += encode(Helper.round6(p.lat) + "," + Helper.round6(p.lon));
+        }
+        return pointName + "=" + pointsStr;
+    }
+
+    @Override
+    public void fillResponseFromJson(MatrixResponse matrixResponse, String responseAsString) throws IOException {
+        fillResponseFromJson(matrixResponse, objectMapper.reader().readTree(responseAsString));
+    }
+
+    @Override
+    protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode responseJson) {
+        String status = responseJson.get("status").asText();
+        if ("OK".equals(status)) {
+            if (!responseJson.has("rows")) {
+                matrixResponse.addError(new RuntimeException("No 'rows' entry found in Google Matrix response. status:OK"));
+                return;
+            }
+
+            JsonNode rows = responseJson.get("rows");
+            int fromCount = rows.size();
+
+            for (int fromIndex = 0; fromIndex < fromCount; fromIndex++) {
+                JsonNode elementsObj = rows.get(fromIndex);
+                JsonNode elements = elementsObj.get("elements");
+                int toCount = elements.size();
+                long[] times = new long[toCount];
+                int[] distances = new int[toCount];
+
+                for (int toIndex = 0; toIndex < toCount; toIndex++) {
+                    JsonNode element = elements.get(toIndex);
+
+                    if ("OK".equals(element.get("status").asText())) {
+                        JsonNode distance = element.get("distance");
+                        JsonNode duration = element.get("duration");
+
+                        times[toIndex] = duration.get("value").asLong() * 1000;
+                        distances[toIndex] = Math.round(distance.get("value").asLong());
+                    } else {
+                        matrixResponse.addError(new IllegalArgumentException("Cannot find route " + fromIndex + "->" + toIndex));
+                    }
+                }
+
+                matrixResponse.setTimeRow(fromIndex, times);
+                matrixResponse.setDistanceRow(fromIndex, distances);
+            }
+        } else if (responseJson.has("error_message")) {
+            matrixResponse.addError(new RuntimeException(responseJson.get("error_message").asText()));
+        } else {
+            matrixResponse.addError(new RuntimeException("Something went wrong with Google Matrix response. status:" + status));
+        }
+    }
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java
new file mode 100644
index 0000000000..a72432c580
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java
@@ -0,0 +1,46 @@
+package com.graphhopper.api;
+
+import com.graphhopper.util.Helper;
+import okhttp3.MediaType;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class GraphHopperMatrixWeb {
+
+    public static final String SERVICE_URL = "service_url";
+    public static final String KEY = "key";
+    public static final MediaType MT_JSON = MediaType.parse("application/json; charset=utf-8");
+    private final GHMatrixAbstractRequester requester;
+    private String key;
+
+    public GraphHopperMatrixWeb() {
+        this(new GHMatrixBatchRequester());
+    }
+
+    public GraphHopperMatrixWeb(String serviceUrl) {
+        this(new GHMatrixBatchRequester(serviceUrl));
+    }
+
+    public GraphHopperMatrixWeb(GHMatrixAbstractRequester requester) {
+        this.requester = requester;
+    }
+
+    public GraphHopperMatrixWeb setKey(String key) {
+        if (key == null || key.isEmpty()) {
+            throw new IllegalStateException("Key cannot be empty");
+        }
+
+        this.key = key;
+        return this;
+    }
+
+    public MatrixResponse route(GHMRequest request) {
+        if (!Helper.isEmpty(key)) {
+            request.getHints().put(KEY, key);
+        }
+
+        return requester.route(request);
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
similarity index 69%
rename from web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
rename to client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index 82bcdba713..48daf5a87d 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -1,23 +1,22 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.http;
+package com.graphhopper.api;
 
-import com.fasterxml.jackson.core.JsonParseException;
 import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
@@ -29,34 +28,56 @@
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.exceptions.*;
 import com.graphhopper.util.shapes.GHPoint;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.util.*;
-import java.util.Map.Entry;
+import java.util.concurrent.TimeUnit;
 
 /**
- * Main wrapper of the GraphHopper Directions API for a simple and efficient usage.
+ * Main wrapper of the GraphHopper Directions API for a simple and efficient
+ * usage.
  *
  * @author Peter Karich
  */
 public class GraphHopperWeb implements GraphHopperAPI {
-    private ObjectMapper objectMapper;
-    private final Set<String> ignoreSet;
-    private Downloader downloader = new Downloader("GraphHopper Java Client");
-    private String routeServiceUrl = "https://graphhopper.com/api/1/route";
+
+    private final ObjectMapper objectMapper;
+    private OkHttpClient downloader;
+    private String routeServiceUrl;
     private String key = "";
     private boolean instructions = true;
     private boolean calcPoints = true;
-    private boolean turnDescription = true;
     private boolean elevation = false;
+    private boolean turnDescription = true;
+    private String optimize = "false";
+    private final Set<String> ignoreSet;
+
+    public static final String TIMEOUT = "timeout";
+    private final long DEFAULT_TIMEOUT = 5000;
 
     public GraphHopperWeb() {
+        this("https://graphhopper.com/api/1/route");
+    }
+
+    public GraphHopperWeb(String serviceUrl) {
+        this.routeServiceUrl = serviceUrl;
+        downloader = new OkHttpClient.Builder().
+                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).
+                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).
+                build();
+
         // some parameters are supported directly via Java API so ignore them when writing the getHints map
-        ignoreSet = new HashSet<>();
+        ignoreSet = new HashSet<String>();
         ignoreSet.add("calc_points");
         ignoreSet.add("calcpoints");
         ignoreSet.add("instructions");
         ignoreSet.add("elevation");
         ignoreSet.add("key");
+        ignoreSet.add("optimize");
 
         // some parameters are in the request:
         ignoreSet.add("algorithm");
@@ -71,7 +92,16 @@ public GraphHopperWeb() {
         objectMapper = new ObjectMapper();
     }
 
-    private PathWrapper createPathWrapper(JsonNode path,
+    public GraphHopperWeb setDownloader(OkHttpClient downloader) {
+        this.downloader = downloader;
+        return this;
+    }
+
+    public OkHttpClient getDownloader() {
+        return downloader;
+    }
+
+    PathWrapper createPathWrapper(JsonNode path,
                                           boolean tmpCalcPoints, boolean tmpInstructions,
                                           boolean tmpElevation, boolean turnDescription,
                                           boolean tmpCalcDetails) {
@@ -162,7 +192,7 @@ private PathWrapper createPathWrapper(JsonNode path,
             if (tmpCalcDetails) {
                 JsonNode details = path.get("details");
                 Map<String, List<PathDetail>> pathDetails = new HashMap<>(details.size());
-                Iterator<Entry<String, JsonNode>> detailIterator = details.fields();
+                Iterator<Map.Entry<String, JsonNode>> detailIterator = details.fields();
                 while (detailIterator.hasNext()) {
                     Map.Entry<String, JsonNode> detailEntry = detailIterator.next();
                     List<PathDetail> pathDetailList = new ArrayList<>();
@@ -263,11 +293,6 @@ else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
         return errors;
     }
 
-    public GraphHopperWeb setDownloader(Downloader downloader) {
-        this.downloader = downloader;
-        return this;
-    }
-
     @Override
     public boolean load(String serviceUrl) {
         this.routeServiceUrl = serviceUrl;
@@ -275,97 +300,169 @@ public boolean load(String serviceUrl) {
     }
 
     public GraphHopperWeb setKey(String key) {
-        if (key == null || key.isEmpty())
+        if (key == null || key.isEmpty()) {
             throw new IllegalStateException("Key cannot be empty");
+        }
 
         this.key = key;
         return this;
     }
 
+    /**
+     * Enable or disable calculating points for the way. The default is true.
+     */
     public GraphHopperWeb setCalcPoints(boolean calcPoints) {
         this.calcPoints = calcPoints;
         return this;
     }
 
+    /**
+     * Enable or disable calculating and returning turn instructions. The
+     * default is true.
+     */
     public GraphHopperWeb setInstructions(boolean b) {
         instructions = b;
         return this;
     }
 
+    /**
+     * Enable or disable elevation. The default is false.
+     */
     public GraphHopperWeb setElevation(boolean withElevation) {
         this.elevation = withElevation;
         return this;
     }
 
+    /**
+     * @param optimize "false" if the order of the locations should be left
+     *                 unchanged, this is the default. Or if "true" then the order of the
+     *                 location is optimized according to the overall best route and returned
+     *                 this way i.e. the traveling salesman problem is solved under the hood.
+     *                 Note that in this case the request takes longer and costs more credits.
+     *                 For more details see:
+     *                 https://github.com/graphhopper/directions-api/blob/master/FAQ.md#what-is-one-credit
+     */
+    public GraphHopperWeb setOptimize(String optimize) {
+        this.optimize = optimize;
+        return this;
+    }
+
+
     @Override
     public GHResponse route(GHRequest request) {
         try {
-            String places = "";
-            for (GHPoint p : request.getPoints()) {
-                places += "point=" + p.lat + "," + p.lon + "&";
-            }
+            Request okRequest = createRequest(request);
+            ResponseBody rspBody = getClientForRequest(request).newCall(okRequest).execute().body();
+            JsonNode json = objectMapper.reader().readTree(rspBody.byteStream());
+            rspBody.close();
+
+            GHResponse res = new GHResponse();
+            res.addErrors(readErrors(json));
+            if (res.hasErrors())
+                return res;
+
+            JsonNode paths = json.get("paths");
 
             boolean tmpInstructions = request.getHints().getBool("instructions", instructions);
             boolean tmpCalcPoints = request.getHints().getBool("calc_points", calcPoints);
+            boolean tmpElevation = request.getHints().getBool("elevation", elevation);
             boolean tmpTurnDescription = request.getHints().getBool("turn_description", turnDescription);
 
-            if (tmpInstructions && !tmpCalcPoints)
-                throw new IllegalStateException("Cannot calculate instructions without points (only points without instructions). "
-                        + "Use calc_points=false and instructions=false to disable point and instruction calculation");
+            for (JsonNode path : paths) {
+                PathWrapper altRsp = createPathWrapper(path, tmpCalcPoints, tmpInstructions, tmpElevation, tmpTurnDescription, !request.getPathDetails().isEmpty());
+                res.add(altRsp);
+            }
+
+            return res;
 
-            boolean tmpElevation = request.getHints().getBool("elevation", elevation);
+        } catch (Exception ex) {
+            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
+        }
+    }
 
-            String url = routeServiceUrl
-                    + "?"
-                    + places
-                    + "&type=json"
-                    + "&instructions=" + tmpInstructions
-                    + "&points_encoded=true"
-                    + "&calc_points=" + tmpCalcPoints
-                    + "&algorithm=" + request.getAlgorithm()
-                    + "&locale=" + request.getLocale().toString()
-                    + "&elevation=" + tmpElevation;
-
-            if (!request.getVehicle().isEmpty())
-                url += "&vehicle=" + request.getVehicle();
-
-            for (String details : request.getPathDetails()) {
-                url += "&" + Parameters.DETAILS.PATH_DETAILS + "=" + details;
-            }
+    private OkHttpClient getClientForRequest(GHRequest request) {
+        OkHttpClient client = this.downloader;
+        if (request.getHints().has(TIMEOUT)) {
+            long timeout = request.getHints().getLong(TIMEOUT, DEFAULT_TIMEOUT);
+            client = client.newBuilder()
+                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)
+                    .readTimeout(timeout, TimeUnit.MILLISECONDS)
+                    .build();
+        }
 
-            if (!key.isEmpty())
-                url += "&key=" + key;
+        return client;
+    }
 
-            for (Entry<String, String> entry : request.getHints().toMap().entrySet()) {
-                String urlKey = entry.getKey();
-                String urlValue = entry.getValue();
+    private Request createRequest(GHRequest request) {
+        boolean tmpInstructions = request.getHints().getBool("instructions", instructions);
+        boolean tmpCalcPoints = request.getHints().getBool("calc_points", calcPoints);
+        String tmpOptimize = request.getHints().get("optimize", optimize);
 
-                // use lower case conversion for check only!
-                if (ignoreSet.contains(urlKey.toLowerCase()))
-                    continue;
+        if (tmpInstructions && !tmpCalcPoints) {
+            throw new IllegalStateException("Cannot calculate instructions without points (only points without instructions). "
+                    + "Use calc_points=false and instructions=false to disable point and instruction calculation");
+        }
 
-                if (urlValue != null && !urlValue.isEmpty())
-                    url += "&" + WebHelper.encodeURL(urlKey) + "=" + WebHelper.encodeURL(urlValue);
-            }
+        boolean tmpElevation = request.getHints().getBool("elevation", elevation);
 
-            String str = downloader.downloadAsString(url, true);
-            JsonNode json = objectMapper.reader().readTree(str);
+        String places = "";
+        for (GHPoint p : request.getPoints()) {
+            places += "point=" + Helper.round6(p.lat) + "," + Helper.round6(p.lon) + "&";
+        }
 
-            GHResponse res = new GHResponse();
-            res.addErrors(readErrors(json));
-            if (res.hasErrors())
-                return res;
+        String type = request.getHints().get("type", "json");
+
+        String url = routeServiceUrl
+                + "?"
+                + places
+                + "&type=" + type
+                + "&instructions=" + tmpInstructions
+                + "&points_encoded=true"
+                + "&calc_points=" + tmpCalcPoints
+                + "&algorithm=" + request.getAlgorithm()
+                + "&locale=" + request.getLocale().toString()
+                + "&elevation=" + tmpElevation
+                + "&optimize=" + tmpOptimize;
+
+        if (!request.getVehicle().isEmpty()) {
+            url += "&vehicle=" + request.getVehicle();
+        }
 
-            JsonNode paths = json.get("paths");
-            for (JsonNode path : paths) {
-                PathWrapper altRsp = createPathWrapper(path, tmpCalcPoints, tmpInstructions, tmpElevation, tmpTurnDescription, !request.getPathDetails().isEmpty());
-                res.add(altRsp);
+        for (String details : request.getPathDetails()) {
+            url += "&" + Parameters.DETAILS.PATH_DETAILS + "=" + details;
+        }
+
+        if (!key.isEmpty()) {
+            url += "&key=" + WebHelper.encodeURL(key);
+        }
+
+        for (Map.Entry<String, String> entry : request.getHints().toMap().entrySet()) {
+            String urlKey = entry.getKey();
+            String urlValue = entry.getValue();
+
+            // use lower case conversion for check only!
+            if (ignoreSet.contains(urlKey.toLowerCase())) {
+                continue;
             }
 
-            return res;
+            if (urlValue != null && !urlValue.isEmpty()) {
+                url += "&" + WebHelper.encodeURL(urlKey) + "=" + WebHelper.encodeURL(urlValue);
+            }
+        }
 
+        return new Request.Builder().url(url).build();
+    }
+
+    public String export(GHRequest ghRequest) {
+        String str = "Creating request failed";
+        try {
+            Request okRequest = createRequest(ghRequest);
+            str = getClientForRequest(ghRequest).newCall(okRequest).execute().body().string();
+
+            return str;
         } catch (Exception ex) {
-            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
+            throw new RuntimeException("Problem while fetching export " + ghRequest.getPoints()
+                    + ", error: " + ex.getMessage() + " response: " + str, ex);
         }
     }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java b/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
new file mode 100644
index 0000000000..b444b75f63
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
@@ -0,0 +1,193 @@
+package com.graphhopper.api;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * This class defines the response for a M-to-N requests.
+ *
+ * @author Peter Karich
+ */
+public class MatrixResponse {
+
+    private String debugInfo = "";
+    private final List<Throwable> errors = new ArrayList<>(4);
+    private long[][] times = new long[0][];
+    private int[][] distances = new int[0][];
+    private double[][] weights = new double[0][];
+    private final int fromCount;
+    private final int toCount;
+
+    public MatrixResponse() {
+        this(10, 10, true, true, true);
+    }
+
+    public MatrixResponse(int fromCap, int toCap, boolean withTimes, boolean withDistances, boolean withWeights) {
+        if (fromCap <= 0 || toCap <= 0)
+            throw new IllegalArgumentException("Requested matrix too small: " + fromCap + "x" + toCap);
+        this.fromCount = fromCap;
+        this.toCount = toCap;
+
+        if (withTimes) {
+            times = new long[fromCap][toCap];
+        }
+
+        if (withDistances) {
+            distances = new int[fromCap][toCap];
+        }
+
+        if (withWeights) {
+            weights = new double[fromCap][toCap];
+        }
+
+        if (!withTimes && !withDistances && !withWeights)
+            throw new IllegalArgumentException("Please specify times, distances or weights that should be calculated by the matrix");
+    }
+
+    public void setFromRow(int row, long timeRow[], int distanceRow[], double weightRow[]) {
+        if (times.length > 0) {
+            check(timeRow.length, toCount, "to times");
+            times[row] = timeRow;
+        }
+
+        if (distances.length > 0) {
+            check(distanceRow.length, toCount, "to distances");
+            distances[row] = distanceRow;
+        }
+
+        if (weights.length > 0) {
+            check(weights.length, toCount, "to weights");
+            weights[row] = weightRow;
+        }
+    }
+
+    private void check(int currentLength, int expectedLength, String times) {
+        if (currentLength != expectedLength)
+            throw new IllegalArgumentException("Sizes do not match for '" + times + "'. " +
+                    "Expected " + expectedLength + " was: " + currentLength + ". Matrix: " + fromCount + "x" + toCount);
+    }
+
+    public void setTimeRow(int row, long timeRow[]) {
+        if (times.length > 0) {
+            check(timeRow.length, toCount, "to times");
+            times[row] = timeRow;
+        } else {
+            throw new UnsupportedOperationException("Cannot call setTimeRow if times are disabled");
+        }
+    }
+
+    public void setDistanceRow(int row, int distanceRow[]) {
+        if (distances.length > 0) {
+            check(distanceRow.length, toCount, "to distances");
+            distances[row] = distanceRow;
+        } else {
+            throw new UnsupportedOperationException("Cannot call setDistanceRow if distances are disabled");
+        }
+    }
+
+    public void setWeightRow(int row, double weightRow[]) {
+        if (weights.length > 0) {
+            check(weights.length, toCount, "to weights");
+            weights[row] = weightRow;
+        } else {
+            throw new UnsupportedOperationException("Cannot call setWeightRow if weights are disabled");
+        }
+    }
+
+    /**
+     * Returns the time for the specific entry (from -&gt; to) in milliseconds.
+     */
+    public long getTime(int from, int to) {
+        if (hasErrors()) {
+            throw new IllegalStateException("Cannot return time (" + from + "," + to + ") if errors occured " + getErrors());
+        }
+
+        if (from >= times.length) {
+            throw new IllegalStateException("Cannot get 'from' " + from + " from times with size " + times.length);
+        } else if (to >= times[from].length) {
+            throw new IllegalStateException("Cannot get 'to' " + to + " from times with size " + times[from].length);
+        }
+        return times[from][to];
+    }
+
+    /**
+     * Returns the distance for the specific entry (from -&gt; to) in meter.
+     */
+    public double getDistance(int from, int to) {
+        if (hasErrors()) {
+            throw new IllegalStateException("Cannot return distance (" + from + "," + to + ") if errors occured " + getErrors());
+        }
+
+        if (from >= distances.length) {
+            throw new IllegalStateException("Cannot get 'from' " + from + " from distances with size " + distances.length);
+        } else if (to >= distances[from].length) {
+            throw new IllegalStateException("Cannot get 'to' " + to + " from distances with size " + distances[from].length);
+        }
+        return distances[from][to];
+    }
+
+    /**
+     * Returns the weight for the specific entry (from -&gt; to) in arbitrary units
+     * ('costs').
+     */
+    public double getWeight(int from, int to) {
+        if (hasErrors()) {
+            throw new IllegalStateException("Cannot return weight (" + from + "," + to + ") if errors occured " + getErrors());
+        }
+
+        if (from >= weights.length) {
+            throw new IllegalStateException("Cannot get 'from' " + from + " from weights with size " + weights.length);
+        } else if (to >= weights[from].length) {
+            throw new IllegalStateException("Cannot get 'to' " + to + " from weights with size " + weights[from].length);
+        }
+        return weights[from][to];
+    }
+
+    public String getDebugInfo() {
+        return debugInfo;
+    }
+
+    public MatrixResponse setDebugInfo(String debugInfo) {
+        if (debugInfo != null) {
+            this.debugInfo = debugInfo;
+        }
+        return this;
+    }
+
+    /**
+     * @return true if one or more error found
+     */
+    public boolean hasErrors() {
+        return !errors.isEmpty();
+    }
+
+    public List<Throwable> getErrors() {
+        return errors;
+    }
+
+    public MatrixResponse addError(Throwable error) {
+        errors.add(error);
+        return this;
+    }
+
+    public MatrixResponse addErrors(Collection<Throwable> errorList) {
+        errors.addAll(errorList);
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        String addInfo = "";
+
+        if (times.length > 0) {
+            addInfo += ", times: " + times.length + "x" + times[0].length;
+        }
+
+        if (distances.length > 0) {
+            addInfo += ", distances: " + distances.length + "x" + distances[0].length;
+        }
+
+        return "[" + addInfo + "] errors:" + errors.toString();
+    }
+}
diff --git a/client-hc/src/main/java/com/graphhopper/api/WebHelper.java b/client-hc/src/main/java/com/graphhopper/api/WebHelper.java
new file mode 100644
index 0000000000..a7df96be34
--- /dev/null
+++ b/client-hc/src/main/java/com/graphhopper/api/WebHelper.java
@@ -0,0 +1,85 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.api;
+
+import com.graphhopper.util.PointList;
+
+import java.net.URLEncoder;
+
+/**
+ * Code which handles polyline encoding and other web stuff.
+ * <p>
+ *
+ * @author Peter Karich
+ */
+public class WebHelper {
+
+    public static String encodeURL(String str) {
+        try {
+            return URLEncoder.encode(str, "UTF-8");
+        } catch (Exception _ignore) {
+            return str;
+        }
+    }
+
+    public static PointList decodePolyline(String encoded, int initCap, boolean is3D) {
+        PointList poly = new PointList(initCap, is3D);
+        int index = 0;
+        int len = encoded.length();
+        int lat = 0, lng = 0, ele = 0;
+        while (index < len) {
+            // latitude
+            int b, shift = 0, result = 0;
+            do {
+                b = encoded.charAt(index++) - 63;
+                result |= (b & 0x1f) << shift;
+                shift += 5;
+            } while (b >= 0x20);
+            int deltaLatitude = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
+            lat += deltaLatitude;
+
+            // longitute
+            shift = 0;
+            result = 0;
+            do {
+                b = encoded.charAt(index++) - 63;
+                result |= (b & 0x1f) << shift;
+                shift += 5;
+            } while (b >= 0x20);
+            int deltaLongitude = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
+            lng += deltaLongitude;
+
+            if (is3D) {
+                // elevation
+                shift = 0;
+                result = 0;
+                do {
+                    b = encoded.charAt(index++) - 63;
+                    result |= (b & 0x1f) << shift;
+                    shift += 5;
+                } while (b >= 0x20);
+                int deltaElevation = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
+                ele += deltaElevation;
+                poly.add((double) lat / 1e5, (double) lng / 1e5, (double) ele / 100);
+            } else {
+                poly.add((double) lat / 1e5, (double) lng / 1e5);
+            }
+        }
+        return poly;
+    }
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java
new file mode 100644
index 0000000000..c232e99673
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java
@@ -0,0 +1,105 @@
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Test;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Peter Karich
+ */
+public abstract class AbstractGHMatrixWebTester {
+
+    protected final ObjectMapper objectMapper = new ObjectMapper();
+
+    abstract GraphHopperMatrixWeb createMatrixClient(String json) throws IOException;
+
+    public static GHMRequest createRequest() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(51.534377, -0.087891));
+        req.addPoint(new GHPoint(51.467697, -0.090637));
+        req.addPoint(new GHPoint(51.521241, -0.171833));
+        req.addPoint(new GHPoint(51.473685, -0.211487));
+        return req;
+    }
+
+    @Test
+    public void testReadingMatrixWithError() throws IOException {
+        String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("matrix_error.json")));
+        GraphHopperMatrixWeb matrixWeb = createMatrixClient(ghMatrix);
+
+        GHMRequest req = createRequest();
+        MatrixResponse rsp = matrixWeb.route(req);
+
+        assertTrue(rsp.hasErrors());
+        assertEquals(2, rsp.getErrors().size());
+    }
+
+    @Test
+    public void testReadingWeights() throws IOException {
+        String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("matrix-weights-only.json")));
+        GraphHopperMatrixWeb matrixWeb = createMatrixClient(ghMatrix);
+
+        GHMRequest req = createRequest();
+        MatrixResponse rsp = matrixWeb.route(req);
+        assertFalse(rsp.hasErrors());
+
+        assertEquals(885.9, rsp.getWeight(0, 1), .1);
+
+        try {
+            assertEquals(0., rsp.getDistance(0, 1), .1);
+            assertTrue(false);
+        } catch (Exception ex) {
+        }
+    }
+
+    @Test
+    public void testReadingGoogleThrowsException() throws IOException {
+        String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("google-matrix1.json")));
+        GraphHopperMatrixWeb matrixWeb = createMatrixClient(ghMatrix);
+        GHMRequest req = createRequest();
+        MatrixResponse rsp = matrixWeb.route(req);
+        assertTrue(rsp.hasErrors());
+    }
+
+    @Test
+    public void testReadingWeights_TimesAndDistances() throws IOException {
+        String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("matrix.json")));
+        GraphHopperMatrixWeb matrixWeb = createMatrixClient(ghMatrix);
+
+        GHMRequest req = createRequest();
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        req.addOutArray("times");
+        MatrixResponse rsp = matrixWeb.route(req);
+
+        assertFalse(rsp.hasErrors());
+
+        assertEquals(9475., rsp.getDistance(0, 1), .1);
+        assertEquals(9734., rsp.getDistance(1, 2), .1);
+        assertEquals(0., rsp.getDistance(1, 1), .1);
+
+        assertEquals(885.867, rsp.getWeight(0, 1), .1);
+        assertEquals(807.167, rsp.getWeight(1, 2), .1);
+        assertEquals(0., rsp.getWeight(1, 1), .1);
+
+        assertEquals(886, rsp.getTime(0, 1) / 1000);
+    }
+
+    public static String readFile(Reader simpleReader) throws IOException {
+        try (BufferedReader reader = new BufferedReader(simpleReader)) {
+            String res = "";
+            String line;
+            while ((line = reader.readLine()) != null) {
+                res += line;
+            }
+            return res;
+        }
+    }
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
new file mode 100644
index 0000000000..5d255c3f3e
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -0,0 +1,74 @@
+package com.graphhopper.api;
+
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Arrays;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * @author Peter Karich
+ */
+public abstract class AbstractGraphHopperMatrixWebIntegrationTester {
+
+    protected GraphHopperMatrixWeb ghMatrix;
+
+    abstract GraphHopperMatrixWeb createMatrixWeb();
+
+    @Before
+    public void setUp() {
+        String key = System.getProperty("graphhopper.key", GraphHopperWebIT.KEY);
+        ghMatrix = createMatrixWeb();
+        ghMatrix.setKey(key);
+    }
+
+    @Test
+    public void testMatrix() {
+        GHMRequest req = AbstractGHMatrixWebTester.createRequest();
+        MatrixResponse res = ghMatrix.route(req);
+
+        // no distances available
+        try {
+            assertEquals(0, res.getDistance(1, 2), 1);
+            assertTrue(false);
+        } catch (Exception ex) {
+        }
+
+        // ... only weight:
+        assertEquals(1685, res.getWeight(1, 2), 5);
+
+        req = AbstractGHMatrixWebTester.createRequest();
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        res = ghMatrix.route(req);
+
+        assertEquals(9664, res.getDistance(1, 2), 20);
+        assertEquals(1685, res.getWeight(1, 2), 10);
+    }
+
+    @Test
+    public void testBikeMatrix() {
+        GHMRequest req = AbstractGHMatrixWebTester.createRequest();
+        req.setVehicle("bike");
+        req.addOutArray("times");
+
+        MatrixResponse res = ghMatrix.route(req);
+        assertEquals(2350, res.getTime(1, 2) / 1000, 50);
+    }
+
+    @Test
+    public void testNxM_issue45() {
+        GHMRequest ghmRequest = new GHMRequest();
+        ghmRequest.addOutArray("distances");
+        ghmRequest.addOutArray("times");
+        ghmRequest.setVehicle("car");
+        ghmRequest.addFromPoints(Arrays.asList(new GHPoint(52.557151, 13.515244)))
+                .addToPoints(Arrays.asList(new GHPoint(52.557151, 13.515244), new GHPoint(52.454545, 13.295517)));
+
+        MatrixResponse res = ghMatrix.route(ghmRequest);
+        assertEquals(2436, res.getTime(0, 1) / 1000, 20);
+    }
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GHMatrixBatchTest.java b/client-hc/src/test/java/com/graphhopper/api/GHMatrixBatchTest.java
new file mode 100644
index 0000000000..f20fcb6064
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GHMatrixBatchTest.java
@@ -0,0 +1,29 @@
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.JsonNode;
+
+import java.io.IOException;
+
+/**
+ * @author Peter Karich
+ */
+public class GHMatrixBatchTest extends AbstractGHMatrixWebTester {
+
+    @Override
+    GraphHopperMatrixWeb createMatrixClient(final String jsonTmp) {
+        return new GraphHopperMatrixWeb(new GHMatrixBatchRequester("") {
+
+            private final String json = jsonTmp;
+
+            @Override
+            protected String postJson(String url, JsonNode data) throws IOException {
+                return "{\"job_id\": \"1\"}";
+            }
+
+            @Override
+            protected String getJson(String url) throws IOException {
+                return json;
+            }
+        }.setSleepAfterGET(0));
+    }
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GHMatrixSyncTest.java b/client-hc/src/test/java/com/graphhopper/api/GHMatrixSyncTest.java
new file mode 100644
index 0000000000..936013a4a7
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GHMatrixSyncTest.java
@@ -0,0 +1,35 @@
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.JsonNode;
+
+import java.io.IOException;
+
+/**
+ * @author Peter Karich
+ */
+public class GHMatrixSyncTest extends AbstractGHMatrixWebTester {
+
+    @Override
+    GraphHopperMatrixWeb createMatrixClient(String jsonStr) throws IOException {
+        JsonNode json = objectMapper.readTree(jsonStr);
+
+        // for test we grab the solution from the "batch json"
+        if (json.has("solution")) {
+            json = json.get("solution");
+        }
+
+        final String finalJsonStr = json.toString();
+        return new GraphHopperMatrixWeb(new GHMatrixSyncRequester("") {
+
+            @Override
+            protected String postJson(String url, JsonNode data) throws IOException {
+                return "{\"job_id\": \"1\"}";
+            }
+
+            @Override
+            protected String getJson(String url) throws IOException {
+                return finalJsonStr;
+            }
+        });
+    }
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GoogleMatrixSyncRequesterTest.java b/client-hc/src/test/java/com/graphhopper/api/GoogleMatrixSyncRequesterTest.java
new file mode 100644
index 0000000000..3c39c75d72
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GoogleMatrixSyncRequesterTest.java
@@ -0,0 +1,68 @@
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+import static com.graphhopper.api.AbstractGHMatrixWebTester.createRequest;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * @author Peter Karich
+ */
+public class GoogleMatrixSyncRequesterTest {
+    final ObjectMapper objectMapper = new ObjectMapper();
+
+    GraphHopperMatrixWeb createMatrixClient(String jsonStr) throws IOException {
+        JsonNode json = objectMapper.readTree(jsonStr);
+        final String finalJsonStr = json.toString();
+        return new GraphHopperMatrixWeb(new GoogleMatrixSyncRequester("") {
+
+            @Override
+            protected String postJson(String url, JsonNode data) throws IOException {
+                return "{\"job_id\": \"1\"}";
+            }
+
+            @Override
+            protected String getJson(String url) throws IOException {
+                return finalJsonStr;
+            }
+        });
+    }
+
+    @Test
+    public void testMatrix() throws IOException {
+        GHMRequest req = new GHMRequest();
+        req.addFromPoint(new GHPoint(51.534377, -0.087891));
+        req.addFromPoint(new GHPoint(51.467697, -0.090637));
+
+        req.addToPoint(new GHPoint(51.521241, -0.171833));
+        req.addToPoint(new GHPoint(51.467697, -0.090637));
+        req.addToPoint(new GHPoint(51.534377, -0.087891));
+
+        GraphHopperMatrixWeb matrix = createMatrixClient(AbstractGHMatrixWebTester.readFile(
+                new InputStreamReader(getClass().getResourceAsStream("google-matrix1.json"))));
+        MatrixResponse rsp = matrix.route(req);
+
+        assertEquals(712692, rsp.getDistance(0, 1), .1);
+        assertEquals(25995, rsp.getTime(0, 1) / 1000);
+
+        assertEquals(806813, rsp.getDistance(1, 2), .1);
+        assertEquals(28737, rsp.getTime(1, 2) / 1000);
+    }
+
+    @Test
+    public void testMatrixWithError() throws IOException {
+        GHMRequest req = createRequest();
+
+        GraphHopperMatrixWeb matrix = createMatrixClient(AbstractGHMatrixWebTester.readFile(
+                new InputStreamReader(getClass().getResourceAsStream("google-error1.json"))));
+        MatrixResponse rsp = matrix.route(req);
+        assertTrue(rsp.hasErrors());
+    }
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixBatchIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixBatchIT.java
new file mode 100644
index 0000000000..968d33c058
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixBatchIT.java
@@ -0,0 +1,12 @@
+package com.graphhopper.api;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperMatrixBatchIT extends AbstractGraphHopperMatrixWebIntegrationTester {
+
+    @Override
+    GraphHopperMatrixWeb createMatrixWeb() {
+        return new GraphHopperMatrixWeb(new GHMatrixBatchRequester());
+    }
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
new file mode 100644
index 0000000000..1b19f4404d
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
@@ -0,0 +1,33 @@
+package com.graphhopper.api;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperMatrixGoogleIT {
+
+    protected GraphHopperMatrixWeb ghMatrix;
+
+    @Before
+    public void setUp() {
+        // skip setKey as it is the graphhopper key
+        ghMatrix = createMatrixWeb();
+    }
+
+    GraphHopperMatrixWeb createMatrixWeb() {
+        return new GraphHopperMatrixWeb(new GoogleMatrixSyncRequester("https://maps.googleapis.com/maps/api/distancematrix/json"));
+    }
+
+    @Test
+    public void testMatrix() {
+        GHMRequest req = AbstractGHMatrixWebTester.createRequest();
+        MatrixResponse res = ghMatrix.route(req);
+
+        assertEquals(11000, res.getDistance(1, 2), 2000);
+        assertEquals(2500, res.getTime(1, 2) / 1000, 1000);
+    }
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixSyncIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixSyncIT.java
new file mode 100644
index 0000000000..bd57300c55
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixSyncIT.java
@@ -0,0 +1,12 @@
+package com.graphhopper.api;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperMatrixSyncIT extends AbstractGraphHopperMatrixWebIntegrationTester {
+
+    @Override
+    GraphHopperMatrixWeb createMatrixWeb() {
+        return new GraphHopperMatrixWeb(new GHMatrixSyncRequester());
+    }
+}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
new file mode 100644
index 0000000000..241ad0f3ef
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -0,0 +1,263 @@
+package com.graphhopper.api;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.util.Instruction;
+import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.RoundaboutInstruction;
+import com.graphhopper.util.exceptions.PointNotFoundException;
+import com.graphhopper.util.exceptions.PointOutOfBoundsException;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.net.SocketTimeoutException;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Peter Karich
+ */
+public class GraphHopperWebIT {
+
+    public static final String KEY = "614b8305-b4db-48c9-bf4a-40de90919939";
+
+    private final GraphHopperWeb gh = new GraphHopperWeb();
+    private final GraphHopperMatrixWeb ghMatrix = new GraphHopperMatrixWeb();
+
+    @Before
+    public void setUp() {
+        String key = System.getProperty("graphhopper.key", KEY);
+        gh.setKey(key);
+        ghMatrix.setKey(key);
+    }
+
+    @Test
+    public void testSimpleRoute() {
+        // https://graphhopper.com/maps/?point=49.6724%2C11.3494&point=49.655%2C11.418
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.6724, 11.3494)).
+                addPoint(new GHPoint(49.6550, 11.4180));
+        req.getHints().put("elevation", false);
+        req.getHints().put("instructions", true);
+        req.getHints().put("calc_points", true);
+        GHResponse res = gh.route(req);
+        assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
+        PathWrapper alt = res.getBest();
+        isBetween(200, 250, alt.getPoints().size());
+        isBetween(9900, 10300, alt.getDistance());
+
+        // change vehicle
+        res = gh.route(new GHRequest(49.6724, 11.3494, 49.6550, 11.4180).
+                setVehicle("bike"));
+        alt = res.getBest();
+        assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
+        isBetween(9000, 9500, alt.getDistance());
+    }
+
+    @Test
+    public void testTimeout() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.6724, 11.3494)).
+                addPoint(new GHPoint(49.6550, 11.4180));
+        GHResponse res = gh.route(req);
+        assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
+
+        req.getHints().put(GraphHopperWeb.TIMEOUT, 1);
+        try {
+            res = gh.route(req);
+            fail();
+        } catch (RuntimeException e) {
+            assertEquals(SocketTimeoutException.class, e.getCause().getClass());
+        }
+    }
+
+    @Test
+    public void testNoPoints() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.6724, 11.3494)).
+                addPoint(new GHPoint(49.6550, 11.4180));
+
+        req.getHints().put("instructions", false);
+        req.getHints().put("calc_points", false);
+        GHResponse res = gh.route(req);
+        assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
+        PathWrapper alt = res.getBest();
+        assertEquals(0, alt.getPoints().size());
+        isBetween(9900, 10300, alt.getDistance());
+    }
+
+    @Test
+    public void readRoundabout() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(52.261434, 13.485718)).
+                addPoint(new GHPoint(52.399067, 13.469238));
+
+        GHResponse res = gh.route(req);
+        int counter = 0;
+        for (Instruction i : res.getBest().getInstructions()) {
+            if (i instanceof RoundaboutInstruction) {
+                counter++;
+                RoundaboutInstruction ri = (RoundaboutInstruction) i;
+                assertEquals("turn_angle was incorrect:" + ri.getTurnAngle(), -1.5, ri.getTurnAngle(), 0.1);
+                // This route contains only one roundabout and no (via) point in a roundabout
+                assertEquals("exited was incorrect:" + ri.isExited(), ri.isExited(), true);
+            }
+        }
+        assertTrue("no roundabout in route?", counter > 0);
+    }
+
+    @Test
+    public void testRetrieveOnlyStreetname() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(52.261434, 13.485718)).
+                addPoint(new GHPoint(52.399067, 13.469238));
+
+        GHResponse res = gh.route(req);
+        assertEquals("Turn right onto B 246", res.getBest().getInstructions().get(4).getName());
+
+        req.getHints().put("turn_description", false);
+        res = gh.route(req);
+        assertEquals("B 246", res.getBest().getInstructions().get(4).getName());
+    }
+
+    @Test
+    public void testCannotFindPointException() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(-4.214943, -130.078125)).
+                addPoint(new GHPoint(39.909736, -91.054687));
+
+        GHResponse res = gh.route(req);
+        assertTrue("no erros found?", res.hasErrors());
+        assertTrue(res.getErrors().get(0) instanceof PointNotFoundException);
+    }
+
+
+    @Test
+    public void testOutOfBoundsException() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(-400.214943, -130.078125)).
+                addPoint(new GHPoint(39.909736, -91.054687));
+
+        GHResponse res = gh.route(req);
+        assertTrue("no erros found?", res.hasErrors());
+        assertTrue(res.getErrors().get(0) instanceof PointOutOfBoundsException);
+    }
+
+    @Test
+    public void readFinishInstruction() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(52.261434, 13.485718)).
+                addPoint(new GHPoint(52.399067, 13.469238));
+
+        GHResponse res = gh.route(req);
+        InstructionList instructions = res.getBest().getInstructions();
+        String finishInstructionName = instructions.get(instructions.size() - 1).getName();
+        assertEquals("Arrive at destination", finishInstructionName);
+    }
+
+    @Test
+    public void doNotReadFinishInstruction() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(52.261434, 13.485718)).
+                addPoint(new GHPoint(52.399067, 13.469238));
+        req.getHints().put("turn_description", false);
+        GHResponse res = gh.route(req);
+        InstructionList instructions = res.getBest().getInstructions();
+        String finishInstructionName = instructions.get(instructions.size() - 1).getName();
+        assertEquals("", finishInstructionName);
+    }
+
+    @Test
+    public void testSimpleExport() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.6724, 11.3494)).
+                addPoint(new GHPoint(49.6550, 11.4180));
+        req.getHints().put("elevation", false);
+        req.getHints().put("instructions", true);
+        req.getHints().put("calc_points", true);
+        req.getHints().put("type", "gpx");
+        String res = gh.export(req);
+        assertTrue(res.contains("<gpx"));
+        assertTrue(res.contains("<rtept lat="));
+        assertTrue(res.contains("<trk><name>GraphHopper Track</name><trkseg>"));
+        assertTrue(res.endsWith("</gpx>"));
+    }
+
+    @Test
+    public void testExportWithoutTrack() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.6724, 11.3494)).
+                addPoint(new GHPoint(49.6550, 11.4180));
+        req.getHints().put("elevation", false);
+        req.getHints().put("instructions", true);
+        req.getHints().put("calc_points", true);
+        req.getHints().put("type", "gpx");
+        req.getHints().put("gpx.track", "false");
+        String res = gh.export(req);
+        assertTrue(res.contains("<gpx"));
+        assertTrue(res.contains("<rtept lat="));
+        assertTrue(!res.contains("<trk><name>GraphHopper Track</name><trkseg>"));
+        assertTrue(res.endsWith("</gpx>"));
+    }
+
+    @Test
+    public void testCreateGPXFromInstructionList() {
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.6724, 11.3494)).
+                addPoint(new GHPoint(49.6550, 11.4180));
+        req.getHints().put("elevation", false);
+        req.getHints().put("instructions", true);
+        req.getHints().put("calc_points", true);
+        GHResponse ghResponse = gh.route(req);
+        String gpx = ghResponse.getBest().getInstructions().createGPX();
+        assertTrue(gpx.contains("<gpx"));
+        assertTrue(gpx.contains("<rtept lat="));
+        assertTrue(gpx.contains("<trk><name>"));
+        assertTrue(gpx.endsWith("</gpx>"));
+    }
+
+    void isBetween(double from, double to, double expected) {
+        assertTrue("expected value " + expected + " was smaller than limit " + from, expected >= from);
+        assertTrue("expected value " + expected + " was bigger than limit " + to, expected <= to);
+    }
+
+    @Test
+    public void testMatrix() {
+        GHMRequest req = AbstractGHMatrixWebTester.createRequest();
+        MatrixResponse res = ghMatrix.route(req);
+
+        // no distances available
+        try {
+            assertEquals(0, res.getDistance(1, 2), 1);
+            assertTrue(false);
+        } catch (Exception ex) {
+        }
+
+        // ... only weight:
+        assertEquals(1685, res.getWeight(1, 2), 5);
+
+        req = AbstractGHMatrixWebTester.createRequest();
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        res = ghMatrix.route(req);
+
+        assertEquals(9664, res.getDistance(1, 2), 20);
+        assertEquals(1685, res.getWeight(1, 2), 10);
+    }
+
+    @Test
+    public void testUnknownInstructionSign() throws IOException {
+        // Actual path for the request: point=48.354413%2C8.676335&point=48.35442%2C8.676345
+        // Modified the sign though
+        JsonNode json = new ObjectMapper().readTree("{\"instructions\":[{\"distance\":1.073,\"sign\":741,\"interval\":[0,1],\"text\":\"Continue onto A 81\",\"time\":32,\"street_name\":\"A 81\"},{\"distance\":0,\"sign\":4,\"interval\":[1,1],\"text\":\"Finish!\",\"time\":0,\"street_name\":\"\"}],\"descend\":0,\"ascend\":0,\"distance\":1.073,\"bbox\":[8.676286,48.354446,8.676297,48.354453],\"weight\":0.032179,\"time\":32,\"points_encoded\":true,\"points\":\"gfcfHwq}s@}c~AAA?\",\"snapped_waypoints\":\"gfcfHwq}s@}c~AAA?\"}");
+        PathWrapper wrapper = new GraphHopperWeb().createPathWrapper(json, true, true, true, true, false);
+
+        assertEquals(741, wrapper.getInstructions().get(0).getSign());
+        assertEquals("Continue onto A 81", wrapper.getInstructions().get(0).getName());
+    }
+}
diff --git a/client-hc/src/test/resources/com/graphhopper/api/google-error1.json b/client-hc/src/test/resources/com/graphhopper/api/google-error1.json
new file mode 100644
index 0000000000..602a687bd5
--- /dev/null
+++ b/client-hc/src/test/resources/com/graphhopper/api/google-error1.json
@@ -0,0 +1,7 @@
+{
+    "destination_addresses": [],
+    "error_message": "You have exceeded your rate-limit for this API.",
+    "origin_addresses": [],
+    "rows": [],
+    "status": "OVER_QUERY_LIMIT"
+}
\ No newline at end of file
diff --git a/client-hc/src/test/resources/com/graphhopper/api/google-matrix1.json b/client-hc/src/test/resources/com/graphhopper/api/google-matrix1.json
new file mode 100644
index 0000000000..a16b556aba
--- /dev/null
+++ b/client-hc/src/test/resources/com/graphhopper/api/google-matrix1.json
@@ -0,0 +1,88 @@
+{
+  "destination_addresses": [
+    "334-350 Hicks St, Brooklyn, NY 11201, USA",
+    "334-350 Hicks St, Brooklyn, NY 11201, USA",
+    "334-350 Hicks St, Brooklyn, NY 11201, USA"
+  ],
+  "origin_addresses": [
+    "45 Bell St, Chagrin Falls, OH 44022, USA",
+    "170 Lynch Church Road, Marietta, OH 45750, USA"
+  ],
+  "rows": [
+    {
+      "elements": [
+        {
+          "distance": {
+            "text": "443 mi",
+            "value": 712692
+          },
+          "duration": {
+            "text": "7 hours 13 mins",
+            "value": 25995
+          },
+          "status": "OK"
+        },
+        {
+          "distance": {
+            "text": "443 mi",
+            "value": 712692
+          },
+          "duration": {
+            "text": "7 hours 13 mins",
+            "value": 25995
+          },
+          "status": "OK"
+        },
+        {
+          "distance": {
+            "text": "443 mi",
+            "value": 712692
+          },
+          "duration": {
+            "text": "7 hours 13 mins",
+            "value": 25995
+          },
+          "status": "OK"
+        }
+      ]
+    },
+    {
+      "elements": [
+        {
+          "distance": {
+            "text": "501 mi",
+            "value": 806813
+          },
+          "duration": {
+            "text": "7 hours 59 mins",
+            "value": 28737
+          },
+          "status": "OK"
+        },
+        {
+          "distance": {
+            "text": "501 mi",
+            "value": 806813
+          },
+          "duration": {
+            "text": "7 hours 59 mins",
+            "value": 28737
+          },
+          "status": "OK"
+        },
+        {
+          "distance": {
+            "text": "501 mi",
+            "value": 806813
+          },
+          "duration": {
+            "text": "7 hours 59 mins",
+            "value": 28737
+          },
+          "status": "OK"
+        }
+      ]
+    }
+  ],
+  "status": "OK"
+}
diff --git a/client-hc/src/test/resources/com/graphhopper/api/matrix-weights-only.json b/client-hc/src/test/resources/com/graphhopper/api/matrix-weights-only.json
new file mode 100644
index 0000000000..f6e2e941b8
--- /dev/null
+++ b/client-hc/src/test/resources/com/graphhopper/api/matrix-weights-only.json
@@ -0,0 +1,10 @@
+{
+    "status": "finished",
+    "solution": {
+        "info": {
+            "took": 0.049935993,
+            "copyrights": ["GraphHopper", "OpenStreetMap contributors"]
+        },
+        "weights": [[0.0, 885.867, 605.35, 1130.857], [847.623, 0.0, 807.167, 927.171], [561.04, 777.33, 0.0, 660.491], [1102.729, 905.987, 662.747, 0.0]]        
+    }
+}
\ No newline at end of file
diff --git a/client-hc/src/test/resources/com/graphhopper/api/matrix.json b/client-hc/src/test/resources/com/graphhopper/api/matrix.json
new file mode 100644
index 0000000000..b0f62be740
--- /dev/null
+++ b/client-hc/src/test/resources/com/graphhopper/api/matrix.json
@@ -0,0 +1,12 @@
+{
+    "status": "finished",
+    "solution": {
+        "info": {
+            "took": 0.049935993,
+            "copyrights": ["GraphHopper", "OpenStreetMap contributors"]
+        },
+        "distances": [[0, 9475, 7199, 12869], [8939, 0, 9734, 10996], [7014, 9116, 0, 8616], [12459, 10720, 8450, 0]],
+        "times": [[0, 886, 605, 1131], [848, 0, 807, 927], [561, 777, 0, 660], [1103, 906, 663, 0]],
+        "weights": [[0.0, 885.867, 605.35, 1130.857], [847.623, 0.0, 807.167, 927.171], [561.04, 777.33, 0.0, 660.491], [1102.729, 905.987, 662.747, 0.0]]        
+    }
+}
\ No newline at end of file
diff --git a/client-hc/src/test/resources/com/graphhopper/api/matrix_error.json b/client-hc/src/test/resources/com/graphhopper/api/matrix_error.json
new file mode 100644
index 0000000000..68aa928dbd
--- /dev/null
+++ b/client-hc/src/test/resources/com/graphhopper/api/matrix_error.json
@@ -0,0 +1,8 @@
+{
+    "message": "Cannot find from_points: 7, 8",
+    "hints": [{
+            "message": "Cannot find from_points: 7, 8"
+        }, {
+            "message": "Cannot find to_points: 7, 8"
+        }]
+}
\ No newline at end of file
diff --git a/client-hc/src/test/resources/log4j.xml b/client-hc/src/test/resources/log4j.xml
new file mode 100644
index 0000000000..a9bb71c09f
--- /dev/null
+++ b/client-hc/src/test/resources/log4j.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
+<log4j:configuration>
+    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
+        </layout>
+    </appender>
+    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
+        <param name="BufferSize" value="500"/>
+        <appender-ref ref="stdout"/>
+    </appender>    
+    <logger name="com.graphhopper" additivity="false">
+        <level value="warn" />
+        <appender-ref ref="ASYNC" />
+    </logger>
+    <root>
+        <priority value="warn"></priority>
+        <appender-ref ref="ASYNC"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index c6889af7dd..f481a8d9cf 100644
--- a/pom.xml
+++ b/pom.xml
@@ -80,6 +80,7 @@
         <module>reader-json</module>
         <module>tools</module>
         <module>web</module>
+        <module>client-hc</module>
     </modules>
     <build>
         <plugins>
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 2b818b29a5..59199cb0f0 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -226,14 +226,25 @@ private void parseSolutionsAndAddToResponse(List<Label> solutions, PointList way
         }
 
         private int accessNode(Label solution) {
-            while(solution.parent.parent != null) {
-                solution = solution.parent;
+            if (!arriveBy) {
+                while (solution.parent.parent != null) {
+                    solution = solution.parent;
+                }
+                return solution.adjNode;
+            } else {
+                return solution.parent.adjNode;
             }
-            return solution.adjNode;
         }
 
         private int egressNode(Label solution) {
-            return solution.parent.adjNode;
+            if (!arriveBy) {
+                return solution.parent.adjNode;
+            } else {
+                while(solution.parent.parent != null) {
+                    solution = solution.parent;
+                }
+                return solution.adjNode;
+            }
         }
 
         private List<Label> findPaths(int startNode, int destNode) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index 2945eabf13..a15134a09e 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -124,7 +124,7 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                     }
                     double walkDistanceOnCurrentLeg = (!reverse && edgeType == GtfsStorage.EdgeType.BOARD || reverse && edgeType == GtfsStorage.EdgeType.ALIGHT) ? 0 : (label.walkDistanceOnCurrentLeg + weighting.getWalkDistance(edge));
                     boolean isTryingToReEnterPtAfterTransferWalking = (!reverse && edgeType == GtfsStorage.EdgeType.ENTER_PT || reverse && edgeType == GtfsStorage.EdgeType.EXIT_PT) && label.nTransfers > 0 && label.walkDistanceOnCurrentLeg > maxTransferDistancePerLeg;
-                    long walkTime = label.walkTime + (edgeType == GtfsStorage.EdgeType.HIGHWAY ? nextTime - label.currentTime : 0);
+                    long walkTime = label.walkTime + (edgeType == GtfsStorage.EdgeType.HIGHWAY || edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT ? nextTime - label.currentTime : 0);
                     int nWalkDistanceConstraintViolations = Math.min(1, label.nWalkDistanceConstraintViolations + (
                             isTryingToReEnterPtAfterTransferWalking ? 1 : (label.walkDistanceOnCurrentLeg <= maxWalkDistancePerLeg && walkDistanceOnCurrentLeg > maxWalkDistancePerLeg ? 1 : 0)));
                     Set<Label> sptEntries = fromMap.get(edge.getAdjNode());
diff --git a/web/pom.xml b/web/pom.xml
index a427247c8a..89872c9952 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -94,19 +94,12 @@
 
         <!-- for integration tests of service -->
         <dependency>
-            <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-webapp</artifactId>
-            <version>${jetty.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <!-- for integration tests of service --> 
-        <dependency>
-            <groupId>com.squareup.okhttp3</groupId>
-            <artifactId>okhttp</artifactId>
-            <version>3.4.2</version>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>directions-api-client-hc</artifactId>
+            <version>0.10-SNAPSHOT</version>
             <scope>test</scope>
         </dependency>
-        
+
     </dependencies>
 
     <build>
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 2f34e3ea8d..0891185abc 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -114,7 +114,7 @@ public void testFailIfElevationRequestedButNotIncluded() throws Exception {
 
     @Test
     public void testGraphHopperWeb() throws Exception {
-        GraphHopperAPI hopper = new GraphHopperWeb();
+        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load(getTestRouteAPIUrl()));
         GHResponse rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128));
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
@@ -143,7 +143,7 @@ public void testGraphHopperWeb() throws Exception {
 
     @Test
     public void testPathDetails() throws Exception {
-        GraphHopperAPI hopper = new GraphHopperWeb();
+        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load(getTestRouteAPIUrl()));
         GHRequest request = new GHRequest(42.554851, 1.536198, 42.510071, 1.548128);
         request.setPathDetails(Arrays.asList("average_speed", "edge_id", "time"));
@@ -181,7 +181,7 @@ public void testPathDetails() throws Exception {
 
     @Test
     public void testPathDetailsNoConnection() throws Exception {
-        GraphHopperAPI hopper = new GraphHopperWeb();
+        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load(getTestRouteAPIUrl()));
         GHRequest request = new GHRequest(42.542078, 1.45586, 42.537841, 1.439981);
         request.setPathDetails(Arrays.asList("average_speed"));
@@ -207,7 +207,7 @@ public void testPathDetailsWithoutGraphHopperWeb() throws Exception {
 
     @Test
     public void testInitInstructionsWithTurnDescription() {
-        GraphHopperAPI hopper = new GraphHopperWeb();
+        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load(getTestRouteAPIUrl()));
         GHRequest request = new GHRequest(42.554851, 1.536198, 42.510071, 1.548128);
         GHResponse rsp = hopper.route(request);
@@ -220,7 +220,7 @@ public void testInitInstructionsWithTurnDescription() {
 
     @Test
     public void testGraphHopperWebRealExceptions() {
-        GraphHopperAPI hopper = new GraphHopperWeb();
+        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load(getTestRouteAPIUrl()));
 
         // IllegalArgumentException (Wrong Request)
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java b/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
deleted file mode 100644
index 6539e43281..0000000000
--- a/web/src/test/java/com/graphhopper/http/GraphHopperWebTest.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper GmbH licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.http;
-
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.PathWrapper;
-import com.graphhopper.util.Downloader;
-import com.graphhopper.util.Helper;
-import org.junit.Test;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.util.Arrays;
-
-import static org.junit.Assert.*;
-
-/**
- * @author Peter Karich
- */
-public class GraphHopperWebTest {
-    // see also GraphHopperServletIT.testGraphHopperWeb for real routes against local jetty service    
-
-    @Test
-    public void testReadEncoded() throws Exception {
-        Downloader downloader = new Downloader("GraphHopper Test") {
-            @Override
-            public InputStream fetch(HttpURLConnection conn, boolean readErrorStreamNoException) throws IOException {
-                return getClass().getResourceAsStream("test_encoded.json");
-            }
-        };
-        GraphHopperWeb instance = new GraphHopperWeb();
-        instance.setDownloader(downloader);
-        GHResponse rsp = instance.route(new GHRequest(52.47379, 13.362808, 52.4736925, 13.3904394));
-        PathWrapper arsp = rsp.getBest();
-        assertEquals(2138.3, arsp.getDistance(), 1e-1);
-        assertEquals(17, arsp.getPoints().getSize());
-        assertEquals(5, arsp.getInstructions().size());
-        assertEquals("(0,Geradeaus auf A 100,1268.519329705091,65237)", arsp.getInstructions().get(0).toString());
-        assertEquals(11, arsp.getInstructions().get(0).getPoints().size());
-
-        assertEquals(43.73595, arsp.getWaypoints().getLat(0), 1e-4);
-        assertEquals(7.42015, arsp.getWaypoints().getLon(0), 1e-4);
-        assertEquals(43.73761, arsp.getWaypoints().getLat(1), 1e-4);
-    }
-
-    @Test
-    public void testCreateURL() throws Exception {
-        Downloader downloader = new Downloader("GraphHopper Test") {
-            @Override
-            public String downloadAsString(String url, boolean readErrorStreamNoException) throws IOException {
-                assertFalse(url.contains("xy"));
-                assertFalse(url.contains("algo1"));
-                assertTrue(url.contains("alternative_route.max_paths=4"));
-
-                assertEquals("https://graphhopper.com/api/1/route?point=52.0,13.0&point=52.0,14.0&&type=json&instructions=true&points_encoded=true&calc_points=true&algorithm=&locale=en_US&elevation=false&key=blup&alternative_route.max_paths=4", url);
-                return Helper.isToString(getClass().getResourceAsStream("test_encoded.json"));
-            }
-        };
-        GraphHopperWeb instance = new GraphHopperWeb();
-        instance.setKey("blup");
-        instance.setDownloader(downloader);
-        GHRequest req = new GHRequest(52, 13, 52, 14);
-
-        // should be ignored, use GraphHopperWeb or GHRequest directly instead
-        req.getHints().put("key", "xy");
-        req.getHints().put("algorithm", "algo1");
-        req.getHints().put("alternative_route.max_paths", "4");
-        instance.route(req);
-    }
-
-    @Test
-    public void testSimpleToStringStream() {
-        assertEquals("12;2", Arrays.asList("12", "2").stream().reduce("", (s1, s2) -> s1.isEmpty() ? s2 : s1 + ";" + s2));
-        assertEquals("2", Arrays.asList("2").stream().reduce("", (s1, s2) -> s1.isEmpty() ? s2 : s1 + ";" + s2));
-    }
-}
