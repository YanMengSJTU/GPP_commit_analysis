diff --git a/config-example.properties b/config-example.properties
index f57a1add45..7890d07015 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -1,41 +1,52 @@
-####################
 ##### Vehicles #####
+#
 # Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
-# When using two or three option together set "prepare.chWeighting=no" - see below
 # bike2 takes elevation data into account (like up-hill is slower than down-hill)
-# and requires enabling graph.elevation.provider below, e.g. see #169
+# and requires enabling graph.elevation.provider below
 graph.flagEncoders=car
 
-# to enable turn restrictions for car do
+# Enable turn restrictions for car or motorcycle. 
+# Currently you need to additionally set prepare.chWeighting=no before using this (see below and #270)
 # graph.flagEncoders=car|turnCosts=true
 
 
-
 ##### Elevation #####
+#
 # To populate your graph with elevation data use SRTM, default is noop
 # graph.elevation.provider=srtm
 #
-# default location for cache is used /tmp/srtm
+# default location for cache is /tmp/srtm
 # graph.elevation.cachedir=./srtmprovider/
 #
-# If you have a slow disk or plenty of RAM change the default MMAP to
+# If you have a slow disk or plenty of RAM change the default MMAP to:
 # graph.elevation.dataaccess=RAM_STORE
 
 
 
 ##### Storage #####
-# configure the memory access, use RAM_STORE for well equipped servers
+#
+# configure the memory access, use RAM_STORE for well equipped servers, 
 # MMAP_STORE_SYNC could be used otherwise but will be a lot slower
 graph.dataaccess=RAM_STORE
 
-# if you want to reduce storage size and you don't need instructions for a path uncomment this
+# if you want to reduce storage size and you don't need instructions for the resulting path use:
 # osmreader.instructions=false
 
-# Default: use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
-prepare.chWeighting=fastest
+#### Speed-up Mode vs. Flexibility Mode ####
+#
+# By default the speed-up mode with the 'fastest' weighting is used. Internally contraction hierarchies is 
+# used to speed routing up. This requires more RAM/disc space for holding the graph but less for every request.
+# prepare.chWeighting=fastest
+#
+# Disable the speed-up mode (contraction hierarchies, CH) via enabling the flexibility mode:
+# prepare.chWeighting=no
 
 
+# If multiple vehicles are used and prepare.chWeighting=fastest only one vehicle can be in speed-up
+# When nothing is specified the (lexicographically) first vehicle from the graph.flagEncoders list is chosen
+# algorithm.defaultVehicle=car
 
 ##### Web #####
-# if you want to support jsonp response type you need to add it explicitely here:
-#web.jsonpAllowed=true
+# if you want to support jsonp response type you need to add it explicitely here. By default it is disabled for 
+# stronger security.
+# web.jsonpAllowed=true
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index d978edceea..3ded1da004 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,9 @@
 0.4.0
+    create location index before preparation in the GraphHopper class
+    encodingManager.getSingle() is removed as one can specify an encoder explicitly. GraphHopper picks the first encoder automatically for default vehicle, can be overwritten via setDefaultVehicle
+    removed LocationIndexTreeSC, use new LocationIndexTree(levelGraph.getOriginalGraph(), directory) instead
+    getLevel and setLevel do no longer automatically increase node count, use getNodeAccess.ensureNode for that
+    normal algorithms are now possible on prepared graph use getOriginalGraph, see #116
     GHResponse no longer has isFound method, use !hasErrors instead
     merged unused Edge class into EdgeEntry
     astar and astarbi are now both none-heuristic and take parameters for beeline approximation: astar.approximation=BeelineSimplification|BeelineAccurate or astarbi.approximation=...
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 1d0e4298c2..4b3edc8766 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -66,6 +66,7 @@
     private double defaultWeightLimit = Double.MAX_VALUE;
     private boolean simplifyResponse = true;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private String defaultVehicleStr;
     private RoutingAlgorithmFactory algoFactory;
     // for index
     private LocationIndex locationIndex;
@@ -77,7 +78,7 @@
     // for CH prepare    
     private boolean doPrepare = true;
     private boolean chEnabled = true;
-    private String chWeighting = "fastest";
+    private String chWeightingStr = "fastest";
     private int periodicUpdates = -1;
     private int lazyUpdates = -1;
     private int neighborUpdates = -1;
@@ -104,6 +105,7 @@ protected GraphHopper loadGraph( GraphStorage g )
         this.graph = g;
         fullyLoaded = true;
         initLocationIndex();
+        initDefaultVehicleIfNecessary();
         return this;
     }
 
@@ -121,6 +123,11 @@ public GraphHopper setEncodingManager( EncodingManager em )
         return this;
     }
 
+    private FlagEncoder getFirstVehicle()
+    {
+        return encodingManager.fetchEdgeEncoders().get(0);
+    }
+
     public EncodingManager getEncodingManager()
     {
         return encodingManager;
@@ -272,12 +279,28 @@ private GraphHopper setUnsafeMemory()
     }
 
     /**
-     * Disables "CH-preparation". Use only if you know what you do.
+     * This method sets the default vehicle to use if no vehicle is specified in the GHRequest
+     * object. Per default the lexicographically first vehicle is used.
      */
-    public GraphHopper setDoPrepare( boolean doPrepare )
+    public void setDefaultVehicle( String defaultVehicleStr )
     {
-        this.doPrepare = doPrepare;
-        return this;
+        if (this.defaultVehicleStr != null)
+            throw new RuntimeException("Cannot change default vehicle " + this.defaultVehicleStr + " to " + defaultVehicleStr);
+
+        this.defaultVehicleStr = defaultVehicleStr;
+    }
+
+    /**
+     * The default vehicle is the single vehicle used for CH preparation as well as the default
+     * vehicle if no specified in GHRequest. Per default the lexicographically first vehicle is
+     * used.
+     */
+    public String getDefaultVehicle()
+    {
+        if (defaultVehicleStr == null)
+            throw new RuntimeException("Set default vehicle before");
+
+        return defaultVehicleStr;
     }
 
     /**
@@ -289,18 +312,29 @@ public GraphHopper setDoPrepare( boolean doPrepare )
     public GraphHopper setCHWeighting( String weighting )
     {
         ensureNotLoaded();
-        chWeighting = weighting;
+        chWeightingStr = weighting;
         return this;
     }
 
     public String getCHWeighting()
     {
-        return chWeighting;
+        return chWeightingStr;
     }
 
     /**
-     * Enables or disables contraction hierarchies. Enabled by default. Disabling CH is only
-     * recommended for a small area or in combination with setDefaultWeightLimit
+     * Disables the "CH-preparation" preparation only. Use only if you know what you do. To disable
+     * the full usage of CH use setCHEnable(false) instead.
+     */
+    public GraphHopper setDoPrepare( boolean doPrepare )
+    {
+        this.doPrepare = doPrepare;
+        return this;
+    }
+
+    /**
+     * Enables or disables contraction hierarchies (CH). This speed-up mode is enabled by default.
+     * Disabling CH is only recommended for short routes or in combination with
+     * setDefaultWeightLimit and called flexibility mode
      * <p>
      * @see #setDefaultWeightLimit(double)
      */
@@ -556,12 +590,14 @@ public GraphHopper init( CmdArgs args )
 
         // osm import
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
-        String flagEncoders = args.get("graph.flagEncoders", "CAR");
-
+        String flagEncoders = args.get("graph.flagEncoders", "");
         setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
+        // default vehicle which is used if no algorithm is specified
+        setDefaultVehicle(args.get("algorithm.defaultVehicle", getFirstVehicle().toString()));
+
         // index
         preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
         maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
@@ -713,7 +749,9 @@ public boolean load( String graphHopperFolder )
         setGraphHopperLocation(graphHopperFolder);
 
         if (encodingManager == null)
-            encodingManager = EncodingManager.create(ghLocation);
+            setEncodingManager(EncodingManager.create(ghLocation));
+
+        initDefaultVehicleIfNecessary();
 
         if (!allowWrites && dataAccessType.isMMap())
             dataAccessType = DAType.MMAP_RO;
@@ -772,15 +810,14 @@ public void setAlgorithmFactory( RoutingAlgorithmFactory algoFactory )
      */
     protected void postProcessing()
     {
-        encodingManager = graph.getEncodingManager();
+        initLocationIndex();
         if (chEnabled)
             algoFactory = createPrepare();
         else
             algoFactory = new RoutingAlgorithmFactorySimple();
 
         if (!isPrepared())
-            prepare();
-        initLocationIndex();
+            prepare();        
     }
 
     private boolean isPrepared()
@@ -790,9 +827,16 @@ private boolean isPrepared()
 
     protected RoutingAlgorithmFactory createPrepare()
     {
-        FlagEncoder encoder = encodingManager.getSingle();
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph, encoder,
-                createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
+        if (!encodingManager.supports(getDefaultVehicle()))
+        {
+            throw new IllegalStateException("Should not happen: default vehicle " + getDefaultVehicle() + " not supported"
+                    + " from EncodingManager " + encodingManager.toDetailsString() + ". Cannot do CH preparation");
+        }
+
+        FlagEncoder defaultVehicle = encodingManager.getEncoder(getDefaultVehicle());
+        Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
+        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph,
+                defaultVehicle, weighting, traversalMode);
         tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
                 setLazyUpdates(lazyUpdates).
                 setNeighborUpdates(neighborUpdates).
@@ -876,7 +920,7 @@ public GHResponse route( GHRequest request )
 
         String vehicle = request.getVehicle();
         if (vehicle.isEmpty())
-            vehicle = encodingManager.getSingle().toString();
+            vehicle = getDefaultVehicle();
 
         if (!encodingManager.supports(vehicle))
         {
@@ -924,7 +968,19 @@ public GHResponse route( GHRequest request )
             return Collections.emptyList();
 
         String debug = "idLookup:" + sw.stop().getSeconds() + "s";
-        QueryGraph queryGraph = new QueryGraph(graph);
+
+        QueryGraph queryGraph;
+        RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
+        if (chEnabled && !vehicle.equals(getDefaultVehicle()))
+        {
+            // fall back to normal traversing
+            tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
+            queryGraph = new QueryGraph(graph.getBaseGraph());
+        } else
+        {
+            queryGraph = new QueryGraph(graph);
+        }
+
         queryGraph.lookup(qResults);
 
         List<Path> paths = new ArrayList<Path>(points.size() - 1);
@@ -934,13 +990,15 @@ public GHResponse route( GHRequest request )
 
         double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
         String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
-        AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).build();
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().
+                algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).
+                build();
 
         for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
         {
             QueryResult toQResult = qResults.get(placeIndex);
             sw = new StopWatch().start();
-            RoutingAlgorithm algo = getAlgorithmFactory().createAlgo(queryGraph, algoOpts);
+            RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
             algo.setWeightLimit(weightLimit);
             debug += ", algoInit:" + sw.stop().getSeconds() + "s";
 
@@ -968,17 +1026,9 @@ public GHResponse route( GHRequest request )
 
     protected LocationIndex createLocationIndex( Directory dir )
     {
-        LocationIndex tmpIndex;
-        if (graph instanceof LevelGraph)
-        {
-            tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-        } else
-        {
-            tmpIndex = new LocationIndexTree(graph, dir);
-        }
+        LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
         tmpIndex.setResolution(preciseIndexResolution);
-        ((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
-
+        tmpIndex.setMaxRegionSearch(maxRegionSearch);
         if (!tmpIndex.loadExisting())
         {
             ensureWriteAccess();
@@ -1028,11 +1078,7 @@ protected void prepare()
         if (tmpPrepare)
         {
             ensureWriteAccess();
-            if (encodingManager.getVehicleCount() > 1)
-                throw new IllegalArgumentException("Contraction hierarchies preparation "
-                        + "requires (at the moment) only one vehicle. But was:" + encodingManager);
-
-            logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... (" + Helper.getMemInfo() + ")");
+            logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
             ((PrepareContractionHierarchies) algoFactory).doWork();
             graph.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
@@ -1122,4 +1168,14 @@ public long getVisitedSum()
     {
         return visitedSum.get();
     }
+
+    private void initDefaultVehicleIfNecessary()
+    {
+        if (defaultVehicleStr == null)
+            setDefaultVehicle(getFirstVehicle().toString());
+
+        if (!encodingManager.supports(getDefaultVehicle()))
+            throw new IllegalArgumentException("Default vehicle " + defaultVehicleStr + " is not supported. "
+                    + "Include vehicle in EncodingManager or via the property graph.flagEncoders OR set it explicitely via setDefaultVehicle");
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
index 2edee09bc7..0c612d5e7b 100644
--- a/core/src/main/java/com/graphhopper/reader/PillarInfo.java
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -57,26 +57,28 @@ public int getDimension()
     }
 
     @Override
-    public void setNode( int id, double lat, double lon )
+    public void ensureNode( int nodeId )
     {
-//        if (is3D())
-//            throw new IllegalStateException("Can only be called if 3D is disabled");
+        long tmp = (long) nodeId * rowSizeInBytes;
+        da.ensureCapacity(tmp + rowSizeInBytes);
+    }        
 
-        _setNode(id, lat, lon, Double.NaN);
+    @Override
+    public void setNode( int nodeId, double lat, double lon )
+    {
+        _setNode(nodeId, lat, lon, Double.NaN);
     }
 
     @Override
-    public void setNode( int id, double lat, double lon, double ele )
+    public void setNode( int nodeId, double lat, double lon, double ele )
     {
-//        if (!is3D())
-//            throw new IllegalStateException("Can only be called if 3D is enabled");
-        _setNode(id, lat, lon, ele);
+        _setNode(nodeId, lat, lon, ele);
     }
 
-    private void _setNode( int id, double lat, double lon, double ele )
+    private void _setNode( int nodeId, double lat, double lon, double ele )
     {
-        long tmp = (long) id * rowSizeInBytes;
-        da.ensureCapacity(tmp + rowSizeInBytes);
+        ensureNode(nodeId);
+        long tmp = (long) nodeId * rowSizeInBytes;
         da.setInt(tmp + LAT, Helper.degreeToInt(lat));
         da.setInt(tmp + LON, Helper.degreeToInt(lon));
 
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index d919509837..54f4284bf1 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -258,7 +258,7 @@ private void forEveryEdge( EdgeVisitor visitor )
                         + ", array index:" + i + ", edges:" + edgeIds.size());
 
             tmpNode = edgeBase.getBaseNode();
-            // later: more efficient swap
+            // more efficient swap, currently not implemented for virtual edges: visitor.next(edgeBase.detach(true), i);
             edgeBase = graph.getEdgeProps(edgeBase.getEdge(), tmpNode);
             visitor.next(edgeBase, i);
         }
@@ -434,13 +434,13 @@ public void next( EdgeIteratorState edge, int index )
                 } else
                 {
                     if (isRoundabout)
-                        // remark: names and annotations within roundabout are ignored
+                    // remark: names and annotations within roundabout are ignored
                     {
                         if (!prevInRoundabout) //just entered roundabout
                         {
                             int sign = Instruction.USE_ROUNDABOUT;
                             RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name,
-                                                                annotation, new PointList(10, nodeAccess.is3D()));
+                                    annotation, new PointList(10, nodeAccess.is3D()));
                             if (prevName != null)
                             {
                                 // previous orientation is last orientation before entering roundabout
@@ -468,7 +468,10 @@ public void next( EdgeIteratorState edge, int index )
                         // This could lead to problems if there are non-complete roundabouts!
                         EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
                         edgeIter.next();
-                        if (edgeIter.next()) {((RoundaboutInstruction) prevInstruction).increaseExitNumber();}
+                        if (edgeIter.next())
+                        {
+                            ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
+                        }
 
                     } else if (prevInRoundabout) //previously in roundabout but not anymore
                     {
@@ -487,9 +490,9 @@ public void next( EdgeIteratorState edge, int index )
                         double deltaOut = (orientation - recentOrientation);
 
                         prevInstruction = ((RoundaboutInstruction) prevInstruction)
-                            .setRadian(deltaInOut)
-                            .setDirOfRotation(deltaOut)
-                            .setExited();
+                                .setRadian(deltaInOut)
+                                .setDirOfRotation(deltaOut)
+                                .setExited();
 
                         prevName = name;
                         prevAnnotation = annotation;
@@ -532,7 +535,7 @@ public void next( EdgeIteratorState edge, int index )
                                 sign = Instruction.TURN_SHARP_RIGHT;
 
                         }
-                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()) );
+                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
                         ways.add(prevInstruction);
                         prevName = name;
                         prevAnnotation = annotation;
@@ -545,12 +548,11 @@ public void next( EdgeIteratorState edge, int index )
                 {
                     doublePrevLat = prevLat;
                     doublePrevLong = prevLon;
-                }
-                else
+                } else
                 {
                     int beforeLast = wayGeo.getSize() - 2;
                     doublePrevLat = wayGeo.getLatitude(beforeLast);
-                    doublePrevLong =  wayGeo.getLongitude(beforeLast);
+                    doublePrevLong = wayGeo.getLongitude(beforeLast);
                 }
                 prevInRoundabout = isRoundabout;
                 prevLat = adjLat;
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index 7d794145e1..ffbb943041 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -19,10 +19,7 @@
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphExtension;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -54,6 +51,8 @@
     private final NodeAccess mainNodeAccess;
     private final int mainNodes;
     private final int mainEdges;
+    private final QueryGraph baseGraph;
+    private final GraphExtension wrappedExtension;
     private List<QueryResult> queryResults;
     /**
      * Virtual edges are created between existing graph and new virtual tower nodes. For every
@@ -66,8 +65,6 @@
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
-    private final DistanceCalc distCalc = Helper.DIST_PLANE;
-    private final GraphExtension wrappedExtension;
 
     public QueryGraph( Graph graph )
     {
@@ -80,6 +77,22 @@ public QueryGraph( Graph graph )
             wrappedExtension = new QueryGraphTurnExt(this);
         else
             wrappedExtension = mainGraph.getExtension();
+
+        // create very lightweight QueryGraph which uses variables from this QueryGraph (same virtual edges)
+        baseGraph = new QueryGraph(graph.getBaseGraph(), this);
+    }
+
+    /**
+     * See 'lookup' for further variables that are initialized
+     */
+    private QueryGraph( Graph graph, QueryGraph superQueryGraph )
+    {
+        mainGraph = graph;
+        baseGraph = this;
+        wrappedExtension = superQueryGraph.wrappedExtension;
+        mainNodeAccess = graph.getNodeAccess();
+        mainNodes = superQueryGraph.mainNodes;
+        mainEdges = superQueryGraph.mainEdges;
     }
 
     /**
@@ -103,9 +116,13 @@ public void lookup( List<QueryResult> resList )
         if (isInitialized())
             throw new IllegalStateException("Call lookup only once. Otherwise you'll have problems for queries sharing the same edge.");
 
+        // initialize all none-final variables
         virtualEdges = new ArrayList<EdgeIteratorState>(resList.size() * 2);
         virtualNodes = new PointList(resList.size(), mainNodeAccess.is3D());
         queryResults = new ArrayList<QueryResult>(resList.size());
+        baseGraph.virtualEdges = virtualEdges;
+        baseGraph.virtualNodes = virtualNodes;
+        baseGraph.queryResults = queryResults;
 
         TIntObjectMap<List<QueryResult>> edge2res = new TIntObjectHashMap<List<QueryResult>>(resList.size());
 
@@ -191,8 +208,8 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                             double fromLat = fullPL.getLatitude(o1.getWayIndex());
                             double fromLon = fullPL.getLongitude(o1.getWayIndex());
-                            if (distCalc.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
-                                    > distCalc.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
+                            if (Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
+                                    > Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
                                 return 1;
                             return -1;
                         }
@@ -258,6 +275,25 @@ public int compare( QueryResult o1, QueryResult o2 )
         });
     }
 
+    @Override
+    public Graph getBaseGraph()
+    {
+        // Note: if the mainGraph of this QueryGraph is a LevelGraph then ignoring the shortcuts will produce a 
+        // huge gap of edgeIds between base and virtual edge ids. The only solution would be to move virtual edges
+        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
+        return baseGraph;
+    }
+
+    public boolean isVirtualEdge( int edgeId )
+    {
+        return edgeId >= mainEdges;
+    }
+
+    public boolean isVirtualNode( int nodeId )
+    {
+        return nodeId >= mainNodes;
+    }
+
     class QueryGraphTurnExt extends TurnCostExtension
     {
         private final TurnCostExtension mainTurnExtension;
@@ -307,7 +343,7 @@ private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D cur
         basePoints.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
         PointList baseReversePoints = basePoints.clone(true);
-        double baseDistance = basePoints.calcDistance(distCalc);
+        double baseDistance = basePoints.calcDistance(Helper.DIST_PLANE);
         int virtEdgeId = mainEdges + virtualEdges.size();
 
         // edges between base and snapped point
@@ -332,18 +368,14 @@ public NodeAccess getNodeAccess()
         return nodeAccess;
     }
 
-    private boolean isVirtualNode( int node )
-    {
-        return node >= mainNodes;
-    }
-
-    private boolean isVirtualEdge( int edgeId )
-    {
-        return edgeId >= mainEdges;
-    }
-
     private final NodeAccess nodeAccess = new NodeAccess()
     {
+        @Override
+        public void ensureNode( int nodeId )
+        {
+            mainNodeAccess.ensureNode(nodeId);
+        }
+
         @Override
         public boolean is3D()
         {
@@ -490,7 +522,7 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
             //
             // base node
             int towerNode = baseRevEdge.getAdjNode();
-            if (towerNode < mainNodes)
+            if (!isVirtualNode(towerNode))
             {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, true, towerNode, i);
@@ -498,7 +530,7 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
 
             // adj node
             towerNode = adjEdge.getAdjNode();
-            if (towerNode < mainNodes)
+            if (!isVirtualNode(towerNode))
             {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, false, towerNode, i);
@@ -554,7 +586,7 @@ private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, E
     void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
     {
         if (isVirtualNode(towerNode))
-            throw new IllegalStateException("should not happen:" + towerNode + ", " + node2Edge);
+            throw new IllegalStateException("Node should not be virtual:" + towerNode + ", " + node2Edge);
 
         VirtualEdgeIterator vIter = node2Edge.get(towerNode);
         TIntArrayList ignoreEdges = new TIntArrayList(vIter.count() * 2);
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index 54807733e7..fe8163b088 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -30,17 +30,20 @@
  */
 public class Path4CH extends PathBidirRef
 {
-    public Path4CH( Graph g, FlagEncoder encoder )
+    private final Graph routingGraph;
+
+    public Path4CH( Graph routingGraph, Graph baseGraph, FlagEncoder encoder )
     {
-        super(g, encoder);
+        super(baseGraph, encoder);
+        this.routingGraph = routingGraph;
     }
 
     @Override
-    protected void processEdge( int tmpEdge, int endNode )
+    protected final void processEdge( int tmpEdge, int endNode )
     {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((EdgeSkipIterState) graph.getEdgeProps(tmpEdge, endNode), false);
+        expandEdge((EdgeSkipIterState) routingGraph.getEdgeProps(tmpEdge, endNode), false);
     }
 
     private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
@@ -58,6 +61,8 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         int skippedEdge1 = mainEdgeState.getSkippedEdge1();
         int skippedEdge2 = mainEdgeState.getSkippedEdge2();
         int from = mainEdgeState.getBaseNode(), to = mainEdgeState.getAdjNode();
+
+        // get properties like speed of the edge in the correct direction
         if (reverse)
         {
             int tmp = from;
@@ -68,32 +73,32 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
         if (reverseOrder)
         {
-            EdgeSkipIterState edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+            EdgeSkipIterState edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             boolean empty = edgeState == null;
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(edgeState, false);
 
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             else
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(edgeState, true);
         } else
         {
-            EdgeSkipIterState iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+            EdgeSkipIterState iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             boolean empty = iter == null;
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(iter, true);
 
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             else
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(iter, false);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index fd3006faf1..9fa3bf8ed4 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -37,13 +37,13 @@ public PreparationWeighting( Weighting userWeighting )
     }
 
     @Override
-    public double getMinWeight( double distance )
+    public final double getMinWeight( double distance )
     {
         return userWeighting.getMinWeight(distance);
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
         if (edgeState instanceof EdgeSkipIterState)
         {
@@ -60,9 +60,4 @@ public String toString()
     {
         return "PREPARE+" + userWeighting.toString();
     }
-
-    Weighting getUserWeighting()
-    {
-        return userWeighting;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 8a093fb74d..d6732420f9 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -60,7 +60,10 @@
     private EdgeSkipExplorer vehicleAllExplorer;
     private EdgeSkipExplorer vehicleAllTmpExplorer;
     private EdgeSkipExplorer calcPrioAllExplorer;
+    private LevelEdgeFilter levelFilter;
+    private int maxLevel;
     private final LevelGraph prepareGraph;
+
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
     private int oldPriorities[];
@@ -68,7 +71,6 @@
     private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
     private IgnoreNodeFilter ignoreNodeFilter;
     private DijkstraOneToMany prepareAlgo;
-    private boolean removesHigher2LowerEdges = true;
     private long counter;
     private int newShortcuts;
     private long dijkstraCount;
@@ -182,18 +184,6 @@ public void setInitialCollectionSize( int initialCollectionSize )
         this.initialCollectionSize = initialCollectionSize;
     }
 
-    /**
-     * Disconnect is very important to improve query time and preparation if enabled. It will remove
-     * the edge going from the higher level node to the currently contracted one. But the original
-     * graph is no longer available, so it is only useful for bidirectional CH algorithms. Default
-     * is true.
-     */
-    public PrepareContractionHierarchies setRemoveHigher2LowerEdges( boolean removeHigher2LowerEdges )
-    {
-        this.removesHigher2LowerEdges = removeHigher2LowerEdges;
-        return this;
-    }
-
     @Override
     public void doWork()
     {
@@ -228,15 +218,15 @@ boolean prepareEdges()
         return c > 0;
     }
 
-    // TODO we can avoid node level if we store this into a temporary array and 
-    // disconnect all edges which goes from higher to lower level
-    // uninitialized nodes have a level of 0
-    // TODO we could avoid the second storage for skippedEdge as we could store that info into linkB or A if it is disconnected
     boolean prepareNodes()
     {
-        int len = prepareGraph.getNodes();
+        int nodes = prepareGraph.getNodes();
+        for (int node = 0; node < nodes; node++)
+        {
+            prepareGraph.setLevel(node, maxLevel);
+        }
 
-        for (int node = 0; node < len; node++)
+        for (int node = 0; node < nodes; node++)
         {
             int priority = oldPriorities[node] = calculatePriority(node);
             sortedNodes.insert(node, priority);
@@ -269,7 +259,7 @@ void contractNodes()
 
         // disable as preparation is slower and query time does not benefit
         long lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
-                ? 0l
+                ? 0L
                 : Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
 
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
@@ -285,7 +275,7 @@ void contractNodes()
             neighborUpdate = false;
 
         StopWatch neighborSW = new StopWatch();
-        LevelGraphStorage lg = ((LevelGraphStorage) prepareGraph);
+        LevelGraphStorage levelGraphCast = ((LevelGraphStorage) prepareGraph);
         while (!sortedNodes.isEmpty())
         {
             // periodically update priorities of ALL nodes            
@@ -293,10 +283,10 @@ void contractNodes()
             {
                 periodSW.start();
                 sortedNodes.clear();
-                int len = lg.getNodes();
+                int len = prepareGraph.getNodes();
                 for (int node = 0; node < len; node++)
                 {
-                    if (lg.getLevel(node) != 0)
+                    if (prepareGraph.getLevel(node) != maxLevel)
                         continue;
 
                     int priority = oldPriorities[node] = calculatePriority(node);
@@ -345,25 +335,18 @@ void contractNodes()
 
             // contract!            
             newShortcuts += addShortcuts(polledNode);
-            lg.setLevel(polledNode, level);
+            prepareGraph.setLevel(polledNode, level);
             level++;
 
             if (sortedNodes.getSize() < nodesToAvoidContract)
-            {
-                while (!sortedNodes.isEmpty())
-                {
-                    polledNode = sortedNodes.pollKey();
-                    lg.setLevel(polledNode, level);
-                }
+                // skipped nodes are already set to maxLevel
                 break;
-            }
 
             EdgeSkipIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next())
             {
                 int nn = iter.getAdjNode();
-                if (lg.getLevel(nn) != 0)
-                    // already contracted no update necessary
+                if (prepareGraph.getLevel(nn) != maxLevel)
                     continue;
 
                 if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage)
@@ -377,8 +360,7 @@ void contractNodes()
                     neighborSW.stop();
                 }
 
-                if (removesHigher2LowerEdges)
-                    lg.disconnect(vehicleAllTmpExplorer, iter);
+                levelGraphCast.disconnect(vehicleAllTmpExplorer, iter);
             }
         }
 
@@ -389,7 +371,6 @@ void contractNodes()
                 + ", new shortcuts: " + newShortcuts
                 + ", " + prepareWeighting
                 + ", " + prepareFlagEncoder
-                + ", removeHigher2LowerEdges:" + removesHigher2LowerEdges
                 + ", dijkstras:" + dijkstraCount
                 + ", t(dijk):" + (int) dijkstraSW.getSeconds()
                 + ", t(period):" + (int) periodSW.getSeconds()
@@ -486,8 +467,6 @@ public void foundShortcut( int u_fromNode, int w_toNode,
             // and also in the graph for u->w. If existing AND identical weight => update setProperties.
             // Hint: shortcuts are always one-way due to distinct level of every node but we don't
             // know yet the levels so we need to determine the correct direction or if both directions
-            // minor improvement: if (shortcuts.containsKey(sc) 
-            // then two shortcuts with the same nodes (u<->n.adjNode) exists => check current shortcut against both
             Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
             if (shortcuts.containsKey(sc))
                 return;
@@ -579,7 +558,7 @@ void findShortcuts( ShortcutHandler sch )
         {
             int u_fromNode = incomingEdges.getAdjNode();
             // accept only uncontracted nodes
-            if (prepareGraph.getLevel(u_fromNode) != 0)
+            if (prepareGraph.getLevel(u_fromNode) != maxLevel)
                 continue;
 
             double v_u_dist = incomingEdges.getDistance();
@@ -595,7 +574,7 @@ void findShortcuts( ShortcutHandler sch )
             {
                 int w_toNode = outgoingEdges.getAdjNode();
                 // add only uncontracted nodes
-                if (prepareGraph.getLevel(w_toNode) != 0 || u_fromNode == w_toNode)
+                if (prepareGraph.getLevel(w_toNode) != maxLevel || u_fromNode == w_toNode)
                     continue;
 
                 // Limit weight as ferries or forbidden edges can increase local search too much.
@@ -607,8 +586,9 @@ void findShortcuts( ShortcutHandler sch )
                             + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
                             + ", dist:" + outgoingEdges.getDistance() + ", speed:" + prepareFlagEncoder.getSpeed(outgoingEdges.getFlags()));
 
-                if (existingDirectWeight >= Double.MAX_VALUE)
+                if (Double.isInfinite(existingDirectWeight))
                     continue;
+
                 double existingDistSum = v_u_dist + outgoingEdges.getDistance();
                 prepareAlgo.setWeightLimit(existingDirectWeight);
                 prepareAlgo.setLimitVisitedNodes((int) meanDegree * 100)
@@ -710,14 +690,33 @@ PrepareContractionHierarchies initFromGraph()
     {
         vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
         vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
-        vehicleAllExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph);
+        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
+
+        // filter by vehicle and level number
+        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph)
+        {
+            @Override
+            public final boolean accept( EdgeIteratorState edgeState )
+            {
+                if (!super.accept(edgeState))
+                    return false;
+
+                return allFilter.accept(edgeState);
+            }
+        };
+
+        levelFilter = new LevelEdgeFilter(prepareGraph);
+        maxLevel = prepareGraph.getNodes() + 1;
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
+        vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
+
         // Use an alternative to PriorityQueue as it has some advantages: 
-        //   1. Gets automatically smaller if less entries are stored => less total RAM used (as Graph is increasing until the end)
+        //   1. Gets automatically smaller if less entries are stored => less total RAM used. 
+        //      Important because Graph is increasing until the end.
         //   2. is slightly faster
-        //   but we need additional priorities array to keep old value which is necessary for update method
+        //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
         oldPriorities = new int[prepareGraph.getNodes()];
         prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareFlagEncoder, prepareWeighting, traversalMode);
@@ -732,11 +731,13 @@ public int getShortcuts()
     static class IgnoreNodeFilter implements EdgeFilter
     {
         int avoidNode;
+        int maxLevel;
         LevelGraph graph;
 
-        public IgnoreNodeFilter( LevelGraph g )
+        public IgnoreNodeFilter( LevelGraph g, int maxLevel )
         {
             this.graph = g;
+            this.maxLevel = maxLevel;
         }
 
         public IgnoreNodeFilter setAvoidNode( int node )
@@ -748,9 +749,9 @@ public IgnoreNodeFilter setAvoidNode( int node )
         @Override
         public final boolean accept( EdgeIteratorState iter )
         {
-            // ignore if it is skipNode or a adjNode already contracted
+            // ignore if it is skipNode or adjNode is already contracted
             int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == 0;
+            return avoidNode != node && graph.getLevel(node) == maxLevel;
         }
     }
 
@@ -799,9 +800,10 @@ protected boolean finished()
                 }
 
                 @Override
+
                 protected Path createAndInitPath()
                 {
-                    bestPath = new Path4CH(graph, flagEncoder);
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
                     return bestPath;
                 }
 
@@ -812,6 +814,7 @@ public String getName()
                 }
 
                 @Override
+
                 public String toString()
                 {
                     return getName() + "|" + prepareWeighting;
@@ -846,7 +849,7 @@ public boolean finished()
                 @Override
                 protected Path createAndInitPath()
                 {
-                    bestPath = new Path4CH(graph, flagEncoder);
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
                     return bestPath;
                 }
 
@@ -867,9 +870,7 @@ public String toString()
             throw new UnsupportedOperationException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies");
         }
 
-        if (!removesHigher2LowerEdges)
-            algo.setEdgeFilter(new LevelEdgeFilter(prepareGraph));
-
+        algo.setEdgeFilter(levelFilter);
         return algo;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
index 8823be538b..a108e4826c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
@@ -29,12 +29,12 @@
     /**
      * @return true if the current edge should be processed and false otherwise.
      */
-    boolean accept( EdgeIteratorState edgeIterState );
+    boolean accept( EdgeIteratorState edgeState );
 
     static final EdgeFilter ALL_EDGES = new EdgeFilter()
     {
         @Override
-        public final boolean accept( EdgeIteratorState edgeIterState )
+        public final boolean accept( EdgeIteratorState edgeState )
         {
             return true;
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index e2c2d6c18e..fd51deba9c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -113,6 +113,9 @@ public int compare( FlagEncoder o1, FlagEncoder o2 )
         {
             registerEncoder((AbstractFlagEncoder) flagEncoder);
         }
+
+        if (edgeEncoders.isEmpty())
+            throw new IllegalStateException("No vehicles found");
     }
 
     public int getBytesForFlags()
@@ -272,11 +275,6 @@ public long handleWayTags( OSMWay way, long includeWay, long relationFlags )
         return flags;
     }
 
-    public int getVehicleCount()
-    {
-        return edgeEncoders.size();
-    }
-
     @Override
     public String toString()
     {
@@ -308,17 +306,6 @@ public String toDetailsString()
         return str.toString();
     }
 
-    public FlagEncoder getSingle()
-    {
-        if (getVehicleCount() > 1)
-            throw new IllegalStateException("Multiple encoders are active. cannot return one:" + toString());
-
-        if (getVehicleCount() == 0)
-            throw new IllegalStateException("No encoder is active!");
-
-        return edgeEncoders.get(0);
-    }
-
     public long flagsDefault( boolean forward, boolean backward )
     {
         long flags = 0;
@@ -415,6 +402,9 @@ public void applyWayTags( OSMWay way, EdgeIteratorState edge )
         }
     }
 
+    /**
+     * The returned list is never empty.
+     */
     public List<FlagEncoder> fetchEdgeEncoders()
     {
         List<FlagEncoder> list = new ArrayList<FlagEncoder>();
diff --git a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
index 0f5954ad1e..985a4477d5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.EdgeSkipIterator;
 
 /**
  * Only certain nodes are accepted and therefor the others are ignored.
@@ -28,21 +30,25 @@
 public class LevelEdgeFilter implements EdgeFilter
 {
     private final LevelGraph graph;
-    private final int nodes;
+    private final int maxNodes;
 
     public LevelEdgeFilter( LevelGraph g )
     {
         graph = g;
-        nodes = g.getNodes();
+        maxNodes = g.getNodes();
     }
 
     @Override
-    public boolean accept( EdgeIteratorState edgeIter )
+    public boolean accept( EdgeIteratorState edgeIterState )
     {
-        int base = edgeIter.getBaseNode();
-        int adj = edgeIter.getAdjNode();
-        // for now workaround for #288
-        if (base >= nodes || adj >= nodes)
+        int base = edgeIterState.getBaseNode();
+        int adj = edgeIterState.getAdjNode();
+        // always accept virtual edges, see #288
+        if (base >= maxNodes || adj >= maxNodes)
+            return true;
+
+        // minor performance improvement: shortcuts in wrong direction are disconnected, so no need to exclude them
+        if (((EdgeSkipIterState) edgeIterState).isShortcut())
             return true;
 
         return graph.getLevel(base) <= graph.getLevel(adj);
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index 3388a7b256..a02bf36a83 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -46,18 +46,16 @@
     private int minOneWayNetworkSize = 0;
     private int subNetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
-    private final EncodingManager encodingManager;
+    private FlagEncoder singleEncoder;
 
     public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
     {
         this.g = g;
-        if (em.getVehicleCount() == 0)
-            throw new IllegalStateException("No vehicles found");
-        else if (em.getVehicleCount() > 1)
+        List<FlagEncoder> encoders = em.fetchEdgeEncoders();
+        if (encoders.size() > 1)
             edgeFilter = EdgeFilter.ALL_EDGES;
         else
-            edgeFilter = new DefaultEdgeFilter(em.getSingle());
-        this.encodingManager = em;
+            edgeFilter = new DefaultEdgeFilter(singleEncoder = encoders.get(0));
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
@@ -78,9 +76,9 @@ public void doWork()
         Map<Integer, Integer> map = findSubnetworks();
         keepLargeNetworks(map);
 
-        int unvisitedDeadEnds = 0;
-        if ((this.minOneWayNetworkSize > 0) && (this.encodingManager.getVehicleCount() == 1))
-            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(this.encodingManager.getSingle());
+        int unvisitedDeadEnds = -1;
+        if ((this.minOneWayNetworkSize > 0) && singleEncoder != null)
+            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
 
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
                 + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
@@ -247,7 +245,6 @@ public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
         int removed = 0;
         for (TIntArrayList component : components)
         {
-
             if (component.size() < minOneWayNetworkSize)
             {
                 for (int i = 0; i < component.size(); i++)
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index ca06914204..66d437d1ac 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -48,7 +48,7 @@ public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryRe
             OneRun oneRun )
     {
         List<Path> viaPaths = new ArrayList<Path>();
-        QueryGraph queryGraph = new QueryGraph(algoEntry.originalGraph);
+        QueryGraph queryGraph = new QueryGraph(algoEntry.getQueryGraph());
         queryGraph.lookup(queryList);
         AlgorithmOptions opts = algoEntry.opts;
         FlagEncoder encoder = opts.getFlagEncoder();
@@ -148,17 +148,27 @@ void printSummary()
 
     public static class AlgoHelperEntry
     {
-        private Graph originalGraph;
+        private Graph queryGraph;
         private final LocationIndex idx;
         private AlgorithmOptions opts;
 
         public AlgoHelperEntry( Graph g, AlgorithmOptions opts, LocationIndex idx )
         {
-            this.originalGraph = g;
+            this.queryGraph = g;
             this.opts = opts;
             this.idx = idx;
         }
 
+        public Graph getQueryGraph()
+        {
+            return queryGraph;
+        }
+
+        public void setQueryGraph( Graph queryGraph )
+        {
+            this.queryGraph = queryGraph;
+        }
+
         public void setAlgorithmOptions( AlgorithmOptions opts )
         {
             this.opts = opts;
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
similarity index 60%
rename from core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
rename to core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 57d8dbc81b..21fbf67926 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -1,71 +1,91 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.storage.index;
+package com.graphhopper.storage;
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.util.*;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterator;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
 
 /**
- * The LevelGraph has some edges disconnected (to be more efficient), but this happens before the
- * index is created! So we need to take care of this and also ignore the introduced shortcuts e.g.
- * for calculating closest edges.
- * <p/>
- * TODO avoid some of the tricks if we move a disconnected edge to the end of the edge-list (instead
- * of just disconnecting them). And then while accessing them break iteration if we encounter the
- * first of those disconnected edges (this should have the same speed). Therefor we also need to
- * change the EdgeFilter interface and add a stop(EdgeIterator) method or similar.
- * <p/>
  * @author Peter Karich
  */
-public class LocationIndexTreeSC extends LocationIndexTree
+class BaseGraph implements Graph
 {
-    private final static EdgeFilter NO_SHORTCUT = new EdgeFilter()
-    {
-        @Override
-        public boolean accept( EdgeIteratorState edgeIterState )
-        {
-            return !((EdgeSkipIterator) edgeIterState).isShortcut();
-        }
-    };
     private final LevelGraph lg;
 
-    public LocationIndexTreeSC( LevelGraph g, Directory dir )
+    BaseGraph( LevelGraph lg )
+    {
+        this.lg = lg;
+    }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return this;
+    }
+
+    @Override
+    public int getNodes()
+    {
+        return lg.getNodes();
+    }
+
+    @Override
+    public NodeAccess getNodeAccess()
+    {
+        return lg.getNodeAccess();
+    }
+
+    @Override
+    public BBox getBounds()
+    {
+        return lg.getBounds();
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b )
+    {
+        return lg.edge(a, b);
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
     {
-        super(g, dir);
-        lg = g;
+        return lg.edge(a, b, distance, bothDirections);
     }
 
     @Override
-    protected int pickBestNode( int nodeA, int nodeB )
+    public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
     {
-        // return lower level nodes as those nodes are always connected to higher ones
-        // (high level nodes are potentially disconnected from lower ones in order to improve performance on Android)
-        if (lg.getLevel(nodeA) < lg.getLevel(nodeB))
-            return nodeA;
-        return nodeB;
+        if (lg.isShortcut(edgeId))
+            throw new IllegalStateException("Do not fetch shortcuts from BaseGraph use the LevelGraph instead");
+
+        return lg.getEdgeProps(edgeId, adjNode);
     }
 
     @Override
-    protected AllEdgesIterator getAllEdges()
+    public AllEdgesIterator getAllEdges()
     {
         final AllEdgesSkipIterator tmpIter = lg.getAllEdges();
         return new AllEdgesIterator()
@@ -182,8 +202,48 @@ public EdgeIteratorState detach( boolean reverse )
     }
 
     @Override
-    protected EdgeFilter getEdgeFilter()
+    public EdgeExplorer createEdgeExplorer( final EdgeFilter filter )
+    {
+        if (filter == EdgeFilter.ALL_EDGES)
+            return createEdgeExplorer();
+
+        return lg.createEdgeExplorer(new EdgeFilter()
+        {
+            @Override
+            public boolean accept( EdgeIteratorState edgeIterState )
+            {
+                if (((EdgeSkipIterator) edgeIterState).isShortcut())
+                    return false;
+
+                return filter.accept(edgeIterState);
+            }
+        });
+    }
+
+    private final static EdgeFilter NO_SHORTCUTS = new EdgeFilter()
+    {
+        @Override
+        public boolean accept( EdgeIteratorState edgeIterState )
+        {
+            return !((EdgeSkipIterator) edgeIterState).isShortcut();
+        }
+    };
+
+    @Override
+    public EdgeExplorer createEdgeExplorer()
+    {
+        return lg.createEdgeExplorer(NO_SHORTCUTS);
+    }
+
+    @Override
+    public Graph copyTo( Graph g )
+    {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    @Override
+    public GraphExtension getExtension()
     {
-        return NO_SHORTCUT;
+        return lg.getExtension();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index 1b2f2bfcb3..b075f3864f 100644
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -36,6 +36,12 @@ public GHNodeAccess( GraphHopperStorage that, boolean withElevation )
         this.elevation = withElevation;
     }
 
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        that.ensureNodeIndex(nodeId);
+    }
+
     @Override
     public final void setNode( int nodeId, double lat, double lon )
     {
@@ -43,10 +49,10 @@ public final void setNode( int nodeId, double lat, double lon )
     }
 
     @Override
-    public final void setNode( int index, double lat, double lon, double ele )
+    public final void setNode( int nodeId, double lat, double lon, double ele )
     {
-        that.ensureNodeIndex(index);
-        long tmp = (long) index * that.nodeEntryBytes;
+        that.ensureNodeIndex(nodeId);
+        long tmp = (long) nodeId * that.nodeEntryBytes;
         that.nodes.setInt(tmp + that.N_LAT, Helper.degreeToInt(lat));
         that.nodes.setInt(tmp + that.N_LON, Helper.degreeToInt(lon));
 
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index c259176a2a..65e9c63b26 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -31,6 +31,12 @@
  */
 public interface Graph
 {
+    /**
+     * @return a graph which behaves like an unprepared graph and e.g. the normal unidirectional
+     * Dijkstra or any graph traversal algorithm can be executed.
+     */
+    Graph getBaseGraph();
+
     /**
      * @return the number of created locations - via setNode() or edge()
      */
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 4ee6ea171d..de2e8b4a51 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -125,6 +125,12 @@ public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boole
         extendedStorage.init(this);
     }
 
+    @Override
+    public Graph getBaseGraph()
+    {
+        return this;
+    }
+
     void checkInit()
     {
         if (initialized)
@@ -799,13 +805,13 @@ public final boolean next()
                 adjNode = getOtherNode(baseNode, edgePointer);
                 reverse = baseNode > adjNode;
 
-                // position to next edge
+                // position to next edge                
                 nextEdge = edges.getInt(getLinkPosInEdgeArea(baseNode, adjNode, edgePointer));
                 if (nextEdge == edgeId)
                     throw new AssertionError("endless loop detected for " + baseNode + ", " + adjNode
                             + ", " + edgePointer + ", " + edgeId);
 
-                foundNext = filter == null || filter.accept(this);
+                foundNext = filter.accept(this);
                 if (foundNext)
                     break;
             }
@@ -903,7 +909,7 @@ public EdgeIteratorState detach( boolean reverseArg )
             if (edgeId == nextEdge)
                 throw new IllegalStateException("call next before detaching");
 
-            EdgeIterable iter = iter = new EdgeIterable(filter);
+            EdgeIterable iter = new EdgeIterable(filter);
             iter.setBaseNode(baseNode);
             iter.setEdgeId(edgeId);
             iter.next();
@@ -1573,7 +1579,7 @@ public boolean isClosed()
     }
 
     @Override
-    public GraphExtension getExtension()
+    public GraphExtension getExtension()    
     {
         return extStorage;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraph.java b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
index 8bca2098a9..d7917c32ef 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
@@ -23,16 +23,29 @@
 import com.graphhopper.util.EdgeSkipIterState;
 
 /**
- * Extended graph interface which supports storing and retrieving the level for a node.
+ * Extended graph interface which supports storing and retrieving the level for a node and creating
+ * shortcuts, which are additional 'artificial' edges to speedup traversal in certain cases.
  * <p/>
  * @author Peter Karich
  */
 public interface LevelGraph extends Graph
 {
-    void setLevel( int index, int level );
-
-    int getLevel( int index );
-
+    /**
+     * This methods sets the level of the specified node.
+     */
+    void setLevel( int nodeId, int level );
+
+    /**
+     * @return the level of the specified node.
+     */
+    int getLevel( int nodeId );
+
+    boolean isShortcut( int edgeId );
+
+    /**
+     * This method creates a shortcut between a to b which is nearly identical to creating an edge
+     * except that it can be excluded or included for certain traversals or algorithms.
+     */
     EdgeSkipIterState shortcut( int a, int b );
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index 1b666abd0c..d16a114944 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -42,10 +42,18 @@
     // after the last edge only shortcuts are stored
     private int lastEdgeIndex = -1;
     private final long scDirMask = PrepareEncoder.getScDirMask();
+    private final Graph baseGraph;
 
     public LevelGraphStorage( Directory dir, EncodingManager encodingManager, boolean enabled3D )
     {
         super(dir, encodingManager, enabled3D);
+        baseGraph = new BaseGraph(this);
+    }
+
+    @Override
+    public boolean isShortcut( int edgeId )
+    {
+        return edgeId > lastEdgeIndex;
     }
 
     @Override
@@ -59,17 +67,22 @@ protected void initStorage()
     }
 
     @Override
-    public final void setLevel( int index, int level )
+    public final void setLevel( int nodeIndex, int level )
     {
-        ensureNodeIndex(index);
-        nodes.setInt((long) index * nodeEntryBytes + I_LEVEL, level);
+        if (nodeIndex >= getNodes())
+            return;
+
+        nodes.setInt((long) nodeIndex * nodeEntryBytes + I_LEVEL, level);
     }
 
     @Override
-    public final int getLevel( int index )
+    public final int getLevel( int nodeIndex )
     {
-        ensureNodeIndex(index);
-        return nodes.getInt((long) index * nodeEntryBytes + I_LEVEL);
+        // automatically allocate new nodes only via creating edges or setting node properties
+        if (nodeIndex >= getNodes())
+            throw new IllegalStateException("node " + nodeIndex + " is invalid. Not in [0," + getNodes() + ")");
+
+        return nodes.getInt((long) nodeIndex * nodeEntryBytes + I_LEVEL);
     }
 
     @Override
@@ -267,25 +280,20 @@ long reverseFlags( long edgePointer, long flags )
      */
     public void disconnect( EdgeSkipExplorer explorer, EdgeIteratorState edgeState )
     {
-        // search edge with opposite direction        
+        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
         // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
         EdgeSkipIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
         int tmpPrevEdge = EdgeIterator.NO_EDGE;
-        boolean found = false;
         while (tmpIter.next())
         {
-            // If we disconnect shortcuts only we could run normal algos on the graph too
-            // BUT CH queries will be 10-20% slower and preparation will be 10% slower
-            if (/*tmpIter.isShortcut() &&*/tmpIter.getEdge() == edgeState.getEdge())
+            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
             {
-                found = true;
+                internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
                 break;
             }
 
             tmpPrevEdge = tmpIter.getEdge();
         }
-        if (found)
-            internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
     }
 
     @Override
@@ -431,4 +439,10 @@ protected int setEdgesHeader()
         edges.setHeader(next * 4, lastEdgeIndex);
         return next + 1;
     }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return baseGraph;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 27116a1892..49a7786419 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -20,11 +20,11 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.geohash.SpatialKeyAlgo;
-import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -74,8 +74,15 @@
      */
     private double equalNormedDelta;
 
+    /**
+     * @param g the graph for which this index should do the lookup based on latitude,longitude.
+     * @param dir
+     */
     public LocationIndexTree( Graph g, Directory dir )
     {
+        if (g instanceof LevelGraph)
+            throw new IllegalArgumentException("Call LevelGraph.getBaseGraph() instead of using the LevelGraph itself");
+
         MAGIC_INT = Integer.MAX_VALUE / 22316;
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
@@ -374,7 +381,7 @@ public InMemConstructionIndex( int noOfSubEntries )
 
         void prepare()
         {
-            final EdgeIterator allIter = getAllEdges();
+            final EdgeIterator allIter = graph.getAllEdges();
             try
             {
                 while (allIter.next())
@@ -418,7 +425,7 @@ public void set( double lat, double lon )
                     long key = keyAlgo.encode(lat, lon);
                     long keyPart = createReverseKey(key);
                     // no need to feed both nodes as we search neighbors in fillIDs
-                    addNode(root, pickBestNode(nodeA, nodeB), 0, keyPart, key);
+                    addNode(root, nodeA, 0, keyPart, key);
                 }
             };
             BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
@@ -787,7 +794,7 @@ public QueryResult findClosest( final double queryLat, final double queryLon, fi
         // clone storedIds to avoid interference with forEach
         final GHBitSet checkBitset = new GHTBitSet(new TIntHashSet(storedNetworkEntryIds));
         // find nodes from the network entries which are close to 'point'
-        final EdgeExplorer explorer = graph.createEdgeExplorer(getEdgeFilter());
+        final EdgeExplorer explorer = graph.createEdgeExplorer();
         storedNetworkEntryIds.forEach(new TIntProcedure()
         {
             @Override
@@ -938,23 +945,6 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
         protected abstract boolean check( int node, double normedDist, int wayIndex, EdgeIteratorState iter, QueryResult.Position pos );
     }
 
-    protected int pickBestNode( int nodeA, int nodeB )
-    {
-        // For normal graph the node does not matter because if nodeA is conntected to nodeB
-        // then nodeB is also connect to nodeA, but for a LevelGraph this does not apply.
-        return nodeA;
-    }
-
-    protected EdgeFilter getEdgeFilter()
-    {
-        return EdgeFilter.ALL_EDGES;
-    }
-
-    protected AllEdgesIterator getAllEdges()
-    {
-        return graph.getAllEdges();
-    }
-
     // make entries static as otherwise we get an additional reference to this class (memory waste)
     static interface InMemEntry
     {
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 24cb8cd371..590c89b2fa 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -63,25 +63,33 @@ public MiniPerfTest setIterations( int counts )
         return this;
     }
 
-    // in ms
+    /**
+     * @return minimum time of every call, in ms
+     */
     public double getMin()
     {
         return min / 1e6;
     }
 
-    // in ms
+    /**
+     * @return maximum time of every calls, in ms
+     */
     public double getMax()
     {
         return max / 1e6;
     }
 
-    // in ms
+    /**
+     * @return time for all calls accumulated, in ms
+     */
     public double getSum()
     {
         return fullTime / 1e6;
     }
 
-    // in ms
+    /**
+     * @return mean time per call, in ms
+     */
     public double getMean()
     {
         return getSum() / counts;
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/core/src/main/java/com/graphhopper/util/PointAccess.java
index e8a395192d..5d3068a599 100644
--- a/core/src/main/java/com/graphhopper/util/PointAccess.java
+++ b/core/src/main/java/com/graphhopper/util/PointAccess.java
@@ -23,7 +23,6 @@
  */
 public interface PointAccess
 {
-
     /**
      * @return true if elevation data is stored and can be retrieved
      */
@@ -34,6 +33,12 @@
      */
     int getDimension();
 
+    /**
+     * This method ensures that the node with the specified index exists i.e. allocates space for
+     * it.
+     */
+    void ensureNode( int nodeId );
+
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index 1d25102e5b..cb29f7fb96 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -67,6 +67,12 @@ public int getDimension()
         return 2;
     }
 
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        incCap(nodeId + 1);
+    }
+
     @Override
     public void setNode( int nodeId, double lat, double lon )
     {
@@ -94,7 +100,7 @@ else if (!Double.isNaN(ele))
 
     private void incCap( int newSize )
     {
-        if (newSize < latitudes.length)
+        if (newSize <= latitudes.length)
             return;
 
         int cap = newSize * 2;
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index d3ee1547cc..a2925d3f93 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -74,8 +74,9 @@ public void testLoadOSM()
         assertEquals(3, rsp.getPoints().getSize());
 
         closableInstance.close();
-        closableInstance = new GraphHopper().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("CAR"));
+        
+        // no encoding manager necessary
+        closableInstance = new GraphHopper().setStoreOnFlush(true);
         assertTrue(closableInstance.load(ghLoc));
         rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
         assertFalse(rsp.hasErrors());
@@ -230,7 +231,7 @@ public void testPrepare()
         GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
                 setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
         assertFalse(rsp.hasErrors());
-        assertEquals("(51.24921503475044,9.431716451757769), (52.0,9.0), (51.199999850988384,9.39999970197677)", rsp.getPoints().toString());
+        assertEquals(Helper.createPointList(51.249215, 9.431716, 52.0, 9.0, 51.2, 9.4), rsp.getPoints());
         assertEquals(3, rsp.getPoints().getSize());
     }
 
@@ -499,7 +500,7 @@ public void testVia()
                 init(new CmdArgs().
                         put("osmreader.osm", testOsm3).
                         put("prepare.minNetworkSize", "1").
-                        put("graph.acceptWay", "CAR")).
+                        put("graph.flagEncoders", "CAR")).
                 setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
 
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index d1df1a0b63..5b09bd3268 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -21,12 +21,12 @@
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import java.util.Random;
 import static org.junit.Assert.*;
+import org.junit.Before;
 import org.junit.Test;
 
 /**
@@ -38,9 +38,18 @@
     // problem is: matrix graph is expensive to create to cache it in a static variable
     private static Graph matrixGraph;
     protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
-    protected FlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-    protected FlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
-    protected AlgorithmOptions defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new ShortestWeighting()).build();
+    protected FlagEncoder carEncoder;
+    protected FlagEncoder footEncoder;
+    protected AlgorithmOptions defaultOpts;
+
+    @Before
+    public void setUp()
+    {
+        carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
+        footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+        defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new ShortestWeighting()).build();
+    }
 
     protected Graph createGraph( EncodingManager em, boolean is3D )
     {
@@ -91,15 +100,14 @@ public void testCalcShortestPathWithLimit()
     public void testCalcFastestPath()
     {
         Graph graphShortest = createGraph(false);
-        initDirectedAndDiffSpeed(graphShortest);
-        Path p1 = createAlgo(graphShortest, defaultOpts).
-                calcPath(0, 3);
+        initDirectedAndDiffSpeed(graphShortest, carEncoder);
+        Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
         assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 144823, p1.getMillis());
 
         Graph graphFastest = createGraph(false);
-        initDirectedAndDiffSpeed(graphFastest);
+        initDirectedAndDiffSpeed(graphFastest, carEncoder);
         Path p2 = createAlgo(graphFastest,
                 AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
                 calcPath(0, 3);
@@ -113,28 +121,28 @@ public void testCalcFastestPath()
     // 4-5-- |
     // |/ \--7
     // 6----/
-    void initDirectedAndDiffSpeed( Graph graph )
+    protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
     {
-        graph.edge(0, 1).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(0, 4).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
+        graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(1, 4).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setFlags(carEncoder.setProperties(10, true, true));
-        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(carEncoder.setProperties(10, true, true));
+        graph.edge(1, 4).setFlags(enc.setProperties(10, true, true));
+        graph.edge(1, 5).setFlags(enc.setProperties(10, true, true));
+        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(enc.setProperties(10, true, true));
 
-        graph.edge(5, 2).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(2, 3).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(5, 2).setFlags(enc.setProperties(10, true, false));
+        graph.edge(2, 3).setFlags(enc.setProperties(10, true, false));
 
-        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(3, 7).setFlags(carEncoder.setProperties(10, true, false));
+        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(enc.setProperties(20, true, false));
+        graph.edge(3, 7).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(4, 6).setFlags(carEncoder.setProperties(100, true, false));
-        graph.edge(5, 4).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(4, 6).setFlags(enc.setProperties(100, true, false));
+        graph.edge(5, 4).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(5, 6).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(7, 5).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(5, 6).setFlags(enc.setProperties(10, true, false));
+        graph.edge(7, 5).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(6, 7).setFlags(carEncoder.setProperties(100, true, true));
+        graph.edge(6, 7).setFlags(enc.setProperties(100, true, true));
 
         updateDistancesFor(graph, 0, 0.002, 0);
         updateDistancesFor(graph, 1, 0.002, 0.001);
@@ -154,14 +162,15 @@ public void testCalcFootPath()
     {
         Graph graphShortest = createGraph(false);
         initFootVsCar(graphShortest);
-        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).weighting(new ShortestWeighting()).build()).
+        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new ShortestWeighting()).build()).
                 calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 12240 * 1000, p1.getMillis());
         assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
     }
 
-    void initFootVsCar( Graph graph )
+    protected void initFootVsCar( Graph graph )
     {
         graph.edge(0, 1).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
         graph.edge(0, 4).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
@@ -591,7 +600,7 @@ public void testViaEdges_SpecialCases()
     public void testQueryGraphAndFastest()
     {
         Graph graph = createGraph(false);
-        initDirectedAndDiffSpeed(graph);
+        initDirectedAndDiffSpeed(graph, carEncoder);
         Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
         assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
         assertEquals(602.98, p.getDistance(), 1e-1);
@@ -605,12 +614,7 @@ Path calcPathViaQuery( Graph graph, double fromLat, double fromLon, double toLat
 
     Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fromLon, double toLat, double toLon )
     {
-        LocationIndex index;
-        if (graph instanceof LevelGraph)
-            index = new LocationIndexTreeSC((LevelGraph) graph, new RAMDirectory());
-        else
-            index = new LocationIndexTree(graph, new RAMDirectory());
-
+        LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory());
         index.prepareIndex();
         QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
         QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
diff --git a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java b/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
index 61e00f2f72..22b886c9a8 100644
--- a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
@@ -28,46 +28,59 @@
 import java.io.File;
 import java.util.List;
 import java.util.Map;
-import org.junit.After;
-import org.junit.Test;
+import org.junit.*;
 import static org.junit.Assert.*;
-import org.junit.Before;
 
 /**
  * @author Peter Karich
  */
 public class GraphHopperIT
 {
-    String graphFile = "target/graph-GraphHopperIT";
-    String osmFile = "files/monaco.osm.gz";
-    String vehicle = "FOOT";
-    String importVehicles = "FOOT";
-    String weightCalcStr = "shortest";
+    private static GraphHopper hopper;
+    private static final String graphFileFoot = "target/graphhopperIT-foot";
+    private static final String osmFile = "files/monaco.osm.gz";
+    private static final String importVehicles = "FOOT";
+    private static final String vehicle = "FOOT";
+    private static final String weightCalcStr = "shortest";
+
+    private final String tmpGraphFile = "target/graphhopperIT-tmp";
 
     @Before
     public void setUp()
     {
-        // make sure we are using fresh graphhopper files with correct vehicle
-        Helper.removeDir(new File(graphFile));
+        Helper.removeDir(new File(tmpGraphFile));
     }
 
     @After
     public void tearDown()
     {
-        Helper.removeDir(new File(graphFile));
+        Helper.removeDir(new File(tmpGraphFile));
     }
 
-    @Test
-    public void testMonacoWithInstructions() throws Exception
+    @BeforeClass
+    public static void beforeClass()
     {
-        GraphHopper hopper = new GraphHopper().
+        // make sure we are using fresh graphhopper files with correct vehicle
+        Helper.removeDir(new File(graphFileFoot));
+
+        hopper = new GraphHopper().
                 setStoreOnFlush(true).
                 setOSMFile(osmFile).
                 setCHEnable(false).
-                setGraphHopperLocation(graphFile).
+                setGraphHopperLocation(graphFileFoot).
                 setEncodingManager(new EncodingManager(importVehicles)).
                 importOrLoad();
+    }
+
+    @AfterClass
+    public static void afterClass()
+    {
+        Helper.removeDir(new File(graphFileFoot));
+    }
 
+    @Test
+    public void testMonacoWithInstructions() throws Exception
+    {
         GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
                 setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
@@ -106,20 +119,89 @@ public void testMonacoWithInstructions() throws Exception
         assertEquals(totalResponseMillis, lastEntryMillis);
     }
 
+    @Test
+    public void testMonacoVia()
+    {
+        GHResponse rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.74958, 7.436566)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+
+        assertEquals(6875.1, rsp.getDistance(), .1);
+        assertEquals(179, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(26, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
+        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
+        assertEquals("Turn left", resultJson.get(3).get("text"));
+        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+
+        assertEquals("Stopover 1", resultJson.get(12).get("text"));
+
+        assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
+        assertEquals("Turn left", resultJson.get(21).get("text"));
+        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
+        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
+        assertEquals("Turn slight right onto Avenue des Guelfes", resultJson.get(24).get("text"));
+        assertEquals("Finish!", resultJson.get(25).get("text"));
+
+        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
+        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
+        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
+        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
+        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
+        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+
+        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
+        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
+        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
+        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
+        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
+        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+
+        // special case of identical start and end point
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(1, rsp.getPoints().getSize());
+        assertEquals(1, rsp.getInstructions().size());
+        assertEquals("Finish!", rsp.getInstructions().createJson().get(0).get("text"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(0).get("sign"));
+
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(2, rsp.getPoints().getSize());
+        assertEquals(2, rsp.getInstructions().size());
+        assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().createJson().get(0).get("sign"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
+    }
+
     @Test
     public void testSRTMWithInstructions() throws Exception
     {
-        GraphHopper hopper = new GraphHopper().
+        GraphHopper tmpHopper = new GraphHopper().
                 setStoreOnFlush(true).
                 setOSMFile(osmFile).
                 setCHEnable(false).
-                setGraphHopperLocation(graphFile).
+                setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager(importVehicles));
 
-        hopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
-        hopper.importOrLoad();
+        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
+        tmpHopper.importOrLoad();
 
-        GHResponse rsp = hopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
                 setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         assertEquals(1626.8, rsp.getDistance(), .1);
@@ -160,134 +242,101 @@ public void testSRTMWithInstructions() throws Exception
     public void testKremsCyclewayInstructionsWithWayTypeInfo()
     {
         String tmpOsmFile = "files/krems.osm.gz";
-        String tmpGraphFile = "target/graph-krems";
         String tmpVehicle = "BIKE";
         String tmpImportVehicles = "CAR,BIKE";
         String tmpWeightCalcStr = "fastest";
 
-        try
-        {
-            // make sure we are using fresh graphhopper files with correct vehicle
-            Helper.removeDir(new File(tmpGraphFile));
-            GraphHopper hopper = new GraphHopper().
-                    setStoreOnFlush(true).
-                    setOSMFile(tmpOsmFile).
-                    setCHEnable(false).
-                    setGraphHopperLocation(tmpGraphFile).
-                    setEncodingManager(new EncodingManager(tmpImportVehicles)).
-                    importOrLoad();
-
-            GHResponse rsp = hopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
-                    setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
-
-            assertEquals(6932.24, rsp.getDistance(), .1);
-            assertEquals(110, rsp.getPoints().getSize());
-
-            InstructionList il = rsp.getInstructions();
-            assertEquals(19, il.size());
-            List<Map<String, Object>> resultJson = il.createJson();
-
-            assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
-            assertEquals("get off the bike", resultJson.get(0).get("annotationText"));
-            assertEquals("Turn sharp left onto Kirchengasse", resultJson.get(1).get("text"));
-            assertEquals("get off the bike", resultJson.get(1).get("annotationText"));
-
-            assertEquals("Turn sharp right onto Pfarrplatz", resultJson.get(2).get("text"));
-            assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
-            assertEquals("Turn left onto Hoher Markt", resultJson.get(4).get("text"));
-            assertEquals("Turn slight right onto Wegscheid", resultJson.get(5).get("text"));
-            assertEquals("Turn slight left onto Untere Landstraße", resultJson.get(6).get("text"));
-            assertEquals("Turn right onto Ringstraße, L73", resultJson.get(7).get("text"));
-            assertEquals("Continue onto Eyblparkstraße", resultJson.get(8).get("text"));
-            assertEquals("Continue onto Austraße", resultJson.get(9).get("text"));
-            assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
-            //..
-            assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
-            assertEquals("cycleway", resultJson.get(15).get("annotationText"));
-
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("cannot handle osm file " + tmpOsmFile, ex);
-        } finally
-        {
-            Helper.removeDir(new File(tmpGraphFile));
-        }
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+
+        assertEquals(6932.24, rsp.getDistance(), .1);
+        assertEquals(110, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(19, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+
+        assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
+        assertEquals("get off the bike", resultJson.get(0).get("annotationText"));
+        assertEquals("Turn sharp left onto Kirchengasse", resultJson.get(1).get("text"));
+        assertEquals("get off the bike", resultJson.get(1).get("annotationText"));
+
+        assertEquals("Turn sharp right onto Pfarrplatz", resultJson.get(2).get("text"));
+        assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
+        assertEquals("Turn left onto Hoher Markt", resultJson.get(4).get("text"));
+        assertEquals("Turn slight right onto Wegscheid", resultJson.get(5).get("text"));
+        assertEquals("Turn slight left onto Untere Landstraße", resultJson.get(6).get("text"));
+        assertEquals("Turn right onto Ringstraße, L73", resultJson.get(7).get("text"));
+        assertEquals("Continue onto Eyblparkstraße", resultJson.get(8).get("text"));
+        assertEquals("Continue onto Austraße", resultJson.get(9).get("text"));
+        assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
+        //..
+        assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
+        assertEquals("cycleway", resultJson.get(15).get("annotationText"));
     }
 
     @Test
-    public void testMonacoVia()
+    public void testRoundaboutInstructionsWithCH()
     {
-        GraphHopper hopper = new GraphHopper().
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpVehicle = "car";
+        String tmpImportVehicles = "foot,car";
+        String tmpWeightCalcStr = "fastest";
+
+        GraphHopper tmpHopper = new GraphHopper().
                 setStoreOnFlush(true).
-                setOSMFile(osmFile).
-                setCHEnable(false).
-                setGraphHopperLocation(graphFile).
-                setEncodingManager(new EncodingManager(importVehicles)).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
                 importOrLoad();
 
-        GHResponse rsp = hopper.route(new GHRequest().
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.74958, 7.436566)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        // lexicographically first vehicle
+        assertEquals(tmpVehicle, tmpHopper.getDefaultVehicle());
+        assertFalse(RoutingAlgorithmFactorySimple.class.isAssignableFrom(tmpHopper.getAlgorithmFactory().getClass()));
 
-        assertEquals(6875.1, rsp.getDistance(), .1);
-        assertEquals(179, rsp.getPoints().getSize());
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.745084, 7.430513, 43.745247, 7.430347)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
 
-        InstructionList il = rsp.getInstructions();
-        assertEquals(26, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
-        assertEquals("Turn left", resultJson.get(3).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+        rsp = tmpHopper.route(new GHRequest(43.745968, 7.42907, 43.745832, 7.428614)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
 
-        assertEquals("Stopover 1", resultJson.get(12).get("text"));
+        rsp = tmpHopper.route(new GHRequest(43.745948, 7.42914, 43.746173, 7.428834)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
 
-        assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
-        assertEquals("Turn left", resultJson.get(21).get("text"));
-        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
-        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
-        assertEquals("Turn slight right onto Avenue des Guelfes", resultJson.get(24).get("text"));
-        assertEquals("Finish!", resultJson.get(25).get("text"));
+        assertEquals(1, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+    }
 
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+    @Test
+    public void testMultipleVehiclesAndCH()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpImportVehicles = "foot,car";
 
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
 
-        // special case of identical start and end point
-        rsp = hopper.route(new GHRequest().
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
-        assertEquals(0, rsp.getDistance(), .1);
-        assertEquals(0, rsp.getRouteWeight(), .1);
-        assertEquals(1, rsp.getPoints().getSize());
-        assertEquals(1, rsp.getInstructions().size());
-        assertEquals("Finish!", rsp.getInstructions().createJson().get(0).get("text"));
-        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(0).get("sign"));
-        
-        rsp = hopper.route(new GHRequest().
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
-        assertEquals(0, rsp.getDistance(), .1);
-        assertEquals(0, rsp.getRouteWeight(), .1);
-        assertEquals(2, rsp.getPoints().getSize());
-        assertEquals(2, rsp.getInstructions().size());
-        assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().createJson().get(0).get("sign"));
-        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("car"));
+        assertEquals(207, rsp.getMillis() / 1000f, 1);
+        assertEquals(2838, rsp.getDistance(), 1);        
+
+        rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("foot"));
+        assertEquals(1574, rsp.getMillis() / 1000f, 1);
+        assertEquals(2187, rsp.getDistance(), 1);        
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index ecf8faec01..a74897fb02 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -273,7 +273,7 @@ public void testCalcInstructionsRoundabout()
     {
         RoundaboutGraph rg = new RoundaboutGraph(false);
         rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
-        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         // Test instructions
         List<String> tmpList = pick("text", wayList.createJson());
@@ -287,7 +287,7 @@ public void testCalcInstructionsRoundabout()
         assertEquals(delta, instr.getRadian(), 0.01);
 
         // case of continuing a street through a roundabout
-        p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+        p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
         wayList = p.calcInstructions(tr);
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto MainStreet",
@@ -308,7 +308,7 @@ public void testCalcInstructionsRoundabout2()
     {
         RoundaboutGraph rg = new RoundaboutGraph(false);
         rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
-        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
@@ -324,7 +324,7 @@ public void testCalcInstructionsRoundaboutBegin()
     {
         RoundaboutGraph rg = new RoundaboutGraph(false);
         rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, false));
-        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto MainStreet",
@@ -348,7 +348,7 @@ public void testCalcInstructionsRoundaboutClockwise()
         RoundaboutGraph rg = new RoundaboutGraph(true);
         System.out.println(rg.clockwise);
 
-        Path p = new Dijkstra(rg.g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList( "Continue onto MainStreet",
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index c8607c1f5e..9d2bc3acaa 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -36,12 +36,15 @@
  */
 public class QueryGraphTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
+    private EncodingManager encodingManager;
+    private FlagEncoder carEncoder;
     private GraphStorage g;
 
     @Before
     public void setUp()
     {
+        carEncoder = new CarFlagEncoder();
+        encodingManager = new EncodingManager(carEncoder);
         g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(100);
     }
 
@@ -325,8 +328,7 @@ public void testOneWayLoop_Issue162()
         // | x
         // 0<-\
         // |
-        // 1
-        FlagEncoder carEncoder = encodingManager.getSingle();
+        // 1        
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0, 0);
         na.setNode(1, 0, -0.001);
@@ -520,13 +522,13 @@ public void testTurnCostsProperlyPropagated_Issue282()
         QueryGraph qGraph = new QueryGraph(graphWithTurnCosts);
         FastestWeighting weighting = new FastestWeighting(encoder);
         TurnWeighting turnWeighting = new TurnWeighting(weighting, encoder, (TurnCostExtension) qGraph.getExtension());
-        
+
         assertEquals(0, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
 
         // now use turn costs and QueryGraph
         turnExt.addTurnInfo(edge0.getEdge(), 1, edge1.getEdge(), encoder.getTurnFlags(false, 10));
         assertEquals(10, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
-        
+
         QueryResult res1 = createLocationResult(0.000, 0.005, edge0, 0, QueryResult.Position.EDGE);
         QueryResult res2 = createLocationResult(0.005, 0.010, edge1, 0, QueryResult.Position.EDGE);
 
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 74cc852f3b..cf1ece6a4e 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -28,7 +28,7 @@
 import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
+import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
@@ -94,6 +94,57 @@ public void testMonaco()
         assertEquals(7.429758, g.getNodeAccess().getLon(201), 1e-6);
     }
 
+    @Test
+    public void testMonacoAllAlgorithmsWithBaseGraph()
+    {
+        String vehicle = "car";
+        String graphFile = "target/monaco-gh";
+        String osmFile = "files/monaco.osm.gz";
+        String importVehicles = vehicle;
+
+        Helper.removeDir(new File(graphFile));
+        GraphHopper hopper = new GraphHopper().
+                // avoid that path.getDistance is too different to path.getPoint.calcDistance
+                setWayPointMaxDistance(0).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(graphFile).
+                setEncodingManager(new EncodingManager(importVehicles));
+
+        hopper.importOrLoad();
+
+        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
+        Weighting weighting = hopper.createWeighting(new WeightingMap("shortest"), encoder);
+
+        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                encoder, true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
+        AlgoHelperEntry chPrepare = prepares.get(prepares.size() - 1);
+        if (!(chPrepare.getQueryGraph() instanceof LevelGraph))
+            throw new IllegalStateException("Last prepared queryGraph has to be a levelGraph");
+
+        // set all normal algorithms to baseGraph of already prepared to see if all algorithms still work
+        Graph baseGraphOfCHPrepared = chPrepare.getQueryGraph().getBaseGraph();
+        for (AlgoHelperEntry ahe : prepares)
+        {
+            if (!(ahe.getQueryGraph() instanceof LevelGraph))
+            {
+                ahe.setQueryGraph(baseGraphOfCHPrepared);
+            }
+        }
+
+        List<OneRun> forEveryAlgo = createMonacoCar();
+        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+        for (AlgoHelperEntry entry : prepares)
+        {
+            LocationIndex idx = entry.getIdx();
+            for (OneRun oneRun : forEveryAlgo)
+            {
+                List<QueryResult> list = oneRun.getList(idx, edgeFilter);
+                testCollector.assertDistance(entry, list, oneRun);
+            }
+        }
+    }
+
     @Test
     public void testOneWayCircleBug()
     {
@@ -609,7 +660,7 @@ public void run()
         hopper.close();
     }
 
-    public static Collection<AlgoHelperEntry> createAlgos( Graph g,
+    static List<AlgoHelperEntry> createAlgos( Graph g,
             LocationIndex idx, final FlagEncoder encoder, boolean withCh,
             final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
     {
@@ -630,7 +681,7 @@ public void run()
                     set3D(g.getNodeAccess().is3D()).levelGraphCreate());
             final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(graphCH, encoder, weighting, tMode);
             prepareCH.doWork();
-            LocationIndex idxCH = new LocationIndexTreeSC(graphCH, new RAMDirectory()).prepareIndex();
+            LocationIndex idxCH = new LocationIndexTree(graphCH.getBaseGraph(), new RAMDirectory()).prepareIndex();
             prepare.add(new AlgoHelperEntry(graphCH, dijkstrabiOpts, idxCH)
             {
                 @Override
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index b086da8b50..9dd71bd9c2 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -18,12 +18,7 @@
 package com.graphhopper.routing.ch;
 
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.LevelGraphStorage;
@@ -145,9 +140,60 @@ public long setProperties( double speed, boolean forward, boolean backward )
             }
         };
 
-        footEncoder = new EncodingManager("FOOT").getSingle();
+        footEncoder = new FootFlagEncoder();
+        new EncodingManager(footEncoder);
+        
         super.testCalcFootPath();
         footEncoder = tmpFootEncoder;
         carEncoder = tmpCarEncoder;
     }
+
+    @Test
+    public void testBaseGraph()
+    {
+        CarFlagEncoder carFE = new CarFlagEncoder();
+        Graph g = createGraph(new EncodingManager(carFE), false);
+        initDirectedAndDiffSpeed(g, carFE);
+
+        // do CH preparation for car
+        createFactory(g, defaultOpts);
+
+        // use base graph for solving normal Dijkstra
+        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(g, defaultOpts).calcPath(0, 3);
+        assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
+        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 144823, p1.getMillis());
+    }
+
+    @Test
+    public void testBaseGraphMultipleVehicles()
+    {
+        Graph g = createGraph(encodingManager, false);
+        initFootVsCar(g);
+
+        AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new FastestWeighting(footEncoder)).build();
+        AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new FastestWeighting(carEncoder)).build();
+
+        // do CH preparation for car
+        RoutingAlgorithmFactory contractedFactory = createFactory(g, carOptions);
+
+        // use contracted graph
+        Path p1 = contractedFactory.createAlgo(g, carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p1.calcNodes());
+        assertEquals(p1.toString(), 15000, p1.getDistance(), 1e-6);
+
+        // use base graph for solving normal Dijkstra via car
+        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p2.calcNodes());
+        assertEquals(p2.toString(), 15000, p2.getDistance(), 1e-6);
+        assertEquals(p2.toString(), 2700 * 1000, p2.getMillis());
+
+        // use base graph for solving normal Dijkstra via foot
+        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), footOptions).calcPath(0, 7);
+        assertEquals(p3.toString(), 17000, p3.getDistance(), 1e-6);
+        assertEquals(p3.toString(), 12240 * 1000, p3.getMillis());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 2f58c974ec..d2956408f6 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -38,7 +38,7 @@
     private final EncodingManager encodingManager = new EncodingManager("CAR");
     private final CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
     private final Weighting weighting = new ShortestWeighting();
-    private TraversalMode tMode = TraversalMode.NODE_BASED;
+    private final TraversalMode tMode = TraversalMode.NODE_BASED;
 
     LevelGraph createGraph()
     {
@@ -71,7 +71,9 @@ public void testShortestPathSkipNode()
         LevelGraph g = createExampleGraph();
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
         algo.setWeightLimit(100);
         int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
@@ -88,7 +90,9 @@ public void testShortestPathSkipNode2()
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         assertEquals(3, normalDist, 1e-5);
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
         algo.setWeightLimit(10);
         int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
@@ -102,7 +106,9 @@ public void testShortestPathLimit()
     {
         LevelGraph g = createExampleGraph();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(0));
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(0));
         algo.setWeightLimit(2);
         int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
@@ -190,6 +196,7 @@ public void testDirectedGraph3()
 
         PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.initFromGraph();
+        prepare.prepareNodes();
         // find all shortcuts if we contract node 1
         Collection<Shortcut> scs = prepare.testFindShortcuts(1);
         assertEquals(2, scs.size());
@@ -293,10 +300,6 @@ public void testFindShortcuts_Roundabout()
         EdgeIteratorState iter3_1 = g.edge(6, 7, 1, true);
         EdgeIteratorState iter3_2 = g.edge(6, 8, 2, false);
         g.edge(8, 4, 1, false);
-        g.setLevel(3, 3);
-        g.setLevel(5, 5);
-        g.setLevel(7, 7);
-        g.setLevel(8, 8);
 
         PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         EdgeSkipIterState tmp = g.shortcut(1, 4);
@@ -314,6 +317,12 @@ public void testFindShortcuts_Roundabout()
         tmp.setSkippedEdges(iter3_1.getEdge(), iter3_2.getEdge());
 
         prepare.initFromGraph();
+        prepare.prepareNodes();
+        g.setLevel(3, 3);
+        g.setLevel(5, 5);
+        g.setLevel(7, 7);
+        g.setLevel(8, 8);
+
         // there should be two different shortcuts for both directions!
         Collection<Shortcut> sc = prepare.testFindShortcuts(4);
         assertEquals(2, sc.size());
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index 1b45cb56ac..c6ec097254 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -22,18 +22,11 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
-import java.util.Collection;
-import java.util.Collections;
-
 import org.junit.Test;
 
-import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.util.BitUtil;
-import java.util.*;
 
 /**
  *
@@ -198,7 +191,7 @@ public void testCompatibilityBug()
         osmWay.setTag("highway", "footway");
         osmWay.setTag("name", "test");
 
-        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getSingle();
+        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getEncoder("bike2");
         long flags = manager2.handleWayTags(osmWay, singleBikeEnc.acceptBit, 0);
         double singleSpeed = singleBikeEnc.getSpeed(flags);
         assertEquals(4, singleSpeed, 1e-3);
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index 9bd116a678..61a2936111 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -28,13 +28,14 @@
 import java.util.Map;
 import org.junit.*;
 import static org.junit.Assert.*;
+
 /**
  *
  * @author Peter Karich
  */
 public class PrepareRoutingSubnetworksTest
 {
-    private final EncodingManager em = new EncodingManager("CAR");
+    private final EncodingManager em = new EncodingManager("car");
 
     GraphStorage createGraph( EncodingManager eman )
     {
@@ -197,8 +198,9 @@ public void testRemoveDeadEndUnvisitedNetworks()
         GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
         assertEquals(11, g.getNodes());
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOneWayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(3);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
         assertEquals(3, removed);
 
@@ -212,7 +214,7 @@ public void testTarjan()
         GraphStorage g = createSubnetworkTestGraph();
 
         // Requires a single vehicle type, otherwise we throw.
-        final FlagEncoder flagEncoder = em.getSingle();
+        final FlagEncoder flagEncoder = em.getEncoder("car");
         final EdgeFilter filter = new DefaultEdgeFilter(flagEncoder, false, true);
 
         TarjansStronglyConnectedComponentsAlgorithm tarjan = new TarjansStronglyConnectedComponentsAlgorithm(g, filter);
@@ -220,24 +222,36 @@ public void testTarjan()
         List<TIntArrayList> components = tarjan.findComponents();
 
         assertEquals(4, components.size());
-        assertEquals(new TIntArrayList(new int[]{ 13, 5, 3, 7, 0 }), components.get(0));
-        assertEquals(new TIntArrayList(new int[]{ 2, 4, 12, 11, 8, 1 }), components.get(1));
-        assertEquals(new TIntArrayList(new int[] {10, 14, 6}), components.get(2));
-        assertEquals(new TIntArrayList(new int[] {9}), components.get(3));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            13, 5, 3, 7, 0
+        }), components.get(0));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            2, 4, 12, 11, 8, 1
+        }), components.get(1));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            10, 14, 6
+        }), components.get(2));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            9
+        }), components.get(3));
     }
 
     // Previous two-pass implementation failed on 1 -> 2 -> 0
     @Test
-    public void testNodeOrderingRegression() {
+    public void testNodeOrderingRegression()
+    {
         // 1 -> 2 -> 0
         GraphStorage g = createGraph(em);
         g.edge(1, 2, 1, false);
         g.edge(2, 0, 1, false);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(2);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOneWayNetworkSize(2);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
-        
         assertEquals(3, removed);
     }
-
 }
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
index f0b8b8cffe..0fbc9477e4 100644
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
@@ -17,14 +17,14 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.ch.PrepareEncoder;
 import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.LevelEdgeFilter;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.GHUtility;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import static org.junit.Assert.*;
 import org.junit.Test;
@@ -72,6 +72,7 @@ public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
     public void testPriosWhileDeleting()
     {
         LevelGraphStorage g = createGraph();
+        g.getNodeAccess().ensureNode(19);
         for (int i = 0; i < 20; i++)
         {
             g.setLevel(i, i);
@@ -80,13 +81,14 @@ public void testPriosWhileDeleting()
         g.optimize();
         assertEquals(9, g.getLevel(9));
         assertNotSame(10, g.getLevel(10));
-        assertEquals(19, g.getNodes());
     }
 
     @Test
     public void testPrios()
     {
         LevelGraph g = createGraph();
+        g.getNodeAccess().ensureNode(30);
+
         assertEquals(0, g.getLevel(10));
 
         g.setLevel(10, 100);
@@ -210,4 +212,47 @@ public void testGetWeightIfAdvancedEncoder()
         sc1.setWeight(1.011011);
         assertEquals(1.011011, sc1.getWeight(), 1e-3);
     }
+
+    @Test
+    public void testQueryGraph()
+    {
+        LevelGraph levelGraph = createGraph();
+        NodeAccess na = levelGraph.getNodeAccess();
+        na.setNode(0, 1.00, 1.00);
+        na.setNode(1, 1.02, 1.00);
+        na.setNode(2, 1.04, 1.00);
+
+        EdgeIteratorState edge1 = levelGraph.edge(0, 1);
+        EdgeIteratorState edge2 = levelGraph.edge(1, 2);
+        levelGraph.shortcut(0, 1);
+        
+        QueryGraph qGraph = new QueryGraph(levelGraph);
+        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
+        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
+        qGraph.lookup(fromRes, toRes);
+
+        Graph oGraph = qGraph.getBaseGraph();
+        EdgeExplorer explorer = oGraph.createEdgeExplorer();
+
+        assertTrue(levelGraph.getNodes() < qGraph.getNodes());
+        assertTrue(oGraph.getNodes() == qGraph.getNodes());
+
+        // traverse virtual edges and normal edges but no shortcuts!
+        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
+        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
+
+        // get neighbors from virtual nodes
+        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
+        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
+    }
+
+    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
+    {
+        QueryResult res = new QueryResult(lat, lon);
+        res.setClosestEdge(edge);
+        res.setWayIndex(wayIndex);
+        res.setSnappedPosition(QueryResult.Position.EDGE);
+        res.calcSnappedPoint(Helper.DIST_PLANE);
+        return res;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index cf996add31..e447b1c058 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -74,7 +74,7 @@ public void testSimpleGraph()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 8);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -128,7 +128,7 @@ public void testSimpleGraph2()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 28);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -153,7 +153,7 @@ public void testGrid()
         Graph g = createSampleGraph(new EncodingManager("CAR"));
         int locs = g.getNodes();
 
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
         // if we would use less array entries then some points gets the same key so avoid that for this test
         // e.g. for 16 we get "expected 6 but was 9" i.e 6 was overwritten by node j9 which is a bit closer to the grid center        
         // go through every point of the graph if all points are reachable
@@ -211,7 +211,7 @@ boolean testGridIgnore( int i )
     public void testSinglePoints120()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
 
         assertEquals(1, idx.findID(1.637, 2.23));
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -227,7 +227,7 @@ public void testSinglePoints120()
     public void testSinglePoints32()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
 
         // 10 or 6
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -355,7 +355,7 @@ public void testDifferentVehicles()
         final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
         Graph g = createGraph(encodingManager);
         initSimpleGraph(g);
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         assertEquals(1, idx.findID(1, -1));
 
         // now make all edges from node 1 accessible for CAR only
@@ -367,7 +367,7 @@ public void testDifferentVehicles()
         }
         idx.close();
 
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
         assertEquals(2, idx.findClosest(1, -1, new DefaultEdgeFilter(footEncoder)).getClosestNode());
         Helper.close((Closeable) g);
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index 801367d298..bb43cef11b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -33,13 +33,16 @@
     @Override
     public LocationIndex createIndex( Graph g, int resolution )
     {
-        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).setResolution(resolution).prepareIndex();
+        if(resolution < 0)
+            resolution = 120;
+        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).
+                setResolution(resolution).prepareIndex();
     }
 
     @Test
     public void testNormedDist()
     {
-        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager()), new RAMDirectory());
+        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
         assertEquals(2, index.getNormedDist(0, 7), 1e-6);
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
similarity index 85%
rename from core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
rename to core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
index 0b59bcb6c9..0f3c93d92b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
@@ -40,15 +40,23 @@
 /**
  * @author Peter Karich
  */
-public class LocationIndexTreeSCTest extends LocationIndexTreeTest
+public class LocationIndexTreeForLevelGraphTest extends LocationIndexTreeTest
 {
     @Override
-    public LocationIndexTreeSC createIndex( Graph g, int resolution )
+    public LocationIndexTree createIndex( Graph g, int resolution )
+    {
+        if (resolution < 0)
+            resolution = 500000;
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
+    }
+
+    @Override
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
-        LocationIndexTreeSC idx = new LocationIndexTreeSC((LevelGraph) g, dir);
-        idx.setResolution(1000000).prepareIndex();
-        return idx;
+        LocationIndexTree tmpIdx = new LocationIndexTree(g.getBaseGraph(), dir);
+        tmpIdx.setResolution(resolution);
+        return tmpIdx;
     }
 
     @Override
@@ -99,6 +107,7 @@ public void testLevelGraph()
     public void testSortHighLevelFirst()
     {
         final LevelGraph lg = createGraph(new RAMDirectory(), encodingManager, false);
+        lg.getNodeAccess().ensureNode(4);
         lg.setLevel(1, 10);
         lg.setLevel(2, 30);
         lg.setLevel(3, 20);
@@ -135,7 +144,7 @@ public void testLevelGraphBug()
         na.setNode(2, 0.5, 0.5);
         na.setNode(3, 0.5, 1);
         EdgeIteratorState iter1 = lg.edge(1, 0, 100, true);
-        EdgeIteratorState iter2 = lg.edge(2, 3, 100, true);
+        lg.edge(2, 3, 100, true);
 
         lg.setLevel(0, 11);
         lg.setLevel(1, 10);
@@ -147,15 +156,17 @@ public void testLevelGraphBug()
         // disconnect higher 3 from lower 2
         lg.disconnect(lg.createEdgeExplorer(), iter1);
 
-        LocationIndexTreeSC index = new LocationIndexTreeSC(lg, new RAMDirectory());
-        index.setResolution(100000);
-        index.prepareIndex();
+        LocationIndexTree index = createIndex(lg, 100000);
+
         // very close to 2, but should match the edge 0--1
         TIntHashSet set = index.findNetworkEntries(0.51, 0.2, index.maxRegionSearch);
+        assertEquals(0, index.findID(0.51, 0.2));
+        assertEquals(1, index.findID(0.1, 0.1));
+        assertEquals(2, index.findID(0.51, 0.51));
+        assertEquals(3, index.findID(0.51, 1.1));
         TIntSet expectedSet = new TIntHashSet();
-        expectedSet.add(1);
+        expectedSet.add(0);
         expectedSet.add(2);
         assertEquals(expectedSet, set);
-        assertEquals(0, index.findID(0.51, 0.2));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index 8fcb543aad..f4a24cfc41 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -42,14 +42,16 @@
     @Override
     public LocationIndexTree createIndex( Graph g, int resolution )
     {
-        return internalCreateIndex(g, 500000);
+        if (resolution < 0)
+            resolution = 500000;        
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
     }
 
-    public LocationIndexTree internalCreateIndex( Graph g, int minMeter )
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
         LocationIndexTree tmpIDX = new LocationIndexTree(g, dir);
-        tmpIDX.setResolution(minMeter).prepareIndex();
+        tmpIDX.setResolution(resolution);
         return tmpIDX;
     }
 
@@ -87,7 +89,7 @@ Graph createTestGraph()
     public void testSnappedPointAndGeometry()
     {
         Graph graph = createTestGraph();
-        LocationIndex index = createIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         // query directly the tower node
         QueryResult res = index.findClosest(-0.4, 0.9, EdgeFilter.ALL_EDGES);
         assertEquals(new GHPoint(-0.4, 0.9), res.getSnappedPoint());
@@ -103,8 +105,8 @@ public void testSnappedPointAndGeometry()
     public void testInMemIndex()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 50000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
 
@@ -144,8 +146,8 @@ public void testInMemIndex()
     public void testInMemIndex2()
     {
         Graph graph = createTestGraph2();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(500).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 500);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
         assertEquals(3, inMemIndex.getEntriesOf(0).size());
@@ -181,9 +183,8 @@ public void testInMemIndex2()
     @Test
     public void testInMemIndex3()
     {
-        Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(10000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(createTestGraph(), 10000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(64, 4), index.getEntries());
 
@@ -202,8 +203,7 @@ public void testInMemIndex3()
     @Test
     public void testReverseSpatialKey()
     {
-        LocationIndexTree index = new LocationIndexTree(createTestGraph(), new RAMDirectory());
-        index.setMinResolutionInMeter(200).prepareAlgo();
+        LocationIndexTree index = createIndex(createTestGraph(), 200);
         assertEquals(Helper.createTList(64, 64, 64, 4), index.getEntries());
 
         // 10111110111110101010
@@ -224,7 +224,7 @@ public void testMoreReal()
         graph.edge(1, 0, 1000, true);
         graph.edge(0, 2, 1000, true);
         graph.edge(0, 3, 1000, true).setWayGeometry(Helper.createPointList(51.21, 9.43));
-        LocationIndex index = internalCreateIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         assertEquals(2, index.findID(51.2, 9.4));
     }
 
@@ -261,7 +261,7 @@ private Graph createTestGraphWithWayGeometry()
     public void testWayGeometry()
     {
         Graph g = createTestGraphWithWayGeometry();
-        LocationIndex index = createIndex(g, 1000);
+        LocationIndex index = createIndex(g, -1);
         assertEquals(1, index.findID(0, 0));
         assertEquals(1, index.findID(0, 0.1));
         assertEquals(1, index.findID(0.1, 0.1));
@@ -289,7 +289,7 @@ public void testFindingWayGeometry()
     public void testEdgeFilter()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = createIndex(graph, 1000);
+        LocationIndexTree index = createIndex(graph, -1);
 
         assertEquals(1, index.findClosest(-.6, -.6, EdgeFilter.ALL_EDGES).getClosestNode());
         assertEquals(2, index.findClosest(-.6, -.6, new EdgeFilter()
@@ -402,9 +402,7 @@ Graph createTestGraph2()
     public void testRMin()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMaxRegionSearch(1);
-        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree index = createIndex(graph, 50000);
 
         //query: 0.05 | -0.3
         DistanceCalc distCalc = new DistancePlaneProjection();
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 17e1dcaf91..79b9fc9f95 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -39,6 +39,7 @@
 import org.json.JSONObject;
 import org.junit.Test;
 import static org.junit.Assert.*;
+import org.junit.Before;
 import org.xml.sax.SAXException;
 
 /**
@@ -50,12 +51,19 @@
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation usTR = trMap.getWithFallBack(Locale.US);
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
+    private EncodingManager carManager;
+    private FlagEncoder carEncoder;
+    
+    @Before
+    public void setUp() {
+        carEncoder = new CarFlagEncoder();
+        carManager = new EncodingManager(carEncoder);
+    }
 
     @SuppressWarnings("unchecked")
     @Test
     public void testWayList()
-    {
-        EncodingManager carManager = new EncodingManager("CAR");
+    {                
         Graph g = new GraphBuilder(carManager).create();
         // 0-1-2
         // | | |
@@ -101,7 +109,7 @@ public void testWayList()
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 10);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 10);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
@@ -131,7 +139,6 @@ public void testWayList()
                 asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
-        FlagEncoder carEncoder = carManager.getSingle();
         p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
         assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
@@ -145,7 +152,7 @@ public void testWayList()
                 wayList.createStartPoints());
 
         // special case of identical start and end
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 0);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 0);
         wayList = p.calcInstructions(usTR);
         assertEquals(1, wayList.size());
         assertEquals("Finish!", wayList.get(0).getTurnDescription(usTR));
@@ -206,7 +213,6 @@ void compare( List<List<Double>> expected, List<List<Double>> was )
     @Test
     public void testWayList2()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -228,14 +234,14 @@ public void testWayList2()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
 
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Finish!"),
                 tmpList);
 
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(3, 5);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(usTR);
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-4", "Continue onto 4-5", "Finish!"),
@@ -246,7 +252,6 @@ public void testWayList2()
     @Test
     public void testNoInstructionIfSameStreet()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -268,7 +273,7 @@ public void testNoInstructionIfSameStreet()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto street", "Finish!"), tmpList);
@@ -277,7 +282,6 @@ public void testNoInstructionIfSameStreet()
     @Test
     public void testInstructionsWithTimeAndPlace()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   4-5
         //   |
@@ -296,7 +300,7 @@ public void testInstructionsWithTimeAndPlace()
         g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
         g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(1, 5);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
         InstructionList wayList = p.calcInstructions(usTR);
         assertEquals(5, wayList.size());
 
@@ -458,10 +462,9 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
 
     @Test
     public void testEmptyList()
-    {
-        EncodingManager carManager = new EncodingManager("CAR");
+    {        
         Graph g = new GraphBuilder(carManager).create();
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 1);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(usTR);
         assertEquals(0, il.size());
         assertEquals(0, il.createStartPoints().size());
diff --git a/docs/core/ch.md b/docs/core/ch.md
index 32cdbda276..4d55a5c847 100644
--- a/docs/core/ch.md
+++ b/docs/core/ch.md
@@ -6,14 +6,6 @@ In GraphHopper CH is enabled by default but can be easily disabled.
 To make CH work in GraphHopper a LevelGraphStorage instead of the normal GraphStorage 
 is necessary which allows to store shortcuts too.
 
-After a graph is prepared it cannot be used for graph exploration anymore, this is
-a limitation of the preparation and storage and is handled in issue #116.
-Due to that limitation a special location index is necessary (LocationIndexTreeSC).
-
-Also at the moment only one vehicle can be used if CH is enabled, see issue #111.
-
-So, if you still need graph exploration for your LevelGraphStorage you can specify 
-graphHopper.doPrepare(false) before you call importOrLoad, which avoids the CH preparation.
-Then do your graph explorations or whatever and store the graph.
-If you call importOrLoad next time without doPrepare(false) the CH-preparation will be done.
+A prepared graph can also be used for normal graph traversal IF you use graph.getBaseGraph().
 
+If CH is enabled multiple vehicles will work but only one works in speed-up mode and is faster, see issue #111.
diff --git a/docs/core/location-index.md b/docs/core/location-index.md
index 9fa25b7c7a..69a18b839a 100644
--- a/docs/core/location-index.md
+++ b/docs/core/location-index.md
@@ -12,19 +12,12 @@ QueryResult qr = findClosest(lat, lon, EdgeFilter.ALL_EDGES );
 EdgeIteratorState edge = qr.getClosestEdge();
 ```
 
-If you don't use the GraphHopper class you have to handle every case on your own to build a location index.
-E.g. if it is a LevelGraph you need LocationIndexTreeSC otherwise LocationIndexTree:
+If you don't use the GraphHopper class you have to use the low level API:
 
 ```java
-LocationIndexTree tmpIndex;
-if (graph instanceof LevelGraph)
-   tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-else
-   tmpIndex = new LocationIndexTree(graph, dir);
-
-tmpIndex.setResolution(preciseIndexResolution);
-tmpIndex.setSearchRegion(searchRegion);
-// now build the index if it cannot be loaded
-if (!tmpIndex.loadExisting())
-   tmpIndex.prepareIndex();
+LocationIndexTree index = new LocationIndexTree(graph.getBaseGraph(), dir);
+index.setResolution(preciseIndexResolution);
+index.setMaxRegionSearch(maxRegionSearch);
+if (!index.loadExisting())
+    index.prepareIndex();
 ```
\ No newline at end of file
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index b552261124..3fb61ae58e 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -40,7 +40,7 @@ graph.flush();
 ...
 GraphStorage graph = gb.load();
 // Load index
-LocationIndex index = new LocationIndexTree(graph, new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location index cannot be loaded!");
 ```
@@ -84,7 +84,7 @@ graph.flush();
 GraphStorage graph = gb.load();
 
  // Load index
-Location2IDIndex index = new LocationIndexTreeSC(graph, new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location2id index cannot be loaded!");
 
diff --git a/docs/core/routing.md b/docs/core/routing.md
index dcdaf693c1..5c6da786bd 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -46,9 +46,16 @@ List<String> iList = il.createDescription(tr);
 List<GPXEntry> list = il.createGPXList();
 ```
 
-If you want a more flexible routing (but slower) you can disable contraction hierarchies
-and import multiple vehicles. Then pick one vehicle and optionally the algorithm like
-astar as algorithm:
+If you want to support multiple profiles you have to specify the default vehicle in order
+to pick the vehicle where contraction hierarchies will be enabled:
+```java
+GraphHopper hopper = new GraphHopper().forServer();
+hopper.setDefaultVehicle("car");
+...
+```
+
+If you want a more flexible routing (but slower) you can disable contraction hierarchies. 
+Then pick one vehicle to route on and optionally the algorithm like 'bidirectional astar' as algorithm:
 
 ```java
 GraphHopper hopper = new GraphHopper().forServer();
@@ -60,14 +67,20 @@ hopper.setEncodingManager(new EncodingManager("car,bike"));
 
 hopper.importOrLoad();
 
-GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR);
+GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
+    setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR_BI);
 GHResponse res = hopper.route(req);
 ```
 
-In case you need the online routing API in a Java or Android application the GraphHopperWeb comes handy - see the 'web' sub module.
+In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
+ see the 'web' sub module.
 
 ```java
 GraphHopperAPI gh = new GraphHopperWeb();
 gh.load("http://your-graphhopper-service.com");
+
+// or for the GraphHopper Directions API https://graphhopper.com/#directions-api
+// gh.load("https://graphhopper.com/api/1/route");
+
 GHResponse rsp = gh.route(new GHRequest(...));
 ```
\ No newline at end of file
diff --git a/docs/core/technical.md b/docs/core/technical.md
index 5cc0ea1372..50f831d5fb 100644
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -59,7 +59,7 @@ For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teachi
 See issue [#116](https://github.com/graphhopper/graphhopper/issues/116) for the progress of this feature.
 
 In order to traverse the _LevelGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
-is done automatically for you if you call graph.getOriginalGraph(). This is necessary in a 
+is done automatically for you if you call graph.getBaseGraph(). This is necessary in a 
 _LocationIndex_ and partially in the _Path_ class in order to identify how many streets leave a junction
 or similar. See #116 for more information.
 
diff --git a/graphhopper.sh b/graphhopper.sh
index 31743f87aa..c6bd2b132a 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -259,8 +259,8 @@ elif [ "$ACTION" = "torture" ]; then
  "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.QueryTorture $3 $4 $5 $6 $7 $8 $9
 
 
-elif [ "$ACTION" = "miniui" ]; then
- "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/tools/pom.xml" -DskipTests clean install assembly:single
+elif [ "$ACTION" = "xminiui" ]; then
+ "$MAVEN_HOME/bin/mvn" --projects tools -DskipTests clean install assembly:single
  JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar   
  "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI osmreader.osm="$OSM_FILE" printVersion=true config=$CONFIG \
               graph.location="$GRAPH"
@@ -289,7 +289,7 @@ elif [ "$ACTION" = "measurement" ]; then
   
  if [ "$last_commits" = "" ]; then
    # use current version
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
    exit
  fi
@@ -302,7 +302,7 @@ elif [ "$ACTION" = "measurement" ]; then
    M_FILE_NAME="measurement$M_FILE_NAME.properties"
    echo -e "\nusing commit $commit and $M_FILE_NAME"
    
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
    echo -e "\nmeasurement.commit=$commit\n" >> "$M_FILE_NAME"
  done
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index ae932d78b7..48fd784f85 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -121,7 +121,7 @@ void start( CmdArgs args )
         try
         {
             maxNode = g.getNodes();
-            printGraphDetails(g);
+            printGraphDetails(g, vehicleStr);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
 
             // Route via dijkstrabi. Normal routing takes a lot of time => smaller query number than CH
@@ -161,13 +161,13 @@ void start( CmdArgs args )
         }
     }
 
-    private void printGraphDetails( GraphStorage g )
+    private void printGraphDetails( GraphStorage g, String vehicleStr )
     {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
         put("graph.edges", g.getAllEdges().getCount());
         put("graph.sizeInMB", g.getCapacity() / Helper.MB);
-        put("graph.encoder", g.getEncodingManager().getSingle().toString());
+        put("graph.encoder", vehicleStr);
     }
 
     private void printLocationIndexQuery( Graph g, final LocationIndex idx, int count )
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 6d8038ee2c..0049944ee0 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -76,7 +76,7 @@ public MiniGraphUI( GraphHopper hopper, boolean debug )
         this.graph = hopper.getGraph();
         this.na = graph.getNodeAccess();
         algoFactory = hopper.getAlgorithmFactory();
-        encoder = hopper.getEncodingManager().getSingle();
+        encoder = hopper.getEncodingManager().getEncoder("car");
         weighting = hopper.createWeighting(new WeightingMap("fastest"), encoder);
         algoOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
 
