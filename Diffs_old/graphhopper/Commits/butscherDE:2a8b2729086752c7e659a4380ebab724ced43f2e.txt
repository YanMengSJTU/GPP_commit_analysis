diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index fb570c047b..f0df32a48a 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -71,10 +71,10 @@ private void prepareRouteCandidateList() {
 
     private void pruneLowerQuantileInROIcandidateRoutes() {
         // Assumes that routeCandidates was already sorted descending to roi distance after pruning dominated route candidates
-        final int startIndex = (int) (this.routeCandidates.getCandidates().size() * 0.75) + 1;
+        final int startIndex = (int) (this.routeCandidates.size() * 0.75) + 1;
 
-        for (int i = startIndex; i < this.routeCandidates.getCandidates().size(); i++) {
-            this.routeCandidates.getCandidates().remove(i);
+        for (int i = startIndex; i < this.routeCandidates.size(); i++) {
+            this.routeCandidates.remove(i);
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
index 1c34e79b83..f3fbf08546 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -103,7 +103,7 @@ private void buildRouteCandidatesForCurrentPoint(final int currentViaPoint, fina
         for (final int LOTNodeL : currentPointsLOTNodes) {
             for (final int LOTNodeLPrime : currentPointsLOTNodes) {
                 if (LOTNodeL != LOTNodeLPrime) {
-                    this.routeCandidates.getCandidates().add(buildCandidatePath(currentViaPoint, nextViaPoint, LOTNodeL, LOTNodeLPrime));
+                    this.routeCandidates.add(buildCandidatePath(currentViaPoint, nextViaPoint, LOTNodeL, LOTNodeLPrime));
                 }
             }
         }
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
index fe1af42768..a455c4b8fd 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/OneToManyRouting.java
@@ -29,15 +29,12 @@ public OneToManyRouting(final int fromNode, final List<Integer> toNodes, List<In
     }
 
     void calculatePaths() {
-        StopWatch sw = new StopWatch("one to many routing complete");
-        sw.start();
         for (final int toNode : toNodes) {
+            final int lala = toNode;
             final RoutingAlgorithm routingAlgorithm = buildRoutingAlgorithmForFromToPair(toNode);
             final Path path = routingAlgorithm.calcPath(this.fromNode, toNode);
             this.allFoundPaths.put(new Pair<>(this.fromNode, toNode), path);
         }
-        sw.stop();
-        System.out.println(sw.toString());
     }
 
     private RoutingAlgorithm buildRoutingAlgorithmForFromToPair(int toNode) {
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
index 54707a90a7..fb13178f1d 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateList.java
@@ -17,11 +17,11 @@ public RouteCandidateList() {
     }
 
     public void sortByGainAscending() {
-        Collections.sort(this.getCandidates());
+        Collections.sort(this.candidates);
     }
 
     private void sortRouteCandidatesToDistanceInROIDescending() {
-        Collections.sort(this.getCandidates(), new Comparator<RouteCandidatePolygon>() {
+        Collections.sort(this.candidates, new Comparator<RouteCandidatePolygon>() {
             @Override
             public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
                 double distanceDifference = rc1.getDistanceInROI() - rc2.getDistanceInROI();
@@ -42,7 +42,7 @@ public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
     public List<Path> getFirstAsPathList(int nOfFirstElements, QueryGraph queryGraph, AlgorithmOptions algorithmOptions) {
         final List<Path> paths = new ArrayList<>(nOfFirstElements);
 
-        final int endOfCandidates = getCandidates().size() - 1;
+        final int endOfCandidates = this.candidates.size() - 1;
         paths.addAll(addPathsBasedOnIntersectionStatus(nOfFirstElements, queryGraph, algorithmOptions, endOfCandidates, false));
         paths.addAll(addPathsBasedOnIntersectionStatus(nOfFirstElements, queryGraph, algorithmOptions, endOfCandidates, true));
 
@@ -54,7 +54,7 @@ public int compare(RouteCandidatePolygon rc1, RouteCandidatePolygon rc2) {
         List<Path> paths = new ArrayList<>(nOfFirstElements);
         int indexIntoCandidates = endOfCandidates;
         while (indexIntoCandidates >= 0 && paths.size() < nOfFirstElements) {
-            final RouteCandidatePolygon candidate = this.getCandidates().get(indexIntoCandidates);
+            final RouteCandidatePolygon candidate = this.candidates.get(indexIntoCandidates);
 
             if (candidate.isDetourSelfIntersecting(queryGraph, algorithmOptions) == addSelfIntersecting) {
                 paths.add(candidate.getMergedPath(queryGraph, algorithmOptions));
@@ -72,7 +72,7 @@ public void pruneDominatedCandidateRoutes() {
 
         int currentPruningCandidateIndex = 1;
         while (indexInCandidateBounds(currentPruningCandidateIndex)) {
-            RouteCandidatePolygon currentPruningCandidate = this.getCandidates().get(currentPruningCandidateIndex);
+            RouteCandidatePolygon currentPruningCandidate = this.candidates.get(currentPruningCandidateIndex);
 
             boolean foundDominatingPath = isThisCandidateDominatedByAny(currentPruningCandidateIndex, currentPruningCandidate);
 
@@ -84,7 +84,7 @@ private boolean isThisCandidateDominatedByAny(int currentPruningCandidateIndex,
         boolean foundDominatingPath = false;
         for (int i = currentPruningCandidateIndex - 1; i >= 0 && !foundDominatingPath; i--) {
             // routeCandidates must be sorted by now. Therefore dominators can only bbe found on lower indices than the current pruning candidate.
-            RouteCandidatePolygon possiblyBetterRouteCandidate = this.getCandidates().get(i);
+            RouteCandidatePolygon possiblyBetterRouteCandidate = this.candidates.get(i);
 
             if (isPruningCandidateDominated(currentPruningCandidate, possiblyBetterRouteCandidate)) {
                 foundDominatingPath = true;
@@ -95,7 +95,7 @@ private boolean isThisCandidateDominatedByAny(int currentPruningCandidateIndex,
 
     private int pruneOrUpdateIndex(int currentPruningCandidateIndex, boolean foundDominatingPath) {
         if (foundDominatingPath) {
-            this.getCandidates().remove(currentPruningCandidateIndex);
+            this.candidates.remove(currentPruningCandidateIndex);
         } else {
             currentPruningCandidateIndex++;
         }
@@ -108,11 +108,29 @@ private boolean isPruningCandidateDominated(RouteCandidatePolygon currentPruning
     }
 
     private boolean indexInCandidateBounds(int currentPruningCandidateIndex) {
-        return currentPruningCandidateIndex < this.getCandidates().size();
+        return currentPruningCandidateIndex < this.candidates.size();
     }
 
-    public List<T> getCandidates() {
-        return candidates;
+    public int size() {
+        return this.candidates.size();
+    }
+
+    public void remove(Object o) {
+        this.candidates.remove(o);
+    }
+
+    public void add(T o) {
+        if (o.isLegalCandidate()) {
+            this.candidates.add(o);
+        }
+    }
+
+    public void clear() {
+        this.candidates.clear();
+    }
+
+    public T get(int i) {
+        return this.candidates.get(i);
     }
 
     void setCandidates(List<T> candidates) {
diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
index 5a3736bab1..11968ea137 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
@@ -40,6 +40,7 @@ public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions al
     private void mergePath(QueryGraph queryGraph, AlgorithmOptions algoOpts) {
         PathMerge completePathCandidate = new PathMerge(queryGraph, algoOpts.getWeighting());
 
+        System.out.println(this.toString());
         completePathCandidate.addPath(startToDetourEntry);
         completePathCandidate.addPath(detourEntryToDetourExit);
         completePathCandidate.addPath(detourExitToEnd);
@@ -133,4 +134,25 @@ public String toString() {
                     "gain: " + this.getGain();
         return sb;
     }
+
+    public boolean isLegalCandidate() {
+        return isAllSubpathsValid();
+    }
+
+    private boolean isAllSubpathsValid() {
+        boolean allValid = true;
+        allValid &= isSubpathValid(this.startToDetourEntry);
+        allValid &= isSubpathValid(this.detourEntryToDetourExit);
+        allValid &= isSubpathValid(this.detourExitToEnd);
+
+        return allValid;
+    }
+
+    private static boolean isSubpathValid(final Path path) {
+        if (path != null) {
+            return path.isFound();
+        } else {
+            throw new IllegalStateException("Calculate paths before validating them.");
+        }
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
index 54f9a43a56..c1024ba965 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateListTest.java
@@ -21,48 +21,48 @@
     private final GHRequest ghRequest = new GHRequest(0, 0, 10, 10).setPolygon(new Polygon(new double[]{5, 10, 10, 5}, new double[]{5, 5, 10, 10})).setVehicle("car");
 
     private void addTestingCandidates() {
-        this.candidateList.getCandidates().clear();
+        this.candidateList.clear();
 
-        Path startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        Path detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        Path detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(3, 6, 1, "a", startToDetourEntry,
+        Path startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        Path detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        Path detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(3, 6, 1, "a", startToDetourEntry,
                                                                         detourEntryToDetourExit, detourExitToEnd, null));
 
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(2, 3, 1, "b", startToDetourEntry,
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(2, 3, 1, "b", startToDetourEntry,
                                                                         detourEntryToDetourExit, detourExitToEnd, null));
 
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(6, 6, 5, "c", startToDetourEntry,
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(6, 6, 5, "c", startToDetourEntry,
                                                                         detourEntryToDetourExit, detourExitToEnd, null));
 
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(4, 5, 3, "d", startToDetourEntry,
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(4, 5, 3, "d", startToDetourEntry,
                                                                         detourEntryToDetourExit, detourExitToEnd, null));
 
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(8, 4, 6, "e", startToDetourEntry,
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(8, 4, 6, "e", startToDetourEntry,
                                                                         detourEntryToDetourExit, detourExitToEnd, null));
 
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(6, 1, 3, "f", startToDetourEntry,
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(6, 1, 3, "f", startToDetourEntry,
                                                                         detourEntryToDetourExit, detourExitToEnd, null));
 
-        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting);
-        this.candidateList.getCandidates().add(new RouteCandidateMocker(7, 1, 6, "g", startToDetourEntry,
+        startToDetourEntry = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourEntryToDetourExit = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        detourExitToEnd = new PathMerge(graphMocker.graph, graphMocker.weighting).setFound(true);
+        this.candidateList.add(new RouteCandidateMocker(7, 1, 6, "g", startToDetourEntry,
                                                                         detourEntryToDetourExit, detourExitToEnd, null));
     }
 
@@ -71,9 +71,9 @@ public void assertCorrectListContentAfterPruning() {
         addTestingCandidates();
         this.candidateList.pruneDominatedCandidateRoutes();
 
-        assertEquals("a", this.candidateList.getCandidates().get(0).name);
-        assertEquals("c", this.candidateList.getCandidates().get(1).name);
-        assertEquals("b", this.candidateList.getCandidates().get(2).name);
+        assertEquals("a", this.candidateList.get(0).name);
+        assertEquals("c", this.candidateList.get(1).name);
+        assertEquals("b", this.candidateList.get(2).name);
     }
 
     @Test
@@ -91,6 +91,39 @@ public void assertCorrectTopThreeRoutes() {
         assertEquals(3, topCandidates.size());
     }
 
+    @Test
+    public void testIllegalStartToDetourSubpath() {
+        addTestingCandidates();
+        final RouteCandidateMocker testingCandidate = this.candidateList.get(0);
+        testingCandidate.startToDetourEntry.setFound(false);
+
+        illegalCandidateNotAdded(testingCandidate);
+    }
+
+    @Test
+    public void testIllegalDetourEntryToDetourExitSubpath() {
+        addTestingCandidates();
+        final RouteCandidateMocker testingCandidate = this.candidateList.get(0);
+        testingCandidate.detourEntryToDetourExit.setFound(false);
+
+        illegalCandidateNotAdded(testingCandidate);
+    }
+
+    @Test
+    public void testIllegalDetourExitToEndSubpath() {
+        addTestingCandidates();
+        final RouteCandidateMocker testingCandidate = this.candidateList.get(0);
+        testingCandidate.detourExitToEnd.setFound(false);
+
+        illegalCandidateNotAdded(testingCandidate);
+    }
+
+    private void illegalCandidateNotAdded(RouteCandidateMocker testingCandidate) {
+        final int sizeBeforeAdding = this.candidateList.size();
+        this.candidateList.add(testingCandidate);
+        assertEquals(sizeBeforeAdding, this.candidateList.size());
+    }
+
     class RouteCandidateMocker extends RouteCandidatePolygon {
         final double polygonRouteDistance;
         final double roiDistance;
