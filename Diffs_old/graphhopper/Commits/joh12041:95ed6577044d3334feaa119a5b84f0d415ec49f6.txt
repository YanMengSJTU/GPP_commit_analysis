diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/GPSToPath.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/GPSToPath.java
deleted file mode 100644
index 1d41f3ffa1..0000000000
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/GPSToPath.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package com.graphhopper.reader.osm;
-
-/**
- * Created by isaac on 11/26/16.
- */
-public class GPSToPath {
-}
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
index 06c601f61a..8a8be7dbd0 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/runKSP.java
@@ -4,7 +4,12 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.PathWrapper;
+import com.graphhopper.matching.MapMatching;
+import com.graphhopper.matching.MatchResult;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.Path;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.util.*;
 
 import java.util.*;
@@ -30,6 +35,9 @@
     private HashMap<String, Integer> gvHeaderMap;
     private HashMap<String, Float> gridBeauty;
     private GraphHopper hopper;
+    private MapMatching mapMatching;
+    private String outputheader = "ID,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity" +
+            System.getProperty("line.separator");
 
     public runKSP(String city, String route_type) {
 
@@ -38,7 +46,7 @@ public runKSP(String city, String route_type) {
         this.outputFiles = new ArrayList<>(4);
     }
 
-    public void setCiy(String city) {
+    public void setCity(String city) {
         this.city = city;
     }
 
@@ -46,6 +54,93 @@ public void setRouteType(String route_type) {
         this.route_type = route_type;
     }
 
+    public PathWrapper GPXToPath(ArrayList<GPXEntry> gpxEntries) {
+        PathWrapper matchGHRsp = new PathWrapper();
+        try {
+            MatchResult mr = mapMatching.doWork(gpxEntries);
+            Path path = mapMatching.calcPath(mr);
+            new PathMerger().doWork(matchGHRsp, Collections.singletonList(path), new TranslationMap().doImport().getWithFallBack(Locale.US));
+        }
+        catch (RuntimeException e) {
+            System.out.println("Broken GPX trace.");
+            System.out.println(e.getMessage());
+        }
+        return matchGHRsp;
+    }
+
+    public void PointsToPath(String fin, String fout) throws IOException {
+        Scanner sc_in = new Scanner(new File(fin));
+        String[] pointsHeader = sc_in.nextLine().split(",");
+        int idIdx = -1;
+        int latIdx = -1;
+        int lonIdx = -1;
+        int timeIdx = -1;
+        for (int i=0; i<pointsHeader.length; i++) {
+            if (pointsHeader[i].equalsIgnoreCase("ID")) {
+                idIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("lat")) {
+                latIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("lon")) {
+                lonIdx = i;
+            }
+            else if (pointsHeader[i].equalsIgnoreCase("millis")) {
+                timeIdx = i;
+            }
+            else {
+                System.out.println("Unexpected header value: " + pointsHeader[i]);
+            }
+        }
+        String line;
+        String[] vals;
+        String routeID = "";
+        String prevRouteID = "";
+        double lat;
+        double lon;
+        long time;
+        ArrayList<GPXEntry> pointsList = new ArrayList<>();
+        PathWrapper path;
+        FileWriter sc_out = new FileWriter(fout, true);
+        sc_out.write(outputheader);
+        int i = 0;
+        float score;
+        while (sc_in.hasNext()) {
+            line = sc_in.nextLine();
+            vals = line.split(",");
+            routeID = vals[idIdx];
+            lat = Double.valueOf(vals[latIdx]);
+            lon = Double.valueOf(vals[lonIdx]);
+            time = Long.valueOf(vals[timeIdx]);
+            GPXEntry pt = new GPXEntry(lat, lon, time);
+            if (routeID.equalsIgnoreCase(prevRouteID)) {
+                pointsList.add(pt);
+            }
+            else if (pointsList.size() > 0) {
+                path = GPXToPath(pointsList);
+                if (path.getDistance() > 0) {
+                    score = getBeauty(path);
+                    writeOutput(sc_out, i, "Google", routeID, path, score);
+                }
+                pointsList.clear();
+                i++;
+            }
+            pointsList.add(pt);
+            prevRouteID = routeID;
+        }
+        if (pointsList.size() > 0) {
+            path = GPXToPath(pointsList);
+            if (path.getDistance() > 0) {
+                score = getBeauty(path);
+                writeOutput(sc_out, i, "Google", routeID, path, score);
+            }
+        }
+        sc_out.close();
+        sc_in.close();
+    }
+
+
+
     public void setDataSources() throws Exception {
         if (city.equals("SF")) {
             osmFile = osmFile + "san-francisco-bay_california.osm.pbf";
@@ -114,6 +209,20 @@ public void prepareGraphHopper() {
         hopper.importOrLoad();
     }
 
+    public void prepMapMatcher() {
+
+        // create MapMatching object, can and should be shared accross threads
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().
+                algorithm(Parameters.Algorithms.DIJKSTRA_BI).
+                traversalMode(hopper.getTraversalMode()).
+                hints(new HintsMap().put("weighting", "fastest").put("vehicle", "car")).
+                build();
+        mapMatching = new MapMatching(hopper, algoOpts);
+        mapMatching.setTransitionProbabilityBeta(0.00959442);
+        mapMatching.setMeasurementErrorSigma(40);
+    }
+
+
     public void writeOutput(FileWriter fw, int i, String optimized, String od_id, PathWrapper bestPath, float score) throws IOException {
 
         // points, distance in meters and time in seconds (convert from ms) of the full path
@@ -135,13 +244,29 @@ public void writeOutput(FileWriter fw, int i, String optimized, String od_id, Pa
 
     }
 
+    public float getBeauty(PathWrapper path) {
+        HashSet<String> roundedPoints = path.roundPoints();
+        float score = 0;
+        for (String pt : roundedPoints) {
+            if (gridBeauty.containsKey(pt)) {
+                score = score + gridBeauty.get(pt);
+            }
+        }
+        score = score / roundedPoints.size();
+        return score;
+    }
+
+
+    public void augment_routes() throws Exception {
+
+    }
+
+
     public void process_routes() throws Exception {
         ArrayList<float[]> inputPoints = new ArrayList<float[]>();
         ArrayList<String> id_to_points = new ArrayList<String>();
 
         // Prep Filewriters (Optimized, Worst-but-same-distance, Fastest, Simplest)
-        String outputheader = "ID,polyline_points,total_time_in_sec,total_distance_in_meters,number_of_steps,maneuvers,beauty,simplicity" +
-                System.getProperty("line.separator");
         outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_beauty.csv"), true));
         outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_ugly.csv"), true));
         outputFiles.add(new FileWriter(outputPointsFN.replaceFirst(".csv","_fast.csv"), true));
@@ -210,19 +335,11 @@ public void process_routes() throws Exception {
             List<PathWrapper> paths = rsp.getAll();
 
             // Score each route on beauty to determine most beautiful
-            HashSet<String> roundedPoints;
             int j = 0;
             float bestscore = -1000;
             int routeidx = -1;
             for (PathWrapper path : paths) {
-                roundedPoints = path.roundPoints();
-                float score = 0;
-                for (String pt : roundedPoints) {
-                    if (gridBeauty.containsKey(pt)) {
-                        score = score + gridBeauty.get(pt);
-                    }
-                }
-                score = score / roundedPoints.size();
+                float score = getBeauty(path);
                 if (score > bestscore) {
                     bestscore = score;
                     routeidx = j;
@@ -240,14 +357,7 @@ public void process_routes() throws Exception {
             for (PathWrapper path : paths) {
                 uglydistance = path.getDistance();
                 if (uglydistance / beautyDistance < 1.05 && uglydistance / beautyDistance > 0.95) {
-                    roundedPoints = path.roundPoints();
-                    float score = 0;
-                    for (String pt : roundedPoints) {
-                        if (gridBeauty.containsKey(pt)) {
-                            score = score + gridBeauty.get(pt);
-                        }
-                    }
-                    score = score / roundedPoints.size();
+                    float score = getBeauty(path);
                     if (score < bestscore) {
                         bestscore = score;
                         routeidx = j;
@@ -267,14 +377,7 @@ public void process_routes() throws Exception {
                 if (score < bestscore) {
                     bestscore = score;
                     routeidx = j;
-                    roundedPoints = path.roundPoints();
-                    beauty = 0;
-                    for (String pt : roundedPoints) {
-                        if (gridBeauty.containsKey(pt)) {
-                            beauty = beauty + gridBeauty.get(pt);
-                        }
-                    }
-                    beauty = beauty / roundedPoints.size();
+                    beauty = getBeauty(path);
                 }
                 j++;
             }
@@ -282,14 +385,7 @@ public void process_routes() throws Exception {
 
             // Fastest Route
             PathWrapper bestPath = paths.get(0);
-            roundedPoints = bestPath.roundPoints();
-            beauty = 0;
-            for (String pt : roundedPoints) {
-                if (gridBeauty.containsKey(pt)) {
-                    beauty = beauty + gridBeauty.get(pt);
-                }
-            }
-            beauty = beauty / roundedPoints.size();
+            beauty = getBeauty(bestPath);
             writeOutput(outputFiles.get(3), i, "Fast", od_id, bestPath, beauty);
         }
 
@@ -303,18 +399,28 @@ public void process_routes() throws Exception {
     public static void main(String[] args) throws Exception {
 
         // PBF from: https://mapzen.com/data/metro-extracts/
-        // NYC Grid
-        //process_routes("NYC", "grid", true);
-        // NYC Random
-        //process_routes("NYC", "rand", true);
         // SF Grid
-        runKSP SFGrid = new runKSP("SF", "grid");
-        SFGrid.setDataSources();
-        SFGrid.getGridValues();
-        SFGrid.prepareGraphHopper();
-        SFGrid.process_routes();
+        runKSP ksp = new runKSP("SF", "grid");
         // SF Random
-        //process_routes("SF", "rand", true);
-        //process_routes("BOS", "check", true);
+        //runKSP ksp = new runKSP("SF", "rand");
+        // NYC Grid
+        //runKSP ksp = new runKSP("NYC", "grid");
+        // NYC Random
+        //runKSP ksp = new runKSP("NYC", "rand");
+        // BOS Check
+        //runKSP ksp = new runKSP("BOS", "check");
+
+        // Get routes and scores for origin-destination pairs
+        ksp.setDataSources();
+        ksp.getGridValues();
+        ksp.prepareGraphHopper();
+        //ksp.process_routes();
+
+        // Score external API routes
+        //ksp.setCity("SF");
+        //ksp.setRouteType("grid");
+        ksp.prepMapMatcher();
+        ksp.PointsToPath("../data/output/sf_grid_google_gpx.csv", "../data/output/sf_grid_google_ghenhanced.csv");
+
     }
 }
