diff --git a/.travis.yml b/.travis.yml
index f1e53db4fa..3bf2a5c51a 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -12,9 +12,9 @@ env:
 matrix:
   include:
     - jdk: openjdk8
-    - env: JDK='OpenJDK 11'
-      install: . ./install-jdk.sh -F 11 -C
     - env: JDK='OpenJDK 12'
+      install: . ./install-jdk.sh -F 11 -C
+    - env: JDK='OpenJDK 13'
       install: . ./install-jdk.sh -F 12 -C
     
 # avoid default dependency command for maven, 'true' means 'return true' and continue
diff --git a/README.md b/README.md
index 2beab72602..e4566f6188 100644
--- a/README.md
+++ b/README.md
@@ -183,9 +183,9 @@ docker run -d --name graphhopper -v <path_data_directory>/data:/data -p 8989:898
 
 Here is a list of the more detailed features including a link to the documentation:
 
- * [Simple start for users](./docs/web/quickstart.md) - just Java necessary! [Simple start for developers](./docs/core/quickstart-from-source.md) due to Maven.
- * Works out of the box with OpenStreetMap (osm/xml and pbf) but can be adapted to use your own data
- * OpenStreetMap integration: Takes care of the road type, the surface, barriers, access restrictions, ferries, [conditional access restrictions](https://github.com/graphhopper/graphhopper/pull/621), ...
+ * [Quick installation and start for users](./docs/web/quickstart.md) - just Java necessary! [Simple start for developers](./docs/core/quickstart-from-source.md) due to Maven.
+ * Works out of the box with OpenStreetMap (osm/xml and pbf) and can be adapted to custom data
+ * OpenStreetMap integration: Takes care of the road type, speed limit, the surface, barriers, access restrictions, ferries, [conditional access restrictions](https://github.com/graphhopper/graphhopper/pull/621), ...
  * GraphHopper is fast. And with the so called "Contraction Hierarchies" it can be even faster (enabled by default).
  * Memory efficient data structures, algorithms and [the low and high level API](./docs/core/low-level-api.md) is tuned towards ease of use and efficiency
  * Provides a simple [web API](./docs/web/api-doc.md) including JavaScript and Java clients
@@ -199,10 +199,9 @@ Here is a list of the more detailed features including a link to the documentati
  * [Alternative routes](https://discuss.graphhopper.com/t/alternative-routes/424) (flexible and hybrid mode only)
  * [Turn costs and restrictions](./docs/core/turn-restrictions.md)
  * Country specific routing via SpatialRules
- * Multiple profiles and weightings
- * Several pre-built routing profiles: car, bike, racingbike, mountain bike, foot, motorcycle, ...
  * The core uses only a few dependencies (hppc, jts and slf4j)
  * Scales from small indoor-sized to world-wide-sized graphs
- * Find nearest point on street e.g. to get elevation or 'snap to road'
+ * Find nearest point on street e.g. to get elevation or 'snap to road' or being used as spatial index (see [#1485](https://github.com/graphhopper/graphhopper/pull/1485))
  * Do [map matching](https://github.com/graphhopper/map-matching) with GraphHopper
  * Calculate [isochrones](./docs/web/api-doc.md#isochrone) with GraphHopper
+ * Show path details [#1142](https://github.com/graphhopper/graphhopper/pull/1142)
diff --git a/android/app/build.gradle b/android/app/build.gradle
index 8a4611deb1..fc4d4ea6ba 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -42,14 +42,14 @@ dependencies {
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    implementation 'org.mapsforge:vtm:0.10.0'
-    implementation 'org.mapsforge:vtm-android:0.10.0'
-    implementation 'org.mapsforge:vtm-android:0.10.0:natives-armeabi-v7a'
-    implementation 'org.mapsforge:vtm-android:0.10.0:natives-arm64-v8a'
-    implementation 'org.mapsforge:vtm-android:0.10.0:natives-x86'
-    implementation 'org.mapsforge:vtm-android:0.10.0:natives-x86_64'
-    implementation 'org.mapsforge:vtm-jts:0.10.0'
-    implementation 'org.mapsforge:vtm-themes:0.10.0'
+    implementation 'org.mapsforge:vtm:0.11.0'
+    implementation 'org.mapsforge:vtm-android:0.11.0'
+    implementation 'org.mapsforge:vtm-android:0.11.0:natives-armeabi-v7a'
+    implementation 'org.mapsforge:vtm-android:0.11.0:natives-arm64-v8a'
+    implementation 'org.mapsforge:vtm-android:0.11.0:natives-x86'
+    implementation 'org.mapsforge:vtm-android:0.11.0:natives-x86_64'
+    implementation 'org.mapsforge:vtm-jts:0.11.0'
+    implementation 'org.mapsforge:vtm-themes:0.11.0'
     implementation 'com.caverock:androidsvg:1.3'
 
     implementation 'org.slf4j:slf4j-api:1.7.25'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index 8de5671ed0..ade25517b7 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -19,7 +19,7 @@
         <version>0.13-SNAPSHOT</version>
     </parent>
     <properties>
-        <vtm.version>0.10.0</vtm.version>
+        <vtm.version>0.11.0</vtm.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
diff --git a/android/build.gradle b/android/build.gradle
index a743a5ba45..ca48f6921f 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.2.1'
+        classpath 'com.android.tools.build:gradle:3.3.2'
     }
 }
 
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index 9a4163a4f5..4e974715fd 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/api/src/main/java/com/graphhopper/util/Helper.java b/api/src/main/java/com/graphhopper/util/Helper.java
index de08e73101..11c2270460 100644
--- a/api/src/main/java/com/graphhopper/util/Helper.java
+++ b/api/src/main/java/com/graphhopper/util/Helper.java
@@ -20,6 +20,8 @@
 import com.graphhopper.util.shapes.BBox;
 
 import java.io.*;
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
 import java.nio.ByteBuffer;
 import java.nio.MappedByteBuffer;
 import java.nio.charset.Charset;
@@ -174,6 +176,29 @@ public static String getMemInfo() {
         return "totalMB:" + getTotalMB() + ", usedMB:" + getUsedMB();
     }
 
+    public static int getUsedMBAfterGC() {
+        long before = getTotalGcCount();
+        // trigger gc
+        System.gc();
+        while (getTotalGcCount() == before) {
+            // wait for the gc to have completed
+        }
+        long result = (ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed() +
+                ManagementFactory.getMemoryMXBean().getNonHeapMemoryUsage().getUsed()) / (1024 * 1024);
+        return (int) result;
+    }
+
+    private static long getTotalGcCount() {
+        long sum = 0;
+        for (GarbageCollectorMXBean b : ManagementFactory.getGarbageCollectorMXBeans()) {
+            long count = b.getCollectionCount();
+            if (count != -1) {
+                sum += count;
+            }
+        }
+        return sum;
+    }
+
     public static int getSizeOfObjectRef(int factor) {
         // pointer to class, flags, lock
         return factor * (4 + 4 + 4);
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
index 09391def2d..cfc3a31cc2 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
@@ -26,12 +26,14 @@
 
 /**
  * Uses a very simple version of stall-on-demand (SOD) for CH queries to prevent exploring nodes that can not be part
- * of a shortest path. When a node that is about to be settled is stallable it is not expanded, but no further search
- * for neighboring stallable nodes is performed.
+ * of a shortest path. When a node that is about to be settled is stallable it is not expanded. However, no further search
+ * for neighboring stallable nodes is performed (sometimes called 'aggressive' stalling in the literature). Some experimenting
+ * showed that due to the overhead for such aggressive stalling the routing does not become faster, see #240.
  *
  * @author easbar
  */
 public class DijkstraBidirectionCH extends DijkstraBidirectionCHNoSOD {
+
     public DijkstraBidirectionCH(Graph graph, Weighting weighting) {
         super(graph, weighting);
     }
@@ -62,10 +64,16 @@ private boolean entryIsStallable(SPTEntry entry, IntObjectMap<SPTEntry> bestWeig
         // reached via a suboptimal path. We do this regardless of the CH level of the adjacent nodes.
         EdgeIterator iter = edgeExplorer.setBaseNode(entry.adjNode);
         while (iter.next()) {
+            // no need to inspect the edge we are coming from
+            if (iter.getEdge() == entry.adjNode) {
+                continue;
+            }
             int traversalId = traversalMode.createTraversalId(iter, reverse);
             SPTEntry adjNode = bestWeightMap.get(traversalId);
+            // we have to be careful because of rounded shortcut weights in combination with virtual via nodes, see #1574
+            final double precision = 0.001;
             if (adjNode != null &&
-                    adjNode.weight + weighting.calcWeight(iter, !reverse, getIncomingEdge(entry)) < entry.weight) {
+                    adjNode.weight + weighting.calcWeight(iter, !reverse, getIncomingEdge(entry)) - entry.weight < -precision) {
                 return true;
             }
         }
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index 684ecc9dd5..1c52802bdc 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -83,7 +83,7 @@ public Path extract() {
         setFromNode(currEdge.adjNode);
         reverseOrder();
         currEdge = edgeTo;
-        int prevEdge = nextEdgeValid ? sptEntry.edge : EdgeIterator.NO_EDGE;
+        int prevEdge = EdgeIterator.Edge.isValid(sptEntry.edge) ? sptEntry.edge : EdgeIterator.NO_EDGE;
         int tmpEdge = currEdge.edge;
         while (EdgeIterator.Edge.isValid(tmpEdge)) {
             currEdge = currEdge.parent;
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
index c873f90e58..0393696503 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -213,7 +213,11 @@ public EdgeIteratorState setName(String name) {
 
     @Override
     public String toString() {
-        return edges.toString();
+        if (current >= 0 && current < edges.size()) {
+            return "virtual edge: " + edges.get(current) + ", all: " + edges.toString();
+        } else {
+            return "virtual edge: (invalid)" + ", all: " + edges.toString();
+        }
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
index 1158a5047f..ce6135e1a8 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
@@ -167,12 +167,15 @@ private long findShortcuts(ShortcutHandler sch) {
         // collect outgoing nodes (goal-nodes) only once
         while (incomingEdges.next()) {
             int fromNode = incomingEdges.getAdjNode();
-            // accept only uncontracted nodes
-            if (isContracted(fromNode))
+            // accept only not-contracted nodes, do not consider loops at the node that is being contracted
+            if (fromNode == sch.getNode() || isContracted(fromNode))
                 continue;
 
+            final double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
+            if (Double.isInfinite(incomingEdgeWeight)) {
+                continue;
+            }
             final double incomingEdgeDistance = incomingEdges.getDistance();
-            double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
             int incomingEdge = incomingEdges.getEdge();
             int inOrigEdgeCount = getOrigEdgeCount(incomingEdge);
             // collect outgoing nodes (goal-nodes) only once
@@ -182,8 +185,8 @@ private long findShortcuts(ShortcutHandler sch) {
             degree++;
             while (outgoingEdges.next()) {
                 int toNode = outgoingEdges.getAdjNode();
-                // add only uncontracted nodes
-                if (isContracted(toNode) || fromNode == toNode)
+                // add only not-contracted nodes, do not consider loops at the node that is being contracted
+                if (toNode == sch.getNode() || isContracted(toNode) || fromNode == toNode)
                     continue;
 
                 // Limit weight as ferries or forbidden edges can increase local search too much.
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 4d7df30659..413a0b2bd2 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -605,7 +605,7 @@ public DecimalEncodedValue getDecimalEncodedValue(String key) {
     }
 
     @Override
-    public <T extends Enum> EnumEncodedValue getEnumEncodedValue(String key, Class<T> enumType) {
+    public <T extends Enum> EnumEncodedValue<T> getEnumEncodedValue(String key, Class<T> enumType) {
         return encodedValueLookup.getEnumEncodedValue(key, enumType);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
index 1a99a8fb46..b745d59bc7 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
@@ -18,7 +18,7 @@
 package com.graphhopper.routing.util;
 
 /**
- * Encodes and decodes a turn restriction and turn costs within a integer flag
+ * Encodes and decodes a turn restriction or turn costs within an integer flag
  *
  * @author Karl Hübner
  */
@@ -35,8 +35,7 @@
     double getTurnCost(long flags);
 
     /**
-     * @param restricted true if restricted turn, equivalent to specifying of costs
-     *                   Double.POSITIVE_INFINITY
+     * @param restricted true if restricted turn, equivalent to specifying costs = Double.POSITIVE_INFINITY
      * @param costs      the turn costs, specify 0 or Double.POSITIVE_INFINITY if restricted == true.
      *                   Only used if restricted == false.
      * @return the encoded flags
@@ -44,7 +43,7 @@
     long getTurnFlags(boolean restricted, double costs);
 
     /**
-     * No turn costs will be enabled by this encoder, should be used for pedestrians
+     * No turn costs will be enabled by this encoder, should be used for e.g. pedestrians
      */
     class NoTurnCostsEncoder implements TurnCostEncoder {
 
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
index 24ff798e80..dec1157968 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
@@ -89,15 +89,14 @@ public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrN
         if (prevOrNextEdgeId == EdgeIterator.NO_EDGE)
             return millis;
 
-        // TODO for now assume turn costs are returned in milliseconds?
         // should we also separate weighting vs. time for turn? E.g. a fast but dangerous turn - is this common?
-        long turnCostsInMillis;
+        long turnCostsInSeconds;
         if (reverse)
-            turnCostsInMillis = (long) calcTurnWeight(edgeState.getEdge(), edgeState.getBaseNode(), prevOrNextEdgeId);
+            turnCostsInSeconds = (long) calcTurnWeight(edgeState.getEdge(), edgeState.getBaseNode(), prevOrNextEdgeId);
         else
-            turnCostsInMillis = (long) calcTurnWeight(prevOrNextEdgeId, edgeState.getBaseNode(), edgeState.getEdge());
+            turnCostsInSeconds = (long) calcTurnWeight(prevOrNextEdgeId, edgeState.getBaseNode(), edgeState.getEdge());
 
-        return millis + turnCostsInMillis;
+        return millis + 1000 * turnCostsInSeconds;
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index 0636306da8..fe2a6b4168 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -95,7 +95,7 @@ public CHGraph chGraphCreate(Weighting singleCHWeighting) {
     /**
      * Default graph is a {@link GraphHopperStorage} with an in memory directory and disabled storing on flush.
      * Afterwards you'll need to call {@link GraphHopperStorage#create} to have a usable object. Better use
-     * {@link GraphHopperStorage#create} directly.
+     * {@link #create} directly.
      */
     public GraphHopperStorage build() {
         Directory dir = mmap ?
diff --git a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
index d1a1c2cb25..248064119d 100644
--- a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
+++ b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
@@ -93,7 +93,7 @@ private long applyChange(JsonFeature jsonFeature, FlagEncoder encoder) {
         BooleanEncodedValue accessEnc = encoder.getAccessEnc();
         DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
         long updates = 0;
-        EdgeFilter filter = DefaultEdgeFilter.allEdges(encoder);
+        EdgeFilter filter = EdgeFilter.ALL_EDGES;
         GHIntHashSet edges = new GHIntHashSet();
         if (jsonFeature.hasGeometry()) {
             graphBrowser.fillEdgeIDs(edges, jsonFeature.getGeometry(), filter);
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index ed68a50c1d..fe8bd4baa5 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -164,7 +164,7 @@ public void calcSnappedPoint(DistanceCalc distCalc) {
     @Override
     public String toString() {
         if (closestEdge != null)
-            return closestEdge.getBaseNode() + "-" + closestEdge.getAdjNode() + "  " + snappedPoint;
+            return closestEdge.getBaseNode() + "-" + closestEdge.getAdjNode() + "  " + snappedPoint + ", " + queryPoint;
         return closestNode + ", " + queryPoint + ", " + wayIndex;
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index e4596d1b97..18ad578b8f 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -164,7 +164,10 @@ private static void printUnitTestEdge(FlagEncoder encoder, EdgeIteratorState edg
                 "graph.edge(%d, %d, %f, %s);\n", from, to, edge.getDistance(), fwd && bwd ? "true" : "false");
     }
 
-    public static void buildRandomGraph(Graph graph, long seed, int numNodes, double meanDegree, boolean allowLoops, boolean allowZeroDistance, double pBothDir) {
+    public static void buildRandomGraph(Graph graph, long seed, int numNodes, double meanDegree, boolean allowLoops, boolean allowZeroDistance, double pBothDir, double pRandomOffset) {
+        if (numNodes < 2 || meanDegree < 1) {
+            throw new IllegalArgumentException("numNodes must be >= 2, meanDegree >= 1");
+        }
         Random random = new Random(seed);
         for (int i = 0; i < numNodes; ++i) {
             double lat = 49.4 + (random.nextDouble() * 0.01);
@@ -173,32 +176,38 @@ public static void buildRandomGraph(Graph graph, long seed, int numNodes, double
         }
         double minDist = Double.MAX_VALUE;
         double maxDist = Double.MIN_VALUE;
-        int numEdges = (int) (0.5 * meanDegree * numNodes);
-        for (int i = 0; i < numEdges; ++i) {
+        int totalNumEdges = (int) (0.5 * meanDegree * numNodes);
+        int numEdges = 0;
+        while (numEdges < totalNumEdges) {
             int from = random.nextInt(numNodes);
             int to = random.nextInt(numNodes);
             if (!allowLoops && from == to) {
                 continue;
             }
             double distance = GHUtility.getDistance(from, to, graph.getNodeAccess());
+            // allow loops with non-zero distance
+            if (from == to && random.nextDouble() < 0.7) {
+                distance = random.nextDouble() * 1000;
+            }
             if (!allowZeroDistance) {
                 distance = Math.max(0.001, distance);
             }
-            // add some random offset for most cases, but also allow duplicate edges with same weight
-            if (random.nextDouble() < 0.8)
+            // add some random offset, but also allow duplicate edges with same weight
+            if (random.nextDouble() < pRandomOffset)
                 distance += random.nextDouble() * distance * 0.01;
             minDist = Math.min(minDist, distance);
             maxDist = Math.max(maxDist, distance);
             // using bidirectional edges will increase mean degree of graph above given value
             boolean bothDirections = random.nextDouble() < pBothDir;
             graph.edge(from, to, distance, bothDirections);
+            numEdges++;
         }
         LOGGER.debug(String.format(Locale.ROOT, "Finished building random graph" +
                         ", nodes: %d, edges: %d , min distance: %.2f, max distance: %.2f\n",
                 graph.getNodes(), graph.getAllEdges().length(), minDist, maxDist));
     }
 
-    private static double getDistance(int from, int to, NodeAccess nodeAccess) {
+    public static double getDistance(int from, int to, NodeAccess nodeAccess) {
         double fromLat = nodeAccess.getLat(from);
         double fromLon = nodeAccess.getLon(from);
         double toLat = nodeAccess.getLat(to);
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index d775530f23..8faeec1bdf 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -29,12 +29,12 @@
 import java.util.List;
 
 /**
- * This class merges multiple {@link Path} objects into one continues object that
+ * This class merges multiple {@link Path} objects into one continuous object that
  * can be used in the {@link PathWrapper}. There will be a Path between every waypoint.
  * So for two waypoints there will be only one Path object. For three waypoints there will be
  * two Path objects.
  * <p>
- * The instructions are generated per Path object and are merged into one continues InstructionList.
+ * The instructions are generated per Path object and are merged into one continuous InstructionList.
  * The PointList per Path object are merged and optionally simplified.
  *
  * @author Peter Karich
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index 67b0751eb9..e9e39e371e 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -19,7 +19,10 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.cursors.IntCursor;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
@@ -28,6 +31,7 @@
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Assume;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -55,6 +59,8 @@ public EdgeBasedRoutingAlgorithmTest(String algo) {
     @Parameters(name = "{0}")
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
+                // todo: make this test run also for edge-based CH or otherwise make sure time calculation is tested also for edge-based CH (at the moment it will fail!)
+                // todo: make this test run also for ALT or otherwise make sure time calculation is tested also for ALT (at the moment it will fail?!)
                 {DIJKSTRA},
                 {DIJKSTRA_BI},
                 {ASTAR},
@@ -81,7 +87,7 @@ public static void initGraph(Graph g) {
         g.edge(6, 7, 1, true);
     }
 
-    EncodingManager createEncodingManager(boolean restrictedOnly) {
+    private EncodingManager createEncodingManager(boolean restrictedOnly) {
         if (restrictedOnly)
             carEncoder = new CarFlagEncoder(5, 5, 1);
         else
@@ -95,38 +101,36 @@ public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
         return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
     }
 
-    protected GraphHopperStorage createStorage(EncodingManager em) {
+    private GraphHopperStorage createStorage(EncodingManager em) {
         return new GraphBuilder(em).create();
     }
 
-    private void initTurnRestrictions(Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder) {
-        long tflags = tEncoder.getTurnFlags(true, 0);
-
+    private void initTurnRestrictions(Graph g, TurnCostExtension tcs) {
         // only forward from 2-3 to 3-4 => limit 2,3->3,6 and 2,3->3,1
-        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
-        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
+        addTurnRestriction(g, tcs, 2, 3, 6);
+        addTurnRestriction(g, tcs, 2, 3, 1);
 
         // only right   from 5-2 to 2-3 => limit 5,2->2,0
-        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 0).getEdge(), tflags);
+        addTurnRestriction(g, tcs, 5, 2, 0);
 
         // only right   from 7-6 to 6-3 => limit 7,6->6,5
-        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
+        addTurnRestriction(g, tcs, 7, 6, 5);
 
         // no 5-6 to 6-3
-        tcs.addTurnInfo(getEdge(g, 5, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
+        addTurnRestriction(g, tcs, 5, 6, 3);
         // no 4-3 to 3-1
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
+        addTurnRestriction(g, tcs, 4, 3, 1);
         // no 4-3 to 3-2
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), tflags);
+        addTurnRestriction(g, tcs, 4, 3, 2);
 
         // no u-turn at 6-7
-        tcs.addTurnInfo(getEdge(g, 6, 7).getEdge(), 7, getEdge(g, 7, 6).getEdge(), tflags);
+        addTurnRestriction(g, tcs, 6, 7, 6);
 
         // no u-turn at 3-6
-        tcs.addTurnInfo(getEdge(g, 3, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
+        addTurnRestriction(g, tcs, 3, 6, 3);
     }
 
-    Weighting createWeighting(FlagEncoder encoder, TurnCostExtension tcs, double uTurnCosts) {
+    private Weighting createWeighting(FlagEncoder encoder, TurnCostExtension tcs, double uTurnCosts) {
         return new TurnWeighting(new FastestWeighting(encoder), tcs).setDefaultUTurnCost(uTurnCosts);
     }
 
@@ -135,40 +139,81 @@ public void testBasicTurnRestriction() {
         GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
-        initTurnRestrictions(g, tcs, carEncoder);
+        initTurnRestrictions(g, tcs);
         Path p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 1);
-        assertEquals(IntArrayList.from(new int[]{5, 2, 3, 4, 7, 6, 3, 1}), p.calcNodes());
+        assertEquals(IntArrayList.from(5, 2, 3, 4, 7, 6, 3, 1), p.calcNodes());
 
         // test 7-6-5 and reverse
         p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 7);
-        assertEquals(IntArrayList.from(new int[]{5, 6, 7}), p.calcNodes());
+        assertEquals(IntArrayList.from(5, 6, 7), p.calcNodes());
 
         p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(7, 5);
-        assertEquals(IntArrayList.from(new int[]{7, 6, 3, 2, 5}), p.calcNodes());
+        assertEquals(IntArrayList.from(7, 6, 3, 2, 5), p.calcNodes());
+    }
+
+    @Test
+    public void testTurnCosts_timeCalculation() {
+        // 0 - 1 - 2 - 3 - 4
+        GraphHopperStorage g = createStorage(createEncodingManager(false));
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        final int distance = 100;
+        final int turnCosts = 2;
+        g.edge(0, 1, distance, true);
+        g.edge(1, 2, distance, true);
+        g.edge(2, 3, distance, true);
+        g.edge(3, 4, distance, true);
+        addTurnCost(g, tcs, turnCosts, 1, 2, 3);
+
+        AlgorithmOptions opts = AlgorithmOptions.start()
+                .weighting(createWeighting(carEncoder, tcs, 40))
+                .traversalMode(TraversalMode.EDGE_BASED_2DIR)
+                .build();
+
+        {
+            // simple case where turn cost is encountered during forward search
+            Path p14 = createAlgo(g, opts).calcPath(1, 4);
+            assertDistTimeWeight(p14, 3, distance, 6, turnCosts);
+            assertEquals(20, p14.getWeight(), 1.e-6);
+            assertEquals(20000, p14.getTime());
+        }
+
+        {
+            // this test is more involved for bidir algos: the turn costs have to be taken into account also at the
+            // node where fwd and bwd searches meet
+            Path p04 = createAlgo(g, opts).calcPath(0, 4);
+            assertDistTimeWeight(p04, 4, distance, 6, turnCosts);
+            assertEquals(26, p04.getWeight(), 1.e-6);
+            assertEquals(26000, p04.getTime());
+        }
+    }
+
+    private void assertDistTimeWeight(Path path, int numEdges, double distPerEdge, double weightPerEdge, int turnCost) {
+        assertEquals("wrong distance", numEdges * distPerEdge, path.getDistance(), 1.e-6);
+        assertEquals("wrong weight", numEdges * weightPerEdge + turnCost, path.getWeight(), 1.e-6);
+        assertEquals("wrong time", 1000 * (numEdges * weightPerEdge + turnCost), path.getTime(), 1.e-6);
     }
 
 
-    private void blockNode3(Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder) {
+    private void blockNode3(Graph g, TurnCostExtension tcs) {
         // Totally block this node (all 9 turn relations)
-        final long BLOCK = tEncoder.getTurnFlags(true, 0);
-        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 4).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 4).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 1, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 1, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 1, 3).getEdge(), 3, getEdge(g, 3, 4).getEdge(), BLOCK);
+        addTurnRestriction(g, tcs, 2, 3, 1);
+        addTurnRestriction(g, tcs, 2, 3, 4);
+        addTurnRestriction(g, tcs, 4, 3, 1);
+        addTurnRestriction(g, tcs, 4, 3, 2);
+        addTurnRestriction(g, tcs, 6, 3, 1);
+        addTurnRestriction(g, tcs, 6, 3, 4);
+        addTurnRestriction(g, tcs, 1, 3, 6);
+        addTurnRestriction(g, tcs, 1, 3, 2);
+        addTurnRestriction(g, tcs, 1, 3, 4);
     }
 
     @Test
@@ -176,11 +221,11 @@ public void testBlockANode() {
         GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
-        blockNode3(g, tcs, carEncoder);
-        for (int i=0; i<=7; i++) {
-            if (i==3) continue;
-            for (int j=0; j<=7; j++) {
-                if (j==3) continue;
+        blockNode3(g, tcs);
+        for (int i = 0; i <= 7; i++) {
+            if (i == 3) continue;
+            for (int j = 0; j <= 7; j++) {
+                if (j == 3) continue;
                 Path p = createAlgo(g, AlgorithmOptions.start().
                         weighting(createWeighting(carEncoder, tcs, 40)).
                         traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
@@ -199,31 +244,29 @@ public void testUTurns() {
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
 
-        long tflags = carEncoder.getTurnFlags(true, 0);
-
         // force u-turn via lowering the cost for it
         EdgeIteratorState e3_6 = getEdge(g, 3, 6);
         e3_6.setDistance(0.1);
         getEdge(g, 3, 2).setDistance(864);
         getEdge(g, 1, 0).setDistance(864);
 
-        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, e3_6.getEdge(), tflags);
+        addTurnRestriction(g, tcs, 7, 6, 5);
+        addTurnRestriction(g, tcs, 4, 3, 6);
         AlgorithmOptions opts = AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 50)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
         Path p = createAlgo(g, opts).calcPath(7, 5);
 
-        assertEquals(IntArrayList.from(new int[]{7, 6, 3, 6, 5}), p.calcNodes());
+        assertEquals(IntArrayList.from(7, 6, 3, 6, 5), p.calcNodes());
 
         // no u-turn for 6-3
         opts = AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 100)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
-        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
+        addTurnRestriction(g, tcs, 6, 3, 6);
         p = createAlgo(g, opts).calcPath(7, 5);
 
-        assertEquals(IntArrayList.from(new int[]{7, 6, 3, 2, 5}), p.calcNodes());
+        assertEquals(IntArrayList.from(7, 6, 3, 2, 5), p.calcNodes());
     }
 
     @Test
@@ -237,19 +280,17 @@ public void testBasicTurnCosts() {
                 calcPath(5, 1);
 
         // no restriction and costs
-        EdgeIteratorState e3_6 = getEdge(g, 5, 6);
-        e3_6.setDistance(2);
-        assertEquals(IntArrayList.from(new int[]{5, 2, 3, 1}), p.calcNodes());
+        assertEquals(IntArrayList.from(5, 2, 3, 1), p.calcNodes());
 
         // now introduce some turn costs
-        long tflags = carEncoder.getTurnFlags(false, 2);
-        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
+        getEdge(g, 5, 6).setDistance(2);
+        addTurnCost(g, tcs, 2, 5, 2, 3);
 
         p = createAlgo(g, AlgorithmOptions.start().
                 weighting(createWeighting(carEncoder, tcs, 40)).
                 traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
                 calcPath(5, 1);
-        assertEquals(IntArrayList.from(new int[]{5, 6, 3, 1}), p.calcNodes());
+        assertEquals(IntArrayList.from(5, 6, 3, 1), p.calcNodes());
     }
 
     @Test
@@ -258,13 +299,10 @@ public void testTurnCostsBug_991() {
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
 
-        long tflags = carEncoder.getTurnFlags(false, 2);
-        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
-        tcs.addTurnInfo(getEdge(g, 2, 0).getEdge(), 0, getEdge(g, 0, 1).getEdge(), tflags);
-        tcs.addTurnInfo(getEdge(g, 5, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
-
-        tflags = carEncoder.getTurnFlags(false, 1);
-        tcs.addTurnInfo(getEdge(g, 6, 7).getEdge(), 7, getEdge(g, 7, 4).getEdge(), tflags);
+        addTurnCost(g, tcs, 2, 5, 2, 3);
+        addTurnCost(g, tcs, 2, 2, 0, 1);
+        addTurnCost(g, tcs, 2, 5, 6, 3);
+        addTurnCost(g, tcs, 1, 6, 7, 4);
 
         Path p = createAlgo(g, AlgorithmOptions.start().
                 weighting(new TurnWeighting(new FastestWeighting(carEncoder), tcs) {
@@ -279,7 +317,23 @@ public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
                 }.setDefaultUTurnCost(40)).
                 traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
                 calcPath(5, 1);
-        assertEquals(IntArrayList.from(new int[]{5, 6, 7, 4, 3, 1}), p.calcNodes());
-        assertEquals(301, p.getTime(), .1);
+        assertEquals(IntArrayList.from(5, 6, 7, 4, 3, 1), p.calcNodes());
+        assertEquals(5 * 0.06 + 1, p.getWeight(), 1.e-6);
+        assertEquals(1300, p.getTime(), .1);
+    }
+
+    private void addTurnRestriction(Graph g, TurnCostExtension tcs, int from, int via, int to) {
+        long turnFlags = carEncoder.getTurnFlags(true, 0);
+        addTurnFlags(g, tcs, from, via, to, turnFlags);
     }
+
+    private void addTurnCost(Graph g, TurnCostExtension tcs, int costs, int from, int via, int to) {
+        long turnFlags = carEncoder.getTurnFlags(false, costs);
+        addTurnFlags(g, tcs, from, via, to, turnFlags);
+    }
+
+    private void addTurnFlags(Graph g, TurnCostExtension tcs, int from, int via, int to, long turnFlags) {
+        tcs.addTurnInfo(getEdge(g, from, via).getEdge(), via, getEdge(g, via, to).getEdge(), turnFlags);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
index 54b1d9f1ef..6ee7677a52 100644
--- a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
@@ -18,15 +18,15 @@
 package com.graphhopper.routing;
 
 import com.carrotsearch.hppc.IntArrayList;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.SPTEntry;
-import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIterator;
 import org.junit.Test;
 
@@ -36,9 +36,8 @@
  * @author Peter Karich
  */
 public class PathBidirRefTest {
-    private final EncodingManager encodingManager = EncodingManager.create("car");
-    private FlagEncoder carEncoder = encodingManager.getEncoder("car");
-    private EdgeFilter carOutEdges = DefaultEdgeFilter.outEdges(carEncoder);
+    private FlagEncoder carEncoder = new CarFlagEncoder(5, 5, 10);
+    private final EncodingManager encodingManager = EncodingManager.create(carEncoder);
 
     Graph createGraph() {
         return new GraphBuilder(encodingManager).create();
@@ -48,37 +47,38 @@ Graph createGraph() {
     public void testExtract() {
         Graph g = createGraph();
         g.edge(1, 2, 10, true);
-        PathBidirRef pw = new PathBidirRef(g, new FastestWeighting(carEncoder));
-        EdgeExplorer explorer = g.createEdgeExplorer(carOutEdges);
-        EdgeIterator iter = explorer.setBaseNode(1);
-        iter.next();
-        pw.sptEntry = new SPTEntry(iter.getEdge(), 2, 0);
-        pw.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
-        pw.edgeTo = new SPTEntry(EdgeIterator.NO_EDGE, 2, 0);
-        Path p = pw.extract();
-        assertEquals(IntArrayList.from(new int[]{1, 2}), p.calcNodes());
+        PathBidirRef p = new PathBidirRef(g, new FastestWeighting(carEncoder));
+        p.sptEntry = new SPTEntry(0, 2, 0);
+        p.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
+        p.edgeTo = new SPTEntry(EdgeIterator.NO_EDGE, 2, 0);
+        p.extract();
+        assertEquals(IntArrayList.from(1, 2), p.calcNodes());
         assertEquals(10, p.getDistance(), 1e-4);
     }
 
     @Test
     public void testExtract2() {
+        // 1->2->3
         Graph g = createGraph();
         g.edge(1, 2, 10, false);
         g.edge(2, 3, 20, false);
-        EdgeExplorer explorer = g.createEdgeExplorer(carOutEdges);
-        EdgeIterator iter = explorer.setBaseNode(1);
-        iter.next();
-        PathBidirRef pw = new PathBidirRef(g, new FastestWeighting(carEncoder));
-        pw.sptEntry = new SPTEntry(iter.getEdge(), 2, 10);
-        pw.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
+        // add some turn costs at node 2 where fwd&bwd searches meet. these costs have to be included in the
+        // weight and the time of the path
+        TurnCostExtension turnCostExtension = (TurnCostExtension) g.getExtension();
+        turnCostExtension.addTurnInfo(0, 2, 1, carEncoder.getTurnFlags(false, 5));
 
-        explorer = g.createEdgeExplorer(DefaultEdgeFilter.inEdges(carEncoder));
-        iter = explorer.setBaseNode(3);
-        iter.next();
-        pw.edgeTo = new SPTEntry(iter.getEdge(), 2, 20);
-        pw.edgeTo.parent = new SPTEntry(EdgeIterator.NO_EDGE, 3, 0);
-        Path p = pw.extract();
-        assertEquals(IntArrayList.from(new int[]{1, 2, 3}), p.calcNodes());
+        PathBidirRef p = new PathBidirRef(g, new TurnWeighting(new FastestWeighting(carEncoder), turnCostExtension));
+        p.sptEntry = new SPTEntry(0, 2, 0.6);
+        p.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
+
+        p.edgeTo = new SPTEntry(1, 2, 1.2);
+        p.edgeTo.parent = new SPTEntry(EdgeIterator.NO_EDGE, 3, 0);
+        p.setWeight(5 + 1.8);
+
+        p.extract();
+        assertEquals(IntArrayList.from(1, 2, 3), p.calcNodes());
         assertEquals(30, p.getDistance(), 1e-4);
+        assertEquals(5 + 1.8, p.getWeight(), 1e-4);
+        assertEquals(5000 + 1800, p.getTime(), 1.e-6);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index 5010b7cd22..e31511b31b 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -162,9 +162,9 @@ void fillVirtualEdges(IntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode
                 super.fillVirtualEdges(node2Edge, towerNode, mainExpl);
                 // ignore nodes should include baseNode == 1
                 if (towerNode == 3)
-                    assertEquals("[3->4]", node2Edge.get(towerNode).toString());
+                    assertEquals("virtual edge: (invalid), all: [3->4]", node2Edge.get(towerNode).toString());
                 else if (towerNode == 1)
-                    assertEquals("[1->4, 1 1-0]", node2Edge.get(towerNode).toString());
+                    assertEquals("virtual edge: (invalid), all: [1->4, 1 1-0]", node2Edge.get(towerNode).toString());
                 else
                     throw new IllegalStateException("not allowed " + towerNode);
             }
@@ -760,4 +760,38 @@ public void testWayGeometry_pillar() {
         assertFalse(iter.next());
     }
 
+    @Test
+    public void testVirtualEdgeDistance() {
+        //   x
+        // -----
+        // |   |
+        // 0   1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0);
+        na.setNode(1, 0, 1);
+        // dummy node to make sure graph bounds are valid
+        na.setNode(2, 2, 2);
+        DistanceCalc distCalc = Helper.DIST_PLANE;
+        double dist = 0;
+        dist += distCalc.calcDist(0, 0, 1, 0);
+        dist += distCalc.calcDist(1, 0, 1, 1);
+        dist += distCalc.calcDist(1, 1, 0, 1);
+        g.edge(0, 1, dist, true).setWayGeometry(Helper.createPointList(1, 0, 1, 1));
+        LocationIndexTree index = new LocationIndexTree(g, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr = index.findClosest(1.01, 0.7, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Collections.singletonList(qr));
+        // the sum of the virtual edge distances adjacent to the virtual node should be equal to the distance
+        // of the real edge, so the 'distance' from 0 to 1 is the same no matter if we travel on the query graph or the
+        // real graph
+        EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(3);
+        double virtualEdgeDistanceSum = 0;
+        while (iter.next()) {
+            virtualEdgeDistanceSum += iter.getDistance();
+        }
+        double directDist = g.getEdgeIteratorState(0, 1).getDistance();
+        assertEquals(directDist, virtualEdgeDistanceSum, 1.e-3);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
new file mode 100644
index 0000000000..917f5a7715
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
@@ -0,0 +1,178 @@
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.PMap;
+import com.graphhopper.util.shapes.BBox;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class RandomCHRoutingTest {
+    private final TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private Directory dir;
+    private CarFlagEncoder encoder;
+    private Weighting weighting;
+    private GraphHopperStorage graph;
+    private LocationIndexTree locationIndex;
+    private CHGraph chGraph;
+
+    @Before
+    public void init() {
+        dir = new RAMDirectory();
+        encoder = new CarFlagEncoder();
+        EncodingManager em = EncodingManager.create(encoder);
+        weighting = new FastestWeighting(encoder);
+        graph = new GraphBuilder(em).setCHGraph(weighting).create();
+        chGraph = graph.getGraph(CHGraph.class);
+    }
+
+
+    /**
+     * Runs random routing queries on a random query/CH graph with random speeds and adding random virtual edges and
+     * nodes.
+     */
+    @Test
+    public void issues1574_1581_random() {
+        // you might have to keep this test running in an infinite loop for several minutes to find potential routing
+        // bugs (e.g. use intellij 'run until stop/failure').
+        int numNodes = 50;
+        long seed = System.nanoTime();
+        // for example these used to fail before fixing #1574 and/or #1581
+//        seed = 9348906923700L;
+//        seed = 9376976930825L;
+//        seed = 9436934744695L;
+//        seed = 10093639220394L;
+//        seed = 10785899964423L;
+
+        System.out.println("seed: " + seed);
+        Random rnd = new Random(seed);
+        buildRandomGraph(rnd, numNodes, 2.5, true, true, 0.9);
+        locationIndex = new LocationIndexTree(graph, dir);
+        locationIndex.prepareIndex();
+
+        graph.freeze();
+        PrepareContractionHierarchies pch = new PrepareContractionHierarchies(chGraph, weighting, traversalMode);
+        pch.doWork();
+
+        int numQueryGraph = 50;
+        for (int j = 0; j < numQueryGraph; j++) {
+            QueryGraph queryGraph = new QueryGraph(graph);
+            QueryGraph chQueryGraph = new QueryGraph(chGraph);
+            addVirtualNodesAndEdges(rnd, queryGraph, chQueryGraph);
+
+            int numQueries = 100;
+            int numPathsNotFound = 0;
+            for (int i = 0; i < numQueries; i++) {
+                assertEquals("queryGraph and chQueryGraph should have equal number of nodes", queryGraph.getNodes(), chQueryGraph.getNodes());
+                int from = rnd.nextInt(queryGraph.getNodes());
+                int to = rnd.nextInt(queryGraph.getNodes());
+                DijkstraBidirectionRef refAlgo = new DijkstraBidirectionRef(queryGraph, weighting, TraversalMode.NODE_BASED);
+                Path refPath = refAlgo.calcPath(from, to);
+                if (!refPath.isFound()) {
+                    numPathsNotFound++;
+                    continue;
+                }
+
+                RoutingAlgorithm algo = pch.createAlgo(chQueryGraph, AlgorithmOptions.start().hints(new PMap().put("stall_on_demand", true)).build());
+                Path path = algo.calcPath(from, to);
+                if (!path.isFound()) {
+                    fail("path not found for for " + from + "->" + to + ", expected weight: " + path.getWeight());
+                }
+
+                double weight = path.getWeight();
+                double refWeight = refPath.getWeight();
+                if (Math.abs(refWeight - weight) > 1) {
+                    fail("wrong weight: " + from + "->" + to + ", dijkstra: " + refWeight + " vs. ch: " + path.getWeight());
+                }
+            }
+            if (numPathsNotFound > 0.9 * numQueries) {
+                fail("Too many paths not found: " + numPathsNotFound + "/" + numQueries);
+            }
+        }
+    }
+
+    private void addVirtualNodesAndEdges(Random rnd, QueryGraph queryGraph, QueryGraph chQueryGraph) {
+        BBox bbox = graph.getBounds();
+        int numVirtualNodes = 20;
+        int count = 0;
+        List<QueryResult> qrs = new ArrayList<>(numVirtualNodes);
+        while (qrs.size() < numVirtualNodes) {
+            if (count > numVirtualNodes * 100) {
+                throw new IllegalArgumentException("Could not create enough virtual edges");
+            }
+            QueryResult qr = findQueryResult(rnd, bbox);
+            if (qr.getSnappedPosition().equals(QueryResult.Position.EDGE)) {
+                qrs.add(qr);
+            }
+            count++;
+        }
+        queryGraph.lookup(qrs);
+        chQueryGraph.lookup(qrs);
+    }
+
+    private QueryResult findQueryResult(Random rnd, BBox bbox) {
+        return locationIndex.findClosest(
+                randomDoubleInRange(rnd, bbox.minLat, bbox.maxLat),
+                randomDoubleInRange(rnd, bbox.minLon, bbox.maxLon),
+                EdgeFilter.ALL_EDGES
+        );
+    }
+
+    private double randomDoubleInRange(Random rnd, double min, double max) {
+        return min + rnd.nextDouble() * (max - min);
+    }
+
+    private void buildRandomGraph(Random random, int numNodes, double meanDegree, boolean allowLoops, boolean allowZeroDistance, double pBothDir) {
+        for (int i = 0; i < numNodes; ++i) {
+            double lat = 49.4 + (random.nextDouble() * 0.0001);
+            double lon = 9.7 + (random.nextDouble() * 0.0001);
+            graph.getNodeAccess().setNode(i, lat, lon);
+        }
+        double minDist = Double.MAX_VALUE;
+        double maxDist = Double.MIN_VALUE;
+        int numEdges = (int) (0.5 * meanDegree * numNodes);
+        for (int i = 0; i < numEdges; ++i) {
+            int from = random.nextInt(numNodes);
+            int to = random.nextInt(numNodes);
+            if (!allowLoops && from == to) {
+                continue;
+            }
+            double distance = GHUtility.getDistance(from, to, graph.getNodeAccess());
+            if (!allowZeroDistance) {
+                distance = Math.max(0.001, distance);
+            }
+            // add some random offset for most cases, but also allow duplicate edges with same weight
+            if (random.nextDouble() < 0.8)
+                distance += random.nextDouble() * distance * 0.01;
+            minDist = Math.min(minDist, distance);
+            maxDist = Math.max(maxDist, distance);
+            // using bidirectional edges will increase mean degree of graph above given value
+            boolean bothDirections = random.nextDouble() < pBothDir;
+            EdgeIteratorState edge = graph.edge(from, to, distance, bothDirections);
+            double fwdSpeed = 10 + random.nextDouble() * 120;
+            double bwdSpeed = 10 + random.nextDouble() * 120;
+            DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+            edge.set(speedEnc, fwdSpeed);
+            edge.setReverse(speedEnc, bwdSpeed);
+        }
+    }
+}
+
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
index 92b2463579..ee976e4451 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
@@ -692,7 +692,7 @@ public void testFindPath_random_compareWithDijkstra() {
         LOGGER.info("Seed used to generate graph: {}", seed);
         final Random rnd = new Random(seed);
         // for larger graphs preparation takes much longer the higher the degree is!
-        GHUtility.buildRandomGraph(graph, seed, 20, 3.0, true, true, 0.9);
+        GHUtility.buildRandomGraph(graph, seed, 20, 3.0, true, true, 0.9, 0.8);
         GHUtility.addRandomTurnCosts(graph, seed, encoder, maxCost, turnCostExtension);
         graph.freeze();
         List<Integer> contractionOrder = getRandomIntegerSequence(chGraph.getNodes(), rnd);
@@ -707,7 +707,7 @@ public void testFindPath_random_compareWithDijkstra() {
     public void testFindPath_heuristic_compareWithDijkstra() {
         long seed = System.nanoTime();
         LOGGER.info("Seed used to generate graph: {}", seed);
-        GHUtility.buildRandomGraph(graph, seed, 20, 3.0, true, true, 0.9);
+        GHUtility.buildRandomGraph(graph, seed, 20, 3.0, true, true, 0.9, 0.8);
         GHUtility.addRandomTurnCosts(graph, seed, encoder, maxCost, turnCostExtension);
         graph.freeze();
         automaticCompareCHWithDijkstra(100);
diff --git a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
index 2d37a290a1..8d09521584 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
@@ -383,6 +383,31 @@ public void testNodeContraction_shortcutWeightRounding() {
         assertEquals(dijkstraPath.getWeight(), chPath.getWeight(), 1.e-6);
     }
 
+    @Test
+    public void testNodeContraction_preventUnnecessaryShortcutWithLoop() {
+        // there should not be shortcuts where one of the skipped edges is a loop at the node to be contracted,
+        // see also #1581
+        CarFlagEncoder encoder = new CarFlagEncoder();
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        Weighting weighting = new FastestWeighting(encoder);
+        GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
+        CHGraph lg = graph.getGraph(CHGraph.class);
+        // 0 - 1 - 2 - 3
+        // o           o
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 3, 1, true);
+        graph.edge(0, 0, 1, true);
+        graph.edge(3, 3, 1, true);
+
+        graph.freeze();
+        setMaxLevelOnAllNodes(lg);
+        NodeContractor nodeContractor = createNodeContractor(lg, weighting);
+        nodeContractor.contractNode(0);
+        nodeContractor.contractNode(3);
+        checkNoShortcuts(lg);
+    }
+
     private void contractInOrder(int... nodeIds) {
         contractInOrder(lg, weighting, nodeIds);
     }
@@ -401,11 +426,15 @@ private void contractInOrder(CHGraph chGraph, Weighting weighting, int... nodeId
      * Queries the ch graph and checks if the graph's shortcuts match the given expected shortcuts.
      */
     private void checkShortcuts(Shortcut... expectedShortcuts) {
+        checkShortcuts(lg, expectedShortcuts);
+    }
+
+    private void checkShortcuts(CHGraph chGraph, Shortcut... expectedShortcuts) {
         Set<Shortcut> expected = setOf(expectedShortcuts);
         if (expected.size() != expectedShortcuts.length) {
             fail("was given duplicate shortcuts");
         }
-        AllCHEdgesIterator iter = lg.getAllEdges();
+        AllCHEdgesIterator iter = chGraph.getAllEdges();
         Set<Shortcut> given = new HashSet<>();
         while (iter.next()) {
             if (iter.isShortcut()) {
@@ -419,7 +448,11 @@ private void checkShortcuts(Shortcut... expectedShortcuts) {
     }
 
     private void checkNoShortcuts() {
-        checkShortcuts();
+        checkShortcuts(lg);
+    }
+
+    private void checkNoShortcuts(CHGraph chGraph) {
+        checkShortcuts(chGraph);
     }
 
     private Shortcut expectedShortcut(int baseNode, int adjNode, EdgeIteratorState edge1, EdgeIteratorState edge2,
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 39d988964d..15ebdc3798 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -19,21 +19,20 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.IntIndexedContainer;
-import com.graphhopper.routing.AlgorithmOptions;
-import com.graphhopper.routing.Dijkstra;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import org.junit.Before;
 import org.junit.Test;
 
 import java.util.*;
 
+import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static org.junit.Assert.*;
 
@@ -122,7 +121,11 @@ public static Graph initShortcutsGraph(Graph g) {
     }
 
     GraphHopperStorage createGHStorage() {
-        return new GraphBuilder(encodingManager).setCHGraph(weighting).create();
+        return createGHStorage(weighting);
+    }
+
+    GraphHopperStorage createGHStorage(Weighting w) {
+        return new GraphBuilder(encodingManager).setCHGraph(w).create();
     }
 
     GraphHopperStorage createExampleGraph() {
@@ -154,6 +157,7 @@ public void testReturnsCorrectWeighting() {
         GraphHopperStorage g = createGHStorage();
         CHGraph lg = g.getGraph(CHGraph.class);
         PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
+        prepare.doWork();
         assertSame(weighting, prepare.getWeighting());
     }
 
@@ -349,6 +353,7 @@ public void testUnpackingOrder() {
         CHGraph lg = g.getGraph(CHGraph.class);
         initUnpackingGraph(g, lg, weighting);
         PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
+        prepare.doWork();
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
@@ -363,6 +368,7 @@ public void testUnpackingOrder_Fastest() {
         initUnpackingGraph(g, lg, w);
 
         PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
+        prepare.doWork();
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
@@ -419,6 +425,108 @@ public int getNumNodes() {
         return new HashSet<>(Arrays.asList(values));
     }
 
+    @Test
+    public void testStallOnDemandViaVirtuaNode_issue1574() {
+        // this test reproduces the issue that appeared in issue1574 and the problem is very intricate
+        // the problem is a combination of all these things:
+        // * contraction hierarchies
+        // * stall-on-demand (without sod there is no problem, at least in this test)
+        // * shortcuts weight rounding
+        // * via nodes/virtual edges and the associated weight precision (without virtual nodes between source and target
+        //   there is no problem, but this can happen for via routes
+        // * the fact that the LevelEdgeFilter always accepts virtual nodes
+
+        // use fastest weighting in this test to be able to fine-tune some weights via the speed (see below)
+        Weighting fastestWeighting = new FastestWeighting(carEncoder);
+        final GraphHopperStorage g = createGHStorage(fastestWeighting);
+        CHGraph lg = g.getGraph(CHGraph.class);
+        // the following graph reproduces the issue. note that we will use the node ids as ch levels, so there will
+        // be a shortcuts from 1->3 and 2->3 (not the other way around, because of shortcut disconnections!)
+        // since the shortest path is strictly upward only the forward search runs here, this is also important!
+        // start 0 - 3 - x - 1 - 2
+        //             \         |
+        //               sc ---- 4 - 5 - 6 - 7 finish
+        g.edge(0, 3, 1, true);
+        EdgeIteratorState edge31 = g.edge(3, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        EdgeIteratorState edge24 = g.edge(2, 4, 1, true);
+        g.edge(4, 5, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(6, 7, 1, true);
+        updateDistancesFor(g, 0, 0.001, 0.0000);
+        updateDistancesFor(g, 3, 0.001, 0.0001);
+        updateDistancesFor(g, 1, 0.001, 0.0002);
+        updateDistancesFor(g, 2, 0.001, 0.0003);
+        updateDistancesFor(g, 4, 0.000, 0.0003);
+        updateDistancesFor(g, 5, 0.000, 0.0004);
+        updateDistancesFor(g, 6, 0.000, 0.0005);
+        updateDistancesFor(g, 7, 0.000, 0.0006);
+
+        // we use the speed to fine tune some weights:
+        // the weight of edge 3-1 must be such that node 2 gets stalled in the forward search via the incoming shortcut
+        // at node 2 coming from 3. this happens because due to the virtual node x between 3 and 1, the spt entries
+        // calculated on the query graph (using the virtual edges) use different floating point rounding / arithmetics.
+        edge31.set(carEncoder.getAverageSpeedEnc(), 22);
+
+        // just stalling node 2 due to the differently calculated weights for the virtual edges would be no problem, yet
+        // because the shortcut 3-4 still finds node 4. however node 4 might also get stalled via node 2. 'normally' this
+        // would not happen, because node 2 would not even be explored in the forward search, but because of the virtual
+        // node the strict upward search is modified and goes like 0-3-1-2 (i.e. it finds node 2).
+        // so no we fine tune the weight for 2-4 such that node 4 gets also stalled
+        edge24.setReverse(carEncoder.getAverageSpeedEnc(), 27.5);
+
+        // prepare ch, use node ids as levels
+        PrepareContractionHierarchies pch = createPrepareContractionHierarchies(g, lg, fastestWeighting);
+        pch.useFixedNodeOrdering(new NodeOrderingProvider() {
+            @Override
+            public int getNodeIdForLevel(int level) {
+                return level;
+            }
+
+            @Override
+            public int getNumNodes() {
+                return g.getNodes();
+            }
+        }).doWork();
+        assertEquals("there should be exactly two shortcuts (3->2) and (3->4)", 2, lg.getEdges() - lg.getOriginalEdges());
+
+        // insert virtual node and edges
+        QueryResult qr = new QueryResult(0.0001, 0.0015);
+        qr.setClosestEdge(edge31);
+        qr.setSnappedPosition(QueryResult.Position.EDGE);
+        qr.setClosestNode(8);
+        qr.setWayIndex(0);
+        qr.calcSnappedPoint(new DistanceCalc2D());
+        QueryGraph queryGraph = new QueryGraph(lg);
+        queryGraph.lookup(Collections.singletonList(qr));
+
+        // we make sure our weight fine tunings do what they are supposed to
+        double weight03 = getWeight(queryGraph, fastestWeighting, 0, 3);
+        double scWeight23 = weight03 + ((CHEdgeIteratorState) getEdge(lg, 2, 3)).getWeight();
+        double scWeight34 = weight03 + ((CHEdgeIteratorState) getEdge(lg, 3, 4)).getWeight();
+        double sptWeight2 = weight03 + getWeight(queryGraph, fastestWeighting, 3, 8) + getWeight(queryGraph, fastestWeighting, 8, 1) + getWeight(queryGraph, fastestWeighting, 1, 2);
+        double sptWeight4 = sptWeight2 + getWeight(queryGraph, fastestWeighting, 2, 4);
+        assertTrue("incoming shortcut weight 3->2 should be smaller than sptWeight at node 2 to make sure 2 gets stalled", scWeight23 < sptWeight2);
+        assertTrue("sptWeight at node 4 should be smaller than shortcut weight 3->4 to make sure node 4 gets stalled", sptWeight4 < scWeight34);
+
+        Path path = pch.createAlgo(queryGraph, AlgorithmOptions.start().build()).calcPath(0, 7);
+        assertEquals("wrong or no path found", IntArrayList.from(0, 3, 8, 1, 2, 4, 5, 6, 7), path.calcNodes());
+    }
+
+    private double getWeight(Graph graph, Weighting w, int from, int to) {
+        return w.calcWeight(getEdge(graph, from, to), false, -1);
+    }
+
+    private EdgeIteratorState getEdge(Graph graph, int from, int to) {
+        EdgeIterator iter = graph.createEdgeExplorer().setBaseNode(from);
+        while (iter.next()) {
+            if (iter.getAdjNode() == to) {
+                return iter;
+            }
+        }
+        throw new IllegalArgumentException("Could not find edge from: " + from + " to: " + to);
+    }
+
     @Test
     public void testCircleBug() {
         GraphHopperStorage g = createGHStorage();
@@ -556,7 +664,7 @@ public void testReusingNodeOrdering() {
         int numNodes = 5_000;
         int numQueries = 100;
         long seed = System.nanoTime();
-        GHUtility.buildRandomGraph(ghStorage, seed, numNodes, 1.3, false, false, 0.9);
+        GHUtility.buildRandomGraph(ghStorage, seed, numNodes, 1.3, false, false, 0.9, 0.8);
         ghStorage.freeze();
 
         // create CH for cars
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java
new file mode 100644
index 0000000000..b8c99fa668
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java
@@ -0,0 +1,62 @@
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.graphhopper.util.GHUtility.getEdge;
+import static org.junit.Assert.assertEquals;
+
+public class TurnWeightingTest {
+
+    private Graph graph;
+    private FlagEncoder encoder;
+    private EncodingManager encodingManager;
+    private Weighting weighting;
+    private TurnCostExtension turnCostExt;
+
+    @Before
+    public void setup() {
+        encoder = new CarFlagEncoder(5, 5, 10);
+        encodingManager = EncodingManager.create(encoder);
+        graph = new GraphBuilder(encodingManager).create();
+        weighting = new FastestWeighting(encoder);
+        turnCostExt = (TurnCostExtension) graph.getExtension();
+    }
+
+    @Test
+    public void calcWeightAndTime_withTurnCosts() {
+        graph.edge(0, 1, 100, true);
+        EdgeIteratorState edge = graph.edge(1, 2, 100, true);
+        // turn costs are given in seconds
+        addTurnCost(0, 1, 2, 5);
+        TurnWeighting turnWeighting = new TurnWeighting(weighting, turnCostExt);
+        assertEquals(6 + 5, turnWeighting.calcWeight(edge, false, 0), 1.e-6);
+        assertEquals(6000 + 5000, turnWeighting.calcMillis(edge, false, 0), 1.e-6);
+    }
+
+    @Test
+    public void calcWeightAndTime_withTurnCosts_shortest() {
+        graph.edge(0, 1, 100, true);
+        EdgeIteratorState edge = graph.edge(1, 2, 100, true);
+        // turn costs are given in seconds
+        addTurnCost(0, 1, 2, 5);
+        TurnWeighting turnWeighting = new TurnWeighting(new ShortestWeighting(encoder), turnCostExt);
+        // todo: for the shortest weighting turn costs cannot be interpreted as seconds ? at least when they are added
+        // to the weight ? how much should they contribute ?
+//        assertEquals(105, turnWeighting.calcWeight(edge, false, 0), 1.e-6);
+        assertEquals(6000 + 5000, turnWeighting.calcMillis(edge, false, 0), 1.e-6);
+    }
+
+    private void addTurnCost(int from, int via, int to, double turnCost) {
+        long turnFlags = encoder.getTurnFlags(false, turnCost);
+        turnCostExt.addTurnInfo(getEdge(graph, from, via).getEdge(), via, getEdge(graph, via, to).getEdge(), turnFlags);
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java b/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
index 35926b18c4..3feea2b09b 100644
--- a/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
+++ b/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
@@ -3,11 +3,15 @@
 import com.graphhopper.jackson.Jackson;
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.Path;
 import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.RAMDirectory;
@@ -76,4 +80,56 @@ public void testApplyChanges() throws IOException {
         assertTrue(newSpeed < defaultSpeed);
         assertFalse(GHUtility.getEdge(graph, 3, 4).get(accessEnc));
     }
+
+    @Test
+    public void testRevertChanges() throws IOException {
+        // 0-1-2
+        // | |
+        // 3-4
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(3, 4, 1, true);
+        graph.edge(0, 3, 1, true);
+        graph.edge(1, 4, 1, true);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.01, 0.00);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.01, 0.02);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 0.00, 0.00);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, 0.00, 0.01);
+        LocationIndex locationIndex = new LocationIndexTree(graph, new RAMDirectory()).prepareIndex();
+
+        FlagEncoder encoder = encodingManager.getEncoder("car");
+        Path p = new Dijkstra(graph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(0, 2);
+        assertTrue(p.isFound());
+
+        double distanceBeforeBlock = p.getDistance();
+        assertEquals(2223, distanceBeforeBlock, 1);
+
+        // Block the edge 0-1
+        Reader reader = new InputStreamReader(getClass().getResourceAsStream("overlaydata2.json"), Helper.UTF_CS);
+        ChangeGraphHelper instance = new ChangeGraphHelper(graph, locationIndex);
+        JsonFeatureCollection collection = Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class);
+        long updates = instance.applyChanges(encodingManager, collection.getFeatures());
+        assertEquals(1, updates);
+
+        p = new Dijkstra(graph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(0, 2);
+        assertTrue(p.isFound());
+
+        double distanceAfterBlock = p.getDistance();
+        assertEquals(4447, distanceAfterBlock, 1);
+
+        // Unblock the edge 0-1
+        reader = new InputStreamReader(getClass().getResourceAsStream("overlaydata3.json"), Helper.UTF_CS);
+        collection = Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class);
+        updates = instance.applyChanges(encodingManager, collection.getFeatures());
+        assertEquals(1, updates);
+
+        p = new Dijkstra(graph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(0, 2);
+        assertTrue(p.isFound());
+
+        assertEquals(distanceBeforeBlock, p.getDistance(), 1);
+    }
 }
diff --git a/core/src/test/resources/com/graphhopper/storage/change/overlaydata2.json b/core/src/test/resources/com/graphhopper/storage/change/overlaydata2.json
new file mode 100644
index 0000000000..72253eba68
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/storage/change/overlaydata2.json
@@ -0,0 +1,14 @@
+{
+    "type": "FeatureCollection",
+    "features": [{
+        "type": "Feature",
+        "geometry": {
+            "type": "Point",
+            "coordinates": [0.005, 0.01]
+        },
+        "properties": {
+            "vehicles": ["car"],
+            "access": false
+        }
+    }]
+}
\ No newline at end of file
diff --git a/core/src/test/resources/com/graphhopper/storage/change/overlaydata3.json b/core/src/test/resources/com/graphhopper/storage/change/overlaydata3.json
new file mode 100644
index 0000000000..b1d42babec
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/storage/change/overlaydata3.json
@@ -0,0 +1,14 @@
+{
+    "type": "FeatureCollection",
+    "features": [{
+        "type": "Feature",
+        "geometry": {
+            "type": "Point",
+            "coordinates": [0.005, 0.01]
+        },
+        "properties": {
+            "vehicles": ["car"],
+            "access": true
+        }
+    }]
+}
\ No newline at end of file
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 18fcd2f7ff..2d6cdaa513 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -95,7 +95,7 @@ public GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder
             @Override
             public boolean tryAdvance(Consumer<? super EdgeIteratorState> action) {
                 if (edgeIterator.next()) {
-                    GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator);
+                    GtfsStorage.EdgeType edgeType = edgeIterator.get(flagEncoder.getTypeEnc());
 
                     // Optimization (around 20% in Swiss network):
                     // Only use the (single) least-wait-time edge to enter the
@@ -127,7 +127,7 @@ private EdgeIteratorState findEnterEdge() {
     }
 
     long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
-        GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge);
+        GtfsStorage.EdgeType edgeType = edge.get(flagEncoder.getTypeEnc());
         switch (edgeType) {
             case HIGHWAY:
                 return (long) (accessEgressWeighting.calcMillis(edge, reverse, -1) * (5.0 / walkSpeedKmH));
@@ -176,7 +176,7 @@ private long millisOnTravelDay(EdgeIteratorState edge, long instant) {
     }
 
     private boolean isValidOn(EdgeIteratorState edge, long instant) {
-        GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge);
+        GtfsStorage.EdgeType edgeType = edge.get(flagEncoder.getTypeEnc());
         if (edgeType == GtfsStorage.EdgeType.BOARD || edgeType == GtfsStorage.EdgeType.ALIGHT) {
             final int validityId = edge.get(flagEncoder.getValidityIdEnc());
             final GtfsStorage.Validity validity = realtimeFeed.getValidity(validityId);
@@ -229,7 +229,7 @@ public Graph getGraph() {
 
         @Override
         public boolean test(EdgeIteratorState edgeIterator) {
-            final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator);
+            final GtfsStorage.EdgeType edgeType = edgeIterator.get(flagEncoder.getTypeEnc());
             if (edgeType == GtfsStorage.EdgeType.HIGHWAY) {
                 if (reverse) {
                     return edgeIterator.getReverse(accessEgressWeighting.getFlagEncoder().getAccessEnc());
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 620fa6a4e9..9f497b0d8b 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -173,8 +173,8 @@ private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
             if (!source.isValid()) {
                 throw new PointNotFoundException("Cannot find point: " + point, indexForErrorMessage);
             }
-            if (flagEncoder.getEdgeType(source.getClosestEdge()) != GtfsStorage.EdgeType.HIGHWAY) {
-                throw new RuntimeException(flagEncoder.getEdgeType(source.getClosestEdge()).name());
+            if (source.getClosestEdge().get(flagEncoder.getTypeEnc()) != GtfsStorage.EdgeType.HIGHWAY) {
+                throw new RuntimeException(source.getClosestEdge().get(flagEncoder.getTypeEnc()).name());
             }
             return source;
         }
@@ -206,7 +206,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                 if (label.adjNode == startNode) {
                     stationLabels.add(label);
                     break;
-                } else if (label.edge != -1 && flagEncoder.getEdgeType(accessEgressGraphExplorer.getEdgeIteratorState(label.edge, label.parent.adjNode)) == edgeType) {
+                } else if (label.edge != -1 && accessEgressGraphExplorer.getEdgeIteratorState(label.edge, label.parent.adjNode).get(flagEncoder.getTypeEnc()) == edgeType) {
                     stationLabels.add(label);
                 }
             }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 82aa62c79f..2b0ce9a2ee 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -455,7 +455,7 @@ private void patchArrivalTimeline(ZoneId zoneId, NavigableMap<Integer, Integer>
         }
         EdgeIterator edge = graph.getBaseGraph().createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder)).setBaseNode(platformEnterNode);
         while (edge.next()) {
-            if (encoder.getEdgeType(edge) == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
+            if (edge.get(encoder.getTypeEnc()) == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
                 result.put(edge.get(timeEnc), edge.getAdjNode());
             }
         }
@@ -473,7 +473,7 @@ private int findPlatformNode(int stationNode, GtfsStorageI.PlatformDescriptor pl
         }
         EdgeIterator i = graph.getBaseGraph().createEdgeExplorer(filter).setBaseNode(stationNode);
         while (i.next()) {
-            if (encoder.getEdgeType(i) == edgeType) {
+            if (i.get(encoder.getTypeEnc()) == edgeType) {
                 if (platformDescriptor.equals(gtfsStorage.getRoutes().get(i.getEdge()))) {
                     return i.getAdjNode();
                 }
@@ -605,12 +605,12 @@ private void insertInboundTransfers(String fromStopId, String from_route_id, int
         int stationNode = gtfsStorage.getStationNodes().get(fromStopId);
         EdgeIterator i = graph.createEdgeExplorer().setBaseNode(stationNode);
         while (i.next()) {
-            if (encoder.getEdgeType(i) == GtfsStorage.EdgeType.EXIT_PT) {
+            if (i.get(encoder.getTypeEnc()) == GtfsStorage.EdgeType.EXIT_PT) {
                 GtfsStorageI.PlatformDescriptor routeId = gtfsStorage.getRoutes().get(i.getEdge());
                 if (from_route_id == null || GtfsStorageI.PlatformDescriptor.route(from_route_id).equals(routeId)) {
                     EdgeIterator j = graph.createEdgeExplorer().setBaseNode(i.getAdjNode());
                     while (j.next()) {
-                        if (encoder.getEdgeType(j) == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
+                        if (j.get(encoder.getTypeEnc()) == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
                             int arrivalTime = j.get(timeEnc);
                             SortedMap<Integer, Integer> tailSet = toStopTimelineNode.tailMap(arrivalTime + minimumTransferTime);
                             if (!tailSet.isEmpty()) {
@@ -630,14 +630,14 @@ private void insertOutboundTransfers(String toStopId, String toRouteId, int mini
         int stationNode = gtfsStorage.getStationNodes().get(toStopId);
         EdgeIterator i = graph.getBaseGraph().createEdgeExplorer().setBaseNode(stationNode);
         while (i.next()) {
-            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i);
+            GtfsStorage.EdgeType edgeType = i.get(encoder.getTypeEnc());
             if (edgeType == GtfsStorage.EdgeType.ENTER_PT) {
                 GtfsStorageI.PlatformDescriptor routeId = gtfsStorage.getRoutes().get(i.getEdge());
                 if (toRouteId == null || routeId instanceof GtfsStorageI.RouteTypePlatform || GtfsStorageI.PlatformDescriptor.route(toRouteId).equals(routeId)) {
                     fromStopTimelineNodes.forEach((time, e) -> {
                         EdgeIterator j = graph.getBaseGraph().createEdgeExplorer().setBaseNode(i.getAdjNode());
                         while (j.next()) {
-                            GtfsStorage.EdgeType edgeType2 = encoder.getEdgeType(j);
+                            GtfsStorage.EdgeType edgeType2 = j.get(encoder.getTypeEnc());
                             if (edgeType2 == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
                                 int departureTime = j.get(timeEnc);
                                 if (departureTime < time + minimumTransferTime) {
@@ -663,7 +663,7 @@ private String getRouteName(GTFSFeed feed, Trip trip) {
 
     private void setEdgeTypeAndClearDistance(EdgeIteratorState edge, GtfsStorage.EdgeType edgeType) {
         edge.setDistance(0.0);
-        encoder.setEdgeType(edge, edgeType);
+        edge.set(encoder.getTypeEnc(), edgeType);
     }
 
     private BitSet getValidOn(BitSet validOnDay, int dayShift) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index f78f110ec5..03d92d02c8 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.reader.gtfs;
 
-import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
 
 import java.time.Instant;
@@ -141,7 +140,7 @@ public Transition next() {
     }
 
     private static EdgeLabel getEdgeLabel(EdgeIteratorState edgeIteratorState, PtFlagEncoder flagEncoder) {
-        return new EdgeLabel(edgeIteratorState, flagEncoder.getEdgeType(edgeIteratorState), edgeIteratorState.get(flagEncoder.getValidityIdEnc()),
+        return new EdgeLabel(edgeIteratorState, edgeIteratorState.get(flagEncoder.getTypeEnc()), edgeIteratorState.get(flagEncoder.getValidityIdEnc()),
                 edgeIteratorState.get(flagEncoder.getTransfersEnc()), edgeIteratorState.getDistance());
     }
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index b80065d48f..869e42c5fc 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -150,7 +150,7 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                 action.accept(label);
                 final IntEncodedValue validityEnc = flagEncoder.getValidityIdEnc();
                 explorer.exploreEdgesAround(label).forEach(edge -> {
-                    GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge);
+                    GtfsStorage.EdgeType edgeType = edge.get(flagEncoder.getTypeEnc());
                     if (edgeType == GtfsStorage.EdgeType.ENTER_PT && reverse && ptOnly) return;
                     if (edgeType == GtfsStorage.EdgeType.EXIT_PT && !reverse && ptOnly) return;
                     if ((edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT) && (blockedRouteTypes & (1 << edge.get(validityEnc))) != 0)
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
index 5ddcc4151f..4b5602fcfa 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
@@ -21,6 +21,7 @@
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
 import com.graphhopper.routing.profiles.IntEncodedValue;
 import com.graphhopper.routing.profiles.SimpleIntEncodedValue;
 import com.graphhopper.routing.util.AbstractFlagEncoder;
@@ -35,7 +36,7 @@
     private IntEncodedValue timeEnc;
     private IntEncodedValue transfersEnc;
     private IntEncodedValue validityIdEnc;
-    private IntEncodedValue typeEnc;
+    private EnumEncodedValue<GtfsStorage.EdgeType> typeEnc;
 
     public PtFlagEncoder() {
         super(0, 1, 0);
@@ -48,7 +49,7 @@ public void createEncodedValues(List<EncodedValue> list, String prefix, int inde
 
         list.add(validityIdEnc = new SimpleIntEncodedValue(prefix + "validity_id", 20, false));
         list.add(transfersEnc = new SimpleIntEncodedValue(prefix + "transfers", 1, false));
-        list.add(typeEnc = new SimpleIntEncodedValue(prefix + "type", 4, false));
+        list.add(typeEnc = new EnumEncodedValue<>(prefix + "type", GtfsStorage.EdgeType.class));
         list.add(timeEnc = new SimpleIntEncodedValue(prefix + "time", 17, false));
     }
 
@@ -79,12 +80,8 @@ public IntEncodedValue getValidityIdEnc() {
         return validityIdEnc;
     }
 
-    GtfsStorage.EdgeType getEdgeType(EdgeIteratorState edge) {
-        return GtfsStorage.EdgeType.values()[edge.get(typeEnc)];
-    }
-
-    void setEdgeType(EdgeIteratorState edge, GtfsStorage.EdgeType edgeType) {
-        edge.set(typeEnc, edgeType.ordinal());
+    public EnumEncodedValue<GtfsStorage.EdgeType> getTypeEnc() {
+        return typeEnc;
     }
 
     public String toString() {
diff --git a/web/src/main/resources/assets/index.html b/web/src/main/resources/assets/index.html
index 2d1278ee99..1e388fd05d 100644
--- a/web/src/main/resources/assets/index.html
+++ b/web/src/main/resources/assets/index.html
@@ -110,28 +110,25 @@
 </div>
 <div id="map">
 </div>
-<!-- Piwik -->
-<script type="text/javascript">
-            PIWIK = false;
-            if (PIWIK) {
-                var _paq = _paq || [];
-                _paq.push(['trackPageView']);
-                _paq.push(['enableLinkTracking']);
-                (function () {
-                    var url = "https://graphhopper.com/piwik/";
-                    _paq.push(['setTrackerUrl', url + 'piwik.php']);
-                    _paq.push(['setSiteId', 1]);
-                    var d = document, g = d.createElement('script'), s = d.getElementsByTagName('script')[0];
-                    g.type = 'text/javascript';
-                    g.defer = true;
-                    g.async = true;
-                    g.src = url + 'piwik.js';
-                    s.parentNode.insertBefore(g, s);
-                })();
-            }
 
+<!-- Matomo -->
+<script type="text/javascript">
+        PIWIK = false;
+        if (PIWIK) {
+          var _paq = window._paq || [];
+          /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
+          _paq.push(['trackPageView']);
+          _paq.push(['enableLinkTracking']);
+          (function() {
+            var u="//matomo.graphhopper.com/";
+            _paq.push(['setTrackerUrl', u+'matomo.php']);
+            _paq.push(['setSiteId', '1']);
+            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
+            g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
+          })();
+        }
 </script>
-<noscript><p><img src="https://graphhopper.com/piwik/piwik.php?idsite=1" style="border:0;" alt=""/></p></noscript>
-<!-- End Piwik Code -->
+<noscript><p><img src="https://matomo.graphhopper.com/matomo.php?idsite=1&amp;rec=1" style="border:0;" alt=""/></p></noscript>
+<!-- End Matomo Code -->
 </body>
 </html>
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceIssue1574Test.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceIssue1574Test.java
new file mode 100644
index 0000000000..828733d97f
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceIssue1574Test.java
@@ -0,0 +1,74 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http.resources;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.graphhopper.http.GraphHopperApplication;
+import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import io.dropwizard.testing.junit.DropwizardAppRule;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+import javax.ws.rs.core.Response;
+import java.io.File;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+/**
+ * @author Peter Karich
+ */
+public class RouteResourceIssue1574Test {
+    private static final String DIR = "./target/andorra-1574-gh/";
+
+    private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
+
+    static {
+        // this is the reason we put this test into an extra file: we can only reproduce the bug of issue 1574 by increasing the one-way-network size
+        config.getGraphHopperConfiguration().merge(new CmdArgs().
+                put("graph.flag_encoders", "car").
+                put("prepare.ch.weightings", "fastest").
+                put("prepare.min_network_size", "0").
+                put("prepare.min_one_way_network_size", "12").
+                put("datareader.file", "../core/files/andorra.osm.pbf").
+                put("graph.location", DIR));
+    }
+
+    @ClassRule
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule<>(GraphHopperApplication.class, config);
+
+    @BeforeClass
+    @AfterClass
+    public static void cleanUp() {
+        Helper.removeDir(new File(DIR));
+    }
+
+    @Test
+    public void testStallOnDemandBug_issue1574() {
+        final Response response = app.client().target("http://localhost:8080/route?point=42.486984,1.493152&point=42.481863,1.491297&point=42.49697,1.501265&&vehicle=car&weighting=fastest&stall_on_demand=true").request().buildGet().invoke();
+        JsonNode json = response.readEntity(JsonNode.class);
+        assertFalse("there should be no error, but: " + json.get("message"), json.has("message"));
+        System.out.println(json);
+        assertEquals(200, response.getStatus());
+    }
+
+}
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
index 3ad37ae96e..72e831b3cf 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
@@ -32,6 +32,7 @@
 import com.graphhopper.util.shapes.GHPoint;
 import io.dropwizard.testing.junit.DropwizardAppRule;
 import org.junit.AfterClass;
+import org.junit.BeforeClass;
 import org.junit.ClassRule;
 import org.junit.Test;
 
@@ -62,9 +63,9 @@
     }
 
     @ClassRule
-    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule(
-            GraphHopperApplication.class, config);
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule<>(GraphHopperApplication.class, config);
 
+    @BeforeClass
     @AfterClass
     public static void cleanUp() {
         Helper.removeDir(new File(DIR));
