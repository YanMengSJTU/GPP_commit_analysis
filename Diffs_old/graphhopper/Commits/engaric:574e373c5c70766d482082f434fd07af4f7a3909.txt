diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
index bec4d008bd..30166843e3 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
@@ -21,10 +21,10 @@ public void getRoute(String pointA, String pointB, String routeType)
 			throws InterruptedException {
 
 		if (routeType.equalsIgnoreCase("car"))
-
+//added ITN url
 			graphUiUtil = new GraphHopperUIUtil(
 					IntegrationTestProperties
-							.getTestProperty("graphHopperWebUrl"));
+							.getTestProperty("itngraphHopperWebUrl"));
 		else
 			graphUiUtil = new GraphHopperUIUtil(
 					IntegrationTestProperties
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
index 4090654750..b2172bed83 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
@@ -155,7 +155,7 @@ public void verifyInstructionThroughUI(String routeStepNumber,
 				.xpath("//*[@id='instructions']/tbody/tr[*]/td[2]"));
 		WAY_POINTS.get(Integer.parseInt(routeStepNumber) - 1).click();
 
-		checkTableRowIgnoreCase(INSTRUCTIONS, Integer.parseInt(this.routeStepNumber),
+		checkTableRow(INSTRUCTIONS, Integer.parseInt(this.routeStepNumber),
 				stepInstruction);
 
 	}
diff --git a/acceptancetesting/src/test/cucumber/DPNRouting.feature b/acceptancetesting/src/test/cucumber/DPNRouting.feature
index db7f102ab7..0e0ab62ce5 100644
--- a/acceptancetesting/src/test/cucumber/DPNRouting.feature
+++ b/acceptancetesting/src/test/cucumber/DPNRouting.feature
@@ -8,7 +8,7 @@ Feature: Verify a route from A to B
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints on the route map:
       | wayPointIndex | waypointco        | waypointdesc            | azimuth | direction | time  | distance |
-      | 4             | 53.1356,-1.820891 | continue onto Mill Lane | 78      | E         | 23165 | 32.175   |
+      | 4             | 53.1356,-1.820891 | Continue onto Mill Lane | 78      | E         | 23165 | 32.175   |
 
     Examples: 
       | pointA              | pointB             | routetype |
@@ -19,8 +19,8 @@ Feature: Verify a route from A to B
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints on the route map:
       | wayPointIndex | waypointco          | waypointdesc                          | azimuth | direction | time   | distance |
-      | 5             | 53.197269,-1.608797 | continue onto Chatsworth Road         | 181     | S         | 670049 | 930.629  |
-      | 6             | 53.189535,-1.613492 | turn slight left onto Dale Road North | 141     | SE        | 312088 | 433.456  |
+      | 5             | 53.197269,-1.608797 | Continue onto Chatsworth Road         | 181     | S         | 670049 | 930.629  |
+      | 6             | 53.189535,-1.613492 | Turn slight left onto Dale Road North | 141     | SE        | 312088 | 433.456  |
 
     Examples: 
       | pointA              | pointB              | routetype |
@@ -113,3 +113,14 @@ Feature: Verify a route from A to B
     Examples: 
       | pointA              | pointB              | routetype |
       | 53.142876,-1.642599 | 53.163897,-1.714249 | foot      |
+
+  @Routing
+  Scenario Outline: Verify  Road Names on a Walking Route  (Cardlemere Lane)
+    Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
+    Then I should be able to verify the waypoints on the route map:
+      | wayPointIndex | waypointco          | waypointdesc                   | azimuth | direction | time   | distance |
+      | 4             | 53.129383,-1.754591 | Turn left onto Cardlemere Lane | 115     | SE        | 581179 | 807.194  |
+
+    Examples: 
+      | pointA              | pointB             | routetype |
+      | 53.114295,-1.762789 | 53.086961,-1.69626 | foot      |
diff --git a/acceptancetesting/src/test/cucumber/Routing-Exeter.feature b/acceptancetesting/src/test/cucumber/Routing-Exeter.feature
index cdf3f40677..1eb76a7f18 100644
--- a/acceptancetesting/src/test/cucumber/Routing-Exeter.feature
+++ b/acceptancetesting/src/test/cucumber/Routing-Exeter.feature
@@ -41,7 +41,7 @@ Feature: Verify a route from A to B
 
   @Routing
   Scenario Outline: Verify  one Way  Restrictions (Except Buses) on a Route (SIDWELL STREET-Exeter)
-    Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
+    Given I request a route between "<pointA>" and "webDriverHubUrl=http://ND26185.ordsvy.gov.uk:5555/wd/hub<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints on the route map:
       | wayPointIndex | waypointco         | waypointdesc                    | azimuth | direction | time | distance |
       | 4             | 50.726689,-3.52712 | Turn left onto LONGBROOK STREET | 196     | S         | 8057 | 78.339   |
@@ -61,7 +61,7 @@ Feature: Verify a route from A to B
       | pointA              | pointB             | routetype |
       | 50.720492,-3.535221 | 50.718641,-3.53476 | car       |
 
-  @Routing @KnownIssue
+  @KnownIssue
   Scenario Outline: Verify  one Way  Restrictions  on a Route (Exeter WSPIP-98)
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints not on the route map:
@@ -140,7 +140,7 @@ Feature: Verify a route from A to B
       | pointA             | pointB             | routetype |
       | 50.72148,-3.532485 | 50.721888,-3.53182 | car       |
 
-  @Routing @KnownIssue
+  @KnownIssue
   Scenario Outline: Verify No  Turn Restrictions(Except Bus)  on a Route (BELGROVE ROAD -Exeter ROUTE-67)
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints not on the route map:
@@ -174,6 +174,7 @@ Feature: Verify a route from A to B
       | pointA              | pointB              | routetype |
       | 50.724777,-3.520811 | 50.724394,-3.520953 | car       |
 
+  @Routing
   Scenario Outline: Verify  Mandatory Turn at Exeter area(COLLEGE ROAD)
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints on the route map:
@@ -288,6 +289,7 @@ Feature: Verify a route from A to B
       | 50.7244,-3.535817 | 50.723705,-3.534493 | car       |
 
   #Private Road
+  @Routing
   Scenario Outline: Verify  a Private Road (Publicly Accessible) on a Route  (PERRY ROAD)
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints on the route map:
@@ -298,6 +300,7 @@ Feature: Verify a route from A to B
       | pointA              | pointB              | routetype |
       | 50.732296,-3.535372 | 50.733538,-3.537462 | car       |
 
+  @Routing
   Scenario Outline: Verify a  Private Road (Publicly Accessible) on a Route (QUEEN STREET)
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints on the route map:
@@ -308,6 +311,7 @@ Feature: Verify a route from A to B
       | pointA              | pointB              | routetype |
       | 50.727003,-3.535041 | 50.727023,-3.533083 | car       |
 
+  @Routing
   Scenario Outline: Verify a PrivateRoad -Restricted Access(WESTERN WAY)
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints on the route map:
@@ -318,6 +322,7 @@ Feature: Verify a route from A to B
       | pointA              | pointB             | routetype |
       | 50.725876,-3.521801 | 50.72619,-3.521541 | car       |
 
+  @Routing
   Scenario Outline: Verify a Private Road - Restricted Access (Denmark Road-Exeter)
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the trackPoints not on the route map:
diff --git a/acceptancetesting/src/test/cucumber/routing.feature b/acceptancetesting/src/test/cucumber/routing.feature
index ef3a937563..aeeee475f9 100644
--- a/acceptancetesting/src/test/cucumber/routing.feature
+++ b/acceptancetesting/src/test/cucumber/routing.feature
@@ -1,7 +1,7 @@
 Feature: Verify a route from A to B
-    As a user
-    I want to get a route from location A to location B using the routing service
-    And route should be the fastest route and contain the waypoints,restrictions,time and other instructions
+   As a user
+   I want to get a route from location A to location B using the routing service
+   And route should be the fastest route and contain the waypoints,restrictions,time and other instructions
 
   @Routing
   Scenario Outline: Verify  waypoints on a Route
@@ -111,7 +111,7 @@ Feature: Verify a route from A to B
       | pointA              | pointB              | routetype |
       | 52.446564,-1.930268 | 52.446744,-1.929469 | car       |
 
-  @Routing @KnownIssues
+  @KnownIssues
   Scenario Outline: Verify  No Turn Restrictions  on a Route (Birmingham Bristol Road WSPIP-83)
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the trackPoints not on the route map:
@@ -144,6 +144,7 @@ Feature: Verify a route from A to B
       | pointA             | pointB             | routetype |
       | 50.91525,-1.318761 | 50.92045,-1.316021 | car       |
 
+ 
   @Routing
   Scenario Outline: Verify  No Turn   (WSPIP-76:Eastley- TWYFORD ROAD )
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
@@ -162,6 +163,7 @@ Feature: Verify a route from A to B
       | wayPointIndex | waypointco          | waypointdesc                              | azimuth | direction | time | distance |
       | 2             | 50.969817,-1.350504 | Turn slight left onto STATION HILL (A335) | 180     | S         | 2932 | 44.811   |
 
+
     Examples: 
       | pointA              | pointB             | routetype |
       | 50.970024,-1.350267 | 50.97008,-1.350521 | car       |
@@ -177,7 +179,7 @@ Feature: Verify a route from A to B
       | pointA             | pointB              | routetype |
       | 51.46882,-0.358687 | 51.469454,-0.357831 | car       |
 
-  @Routing @KnownIssues
+  @KnownIssues
   Scenario Outline: Verify  No Turns with Exceptions(Vehicle Type:Bus)   (High Street-Hounslow)
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the trackPoints not on the route map:
diff --git a/acceptancetesting/src/test/java/uk/co/ordnancesurvey/routing/CucumberRunner.java b/acceptancetesting/src/test/java/uk/co/ordnancesurvey/routing/CucumberRunner.java
index 546569f2c1..d8e35ebe21 100644
--- a/acceptancetesting/src/test/java/uk/co/ordnancesurvey/routing/CucumberRunner.java
+++ b/acceptancetesting/src/test/java/uk/co/ordnancesurvey/routing/CucumberRunner.java
@@ -8,10 +8,9 @@
 
 @RunWith(Cucumber.class)
 @Category(IntegrationTestProperties.class)
-@Cucumber.Options(format = { "html:target/cucumber-reports/html", "json:target/cucumber-reports/cucumber.json" }, glue="uk.co.ordnancesurvey.routing",features = {"src/test/cucumber/Routing-Exeter.feature","src/test/cucumber/DPNRouting.feature"}, tags = { "~@RegressionLiveDataTests","@Routing"})
+@Cucumber.Options(format = { "html:target/cucumber-reports/html", "json:target/cucumber-reports/cucumber.json" }, glue="uk.co.ordnancesurvey.Routing-Exeter",features = {"src/test/cucumber/Routing-Exeter.feature"}, tags = { "~@RegressionLiveDataTests","@Routing"})
 public class CucumberRunner {
-	
-    
+	    
    
 
 }
diff --git a/acceptancetesting/src/test/resources/test-ci.properties b/acceptancetesting/src/test/resources/test-ci.properties
index b72d9e2e08..4cd1fe8705 100644
--- a/acceptancetesting/src/test/resources/test-ci.properties
+++ b/acceptancetesting/src/test/resources/test-ci.properties
@@ -1,4 +1,8 @@
-graphHopperWebUrl=http://os-gh-dev.elasticbeanstalk.com/
+# Revised Exeter data set
+iteGraphHopperWebUrl=http://os-gh-ite.elasticbeanstalk.com/
+# Full UK ITN data set
+itnGraphHopperWebUrl=http://os-graphhopper.elasticbeanstalk.com/
+# DPN data set
 DPNgraphHopperWebUrl=http://dpn-env.elasticbeanstalk.com/
 webDriverHubUrl=http://ND28350.ordsvy.gov.uk:5555/wd/hub
 #testON=Web,Service  // Default both
diff --git a/acceptancetesting/src/test/resources/test.properties b/acceptancetesting/src/test/resources/test.properties
index 76a12b7057..e888ca29e7 100644
--- a/acceptancetesting/src/test/resources/test.properties
+++ b/acceptancetesting/src/test/resources/test.properties
@@ -1,10 +1,14 @@
-graphHopperWebUrl=http://os-gh-ite.elasticbeanstalk.com/
+# Revised Exeter data set
+iteGraphHopperWebUrl=http://os-gh-ite.elasticbeanstalk.com/
+# Full UK ITN data set
+itnGraphHopperWebUrl=http://os-graphhopper.elasticbeanstalk.com/
+# DPN data set
 DPNgraphHopperWebUrl=http://dpn-env.elasticbeanstalk.com/
 #webDriverHubUrl=http://ND28350.ordsvy.gov.uk:5555/wd/hub
-webDriverHubUrl=http://ND27983.ordsvy.gov.uk:5555/wd/hub
+
 #testON=Web,Service  // Default both
 testON=
 traceEnabled=false
 plugInAuthLocation=src/test/resources/autoauth-2.1-fx+fn.xpi
 excludedPlatforms=MAC:chrome,MAC:firefox,WINDOWS:chrome,WINDOWS:internet explorer,LINUX:firefox
-browserWindowDimension=1920,800
\ No newline at end of file
+browserWindowDimension=1920,800
diff --git a/core/.settings/org.eclipse.wst.validation.prefs b/core/.settings/org.eclipse.wst.validation.prefs
new file mode 100644
index 0000000000..04cad8cb75
--- /dev/null
+++ b/core/.settings/org.eclipse.wst.validation.prefs
@@ -0,0 +1,2 @@
+disabled=06target
+eclipse.preferences.version=1
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 4661e36a7e..c45718e40b 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -317,11 +317,7 @@ private GraphHopper setUnsafeMemory() {
      * the GHRequest object. Per default the lexicographically first vehicle is
      * used.
      */
-    // <<<<<<< HEAD
-    // public GraphHopper setDoPrepare(boolean doPrepare)
-    // =======
     public void setDefaultVehicle(String defaultVehicleStr)
-    // >>>>>>> upstream/master
     {
         if (this.defaultVehicleStr != null)
             throw new RuntimeException("Cannot change default vehicle " + this.defaultVehicleStr + " to " + defaultVehicleStr);
@@ -615,20 +611,11 @@ else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
         neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
         logMessages = args.getDouble("prepare.logmessages", logMessages);
 
-        // osm import
-        // <<<<<<< HEAD
-        // osmReaderWayPointMaxDistance =
-        // args.getDouble("osmreader.wayPointMaxDistance",
-        // osmReaderWayPointMaxDistance);
-        // String flagEncoders = args.get("graph.flagEncoders", "CAR");
-        // if (flagEncoders.toLowerCase().contains("turncosts=true"))
-        // traversalMode = TraversalMode.EDGE_BASED_2DIR;
-        // encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
-        // =======
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
         String flagEncoders = args.get("graph.flagEncoders", "");
-        setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
-        // >>>>>>> upstream/master
+        if(!flagEncoders.isEmpty())
+            setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
+
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
@@ -782,13 +769,7 @@ else if (!graphHopperFolder.contains(".")) {
         if (chEnabled)
             graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
         else if (encodingManager.needsTurnCostsSupport())
-            // <<<<<<< HEAD
-            // graph = new GraphHopperStorage(dir, encodingManager,
-            // hasElevation(),
-            // new TurnCostStorage());
-            // =======
             graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
-        // >>>>>>> upstream/master
         else
             graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
 
@@ -848,15 +829,7 @@ private boolean isPrepared() {
     }
 
     protected RoutingAlgorithmFactory createPrepare() {
-        // <<<<<<< HEAD
-        // FlagEncoder encoder = encodingManager.getSingle();
-        // PrepareContractionHierarchies tmpPrepareCH = new
-        // PrepareContractionHierarchies(encoder,
-        // createWeighting(new WeightingMap(chWeighting), encoder),
-        // traversalMode);
-        // tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
-        // .setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
-        // =======
+
         if (!encodingManager.supports(getDefaultVehicle())) {
             throw new IllegalStateException("Should not happen: default vehicle " + getDefaultVehicle() + " not supported" + " from EncodingManager " + encodingManager.toDetailsString() + ". Cannot do CH preparation");
         }
@@ -865,7 +838,6 @@ protected RoutingAlgorithmFactory createPrepare() {
         Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
         PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph, defaultVehicle, weighting, traversalMode);
         tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates).setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
-        // >>>>>>> upstream/master
 
         return tmpPrepareCH;
     }
@@ -905,30 +877,13 @@ else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty()) {
      */
     public Weighting createTurnWeighting(Weighting weighting, Graph graph, FlagEncoder encoder) {
         if (encoder.supports(TurnWeighting.class)) {
-            // <<<<<<< HEAD
-            // result = new TurnWeighting(result, encoder,
-            // (TurnCostStorage) graph.getExtendedStorage());
-            // return result;
-            // =======
             return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
         }
         return weighting;
-        // >>>>>>> upstream/master
     }
 
     @Override
     public GHResponse route(GHRequest request) {
-        // <<<<<<< HEAD
-        // if (graph == null || !fullyLoaded)
-        // throw new
-        // IllegalStateException("Call load or importOrLoad before routing");
-        //
-        // if (graph.isClosed())
-        // throw new IllegalStateException(
-        // "You need to create a new GraphHopper instance as it is already closed");
-        //
-        // =======
-        // >>>>>>> upstream/master
         GHResponse response = new GHResponse();
         List<Path> paths = getPaths(request, response);
         if (response.hasErrors())
@@ -940,14 +895,7 @@ public GHResponse route(GHRequest request) {
         Locale locale = request.getLocale();
         DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
 
-        // <<<<<<< HEAD
-        // new PathMerger().setCalcPoints(calcPoints).setDouglasPeucker(peucker)
-        // .setEnableInstructions(enableInstructions)
-        // .setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
-        // .doWork(response, paths, trMap.getWithFallBack(locale));
-        // =======
         new PathMerger().setCalcPoints(tmpCalcPoints).setDouglasPeucker(peucker).setEnableInstructions(tmpEnableInstructions).setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).doWork(response, paths, trMap.getWithFallBack(locale));
-        // >>>>>>> upstream/master
         return response;
     }
 
@@ -1025,59 +973,10 @@ public GHResponse route(GHRequest request) {
         AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).build();
 
         for (int placeIndex = 1; placeIndex < points.size(); placeIndex++) {
-            // <<<<<<< HEAD
-            // GHPoint point = points.get(placeIndex);
-            // sw = new StopWatch().start();
-            // QueryResult toRes = locationIndex.findClosest(point.lat,
-            // point.lon, edgeFilter);
-            // debug += ", [" + placeIndex + "] idLookup:" +
-            // sw.stop().getSeconds() + "s";
-            // if (!toRes.isValid())
-            // {
-            // rsp.addError(new IllegalArgumentException("Cannot find point " +
-            // placeIndex + ": "
-            // + point));
-            // break;
-            // }
-            //
-            // sw = new StopWatch().start();
-            // String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi"
-            // : request
-            // .getAlgorithm();
-            // RoutingAlgorithm algo = null;
-            // if (chEnabled)
-            // {
-            // if (prepare == null)
-            // throw new IllegalStateException(
-            // "Preparation object is null. CH-preparation wasn't done or did you "
-            // + "forget to call setCHEnable(false)?");
-            //
-            // if (algoStr.equals("dijkstrabi"))
-            // algo = prepare.createAlgo();
-            // else if (algoStr.equals("astarbi"))
-            // algo = ((PrepareContractionHierarchies) prepare).createAStar();
-            // else
-            // {
-            // rsp.addError(new IllegalStateException(
-            // "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
-            // break;
-            // }
-            // } else
-            // {
-            // Weighting weighting = createWeighting(request.getHints(),
-            // encoder);
-            // prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph,
-            // algoStr, encoder,
-            // weighting, tMode);
-            // algo = prepare.createAlgo();
-            // }
-            //
-            // =======
             QueryResult toQResult = qResults.get(placeIndex);
             sw = new StopWatch().start();
             RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
             algo.setWeightLimit(weightLimit);
-            // >>>>>>> upstream/master
             debug += ", algoInit:" + sw.stop().getSeconds() + "s";
 
             sw = new StopWatch().start();
@@ -1086,14 +985,8 @@ public GHResponse route(GHRequest request) {
                 throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
 
             paths.add(path);
-            // <<<<<<< HEAD
-            // debug += ", " + algo.getName() + "-routing:" +
-            // sw.stop().getSeconds() + "s, "
-            // + path.getDebugInfo();
-            // =======
             debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
 
-            // >>>>>>> upstream/master
             visitedSum.addAndGet(algo.getVisitedNodes());
             fromQResult = toQResult;
         }
@@ -1109,15 +1002,7 @@ public GHResponse route(GHRequest request) {
     }
 
     protected LocationIndex createLocationIndex(Directory dir) {
-        // <<<<<<< HEAD
-        // LocationIndex tmpIndex;
-        // if (graph instanceof LevelGraph)
-        // tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-        // else
-        // tmpIndex = new LocationIndexTree(graph, dir);
-        // =======
         LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
-        // >>>>>>> upstream/master
         tmpIndex.setResolution(preciseIndexResolution);
         tmpIndex.setMaxRegionSearch(maxRegionSearch);
         if (!tmpIndex.loadExisting()) {
@@ -1161,22 +1046,8 @@ protected void prepare() {
         boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
         if (tmpPrepare) {
             ensureWriteAccess();
-            // <<<<<<< HEAD
-            // if (prepare instanceof PrepareContractionHierarchies
-            // && encodingManager.getVehicleCount() > 1)
-            // throw new
-            // IllegalArgumentException("Contraction hierarchies preparation "
-            // + "requires (at the moment) only one vehicle. But was:"
-            // + encodingManager);
-            //
-            // logger.info("calling prepare.doWork for " +
-            // encodingManager.toString() + " ... ("
-            // + Helper.getMemInfo() + ")");
-            // prepare.doWork();
-            // =======
             logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
             ((PrepareContractionHierarchies) algoFactory).doWork();
-            // >>>>>>> upstream/master
             graph.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
         graph.getProperties().put("prepare.done", tmpPrepare);
@@ -1192,15 +1063,7 @@ protected void cleanUp() {
         int n = graph.getNodes();
         // calculate remaining subnetworks
         int remainingSubnetworks = preparation.findSubnetworks().size();
-        // <<<<<<< HEAD
-        // logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " +
-        // n + ", there were "
-        // + preparation.getSubNetworks() + " subnetworks. removed them => "
-        // + (prev - n) + " less nodes. Remaining subnetworks:" +
-        // remainingSubnetworks);
-        // =======
         logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were " + preparation.getSubNetworks() + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
-        // >>>>>>> upstream/master
     }
 
     protected void flush() {
@@ -1265,7 +1128,6 @@ public long getVisitedSum() {
         return visitedSum.get();
     }
 
-    // <<<<<<< HEAD
     public GraphHopper setAsOSMReader() {
         dataReader = "OSM";
         return this;
@@ -1279,7 +1141,6 @@ public GraphHopper setAsItnReader() {
     public GraphHopper setAsDpnReader() {
         dataReader = "OSDPN";
         return this;
-        // =======
     }
 
     private void initDefaultVehicleIfNecessary() {
@@ -1288,6 +1149,5 @@ private void initDefaultVehicleIfNecessary() {
 
         if (!encodingManager.supports(getDefaultVehicle()))
             throw new IllegalArgumentException("Default vehicle " + defaultVehicleStr + " is not supported. " + "Include vehicle in EncodingManager or via the property graph.flagEncoders OR set it explicitely via setDefaultVehicle");
-        // >>>>>>> upstream/master
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java b/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
index 28470ad35b..a53defe57f 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
@@ -186,6 +186,7 @@ private int handleRoadNature(XMLStreamReader parser) throws XMLStreamException {
 //        }
     	if(parser.getElementText().equals("Roundabout")) {
     		setTag("junction", "roundabout");
+            setTag("direction", "clockwise");
     	}
         return parser.getEventType();
     }
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index 434240b5cf..f71ff9e8c2 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -31,7 +31,6 @@
 
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import com.graphhopper.reader.DataReader;
@@ -273,7 +272,6 @@ public void testSortedGraph_noCH()
     }
 
     @Test
-    @Ignore
     public void testFootAndCar()
     {
         // now all ways are imported
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/CombinationRestrictionTest.java b/core/src/test/java/com/graphhopper/reader/osgb/CombinationRestrictionTest.java
index 143d4c295c..c31771e260 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/CombinationRestrictionTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/CombinationRestrictionTest.java
@@ -7,7 +7,6 @@
 import java.io.File;
 import java.io.IOException;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
 import com.graphhopper.routing.util.DefaultEdgeFilter;
@@ -28,12 +27,7 @@ public void testNoTurnFrom17To19() throws IOException {
         runNoMotorVehicleTurnFrom17To19Test("./src/test/resources/com/graphhopper/reader/os-itn-no-turn-mandatory-turn-combination-crossroad.xml");
     }
 
-    /**
-     * Lets ignore bus for now
-     * @throws IOException
-     */
     @Test
-    @Ignore
     public void testMandatoryTurnExceptBusTrueFrom19To17() throws IOException {
         runMandatoryMotorVehicleTurnFrom19To17Test("./src/test/resources/com/graphhopper/reader/os-itn-no-turn-mandatory-turn-combination-crossroad.xml");
     }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/HeavitreeRoadDenmarkRoadCrossroadTest.java b/core/src/test/java/com/graphhopper/reader/osgb/HeavitreeRoadDenmarkRoadCrossroadTest.java
index db46246437..d9e11f24cf 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/HeavitreeRoadDenmarkRoadCrossroadTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/HeavitreeRoadDenmarkRoadCrossroadTest.java
@@ -8,7 +8,6 @@
 import java.io.File;
 import java.io.IOException;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
 import com.graphhopper.GHRequest;
@@ -59,7 +58,6 @@ public void testNoTurnFromNWToSW() throws IOException {
     }
 
     @Test
-    @Ignore
     public void testMandatoryTurnFromSWToNW() throws IOException {
         runMandatoryMotorVehicleTurnFromSWToNWTest(FILENAME);
     }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/ITNRoundaboutTest.java b/core/src/test/java/com/graphhopper/reader/osgb/ITNRoundaboutTest.java
new file mode 100644
index 0000000000..ab8ef6f0ce
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/osgb/ITNRoundaboutTest.java
@@ -0,0 +1,81 @@
+package com.graphhopper.reader.osgb;
+
+/**
+ * Created by sadam on 19/03/15.
+ */
+
+import static com.graphhopper.util.GHUtility.count;
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+import org.junit.Test;
+
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.util.ShortestWeighting;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.RoundaboutInstruction;
+import com.graphhopper.util.Translation;
+import com.graphhopper.util.TranslationMap;
+import com.graphhopper.util.TranslationMapTest;
+
+public class ITNRoundaboutTest extends AbstractOsItnReaderTest {
+    private final TranslationMap trMap = TranslationMapTest.SINGLETON;
+    private final Translation tr = trMap.getWithFallBack(Locale.US);
+
+    /**
+     * Alleys are not supported routes. This test is a simple (node A) - alley -
+     * (node B) - A Road - (node C) network. This means the alley should not be
+     * traversible and only nodes B and C should be present.
+     *
+     * @throws IOException
+     */
+    @Test
+    public void testRoundabout() throws IOException {
+        final boolean turnRestrictionsImport = true;
+        final boolean is3D = false;
+        final GraphHopperStorage graph = configureStorage(
+                turnRestrictionsImport, is3D);
+
+        final File file = new File(
+                "./src/test/resources/com/graphhopper/reader/osgb/os-itn-roundabout-exit.xml");
+        readGraphFile(graph, file);
+
+        Path p = new Dijkstra(graph, carEncoder, new ShortestWeighting(),
+                TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        // Test instructions
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto PARIS STREET (B3183)",
+                "At roundabout, take exit 1 onto CHEEKE STREET", "Finish!"), tmpList);
+
+        // case of continuing a street through a roundabout
+        p = new Dijkstra(graph, carEncoder, new ShortestWeighting(),
+                TraversalMode.NODE_BASED).calcPath(1, 9);
+        wayList = p.calcInstructions(tr);
+        tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto PARIS STREET (B3183)",
+                        "At roundabout, take exit 3 onto HEAVITREE ROAD (B3183)", "Finish!"),
+                tmpList);
+    }
+
+    List<String> pick(String key, List<Map<String, Object>> instructionJson) {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson) {
+            list.add(json.get(key).toString());
+        }
+        return list;
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/OSITNWayTest.java b/core/src/test/java/com/graphhopper/reader/osgb/OSITNWayTest.java
index 0143714e0c..0be4ba1695 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/OSITNWayTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/OSITNWayTest.java
@@ -41,6 +41,7 @@ public void testReadTagsForRoundabout() throws XMLStreamException, MismatchedDim
 		XMLStreamReader parser = factory.createXMLStreamReader(stringReader);
 		OSITNWay way = OSITNWay.create(0, parser);
 		assertTrue(way.hasTag("junction", "roundabout"));
+        assertTrue("ITN Data is uk specific so roundabouts should be clockwise", way.hasTag("direction", "clockwise"));
 	}
 
 }
diff --git a/web/.project b/web/.project
index 7af14ce51c..e34687bc08 100644
--- a/web/.project
+++ b/web/.project
@@ -22,12 +22,12 @@
 			</arguments>
 		</buildCommand>
 		<buildCommand>
-			<name>org.eclipse.m2e.core.maven2Builder</name>
+			<name>org.eclipse.wst.validation.validationbuilder</name>
 			<arguments>
 			</arguments>
 		</buildCommand>
 		<buildCommand>
-			<name>org.eclipse.wst.validation.validationbuilder</name>
+			<name>org.eclipse.m2e.core.maven2Builder</name>
 			<arguments>
 			</arguments>
 		</buildCommand>
