diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 7316d30798..f0df1e11ce 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -291,63 +291,25 @@ private PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy,
 
         List<Label.Transition> transitions = new ArrayList<>();
         if (arriveBy) {
-            reverseEdges(solution, queryGraph, false)
+            reverseEdges(solution, queryGraph, encoder, false)
                     .forEach(transitions::add);
         } else {
-            reverseEdges(solution, queryGraph, true)
+            reverseEdges(solution, queryGraph, encoder, true)
                     .forEach(transitions::add);
             Collections.reverse(transitions);
         }
 
         path.setWaypoints(waypoints);
 
-        List<List<Label.Transition>> partitions = new ArrayList<>();
-        for (Label.Transition transition : transitions) {
-            if (partitions.isEmpty() || encoder.getEdgeType(transition.edge.getFlags()) == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK || encoder.getEdgeType(partitions.get(partitions.size()-1).get(partitions.get(partitions.size()-1).size()-1).edge.getFlags()) == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
-                partitions.add(new ArrayList<>());
-            }
-            partitions.get(partitions.size()-1).add(transition);
-        }
+        List<List<Label.Transition>> partitions = getPartitions(transitions);
 
-        path.getLegs().addAll(partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, encoder, weighting, tr).stream()).collect(Collectors.toList()));
-
-        final InstructionList instructions = new InstructionList(tr);
-        for (int i=0; i<path.getLegs().size(); ++i) {
-            Trip.Leg leg = path.getLegs().get(i);
-            if (leg instanceof Trip.WalkLeg) {
-                final Trip.WalkLeg walkLeg = ((Trip.WalkLeg) leg);
-                instructions.addAll(walkLeg.instructions.subList(0, i < path.getLegs().size() - 1 ? walkLeg.instructions.size() - 1 : walkLeg.instructions.size()));
-            } else if (leg instanceof Trip.PtLeg) {
-                final Trip.PtLeg ptLeg = ((Trip.PtLeg) leg);
-                final PointList pl;
-                if (!ptLeg.isInSameVehicleAsPrevious) {
-                    pl = new PointList();
-                    final Instruction departureInstruction = new Instruction(Instruction.PT_START_TRIP, ptLeg.trip_headsign, InstructionAnnotation.EMPTY, pl);
-                    departureInstruction.setDistance(leg.getDistance());
-                    departureInstruction.setTime(ptLeg.travelTime);
-                    instructions.add(departureInstruction);
-                } else {
-                    pl = instructions.get(instructions.size()-2).getPoints();
-                }
-                pl.add(ptLeg.boardStop.geometry.getY(), ptLeg.boardStop.geometry.getX());
-                for (Trip.Stop stop : ptLeg.stops.subList(0, ptLeg.stops.size()-1)) {
-                    pl.add(stop.geometry.getY(), stop.geometry.getX());
-                }
-                final PointList arrivalPointList = new PointList();
-                final Trip.Stop arrivalStop = ptLeg.stops.get(ptLeg.stops.size()-1);
-                arrivalPointList.add(arrivalStop.geometry.getY(), arrivalStop.geometry.getX());
-                Instruction arrivalInstruction = new Instruction(Instruction.PT_END_TRIP, arrivalStop.name, InstructionAnnotation.EMPTY, arrivalPointList);
-                if (ptLeg.isInSameVehicleAsPrevious) {
-                    instructions.replaceLast(arrivalInstruction);
-                } else {
-                    instructions.add(arrivalInstruction);
-                }
-            }
-        }
+        final List<Trip.Leg> legs = getLegs(encoder, tr, queryGraph, weighting, partitions);
+        path.getLegs().addAll(legs);
 
+        final InstructionList instructions = getInstructions(tr, path.getLegs());
         path.setInstructions(instructions);
         PointList pointsList = new PointList();
-        for (Instruction instruction : path.getInstructions()) {
+        for (Instruction instruction : instructions) {
             pointsList.add(instruction.getPoints());
         }
         path.addDebugInfo(String.format("Violations: %d, Last leg dist: %f", solution.nWalkDistanceConstraintViolations, solution.walkDistanceOnCurrentLeg));
@@ -382,6 +344,65 @@ private PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy,
         return path;
     }
 
+    private List<List<Label.Transition>> getPartitions(List<Label.Transition> transitions) {
+        List<List<Label.Transition>> partitions = new ArrayList<>();
+        partitions.add(new ArrayList<>());
+        final Iterator<Label.Transition> iterator = transitions.iterator();
+        partitions.get(partitions.size()-1).add(iterator.next());
+        iterator.forEachRemaining(transition -> {
+            final List<Label.Transition> previous = partitions.get(partitions.size() - 1);
+            final Label.EdgeLabel previousEdge = previous.get(previous.size() - 1).edge;
+            if (previousEdge != null && (transition.edge.edgeType == GtfsStorage.EdgeType.ENTER_PT || previousEdge.edgeType == GtfsStorage.EdgeType.EXIT_PT)) {
+                final ArrayList<Label.Transition> p = new ArrayList<>();
+                p.add(new Label.Transition(previous.get(previous.size()-1).label, null));
+                partitions.add(p);
+            }
+            partitions.get(partitions.size()-1).add(transition);
+        });
+        return partitions;
+    }
+
+    private List<Trip.Leg> getLegs(PtFlagEncoder encoder, Translation tr, QueryGraph queryGraph, PtTravelTimeWeighting weighting, List<List<Label.Transition>> partitions) {
+        return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, encoder, weighting, tr).stream()).collect(Collectors.toList());
+    }
+
+    private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
+        final InstructionList instructions = new InstructionList(tr);
+        for (int i = 0; i< legs.size(); ++i) {
+            Trip.Leg leg = legs.get(i);
+            if (leg instanceof Trip.WalkLeg) {
+                final Trip.WalkLeg walkLeg = ((Trip.WalkLeg) leg);
+                instructions.addAll(walkLeg.instructions.subList(0, i < legs.size() - 1 ? walkLeg.instructions.size() - 1 : walkLeg.instructions.size()));
+            } else if (leg instanceof Trip.PtLeg) {
+                final Trip.PtLeg ptLeg = ((Trip.PtLeg) leg);
+                final PointList pl;
+                if (!ptLeg.isInSameVehicleAsPrevious) {
+                    pl = new PointList();
+                    final Instruction departureInstruction = new Instruction(Instruction.PT_START_TRIP, ptLeg.trip_headsign, InstructionAnnotation.EMPTY, pl);
+                    departureInstruction.setDistance(leg.getDistance());
+                    departureInstruction.setTime(ptLeg.travelTime);
+                    instructions.add(departureInstruction);
+                } else {
+                    pl = instructions.get(instructions.size()-2).getPoints();
+                }
+                pl.add(ptLeg.boardStop.geometry.getY(), ptLeg.boardStop.geometry.getX());
+                for (Trip.Stop stop : ptLeg.stops.subList(0, ptLeg.stops.size()-1)) {
+                    pl.add(stop.geometry.getY(), stop.geometry.getX());
+                }
+                final PointList arrivalPointList = new PointList();
+                final Trip.Stop arrivalStop = ptLeg.stops.get(ptLeg.stops.size()-1);
+                arrivalPointList.add(arrivalStop.geometry.getY(), arrivalStop.geometry.getX());
+                Instruction arrivalInstruction = new Instruction(Instruction.PT_END_TRIP, arrivalStop.name, InstructionAnnotation.EMPTY, arrivalPointList);
+                if (ptLeg.isInSameVehicleAsPrevious) {
+                    instructions.replaceLast(arrivalInstruction);
+                } else {
+                    instructions.add(arrivalInstruction);
+                }
+            }
+        }
+        return instructions;
+    }
+
     private PointList pointListFrom(List<QueryResult> queryResults) {
         PointList waypoints = new PointList(queryResults.size(), true);
         for (QueryResult qr : queryResults) {
@@ -395,44 +416,42 @@ private PointList pointListFrom(List<QueryResult> queryResults) {
     // by hand, because it is always ugly, but use a parser library.
     // The code would then read like a specification of what paths through the graph mean.
     private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, Graph graph, PtFlagEncoder encoder, Weighting weighting, Translation tr) {
-        if (GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK == encoder.getEdgeType(path.get(0).edge.getFlags())) {
-            final GtfsStorage.FeedIdWithTimezone feedIdWithTimezone = gtfsStorage.getTimeZones().get(flagEncoder.getValidityId(path.get(0).edge.getFlags()));
+        if (GtfsStorage.EdgeType.ENTER_PT == path.get(1).edge.edgeType) {
+            final GtfsStorage.FeedIdWithTimezone feedIdWithTimezone = gtfsStorage.getTimeZones().get(path.get(1).edge.timeZoneId);
             final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedIdWithTimezone.feedId);
             List<Trip.Leg> result = new ArrayList<>();
             long boardTime = -1;
             List<Label.Transition> partition = null;
             for (int i=1; i<path.size(); i++) {
                 Label.Transition transition = path.get(i);
-                EdgeIteratorState edge = path.get(i).edge;
-                GtfsStorage.EdgeType edgeType = encoder.getEdgeType(edge.getFlags());
-                if (edgeType == GtfsStorage.EdgeType.BOARD) {
+                Label.EdgeLabel edge = path.get(i).edge;
+                if (edge.edgeType == GtfsStorage.EdgeType.BOARD) {
                     boardTime = transition.label.currentTime;
                     partition = new ArrayList<>();
                 }
                 if (partition != null) {
                     partition.add(path.get(i));
                 }
-                if (EnumSet.of(GtfsStorage.EdgeType.TRANSFER, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK).contains(edgeType)) {
+                if (EnumSet.of(GtfsStorage.EdgeType.TRANSFER, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK).contains(edge.edgeType)) {
                     Geometry lineString = lineStringFromEdges(partition);
-                    String tripId = gtfsStorage.getExtraStrings().get(partition.get(0).edge.getEdge());
+                    String tripId = gtfsStorage.getExtraStrings().get(partition.get(0).edge.edgeIteratorState.getEdge());
                     final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripId);
                     partition.stream()
-                            .filter(e -> EnumSet.of(GtfsStorage.EdgeType.HOP, GtfsStorage.EdgeType.BOARD, GtfsStorage.EdgeType.DWELL).contains(encoder.getEdgeType(e.edge.getFlags())))
+                            .filter(e -> EnumSet.of(GtfsStorage.EdgeType.HOP, GtfsStorage.EdgeType.BOARD, GtfsStorage.EdgeType.DWELL).contains(e.edge.edgeType))
                             .forEach(stopsFromBoardHopDwellEdges::next);
                     stopsFromBoardHopDwellEdges.finish();
                     List<Trip.Stop> stops = stopsFromBoardHopDwellEdges.stops;
 
                     com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripId);
                     result.add(new Trip.PtLeg(
-                            feedIdWithTimezone.feedId,
-                            encoder.getTransfers(partition.get(0).edge.getFlags()) == 0,
+                            feedIdWithTimezone.feedId,partition.get(0).edge.nTransfers == 0,
                             stops.get(0),
                             tripId,
                             trip.route_id,
-                            partition.stream().map(t -> t.edge).collect(Collectors.toList()),
+                            edges(partition).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
                             new Date(boardTime),
                             stops,
-                            partition.stream().mapToDouble(t -> t.edge.getDistance()).sum(),
+                            partition.stream().mapToDouble(t -> t.edge.distance).sum(),
                             path.get(i-1).label.currentTime - boardTime,
                             new Date(path.get(i-1).label.currentTime),
                             lineString));
@@ -442,10 +461,10 @@ private PointList pointListFrom(List<QueryResult> queryResults) {
             return result;
         } else {
             InstructionList instructions = new InstructionList(tr);
-            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(0).edge.getBaseNode(), graph, weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
+            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph, weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
             int prevEdgeId = -1;
-            for (int i=0; i<path.size(); i++) {
-                EdgeIteratorState edge = path.get(i).edge;
+            for (int i=1; i<path.size(); i++) {
+                EdgeIteratorState edge = path.get(i).edge.edgeIteratorState;
                 instructionsFromEdges.next(edge, i, prevEdgeId);
                 prevEdgeId = edge.getEdge();
             }
@@ -455,21 +474,38 @@ private PointList pointListFrom(List<QueryResult> queryResults) {
             return Collections.singletonList(new Trip.WalkLeg(
                     "Walk",
                     Date.from(departureTime),
-                    path.stream().map(t -> t.edge).collect(Collectors.toList()),
+                    edges(path).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
                     lineStringFromEdges(path),
-                    path.stream().mapToDouble(t -> t.edge.getDistance()).sum(),
+                    edges(path).mapToDouble(edgeLabel -> edgeLabel.distance).sum(),
                     instructions.stream().collect(Collectors.toCollection(() -> new InstructionList(tr))),
                     Date.from(arrivalTime)));
         }
     }
 
+    private Stream<Label.EdgeLabel> edges(List<Label.Transition> path) {
+        return path.stream().filter(t -> t.edge != null).map(t -> t.edge);
+    }
+
     private Geometry lineStringFromEdges(List<Label.Transition> transitions) {
-        return Stream.concat(Stream.of(transitions.get(0).edge.fetchWayGeometry(3)),
-                transitions.stream().map(t -> t.edge.fetchWayGeometry(2)))
-                .flatMap(pointList -> pointList.toGeoJson().stream())
-                    .map(doubles -> new Coordinate(doubles[0], doubles[1]))
-                    .collect(Collectors.collectingAndThen(Collectors.toList(),
-                            coords -> geometryFactory.createLineString(coords.toArray(new Coordinate[]{}))));
+        List<Coordinate> coordinates = new ArrayList<>();
+        final Iterator<Label.Transition> iterator = transitions.iterator();
+        iterator.next();
+        coordinates.addAll(toCoordinateArray(iterator.next().edge.edgeIteratorState.fetchWayGeometry(3)));
+        iterator.forEachRemaining(transition -> {
+            coordinates.addAll(toCoordinateArray(transition.edge.edgeIteratorState.fetchWayGeometry(2)));
+        });
+        return geometryFactory.createLineString(coordinates.toArray(new Coordinate[coordinates.size()]));
+    }
+
+
+    public static List<Coordinate> toCoordinateArray(PointList pointList) {
+        List<Coordinate> coordinates = new ArrayList<>(pointList.size());
+        for (int i=0; i<pointList.size(); i++) {
+            coordinates.add(pointList.getDimension() == 3 ?
+                    new Coordinate(pointList.getLon(i), pointList.getLat(i)) :
+                    new Coordinate(pointList.getLon(i), pointList.getLat(i), pointList.getEle(i)));
+        }
+        return coordinates;
     }
 
     private class StopsFromBoardHopDwellEdges {
@@ -487,7 +523,7 @@ private Geometry lineStringFromEdges(List<Label.Transition> transitions) {
 
         void next(Label.Transition t) {
             long departureTime;
-            switch (flagEncoder.getEdgeType(t.edge.getFlags())) {
+            switch (t.edge.edgeType) {
                 case BOARD:
                     stop = findStop(t);
                     departureTime = t.label.currentTime;
@@ -507,7 +543,7 @@ void next(Label.Transition t) {
         }
 
         private Stop findStop(Label.Transition t) {
-            int stopSequence = gtfsStorage.getStopSequences().get(t.edge.getEdge());
+            int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
             StopTime stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripId, stopSequence));
             return gtfsFeed.stops.get(stopTime.stop_id);
         }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index 944943f379..71e7706790 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -26,12 +26,39 @@
 
     static class Transition {
         final Label label;
-        final EdgeIteratorState edge;
+        final EdgeLabel edge;
 
-        Transition(Label label, EdgeIteratorState edge) {
+        Transition(Label label, EdgeLabel edge) {
             this.label = label;
             this.edge = edge;
         }
+
+        @Override
+        public String toString() {
+            return (edge != null ? edge.toString() + " -> " : "") + label.adjNode;
+        }
+
+    }
+
+    static class EdgeLabel {
+        final EdgeIteratorState edgeIteratorState;
+        final GtfsStorage.EdgeType edgeType;
+        final int timeZoneId;
+        final int nTransfers;
+        final double distance;
+
+        public EdgeLabel(EdgeIteratorState edgeIteratorState, GtfsStorage.EdgeType edgeType, int timeZoneId, int nTransfers, double distance) {
+            this.edgeIteratorState = edgeIteratorState;
+            this.edgeType = edgeType;
+            this.timeZoneId = timeZoneId;
+            this.nTransfers = nTransfers;
+            this.distance = distance;
+        }
+
+        @Override
+        public String toString() {
+            return edgeType.toString();
+        }
     }
 
     final long currentTime;
@@ -63,28 +90,42 @@ public String toString() {
         return adjNode + " (" + edge + ") time: " + currentTime;
     }
 
-    static Iterable<Transition> reverseEdges(Label leaf, Graph graph, boolean reverseEdgeFlags) {
+    static Iterable<Transition> reverseEdges(Label leaf, Graph graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
         return new Iterable<Transition>() {
             @Override
             public Iterator<Transition> iterator() {
                 return new Iterator<Transition>() {
+                    int i = 0;
                     Label label = leaf;
                     @Override
                     public boolean hasNext() {
-                        return label.parent != null;
+                        return reverseEdgeFlags ? label != null : label.parent != null;
                     }
 
                     @Override
                     public Transition next() {
-                        EdgeIteratorState edgeIteratorState = graph.getEdgeIteratorState(label.edge, label.parent.adjNode)
-                                .detach(reverseEdgeFlags);
-                        Transition transition = new Transition(label, edgeIteratorState);
-                        label = label.parent;
-                        return transition;
+                        if (i==0 && !reverseEdgeFlags) {
+                            ++i;
+                            return new Transition(label, null);
+                        } else {
+                            EdgeIteratorState edgeIteratorState = label.parent == null ? null : graph.getEdgeIteratorState(label.edge, label.parent.adjNode).detach(reverseEdgeFlags);
+                            Transition transition;
+                            if (reverseEdgeFlags) {
+                                transition = new Transition(label, edgeIteratorState != null ? getEdgeLabel(edgeIteratorState, flagEncoder) : null);
+                            } else {
+                                transition = new Transition(label.parent, edgeIteratorState != null ? getEdgeLabel(edgeIteratorState, flagEncoder) : null);
+                            }
+                            label = label.parent;
+                            return transition;
+                        }
                     }
                 };
             }
         };
     }
 
+    private static EdgeLabel getEdgeLabel(EdgeIteratorState edgeIteratorState, PtFlagEncoder flagEncoder) {
+        return new EdgeLabel(edgeIteratorState, flagEncoder.getEdgeType(edgeIteratorState.getFlags()), flagEncoder.getValidityId(edgeIteratorState.getFlags()), flagEncoder.getTransfers(edgeIteratorState.getFlags()), edgeIteratorState.getDistance());
+    }
+
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index 885b7fae1c..1504379714 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -63,7 +63,7 @@ public static void init() {
         EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
         locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
@@ -84,7 +84,6 @@ public void testRoute1() {
                 TO_LAT, TO_LON
         );
         ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -101,7 +100,6 @@ public void testRoute1DoesNotGoAt654() {
                 TO_LAT, TO_LON
         );
         ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,6,54).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -138,7 +136,6 @@ public void testRoute1ArriveBy() {
         );
         ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,6, 49).atZone(zoneId).toInstant());
         ghRequest.getHints().put(GraphHopperGtfs.ARRIVE_BY, true);
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         GHResponse route = graphHopper.route(ghRequest);
 
@@ -159,11 +156,10 @@ public void testRoute1ProfileEarliestArrival() {
         ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
         ghRequest.getHints().put(GraphHopperGtfs.RANGE_QUERY_END_TIME, LocalDateTime.of(2007,1,1,13,0).atZone(zoneId).toInstant());
         ghRequest.getHints().put(GraphHopperGtfs.IGNORE_TRANSFERS, "true");
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(1)).departureTime.toInstant().atZone(zoneId)))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "06:44", "07:14", "07:44", "08:14", "08:44", "08:54", "09:04", "09:14", "09:24", "09:34", "09:44", "09:54",
@@ -186,11 +182,10 @@ public void testRoute1ProfileLatestDeparture() {
         ghRequest.getHints().put(GraphHopperGtfs.RANGE_QUERY_END_TIME, LocalDateTime.of(2007,1,2,11,0).atZone(zoneId).toInstant());
         // TODO: Find the problem with 1.1.2007
         ghRequest.getHints().put(GraphHopperGtfs.IGNORE_TRANSFERS, "true");
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
-                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(1)).departureTime.toInstant().atZone(zoneId)))
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).departureTime.toInstant().atZone(zoneId)))
                 .collect(Collectors.toList());
         List<LocalTime> expectedDepartureTimes = Stream.of(
                 "12:44", "12:14", "11:44", "11:14", "10:44")
@@ -229,13 +224,13 @@ public void testRoute5() {
                 TO_LAT, TO_LON
         );
         ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
         assertFalse(route.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(8, 10), route.getBest().getTime(), 0.1);
-        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(1)).tripId));
+        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(0)).tripId));
+        assertEquals("Using expected route", "AB1", (((Trip.PtLeg) route.getBest().getLegs().get(1)).tripId));
         assertEquals("Paid expected fare", 250, route.getBest().getFare().multiply(BigDecimal.valueOf(100)).intValue()); // Two legs, no transfers allowed. Need two 'p' tickets costing 125 cents each.
     }
 
@@ -263,7 +258,6 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
                 TO_LAT, TO_LON
         );
         ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant()); // Monday morning
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
 
 
         GHResponse route = graphHopper.route(ghRequest);
@@ -274,13 +268,12 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
                 TO_LAT, TO_LON
         );
         ghRequest1.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,6,0,0).atZone(zoneId).toInstant());
-        ghRequest1.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
         GHResponse route1 = graphHopper.route(ghRequest1);
 
         assertFalse(route1.hasErrors());
         assertFalse(route1.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(9, 0), route1.getBest().getTime());
-        assertEquals("Using expected trip", "AAMV1", (((Trip.PtLeg) route1.getBest().getLegs().get(1)).tripId));
+        assertEquals("Using expected trip", "AAMV1", (((Trip.PtLeg) route1.getBest().getLegs().get(0)).tripId));
         assertEquals("Paid expected fare", 525, route1.getBest().getFare().multiply(BigDecimal.valueOf(100)).intValue());
 
     }
@@ -294,11 +287,10 @@ public void testBlockTrips() {
                 TO_LAT, TO_LON
         );
         ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
         GHResponse response = graphHopper.route(ghRequest);
         assertEquals("Only find one solution. If blocks wouldn't work, there would be two. (There is a slower alternative without transfer.)", 1, response.getAll().size());
         assertEquals("Expected travel time == scheduled travel time", time(1,20), response.getBest().getTime());
-        assertEquals("Four legs: walk, pt, pt, walk, but the two pt legs are in one vehicle, so...", 4, response.getBest().getLegs().size());
+        assertEquals("Two legs: pt, pt, but the two pt legs are in one vehicle, so...", 2, response.getBest().getLegs().size());
         assertEquals("...one boarding instruction", 1, response.getBest().getInstructions().stream().filter(i -> i.getSign() == Instruction.PT_START_TRIP).count());
         assertEquals("...and one alighting instruction", 1, response.getBest().getInstructions().stream().filter(i -> i.getSign() == Instruction.PT_END_TRIP).count());
     }
@@ -365,7 +357,6 @@ private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double from_lat, do
                 to_lat, to_lon
         );
         ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, earliestDepartureTime);
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -383,7 +374,6 @@ private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double
                 to_lat, to_lon
         );
         ghRequest.getHints().put(GraphHopperGtfs.EARLIEST_DEPARTURE_TIME_HINT, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(GraphHopperGtfs.MAX_WALK_DISTANCE_PER_LEG, 30);
 
         GHResponse route = graphHopper.route(ghRequest);
         Assert.assertTrue(route.getAll().isEmpty());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index cfbf2f68ea..3f865e1cfa 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -186,7 +186,7 @@ public void testBlockTrips() {
                 .setScheduleRelationship(SKIPPED);
 
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
-        assertEquals("I can still use the AB1 trip", "AB1", (((Trip.PtLeg) response.getBest().getLegs().get(1)).tripId));
+        assertEquals("I can still use the AB1 trip", "AB1", (((Trip.PtLeg) response.getBest().getLegs().get(0)).tripId));
         assertEquals("It takes", time(1,20), response.getBest().getTime());
     }
 
