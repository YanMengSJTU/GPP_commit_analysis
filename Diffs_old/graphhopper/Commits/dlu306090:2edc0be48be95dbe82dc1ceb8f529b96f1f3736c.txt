diff --git a/android/app/src/main/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
index c407c842d2..2c982f8ef6 100644
--- a/android/app/src/main/AndroidManifest.xml
+++ b/android/app/src/main/AndroidManifest.xml
@@ -9,6 +9,7 @@
     <!-- necessary to easily download maps via wifi -->
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
 
     <uses-sdk
         android:minSdkVersion="10"
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index 9f2b708422..2b3c20c968 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -22,6 +22,10 @@
 import android.widget.Spinner;
 import android.widget.TextView;
 import android.widget.Toast;
+import android.content.Context;
+import android.location.Location;
+import android.location.LocationManager;
+import android.location.LocationListener;
 
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
@@ -63,12 +67,14 @@
 import java.util.Map;
 import java.util.TreeMap;
 
-public class MainActivity extends Activity {
+public class MainActivity extends Activity implements LocationListener {
     private static final int NEW_MENU_ID = Menu.FIRST + 1;
     private MapView mapView;
     private GraphHopper hopper;
     private GeoPoint start;
     private GeoPoint end;
+    private LocationManager locationManager;
+    private MarkerItem locationMarker;
     private Spinner localSpinner;
     private Button localButton;
     private Spinner remoteSpinner;
@@ -83,6 +89,23 @@
     private ItemizedLayer<MarkerItem> itemizedLayer;
     private PathLayer pathLayer;
 
+    @Override
+    public void onLocationChanged(Location location) {
+        itemizedLayer.removeItem(locationMarker);
+        locationMarker = createMarkerItem(new GeoPoint(location.getLatitude(), location.getLongitude()),
+                R.drawable.marker_icon_current_location);
+        itemizedLayer.addItem(locationMarker);
+        mapView.map().updateMap(true);
+    }
+
+    public void onStatusChanged(String s, int i, Bundle bundle) {}
+
+
+    public void onProviderEnabled(String s) {}
+
+
+    public void onProviderDisabled(String s) {}
+
     protected boolean onLongPress(GeoPoint p) {
         if (!isReady())
             return false;
@@ -103,10 +126,17 @@ protected boolean onLongPress(GeoPoint p) {
         } else {
             start = p;
             end = null;
+
             // remove routing layers
             mapView.map().layers().remove(pathLayer);
             itemizedLayer.removeAllItems();
 
+            // Map position
+            Location lastLocation = getLastBestLocation();
+            GeoPoint locationPoint = new GeoPoint(lastLocation.getLatitude(), lastLocation.getLongitude());
+            locationMarker = createMarkerItem(locationPoint, R.drawable.marker_icon_current_location);
+            itemizedLayer.addItem(locationMarker);
+
             itemizedLayer.addItem(createMarkerItem(start, R.drawable.marker_icon_green));
             mapView.map().updateMap(true);
         }
@@ -121,6 +151,8 @@ protected void onCreate(Bundle savedInstanceState) {
 
         Tile.SIZE = Tile.calculateTileSize(getResources().getDisplayMetrics().scaledDensity);
         mapView = new MapView(this);
+        locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
+        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, this);
 
         final EditText input = new EditText(this);
         input.setText(currentArea);
@@ -351,6 +383,32 @@ protected void onPostExecute(Object _ignore) {
         }.execute();
     }
 
+    /**
+     * @return the last know best location
+     */
+    private Location getLastBestLocation() {
+        Location locationGPS = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
+        Location locationNet = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
+
+        if (locationGPS == null && locationNet == null)
+            return null;
+        long GPSLocationTime = 0;
+        if (null != locationGPS) { GPSLocationTime = locationGPS.getTime(); }
+
+        long NetLocationTime = 0;
+
+        if (null != locationNet) {
+            NetLocationTime = locationNet.getTime();
+        }
+
+        if ( 0 < GPSLocationTime - NetLocationTime ) {
+            return locationGPS;
+        }
+        else {
+            return locationNet;
+        }
+    }
+
     void loadMap(File areaFolder) {
         logUser("loading map");
 
@@ -365,13 +423,23 @@ void loadMap(File areaFolder) {
         mapView.map().layers().add(new BuildingLayer(mapView.map(), l));
         mapView.map().layers().add(new LabelLayer(mapView.map(), l));
 
+        // Map position
+        Location lastLocation = getLastBestLocation();
+        GeoPoint mapCenter;
+        if (lastLocation != null) {
+            mapCenter = new GeoPoint(lastLocation.getLatitude(), lastLocation.getLongitude());
+            mapView.map().setMapPosition(lastLocation.getLatitude(), lastLocation.getLongitude(), 1 << 17);
+        }
+        else {
+            mapCenter = tileSource.getMapInfo().boundingBox.getCenterPoint();
+            mapView.map().setMapPosition(mapCenter.getLatitude(), mapCenter.getLongitude(), 1 << 17);
+        }
+
         // Markers layer
         itemizedLayer = new ItemizedLayer<>(mapView.map(), (MarkerSymbol) null);
+        itemizedLayer.addItem(createMarkerItem(mapCenter, R.drawable.marker_icon_current_location));
         mapView.map().layers().add(itemizedLayer);
 
-        // Map position
-        GeoPoint mapCenter = tileSource.getMapInfo().boundingBox.getCenterPoint();
-        mapView.map().setMapPosition(mapCenter.getLatitude(), mapCenter.getLongitude(), 1 << 15);
 
         setContentView(mapView);
         loadGraphStorage();
diff --git a/android/app/src/main/res/drawable-hdpi/marker_icon_current_location.png b/android/app/src/main/res/drawable-hdpi/marker_icon_current_location.png
new file mode 100644
index 0000000000..baee829aad
Binary files /dev/null and b/android/app/src/main/res/drawable-hdpi/marker_icon_current_location.png differ
diff --git a/config-example.properties b/config-example.properties
index 922cbd6a6d..024690739a 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -2,7 +2,7 @@
 
 # Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
 # bike2 takes elevation data into account (like up-hill is slower than down-hill) and requires enabling graph.elevation.provider below
-graph.flag_encoders=car
+graph.flag_encoders=generic
 
 # Enable turn restrictions for car or motorcycle. 
 # Currently you need to additionally set prepare.ch.weightings=no before using this (see below and #270)
@@ -28,10 +28,10 @@ graph.flag_encoders=car
 # By default the speed-up mode with the 'fastest' weighting is used. Internally a graph preparation via
 # contraction hierarchies (CH) is done to speed routing up. This requires more RAM/disc space for holding the
 # graph but less for every request. You can also setup multiple weightings, by providing a coma separated list.
-prepare.ch.weightings=fastest
+# prepare.ch.weightings=fastest
 
 # Disable the speed-up mode. Should be use only with routing.maxVisitedNodes
-# prepare.ch.weightings=no
+prepare.ch.weightings=no
 
 # To make preparation faster for multiple flagEncoders you can increase the default threads if you have enough RAM.
 # Change this setting only if you know what you are doing and if the default worked for you and really make sure you have enough RAM!
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
index 8a7ab6642e..677d1ca505 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -40,24 +40,26 @@
 
     private static final Map<String, Double> DEFAULT_SPEEDS = new LinkedHashMap<String, Double>() {
         {
-            put("motorway", 100d);
-            put("motorway_link", 70d);
-            put("motorroad", 90d);
-            put("trunk", 70d);
-            put("trunk_link", 65d);
-            put("primary", 65d);
-            put("primary_link", 60d);
-            put("secondary", 60d);
-            put("secondary_link", 50d);
-            put("tertiary", 50d);
-            put("tertiary_link", 40d);
-            put("unclassified", 30d);
-            put("residential", 30d);
-            put("living_street", 5d);
-            put("service", 20d);
-            put("road", 20d);
-            put("forestry", 15d);
-            put("track", 15d);
+            // put("motorway", 100d);
+            // put("motorway_link", 70d);
+            // put("motorroad", 90d);
+            // put("trunk", 70d);
+            // put("trunk_link", 65d);
+            // put("primary", 65d);
+            // put("primary_link", 60d);
+            // put("secondary", 60d);
+            // put("secondary_link", 50d);
+            // put("tertiary", 50d);
+            // put("tertiary_link", 40d);
+            // put("unclassified", 30d);
+            // put("residential", 30d);
+            // put("living_street", 5d);
+            // put("service", 20d);
+            // put("road", 20d);
+            // put("forestry", 15d);
+            // put("track", 15d);
+            put("footway", 3d);
+            put("steps", 1d);
         }
     };
     private final Map<String, Integer> surfaceMap = new HashMap<>();
