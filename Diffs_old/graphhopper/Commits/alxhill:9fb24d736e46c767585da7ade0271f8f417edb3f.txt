diff --git a/marmoset/src/main/java/com/graphhopper/marmoset/MarmosetHopper.java b/marmoset/src/main/java/com/graphhopper/marmoset/MarmosetHopper.java
index d784f2f25b..1aa1f6753f 100644
--- a/marmoset/src/main/java/com/graphhopper/marmoset/MarmosetHopper.java
+++ b/marmoset/src/main/java/com/graphhopper/marmoset/MarmosetHopper.java
@@ -3,8 +3,6 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.marmoset.util.CellsGraph;
 import com.graphhopper.marmoset.util.Location;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.util.CmdArgs;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -50,23 +48,7 @@ public void init()
 
         double cellSize = args.getDouble("marmoset.cellsize", 10.0);
         cellsGraph = new CellsGraph(hopper.getGraphHopperStorage().getBaseGraph(), cellSize);
-        cellsGraph.init(getFlagEncoder());
-    }
-
-    public FlagEncoder getFlagEncoder()
-    {
-        EncodingManager em = hopper.getEncodingManager();
-        List<FlagEncoder> encoders = em.fetchEdgeEncoders();
-        if (encoders.size() <= 0)
-        {
-            logger.error("No flag encoders found!");
-            return null;
-        }
-
-        if (encoders.size() > 1)
-            logger.warn("Multiple encoders found - using the first (" + encoders.get(0).toString() + ")");
-
-        return encoders.get(0);
+        cellsGraph.init();
     }
 
     private Random latRan = new Random(123);
diff --git a/marmoset/src/main/java/com/graphhopper/marmoset/Vehicle.java b/marmoset/src/main/java/com/graphhopper/marmoset/Vehicle.java
index e7d5daa22c..66389dde48 100644
--- a/marmoset/src/main/java/com/graphhopper/marmoset/Vehicle.java
+++ b/marmoset/src/main/java/com/graphhopper/marmoset/Vehicle.java
@@ -3,10 +3,15 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.marmoset.util.CellIterator;
 import com.graphhopper.marmoset.util.CellsGraph;
 import com.graphhopper.marmoset.util.Location;
 import com.graphhopper.routing.Path;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.util.*;
+import gnu.trove.list.TIntList;
+import javafx.scene.control.Cell;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -28,16 +33,13 @@
     private Location dest;
     private boolean finished;
 
-    private int edgeId;
+    private VehicleEdgeIterator route;
     private int cellId;
 
     private byte v; // velocity
     private float slowProb;
     private byte maxVelocity = 5;
 
-    private List<EdgeIteratorState> edgeList;
-    private int edgeIndex;
-
     private CellsGraph cg;
 
     public Vehicle(MarmosetHopper hopper, Location start, Location dest)
@@ -57,7 +59,8 @@ public boolean isFinished()
 
     private void finish(String error)
     {
-        logger.error(error);
+        if (error != null)
+            logger.error(error);
         finished = true;
     }
 
@@ -85,9 +88,8 @@ public void init()
             return;
         }
 
-        edgeList = paths.get(0).calcEdges();
-        // start from 1 to avoid the 'fake' edge added by the query graph
-        edgeIndex = 1;
+        Path p = paths.get(0);
+        List<EdgeIteratorState> edgeList = p.calcEdges();
 
         if (edgeList.size() <= 1)
         {
@@ -95,45 +97,48 @@ public void init()
             return;
         }
 
-        EdgeIteratorState e = edgeList.get(edgeIndex);
-        int maxId = edgeList.stream().mapToInt(EdgeIteratorState::getEdge).max().getAsInt();
-        int minId = edgeList.stream().mapToInt(EdgeIteratorState::getEdge).min().getAsInt();
-        edgeId = e.getEdge();
-        logger.debug("edge id: " + edgeId);
-        logger.debug("max edge id: " + maxId);
-        logger.debug("min edge id: " + minId);
+        route = new VehicleEdgeIterator(edgeList);
+        route.next();
 
-        cg.set(edgeId, cellId, true);
+        cg.set(route, cellId, true);
 
         finished = false;
     }
 
-    private int freeCells = -1;
     public void accelerationStep()
     {
-        assert !isFinished();
+        if (v >= maxVelocity)
+            return;
+        CellIterator c = new CellIterator(new VehicleEdgeIterator(route), cg, cellId);
+        int freeCells = 0;
+        while (!c.next() && freeCells < v + 1)
+            freeCells++;
 
-        freeCells = cg.freeCellsAhead(edgeId, cellId);
-        if (freeCells > v+1 && v < maxVelocity)
+        if (freeCells == v + 1)
         {
             logger.debug("Accelerating");
             v++;
         }
+
     }
 
     public void slowStep()
     {
-        if (freeCells < v)
+        int j = 0;
+        CellIterator c = new CellIterator(new VehicleEdgeIterator(route), cg, cellId);
+
+        while (!c.next() && j <= v)
+            j++;
+
+        if (j <= v)
         {
             logger.debug("Slowing");
-            v = (byte) (freeCells);
+            v = (byte) j;
         }
     }
 
     public void randomStep()
     {
-        int c = cg.getCellCount(edgeId);
-        logger.debug(id + "freecells:"+freeCells + "V:"+v + "count:"+ c);
         if (v > 0 && Math.random() < slowProb)
         {
             logger.debug("Randomly slowing");
@@ -143,18 +148,24 @@ public void randomStep()
 
     public void moveStep()
     {
-        logger.debug("Moving from " + cellId + " to " + (cellId + v));
-        cg.set(edgeId, cellId, false);
-        cellId += v;
-        cg.set(edgeId, cellId, true);
+        logger.debug("Moving from " + cellId + " to " + (cellId + v) + " (unless it's going over the edge)");
+        cg.set(route, cellId, false);
+        CellIterator c = new CellIterator(route, cg, cellId);
+        int steps = v;
+        while (steps > 0)
+        {
+            c.next();
+            steps--;
+        }
+        cellId = c.getCellIndex();
+        cg.set(route, cellId, true);
     }
 
     public void updateLocation()
     {
-        double progress = (cellId+1)/ (float) (cg.getCellCount(edgeId));
-        EdgeIteratorState edge = edgeList.get(edgeIndex);
+        double progress = (cellId + 1) / (float) (cg.getCellCount(route));
 
-        PointList path = edge.fetchWayGeometry(3);
+        PointList path = route.fetchWayGeometry(3);
         if (path.isEmpty())
         {
             logger.debug("Path is empty, not moving...");
@@ -170,20 +181,16 @@ public void updateLocation()
         double currDist = 0;
         logger.debug(String.format("start(%d): %f + %f", id, currDist, distTravelled));
         int i = 0;
-        while (i < path.getSize()-1 && currDist <= distTravelled)
+        while (i < path.getSize() - 1 && currDist <= distTravelled)
         {
             double nextDist = dc.calcDist(path.getLat(i), path.getLon(i), path.getLat(i + 1), path.getLon(i + 1));
-            logger.debug(String.format("-%d|%d: %f + %f", id,i,currDist,nextDist));
+            logger.debug(String.format("-%d|%d: %f + %f", id, i, currDist, nextDist));
             if (currDist + nextDist > distTravelled)
             {
-                double partProgress = (distTravelled - currDist)/nextDist;
+                double partProgress = (distTravelled - currDist) / nextDist;
                 double newLat = path.getLat(i) + partProgress * (path.getLat(i + 1) - path.getLat(i));
                 double newLon = path.getLon(i) + partProgress * (path.getLon(i + 1) - path.getLon(i));
                 loc.set(newLat, newLon);
-                if (currDist + nextDist > dist)
-                {
-                    nextEdge();
-                }
                 return;
             }
             currDist += nextDist;
@@ -192,20 +199,6 @@ public void updateLocation()
 
         // if we get here we've reached the end of the edge
         loc.set(path.getLat(path.getSize() - 1), path.getLon(path.getSize() - 1));
-        nextEdge();
-    }
-
-    private void nextEdge()
-    {
-        edgeIndex++;
-        if (edgeIndex >= edgeList.size() - 1)
-        {
-            logger.info("Vehicle " + id + " has reached destination");
-            finished = true;
-            return;
-        }
-        edgeId = edgeList.get(edgeIndex).getEdge();
-        cellId = 0;
     }
 
     @Override
diff --git a/marmoset/src/main/java/com/graphhopper/marmoset/VehicleEdgeIterator.java b/marmoset/src/main/java/com/graphhopper/marmoset/VehicleEdgeIterator.java
new file mode 100644
index 0000000000..2a624bc8ef
--- /dev/null
+++ b/marmoset/src/main/java/com/graphhopper/marmoset/VehicleEdgeIterator.java
@@ -0,0 +1,150 @@
+package com.graphhopper.marmoset;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+
+import java.util.List;
+
+/**
+ * Created by alexander on 09/03/2016.
+ */
+public class VehicleEdgeIterator implements EdgeIterator {
+
+    private List<EdgeIteratorState> edges;
+    private EdgeIteratorState edge;
+    private int index;
+
+    public VehicleEdgeIterator(List<EdgeIteratorState> edges)
+    {
+        // starts at 0 to skip first edge, as the first edge is virtual (i.e not in graph)
+        index = 0;
+        this.edges = edges;
+    }
+
+    public VehicleEdgeIterator(VehicleEdgeIterator e)
+    {
+        edges = e.edges;
+        edge = e.edge;
+        index = e.index;
+    }
+
+    @Override
+    public boolean next()
+    {
+        index++;
+        if (index >= edges.size() - 1) // to skip last virtual edge
+            return false;
+        edge = edges.get(index);
+        return true;
+    }
+
+    @Override
+    public int getEdge()
+    {
+        return edge.getEdge();
+    }
+
+    @Override
+    public int getBaseNode()
+    {
+        return edge.getBaseNode();
+    }
+
+    @Override
+    public int getAdjNode()
+    {
+        return edge.getAdjNode();
+    }
+
+    @Override
+    public PointList fetchWayGeometry(int mode)
+    {
+        return edge.fetchWayGeometry(mode);
+    }
+
+    @Override
+    public EdgeIteratorState setWayGeometry(PointList list)
+    {
+        return edge.setWayGeometry(list);
+    }
+
+    @Override
+    public double getDistance()
+    {
+        return edge.getDistance();
+    }
+
+    @Override
+    public EdgeIteratorState setDistance(double dist)
+    {
+        return edge.setDistance(dist);
+    }
+
+    @Override
+    public long getFlags()
+    {
+        return edge.getFlags();
+    }
+
+    @Override
+    public EdgeIteratorState setFlags(long flags)
+    {
+        return edge.setFlags(flags);
+    }
+
+    @Override
+    public int getAdditionalField()
+    {
+        return edge.getAdditionalField();
+    }
+
+    @Override
+    public boolean isForward(FlagEncoder encoder)
+    {
+        return edge.isForward(encoder);
+    }
+
+    @Override
+    public boolean isBackward(FlagEncoder encoder)
+    {
+        return edge.isBackward(encoder);
+    }
+
+    @Override
+    public boolean getBoolean(int key, boolean reverse, boolean _default)
+    {
+        return edge.getBoolean(key, reverse, _default);
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField(int value)
+    {
+        return edge.setAdditionalField(value);
+    }
+
+    @Override
+    public String getName()
+    {
+        return edge.getName();
+    }
+
+    @Override
+    public EdgeIteratorState setName(String name)
+    {
+        return edge.setName(name);
+    }
+
+    @Override
+    public EdgeIteratorState detach(boolean reverse)
+    {
+        return edge.detach(reverse);
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesTo(EdgeIteratorState e)
+    {
+        return edge.copyPropertiesTo(e);
+    }
+}
diff --git a/marmoset/src/main/java/com/graphhopper/marmoset/util/CellIterator.java b/marmoset/src/main/java/com/graphhopper/marmoset/util/CellIterator.java
new file mode 100644
index 0000000000..ef473c68d6
--- /dev/null
+++ b/marmoset/src/main/java/com/graphhopper/marmoset/util/CellIterator.java
@@ -0,0 +1,37 @@
+package com.graphhopper.marmoset.util;
+
+import com.graphhopper.marmoset.VehicleEdgeIterator;
+
+/**
+ * Created by alexander on 09/03/2016.
+ */
+public class CellIterator {
+
+    private VehicleEdgeIterator route;
+    private CellsGraph cg;
+    private int cellIndex;
+
+    public CellIterator(VehicleEdgeIterator route, CellsGraph cellsGraph, int cellId)
+    {
+        this.route = route;
+        this.cg = cellsGraph;
+        this.cellIndex = cellId;
+    }
+
+    public boolean next()
+    {
+        cellIndex++;
+        if (cellIndex >= cg.getCellCount(route))
+        {
+            cellIndex = 0;
+            // TODO: deal with ending of routes
+            route.next();
+        }
+        return cg.get(route, cellIndex);
+    }
+
+    public int getCellIndex()
+    {
+        return cellIndex;
+    }
+}
diff --git a/marmoset/src/main/java/com/graphhopper/marmoset/util/CellsGraph.java b/marmoset/src/main/java/com/graphhopper/marmoset/util/CellsGraph.java
index 53856c0d6e..11ade56a25 100644
--- a/marmoset/src/main/java/com/graphhopper/marmoset/util/CellsGraph.java
+++ b/marmoset/src/main/java/com/graphhopper/marmoset/util/CellsGraph.java
@@ -3,6 +3,8 @@
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * Created by alexander on 01/03/2016.
@@ -16,10 +18,9 @@
     public CellsGraph(Graph graph, double cellSize) {
         this.cellSize = cellSize;
         this.graph = graph;
-
     }
 
-    public void init(FlagEncoder fe)
+    public void init()
     {
         AllEdgesIterator iterator = graph.getAllEdges();
         cells = new boolean[iterator.getMaxId()][];
@@ -28,45 +29,53 @@ public void init(FlagEncoder fe)
         {
             int cellCount = Math.max(1, (int) (iterator.getDistance() / cellSize));
 
-            if (fe.isForward(iterator.getFlags()))
-                cells[iterator.getEdge()] = new boolean[cellCount];
-
-            if (fe.isBackward(iterator.getFlags()))
-                reverseCells[iterator.getEdge()] = new boolean[cellCount];
+            cells[iterator.getEdge()] = new boolean[cellCount];
+            reverseCells[iterator.getEdge()] = new boolean[cellCount];
         }
     }
 
-    public int getCellCount(int edgeId)
+    public int getCellCount(EdgeIteratorState edge)
     {
-        if (edgeId >= cells.length)
+        int edgeId = edge.getEdge();
+        boolean[][] currCells = getCells(edge);
+        if (edgeId >= currCells.length)
             throw new ArrayIndexOutOfBoundsException(
-                    String.format("EdgeId '%d' out of bounds (max %d)", edgeId, cells.length));
-        return cells[edgeId].length;
+                    String.format("EdgeId '%d' out of bounds (max %d)", edgeId, currCells.length));
+        return currCells[edgeId].length;
     }
 
-    public int freeCellsAhead(int edgeId, int cellId)
+    public void set(EdgeIteratorState edge, int cellId, boolean hasVehicle)
     {
-        int move = 1;
-        while (cellId + move < cells[edgeId].length)
-        {
-            if (!cells[edgeId][cellId + move])
-                move++;
-            else
-                return move-1;
-        }
+        boolean[][] currCells = getCells(edge);
+        int edgeId = edge.getEdge();
+        if (edgeId >= currCells.length)
+            throw new ArrayIndexOutOfBoundsException(
+                    String.format("EdgeId '%d' out of bounds (max %d)", edgeId, currCells.length));
+        if (cellId >= currCells[edgeId].length)
+            throw new ArrayIndexOutOfBoundsException(
+                    String.format("CellId '%d' out of bounds (max %d) for edge %d", cellId, currCells[edgeId].length, edgeId));
 
-        return move-1;
+        currCells[edgeId][cellId] = hasVehicle;
     }
 
-    public void set(int edgeId, int cellId, boolean hasVehicle)
+    public boolean get(EdgeIteratorState edge, int cellId)
     {
-        if (edgeId >= cells.length)
+        boolean[][] currCells = getCells(edge);
+        int edgeId = edge.getEdge();
+        if (edgeId >= currCells.length)
             throw new ArrayIndexOutOfBoundsException(
-                    String.format("EdgeId '%d' out of bounds (max %d)", edgeId, cells.length));
-        if (cellId >= cells[edgeId].length)
+                    String.format("EdgeId '%d' out of bounds (max %d)", edgeId, currCells.length));
+        if (cellId >= currCells[edgeId].length)
             throw new ArrayIndexOutOfBoundsException(
-                    String.format("CellId '%d' out of bounds (max %d) for edge %d", cellId, cells[edgeId].length, edgeId));
+                    String.format("CellId '%d' out of bounds (max %d) for edge %d", cellId, currCells[edgeId].length, edgeId));
+        return currCells[edgeId][cellId];
+    }
+
+    private boolean[][] getCells(EdgeIteratorState edge)
+    {
+        if (edge.getBaseNode() < edge.getAdjNode())
+            return cells;
 
-        cells[edgeId][cellId] = hasVehicle;
+        return reverseCells;
     }
 }
diff --git a/marmoset/src/main/resources/log4j.xml b/marmoset/src/main/resources/log4j.xml
index 99209d02c8..d7f0862713 100644
--- a/marmoset/src/main/resources/log4j.xml
+++ b/marmoset/src/main/resources/log4j.xml
@@ -3,7 +3,7 @@
 <log4j:configuration>
     <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
         <layout class="org.apache.log4j.PatternLayout">
-            <param name="ConversionPattern" value="[%t] %-5p %c - %m%n"/>
+            <param name="ConversionPattern" value="[%t] %-5p %c{1} - %m%n"/>
         </layout>
     </appender>
     <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
