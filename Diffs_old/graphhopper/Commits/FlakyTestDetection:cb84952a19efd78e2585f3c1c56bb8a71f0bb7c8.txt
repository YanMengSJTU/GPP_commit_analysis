diff --git a/core/src/main/java/com/graphhopper/Trip.java b/core/src/main/java/com/graphhopper/Trip.java
index 84e404915d..4ed6b675e7 100644
--- a/core/src/main/java/com/graphhopper/Trip.java
+++ b/core/src/main/java/com/graphhopper/Trip.java
@@ -35,7 +35,7 @@ public double getDistance() {
 
     public static class Stop {
         public final String stop_id;
-        public final String name;
+        public final String stop_name;
         public final Point geometry;
 
         public final Date arrivalTime;
@@ -43,7 +43,7 @@ public double getDistance() {
 
         public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date departureTime) {
             this.stop_id = stop_id;
-            this.name = name;
+            this.stop_name = name;
             this.geometry = geometry;
             this.arrivalTime = arrivalTime;
             this.departureTime = departureTime;
@@ -58,22 +58,20 @@ public WalkLeg(String departureLocation, Date departureTime, List<EdgeIteratorSt
         }
     }
     public static class PtLeg extends Leg {
-        public final String feedId;
+        public final String feed_id;
         public final boolean isInSameVehicleAsPrevious;
         public final String trip_headsign;
         public final long travelTime;
         public final List<Stop> stops;
-        public final Stop boardStop;
-        public final String tripId;
-        public final String routeId;
+        public final String trip_id;
+        public final String route_id;
 
-        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, Stop stop, String tripId, String routeId, List<EdgeIteratorState> edges, Date departureTime, List<Stop> stops, double distance, long travelTime, Date arrivalTime, Geometry geometry) {
-            super("pt", stop.name, departureTime, edges, geometry, distance, arrivalTime);
-            this.feedId = feedId;
+        public PtLeg(String feedId, boolean isInSameVehicleAsPrevious, String tripId, String routeId, List<EdgeIteratorState> edges, Date departureTime, List<Stop> stops, double distance, long travelTime, Date arrivalTime, Geometry geometry) {
+            super("pt", stops.get(0).stop_name, departureTime, edges, geometry, distance, arrivalTime);
+            this.feed_id = feedId;
             this.isInSameVehicleAsPrevious = isInSameVehicleAsPrevious;
-            this.boardStop = stop;
-            this.tripId = tripId;
-            this.routeId = routeId;
+            this.trip_id = tripId;
+            this.route_id = routeId;
             this.trip_headsign = edges.get(0).getName();
             this.travelTime = travelTime;
             this.stops = stops;
diff --git a/core/src/main/resources/com/graphhopper/util/de_DE.txt b/core/src/main/resources/com/graphhopper/util/de_DE.txt
index aa5e6eb39d..d2effe7e9c 100644
--- a/core/src/main/resources/com/graphhopper/util/de_DE.txt
+++ b/core/src/main/resources/com/graphhopper/util/de_DE.txt
@@ -50,7 +50,7 @@ way=Weg
 small_way=kleiner Weg
 paved=befestigt
 unpaved=unbefestigt
-stopover=Zwischenziel %1$s
+stopover=Wegpunkt %1$s
 roundabout_enter=In den Kreisverkehr einfahren
 roundabout_exit=Im Kreisverkehr Ausfahrt %1$s nehmen
 roundabout_exit_onto=Im Kreisverkehr Ausfahrt %1$s auf %2$s nehmen
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index 231e11adea..483f1f620d 100644
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -50,7 +50,7 @@ way=way
 small_way=small way
 paved=paved
 unpaved=unpaved
-stopover=stopover %1$s
+stopover=waypoint %1$s
 roundabout_enter=Enter roundabout
 roundabout_exit=At roundabout, take exit %1$s
 roundabout_exit_onto=At roundabout, take exit %1$s onto %2$s
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index b569436fed..45955d9b96 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -124,7 +124,7 @@ long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
     }
 
     private long waitingTime(EdgeIteratorState edge, long earliestStartTime) {
-        return (flagEncoder.getTime(edge.getFlags()) - secondsOnTrafficDay(edge, earliestStartTime)) * 1000;
+        return flagEncoder.getTime(edge.getFlags()) * 1000 - millisOnTravelDay(edge, earliestStartTime);
     }
 
     private int secondsOnTrafficDay(EdgeIteratorState edge, long instant) {
@@ -132,6 +132,11 @@ private int secondsOnTrafficDay(EdgeIteratorState edge, long instant) {
         return Instant.ofEpochMilli(instant).atZone(zoneId).toLocalTime().toSecondOfDay();
     }
 
+    private long millisOnTravelDay(EdgeIteratorState edge, long instant) {
+        final ZoneId zoneId = gtfsStorage.getTimeZones().get(flagEncoder.getValidityId(edge.getFlags())).zoneId;
+        return Instant.ofEpochMilli(instant).atZone(zoneId).toLocalTime().toNanoOfDay() / 1000000L;
+    }
+
     private boolean isValidOn(EdgeIteratorState edge, long instant) {
         GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
         if (edgeType == GtfsStorage.EdgeType.BOARD || edgeType == GtfsStorage.EdgeType.ALIGHT) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 855bf558d6..996923f85a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -18,17 +18,11 @@
 
 package com.graphhopper.reader.gtfs;
 
-import com.conveyal.gtfs.GTFSFeed;
-import com.conveyal.gtfs.model.Stop;
-import com.conveyal.gtfs.model.StopTime;
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.*;
-import com.graphhopper.gtfs.fare.Fares;
 import com.graphhopper.reader.osm.OSMReader;
-import com.graphhopper.routing.InstructionsFromEdges;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
@@ -36,23 +30,15 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.exceptions.PointNotFoundException;
 import com.graphhopper.util.shapes.GHPoint;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.Geometry;
-import com.vividsolutions.jts.geom.GeometryFactory;
-import org.mapdb.Fun;
 
 import java.io.File;
 import java.io.IOException;
-import java.time.Duration;
 import java.time.Instant;
-import java.time.LocalDateTime;
 import java.time.format.DateTimeParseException;
 import java.util.*;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
 import java.util.zip.ZipFile;
 
-import static com.graphhopper.reader.gtfs.Label.reverseEdges;
 import static com.graphhopper.util.Parameters.PT.PROFILE_QUERY;
 
 public final class GraphHopperGtfs implements GraphHopperAPI {
@@ -91,7 +77,7 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
     private final LocationIndex locationIndex;
     private final GtfsStorage gtfsStorage;
     private final RealtimeFeed realtimeFeed;
-    private final GeometryFactory geometryFactory = new GeometryFactory();
+    private final TripFromLabel tripFromLabel;
 
     private class RequestHandler {
         private final int maxVisitedNodesForRequest;
@@ -115,7 +101,7 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
             maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, Integer.MAX_VALUE);
             profileQuery = request.getHints().getBool(PROFILE_QUERY, false);
             ignoreTransfers = request.getHints().getBool(Parameters.PT.IGNORE_TRANSFERS, false);
-            limitSolutions = request.getHints().getInt(Parameters.PT.LIMIT_SOLUTIONS, profileQuery ? 5 : Integer.MAX_VALUE);
+            limitSolutions = request.getHints().getInt(Parameters.PT.LIMIT_SOLUTIONS, profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
             final String departureTimeString = request.getHints().get(Parameters.PT.EARLIEST_DEPARTURE_TIME, "");
             try {
                 initialTime = Instant.parse(departureTimeString);
@@ -169,7 +155,7 @@ private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
 
         private void parseSolutionsAndAddToResponse(List<Label> solutions, PointList waypoints) {
             for (Label solution : solutions) {
-                response.add(parseSolutionIntoPath(initialTime, arriveBy, flagEncoder, translation, queryGraph, weighting, solution, waypoints));
+                response.add(tripFromLabel.parseSolutionIntoPath(initialTime, arriveBy, flagEncoder, translation, queryGraph, weighting, solution, waypoints));
             }
             response.getAll().sort(Comparator.comparingDouble(PathWrapper::getTime));
         }
@@ -178,7 +164,7 @@ private void parseSolutionsAndAddToResponse(List<Label> solutions, PointList way
             StopWatch stopWatch = new StopWatch().start();
             GraphExplorer graphExplorer = new GraphExplorer(queryGraph, weighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy);
             MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, weighting, arriveBy, maxWalkDistancePerLeg, maxTransferDistancePerLeg, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
-            List<Label> solutions = router.calcPaths(startNode, Collections.singleton(destNode), initialTime)
+            List<Label> solutions = router.calcPaths(startNode, destNode, initialTime)
                     .limit(limitSolutions)
                     .collect(Collectors.toList());
             response.addDebugInfo("routing:" + stopWatch.stop().getSeconds() + "s");
@@ -201,6 +187,7 @@ public GraphHopperGtfs(PtFlagEncoder flagEncoder, TranslationMap translationMap,
         this.locationIndex = locationIndex;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
+        this.tripFromLabel = new TripFromLabel(this.gtfsStorage);
     }
 
     public static GtfsStorage createGtfsStorage() {
@@ -257,8 +244,10 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
     }
 
 
-    public static LocationIndex createOrLoadIndex(GHDirectory directory, GraphHopperStorage graphHopperStorage) {
-        LocationIndex locationIndex = new LocationIndexTree(graphHopperStorage, directory);
+    public static LocationIndex createOrLoadIndex(GHDirectory directory, GraphHopperStorage graphHopperStorage, PtFlagEncoder flagEncoder) {
+        final EverythingButPt everythingButPt = new EverythingButPt(flagEncoder);
+        Graph walkNetwork = GraphSupport.filteredView(graphHopperStorage, everythingButPt);
+        LocationIndex locationIndex = new LocationIndexTree(walkNetwork, directory);
         if (!locationIndex.loadExisting()) {
             locationIndex.prepareIndex();
         }
@@ -282,123 +271,6 @@ private static PtTravelTimeWeighting createPtTravelTimeWeighting(PtFlagEncoder e
         return weighting;
     }
 
-    private PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy, PtFlagEncoder encoder, Translation tr, QueryGraph queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
-        PathWrapper path = new PathWrapper();
-
-        List<Label.Transition> transitions = new ArrayList<>();
-        if (arriveBy) {
-            reverseEdges(solution, queryGraph, encoder, false)
-                    .forEach(transitions::add);
-        } else {
-            reverseEdges(solution, queryGraph, encoder, true)
-                    .forEach(transitions::add);
-            Collections.reverse(transitions);
-        }
-
-        path.setWaypoints(waypoints);
-
-        List<List<Label.Transition>> partitions = getPartitions(transitions);
-
-        final List<Trip.Leg> legs = getLegs(encoder, tr, queryGraph, weighting, partitions);
-        path.getLegs().addAll(legs);
-
-        final InstructionList instructions = getInstructions(tr, path.getLegs());
-        path.setInstructions(instructions);
-        PointList pointsList = new PointList();
-        for (Instruction instruction : instructions) {
-            pointsList.add(instruction.getPoints());
-        }
-        path.addDebugInfo(String.format("Violations: %d, Last leg dist: %f", solution.nWalkDistanceConstraintViolations, solution.walkDistanceOnCurrentLeg));
-        path.setPoints(pointsList);
-        path.setDistance(path.getLegs().stream().mapToDouble(Trip.Leg::getDistance).sum());
-        path.setTime((solution.currentTime - initialTime.toEpochMilli()) * (arriveBy ? -1 : 1));
-        if (solution.departureTime != null) {
-            path.setFirstPtLegDeparture(solution.departureTime);
-        }
-        path.setNumChanges((int) path.getLegs().stream()
-                .filter(l -> l instanceof Trip.PtLeg)
-                .filter(l -> !((Trip.PtLeg) l).isInSameVehicleAsPrevious)
-                .count() - 1);
-        com.graphhopper.gtfs.fare.Trip faresTrip = new com.graphhopper.gtfs.fare.Trip();
-        path.getLegs().stream()
-                .filter(leg -> leg instanceof Trip.PtLeg)
-                .map(leg -> (Trip.PtLeg) leg)
-                .findFirst()
-                .ifPresent(firstPtLeg -> {
-                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.departureTime);
-                    path.getLegs().stream()
-                            .filter(leg -> leg instanceof Trip.PtLeg)
-                            .map(leg -> (Trip.PtLeg) leg)
-                            .map(ptLeg -> {
-                                final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(ptLeg.feedId);
-                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.tripId).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.departureTime)).getSeconds(), gtfsFeed.stops.get(ptLeg.boardStop.stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
-                            })
-                            .forEach(faresTrip.segments::add);
-                    Fares.cheapestFare(gtfsStorage.getFares(), faresTrip)
-                            .ifPresent(amount -> path.setFare(amount.getAmount()));
-                });
-        return path;
-    }
-
-    private List<List<Label.Transition>> getPartitions(List<Label.Transition> transitions) {
-        List<List<Label.Transition>> partitions = new ArrayList<>();
-        partitions.add(new ArrayList<>());
-        final Iterator<Label.Transition> iterator = transitions.iterator();
-        partitions.get(partitions.size()-1).add(iterator.next());
-        iterator.forEachRemaining(transition -> {
-            final List<Label.Transition> previous = partitions.get(partitions.size() - 1);
-            final Label.EdgeLabel previousEdge = previous.get(previous.size() - 1).edge;
-            if (previousEdge != null && (transition.edge.edgeType == GtfsStorage.EdgeType.ENTER_PT || previousEdge.edgeType == GtfsStorage.EdgeType.EXIT_PT)) {
-                final ArrayList<Label.Transition> p = new ArrayList<>();
-                p.add(new Label.Transition(previous.get(previous.size()-1).label, null));
-                partitions.add(p);
-            }
-            partitions.get(partitions.size()-1).add(transition);
-        });
-        return partitions;
-    }
-
-    private List<Trip.Leg> getLegs(PtFlagEncoder encoder, Translation tr, QueryGraph queryGraph, PtTravelTimeWeighting weighting, List<List<Label.Transition>> partitions) {
-        return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, encoder, weighting, tr).stream()).collect(Collectors.toList());
-    }
-
-    private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
-        final InstructionList instructions = new InstructionList(tr);
-        for (int i = 0; i< legs.size(); ++i) {
-            Trip.Leg leg = legs.get(i);
-            if (leg instanceof Trip.WalkLeg) {
-                final Trip.WalkLeg walkLeg = ((Trip.WalkLeg) leg);
-                instructions.addAll(walkLeg.instructions.subList(0, i < legs.size() - 1 ? walkLeg.instructions.size() - 1 : walkLeg.instructions.size()));
-            } else if (leg instanceof Trip.PtLeg) {
-                final Trip.PtLeg ptLeg = ((Trip.PtLeg) leg);
-                final PointList pl;
-                if (!ptLeg.isInSameVehicleAsPrevious) {
-                    pl = new PointList();
-                    final Instruction departureInstruction = new Instruction(Instruction.PT_START_TRIP, ptLeg.trip_headsign, InstructionAnnotation.EMPTY, pl);
-                    departureInstruction.setDistance(leg.getDistance());
-                    departureInstruction.setTime(ptLeg.travelTime);
-                    instructions.add(departureInstruction);
-                } else {
-                    pl = instructions.get(instructions.size()-2).getPoints();
-                }
-                pl.add(ptLeg.boardStop.geometry.getY(), ptLeg.boardStop.geometry.getX());
-                for (Trip.Stop stop : ptLeg.stops.subList(0, ptLeg.stops.size()-1)) {
-                    pl.add(stop.geometry.getY(), stop.geometry.getX());
-                }
-                final PointList arrivalPointList = new PointList();
-                final Trip.Stop arrivalStop = ptLeg.stops.get(ptLeg.stops.size()-1);
-                arrivalPointList.add(arrivalStop.geometry.getY(), arrivalStop.geometry.getX());
-                Instruction arrivalInstruction = new Instruction(Instruction.PT_END_TRIP, arrivalStop.name, InstructionAnnotation.EMPTY, arrivalPointList);
-                if (ptLeg.isInSameVehicleAsPrevious) {
-                    instructions.replaceLast(arrivalInstruction);
-                } else {
-                    instructions.add(arrivalInstruction);
-                }
-            }
-        }
-        return instructions;
-    }
-
     private PointList pointListFrom(List<QueryResult> queryResults) {
         PointList waypoints = new PointList(queryResults.size(), true);
         for (QueryResult qr : queryResults) {
@@ -407,147 +279,4 @@ private PointList pointListFrom(List<QueryResult> queryResults) {
         return waypoints;
     }
 
-    // We are parsing a string of edges into a hierarchical trip.
-    // One could argue that one should never write a parser
-    // by hand, because it is always ugly, but use a parser library.
-    // The code would then read like a specification of what paths through the graph mean.
-    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, Graph graph, PtFlagEncoder encoder, Weighting weighting, Translation tr) {
-        if (GtfsStorage.EdgeType.ENTER_PT == path.get(1).edge.edgeType) {
-            final GtfsStorage.FeedIdWithTimezone feedIdWithTimezone = gtfsStorage.getTimeZones().get(path.get(1).edge.timeZoneId);
-            final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedIdWithTimezone.feedId);
-            List<Trip.Leg> result = new ArrayList<>();
-            long boardTime = -1;
-            List<Label.Transition> partition = null;
-            for (int i = 1; i < path.size(); i++) {
-                Label.Transition transition = path.get(i);
-                Label.EdgeLabel edge = path.get(i).edge;
-                if (edge.edgeType == GtfsStorage.EdgeType.BOARD) {
-                    boardTime = transition.label.currentTime;
-                    partition = new ArrayList<>();
-                }
-                if (partition != null) {
-                    partition.add(path.get(i));
-                }
-                if (EnumSet.of(GtfsStorage.EdgeType.TRANSFER, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK).contains(edge.edgeType)) {
-                    Geometry lineString = lineStringFromEdges(partition);
-                    String tripId = gtfsStorage.getExtraStrings().get(partition.get(0).edge.edgeIteratorState.getEdge());
-                    final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripId);
-                    partition.stream()
-                            .filter(e -> EnumSet.of(GtfsStorage.EdgeType.HOP, GtfsStorage.EdgeType.BOARD, GtfsStorage.EdgeType.DWELL).contains(e.edge.edgeType))
-                            .forEach(stopsFromBoardHopDwellEdges::next);
-                    stopsFromBoardHopDwellEdges.finish();
-                    List<Trip.Stop> stops = stopsFromBoardHopDwellEdges.stops;
-
-                    com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripId);
-                    result.add(new Trip.PtLeg(
-                            feedIdWithTimezone.feedId,partition.get(0).edge.nTransfers == 0,
-                            stops.get(0),
-                            tripId,
-                            trip.route_id,
-                            edges(partition).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
-                            new Date(boardTime),
-                            stops,
-                            partition.stream().mapToDouble(t -> t.edge.distance).sum(),
-                            path.get(i-1).label.currentTime - boardTime,
-                            new Date(path.get(i-1).label.currentTime),
-                            lineString));
-                    partition = null;
-                }
-            }
-            return result;
-        } else {
-            InstructionList instructions = new InstructionList(tr);
-            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph, weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
-            int prevEdgeId = -1;
-            for (int i=1; i<path.size(); i++) {
-                EdgeIteratorState edge = path.get(i).edge.edgeIteratorState;
-                instructionsFromEdges.next(edge, i, prevEdgeId);
-                prevEdgeId = edge.getEdge();
-            }
-            instructionsFromEdges.finish();
-            final Instant departureTime = Instant.ofEpochMilli(path.get(0).label.currentTime);
-            final Instant arrivalTime = Instant.ofEpochMilli(path.get(path.size() - 1).label.currentTime);
-            return Collections.singletonList(new Trip.WalkLeg(
-                    "Walk",
-                    Date.from(departureTime),
-                    edges(path).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
-                    lineStringFromEdges(path),
-                    edges(path).mapToDouble(edgeLabel -> edgeLabel.distance).sum(),
-                    instructions.stream().collect(Collectors.toCollection(() -> new InstructionList(tr))),
-                    Date.from(arrivalTime)));
-        }
-    }
-
-    private Stream<Label.EdgeLabel> edges(List<Label.Transition> path) {
-        return path.stream().filter(t -> t.edge != null).map(t -> t.edge);
-    }
-
-    private Geometry lineStringFromEdges(List<Label.Transition> transitions) {
-        List<Coordinate> coordinates = new ArrayList<>();
-        final Iterator<Label.Transition> iterator = transitions.iterator();
-        iterator.next();
-        coordinates.addAll(toCoordinateArray(iterator.next().edge.edgeIteratorState.fetchWayGeometry(3)));
-        iterator.forEachRemaining(transition -> {
-            coordinates.addAll(toCoordinateArray(transition.edge.edgeIteratorState.fetchWayGeometry(2)));
-        });
-        return geometryFactory.createLineString(coordinates.toArray(new Coordinate[coordinates.size()]));
-    }
-
-
-    public static List<Coordinate> toCoordinateArray(PointList pointList) {
-        List<Coordinate> coordinates = new ArrayList<>(pointList.size());
-        for (int i=0; i<pointList.size(); i++) {
-            coordinates.add(pointList.getDimension() == 3 ?
-                    new Coordinate(pointList.getLon(i), pointList.getLat(i)) :
-                    new Coordinate(pointList.getLon(i), pointList.getLat(i), pointList.getEle(i)));
-        }
-        return coordinates;
-    }
-
-    private class StopsFromBoardHopDwellEdges {
-
-        private final String tripId;
-        private final List<Trip.Stop> stops = new ArrayList<>();
-        private final GTFSFeed gtfsFeed;
-        private long arrivalTimeFromHopEdge;
-        private Stop stop = null;
-
-        StopsFromBoardHopDwellEdges(String feedId, String tripId) {
-            this.tripId = tripId;
-            this.gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedId);
-        }
-
-        void next(Label.Transition t) {
-            long departureTime;
-            switch (t.edge.edgeType) {
-                case BOARD:
-                    stop = findStop(t);
-                    departureTime = t.label.currentTime;
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, Date.from(Instant.ofEpochMilli(departureTime))));
-                    break;
-                case HOP:
-                    stop = findStop(t);
-                    arrivalTimeFromHopEdge = t.label.currentTime;
-                    break;
-                case DWELL:
-                    departureTime = t.label.currentTime;
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), Date.from(Instant.ofEpochMilli(departureTime))));
-                    break;
-                default:
-                    throw new RuntimeException();
-            }
-        }
-
-        private Stop findStop(Label.Transition t) {
-            int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
-            StopTime stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripId, stopSequence));
-            return gtfsFeed.stops.get(stopTime.stop_id);
-        }
-
-        void finish() {
-            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), null));
-        }
-
-    }
-
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java
new file mode 100644
index 0000000000..4f6a9a4459
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java
@@ -0,0 +1,223 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.routing.util.AllEdgesIterator;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
+
+class GraphSupport {
+
+    private GraphSupport() {}
+
+
+    /**
+     * Creates a read-only view of a Graph, presenting the sub-graph consisting of all the nodes; and those
+     * edges accepted by edgeFilter.
+     *
+     * Devised to pass into LocationIndexTree, and works fine there (because LocationIndexTree doesn't index nodes
+     * directly, but only goes through the edges). Probably not useful in other contexts.
+     *
+     * @param baseGraph The graph to construct a view for.
+     * @param edgeFilter The filter to filter with.
+     * @return The filtered view.
+     */
+    static Graph filteredView(GraphHopperStorage baseGraph, EdgeFilter edgeFilter) {
+        return new Graph() {
+            @Override
+            public Graph getBaseGraph() {
+                return baseGraph;
+            }
+
+            @Override
+            public int getNodes() {
+                return baseGraph.getNodes();
+            }
+
+            @Override
+            public NodeAccess getNodeAccess() {
+                return baseGraph.getNodeAccess();
+            }
+
+            @Override
+            public BBox getBounds() {
+                return baseGraph.getBounds();
+            }
+
+            @Override
+            public EdgeIteratorState edge(int a, int b) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirections) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public AllEdgesIterator getAllEdges() {
+                final AllEdgesIterator edge = baseGraph.getAllEdges();
+                return new AllEdgesIterator() {
+                    @Override
+                    public int getMaxId() {
+                        return edge.getMaxId();
+                    }
+
+                    @Override
+                    public boolean next() {
+                        while (edge.next()) {
+                            if (edgeFilter.accept(edge)) {
+                                return true;
+                            }
+                        }
+                        return false;
+                    }
+
+                    @Override
+                    public int getEdge() {
+                        return edge.getEdge();
+                    }
+
+                    @Override
+                    public int getBaseNode() {
+                        return edge.getBaseNode();
+                    }
+
+                    @Override
+                    public int getAdjNode() {
+                        return edge.getAdjNode();
+                    }
+
+                    @Override
+                    public PointList fetchWayGeometry(int mode) {
+                        return edge.fetchWayGeometry(mode);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setWayGeometry(PointList list) {
+                        edge.setWayGeometry(list);
+                        return this;
+                    }
+
+                    @Override
+                    public double getDistance() {
+                        return edge.getDistance();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setDistance(double dist) {
+                        edge.setDistance(dist);
+                        return this;
+                    }
+
+                    @Override
+                    public long getFlags() {
+                        return edge.getFlags();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setFlags(long flags) {
+                        edge.setFlags(flags);
+                        return this;
+                    }
+
+                    @Override
+                    public int getAdditionalField() {
+                        return edge.getAdditionalField();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setAdditionalField(int value) {
+                        edge.setAdditionalField(value);
+                        return this;
+                    }
+
+                    @Override
+                    public boolean isForward(FlagEncoder encoder) {
+                        return edge.isForward(encoder);
+                    }
+
+                    @Override
+                    public boolean isBackward(FlagEncoder encoder) {
+                        return edge.isBackward(encoder);
+                    }
+
+                    @Override
+                    public boolean getBool(int key, boolean _default) {
+                        return edge.getBool(key, _default);
+                    }
+
+                    @Override
+                    public String getName() {
+                        return edge.getName();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setName(String name) {
+                        edge.setName(name);
+                        return this;
+                    }
+
+                    @Override
+                    public EdgeIteratorState detach(boolean reverse) {
+                        return edge.detach(reverse);
+                    }
+
+                    @Override
+                    public EdgeIteratorState copyPropertiesTo(EdgeIteratorState e) {
+                        throw new UnsupportedOperationException();
+                    }
+                };
+            }
+
+            @Override
+            public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeExplorer createEdgeExplorer() {
+                return baseGraph.createEdgeExplorer(edgeFilter);
+            }
+
+            @Override
+            public Graph copyTo(Graph g) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public GraphExtension getExtension() {
+                throw new UnsupportedOperationException();
+            }
+        };
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 424b8b6df6..33a66522c7 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -130,6 +130,7 @@ public void readGraph() {
                 setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
                 exitEdge.setName(stop.stop_name);
             }
+            gtfsStorage.getStationNodes().put(entry.stopId, streetNode);
         }
     }
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
index 0befedbb5a..916af7c6cb 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
@@ -99,6 +99,8 @@ public int hashCode() {
 	private Map<GtfsRealtime.TripDescriptor, int[]> boardEdgesForTrip;
 	private Map<GtfsRealtime.TripDescriptor, int[]> leaveEdgesForTrip;
 
+	private Map<String, Integer> stationNodes;
+
 	enum EdgeType {
 		HIGHWAY, ENTER_TIME_EXPANDED_NETWORK, LEAVE_TIME_EXPANDED_NETWORK, ENTER_PT, EXIT_PT, HOP, DWELL, BOARD, ALIGHT, OVERNIGHT, TRANSFER, WAIT, WAIT_ARRIVAL
     }
@@ -189,6 +191,7 @@ private void init() {
 		this.fares = data.getTreeMap("fares");
 		this.boardEdgesForTrip = data.getHashMap("boardEdgesForTrip");
 		this.leaveEdgesForTrip = data.getHashMap("leaveEdgesForTrip");
+		this.stationNodes = data.getHashMap("stationNodes");
 	}
 
 	void loadGtfsFromFile(String id, ZipFile zip) {
@@ -280,4 +283,8 @@ public long getCapacity() {
 		return Collections.unmodifiableMap(gtfsFeeds);
 	}
 
+	Map<String, Integer> getStationNodes() {
+		return stationNodes;
+	}
+
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index 3430960131..de91b2446d 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -69,21 +69,11 @@
                 .thenComparing(Comparator.comparingLong(l1 -> l1.nTransfers))
                 .thenComparing(Comparator.comparingLong(l1 -> l1.nWalkDistanceConstraintViolations))
                 .thenComparing(Comparator.comparingLong(l -> departureTimeCriterion(l) != null ? departureTimeCriterion(l) : 0));
-        fromHeap = new PriorityQueue<>(new Comparator<Label>() {
-            @Override
-            public int compare(Label o1, Label o) {
-                return queueComparator.compare(o1, o);
-            }
-
-            @Override
-            public boolean equals(Object obj) {
-                return false;
-            }
-        });
+        fromHeap = new PriorityQueue<>(queueComparator);
         fromMap = HashMultimap.create();
     }
 
-    Stream<Label> calcPaths(int from, Set<Integer> to, Instant startTime) {
+    Stream<Label> calcPaths(int from, int to, Instant startTime) {
         this.startTime = startTime.toEpochMilli();
         final Stream<Label> labels = StreamSupport.stream(new MultiCriteriaLabelSettingSpliterator(from, to), false)
                 .limit(maxVisitedNodes)
@@ -95,7 +85,7 @@ public boolean equals(Object obj) {
             @Override
             public boolean tryAdvance(Consumer<? super Label> action) {
                 while (spliterator.tryAdvance(label -> current = label)) {
-                    if (to.contains(current.adjNode)) {
+                    if (to == current.adjNode) {
                         action.accept(current);
                         solutions.add(current);
                         return true;
@@ -109,17 +99,17 @@ public boolean tryAdvance(Consumer<? super Label> action) {
 
     private class MultiCriteriaLabelSettingSpliterator extends Spliterators.AbstractSpliterator<Label> {
 
-        private final Set<Integer> to;
+        private final int to;
         private final Set<Label> targetLabels;
 
-        MultiCriteriaLabelSettingSpliterator(int from, Set<Integer> to) {
+        MultiCriteriaLabelSettingSpliterator(int from, int to) {
             super(0, 0);
             this.to = to;
             targetLabels = new HashSet<>();
             Label label = new Label(startTime, EdgeIterator.NO_EDGE, from, 0, 0, 0.0, null, 0, null);
             fromMap.put(from, label);
             fromHeap.add(label);
-            if (to.contains(from)) {
+            if (to == from) {
                 targetLabels.add(label);
             }
         }
@@ -159,11 +149,11 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                     Label nEdge = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, label);
                     if (isNotDominatedByAnyOf(nEdge, sptEntries) && isNotDominatedByAnyOf(nEdge, targetLabels)) {
                         removeDominated(nEdge, sptEntries);
-                        if (to.contains(edge.getAdjNode())) {
+                        if (to == edge.getAdjNode()) {
                             removeDominated(nEdge, targetLabels);
                         }
                         fromMap.put(edge.getAdjNode(), nEdge);
-                        if (to.contains(edge.getAdjNode())) {
+                        if (to == edge.getAdjNode()) {
                             targetLabels.add(nEdge);
                         }
                         fromHeap.add(nEdge);
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
new file mode 100644
index 0000000000..1d0b29c4e6
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -0,0 +1,322 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.model.Stop;
+import com.conveyal.gtfs.model.StopTime;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.Trip;
+import com.graphhopper.gtfs.fare.Fares;
+import com.graphhopper.routing.InstructionsFromEdges;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.util.*;
+import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.Geometry;
+import com.vividsolutions.jts.geom.GeometryFactory;
+import org.mapdb.Fun;
+
+import java.time.Duration;
+import java.time.Instant;
+import java.time.LocalDateTime;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static com.graphhopper.reader.gtfs.Label.reverseEdges;
+
+class TripFromLabel {
+
+    PathWrapper parseSolutionIntoPath(Instant initialTime, boolean arriveBy, PtFlagEncoder encoder, Translation tr, Graph queryGraph, PtTravelTimeWeighting weighting, Label solution, PointList waypoints) {
+        PathWrapper path = new PathWrapper();
+        path.setWaypoints(waypoints);
+
+        final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
+        path.getLegs().addAll(legs);
+
+        final InstructionList instructions = getInstructions(tr, path.getLegs());
+        path.setInstructions(instructions);
+        PointList pointsList = new PointList();
+        for (Instruction instruction : instructions) {
+            pointsList.add(instruction.getPoints());
+        }
+        path.addDebugInfo(String.format("Violations: %d, Last leg dist: %f", solution.nWalkDistanceConstraintViolations, solution.walkDistanceOnCurrentLeg));
+        path.setPoints(pointsList);
+        path.setDistance(path.getLegs().stream().mapToDouble(Trip.Leg::getDistance).sum());
+        path.setTime((solution.currentTime - initialTime.toEpochMilli()) * (arriveBy ? -1 : 1));
+        if (solution.departureTime != null) {
+            path.setFirstPtLegDeparture(solution.departureTime);
+        }
+        path.setNumChanges((int) path.getLegs().stream()
+                .filter(l -> l instanceof Trip.PtLeg)
+                .filter(l -> !((Trip.PtLeg) l).isInSameVehicleAsPrevious)
+                .count() - 1);
+        com.graphhopper.gtfs.fare.Trip faresTrip = new com.graphhopper.gtfs.fare.Trip();
+        path.getLegs().stream()
+                .filter(leg -> leg instanceof Trip.PtLeg)
+                .map(leg -> (Trip.PtLeg) leg)
+                .findFirst()
+                .ifPresent(firstPtLeg -> {
+                    LocalDateTime firstPtDepartureTime = GtfsHelper.localDateTimeFromDate(firstPtLeg.departureTime);
+                    path.getLegs().stream()
+                            .filter(leg -> leg instanceof Trip.PtLeg)
+                            .map(leg -> (Trip.PtLeg) leg)
+                            .map(ptLeg -> {
+                                final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(ptLeg.feed_id);
+                                return new com.graphhopper.gtfs.fare.Trip.Segment(gtfsFeed.trips.get(ptLeg.trip_id).route_id, Duration.between(firstPtDepartureTime, GtfsHelper.localDateTimeFromDate(ptLeg.departureTime)).getSeconds(), gtfsFeed.stops.get(ptLeg.stops.get(0).stop_id).zone_id, gtfsFeed.stops.get(ptLeg.stops.get(ptLeg.stops.size() - 1).stop_id).zone_id, ptLeg.stops.stream().map(s -> gtfsFeed.stops.get(s.stop_id).zone_id).collect(Collectors.toSet()));
+                            })
+                            .forEach(faresTrip.segments::add);
+                    Fares.cheapestFare(gtfsStorage.getFares(), faresTrip)
+                            .ifPresent(amount -> path.setFare(amount.getAmount()));
+                });
+        return path;
+    }
+
+    private List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, Graph queryGraph, PtTravelTimeWeighting weighting, Label solution) {
+        List<Label.Transition> transitions = new ArrayList<>();
+        if (arriveBy) {
+            reverseEdges(solution, queryGraph, encoder, false)
+                    .forEach(transitions::add);
+        } else {
+            reverseEdges(solution, queryGraph, encoder, true)
+                    .forEach(transitions::add);
+            Collections.reverse(transitions);
+        }
+
+
+        List<List<Label.Transition>> partitions = getPartitions(transitions);
+
+        return getLegs(tr, queryGraph, weighting, partitions);
+    }
+
+    private List<List<Label.Transition>> getPartitions(List<Label.Transition> transitions) {
+        List<List<Label.Transition>> partitions = new ArrayList<>();
+        partitions.add(new ArrayList<>());
+        final Iterator<Label.Transition> iterator = transitions.iterator();
+        partitions.get(partitions.size()-1).add(iterator.next());
+        iterator.forEachRemaining(transition -> {
+            final List<Label.Transition> previous = partitions.get(partitions.size() - 1);
+            final Label.EdgeLabel previousEdge = previous.get(previous.size() - 1).edge;
+            if (previousEdge != null && (transition.edge.edgeType == GtfsStorage.EdgeType.ENTER_PT || previousEdge.edgeType == GtfsStorage.EdgeType.EXIT_PT)) {
+                final ArrayList<Label.Transition> p = new ArrayList<>();
+                p.add(new Label.Transition(previous.get(previous.size()-1).label, null));
+                partitions.add(p);
+            }
+            partitions.get(partitions.size()-1).add(transition);
+        });
+        return partitions;
+    }
+
+    private List<Trip.Leg> getLegs(Translation tr, Graph queryGraph, PtTravelTimeWeighting weighting, List<List<Label.Transition>> partitions) {
+        return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, weighting, tr).stream()).collect(Collectors.toList());
+    }
+
+    private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
+        final InstructionList instructions = new InstructionList(tr);
+        for (int i = 0; i< legs.size(); ++i) {
+            Trip.Leg leg = legs.get(i);
+            if (leg instanceof Trip.WalkLeg) {
+                final Trip.WalkLeg walkLeg = ((Trip.WalkLeg) leg);
+                instructions.addAll(walkLeg.instructions.subList(0, i < legs.size() - 1 ? walkLeg.instructions.size() - 1 : walkLeg.instructions.size()));
+            } else if (leg instanceof Trip.PtLeg) {
+                final Trip.PtLeg ptLeg = ((Trip.PtLeg) leg);
+                final PointList pl;
+                if (!ptLeg.isInSameVehicleAsPrevious) {
+                    pl = new PointList();
+                    final Instruction departureInstruction = new Instruction(Instruction.PT_START_TRIP, ptLeg.trip_headsign, InstructionAnnotation.EMPTY, pl);
+                    departureInstruction.setDistance(leg.getDistance());
+                    departureInstruction.setTime(ptLeg.travelTime);
+                    instructions.add(departureInstruction);
+                } else {
+                    pl = instructions.get(instructions.size()-2).getPoints();
+                }
+                pl.add(ptLeg.stops.get(0).geometry.getY(), ptLeg.stops.get(0).geometry.getX());
+                for (Trip.Stop stop : ptLeg.stops.subList(0, ptLeg.stops.size()-1)) {
+                    pl.add(stop.geometry.getY(), stop.geometry.getX());
+                }
+                final PointList arrivalPointList = new PointList();
+                final Trip.Stop arrivalStop = ptLeg.stops.get(ptLeg.stops.size()-1);
+                arrivalPointList.add(arrivalStop.geometry.getY(), arrivalStop.geometry.getX());
+                Instruction arrivalInstruction = new Instruction(Instruction.PT_END_TRIP, arrivalStop.stop_name, InstructionAnnotation.EMPTY, arrivalPointList);
+                if (ptLeg.isInSameVehicleAsPrevious) {
+                    instructions.replaceLast(arrivalInstruction);
+                } else {
+                    instructions.add(arrivalInstruction);
+                }
+            }
+        }
+        return instructions;
+    }
+
+    private class StopsFromBoardHopDwellEdges {
+
+        private final String tripId;
+        private final List<Trip.Stop> stops = new ArrayList<>();
+        private final GTFSFeed gtfsFeed;
+        private long arrivalTimeFromHopEdge;
+        private Stop stop = null;
+
+        StopsFromBoardHopDwellEdges(String feedId, String tripId) {
+            this.tripId = tripId;
+            this.gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedId);
+        }
+
+        void next(Label.Transition t) {
+            long departureTime;
+            switch (t.edge.edgeType) {
+                case BOARD:
+                    stop = findStop(t);
+                    departureTime = t.label.currentTime;
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, Date.from(Instant.ofEpochMilli(departureTime))));
+                    break;
+                case HOP:
+                    stop = findStop(t);
+                    arrivalTimeFromHopEdge = t.label.currentTime;
+                    break;
+                case DWELL:
+                    departureTime = t.label.currentTime;
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), Date.from(Instant.ofEpochMilli(departureTime))));
+                    break;
+                default:
+                    throw new RuntimeException();
+            }
+        }
+
+        private Stop findStop(Label.Transition t) {
+            int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
+            StopTime stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripId, stopSequence));
+            return gtfsFeed.stops.get(stopTime.stop_id);
+        }
+
+        void finish() {
+            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(Instant.ofEpochMilli(arrivalTimeFromHopEdge)), null));
+        }
+
+    }
+
+
+    private final GtfsStorage gtfsStorage;
+    private final GeometryFactory geometryFactory = new GeometryFactory();
+
+    TripFromLabel(GtfsStorage gtfsStorage) {
+
+        this.gtfsStorage = gtfsStorage;
+    }
+
+    // We are parsing a string of edges into a hierarchical trip.
+    // One could argue that one should never write a parser
+    // by hand, because it is always ugly, but use a parser library.
+    // The code would then read like a specification of what paths through the graph mean.
+    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, Graph graph, Weighting weighting, Translation tr) {
+        if (path.size() <= 1) {
+            return Collections.emptyList();
+        }
+        if (GtfsStorage.EdgeType.ENTER_PT == path.get(1).edge.edgeType) {
+            final GtfsStorage.FeedIdWithTimezone feedIdWithTimezone = gtfsStorage.getTimeZones().get(path.get(1).edge.timeZoneId);
+            final GTFSFeed gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedIdWithTimezone.feedId);
+            List<Trip.Leg> result = new ArrayList<>();
+            long boardTime = -1;
+            List<Label.Transition> partition = null;
+            for (int i = 1; i < path.size(); i++) {
+                Label.Transition transition = path.get(i);
+                Label.EdgeLabel edge = path.get(i).edge;
+                if (edge.edgeType == GtfsStorage.EdgeType.BOARD) {
+                    boardTime = transition.label.currentTime;
+                    partition = new ArrayList<>();
+                }
+                if (partition != null) {
+                    partition.add(path.get(i));
+                }
+                if (EnumSet.of(GtfsStorage.EdgeType.TRANSFER, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK).contains(edge.edgeType)) {
+                    Geometry lineString = lineStringFromEdges(partition);
+                    String tripId = gtfsStorage.getExtraStrings().get(partition.get(0).edge.edgeIteratorState.getEdge());
+                    final StopsFromBoardHopDwellEdges stopsFromBoardHopDwellEdges = new StopsFromBoardHopDwellEdges(feedIdWithTimezone.feedId, tripId);
+                    partition.stream()
+                            .filter(e -> EnumSet.of(GtfsStorage.EdgeType.HOP, GtfsStorage.EdgeType.BOARD, GtfsStorage.EdgeType.DWELL).contains(e.edge.edgeType))
+                            .forEach(stopsFromBoardHopDwellEdges::next);
+                    stopsFromBoardHopDwellEdges.finish();
+                    List<Trip.Stop> stops = stopsFromBoardHopDwellEdges.stops;
+
+                    com.conveyal.gtfs.model.Trip trip = gtfsFeed.trips.get(tripId);
+                    result.add(new Trip.PtLeg(
+                            feedIdWithTimezone.feedId,partition.get(0).edge.nTransfers == 0,
+                            tripId,
+                            trip.route_id,
+                            edges(partition).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
+                            new Date(boardTime),
+                            stops,
+                            partition.stream().mapToDouble(t -> t.edge.distance).sum(),
+                            path.get(i-1).label.currentTime - boardTime,
+                            new Date(path.get(i-1).label.currentTime),
+                            lineString));
+                    partition = null;
+                }
+            }
+            return result;
+        } else {
+            InstructionList instructions = new InstructionList(tr);
+            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph, weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
+            int prevEdgeId = -1;
+            for (int i=1; i<path.size(); i++) {
+                EdgeIteratorState edge = path.get(i).edge.edgeIteratorState;
+                instructionsFromEdges.next(edge, i, prevEdgeId);
+                prevEdgeId = edge.getEdge();
+            }
+            instructionsFromEdges.finish();
+            final Instant departureTime = Instant.ofEpochMilli(path.get(0).label.currentTime);
+            final Instant arrivalTime = Instant.ofEpochMilli(path.get(path.size() - 1).label.currentTime);
+            return Collections.singletonList(new Trip.WalkLeg(
+                    "Walk",
+                    Date.from(departureTime),
+                    edges(path).map(edgeLabel -> edgeLabel.edgeIteratorState).collect(Collectors.toList()),
+                    lineStringFromEdges(path),
+                    edges(path).mapToDouble(edgeLabel -> edgeLabel.distance).sum(),
+                    instructions.stream().collect(Collectors.toCollection(() -> new InstructionList(tr))),
+                    Date.from(arrivalTime)));
+        }
+    }
+
+    private Stream<Label.EdgeLabel> edges(List<Label.Transition> path) {
+        return path.stream().filter(t -> t.edge != null).map(t -> t.edge);
+    }
+
+    private Geometry lineStringFromEdges(List<Label.Transition> transitions) {
+        List<Coordinate> coordinates = new ArrayList<>();
+        final Iterator<Label.Transition> iterator = transitions.iterator();
+        iterator.next();
+        coordinates.addAll(toCoordinateArray(iterator.next().edge.edgeIteratorState.fetchWayGeometry(3)));
+        iterator.forEachRemaining(transition -> coordinates.addAll(toCoordinateArray(transition.edge.edgeIteratorState.fetchWayGeometry(2))));
+        return geometryFactory.createLineString(coordinates.toArray(new Coordinate[coordinates.size()]));
+    }
+
+
+    private static List<Coordinate> toCoordinateArray(PointList pointList) {
+        List<Coordinate> coordinates = new ArrayList<>(pointList.size());
+        for (int i=0; i<pointList.size(); i++) {
+            coordinates.add(pointList.getDimension() == 3 ?
+                    new Coordinate(pointList.getLon(i), pointList.getLat(i)) :
+                    new Coordinate(pointList.getLon(i), pointList.getLat(i), pointList.getEle(i)));
+        }
+        return coordinates;
+    }
+
+
+
+}
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index 847b909353..c7633f6efe 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -64,7 +64,7 @@ public static void init() {
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
     }
@@ -253,8 +253,8 @@ public void testRoute5() {
         assertFalse(route.hasErrors());
         assertFalse(route.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(8, 10), route.getBest().getTime(), 0.1);
-        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(0)).tripId));
-        assertEquals("Using expected route", "AB1", (((Trip.PtLeg) route.getBest().getLegs().get(1)).tripId));
+        assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(0)).trip_id));
+        assertEquals("Using expected route", "AB1", (((Trip.PtLeg) route.getBest().getLegs().get(1)).trip_id));
         assertEquals("Paid expected fare", 250, route.getBest().getFare().multiply(BigDecimal.valueOf(100)).intValue()); // Two legs, no transfers allowed. Need two 'p' tickets costing 125 cents each.
     }
 
@@ -305,7 +305,7 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
         route = graphHopper.route(ghRequest);
         assertFalse(route.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(9, 0), route.getBest().getTime());
-        assertEquals("Using expected trip", "AAMV1", (((Trip.PtLeg) route.getBest().getLegs().get(0)).tripId));
+        assertEquals("Using expected trip", "AAMV1", (((Trip.PtLeg) route.getBest().getLegs().get(0)).trip_id));
         assertEquals("Paid expected fare", 525, route.getBest().getFare().multiply(BigDecimal.valueOf(100)).intValue());
 
     }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 99168b8548..208699dbe4 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -59,7 +59,7 @@ public static void init() {
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
-        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
         graphHopperFactory = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage);
     }
 
@@ -187,7 +187,7 @@ public void testBlockTrips() {
                 .setScheduleRelationship(SKIPPED);
 
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
-        assertEquals("I can still use the AB1 trip", "AB1", (((Trip.PtLeg) response.getBest().getLegs().get(0)).tripId));
+        assertEquals("I can still use the AB1 trip", "AB1", (((Trip.PtLeg) response.getBest().getLegs().get(0)).trip_id));
         assertEquals("It takes", time(1,20), response.getBest().getTime());
     }
 
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index 23271611d8..98ff1d417b 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -337,7 +337,7 @@ public void testMonacoVia() {
         assertEquals("Turn left", resultJson.get(5).get("text"));
         assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
 
-        assertEquals("Stopover 1", resultJson.get(20).get("text"));
+        assertEquals("Waypoint 1", resultJson.get(20).get("text"));
 
         assertEquals("Continue onto Avenue Albert II", resultJson.get(31).get("text"));
         assertEquals("Turn left", resultJson.get(32).get("text"));
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
index 367a82b5ce..8833d7d76d 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStar.java
@@ -21,6 +21,7 @@
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIteratorState;
 
@@ -32,10 +33,12 @@
 public class DebugAStar extends AStar implements DebugAlgo {
     private final GraphicsWrapper mg;
     private Graphics2D g2;
+    private NodeAccess na;
 
     public DebugAStar(Graph graph, Weighting type, TraversalMode tMode, GraphicsWrapper mg) {
         super(graph, type, tMode);
         this.mg = mg;
+        na = graph.getNodeAccess();
     }
 
     @Override
@@ -46,7 +49,7 @@ public void setGraphics2D(Graphics2D g2) {
     @Override
     public void updateBestPath(EdgeIteratorState es, SPTEntry bestEE, int currLoc) {
         if (g2 != null) {
-            mg.plotNode(g2, currLoc, Color.YELLOW);
+            mg.plotEdge(g2, na.getLat(bestEE.parent.adjNode), na.getLon(bestEE.parent.adjNode), na.getLat(currLoc), na.getLon(currLoc), .8f);
         }
         super.updateBestPath(es, bestEE, currLoc);
     }
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
index 7984f6e7ba..8c2b04ed5c 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugDijkstraBidirection.java
@@ -21,6 +21,7 @@
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIteratorState;
 
@@ -32,10 +33,12 @@
 public class DebugDijkstraBidirection extends DijkstraBidirectionRef implements DebugAlgo {
     private final GraphicsWrapper mg;
     private Graphics2D g2;
+    private NodeAccess na;
 
     public DebugDijkstraBidirection(Graph graph, Weighting type, TraversalMode tMode, GraphicsWrapper mg) {
         super(graph, type, tMode);
         this.mg = mg;
+        na = graph.getNodeAccess();
     }
 
     @Override
@@ -46,7 +49,7 @@ public void setGraphics2D(Graphics2D g2) {
     @Override
     public void updateBestPath(EdgeIteratorState es, SPTEntry bestEE, int currLoc) {
         if (g2 != null) {
-            mg.plotNode(g2, currLoc, Color.YELLOW);
+            mg.plotEdge(g2, na.getLat(bestEE.parent.adjNode), na.getLon(bestEE.parent.adjNode), na.getLat(currLoc), na.getLon(currLoc), .8f);
         }
         // System.out.println("new node:" + currLoc);
         super.updateBestPath(es, bestEE, currLoc);
diff --git a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
index d7b29efc84..02aa88ae36 100644
--- a/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
+++ b/tools/src/main/java/com/graphhopper/ui/GraphicsWrapper.java
@@ -123,7 +123,16 @@ public void plotNode(Graphics2D g2, int loc, Color c) {
         plotNode(g2, loc, c, 4);
     }
 
+
     public void plotNode(Graphics2D g2, int loc, Color c, int size) {
+        plotNode(g2, loc, c, size);
+    }
+
+    public void plotNode(Graphics2D g2, int loc, Color c, int size, String text) {
+        plotNode(g2, na, loc, c, 4, "");
+    }
+
+    public void plotNode(Graphics2D g2, NodeAccess na, int loc, Color c, int size, String text) {
         double lat = na.getLatitude(loc);
         double lon = na.getLongitude(loc);
         if (lat < bounds.minLat || lat > bounds.maxLat || lon < bounds.minLon || lon > bounds.maxLon) {
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 21cc0cce90..44a94e10af 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -268,7 +268,7 @@ public void paintComponent(Graphics2D g2) {
                     g2.setColor(color);
                     boolean fwd = encoder.isForward(edge.getFlags());
                     boolean bwd = encoder.isBackward(edge.getFlags());
-                    float width = 1.2f;
+                    float width = speed > 90? 1f : 0.8f;
                     if (fwd && !bwd) {
                         mg.plotDirectedEdge(g2, lat, lon, lat2, lon2, width);
                     } else {
@@ -317,6 +317,12 @@ public void paintComponent(final Graphics2D g2) {
 //                    mg.plotText(g2, lat, lon, nodeId + ": " + dist);
 //                    mg.plotNode(g2, nodeId, Color.red);
 //                }
+                Color red = Color.red.brighter();
+                g2.setColor(red);
+                mg.plotNode(g2, qGraph.getNodeAccess(), fromRes.getClosestNode(), red, 10, "");
+                mg.plotNode(g2, qGraph.getNodeAccess(), toRes.getClosestNode(), red, 10, "");
+
+                g2.setColor(Color.blue.brighter().brighter());
                 path = algo.calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
                 sw.stop();
 
@@ -329,8 +335,8 @@ public void paintComponent(final Graphics2D g2) {
                 logger.info("found path in " + sw.getSeconds() + "s with nodes:"
                         + path.calcNodes().size() + ", millis: " + path.getTime()
                         + ", visited nodes:" + algo.getVisitedNodes());
-                g2.setColor(Color.BLUE.brighter().brighter());
-                plotPath(path, g2, 2);
+                g2.setColor(red);
+                plotPath(path, g2, 4);
             }
         });
 
diff --git a/web/src/main/java/com/graphhopper/http/PtModule.java b/web/src/main/java/com/graphhopper/http/PtModule.java
index 3eac109084..60642f8a1b 100644
--- a/web/src/main/java/com/graphhopper/http/PtModule.java
+++ b/web/src/main/java/com/graphhopper/http/PtModule.java
@@ -58,8 +58,8 @@ GraphHopperStorage createGraphHopperStorage(CmdArgs args, GHDirectory directory,
 
     @Provides
     @Singleton
-    LocationIndex createLocationIndex(GraphHopperStorage graphHopperStorage, GHDirectory directory) {
-        return GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
+    LocationIndex createLocationIndex(GraphHopperStorage graphHopperStorage, GHDirectory directory, PtFlagEncoder ptFlagEncoder) {
+        return GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage, ptFlagEncoder);
     }
 
     @Provides
