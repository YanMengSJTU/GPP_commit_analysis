diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index bef6944d49..fed6ef28c2 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -56,6 +56,7 @@
 import com.graphhopper.routing.util.PrepareRoutingSubnetworks;
 import com.graphhopper.routing.util.PriorityWeighting;
 import com.graphhopper.routing.util.PriorityWithAvoidancesWeighting;
+import com.graphhopper.routing.util.PrivateEdgeFilter;
 import com.graphhopper.routing.util.ShortestWeighting;
 import com.graphhopper.routing.util.ShortestWithAvoidancesWeighting;
 import com.graphhopper.routing.util.TraversalMode;
@@ -926,7 +927,6 @@ public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder
 		Weighting result;
 
 		String avoidanceString = weightingMap.get("avoidances","");
-		System.err.println("AVOID:" + avoidanceString);
 		boolean avoidancesEnabled = avoidanceString.length()>0;
 		if ("shortest".equalsIgnoreCase(weighting))
 		{
@@ -1063,7 +1063,12 @@ public GHResponse route( GHRequest request )
 		visitedSum.set(0);
 
 		FlagEncoder encoder = encodingManager.getEncoder(vehicle);
-		EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+		EdgeFilter edgeFilter;
+		if(!encoder.supports(EscapePrivateWeighting.class) || checkForNoThroughAccess(request)) {
+			edgeFilter = new DefaultEdgeFilter(encoder);
+		} else {
+			edgeFilter = new PrivateEdgeFilter(encoder);
+		}
 
 		StopWatch sw = new StopWatch().start();
 		List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index e86ca2c43d..9b9076cfbe 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -26,7 +26,7 @@
 {
     private final boolean in;
     private final boolean out;
-    private FlagEncoder encoder;
+    protected FlagEncoder encoder;
 
     /**
      * Creates an edges filter which accepts both direction of the specified vehicle.
@@ -44,7 +44,7 @@ public DefaultEdgeFilter( FlagEncoder encoder, boolean in, boolean out )
     }
 
     @Override
-    public final boolean accept( EdgeIteratorState iter )
+    public boolean accept( EdgeIteratorState iter )
     {
         long flags = iter.getFlags();
         return out && encoder.isForward(flags) || in && encoder.isBackward(flags);
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrivateEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/PrivateEdgeFilter.java
new file mode 100644
index 0000000000..a5564c14c3
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/PrivateEdgeFilter.java
@@ -0,0 +1,22 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class PrivateEdgeFilter extends DefaultEdgeFilter
+{
+
+	public PrivateEdgeFilter( FlagEncoder encoder )
+    {
+	    super(encoder);
+    }
+
+	@Override
+	public boolean accept( EdgeIteratorState edgeState )
+	{
+		if(encoder.getLong(edgeState.getFlags(), EscapePrivateWeighting.KEY)>0) {
+			return false;
+		}
+		return super.accept(edgeState);
+	}
+
+}
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index c17e10b185..9b53683644 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -22,6 +22,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import java.io.File;
@@ -33,11 +34,14 @@
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.Matchers;
 import org.mockito.Mockito;
+import org.mockito.internal.verification.VerificationModeFactory;
 
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.util.BanPrivateWeighting;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.EscapePrivateWeighting;
@@ -46,6 +50,7 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.PriorityWeighting;
 import com.graphhopper.routing.util.PriorityWithAvoidancesWeighting;
+import com.graphhopper.routing.util.PrivateEdgeFilter;
 import com.graphhopper.routing.util.ShortestWeighting;
 import com.graphhopper.routing.util.ShortestWithAvoidancesWeighting;
 import com.graphhopper.routing.util.Weighting;
@@ -53,6 +58,7 @@
 import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
@@ -637,4 +643,75 @@ public void testCreatePrivateWeightingWithPriority() {
 		privateWeighting = instance.createPrivateWeighting(weighting, request , graph, unsupportedEncoder);
 		assertEquals(weighting.getClass(), privateWeighting.getClass());
     }
+    
+    @Test
+    public void testIgnorePrivateRoadsOnIndexSearchWhenCannotStartOnPrivate() {
+    	LocationIndex locationIndex = buildGraphAndMocks("OSCAR");
+        expectNearestEdgeLookups(locationIndex);
+		GHRequest request = new GHRequest(11.1, 50, 11.3, 51);
+		request.getHints().put("private", "false");
+		request.setVehicle("car");
+		instance.route(request);
+		verifyEdgeFilterOnLookup(locationIndex, PrivateEdgeFilter.class);
+    }
+
+    @Test
+    public void testDontIgnorePrivateRoadsOnIndexSearchWhenCanStartOnPrivateWithCar() {
+    	LocationIndex locationIndex = buildGraphAndMocks("OSCAR");
+        expectNearestEdgeLookups(locationIndex);
+		GHRequest request = new GHRequest(11.1, 50, 11.3, 51);
+		request.getHints().put("private", "true");
+		request.setVehicle("car");
+		instance.route(request);
+		verifyEdgeFilterOnLookup(locationIndex, DefaultEdgeFilter.class);
+    }
+    
+    @Test
+    public void testDontIgnorePrivateRoadsOnIndexSearchWhenCanStartOnPrivateDueToDefaultWithCar() {
+    	LocationIndex locationIndex = buildGraphAndMocks("OSCAR");
+        expectNearestEdgeLookups(locationIndex);
+		GHRequest request = new GHRequest(11.1, 50, 11.3, 51);
+		request.setVehicle("car");
+		instance.route(request);
+		verifyEdgeFilterOnLookup(locationIndex, DefaultEdgeFilter.class);
+    }
+
+    @Test
+    public void testDontIgnorePrivateRoadsOnIndexSearchWhenCanStartOnPrivateWithEmv() {
+    	LocationIndex locationIndex = buildGraphAndMocks("EMV");
+        expectNearestEdgeLookups(locationIndex);
+		GHRequest request = new GHRequest(11.1, 50, 11.3, 51);
+		request.setVehicle("emv");
+		instance.route(request);
+		verifyEdgeFilterOnLookup(locationIndex, DefaultEdgeFilter.class);
+    }
+    
+    private LocationIndex buildGraphAndMocks(String vehicleEncoder )
+    {
+	    instance = new GraphHopper();
+    	instance = new GraphHopper().setStoreOnFlush(true).setEncodingManager(new EncodingManager(vehicleEncoder)).
+                 init(new CmdArgs().
+                         put("osmreader.osm", testOsm3).
+                         put("prepare.minNetworkSize", "1").
+                         put("graph.flagEncoders", vehicleEncoder)).
+                         setGraphHopperLocation(ghLoc);
+        instance.importOrLoad();
+
+    	LocationIndex locationIndex = Mockito.mock(LocationIndex.class);
+		instance.setLocationIndex(locationIndex );
+        GraphStorage graph = Mockito.mock(GraphStorage.class);
+        instance.setGraph(graph);
+	    return locationIndex;
+    }
+    
+    private void expectNearestEdgeLookups( LocationIndex locationIndex )
+    {
+	    QueryResult nearestResponse = Mockito.mock(QueryResult.class);
+		when(locationIndex.findClosest(Matchers.anyDouble(), Matchers.anyDouble(), Matchers.isA(EdgeFilter.class))).thenReturn(nearestResponse );
+    }
+    
+    private void verifyEdgeFilterOnLookup( LocationIndex locationIndex , Class<? extends EdgeFilter> filterClass  )
+    {
+	    verify(locationIndex, VerificationModeFactory.times(2)).findClosest(Matchers.anyDouble(), Matchers.anyDouble(),Matchers.isA(filterClass));
+    }
 }
