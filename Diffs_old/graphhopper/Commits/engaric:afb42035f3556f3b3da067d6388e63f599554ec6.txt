diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 6479551aee..d25e698d92 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -387,6 +387,7 @@ public InstructionList calcInstructions( final Translation tr )
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
             private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
+            private int prevNode = -1;
             private double prevOrientation;
             private Instruction prevInstruction;
             private boolean prevInRoundabout = false;
@@ -443,6 +444,17 @@ public void next( EdgeIteratorState edge, int index )
                                     annotation, new PointList(10, nodeAccess.is3D()));
                             if (prevName != null)
                             {
+                                // check if there is an exit at the same node the roundabout was entered
+                                EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
+                                while (edgeIter.next()) 
+                                {
+                                    if ((edgeIter.getAdjNode() != prevNode) 
+                                         && edgeIter.getAdjNode() != adjNode)
+                                    {
+                                        roundaboutInstruction.increaseExitNumber();
+                                    }
+                                }
+
                                 // previous orientation is last orientation before entering roundabout
                                 prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
 
@@ -554,7 +566,9 @@ public void next( EdgeIteratorState edge, int index )
                     doublePrevLat = wayGeo.getLatitude(beforeLast);
                     doublePrevLong = wayGeo.getLongitude(beforeLast);
                 }
+                
                 prevInRoundabout = isRoundabout;
+                prevNode = baseNode;
                 prevLat = adjLat;
                 prevLon = adjLon;
 
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 59f0747242..7a4cd1867b 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -214,13 +214,15 @@ public void testFindInstruction()
     private class RoundaboutGraph
     {
         public EdgeIteratorState edge2change;
+        public EdgeIteratorState directExitEdge;
+
         boolean clockwise;
         final public Graph g = new GraphBuilder(carManager).create();
         final public NodeAccess na = g.getNodeAccess();
 
         private RoundaboutGraph(boolean clockwise)
         {
-            //
+            //                          
             //      8
             //       \
             //         5
@@ -228,17 +230,18 @@ private RoundaboutGraph(boolean clockwise)
             //  1 - 2    4 - 7
             //       \  /
             //        3
-            //        |
-            //        6
+            //        | \
+            //        6 [ 9 ] edge 9 is turned off in default mode 
 
             na.setNode(1, 52.514, 13.348);
             na.setNode(2, 52.514, 13.349);
             na.setNode(3, 52.5135,13.35);
             na.setNode(4, 52.514, 13.351);
             na.setNode(5, 52.5145,13.351);
-            na.setNode(6, 52.513, 13.351);
+            na.setNode(6, 52.513, 13.35);
             na.setNode(7, 52.514, 13.352);
             na.setNode(8, 52.515, 13.351);
+            na.setNode(9, 52.513, 13.351);
 
             EdgeIteratorState tmpEdge;
             tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
@@ -252,8 +255,14 @@ private RoundaboutGraph(boolean clockwise)
             tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
             tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
             tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
-            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+            
+            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");                       
             edge2change = tmpEdge.detach(false);
+
+            tmpEdge = g.edge(3, 9, 5, false).setName("3-6");
+            tmpEdge.setFlags(encoder.setAccess(tmpEdge.getFlags(), false, false));
+            directExitEdge = tmpEdge.detach(false);
+            
             this.clockwise = clockwise;
         }
 
@@ -272,7 +281,6 @@ private double getAngle(int n1, int n2, int n3, int n4)
     public void testCalcInstructionsRoundabout()
     {
         RoundaboutGraph rg = new RoundaboutGraph(false);
-        rg.edge2change.setFlags(encoder.setAccess(rg.edge2change.getFlags(), true, false));
         Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
         InstructionList wayList = p.calcInstructions(tr);
         // Test instructions
@@ -301,13 +309,12 @@ public void testCalcInstructionsRoundabout()
     }
 
     /**
-     * case with one edge being not an exit
+     * case starting in Roundabout
      */
     @Test
-    public void testCalcInstructionsRoundabout2()
+    public void testCalcInstructionsRoundaboutBegin()
     {
         RoundaboutGraph rg = new RoundaboutGraph(false);
-        rg.edge2change.setFlags(encoder.setAccess(rg.edge2change.getFlags(), true, false));
         Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
         InstructionList wayList = p.calcInstructions(tr);
         List<String> tmpList = pick("text", wayList.createJson());
@@ -317,10 +324,27 @@ public void testCalcInstructionsRoundabout2()
     }
 
     /**
-     * case starting in Roundabout
+     * case with one node being containig already exit 
      */
     @Test
-    public void testCalcInstructionsRoundaboutBegin()
+    public void testCalcInstructionsRoundaboutDirectExit()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.directExitEdge.setFlags(encoder.setAccess(rg.directExitEdge.getFlags(), true, true));
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(6, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto 3-6",
+                        "At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * case with one edge being not an exit
+     */
+    @Test
+    public void testCalcInstructionsRoundabout2()
     {
         RoundaboutGraph rg = new RoundaboutGraph(false);
         rg.edge2change.setFlags(encoder.setAccess(rg.edge2change.getFlags(), false, false));        
@@ -337,13 +361,11 @@ public void testCalcInstructionsRoundaboutBegin()
         assertEquals(delta, instr.getRadian(), 0.01);
     }
 
-
     /**
      * clockwise roundabout
      */
     @Test
-    public void testCalcInstructionsRoundaboutClockwise()
-    {
+    public void testCalcInstructionsRoundaboutClockwise()    {
 
         RoundaboutGraph rg = new RoundaboutGraph(true);
         System.out.println(rg.clockwise);
