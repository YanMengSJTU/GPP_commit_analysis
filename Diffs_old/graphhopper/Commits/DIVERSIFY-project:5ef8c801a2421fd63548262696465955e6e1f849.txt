diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 6b05128118..00550db229 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -909,6 +909,7 @@ else if (algoStr.equals("astarbi"))
                 
                 //
                 System.out.println("prepare.createAlgo.toString "+ algo.toString());
+                System.out.println("algo.getName() "+ algo.getName());
             }
 
             debug += ", algoInit:" + sw.stop().getSeconds() + "s";
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java
index b54d397a1b..fa5251c7e9 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirection.java
@@ -60,6 +60,7 @@ public DijkstraBidirection( Graph graph, FlagEncoder encoder, Weighting weightin
     {
         super(graph, encoder, weighting);
         initCollections(1000);
+        System.out.println("Entered DijkstraBidirection");
     }
 
     protected void initCollections( int locs )
@@ -135,6 +136,7 @@ protected boolean finished()
     void fillEdges( int currNode, double currWeight, int currRef,
             IntDoubleBinHeap openSet, EdgeWrapper wrapper, EdgeExplorer explorer, boolean reverse )
     {
+
         EdgeIterator iter = explorer.setBaseNode(currNode);
         while (iter.next())
         {
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index 6a8f6835c0..e3b91fcc95 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -51,6 +51,7 @@ public DijkstraBidirectionRef( Graph graph, FlagEncoder encoder, Weighting weigh
     {
         super(graph, encoder, weighting);
         initCollections(1000);
+        System.out.println("Entered DijkstraBidirectionRef");
     }
 
     protected void initCollections( int nodes )
@@ -163,6 +164,7 @@ void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
             double tmpWeight = weighting.calcWeight(iter, reverse) + currEdge.weight;
 
             EdgeEntry de = shortestWeightMap.get(adjNode);
+
             if (de == null)
             {
                 de = new EdgeEntry(iter.getEdge(), adjNode, tmpWeight);
diff --git a/core/src/main/java/com/graphhopper/routing/util/LeastNoisyWeighting.java b/core/src/main/java/com/graphhopper/routing/util/LeastNoisyWeighting.java
index 7e7328a0fa..62579deb82 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LeastNoisyWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LeastNoisyWeighting.java
@@ -13,125 +13,124 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.graphhopper.routing.util;
 
 import com.graphhopper.util.EdgeIteratorState;
 import java.util.Random;
 
-import java.io.IOException;                                                    
+import java.io.IOException;
 import java.net.URI;
 import java.net.URISyntaxException;
-import java.util.HashMap;                                                      
-import java.util.Map;                                                          
-import java.util.List;   
+import java.util.HashMap;
+import java.util.Map;
+import java.util.List;
 import java.util.*;
-                                                                               
-import redis.clients.jedis.BinaryJedis;                                        
-import redis.clients.jedis.Jedis;                                              
-import redis.clients.jedis.Protocol;                                           
-import redis.clients.jedis.exceptions.JedisConnectionException;                
-import redis.clients.jedis.exceptions.JedisDataException;                      
-import redis.clients.util.SafeEncoder;  
+
+import redis.clients.jedis.BinaryJedis;
+import redis.clients.jedis.Jedis;
+import redis.clients.jedis.Protocol;
+import redis.clients.jedis.exceptions.JedisConnectionException;
+import redis.clients.jedis.exceptions.JedisDataException;
+import redis.clients.util.SafeEncoder;
 
 /**
- * Calculates the least noisy route- independent of a vehicle as the calculation is based on 
- * the noise data linked to edges stores in Redis
+ * Calculates the least noisy route- independent of a vehicle as the calculation is based on the
+ * noise data linked to edges stores in Redis
+ * <p>
  * @author Amal Elgammal
  */
 public class LeastNoisyWeighting implements Weighting
 {
     String currentCity;
-    
+
     public LeastNoisyWeighting()
     {
         System.out.println("LeastNoiseWeighting instantiated!");
-        try
-        {
-        
-        Jedis jedis = new Jedis("localhost");
-        String hashname = "dublin_ways_set";
-        //Map<String, String> decibles = jedis.hgetAll(hashname);
-        //System.out.println("Noise Entries = " + decibles);
-        Set<String> affectedEdges = jedis.smembers(hashname);
-        System.out.println("dublin_ways_set = " + affectedEdges);
-        
-       
-        /*for(Map.Entry<String, String> value: decibles.entrySet())
-        {
-            String date = value.getKey();
-            String noise = value.getValue();
-            System.out.println("on " + date + ", noise was: " + noise);
-        }*/
-        } catch(JedisConnectionException e)
-        {
-            System.out.println("JedisConnectionException: " +e.getMessage());
-        } catch(JedisDataException e)
-        {
-            System.out.println("JedisDataException: " +e.getMessage());
-            
-        } catch(Exception e)
-        {
-            System.out.println("Error: " +e.getMessage());
-            
-        }
-        
+
     }
-    
-     @Override
+
+    @Override
     public double getMinWeight( double noiseValue )
     {
         //TODO: Check if this needs to be updated
         return noiseValue;
     }
-    
-     @Override
+
+    @Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse )
     {
         //Experimenting with returning a random radom between 0-80...Worked!
         Random nw = new Random();
         double returnedRandom = nw.nextInt(100);
-       // System.out.println("Random noise value for edge = " +edge+ " = "+ returnedRandom );
+
+        System.out.println("edge.getEdge() = " + edge.getEdge());
+        System.out.println("edge.getFlags() = " + edge.getFlags());
+        System.out.println("edge.getName() = " + edge.getName());
+
         return returnedRandom;
-        
+
         //double noiseValue = getNoiseFromRedis(edge);
         //return noiseValue;
-    
     }
-    
-      double getNoiseFromRedis(EdgeIteratorState edge) throws JedisConnectionException, JedisDataException
+
+    double getNoiseFromRedis( EdgeIteratorState edge ) throws JedisConnectionException, JedisDataException
     {
-        double noiseValue=0;
+        double noiseValue = 0;
         String city = getCurrentCity();
         //TODO: connect to redis
         //The Python code to be extended to include the type of the readings with the key for each has
         //i.e.edge_type (type is the reading type from the relevant config file)
         //check if we can increment the time of the noise reading to instructions in the response??
-        
 
-        
+        try
+        {
+
+            Jedis jedis = new Jedis("localhost");
+            String hashname = "dublin_ways_set";
+        //Map<String, String> decibles = jedis.hgetAll(hashname);
+            //System.out.println("Noise Entries = " + decibles);
+            Set<String> affectedEdges = jedis.smembers(hashname);
+        //System.out.println("dublin_ways_set = " + affectedEdges);
+
+            /*for(Map.Entry<String, String> value: decibles.entrySet())
+             {
+             String date = value.getKey();
+             String noise = value.getValue();
+             System.out.println("on " + date + ", noise was: " + noise);
+             }*/
+        } catch (JedisConnectionException e)
+        {
+            System.out.println("JedisConnectionException: " + e.getMessage());
+        } catch (JedisDataException e)
+        {
+            System.out.println("JedisDataException: " + e.getMessage());
+
+        } catch (Exception e)
+        {
+            System.out.println("Error: " + e.getMessage());
+
+        }
+
         return noiseValue;
     }
-      
-      //TODO: Start here: should be set in the route method (graphhopper) when selecting and init the appropriate weighting
-      void setCurrentCity(String city)
-      {
-          this.currentCity = city;
-      }
-  
-      String getCurrentCity()
-      {
-          return currentCity;
-          
-      }
-    
+
+    //TODO: Start here: should be set in the route method (graphhopper) when selecting and init the appropriate weighting
+    void setCurrentCity( String city )
+    {
+        this.currentCity = city;
+    }
+
+    String getCurrentCity()
+    {
+        return currentCity;
+
+    }
+
     @Override
     public String toString()
     {
         //TODO: check if we need to register it with the encodering manger or elsewhere
         return "LEAST_NOISY";
     }
-    
-  
-    
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PopulateRedisRandomNoise.java b/core/src/main/java/com/graphhopper/routing/util/PopulateRedisRandomNoise.java
index 98d25bce45..699c0ffbb2 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PopulateRedisRandomNoise.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PopulateRedisRandomNoise.java
@@ -17,6 +17,8 @@
 
 import java.util.Random;
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
 
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
@@ -28,7 +30,6 @@
 import redis.clients.jedis.exceptions.JedisConnectionException;
 import redis.clients.jedis.exceptions.JedisDataException;
 
-
 /**
  *
  * @author elgammaa
@@ -48,17 +49,20 @@ public static void main( String[] strs ) throws Exception, JedisConnectionExcept
         try
         {
             Jedis jedis = new Jedis("localhost");
+            jedis.flushAll();
 
             for (int i = 0; i < handler.waysIDs.size(); i++)
             {
                 String hashkey = handler.waysIDs.get(i);
+                System.out.println("hashkey = "+hashkey);
                 hashkey = "dublin-noise-" + hashkey;
+
                 Random noiseValue = new Random();
                 double returnedNoise = noiseValue.nextInt(80);
                 String noise = String.valueOf(returnedNoise);
                 Random noiseTime = new Random();
                 double returnedTime = noiseTime.nextInt(23);
-                String ntime = String.valueOf(returnedTime);
+                String ntime = String.valueOf(returnedTime) + "time";
                 jedis.hset(hashkey, "Noisetube_value", noise);
                 jedis.hset(hashkey, "Noisetube_timestamp", ntime);
             }
@@ -82,6 +86,12 @@ public static void main( String[] strs ) throws Exception, JedisConnectionExcept
 class SAXHandler extends DefaultHandler
 {
     ArrayList<String> waysIDs = new ArrayList<String>();
+    String wayId, wayName, wayRef;
+
+    public SAXHandler()
+    {
+        super();
+    }
 
     @Override
     public void startElement( String uri, String localName, String qName, Attributes attributes ) throws SAXException
@@ -89,9 +99,39 @@ public void startElement( String uri, String localName, String qName, Attributes
 
         if (qName.equalsIgnoreCase("way"))
         {
-            waysIDs.add(attributes.getValue("id"));
+            wayId = attributes.getValue("id");
+            System.out.println("WayID = " + wayId);
+        }
+        else if (qName.equalsIgnoreCase("tag"))
+        {
+            if (attributes.getValue("k").equalsIgnoreCase("name"))
+            {
+                wayName = attributes.getValue("v");
+                System.out.println("wayName = " + wayName);
+            }
+            else if(attributes.getValue("k").equalsIgnoreCase("ref"))
+            {
+                wayRef = attributes.getValue("v");
+                System.out.println("wayRef = " + wayRef);
+            }
+        }
+       
+    }
+    
+    @Override
+    public void endElement(String uri, String localName, String qName) throws SAXException 
+    {
+        if (qName.equalsIgnoreCase("way"))
+        {
+           if(wayId!=null && wayName!=null && wayRef!=null)
+           {
+               waysIDs.add(wayName+"-"+wayRef+"-"+wayId);
+           }
+            
         }
+        
     }
 
 }
 
+
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index dbfbb155c8..4b58a840c8 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -299,6 +299,7 @@ public EdgeIteratorState edge( int a, int b )
     {
         ensureNodeIndex(Math.max(a, b));
         int edge = internalEdgeAdd(a, b);
+        
         EdgeIterable iter = new EdgeIterable(EdgeFilter.ALL_EDGES);
         iter.setBaseNode(a);
         iter.setEdgeId(edge);
@@ -328,7 +329,6 @@ int internalEdgeAdd( int fromNodeId, int toNodeId )
         connectNewEdge(fromNodeId, newOrExistingEdge);
         if (fromNodeId != toNodeId)
             connectNewEdge(toNodeId, newOrExistingEdge);
-
         return newOrExistingEdge;
     }
 
@@ -382,6 +382,7 @@ private long writeEdge( int edge, int nodeThis, int nodeOther, int nextEdge, int
         edges.setInt(edgePointer + E_NODEB, nodeOther);
         edges.setInt(edgePointer + E_LINKA, nextEdge);
         edges.setInt(edgePointer + E_LINKB, nextEdgeOther);
+        
         return edgePointer;
     }
 
@@ -515,6 +516,7 @@ public int getAdjNode()
         @Override
         public double getDistance()
         {
+            
             return getDist(edgePointer);
         }
 
@@ -579,9 +581,12 @@ public PointList fetchWayGeometry( int type )
         @Override
         public String getName()
         {
+            System.out.println("E_NAME = "+ E_NAME);
             int nameIndexRef = edges.getInt(edgePointer + E_NAME);
             return nameIndex.get(nameIndexRef);
         }
+        
+       
 
         @Override
         public EdgeIteratorState setName( String name )
@@ -729,7 +734,7 @@ public EdgeIterable( EdgeFilter filter )
 
         protected void setEdgeId( int edgeId )
         {
-            this.nextEdge = this.edgeId = edgeId;
+            this.nextEdge = this.edgeId = edgeId;        
             this.edgePointer = (long) nextEdge * edgeEntryBytes;
         }
 
