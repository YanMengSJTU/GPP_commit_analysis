diff --git a/core/graphhopper/temp/edges b/core/graphhopper/temp/edges
index 17804c7a54..fb04c137c0 100644
Binary files a/core/graphhopper/temp/edges and b/core/graphhopper/temp/edges differ
diff --git a/core/graphhopper/temp/geometry b/core/graphhopper/temp/geometry
index 754f1ebe0a..205a47f703 100644
Binary files a/core/graphhopper/temp/geometry and b/core/graphhopper/temp/geometry differ
diff --git a/core/graphhopper/temp/location_index b/core/graphhopper/temp/location_index
index a4be5940a5..af3c662309 100644
Binary files a/core/graphhopper/temp/location_index and b/core/graphhopper/temp/location_index differ
diff --git a/core/graphhopper/temp/names b/core/graphhopper/temp/names
index e08d50a4b7..ebdc1b2405 100644
Binary files a/core/graphhopper/temp/names and b/core/graphhopper/temp/names differ
diff --git a/core/graphhopper/temp/nodes b/core/graphhopper/temp/nodes
index f6c16153bd..b9370d6509 100644
Binary files a/core/graphhopper/temp/nodes and b/core/graphhopper/temp/nodes differ
diff --git a/core/graphhopper/temp/properties b/core/graphhopper/temp/properties
index 544e7c7fe2..21e48036f2 100644
Binary files a/core/graphhopper/temp/properties and b/core/graphhopper/temp/properties differ
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 47ef0801a5..90aef95748 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper;
 
-import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.OSMReader;
 import com.graphhopper.reader.dem.CGIARProvider;
 import com.graphhopper.reader.dem.ElevationProvider;
@@ -96,6 +95,7 @@
     private double osmReaderWayPointMaxDistance = 1;
     private int workerThreads = -1;
     private boolean calcPoints = true;
+    private OSMReader osmReader;
     // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
@@ -736,11 +736,11 @@ private GraphHopper process( String graphHopperLocation )
 
             try
             {
-                DataReader reader = importData();
+                osmReader = importData();
                 DateFormat f = Helper.createFormatter();
                 ghStorage.getProperties().put("osmreader.import.date", f.format(new Date()));
-                if (reader.getDataDate() != null)
-                    ghStorage.getProperties().put("osmreader.data.date", f.format(reader.getDataDate()));
+                if (osmReader.getDataDate() != null)
+                    ghStorage.getProperties().put("osmreader.data.date", f.format(osmReader.getDataDate()));
             } catch (IOException ex)
             {
                 throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
@@ -756,7 +756,7 @@ private GraphHopper process( String graphHopperLocation )
         return this;
     }
 
-    protected DataReader importData() throws IOException
+    protected OSMReader importData() throws IOException
     {
         ensureWriteAccess();
         if (ghStorage == null)
@@ -768,13 +768,13 @@ protected DataReader importData() throws IOException
 
         encodingManager.setEnableInstructions(enableInstructions);
         encodingManager.setPreferredLanguage(preferredLanguage);
-        DataReader reader = createReader(ghStorage);
+        OSMReader reader = createReader(ghStorage);
         logger.info("using " + ghStorage.toString() + ", memory:" + Helper.getMemInfo());
         reader.readGraph();
         return reader;
     }
 
-    protected DataReader createReader( GraphHopperStorage ghStorage )
+    protected OSMReader createReader( GraphHopperStorage ghStorage )
     {
         return initOSMReader(new OSMReader(ghStorage));
     }
@@ -988,7 +988,7 @@ public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder
         } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
         {
             if (encoder.supports(PriorityWeighting.class))
-                return new PriorityWeighting(encoder, weightingMap);
+                return new SafetyWeighting(encoder, locationIndex);
             else
                 return new FastestWeighting(encoder, weightingMap);
         } else if ("curvature".equalsIgnoreCase(weighting))
@@ -997,6 +997,11 @@ public Weighting createWeighting( WeightingMap weightingMap, FlagEncoder encoder
                 return new CurvatureWeighting(encoder, weightingMap, ghStorage);
             else
                 return new FastestWeighting(encoder, weightingMap);
+        } else if ("safety".equalsIgnoreCase(weighting)) {
+        	if (encoder.supports(SafetyWeighting.class)) 
+                return new SafetyWeighting(encoder, locationIndex);
+        	else
+                return new SafetyWeighting(encoder, locationIndex);
         }
 
         throw new UnsupportedOperationException("weighting " + weighting + " not supported");
diff --git a/core/src/main/java/com/graphhopper/Main.java b/core/src/main/java/com/graphhopper/Main.java
index 9425f5c2b6..6d0ad567f9 100644
--- a/core/src/main/java/com/graphhopper/Main.java
+++ b/core/src/main/java/com/graphhopper/Main.java
@@ -1,30 +1,43 @@
 package com.graphhopper;
 
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 
 import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.util.GPXEntry;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.PointList;
 
 public class Main {
 	public static void main(String[] args) {
+		// create one GraphHopper instance
 		GraphHopper hopper = new GraphHopper().forServer();
 		hopper.setCHEnable(false);
-		hopper.setOSMFile("maps.osm");
+		hopper.setOSMFile("mapsEdit.osm");
 		hopper.setGraphHopperLocation("graphhopper/temp");
 		hopper.setEncodingManager(new EncodingManager("bike"));
 
+		// now this can take minutes if it imports or a few seconds for loading
+		// of course this is dependent on the area you import
 		hopper.importOrLoad();
+		// simple configuration of the request object, see the GraphHopperServlet class for more possibilities.
+		GHRequest req = new GHRequest(40.35174, -74.70405, 40.35899, -74.64734).
+		    setWeighting("safety").
+		    setLocale(Locale.US);
+		GHResponse rsp = hopper.route(req);
+
+		// first check for errors
+		if(rsp.hasErrors()) {
+		   // handle them!
+		   System.out.println(rsp.getErrors());
+		   return;
+		}
 
-		GHRequest req = new GHRequest(40.3453849, -74.663214, 40.3723288, 74.645158).
-		    setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR);
-		GHResponse res = hopper.route(req);
-		
 		// use the best path, see the GHResponse class for more possibilities.
-		PathWrapper path = res.getBest();
+		PathWrapper path = rsp.getBest();
 
 		// points, distance in meters and time in millis of the full path
 		PointList pointList = path.getPoints();
@@ -32,14 +45,11 @@ public static void main(String[] args) {
 		long timeInMs = path.getTime();
 
 		InstructionList il = path.getInstructions();
+		
 		// iterate over every turn instruction
 		for(Instruction instruction : il) {
 		   instruction.getDistance();
 		   System.out.println(instruction);
 		}
-
-		// or get the json
-		List<Map<String, Object>> iList = il.createJson();
-
 	}
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index 03be962244..0697096cbb 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -105,7 +105,9 @@
     private TLongLongHashMap osmWayIdToRouteWeightMap;
     // stores osm way ids used by relations to identify which edge ids needs to be mapped later
     private TLongHashSet osmWayIdSet = new TLongHashSet();
+    private TLongHashSet osmNodeIdSet = new TLongHashSet();
     private TIntLongMap edgeIdToOsmWayIdMap;
+    private TIntLongMap edgeIdToOsmNodeIdMap;
     private final TLongList barrierNodeIds = new TLongArrayList();
     protected PillarInfo pillarInfo;
     private final DistanceCalc distCalc = Helper.DIST_EARTH;
@@ -241,6 +243,11 @@ private TLongSet getOsmWayIdSet()
     {
         return osmWayIdSet;
     }
+    
+    private TLongSet getOsmNodeIdSet()
+    {
+        return osmNodeIdSet;
+    }
 
     private TIntLongMap getEdgeIdToOsmWayIdMap()
     {
@@ -249,6 +256,14 @@ private TIntLongMap getEdgeIdToOsmWayIdMap()
 
         return edgeIdToOsmWayIdMap;
     }
+    
+    private TIntLongMap getEdgeIdToOsmNodeIdMap()
+    {
+        if (edgeIdToOsmNodeIdMap == null)
+            edgeIdToOsmNodeIdMap = new TIntLongHashMap(getOsmNodeIdSet().size(), 0.5f, -1, -1);
+
+        return edgeIdToOsmNodeIdMap;
+    }
 
     /**
      * Filter ways but do not analyze properties wayNodes will be filled with participating node
@@ -330,7 +345,7 @@ private void writeOsm2Graph( File osmFile )
             Helper.close(in);
         }
 
-        finishedReading();
+        //finishedReading();
         if (graph.getNodes() == 0)
             throw new IllegalStateException("osm must not be empty. read " + counter + " lines and " + locations + " locations");
     }
@@ -528,6 +543,11 @@ public long getOsmIdOfInternalEdge( int edgeId )
     {
         return getEdgeIdToOsmWayIdMap().get(edgeId);
     }
+    
+    public long getOsmNodeIdOfInternalEdge( int edgeId )
+    {
+        return getEdgeIdToOsmNodeIdMap().get(edgeId);
+    }
 
     public int getInternalNodeIdOfOsmNode( long nodeOsmId )
     {
@@ -714,7 +734,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
                         if (pointList.getSize() > 1 && firstNode >= 0)
                         {
                             // TOWER node
-                            newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+                            newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId, osmId));
                             pointList.clear();
                             pointList.add(nodeAccess, tmpNode);
                         }
@@ -746,7 +766,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
                     pointList.add(nodeAccess, tmpNode);
                     if (firstNode >= 0)
                     {
-                        newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+                        newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId, osmId));
                         pointList.clear();
                         pointList.add(nodeAccess, tmpNode);
                     }
@@ -762,7 +782,7 @@ int addTowerNode( long osmId, double lat, double lon, double ele )
         return newEdges;
     }
 
-    EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId )
+    EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId, long nodeOsmId )
     {
         // sanity checks
         if (fromIndex < 0 || toIndex < 0)
@@ -834,6 +854,7 @@ EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long
             iter.setWayGeometry(pillarNodes);
         }
         storeOsmWayID(iter.getEdge(), wayOsmId);
+        storeOsmNodeID(iter.getEdge(), nodeOsmId);
         return iter;
     }
 
@@ -847,6 +868,14 @@ protected void storeOsmWayID( int edgeId, long osmWayId )
             getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
         }
     }
+    
+    protected void storeOsmNodeID( int edgeId, long osmNodeId )
+    {
+        if (getOsmNodeIdSet().contains(osmNodeId))
+        {
+            getEdgeIdToOsmNodeIdMap().put(edgeId, osmNodeId);
+        }
+    }
 
     /**
      * @return converted tower node
@@ -883,7 +912,9 @@ protected void finishedReading()
         osmNodeIdToNodeFlagsMap = null;
         osmWayIdToRouteWeightMap = null;
         osmWayIdSet = null;
+        osmNodeIdSet = null;
         edgeIdToOsmWayIdMap = null;
+        edgeIdToOsmNodeIdMap = null;
     }
 
     /**
@@ -977,7 +1008,7 @@ boolean isInBounds( OSMNode node )
     /**
      * Maps OSM IDs (long) to internal node IDs (int)
      */
-    protected LongIntMap getNodeMap()
+    public LongIntMap getNodeMap()
     {
         return osmNodeIdToInternalNodeMap;
     }
@@ -1040,6 +1071,15 @@ private void printInfo( String str )
                 + ", zeroCounter:" + zeroCounter
                 + " " + Helper.getMemInfo());
     }
+    
+    public void printInfo1( String str )
+    {
+        System.out.println("finished " + str + " processing." + " nodes: " + graph.getNodes()
+                + ", osmIdMap.size:" + getNodeMap().getSize() + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
+                + ", nodeFlagsMap.size:" + getNodeFlagsMap().size() + ", relFlagsMap.size:" + getRelFlagsMap().size()
+                + ", zeroCounter:" + zeroCounter
+                + " " + Helper.getMemInfo());
+    }
 
     @Override
     public Date getDataDate()
diff --git a/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.java b/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.java
index a507821dd6..c12bf28d00 100644
--- a/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.java
+++ b/core/src/main/java/com/graphhopper/routing/safety/ColorMapParser.java
@@ -27,7 +27,7 @@
             int rows; // No of rows
             rows = sheet.getPhysicalNumberOfRows();
 
-            for(int r = 461; r < 463; r++) {
+            for(int r = 0; r < rows; r++) {
                 row = sheet.getRow(r);
                 boolean found = false;
                 Way way = new Way(0);
diff --git a/core/src/main/java/com/graphhopper/routing/util/SafetyWeighting.java b/core/src/main/java/com/graphhopper/routing/util/SafetyWeighting.java
new file mode 100644
index 0000000000..e105b0394f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/SafetyWeighting.java
@@ -0,0 +1,89 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import java.io.IOException;
+import java.util.HashMap;
+
+import com.graphhopper.reader.OSMReader;
+import com.graphhopper.routing.safety.ColorMapParser;
+import com.graphhopper.routing.safety.NodeInformation;
+import com.graphhopper.routing.safety.OSMParser;
+import com.graphhopper.routing.safety.Way;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * Calculates the shortest route - independent of a vehicle as the calculation is based on the
+ * distance only.
+ * <p>
+ * @author Peter Karich
+ */
+public class SafetyWeighting extends PriorityWeighting
+{
+	private HashMap<Long, NodeInformation> nodeMap = new HashMap<Long, NodeInformation>();
+	private HashMap<Long, Way> wayMap = new HashMap<Long, Way>();
+	private HashMap<Long, HashMap<Long, Integer>> scores;
+	HashMap<Integer, Long> encoder;
+	
+    public SafetyWeighting( FlagEncoder flagEncoder, LocationIndex locationIndex )
+    {
+        super(flagEncoder);
+        OSMParser.parseFile(nodeMap, wayMap);
+        scores = ColorMapParser.parseFile(nodeMap, wayMap);
+        encoder = new HashMap<Integer, Long>();
+        for (long id : nodeMap.keySet()) {
+        	int hashedId = locationIndex.findID(nodeMap.get(id).getLat(), nodeMap.get(id).getLong());
+        	encoder.put(hashedId, id);
+        }
+    }
+
+    @Override
+    public double getMinWeight( double currDistToGoal )
+    {
+        return currDistToGoal;
+    }
+
+    @Override
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
+    {
+    	double weight = super.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+        if (Double.isInfinite(weight))
+            return Double.POSITIVE_INFINITY;
+    	if (encoder.containsKey(edgeState.getEdge()) && encoder.containsKey(edgeState.getAdjNode())) {
+    		long startId = encoder.get(edgeState.getEdge());
+        	long endId = encoder.get(edgeState.getAdjNode());
+        	if(scores.get(startId) == null || scores.get(startId).get(endId) == null);
+        	else
+        	{
+        		double score = scores.get(startId).get(endId);
+        		//return weight*score;
+        		return edgeState.getDistance()*score;
+        	}	
+    	}
+        //return weight*2.5;
+    	return edgeState.getDistance();
+    }
+
+    @Override
+    public String getName()
+    {
+        return "safest";
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index 2efc4320a5..add3edbfbf 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper;
 
 import com.graphhopper.reader.DataReader;
+import com.graphhopper.reader.OSMReader;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
@@ -218,7 +219,7 @@ public void testDoNotAllowWritingAndLoadingAtTheSameTime() throws Exception
         final GraphHopper instance1 = new GraphHopper()
         {
             @Override
-            protected DataReader importData() throws IOException
+            protected OSMReader importData() throws IOException
             {
                 try
                 {
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index 7c8833cc14..22c028c5b6 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -123,20 +123,20 @@ public GraphHopperTest( String osmFile, boolean turnCosts )
         }
 
         @Override
-        protected DataReader createReader( GraphHopperStorage tmpGraph )
+        protected OSMReader createReader( GraphHopperStorage tmpGraph )
         {
             return initOSMReader(new OSMReader(tmpGraph));
         }
 
         @Override
-        protected DataReader importData() throws IOException
+        protected OSMReader importData() throws IOException
         {
             getEncodingManager().setPreferredLanguage(getPreferredLanguage());
             GraphHopperStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(),
                     getEncodingManager().needsTurnCostsSupport());
             setGraphHopperStorage(tmpGraph);
 
-            DataReader osmReader = createReader(tmpGraph);
+            OSMReader osmReader = createReader(tmpGraph);
             try
             {
                 ((OSMReader) osmReader).setOSMFile(new File(getClass().getResource(getOSMFile()).toURI()));
@@ -229,7 +229,7 @@ public void testWithBounds()
         GraphHopper hopper = new GraphHopperTest(file1)
         {
             @Override
-            protected DataReader createReader( GraphHopperStorage tmpGraph )
+            protected OSMReader createReader( GraphHopperStorage tmpGraph )
             {
                 return new OSMReader(tmpGraph)
                 {
@@ -675,7 +675,7 @@ public void testReadEleFromCustomOSM()
         GraphHopper hopper = new GraphHopperTest("custom-osm-ele.xml")
         {
             @Override
-            protected DataReader createReader( GraphHopperStorage tmpGraph )
+            protected OSMReader createReader( GraphHopperStorage tmpGraph )
             {
                 return initOSMReader(new OSMReader(tmpGraph)
                 {
diff --git a/graphhopper.sh b/graphhopper.sh
index 51f5cdaf5a..c9d10cbbe0 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -261,7 +261,7 @@ elif [ "$ACTION" = "miniui" ]; then
 
 
 elif [ "$ACTION" = "measurement" ]; then
- ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chWeighting=fastest graph.flagEncoders=CAR"
+ ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chWeighting=safety graph.flagEncoders=car"
  echo -e "\ncreate graph via $ARGS, $JAR"
  START=$(date +%s)
  # avoid islands for measurement at all costs
