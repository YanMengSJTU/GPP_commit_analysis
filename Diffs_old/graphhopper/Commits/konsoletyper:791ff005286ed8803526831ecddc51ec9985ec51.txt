diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index b3cc92601b..ea6217618d 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -137,8 +137,8 @@ public DataAccess find( String name, DAType type )
     @Override
     public void clear()
     {
-        // If there is at least one MMap DA then do not apply the cleanHack 
-        // for every single mmap DA as this is very slow if lots of DataAccess objects were collected 
+        // If there is at least one MMap DA then do not apply the cleanHack
+        // for every single mmap DA as this is very slow if lots of DataAccess objects were collected
         // => forceClean == false
 
         MMapDataAccess mmapDA = null;
@@ -196,7 +196,7 @@ protected void mkdirs()
             new File(location).mkdirs();
     }
 
-    Collection<DataAccess> getAll()
+    public Collection<DataAccess> getAll()
     {
         return map.values();
     }
diff --git a/graphhopper-teavm/pom.xml b/graphhopper-teavm/pom.xml
index 59a8bf3a4f..8e1a090fff 100644
--- a/graphhopper-teavm/pom.xml
+++ b/graphhopper-teavm/pom.xml
@@ -26,6 +26,11 @@
       <artifactId>teavm-core</artifactId>
       <version>0.2-SNAPSHOT</version>
     </dependency>
+    <dependency>
+      <groupId>org.teavm</groupId>
+      <artifactId>teavm-jso</artifactId>
+      <version>0.2-SNAPSHOT</version>
+    </dependency>
   </dependencies>
 
   <build>
@@ -49,7 +54,7 @@
             </goals>
             <phase>process-classes</phase>
             <configuration>
-              <minifying>true</minifying>
+              <minifying>false</minifying>
               <mainClass>com.graphhopper.teavm.Main</mainClass>
               <mainPageIncluded>true</mainPageIncluded>
             </configuration>
diff --git a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Base64.java b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Base64.java
new file mode 100644
index 0000000000..d0bd0c0cb1
--- /dev/null
+++ b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Base64.java
@@ -0,0 +1,117 @@
+package com.graphhopper.teavm;
+
+import java.util.Arrays;
+
+/**
+ *
+ * @author Alexey Andreev
+ */
+public class Base64 {
+    private static char[] map;
+    private static int[] unmap;
+
+    static {
+        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+        map = new char[chars.length()];
+        unmap = new int[127];
+        Arrays.fill(unmap, -1);
+        for (int i = 0; i < chars.length(); ++i) {
+            map[i] = chars.charAt(i);
+            unmap[map[i]] = i;
+        }
+    }
+
+    public static String encode(byte[] bytes) {
+        int buffer = 0;
+        char[] chars = new char[(bytes.length + 2) / 3 * 4];
+        int j = 0;
+        int sz = (bytes.length / 3) * 3;
+        for (int i = 0; i < sz; i += 3, j += 4) {
+            buffer = (bytes[i + 0] << 16) |
+                     (bytes[i + 1] <<  8) |
+                     (bytes[i + 2] <<  0);
+            printBuffer(chars, buffer, j);
+        }
+        switch (bytes.length % 3) {
+            case 2:
+                buffer = (bytes[sz + 0] << 16) |
+                         (bytes[sz + 1] <<  8);
+                chars[j++] = map[(buffer >>> 18) & 63];
+                chars[j++] = map[(buffer >>> 12) & 63];
+                chars[j++] = map[(buffer >>>  6) & 63];
+                chars[j++] = '=';
+                break;
+            case 1:
+                buffer = (bytes[sz + 0] << 16);
+                chars[j++] = map[(buffer >>> 18) & 63];
+                chars[j++] = map[(buffer >>> 12) & 63];
+                chars[j++] = '=';
+                chars[j++] = '=';
+                break;
+        }
+        return new String(chars);
+    }
+
+    private static void printBuffer(char[] chars, int buffer, int target) {
+        chars[target++] = map[(buffer >>> 18) & 63];
+        chars[target++] = map[(buffer >>> 12) & 63];
+        chars[target++] = map[(buffer >>>  6) & 63];
+        chars[target++] = map[(buffer >>>  0) & 63];
+    }
+
+    public static byte[] decode(String message) {
+        byte[] data = new byte[calculateLength(message)];
+        int sz = ((data.length + 1) / 4) * 4;
+        int buffer = 0;
+        int j = 0;
+        for (int i = 0; i < sz; i += 4) {
+            buffer = readBuffer(message, i);
+            data[j++] = (byte)(buffer >> 16);
+            data[j++] = (byte)(buffer >>  8);
+            data[j++] = (byte)(buffer >>  0);
+        }
+        switch (data.length - j) {
+            case 3:
+                buffer = readBuffer(message, sz);
+                data[j++] = (byte)(buffer >> 16);
+                data[j++] = (byte)(buffer >>  8);
+                data[j++] = (byte)(buffer >>  0);
+                break;
+            case 2:
+                buffer = (unmap[message.charAt(sz + 0)] << 18) |
+                         (unmap[message.charAt(sz + 1)] << 12) |
+                         (unmap[message.charAt(sz + 2)] <<  6);
+                data[j++] = (byte)(buffer >> 16);
+                data[j++] = (byte)(buffer >>  8);
+                break;
+            case 1:
+                buffer = (unmap[message.charAt(sz + 0)] << 18) |
+                         (unmap[message.charAt(sz + 1)] << 12);
+                data[j++] = (byte)(buffer >> 16);
+                break;
+        }
+        return data;
+    }
+
+    private static int readBuffer(String chars, int index) {
+        return (unmap[chars.charAt(index + 0)] << 18) |
+               (unmap[chars.charAt(index + 1)] << 12) |
+               (unmap[chars.charAt(index + 2)] <<  6) |
+               (unmap[chars.charAt(index + 3)] <<  0);
+    }
+
+    private static int calculateLength(String message) {
+        int diff = 0;
+        int sz = message.length();
+        if (sz == 0) {
+            return 0;
+        }
+        if (message.charAt(sz - 1) == '=') {
+            ++diff;
+        }
+        if (message.charAt(sz - 2) == '=') {
+            ++diff;
+        }
+        return sz / 4 * 3 - diff;
+    }
+}
diff --git a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/DataEntry.java b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/DataEntry.java
new file mode 100644
index 0000000000..c64495f560
--- /dev/null
+++ b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/DataEntry.java
@@ -0,0 +1,23 @@
+package com.graphhopper.teavm;
+
+import org.teavm.jso.JSArray;
+import org.teavm.jso.JSObject;
+import org.teavm.jso.JSProperty;
+
+/**
+ *
+ * @author Alexey Andreev
+ */
+public interface DataEntry extends JSObject {
+    @JSProperty
+    String getName();
+
+    @JSProperty
+    JSArray<JSObject> getData();
+
+    @JSProperty
+    int getSegmentSize();
+
+    @JSProperty
+    String getHeader();
+}
diff --git a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/GraphhopperJsonGenerator.java b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/GraphhopperJsonGenerator.java
new file mode 100644
index 0000000000..82e7bd5850
--- /dev/null
+++ b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/GraphhopperJsonGenerator.java
@@ -0,0 +1,63 @@
+package com.graphhopper.teavm;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintStream;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.GHDirectory;
+
+/**
+ *
+ * @author Alexey Andreev
+ */
+public class GraphhopperJsonGenerator {
+    public static void main(String[] args) throws IOException {
+        GraphHopper gh = new GraphHopper();
+        gh.setGraphHopperLocation("gh-folder");
+        gh.setOSMFile(args[0]);
+        gh.setInMemory(true);
+        gh.setEncodingManager(new EncodingManager(new Bike2WeightFlagEncoder()));
+        gh.set3D(true);
+        gh.importOrLoad();
+        GHDirectory dir = (GHDirectory)gh.getGraph().getDirectory();
+        byte[] buffer = new byte[1024];
+        PrintStream out = new PrintStream(new File(args[1]));
+        out.println("graphhopperData=[");
+        for (DataAccess dataAccess : dir.getAll()) {
+            out.print("{\"name\":\"" + dataAccess.getName() + "\",");
+            out.print("\"segmentSize\":" + dataAccess.getSegmentSize() + ",");
+            byte[] headerBytes = new byte[80];
+            for (int i = 0; i < 20; ++i) {
+                int val = dataAccess.getHeader(i * 4);
+                headerBytes[i * 4 + 0] = (byte)(val >>> 24);
+                headerBytes[i * 4 + 1] = (byte)(val >>> 16);
+                headerBytes[i * 4 + 2] = (byte)(val >>> 8);
+                headerBytes[i * 4 + 3] = (byte)val;
+            }
+            out.print("\"header\":\"" + Base64.encode(headerBytes) + "\",");
+            out.println("\"data\":[");
+
+            for (int i = 0; i < dataAccess.getCapacity(); i += buffer.length) {
+                int sz = (int)(Math.min(i + buffer.length, dataAccess.getCapacity()) - i);
+                for (int j = 0; j < sz; j += 4) {
+                    int val = dataAccess.getInt(i + j);
+                    buffer[j + 0] = (byte)(val >>> 24);
+                    buffer[j + 1] = (byte)(val >>> 16);
+                    buffer[j + 2] = (byte)(val >>> 8);
+                    buffer[j + 3] = (byte)(val >>> 0);
+                }
+                if (i > 0) {
+                    out.println(",");
+                }
+                out.print("\"" + Base64.encode(buffer) + "\"");
+
+            }
+            out.println("]},");
+        }
+        out.println("]");
+        out.close();
+    }
+}
diff --git a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/JSMap.java b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/JSMap.java
new file mode 100644
index 0000000000..8bee231637
--- /dev/null
+++ b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/JSMap.java
@@ -0,0 +1,16 @@
+package com.graphhopper.teavm;
+
+import org.teavm.jso.JSIndexer;
+import org.teavm.jso.JSObject;
+
+/**
+ *
+ * @author Alexey Andreev
+ */
+public interface JSMap<T extends JSObject> extends JSObject {
+    @JSIndexer
+    T get(String key);
+
+    @JSIndexer
+    void put(String key, T value);
+}
diff --git a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Main.java b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Main.java
index 2a31528bc9..f88d547efc 100644
--- a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Main.java
+++ b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Main.java
@@ -1,8 +1,12 @@
 package com.graphhopper.teavm;
 
+import org.teavm.jso.JS;
+import org.teavm.jso.JSArray;
+import org.teavm.jso.JSObject;
 import com.graphhopper.routing.DijkstraBidirection;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.util.PointList;
@@ -14,6 +18,7 @@
 public class Main {
     public static void main(String[] args) {
         InMemoryDirectory directory = new InMemoryDirectory();
+        readAll(directory);
         EncodingManager encodingManager = new EncodingManager(new BikeFlagEncoder());
         GraphHopperStorage graph = new GraphHopperStorage(directory, encodingManager, false);
         graph.loadExisting();
@@ -34,4 +39,26 @@ public static void main(String[] args) {
         }
         System.out.println("Distance: " + path.getDistance());
     }
+
+    private static void readAll(InMemoryDirectory directory) {
+        JSObject global = JS.getGlobal();
+        @SuppressWarnings("unchecked")
+        JSArray<DataEntry> data = (JSArray<DataEntry>)JS.get(global, JS.wrap("graphhopperData"));
+        for (int i = 0; i < data.getLength(); ++i) {
+            DataEntry entry = data.get(i);
+            DataAccess file = directory.find(entry.getName());
+            file.setSegmentSize(entry.getSegmentSize());
+            long pos = 0;
+            for (int j = 0; j < entry.getData().getLength(); ++j) {
+                byte[] bytes = Base64.decode(JS.unwrapString(entry.getData().get(0)));
+                for (int k = 0; k < bytes.length; k += 4) {
+                    int val = (bytes[k]) | (bytes[k + 1] << 8) | (bytes[k + 2] << 16) | (bytes[k + 3] << 24);
+                    file.setInt(j + k, val);
+                }
+                file.setBytes(pos, bytes, bytes.length);
+                pos += bytes.length;
+            }
+            file.setHeader(i, i);
+        }
+    }
 }
diff --git a/graphhopper-teavm/src/test/java/com/graphhopper/teavm/Base64Test.java b/graphhopper-teavm/src/test/java/com/graphhopper/teavm/Base64Test.java
new file mode 100644
index 0000000000..749b25e5d0
--- /dev/null
+++ b/graphhopper-teavm/src/test/java/com/graphhopper/teavm/Base64Test.java
@@ -0,0 +1,32 @@
+package com.graphhopper.teavm;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+/**
+ *
+ * @author Alexey Andreev
+ */
+public class Base64Test {
+    @Test
+    public void encodes() {
+        assertEquals("", Base64.encode(new byte[0]));
+        assertEquals("Zg==", Base64.encode("f".getBytes()));
+        assertEquals("Zm8=", Base64.encode("fo".getBytes()));
+        assertEquals("Zm9v", Base64.encode("foo".getBytes()));
+        assertEquals("Zm9vYg==", Base64.encode("foob".getBytes()));
+        assertEquals("Zm9vYmE=", Base64.encode("fooba".getBytes()));
+        assertEquals("Zm9vYmFy", Base64.encode("foobar".getBytes()));
+    }
+
+    @Test
+    public void decodes() {
+        assertArrayEquals(new byte[0], Base64.decode(""));
+        assertArrayEquals("f".getBytes(), Base64.decode("Zg=="));
+        assertArrayEquals("fo".getBytes(), Base64.decode("Zm8="));
+        assertArrayEquals("foo".getBytes(), Base64.decode("Zm9v"));
+        assertArrayEquals("foob".getBytes(), Base64.decode("Zm9vYg=="));
+        assertArrayEquals("fooba".getBytes(), Base64.decode("Zm9vYmE="));
+        assertArrayEquals("foobar".getBytes(), Base64.decode("Zm9vYmFy"));
+    }
+}
