diff --git a/acceptancetesting/src/test/cucumber/routing.feature b/acceptancetesting/src/test/cucumber/routing.feature
index 6a68370752..e8ee21442e 100644
--- a/acceptancetesting/src/test/cucumber/routing.feature
+++ b/acceptancetesting/src/test/cucumber/routing.feature
@@ -3,7 +3,7 @@ Feature: Verify a route from A to B
     I want to get a route from location A to location B using the routing service
     And route should be the fastest route and contain the waypoints,restrictions,time and other instructions
 
-  @Routing @New
+  @Routing 
   Scenario Outline: Verify  waypoints on a Route
     Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
     Then I should be able to verify the waypoints on the route map:
@@ -13,6 +13,7 @@ Feature: Verify a route from A to B
     Examples: 
       | pointA                                 | pointB                                 | routetype |
       | 51.471546541834144,-0.3618621826171875 | 51.45914115860512,-0.96679687499999995 | car       |
+      
 
   @Routing
   Scenario Outline: Verify  waypoints on a Route from Hounslow to Reading
@@ -275,3 +276,18 @@ Feature: Verify a route from A to B
     Examples: 
       | pointA              | pointB             | routetype |
       | 50.724316,-3.521008 | 50.72413,-3.518874 | car       |
+      
+      
+      
+    @Routing 
+  Scenario Outline: Verify  Private Road Restricted Access (Warwick Road-Carlisle)
+    Given I request a route between "<pointA>" and "<pointB>" as a "<routetype>" from RoutingAPI
+    Then I should be able to verify the trackPoints not on the route map:
+      | trackPointco      |
+      | 54.894721,-2.921665 |
+
+    Examples: 
+      | pointA              | pointB             | routetype |
+      | 54.894427,-2.921111 | 54.8922,-2.928296 | car       |
+      
+      
diff --git a/core/dpn-patch.txt b/core/dpn-patch.txt
new file mode 100644
index 0000000000..78bb520772
--- /dev/null
+++ b/core/dpn-patch.txt
@@ -0,0 +1,9325 @@
+### Eclipse Workspace Patch 1.0
+#P GraphHopper
+Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java	(working copy)
+@@ -23,12 +23,13 @@
+ import org.opengis.geometry.MismatchedDimensionException;
+ import org.opengis.referencing.FactoryException;
+ import org.opengis.referencing.operation.TransformException;
++import org.slf4j.Logger;
++import org.slf4j.LoggerFactory;
+ 
+ import uk.co.ordnancesurvey.api.srs.LatLong;
+ import uk.co.ordnancesurvey.api.srs.OpenCoordConverter;
+ 
+ import com.graphhopper.reader.Node;
+-import com.graphhopper.reader.osgb.OSITNElement;
+ import com.graphhopper.util.PointAccess;
+ 
+ /**
+@@ -37,132 +38,144 @@
+  * 
+  * @author Nop
+  */
+-public class OsDpnNode extends OSITNElement implements Node {
+-	private double lat;
+-	private double lon;
++public class OsDpnNode extends OsDpnElement implements Node {
++    private double lat;
++    private double lon;
++
++    private static final Logger logger = LoggerFactory
++            .getLogger(OsDpnElement.class);
+ 
+-	public static OsDpnNode create(long id, XMLStreamReader parser)
+-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+-		// int attributeCount = parser.getAttributeCount();
+-		// for (int i = 0; i < attributeCount; i++) {
+-		// QName attributeName = parser.getAttributeName(i);
+-		// System.err.println("QName:" + attributeName);
+-		// }
+-		OsDpnNode node = new OsDpnNode(id);
++    public static OsDpnNode create(String id, XMLStreamReader parser)
++            throws XMLStreamException, MismatchedDimensionException,
++            FactoryException, TransformException {
++        // int attributeCount = parser.getAttributeCount();
++        // for (int i = 0; i < attributeCount; i++) {
++        // QName attributeName = parser.getAttributeName(i);
++        // System.err.println("QName:" + attributeName);
++        // }
++        System.out.println("OsDpnNode.create()");
++        OsDpnNode node = new OsDpnNode(id);
+ 
+-		parser.nextTag();
+-		node.readTags(parser);
+-		return node;
+-	}
++        parser.nextTag();
++        node.readTags(parser);
++        return node;
++    }
+ 
+-	public OsDpnNode(long id, PointAccess pointAccess, int accessId) {
+-		super(id, NODE);
++    public OsDpnNode(String id, PointAccess pointAccess, int accessId) {
++        super(id, NODE);
+ 
+-		this.lat = pointAccess.getLatitude(accessId);
+-		this.lon = pointAccess.getLongitude(accessId);
+-		if (pointAccess.is3D())
+-			setTag("ele", pointAccess.getElevation(accessId));
+-	}
++        this.lat = pointAccess.getLatitude(accessId);
++        this.lon = pointAccess.getLongitude(accessId);
++        if (pointAccess.is3D())
++            setTag("ele", pointAccess.getElevation(accessId));
++    }
+ 
+-	public OsDpnNode(long id) {
+-		super(id, NODE);
++    public OsDpnNode(String id) {
++        super(id, NODE);
+ 
+-	}
++    }
+ 
+-	public double getLat() {
+-		return lat;
+-	}
++    @Override
++    public double getLat() {
++        return lat;
++    }
+ 
+-	public double getLon() {
+-		return lon;
+-	}
++    @Override
++    public double getLon() {
++        return lon;
++    }
+ 
+-	public double getEle() {
+-		Object ele = getTags().get("ele");
+-		if (ele == null)
+-			// return Double.NaN;
+-			return 1d;
+-		return (Double) ele;
+-	}
++    public double getEle() {
++        Object ele = getTags().get("ele");
++        if (ele == null)
++            // return Double.NaN;
++            return 1d;
++        return (Double) ele;
++    }
+ 
+-	@Override
+-	public void setTag(String name, Object value) {
+-		if ("ele".equals(name)) {
+-			if (value == null)
+-				value = null;
+-			else if (value instanceof String) {
+-				String str = (String) value;
+-				str = str.trim().replaceAll("\\,", ".");
+-				if (str.isEmpty())
+-					value = null;
+-				else
+-					try {
+-						value = Double.parseDouble(str);
+-					} catch (NumberFormatException ex) {
+-						return;
+-					}
+-			} else
+-				// force cast
+-				value = ((Number) value).doubleValue();
+-		}
+-		super.setTag(name, value);
+-	}
++    @Override
++    public void setTag(String name, Object value) {
++        if ("ele".equals(name)) {
++            if (value == null)
++                value = null;
++            else if (value instanceof String) {
++                String str = (String) value;
++                str = str.trim().replaceAll("\\,", ".");
++                if (str.isEmpty())
++                    value = null;
++                else
++                    try {
++                        value = Double.parseDouble(str);
++                    } catch (NumberFormatException ex) {
++                        return;
++                    }
++            } else
++                // force cast
++                value = ((Number) value).doubleValue();
++        }
++        super.setTag(name, value);
++    }
+ 
+-	@Override
+-	public String toString() {
+-		StringBuilder txt = new StringBuilder();
+-		txt.append("Node: ");
+-		txt.append(getId());
+-		txt.append(" lat=");
+-		txt.append(getLat());
+-		txt.append(" lon=");
+-		txt.append(getLon());
+-		if (!getTags().isEmpty()) {
+-			txt.append("\n");
+-			txt.append(tagsToString());
+-		}
+-		return txt.toString();
+-	}
++    @Override
++    public String toString() {
++        StringBuilder txt = new StringBuilder();
++        txt.append("Node: ");
++        txt.append(getId());
++        txt.append(" lat=");
++        txt.append(getLat());
++        txt.append(" lon=");
++        txt.append(getLon());
++        if (!getTags().isEmpty()) {
++            txt.append("\n");
++            txt.append(tagsToString());
++        }
++        return txt.toString();
++    }
+ 
+-	@Override
+-	protected void parseCoords(String elementText) throws MismatchedDimensionException, FactoryException, TransformException {
+-		String[] split = elementText.split(",");
++    @Override
++    public void parseCoords(String elementText)
++            throws MismatchedDimensionException, FactoryException,
++            TransformException {
++        String elementSeparator = " ";
++        parseCoordinateString(elementText, elementSeparator);
++    }
+ 
+-		Double easting = Double.parseDouble(split[0]);
+-		Double northing = Double.parseDouble(split[1]);
+-		LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
+-		lat = wgs84.getLatAngle();
+-		lon = wgs84.getLongAngle();
+-		System.err.println(toString());
+-	}
++    public void parseCoordinateString(String elementText,
++            String elementSeparator) throws MismatchedDimensionException,
++            FactoryException, TransformException {
++        String[] split = elementText.split(elementSeparator);
+ 
+-	@Override
+-	protected void parseNetworkMember(String elementText) {
+-		throw new UnsupportedOperationException("Nodes should not have members");
+-	}
++        if (3 == split.length) {
++            setTag("ele", split[2]);
++        }
++        Double easting = Double.parseDouble(split[0]);
++        Double northing = Double.parseDouble(split[1]);
++        LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
++        lat = wgs84.getLatAngle();
++        lon = wgs84.getLongAngle();
++        if (logger.isDebugEnabled())
++            logger.debug(toString());
++    }
+ 
+-	@Override
+-	protected void addDirectedNode(String nodeId, String grade, String orientation) {
+-		throw new UnsupportedOperationException(
+-				"Nodes should not have directed nodes");
+-	}
+-	
+-	@Override
+-	protected void addDirectedLink(String nodeId, String orientation) {
+-		throw new UnsupportedOperationException(
+-				"Nodes should not have directed links");
+-	}
++    @Override
++    protected void parseNetworkMember(String elementText) {
++        throw new UnsupportedOperationException("Nodes should not have members");
++    }
+ 
+-	@Override
+-	protected void parseCoordinateString(String elementText,
+-			String elementSeparator) {
+-		throw new UnsupportedOperationException();
+-		
+-	}
++    @Override
++    protected void addNode(String nodeId) {
++        throw new UnsupportedOperationException(
++                "Nodes should not have directed nodes");
++    }
+ 
+-	@Override
+-	protected void parseCoords(int dimensions, String lineDefinition) {
+-		throw new UnsupportedOperationException();
+-	}
++    @Override
++    protected void addDirectedLink(String nodeId, String orientation) {
++        throw new UnsupportedOperationException(
++                "Nodes should not have directed links");
++    }
++
++    protected void parseCoords(int dimensions, String lineDefinition) {
++        throw new UnsupportedOperationException();
++    }
+ 
+ }
+Index: core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java	(working copy)
+@@ -41,140 +41,156 @@
+  * @author Nop
+  */
+ public class OSITNNode extends OSITNElement implements Node {
+-	private double lat;
+-	private double lon;
+-	private static final Logger logger = LoggerFactory
+-			.getLogger(OSITNNode.class);
+-	private boolean[] clones = {false,false,false,false};
++    private double lat;
++    private double lon;
++    private static final Logger logger = LoggerFactory
++            .getLogger(OSITNNode.class);
++    private final boolean[] clones = { false, false, false, false };
++
++    public static OSITNNode create(long id, XMLStreamReader parser)
++            throws XMLStreamException, MismatchedDimensionException,
++            FactoryException, TransformException {
++        OSITNNode node = new OSITNNode(id);
+ 
+-	public static OSITNNode create(long id, XMLStreamReader parser)
+-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+-		OSITNNode node = new OSITNNode(id);
++        parser.nextTag();
++        node.readTags(parser);
++        return node;
++    }
+ 
+-		parser.nextTag();
+-		node.readTags(parser);
+-		return node;
+-	}
++    public OSITNNode(long id, PointAccess pointAccess, int accessId) {
++        super(id, NODE);
+ 
+-	public OSITNNode(long id, PointAccess pointAccess, int accessId) {
+-		super(id, NODE);
++        this.lat = pointAccess.getLatitude(accessId);
++        this.lon = pointAccess.getLongitude(accessId);
++        if (pointAccess.is3D())
++            setTag("ele", pointAccess.getElevation(accessId));
++    }
+ 
+-		this.lat = pointAccess.getLatitude(accessId);
+-		this.lon = pointAccess.getLongitude(accessId);
+-		if (pointAccess.is3D())
+-			setTag("ele", pointAccess.getElevation(accessId));
+-	}
+-	
+-	public OSITNNode(long id) {
+-		super(id, NODE);
++    public OSITNNode(long id, double lat, double lon) {
++        super(id, NODE);
+ 
+-	}
++        this.lat = lat;
++        this.lon = lon;
++    }
+ 
+-	public double getLat() {
+-		return lat;
+-	}
++    public OSITNNode(long id) {
++        super(id, NODE);
+ 
+-	public double getLon() {
+-		return lon;
+-	}
++    }
+ 
+-	public double getEle() {
+-		Object ele = getTags().get("ele");
+-		if (ele == null)
+-			// return Double.NaN;
+-			return 1d;
+-		return (Double) ele;
+-	}
++    @Override
++    public double getLat() {
++        return lat;
++    }
+ 
+-	@Override
+-	public void setTag(String name, Object value) {
+-		if ("ele".equals(name)) {
+-			if (value == null)
+-				value = null;
+-			else if (value instanceof String) {
+-				String str = (String) value;
+-				str = str.trim().replaceAll("\\,", ".");
+-				if (str.isEmpty())
+-					value = null;
+-				else
+-					try {
+-						value = Double.parseDouble(str);
+-					} catch (NumberFormatException ex) {
+-						return;
+-					}
+-			} else
+-				// force cast
+-				value = ((Number) value).doubleValue();
+-		}
+-		super.setTag(name, value);
+-	}
++    @Override
++    public double getLon() {
++        return lon;
++    }
+ 
+-	@Override
+-	public String toString() {
+-		StringBuilder txt = new StringBuilder();
+-		txt.append("Node: ");
+-		txt.append(getId());
+-		txt.append(" lat=");
+-		txt.append(getLat());
+-		txt.append(" lon=");
+-		txt.append(getLon());
+-		if (!getTags().isEmpty()) {
+-			txt.append("\n");
+-			txt.append(tagsToString());
+-		}
+-		return txt.toString();
+-	}
++    public double getEle() {
++        Object ele = getTags().get("ele");
++        if (ele == null)
++            // return Double.NaN;
++            return 1d;
++        return (Double) ele;
++    }
+ 
+-	@Override
+-	public void parseCoords(String elementText) throws MismatchedDimensionException, FactoryException, TransformException {
+-		String elementSeparator = ",";
+-		parseCoordinateString(elementText, elementSeparator);
+-	}
++    @Override
++    public void setTag(String name, Object value) {
++        if ("ele".equals(name)) {
++            if (value == null)
++                value = null;
++            else if (value instanceof String) {
++                String str = (String) value;
++                str = str.trim().replaceAll("\\,", ".");
++                if (str.isEmpty())
++                    value = null;
++                else
++                    try {
++                        value = Double.parseDouble(str);
++                    } catch (NumberFormatException ex) {
++                        return;
++                    }
++            } else
++                // force cast
++                value = ((Number) value).doubleValue();
++        }
++        super.setTag(name, value);
++    }
+ 
+-	public void parseCoordinateString(String elementText,
+-			String elementSeparator) throws MismatchedDimensionException, FactoryException, TransformException {
+-		String[] split = elementText.split(elementSeparator);
++    @Override
++    public String toString() {
++        StringBuilder txt = new StringBuilder();
++        txt.append("Node: ");
++        txt.append(getId());
++        txt.append(" lat=");
++        txt.append(getLat());
++        txt.append(" lon=");
++        txt.append(getLon());
++        if (!getTags().isEmpty()) {
++            txt.append("\n");
++            txt.append(tagsToString());
++        }
++        return txt.toString();
++    }
+ 
+-		if(3==split.length) {
+-			setTag("ele", split[2]);
+-		}
+-		Double easting = Double.parseDouble(split[0]);
+-		Double northing = Double.parseDouble(split[1]);
+-		LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
+-		lat = wgs84.getLatAngle();
+-		lon = wgs84.getLongAngle();
+-		if (logger.isDebugEnabled()) logger.debug(toString());
+-	}
++    @Override
++    public void parseCoords(String elementText)
++            throws MismatchedDimensionException, FactoryException,
++            TransformException {
++        String elementSeparator = ",";
++        parseCoordinateString(elementText, elementSeparator);
++    }
+ 
+-	@Override
+-	protected void parseNetworkMember(String elementText) {
+-		throw new UnsupportedOperationException("Nodes should not have members");
+-	}
++    @Override
++    public void parseCoordinateString(String elementText,
++            String elementSeparator) throws MismatchedDimensionException,
++            FactoryException, TransformException {
++        String[] split = elementText.split(elementSeparator);
+ 
+-	@Override
+-	protected void addDirectedNode(String nodeId, String grade, String orientation) {
+-		throw new UnsupportedOperationException(
+-				"Nodes should not have directed nodes");
+-	}
+-	
+-	@Override
+-	protected void addDirectedLink(String nodeId, String orientation) {
+-		throw new UnsupportedOperationException(
+-				"Nodes should not have directed links");
+-	}
+-	
+-	public OSITNNode gradeClone(long nodeId) {
+-		OSITNNode clone = new OSITNNode(nodeId);
+-		Map<String, Object> tags = this.getTags();
+-		clone.setTags(tags);
+-		clone.lat = this.lat;
+-		clone.lon = this.lon;
+-		return clone;
+-	}
++        if (3 == split.length) {
++            setTag("ele", split[2]);
++        }
++        Double easting = Double.parseDouble(split[0]);
++        Double northing = Double.parseDouble(split[1]);
++        LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
++        lat = wgs84.getLatAngle();
++        lon = wgs84.getLongAngle();
++        if (logger.isDebugEnabled())
++            logger.debug(toString());
++    }
+ 
+-	@Override
+-	protected void parseCoords(int dimensions, String lineDefinition) {
+-		throw new UnsupportedOperationException();
+-	}
++    @Override
++    protected void parseNetworkMember(String elementText) {
++        throw new UnsupportedOperationException("Nodes should not have members");
++    }
++
++    @Override
++    protected void addDirectedNode(String nodeId, String grade,
++            String orientation) {
++        throw new UnsupportedOperationException(
++                "Nodes should not have directed nodes");
++    }
++
++    @Override
++    protected void addDirectedLink(String nodeId, String orientation) {
++        throw new UnsupportedOperationException(
++                "Nodes should not have directed links");
++    }
++
++    public OSITNNode gradeClone(long nodeId) {
++        OSITNNode clone = new OSITNNode(nodeId);
++        Map<String, Object> tags = this.getTags();
++        clone.setTags(tags);
++        clone.lat = this.lat;
++        clone.lon = this.lon;
++        return clone;
++    }
++
++    @Override
++    protected void parseCoords(int dimensions, String lineDefinition) {
++        throw new UnsupportedOperationException();
++    }
+ 
+ }
+Index: core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java	(working copy)
+@@ -4,20 +4,15 @@
+ import java.util.Collection;
+ import java.util.Collections;
+ import java.util.HashMap;
+-import java.util.HashSet;
+ import java.util.Map;
+-import java.util.Set;
+ 
+ import org.slf4j.Logger;
+ import org.slf4j.LoggerFactory;
+ 
+ import com.graphhopper.reader.DataReader;
+ import com.graphhopper.reader.ITurnCostTableEntry;
+-import com.graphhopper.reader.OSMReader;
+-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
+ import com.graphhopper.reader.OSMTurnRelation.Type;
+ import com.graphhopper.reader.TurnRelation;
+-import com.graphhopper.routing.util.AbstractFlagEncoder;
+ import com.graphhopper.routing.util.TurnCostEncoder;
+ import com.graphhopper.util.EdgeExplorer;
+ import com.graphhopper.util.EdgeIterator;
+@@ -30,7 +25,8 @@
+  * @author Stuart Adam
+  */
+ public class OSITNTurnRelation implements TurnRelation {
+-    private static final Logger logger = LoggerFactory.getLogger(OSITNTurnRelation.class);
++    private static final Logger logger = LoggerFactory
++            .getLogger(OSITNTurnRelation.class);
+ 
+     private static Map<String, Type> tags = new HashMap<String, Type>();
+ 
+@@ -52,7 +48,8 @@
+     private final long toOsmWayId;
+     private final Type restriction;
+ 
+-    public OSITNTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType) {
++    public OSITNTurnRelation(long fromWayID, long viaNodeID, long toWayID,
++            Type restrictionType) {
+         this.fromOsmWayId = fromWayID;
+         this.viaOsmNodeId = viaNodeID;
+         this.toOsmWayId = toWayID;
+@@ -90,7 +87,11 @@
+      * @return a collection of node cost entries which can be added to the graph
+      *         later
+      */
+-    public Collection<ITurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder, EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader osmReader) {
++    @Override
++    public Collection<ITurnCostTableEntry> getRestrictionAsEntries(
++            TurnCostEncoder encoder, EdgeExplorer edgeOutExplorer,
++            EdgeExplorer edgeInExplorer, DataReader dataReader) {
++        DataReader<Long> osmReader = dataReader;
+         int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
+ 
+         try {
+@@ -124,7 +125,10 @@
+             while (iter.next()) {
+                 int edgeId = iter.getEdge();
+                 long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
+-                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0) {
++                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY
++                        && wayId != this.toOsmWayId
++                        || this.restriction == Type.NOT
++                        && wayId == this.toOsmWayId && wayId >= 0) {
+                     final TurnCostTableEntry entry = new TurnCostTableEntry();
+                     entry.nodeViaNode = viaNodeId;
+                     entry.edgeFrom = edgeIdFrom;
+@@ -138,13 +142,16 @@
+             }
+             return entries;
+         } catch (Exception e) {
+-            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
++            throw new IllegalStateException(
++                    "Could not built turn table entry for relation of node with osmId:"
++                            + this.viaOsmNodeId, e);
+         }
+     }
+ 
+     @Override
+     public String toString() {
+-        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
++        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId
++                + ")->*";
+     }
+ 
+     /**
+@@ -160,8 +167,9 @@
+          * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if
+          *         multiple encoders are involved.
+          */
++        @Override
+         public long getItemId() {
+-            return ((long) edgeFrom) << 32 | ((long) edgeTo);
++            return ((long) edgeFrom) << 32 | (edgeTo);
+         }
+ 
+         @Override
+@@ -192,7 +200,8 @@
+ 
+         @Override
+         public String toString() {
+-            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
++            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo
++                    + ")->*";
+         }
+     }
+ 
+Index: core/src/main/java/com/graphhopper/reader/OSMReader.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/OSMReader.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/OSMReader.java	(working copy)
+@@ -40,10 +40,12 @@
+ 
+ import com.graphhopper.coll.GHLongIntBTree;
+ import com.graphhopper.coll.LongIntMap;
+-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
+ import com.graphhopper.reader.dem.ElevationProvider;
+ import com.graphhopper.routing.util.EncodingManager;
+-import com.graphhopper.storage.*;
++import com.graphhopper.storage.ExtendedStorage;
++import com.graphhopper.storage.GraphStorage;
++import com.graphhopper.storage.NodeAccess;
++import com.graphhopper.storage.TurnCostStorage;
+ import com.graphhopper.util.DistanceCalc;
+ import com.graphhopper.util.DistanceCalc3D;
+ import com.graphhopper.util.DistanceCalcEarth;
+@@ -74,10 +76,10 @@
+  * 2.b) Reads ways OSM file and creates edges while calculating the speed etc from the OSM tags.
+  * When creating an edge the pillar node information from the intermediate datastructure will be
+  * stored in the way geometry of that edge.
+- * <p/>
++ * <p/> 
+  * @author Peter Karich
+  */
+-public class OSMReader implements DataReader
++public class OSMReader implements DataReader<Long>
+ {
+     protected static final int EMPTY = -1;
+     // pillar node is >= 3
+@@ -98,7 +100,7 @@
+     // only append and update possible (no unordered storage like with this doubleParse): new OSMIDMap
+     // same here: not applicable as ways introduces the nodes in 'wrong' order: new OSMIDSegmentedMap
+     // memory overhead due to open addressing and full rehash:
+-    //        nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
++    // nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
+     // smaller memory overhead for bigger data sets because of avoiding a "rehash"
+     // remember how many times a node was used to identify tower nodes
+     private LongIntMap osmNodeIdToInternalNodeMap;
+@@ -121,111 +123,113 @@
+     private boolean exitOnlyPillarNodeException = true;
+     private File osmFile;
+ 
+-    public OSMReader( GraphStorage storage )
++    public OSMReader(GraphStorage storage)
+     {
+-        this.graphStorage = storage;
+-        this.nodeAccess = graphStorage.getNodeAccess();
++	this.graphStorage = storage;
++	this.nodeAccess = graphStorage.getNodeAccess();
+ 
+-        osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
+-        osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
+-        osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
+-        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
++	osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
++	osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
++	osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
++	pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
+     }
+ 
+     @Override
+     public void readGraph() throws IOException
+     {
+-        if (encodingManager == null)
+-            throw new IllegalStateException("Encoding manager was not set.");
++	if (encodingManager == null)
++	    throw new IllegalStateException("Encoding manager was not set.");
+ 
+-        if (osmFile == null)
+-            throw new IllegalStateException("No OSM file specified");
++	if (osmFile == null)
++	    throw new IllegalStateException("No OSM file specified");
+ 
+-        if (!osmFile.exists())
+-            throw new IllegalStateException("Your specified OSM file does not exist:" + osmFile.getAbsolutePath());
++	if (!osmFile.exists())
++	    throw new IllegalStateException("Your specified OSM file does not exist:"
++			    + osmFile.getAbsolutePath());
+ 
+-        StopWatch sw1 = new StopWatch().start();
+-        preProcess(osmFile);
+-        sw1.stop();
++	StopWatch sw1 = new StopWatch().start();
++	preProcess(osmFile);
++	sw1.stop();
+ 
+-        StopWatch sw2 = new StopWatch().start();
+-        writeOsm2Graph(osmFile);
+-        sw2.stop();
++	StopWatch sw2 = new StopWatch().start();
++	writeOsm2Graph(osmFile);
++	sw2.stop();
+ 
+-        logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: " + (int) sw2.getSeconds() + " total:"
+-                + ((int) (sw1.getSeconds() + sw2.getSeconds())));
++	logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: " + (int) sw2.getSeconds()
++			+ " total:" + (int) (sw1.getSeconds() + sw2.getSeconds()));
+     }
+ 
+     /**
+      * Preprocessing of OSM file to select nodes which are used for highways. This allows a more
+      * compact graph data structure.
+      */
+-    void preProcess( File osmFile )
++    void preProcess(File osmFile)
+     {
+-        OSMInputFile in = null;
+-        try
+-        {
+-            in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
++	OSMInputFile in = null;
++	try
++	{
++	    in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
+ 
+-            long tmpWayCounter = 1;
+-            long tmpRelationCounter = 1;
+-            RoutingElement item;
+-            while ((item = in.getNext()) != null)
+-            {
+-                if (item.isType(OSMElement.WAY))
+-                {
+-                    final OSMWay way = (OSMWay) item;
+-                    boolean valid = filterWay(way);
+-                    if (valid)
+-                    {
+-                        TLongList wayNodes = way.getNodes();
+-                        int s = wayNodes.size();
+-                        for (int index = 0; index < s; index++)
+-                        {
+-                            prepareHighwayNode(wayNodes.get(index));
+-                        }
++	    long tmpWayCounter = 1;
++	    long tmpRelationCounter = 1;
++	    RoutingElement item;
++	    while ((item = in.getNext()) != null)
++	    {
++		if (item.isType(OSMElement.WAY))
++		{
++		    final OSMWay way = (OSMWay) item;
++		    boolean valid = filterWay(way);
++		    if (valid)
++		    {
++			TLongList wayNodes = way.getNodes();
++			int s = wayNodes.size();
++			for (int index = 0; index < s; index++)
++			{
++			    prepareHighwayNode(wayNodes.get(index));
++			}
+ 
+-                        if (++tmpWayCounter % 5000000 == 0)
+-                        {
+-                            logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:" + nf(getNodeMap().getSize()) + " ("
+-                                    + getNodeMap().getMemoryUsage() + "MB) " + Helper.getMemInfo());
+-                        }
+-                    }
+-                }
+-                if (item.isType(OSMElement.RELATION))
+-                {
+-                    final OSMRelation relation = (OSMRelation) item;
+-                    if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
+-                        prepareWaysWithRelationInfo(relation);
++			if (++tmpWayCounter % 5000000 == 0)
++			{
++			    logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:"
++					    + nf(getNodeMap().getSize()) + " ("
++					    + getNodeMap().getMemoryUsage() + "MB) "
++					    + Helper.getMemInfo());
++			}
++		    }
++		}
++		if (item.isType(OSMElement.RELATION))
++		{
++		    final OSMRelation relation = (OSMRelation) item;
++		    if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
++			prepareWaysWithRelationInfo(relation);
+ 
+-                    if (relation.hasTag("type", "restriction"))
+-                        prepareRestrictionRelation(relation);
++		    if (relation.hasTag("type", "restriction"))
++			prepareRestrictionRelation(relation);
+ 
+-                    if (++tmpRelationCounter % 50000 == 0)
+-                    {
+-                        logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size())
+-                                + " " + Helper.getMemInfo());
+-                    }
+-
+-                }
+-            }
+-        } catch (Exception ex)
+-        {
+-            throw new RuntimeException("Problem while parsing file", ex);
+-        } finally
+-        {
+-            Helper.close(in);
+-        }
++		    if (++tmpRelationCounter % 50000 == 0)
++		    {
++			logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:"
++					+ nf(getRelFlagsMap().size()) + " " + Helper.getMemInfo());
++		    }
++		}
++	    }
++	} catch (Exception ex)
++	{
++	    throw new RuntimeException("Problem while parsing file", ex);
++	} finally
++	{
++	    Helper.close(in);
++	}
+     }
+ 
+-    private void prepareRestrictionRelation( OSMRelation relation )
++    private void prepareRestrictionRelation(OSMRelation relation)
+     {
+-        TurnRelation turnRelation = createTurnRelation(relation);
+-        if (turnRelation != null)
+-        {
+-            getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
+-            getOsmWayIdSet().add(turnRelation.getOsmIdTo());
+-        }
++	TurnRelation turnRelation = createTurnRelation(relation);
++	if (turnRelation != null)
++	{
++	    getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
++	    getOsmWayIdSet().add(turnRelation.getOsmIdTo());
++	}
+     }
+ 
+     /**
+@@ -233,15 +237,15 @@
+      */
+     private TLongSet getOsmWayIdSet()
+     {
+-        return osmWayIdSet;
++	return osmWayIdSet;
+     }
+ 
+     private TIntLongMap getEdgeIdToOsmWayIdMap()
+     {
+-        if (edgeIdToOsmWayIdMap == null)
+-            edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
++	if (edgeIdToOsmWayIdMap == null)
++	    edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
+ 
+-        return edgeIdToOsmWayIdMap;
++	return edgeIdToOsmWayIdMap;
+     }
+ 
+     /**
+@@ -250,652 +254,661 @@
+      * <p/>
+      * @return true the current xml entry is a way entry and has nodes
+      */
+-    boolean filterWay( OSMWay item )
++    boolean filterWay(OSMWay item)
+     {
+-        // ignore broken geometry
+-        if (item.getNodes().size() < 2)
+-            return false;
++	// ignore broken geometry
++	if (item.getNodes().size() < 2)
++	    return false;
+ 
+-        // ignore multipolygon geometry
+-        if (!item.hasTags())
+-            return false;
++	// ignore multipolygon geometry
++	if (!item.hasTags())
++	    return false;
+ 
+-        return encodingManager.acceptWay(item) > 0;
++	return encodingManager.acceptWay(item) > 0;
+     }
+ 
+     /**
+      * Creates the edges and nodes files from the specified osm file.
+      */
+-    private void writeOsm2Graph( File osmFile )
++    private void writeOsm2Graph(File osmFile)
+     {
+-        int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
+-        
+-        logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize()) + ", " + Helper.getMemInfo());
+-        graphStorage.create(tmp);
+-        long wayStart = -1;
+-        long relationStart = -1;
+-        long counter = 1;
+-        OSMInputFile in = null;
+-        try
+-        {
+-            in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
+-            LongIntMap nodeFilter = getNodeMap();
++	int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
++
++	logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize())
++			+ ", " + Helper.getMemInfo());
++	graphStorage.create(tmp);
++	long wayStart = -1;
++	long relationStart = -1;
++	long counter = 1;
++	OSMInputFile in = null;
++	try
++	{
++	    in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
++	    LongIntMap nodeFilter = getNodeMap();
+ 
+-            RoutingElement item;
+-            while ((item = in.getNext()) != null)
+-            {
+-                switch (item.getType())
+-                {
+-                    case OSMElement.NODE:
+-                        if (nodeFilter.get(item.getId()) != -1)
+-                        {
+-                            processNode((OSMNode) item);
+-                        }
+-                        break;
++	    RoutingElement item;
++	    while ((item = in.getNext()) != null)
++	    {
++		switch (item.getType())
++		{
++		case OSMElement.NODE:
++		    OSMNode node = (OSMNode) item;
++		    if (nodeFilter.get(node.getId()) != -1)
++		    {
++			processNode((OSMNode) item);
++		    }
++		    break;
+ 
+-                    case OSMElement.WAY:
+-                        if (wayStart < 0)
+-                        {
+-                            logger.info(nf(counter) + ", now parsing ways");
+-                            wayStart = counter;
+-                        }
+-                        processWay((OSMWay) item);
+-                        break;
+-                    case OSMElement.RELATION:
+-                        if (relationStart < 0)
+-                        {
+-                            logger.info(nf(counter) + ", now parsing relations");
+-                            relationStart = counter;
+-                        }
+-                        processRelation((OSMRelation) item);
+-                        break;
+-                }
+-                if (++counter % 100000000 == 0)
+-                {
+-                    logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations + ") " + Helper.getMemInfo());
+-                }
+-            }
++		case OSMElement.WAY:
++		    if (wayStart < 0)
++		    {
++			logger.info(nf(counter) + ", now parsing ways");
++			wayStart = counter;
++		    }
++		    processWay((OSMWay) item);
++		    break;
++		case OSMElement.RELATION:
++		    if (relationStart < 0)
++		    {
++			logger.info(nf(counter) + ", now parsing relations");
++			relationStart = counter;
++		    }
++		    processRelation((OSMRelation) item);
++		    break;
++		}
++		if (++counter % 100000000 == 0)
++		{
++		    logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations
++				    + ") " + Helper.getMemInfo());
++		}
++	    }
+ 
+-            // logger.info("storage nodes:" + storage.nodes() + " vs. graph nodes:" + storage.getGraph().nodes());
+-        } catch (Exception ex)
+-        {
+-            throw new RuntimeException("Couldn't process file " + osmFile + ", error: " + ex.getMessage(), ex);
+-        } finally
+-        {
+-            Helper.close(in);
+-        }
++	    // logger.info("storage nodes:" + storage.nodes() +
++	    // " vs. graph nodes:" + storage.getGraph().nodes());
++	} catch (Exception ex)
++	{
++	    throw new RuntimeException("Couldn't process file " + osmFile + ", error: "
++			    + ex.getMessage(), ex);
++	} finally
++	{
++	    Helper.close(in);
++	}
+ 
+-        finishedReading();
+-        if (graphStorage.getNodes() == 0)
+-            throw new IllegalStateException("osm must not be empty. read " + counter + " lines and " + locations + " locations");
++	finishedReading();
++	if (graphStorage.getNodes() == 0)
++	    throw new IllegalStateException("osm must not be empty. read " + counter
++			    + " lines and " + locations + " locations");
+     }
+ 
+     /**
+      * Process properties, encode flags and create edges for the way.
+      */
+-    void processWay( OSMWay way )
++    void processWay(OSMWay way)
+     {
+-        if (way.getNodes().size() < 2)
+-            return;
++	if (way.getNodes().size() < 2)
++	    return;
+ 
+-        // ignore multipolygon geometry
+-        if (!way.hasTags())
+-            return;
++	// ignore multipolygon geometry
++	if (!way.hasTags())
++	    return;
+ 
+-        long wayOsmId = way.getId();
++	long wayOsmId = way.getId();
+ 
+-        long includeWay = encodingManager.acceptWay(way);
+-        if (includeWay == 0)
+-            return;
++	long includeWay = encodingManager.acceptWay(way);
++	if (includeWay == 0)
++	    return;
+ 
+-        long relationFlags = getRelFlagsMap().get(way.getId());
++	long relationFlags = getRelFlagsMap().get(way.getId());
+ 
+-        // TODO move this after we have created the edge and know the coordinates => encodingManager.applyWayTags
+-        // estimate length of the track e.g. for ferry speed calculation
+-        TLongList osmNodeIds = way.getNodes();
+-        if (osmNodeIds.size() > 1)
+-        {
+-            int first = getNodeMap().get(osmNodeIds.get(0));
+-            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+-            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+-            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+-            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon))
+-            {
+-                double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
+-                way.setTag("estimated_distance", estimatedDist);
+-                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
+-            }
+-        }
++	// TODO move this after we have created the edge and know the
++	// coordinates => encodingManager.applyWayTags
++	// estimate length of the track e.g. for ferry speed calculation
++	TLongList osmNodeIds = way.getNodes();
++	if (osmNodeIds.size() > 1)
++	{
++	    int first = getNodeMap().get(osmNodeIds.get(0));
++	    int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
++	    double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
++	    double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
++	    if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat)
++			    && !Double.isNaN(lastLon))
++	    {
++		double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
++		way.setTag("estimated_distance", estimatedDist);
++		way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2,
++				(firstLon + lastLon) / 2));
++	    }
++	}
+ 
+-        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
+-        if (wayFlags == 0)
+-            return;
++	long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
++	if (wayFlags == 0)
++	    return;
+ 
+-        List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
+-        // look for barriers along the way
+-        final int size = osmNodeIds.size();
+-        int lastBarrier = -1;
+-        for (int i = 0; i < size; i++)
+-        {
+-            long nodeId = osmNodeIds.get(i);
+-            long nodeFlags = getNodeFlagsMap().get(nodeId);
+-            // barrier was spotted and way is otherwise passable for that mode of travel
+-            if (nodeFlags > 0)
+-            {
+-                if ((nodeFlags & wayFlags) > 0)
+-                {
+-                    // remove barrier to avoid duplicates
+-                    getNodeFlagsMap().put(nodeId, 0);
++	List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
++	// look for barriers along the way
++	final int size = osmNodeIds.size();
++	int lastBarrier = -1;
++	for (int i = 0; i < size; i++)
++	{
++	    long nodeId = osmNodeIds.get(i);
++	    long nodeFlags = getNodeFlagsMap().get(nodeId);
++	    // barrier was spotted and way is otherwise passable for that mode
++	    // of travel
++	    if (nodeFlags > 0)
++		if ((nodeFlags & wayFlags) > 0)
++		{
++		    // remove barrier to avoid duplicates
++		    getNodeFlagsMap().put(nodeId, 0);
+ 
+-                    // create shadow node copy for zero length edge
+-                    long newNodeId = addBarrierNode(nodeId);
+-                    if (i > 0)
+-                    {
+-                        // start at beginning of array if there was no previous barrier
+-                        if (lastBarrier < 0)
+-                            lastBarrier = 0;
++		    // create shadow node copy for zero length edge
++		    long newNodeId = addBarrierNode(nodeId);
++		    if (i > 0)
++		    {
++			// start at beginning of array if there was no previous
++			// barrier
++			if (lastBarrier < 0)
++			    lastBarrier = 0;
+ 
+-                        // add way up to barrier shadow node
+-                        long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
+-                        transfer[transfer.length - 1] = newNodeId;
+-                        TLongList partIds = new TLongArrayList(transfer);
+-                        createdEdges.addAll(addOSMWay(partIds, wayFlags, wayOsmId));
++			// add way up to barrier shadow node
++			long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
++			transfer[transfer.length - 1] = newNodeId;
++			TLongList partIds = new TLongArrayList(transfer);
++			createdEdges.addAll(addOSMWay(partIds, wayFlags, wayOsmId));
+ 
+-                        // create zero length edge for barrier
+-                        createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId));
+-                    } else
+-                    {
+-                        // run edge from real first node to shadow node
+-                        createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId));
++			// create zero length edge for barrier
++			createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags,
++					wayOsmId));
++		    } else
++		    {
++			// run edge from real first node to shadow node
++			createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags,
++					wayOsmId));
+ 
+-                        // exchange first node for created barrier node
+-                        osmNodeIds.set(0, newNodeId);
+-                    }
+-                    // remember barrier for processing the way behind it
+-                    lastBarrier = i;
+-                }
+-            }
+-        }
++			// exchange first node for created barrier node
++			osmNodeIds.set(0, newNodeId);
++		    }
++		    // remember barrier for processing the way behind it
++		    lastBarrier = i;
++		}
++	}
+ 
+-        // just add remainder of way to graph if barrier was not the last node
+-        if (lastBarrier >= 0)
+-        {
+-            if (lastBarrier < size - 1)
+-            {
+-                long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
+-                TLongList partNodeIds = new TLongArrayList(transfer);
+-                createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
+-            }
+-        } else
+-        {
+-            // no barriers - simply add the whole way
+-            createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
+-        }
++	// just add remainder of way to graph if barrier was not the last node
++	if (lastBarrier >= 0)
++	{
++	    if (lastBarrier < size - 1)
++	    {
++		long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
++		TLongList partNodeIds = new TLongArrayList(transfer);
++		createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
++	    }
++	} else
++	    // no barriers - simply add the whole way
++	    createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
+ 
+-        for (EdgeIteratorState edge : createdEdges)
+-        {
+-            encodingManager.applyWayTags(way, edge);
+-        }
++	for (EdgeIteratorState edge : createdEdges)
++	    encodingManager.applyWayTags(way, edge);
+     }
+ 
+-    public void processRelation( OSMRelation relation ) throws XMLStreamException
++    public void processRelation(OSMRelation relation) throws XMLStreamException
+     {
+-        if (relation.hasTag("type", "restriction"))
+-        {
+-            TurnRelation turnRelation = createTurnRelation(relation);
+-            if (turnRelation != null)
+-            {
+-                ExtendedStorage extendedStorage = graphStorage.getExtendedStorage();
+-                if (extendedStorage instanceof TurnCostStorage)
+-                {
+-                    TurnCostStorage tcs = (TurnCostStorage) extendedStorage;
+-                    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(turnRelation, this);
+-                    for (ITurnCostTableEntry entry : entries)
+-                    {
+-                        tcs.addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(), (int) entry.getFlags());
+-                    }
+-                }
+-            }
+-        }
++	if (relation.hasTag("type", "restriction"))
++	{
++	    TurnRelation turnRelation = createTurnRelation(relation);
++	    if (turnRelation != null)
++	    {
++		ExtendedStorage extendedStorage = graphStorage.getExtendedStorage();
++		if (extendedStorage instanceof TurnCostStorage)
++		{
++		    TurnCostStorage tcs = (TurnCostStorage) extendedStorage;
++		    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(
++				    turnRelation, this);
++		    for (ITurnCostTableEntry entry : entries)
++			tcs.addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(),
++					(int) entry.getFlags());
++		}
++	    }
++	}
+     }
+ 
+     /**
+      * @return OSM way ID from specified edgeId. Only previously stored OSM-way-IDs are returned in
+-     * order to reduce memory overhead.
++     *         order to reduce memory overhead.
+      */
+-    public long getOsmIdOfInternalEdge( int edgeId )
++    @Override
++    public Long getOsmIdOfInternalEdge(int edgeId)
+     {
+-        return getEdgeIdToOsmWayIdMap().get(edgeId);
++	return getEdgeIdToOsmWayIdMap().get(edgeId);
+     }
+ 
+-    public int getInternalNodeIdOfOsmNode( long nodeOsmId )
++    @Override
++    public int getInternalNodeIdOfOsmNode(Long nodeOsmId)
+     {
+-        int id = getNodeMap().get(nodeOsmId);
+-        if (id < TOWER_NODE)
+-            return -id - 3;
++	int id = getNodeMap().get(nodeOsmId);
++	if (id < TOWER_NODE)
++	    return -id - 3;
+ 
+-        return EMPTY;
++	return EMPTY;
+     }
+ 
+-    // TODO remove this ugly stuff via better preparsing phase! E.g. putting every tags etc into a helper file!
+-    double getTmpLatitude( int id )
++    // TODO remove this ugly stuff via better preparsing phase! E.g. putting
++    // every tags etc into a helper file!
++    double getTmpLatitude(int id)
+     {
+-        if (id == EMPTY)
+-            return Double.NaN;
+-        if (id < TOWER_NODE)
+-        {
+-            // tower node
+-            id = -id - 3;
+-            return nodeAccess.getLatitude(id);
+-        } else if (id > -TOWER_NODE)
+-        {
+-            // pillar node
+-            id = id - 3;
+-            return pillarInfo.getLatitude(id);
+-        } else
+-            // e.g. if id is not handled from preparse (e.g. was ignored via isInBounds)
+-            return Double.NaN;
++	if (id == EMPTY)
++	    return Double.NaN;
++	if (id < TOWER_NODE)
++	{
++	    // tower node
++	    id = -id - 3;
++	    return nodeAccess.getLatitude(id);
++	} else if (id > -TOWER_NODE)
++	{
++	    // pillar node
++	    id = id - 3;
++	    return pillarInfo.getLatitude(id);
++	} else
++	    // e.g. if id is not handled from preparse (e.g. was ignored via
++	    // isInBounds)
++	    return Double.NaN;
+     }
+ 
+-    double getTmpLongitude( int id )
++    double getTmpLongitude(int id)
+     {
+-        if (id == EMPTY)
+-            return Double.NaN;
+-        if (id < TOWER_NODE)
+-        {
+-            // tower node
+-            id = -id - 3;
+-            return nodeAccess.getLongitude(id);
+-        } else if (id > -TOWER_NODE)
+-        {
+-            // pillar node
+-            id = id - 3;
+-            return pillarInfo.getLon(id);
+-        } else
+-            // e.g. if id is not handled from preparse (e.g. was ignored via isInBounds)
+-            return Double.NaN;
++	if (id == EMPTY)
++	    return Double.NaN;
++	if (id < TOWER_NODE)
++	{
++	    // tower node
++	    id = -id - 3;
++	    return nodeAccess.getLongitude(id);
++	} else if (id > -TOWER_NODE)
++	{
++	    // pillar node
++	    id = id - 3;
++	    return pillarInfo.getLon(id);
++	} else
++	    // e.g. if id is not handled from preparse (e.g. was ignored via
++	    // isInBounds)
++	    return Double.NaN;
+     }
+ 
+-    private void processNode( OSMNode node )
++    private void processNode(OSMNode node)
+     {
+-        if (isInBounds(node))
+-        {
+-            addNode(node);
++	if (isInBounds(node))
++	{
++	    addNode(node);
+ 
+-            // analyze node tags for barriers
+-            if (node.hasTags())
+-            {
+-                long nodeFlags = encodingManager.handleNodeTags(node);
+-                if (nodeFlags != 0)
+-                    getNodeFlagsMap().put(node.getId(), nodeFlags);
+-            }
++	    // analyze node tags for barriers
++	    if (node.hasTags())
++	    {
++		long nodeFlags = encodingManager.handleNodeTags(node);
++		if (nodeFlags != 0)
++		    getNodeFlagsMap().put(node.getId(), nodeFlags);
++	    }
+ 
+-            locations++;
+-        } else
+-        {
+-            skippedLocations++;
+-        }
++	    locations++;
++	} else
++	    skippedLocations++;
+     }
+ 
+-    boolean addNode( OSMNode node )
++    boolean addNode(OSMNode node)
+     {
+-        int nodeType = getNodeMap().get(node.getId());
+-        if (nodeType == EMPTY)
+-            return false;
++	int nodeType = getNodeMap().get(node.getId());
++	if (nodeType == EMPTY)
++	    return false;
+ 
+-        double lat = node.getLat();
+-        double lon = node.getLon();
+-        double ele = getElevation(node);
+-        if (nodeType == TOWER_NODE)
+-        {
+-            addTowerNode(node.getId(), lat, lon, ele);
+-        } else if (nodeType == PILLAR_NODE)
+-        {
+-            pillarInfo.setNode(nextPillarId, lat, lon, ele);
+-            getNodeMap().put(node.getId(), nextPillarId + 3);
+-            nextPillarId++;
+-        }
+-        return true;
++	double lat = node.getLat();
++	double lon = node.getLon();
++	double ele = getElevation(node);
++	if (nodeType == TOWER_NODE)
++	    addTowerNode(node.getId(), lat, lon, ele);
++	else if (nodeType == PILLAR_NODE)
++	{
++	    pillarInfo.setNode(nextPillarId, lat, lon, ele);
++	    getNodeMap().put(node.getId(), nextPillarId + 3);
++	    nextPillarId++;
++	}
++	return true;
+     }
+ 
+-    protected double getElevation( OSMNode node )
++    protected double getElevation(OSMNode node)
+     {
+-        return eleProvider.getEle(node.getLat(), node.getLon());
++	return eleProvider.getEle(node.getLat(), node.getLon());
+     }
+ 
+-    void prepareWaysWithRelationInfo( OSMRelation osmRelation )
++    void prepareWaysWithRelationInfo(OSMRelation osmRelation)
+     {
+-        // is there at least one tag interesting for the registed encoders?
+-        if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
+-            return;
++	// is there at least one tag interesting for the registed encoders?
++	if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
++	    return;
+ 
+-        int size = osmRelation.getMembers().size();
+-        for (int index = 0; index < size; index++)
+-        {
+-            OSMRelation.Member member = osmRelation.getMembers().get(index);
+-            if (member.type() != OSMRelation.Member.WAY)
+-                continue;
++	int size = osmRelation.getMembers().size();
++	for (int index = 0; index < size; index++)
++	{
++	    OSMRelation.Member member = osmRelation.getMembers().get(index);
++	    if (member.type() != OSMRelation.Member.WAY)
++		continue;
+ 
+-            long osmId = member.ref();
+-            long oldRelationFlags = getRelFlagsMap().get(osmId);
++	    long osmId = member.ref();
++	    long oldRelationFlags = getRelFlagsMap().get(osmId);
+ 
+-            // Check if our new relation data is better comparated to the the last one
+-            long newRelationFlags = encodingManager.handleRelationTags(osmRelation, oldRelationFlags);
+-            if (oldRelationFlags != newRelationFlags)
+-                getRelFlagsMap().put(osmId, newRelationFlags);
+-        }
++	    // Check if our new relation data is better comparated to the the
++	    // last one
++	    long newRelationFlags = encodingManager.handleRelationTags(osmRelation,
++			    oldRelationFlags);
++	    if (oldRelationFlags != newRelationFlags)
++		getRelFlagsMap().put(osmId, newRelationFlags);
++	}
+     }
+ 
+-    void prepareHighwayNode( long osmId )
++    void prepareHighwayNode(long osmId)
+     {
+-        int tmpIndex = getNodeMap().get(osmId);
+-        if (tmpIndex == EMPTY)
+-        {
+-            // osmId is used exactly once
+-            getNodeMap().put(osmId, PILLAR_NODE);
+-        } else if (tmpIndex > EMPTY)
+-        {
+-            // mark node as tower node as it occured at least twice times
+-            getNodeMap().put(osmId, TOWER_NODE);
+-        } else
+-        {
+-            // tmpIndex is already negative (already tower node)
+-        }
++	int tmpIndex = getNodeMap().get(osmId);
++	if (tmpIndex == EMPTY)
++	{
++	    // osmId is used exactly once
++	    getNodeMap().put(osmId, PILLAR_NODE);
++	} else if (tmpIndex > EMPTY)
++	{
++	    // mark node as tower node as it occured at least twice times
++	    getNodeMap().put(osmId, TOWER_NODE);
++	} else
++	{
++	    // tmpIndex is already negative (already tower node)
++	}
+     }
+ 
+-    int addTowerNode( long osmId, double lat, double lon, double ele )
++    int addTowerNode(long osmId, double lat, double lon, double ele)
+     {
+-        if (nodeAccess.is3D())
+-            nodeAccess.setNode(nextTowerId, lat, lon, ele);
+-        else
+-            nodeAccess.setNode(nextTowerId, lat, lon);
++	if (nodeAccess.is3D())
++	    nodeAccess.setNode(nextTowerId, lat, lon, ele);
++	else
++	    nodeAccess.setNode(nextTowerId, lat, lon);
+ 
+-        int id = -(nextTowerId + 3);
+-        getNodeMap().put(osmId, id);
+-        nextTowerId++;
+-        return id;
++	int id = -(nextTowerId + 3);
++	getNodeMap().put(osmId, id);
++	nextTowerId++;
++	return id;
+     }
+ 
+     /**
+      * This method creates from an OSM way (via the osm ids) one or more edges in the graph.
+      */
+-    Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long flags, long wayOsmId )
++    Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags, long wayOsmId)
+     {
+-        PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
+-        List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
+-        int firstNode = -1;
+-        int lastIndex = osmNodeIds.size() - 1;
+-        int lastInBoundsPillarNode = -1;
+-        try
+-        {
+-            for (int i = 0; i < osmNodeIds.size(); i++)
+-            {
+-                long osmId = osmNodeIds.get(i);
+-                int tmpNode = getNodeMap().get(osmId);
+-                if (tmpNode == EMPTY)
+-                    continue;
+-
+-                // skip osmIds with no associated pillar or tower id (e.g. !OSMReader.isBounds)
+-                if (tmpNode == TOWER_NODE)
+-                    continue;
++	PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
++	List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
++	int firstNode = -1;
++	int lastIndex = osmNodeIds.size() - 1;
++	int lastInBoundsPillarNode = -1;
++	try
++	{
++	    for (int i = 0; i < osmNodeIds.size(); i++)
++	    {
++		long osmId = osmNodeIds.get(i);
++		int tmpNode = getNodeMap().get(osmId);
++		if (tmpNode == EMPTY)
++		    continue;
+ 
+-                if (tmpNode == PILLAR_NODE)
+-                {
+-                    // In some cases no node information is saved for the specified osmId.
+-                    // ie. a way references a <node> which does not exist in the current file.
+-                    // => if the node before was a pillar node then convert into to tower node (as it is also end-standing).
+-                    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE)
+-                    {
+-                        // transform the pillar node to a tower node
+-                        tmpNode = lastInBoundsPillarNode;
+-                        tmpNode = handlePillarNode(tmpNode, osmId, null, true);
+-                        tmpNode = -tmpNode - 3;
+-                        if (pointList.getSize() > 1 && firstNode >= 0)
+-                        {
+-                            // TOWER node
+-                            newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+-                            pointList.clear();
+-                            pointList.add(nodeAccess, tmpNode);
+-                        }
+-                        firstNode = tmpNode;
+-                        lastInBoundsPillarNode = -1;
+-                    }
+-                    continue;
+-                }
++		// skip osmIds with no associated pillar or tower id (e.g.
++		// !OSMReader.isBounds)
++		if (tmpNode == TOWER_NODE)
++		    continue;
+ 
+-                if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
+-                    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", " + osmId);
++		if (tmpNode == PILLAR_NODE)
++		{
++		    // In some cases no node information is saved for the
++		    // specified osmId.
++		    // ie. a way references a <node> which does not exist in the
++		    // current file.
++		    // => if the node before was a pillar node then convert into
++		    // to tower node (as it is also end-standing).
++		    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE)
++		    {
++			// transform the pillar node to a tower node
++			tmpNode = lastInBoundsPillarNode;
++			tmpNode = handlePillarNode(tmpNode, osmId, null, true);
++			tmpNode = -tmpNode - 3;
++			if (pointList.getSize() > 1 && firstNode >= 0)
++			{
++			    // TOWER node
++			    newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
++			    pointList.clear();
++			    pointList.add(nodeAccess, tmpNode);
++			}
++			firstNode = tmpNode;
++			lastInBoundsPillarNode = -1;
++		    }
++		    continue;
++		}
+ 
+-                if (tmpNode > -TOWER_NODE)
+-                {
+-                    boolean convertToTowerNode = i == 0 || i == lastIndex;
+-                    if (!convertToTowerNode)
+-                    {
+-                        lastInBoundsPillarNode = tmpNode;
+-                    }
++		if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
++		    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", "
++				    + osmId);
+ 
+-                    // PILLAR node, but convert to towerNode if end-standing
+-                    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
+-                }
++		if (tmpNode > -TOWER_NODE)
++		{
++		    boolean convertToTowerNode = i == 0 || i == lastIndex;
++		    if (!convertToTowerNode)
++		    {
++			lastInBoundsPillarNode = tmpNode;
++		    }
++		    // PILLAR node, but convert to towerNode if end-standing
++		    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
++		}
+ 
+-                if (tmpNode < TOWER_NODE)
+-                {
+-                    // TOWER node
+-                    tmpNode = -tmpNode - 3;
+-                    pointList.add(nodeAccess, tmpNode);
+-                    if (firstNode >= 0)
+-                    {
+-                        newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+-                        pointList.clear();
+-                        pointList.add(nodeAccess, tmpNode);
+-                    }
+-                    firstNode = tmpNode;
+-                }
+-            }
+-        } catch (RuntimeException ex)
+-        {
+-            logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
+-            if (exitOnlyPillarNodeException)
+-                throw ex;
+-        }
+-        return newEdges;
++		if (tmpNode < TOWER_NODE)
++		{
++		    // TOWER node
++		    tmpNode = -tmpNode - 3;
++		    pointList.add(nodeAccess, tmpNode);
++		    if (firstNode >= 0)
++		    {
++			newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
++			pointList.clear();
++			pointList.add(nodeAccess, tmpNode);
++		    }
++		    firstNode = tmpNode;
++		}
++	    }
++	} catch (RuntimeException ex)
++	{
++	    logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
++	    if (exitOnlyPillarNodeException)
++		throw ex;
++	}
++	return newEdges;
+     }
+ 
+-    EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId )
++    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long flags,
++		    long wayOsmId)
+     {
+-        // sanity checks
+-        if (fromIndex < 0 || toIndex < 0)
+-            throw new AssertionError("to or from index is invalid for this edge " + fromIndex + "->" + toIndex + ", points:" + pointList);
+-        if (pointList.getDimension() != nodeAccess.getDimension())
+-            throw new AssertionError("Dimension does not match for pointList vs. nodeAccess " + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
++	// sanity checks
++	if (fromIndex < 0 || toIndex < 0)
++	    throw new AssertionError("to or from index is invalid for this edge " + fromIndex
++			    + "->" + toIndex + ", points:" + pointList);
++	if (pointList.getDimension() != nodeAccess.getDimension())
++	    throw new AssertionError("Dimension does not match for pointList vs. nodeAccess "
++			    + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
+ 
+-        double towerNodeDistance = 0;
+-        double prevLat = pointList.getLatitude(0);
+-        double prevLon = pointList.getLongitude(0);
+-        double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
+-        double lat, lon, ele = Double.NaN;
+-        PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
+-        int nodes = pointList.getSize();
+-        for (int i = 1; i < nodes; i++)
+-        {
+-            // we could save some lines if we would use pointList.calcDistance(distCalc);
+-            lat = pointList.getLatitude(i);
+-            lon = pointList.getLongitude(i);
+-            if (pointList.is3D())
+-            {
+-                ele = pointList.getElevation(i);
+-                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
+-                prevEle = ele;
+-            } else
+-                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
+-            prevLat = lat;
+-            prevLon = lon;
+-            if (nodes > 2 && i < nodes - 1)
+-            {
+-                if (pillarNodes.is3D())
+-                    pillarNodes.add(lat, lon, ele);
+-                else
+-                    pillarNodes.add(lat, lon);
+-            }
+-        }
+-        if (towerNodeDistance == 0)
+-        {
+-            // As investigation shows often two paths should have crossed via one identical point 
+-            // but end up in two very release points.
+-            zeroCounter++;
+-            towerNodeDistance = 0.0001;
+-        }
++	double towerNodeDistance = 0;
++	double prevLat = pointList.getLatitude(0);
++	double prevLon = pointList.getLongitude(0);
++	double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
++	double lat, lon, ele = Double.NaN;
++	PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
++	int nodes = pointList.getSize();
++	for (int i = 1; i < nodes; i++)
++	{
++	    // we could save some lines if we would use
++	    // pointList.calcDistance(distCalc);
++	    lat = pointList.getLatitude(i);
++	    lon = pointList.getLongitude(i);
++	    if (pointList.is3D())
++	    {
++		ele = pointList.getElevation(i);
++		towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
++		prevEle = ele;
++	    } else
++		towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
++	    prevLat = lat;
++	    prevLon = lon;
++	    if (nodes > 2 && i < nodes - 1)
++		if (pillarNodes.is3D())
++		    pillarNodes.add(lat, lon, ele);
++		else
++		    pillarNodes.add(lat, lon);
++	}
++	if (towerNodeDistance == 0)
++	{
++	    // As investigation shows often two paths should have crossed via
++	    // one identical point
++	    // but end up in two very release points.
++	    zeroCounter++;
++	    towerNodeDistance = 0.0001;
++	}
+ 
+-        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
+-        if (nodes > 2)
+-        {
+-            if (doSimplify)
+-                simplifyAlgo.simplify(pillarNodes);
++	EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
++			.setDistance(towerNodeDistance).setFlags(flags);
++	if (nodes > 2)
++	{
++	    if (doSimplify)
++		simplifyAlgo.simplify(pillarNodes);
+ 
+-            iter.setWayGeometry(pillarNodes);
+-        }
+-        storeOsmWayID(iter.getEdge(), wayOsmId);
+-        return iter;
++	    iter.setWayGeometry(pillarNodes);
++	}
++	storeOsmWayID(iter.getEdge(), wayOsmId);
++	return iter;
+     }
+ 
+     /**
+      * Stores only osmWayIds which are required for relations
+      */
+-    private void storeOsmWayID( int edgeId, long osmWayId )
++    private void storeOsmWayID(int edgeId, long osmWayId)
+     {
+-        if (getOsmWayIdSet().contains(osmWayId))
+-        {
+-            getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
+-        }
++	if (getOsmWayIdSet().contains(osmWayId))
++	    getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
+     }
+ 
+     /**
+      * @return converted tower node
+      */
+-    private int handlePillarNode( int tmpNode, long osmId, PointList pointList, boolean convertToTowerNode )
++    private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
++		    boolean convertToTowerNode)
+     {
+-        tmpNode = tmpNode - 3;
+-        double lat = pillarInfo.getLatitude(tmpNode);
+-        double lon = pillarInfo.getLongitude(tmpNode);
+-        double ele = pillarInfo.getElevation(tmpNode);
+-        if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
+-            throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
+-                    + "osmId:" + osmId + " pillarIndex:" + tmpNode);
++	tmpNode = tmpNode - 3;
++	double lat = pillarInfo.getLatitude(tmpNode);
++	double lon = pillarInfo.getLongitude(tmpNode);
++	double ele = pillarInfo.getElevation(tmpNode);
++	if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
++	    throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
++			    + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+ 
+-        if (convertToTowerNode)
+-        {
+-            // convert pillarNode type to towerNode, make pillar values invalid
+-            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
+-            tmpNode = addTowerNode(osmId, lat, lon, ele);
+-        } else
+-        {
+-            if (pointList.is3D())
+-                pointList.add(lat, lon, ele);
+-            else
+-                pointList.add(lat, lon);
+-        }
++	if (convertToTowerNode)
++	{
++	    // convert pillarNode type to towerNode, make pillar values invalid
++	    pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
++	    tmpNode = addTowerNode(osmId, lat, lon, ele);
++	} else if (pointList.is3D())
++	    pointList.add(lat, lon, ele);
++	else
++	    pointList.add(lat, lon);
+ 
+-        return (int) tmpNode;
++	return tmpNode;
+     }
+ 
+     protected void finishedReading()
+     {
+-        printInfo("way");
+-        pillarInfo.clear();
+-        eleProvider.release();
+-        osmNodeIdToInternalNodeMap = null;
+-        osmNodeIdToNodeFlagsMap = null;
+-        osmWayIdToRouteWeightMap = null;
+-        osmWayIdSet = null;
+-        edgeIdToOsmWayIdMap = null;
++	printInfo("way");
++	pillarInfo.clear();
++	eleProvider.release();
++	osmNodeIdToInternalNodeMap = null;
++	osmNodeIdToNodeFlagsMap = null;
++	osmWayIdToRouteWeightMap = null;
++	osmWayIdSet = null;
++	edgeIdToOsmWayIdMap = null;
+     }
+ 
+     /**
+      * Create a copy of the barrier node
+      */
+-    long addBarrierNode( long nodeId )
++    long addBarrierNode(long nodeId)
+     {
+-        OSMNode newNode;
+-        int graphIndex = getNodeMap().get(nodeId);
+-        if (graphIndex < TOWER_NODE)
+-        {
+-            graphIndex = -graphIndex - 3;
+-            newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
+-        } else
+-        {
+-            graphIndex = graphIndex - 3;
+-            newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
+-        }
++	OSMNode newNode;
++	int graphIndex = getNodeMap().get(nodeId);
++	if (graphIndex < TOWER_NODE)
++	{
++	    graphIndex = -graphIndex - 3;
++	    newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
++	} else
++	{
++	    graphIndex = graphIndex - 3;
++	    newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
++	}
+ 
+-        final long id = newNode.getId();
+-        prepareHighwayNode(id);
+-        addNode(newNode);
+-        return id;
++	final long id = newNode.getId();
++	prepareHighwayNode(id);
++	addNode(newNode);
++	return id;
+     }
+ 
+     private long createNewNodeId()
+     {
+-        return newUniqueOsmId++;
++	return newUniqueOsmId++;
+     }
+ 
+     /**
+      * Add a zero length edge with reduced routing options to the graph.
+      */
+-    Collection<EdgeIteratorState> addBarrierEdge( long fromId, long toId, long flags, long nodeFlags, long wayOsmId )
++    Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, long flags,
++		    long nodeFlags, long wayOsmId)
+     {
+-        // clear barred directions from routing flags
+-        flags &= ~nodeFlags;
+-        // add edge
+-        barrierNodeIds.clear();
+-        barrierNodeIds.add(fromId);
+-        barrierNodeIds.add(toId);
+-        return addOSMWay(barrierNodeIds, flags, wayOsmId);
++	// clear barred directions from routing flags
++	flags &= ~nodeFlags;
++	// add edge
++	barrierNodeIds.clear();
++	barrierNodeIds.add(fromId);
++	barrierNodeIds.add(toId);
++	return addOSMWay(barrierNodeIds, flags, wayOsmId);
+     }
+ 
+     /**
+      * Creates an OSM turn relation out of an unspecified OSM relation
+      * <p>
++     * 
+      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
+      */
+-    TurnRelation createTurnRelation( OSMRelation relation )
++    TurnRelation createTurnRelation(OSMRelation relation)
+     {
+-        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation.getTag("restriction"));
+-        if (type != OSMTurnRelation.Type.UNSUPPORTED)
+-        {
+-            long fromWayID = -1;
+-            long viaNodeID = -1;
+-            long toWayID = -1;
++	OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation
++			.getTag("restriction"));
++	if (type != OSMTurnRelation.Type.UNSUPPORTED)
++	{
++	    long fromWayID = -1;
++	    long viaNodeID = -1;
++	    long toWayID = -1;
+ 
+-            for (OSMRelation.Member member : relation.getMembers())
+-            {
+-                if (OSMElement.WAY == member.type())
+-                {
+-                    if ("from".equals(member.role()))
+-                    {
+-                        fromWayID = member.ref();
+-                    } else if ("to".equals(member.role()))
+-                    {
+-                        toWayID = member.ref();
+-                    }
+-                } else if (OSMElement.NODE == member.type() && "via".equals(member.role()))
+-                {
+-                    viaNodeID = member.ref();
+-                }
+-            }
+-            if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
+-            {
+-                return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
+-            }
+-        }
+-        return null;
++	    for (OSMRelation.Member member : relation.getMembers())
++		if (OSMElement.WAY == member.type())
++		{
++		    if ("from".equals(member.role()))
++			fromWayID = member.ref();
++		    else if ("to".equals(member.role()))
++			toWayID = member.ref();
++		} else if (OSMElement.NODE == member.type() && "via".equals(member.role()))
++		    viaNodeID = member.ref();
++	    if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
++		return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
++	}
++	return null;
+     }
+ 
+     /**
+      * Filter method, override in subclass
+      */
+-    boolean isInBounds( OSMNode node )
++    boolean isInBounds(OSMNode node)
+     {
+-        return true;
++	return true;
+     }
+ 
+     /**
+@@ -903,76 +916,86 @@
+      */
+     protected LongIntMap getNodeMap()
+     {
+-        return osmNodeIdToInternalNodeMap;
++	return osmNodeIdToInternalNodeMap;
+     }
+ 
+     protected TLongLongMap getNodeFlagsMap()
+     {
+-        return osmNodeIdToNodeFlagsMap;
++	return osmNodeIdToNodeFlagsMap;
+     }
+ 
+     TLongLongHashMap getRelFlagsMap()
+     {
+-        return osmWayIdToRouteWeightMap;
++	return osmWayIdToRouteWeightMap;
+     }
+ 
+     /**
+      * Specify the type of the path calculation (car, bike, ...).
+      */
+-    public OSMReader setEncodingManager( EncodingManager em )
++    @Override
++    public OSMReader setEncodingManager(EncodingManager em)
+     {
+-        this.encodingManager = em;
+-        return this;
++	this.encodingManager = em;
++	return this;
+     }
+ 
+-    public OSMReader setWayPointMaxDistance( double maxDist )
++    @Override
++    public OSMReader setWayPointMaxDistance(double maxDist)
+     {
+-        doSimplify = maxDist > 0;
+-        simplifyAlgo.setMaxDistance(maxDist);
+-        return this;
++	doSimplify = maxDist > 0;
++	simplifyAlgo.setMaxDistance(maxDist);
++	return this;
+     }
+ 
+-    public OSMReader setWorkerThreads( int numOfWorkers )
++    @Override
++    public OSMReader setWorkerThreads(int numOfWorkers)
+     {
+-        this.workerThreads = numOfWorkers;
+-        return this;
++	this.workerThreads = numOfWorkers;
++	return this;
+     }
+ 
+-    public OSMReader setElevationProvider( ElevationProvider eleProvider )
++    @Override
++    public OSMReader setElevationProvider(ElevationProvider eleProvider)
+     {
+-        if (eleProvider == null)
+-            throw new IllegalStateException("Use the NOOP elevation provider instead of null or don't call setElevationProvider");
++	if (eleProvider == null)
++	    throw new IllegalStateException(
++			    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+ 
+-        if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
+-            throw new IllegalStateException("Make sure you graph accepts 3D data");
++	if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
++	    throw new IllegalStateException("Make sure you graph accepts 3D data");
+ 
+-        this.eleProvider = eleProvider;
+-        return this;
++	this.eleProvider = eleProvider;
++	return this;
+     }
+ 
+-    public DataReader setOSMFile( File osmFile )
++    @Override
++    public DataReader setOSMFile(File osmFile)
+     {
+-        this.osmFile = osmFile;
+-        return this;
++	this.osmFile = osmFile;
++	return this;
+     }
+ 
+-    private void printInfo( String str )
++    private void printInfo(String str)
+     {
+-        LoggerFactory.getLogger(getClass()).info(
+-                "finished " + str + " processing." + " nodes: " + graphStorage.getNodes() + ", osmIdMap.size:" + getNodeMap().getSize()
+-                + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB" + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
+-                + ", relFlagsMap.size:" + getRelFlagsMap().size() + " " + Helper.getMemInfo());
++	LoggerFactory.getLogger(getClass()).info(
++			"finished " + str + " processing." + " nodes: " + graphStorage.getNodes()
++					+ ", osmIdMap.size:" + getNodeMap().getSize()
++					+ ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
++					+ ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
++					+ ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
++					+ Helper.getMemInfo());
+     }
+ 
+     @Override
+     public String toString()
+     {
+-        return getClass().getSimpleName();
++	return getClass().getSimpleName();
+     }
+ 
++    @Override
+     public GraphStorage getGraphStorage()
+     {
+-        return graphStorage;
++	return graphStorage;
+     }
+ 
+ }
+Index: core/src/main/java/com/graphhopper/reader/RoutingElement.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/RoutingElement.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/RoutingElement.java	(working copy)
+@@ -5,26 +5,24 @@
+ 
+ public interface RoutingElement {
+ 
+-	void setTag(String name, Object value);
++    void setTag(String name, Object value);
+ 
+-	String getTag(String string);
+-	
+-	<T> T getTag( String key, T defaultValue );
++    String getTag(String string);
+ 
+-	boolean hasTags();
++    <T> T getTag(String key, T defaultValue);
+ 
+-	boolean hasTag(String key, String... values);
++    boolean hasTags();
+ 
+-	boolean hasTag(String key, Object value);
++    boolean hasTag(String key, String... values);
+ 
+-	boolean hasTag(String key, Set<String> values);
++    boolean hasTag(String key, Object value);
+ 
+-	boolean hasTag(List<String> keyList, Set<String> values);
++    boolean hasTag(String key, Set<String> values);
+ 
+-	int getType();
++    boolean hasTag(List<String> keyList, Set<String> values);
+ 
+-	boolean isType(int way);
++    int getType();
+ 
+-	long getId();
++    boolean isType(int way);
+ 
+ }
+\ No newline at end of file
+Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java	(working copy)
+@@ -27,7 +27,6 @@
+ import java.lang.reflect.Constructor;
+ import java.util.concurrent.BlockingQueue;
+ import java.util.concurrent.LinkedBlockingQueue;
+-import java.util.concurrent.TimeUnit;
+ import java.util.zip.GZIPInputStream;
+ import java.util.zip.ZipInputStream;
+ 
+@@ -52,231 +51,198 @@
+  * @author Nop
+  */
+ public class OsDpnInputFile implements Sink, Closeable {
+-	private boolean eof;
+-	private InputStream bis;
+-	// for xml parsing
+-	private XMLStreamReader parser;
+-	// for pbf parsing
+-	private boolean binary = false;
+-	private final BlockingQueue<RoutingElement> itemQueue;
+-	private boolean hasIncomingData;
+-	private int workerThreads = -1;
+-	private static final Logger logger = LoggerFactory
+-			.getLogger(OsDpnInputFile.class);
+-
+-	public OsDpnInputFile(File file) throws IOException {
+-		bis = decode(file);
+-		itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
+-	}
++    private boolean eof;
++    private final InputStream bis;
++    // for xml parsing
++    private XMLStreamReader parser;
++    // for pbf parsing
++    private boolean binary = false;
++    private final BlockingQueue<RoutingElement> itemQueue;
++    private boolean hasIncomingData;
++    private int workerThreads = -1;
++    private static final Logger logger = LoggerFactory
++            .getLogger(OsDpnInputFile.class);
+ 
+-	public OsDpnInputFile open() throws XMLStreamException {
+-		if (binary) {
+-			// openPBFReader(bis);
+-		} else {
+-			openXMLStream(bis);
+-		}
+-		return this;
+-	}
++    public OsDpnInputFile(File file) throws IOException {
++        bis = decode(file);
++        itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
++    }
+ 
+-	/**
+-	 * Currently on for pbf format. Default is number of cores.
+-	 */
+-	public OsDpnInputFile setWorkerThreads(int num) {
+-		workerThreads = num;
+-		return this;
+-	}
++    public OsDpnInputFile open() throws XMLStreamException {
++        if (binary) {
++            // openPBFReader(bis);
++        } else {
++            openXMLStream(bis);
++        }
++        return this;
++    }
+ 
+-	@SuppressWarnings("unchecked")
+-	private InputStream decode(File file) throws IOException {
+-		final String name = file.getName();
++    /**
++     * Currently on for pbf format. Default is number of cores.
++     */
++    public OsDpnInputFile setWorkerThreads(int num) {
++        workerThreads = num;
++        return this;
++    }
+ 
+-		InputStream ips = null;
+-		try {
+-			ips = new BufferedInputStream(new FileInputStream(file), 50000);
+-		} catch (FileNotFoundException e) {
+-			throw new RuntimeException(e);
+-		}
+-		ips.mark(10);
++    @SuppressWarnings("unchecked")
++    private InputStream decode(File file) throws IOException {
++        final String name = file.getName();
+ 
+-		// check file header
+-		byte header[] = new byte[6];
+-		ips.read(header);
++        InputStream ips = null;
++        try {
++            ips = new BufferedInputStream(new FileInputStream(file), 50000);
++        } catch (FileNotFoundException e) {
++            throw new RuntimeException(e);
++        }
++        ips.mark(10);
+ 
+-		/*
+-		 * can parse bz2 directly with additional lib if (header[0] == 'B' &&
+-		 * header[1] == 'Z') { return new CBZip2InputStream(ips); }
+-		 */
+-		if (header[0] == 31 && header[1] == -117) {
+-			ips.reset();
+-			return new GZIPInputStream(ips, 50000);
+-		} else if (header[0] == 0 && header[1] == 0 && header[2] == 0
+-				&& header[4] == 10 && header[5] == 9
+-				&& (header[3] == 13 || header[3] == 14)) {
+-			ips.reset();
+-			binary = true;
+-			return ips;
+-		} else if (header[0] == 'P' && header[1] == 'K') {
+-			ips.reset();
+-			ZipInputStream zip = new ZipInputStream(ips);
+-			zip.getNextEntry();
++        // check file header
++        byte header[] = new byte[6];
++        ips.read(header);
+ 
+-			return zip;
+-		} else if (name.endsWith(".osm") || name.endsWith(".xml")) {
+-			ips.reset();
+-			return ips;
+-		} else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
+-			String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
+-			try {
+-				Class clazz = Class.forName(clName);
+-				ips.reset();
+-				Constructor<InputStream> ctor = clazz.getConstructor(
+-						InputStream.class, boolean.class);
+-				return ctor.newInstance(ips, true);
+-			} catch (Exception e) {
+-				throw new IllegalArgumentException("Cannot instantiate "
+-						+ clName, e);
+-			}
+-		} else {
+-			throw new IllegalArgumentException(
+-					"Input file is not of valid type " + file.getPath());
+-		}
+-	}
++        /*
++         * can parse bz2 directly with additional lib if (header[0] == 'B' &&
++         * header[1] == 'Z') { return new CBZip2InputStream(ips); }
++         */
++        if (header[0] == 31 && header[1] == -117) {
++            ips.reset();
++            return new GZIPInputStream(ips, 50000);
++        } else if (header[0] == 0 && header[1] == 0 && header[2] == 0
++                && header[4] == 10 && header[5] == 9
++                && (header[3] == 13 || header[3] == 14)) {
++            ips.reset();
++            binary = true;
++            return ips;
++        } else if (header[0] == 'P' && header[1] == 'K') {
++            ips.reset();
++            ZipInputStream zip = new ZipInputStream(ips);
++            zip.getNextEntry();
+ 
+-	private void openXMLStream(InputStream in) throws XMLStreamException {
+-		XMLInputFactory factory = XMLInputFactory.newInstance();
+-		parser = factory.createXMLStreamReader(bis, "UTF-8");
++            return zip;
++        } else if (name.endsWith(".gml") || name.endsWith(".xml")) {
++            ips.reset();
++            return ips;
++        } else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
++            String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
++            try {
++                Class clazz = Class.forName(clName);
++                ips.reset();
++                Constructor<InputStream> ctor = clazz.getConstructor(
++                        InputStream.class, boolean.class);
++                return ctor.newInstance(ips, true);
++            } catch (Exception e) {
++                throw new IllegalArgumentException("Cannot instantiate "
++                        + clName, e);
++            }
++        } else {
++            throw new IllegalArgumentException(
++                    "Input file is not of valid type " + file.getPath());
++        }
++    }
+ 
+-		int event = parser.next();
+-		if (event != XMLStreamConstants.START_ELEMENT
+-				|| !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
+-			throw new IllegalArgumentException(
+-					"File is not a valid OS ITN stream");
+-		}
++    private void openXMLStream(InputStream in) throws XMLStreamException {
++        XMLInputFactory factory = XMLInputFactory.newInstance();
++        parser = factory.createXMLStreamReader(bis, "UTF-8");
+ 
+-		eof = false;
+-	}
++        int event = parser.next();
++        if (event != XMLStreamConstants.START_ELEMENT
++                || !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
++            throw new IllegalArgumentException(
++                    "File is not a valid OS ITN stream");
++        }
+ 
+-	public RoutingElement getNext() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+-		if (eof)
+-			throw new IllegalStateException("EOF reached");
++        eof = false;
++    }
+ 
+-		RoutingElement item;
+-		if (binary)
+-			item = getNextPBF();
+-		else
+-			item = getNextXML();
++    public RoutingElement getNext() throws XMLStreamException,
++            MismatchedDimensionException, FactoryException, TransformException {
++        if (eof)
++            throw new IllegalStateException("EOF reached");
+ 
+-		if (item != null)
+-			return item;
++        RoutingElement item;
++        item = getNextXML();
+ 
+-		eof = true;
+-		return null;
+-	}
++        if (item != null)
++            return item;
+ 
+-	private RoutingElement getNextXML() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++        eof = true;
++        return null;
++    }
+ 
+-		int event = parser.next();
+-		while (event != XMLStreamConstants.END_DOCUMENT) {
+-			if (event == XMLStreamConstants.START_ELEMENT) {
+-				String idStr = parser.getAttributeValue("gml", "id");
+-				if (idStr != null) {
+-					String name = parser.getLocalName();
+-					idStr = idStr.substring(4);
+-					long id = Long.parseLong(idStr);
++    private RoutingElement getNextXML() throws XMLStreamException,
++            MismatchedDimensionException, FactoryException, TransformException {
+ 
+-					logger.info(":" + name + ":");
+-					switch (name) {
+-					case "RouteNode": {
+-						return OsDpnNode.create(id, parser);
+-					}
+-					case "RouteLink": {
+-						return OsDpnWay.create(id, parser);
+-					}
+-					case "Route": {
+-						//TODO grouped features
+-					}
+-					default: {
+-						
+-					}
++        int event = parser.next();
++        while (event != XMLStreamConstants.END_DOCUMENT) {
++            if (event == XMLStreamConstants.START_ELEMENT) {
++                String idStr = parser.getAttributeValue(null, "id");
++                if (idStr != null) {
++                    String name = parser.getLocalName();
++                    idStr = idStr.substring(4);
+ 
+-					}
+-				}
+-			}
+-			event = parser.next();
+-		}
+-		parser.close();
+-		return null;
+-	}
++                    logger.info(":" + name + ":");
++                    switch (name) {
++                        case "RouteNode": {
++                            return OsDpnNode.create(idStr, parser);
++                        }
++                        case "RouteLink": {
++                            return OsDpnWay.create(idStr, parser);
++                        }
++                        case "Route": {
++                            // TODO grouped features
++                        }
++                        default: {
+ 
+-	public boolean isEOF() {
+-		return eof;
+-	}
++                        }
+ 
+-	@Override
+-	public void close() throws IOException {
+-		try {
+-			if (!binary)
+-				parser.close();
+-		} catch (XMLStreamException ex) {
+-			throw new IOException(ex);
+-		} finally {
+-			eof = true;
+-			bis.close();
+-			// if exception happend on OSMInputFile-thread we need to shutdown
+-			// the pbf handling
+-			if (pbfReaderThread != null && pbfReaderThread.isAlive())
+-				pbfReaderThread.interrupt();
+-		}
+-	}
++                    }
++                }
++            }
++            event = parser.next();
++        }
++        parser.close();
++        return null;
++    }
+ 
+-	Thread pbfReaderThread;
++    public boolean isEOF() {
++        return eof;
++    }
+ 
+-	// private void openPBFReader(InputStream stream) {
+-	// hasIncomingData = true;
+-	// if (workerThreads <= 0)
+-	// workerThreads = 2;
+-	//
+-	// PbfReader reader = new PbfReader(stream, this, workerThreads);
+-	// pbfReaderThread = new Thread(reader, "PBF Reader");
+-	// pbfReaderThread.start();
+-	// }
++    @Override
++    public void close() throws IOException {
++        try {
++            if (!binary)
++                parser.close();
++        } catch (XMLStreamException ex) {
++            throw new IOException(ex);
++        } finally {
++            eof = true;
++            bis.close();
++            // if exception happend on OSMInputFile-thread we need to shutdown
++            // the pbf handling
++            if (pbfReaderThread != null && pbfReaderThread.isAlive())
++                pbfReaderThread.interrupt();
++        }
++    }
+ 
+-	@Override
+-	public void process(RoutingElement item) {
+-		try {
+-			// blocks if full
+-			itemQueue.put(item);
+-		} catch (InterruptedException ex) {
+-			throw new RuntimeException(ex);
+-		}
++    Thread pbfReaderThread;
+ 
+-		// throw exception if full
+-		// itemQueue.add(item);
+-	}
++    @Override
++    public void process(RoutingElement item) {
++        try {
++            // blocks if full
++            itemQueue.put(item);
++        } catch (InterruptedException ex) {
++            throw new RuntimeException(ex);
++        }
+ 
+-	@Override
+-	public void complete() {
+-		hasIncomingData = false;
+-	}
++        // throw exception if full
++        // itemQueue.add(item);
++    }
+ 
+-	private RoutingElement getNextPBF() {
+-		RoutingElement next = null;
+-		while (next == null) {
+-			if (!hasIncomingData && itemQueue.isEmpty()) {
+-				// we are done, stop polling
+-				eof = true;
+-				break;
+-			}
+-
+-			try {
+-				// we cannot use "itemQueue.take()" as it blocks and
+-				// hasIncomingData can change
+-				next = itemQueue.poll(10, TimeUnit.MILLISECONDS);
+-			} catch (InterruptedException ex) {
+-				eof = true;
+-				break;
+-			}
+-		}
+-		return next;
+-	}
++    @Override
++    public void complete() {
++        hasIncomingData = false;
++    }
+ }
+Index: core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java	(working copy)
+@@ -37,17 +37,15 @@
+ import com.graphhopper.reader.ITurnCostTableEntry;
+ import com.graphhopper.reader.Node;
+ import com.graphhopper.reader.OSMElement;
+-import com.graphhopper.reader.OSMNode;
+ import com.graphhopper.reader.OSMRelation;
+ import com.graphhopper.reader.OSMTurnRelation;
++import com.graphhopper.reader.OSMTurnRelation.Type;
+ import com.graphhopper.reader.PillarInfo;
+ import com.graphhopper.reader.Relation;
+ import com.graphhopper.reader.RelationMember;
+ import com.graphhopper.reader.RoutingElement;
+ import com.graphhopper.reader.Way;
+-import com.graphhopper.reader.OSMTurnRelation.Type;
+ import com.graphhopper.reader.dem.ElevationProvider;
+-import com.graphhopper.routing.util.AbstractFlagEncoder;
+ import com.graphhopper.routing.util.EncodingManager;
+ import com.graphhopper.storage.ExtendedStorage;
+ import com.graphhopper.storage.GraphHopperStorage;
+@@ -108,7 +106,7 @@
+  * @author Peter Karich
+  */
+ 
+-public class OsItnReader implements DataReader {
++public class OsItnReader implements DataReader<Long> {
+ 
+     private static final String TURN_FROM_TO_VIA_FORMAT = "Turn from:{} to:{} via:{}";
+     private static final String PRINT_INFO_FORMAT = "finished {}  processing. nodes:{}, osmIdMap.size:{}, osmIdMap:{}MB, nodeFlagsMap.size:{}, relFlagsMap.size:{} {}";
+@@ -145,7 +143,9 @@
+     private static final String EDGE_ID_TO_OSMIDMAP_FORMAT = "edgeIdTOOsmidmap: {}";
+ 
+     public class ProcessVisitor {
+-        public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++        public void process(ProcessData processData, OsItnInputFile in)
++                throws XMLStreamException, MismatchedDimensionException,
++                FactoryException, TransformException {
+         }
+     }
+ 
+@@ -161,8 +161,10 @@
+     protected static final int PILLAR_NODE = 1;
+     // tower node is <= -3
+     protected static final int TOWER_NODE = -2;
+-    private static final Logger logger = LoggerFactory.getLogger(OsItnReader.class);
+-    private static final Logger errors_logger = LoggerFactory.getLogger("ingestionerrors");
++    private static final Logger logger = LoggerFactory
++            .getLogger(OsItnReader.class);
++    private static final Logger errors_logger = LoggerFactory
++            .getLogger("ingestionerrors");
+ 
+     private static final int MAX_GRADE_SEPARATION = 4;
+     private long locations;
+@@ -191,7 +193,7 @@
+     // smaller memory overhead for bigger data sets because of avoiding a
+     // "rehash"
+     // remember how many times a node was used to identify tower nodes
+-    private LongIntMap osmNodeIdToInternalNodeMap;
++    private final LongIntMap osmNodeIdToInternalNodeMap;
+     private TLongLongHashMap osmNodeIdToNodeFlagsMap;
+     private TLongLongHashMap osmWayIdToRouteWeightMap;
+     // stores osm way ids used by relations to identify which edge ids needs to
+@@ -209,7 +211,7 @@
+     // negative but increasing to avoid clash with custom created OSM files
+     private long newUniqueOsmId = -Long.MAX_VALUE;
+     private ElevationProvider eleProvider = ElevationProvider.NOOP;
+-    private boolean exitOnlyPillarNodeException = true;
++    private final boolean exitOnlyPillarNodeException = true;
+     private File routingFile;
+ 
+     private TLongObjectMap<ItnNodePair> edgeIdToNodeMap;
+@@ -228,7 +230,8 @@
+         osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
+         osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
+         osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
+-        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
++        pillarInfo = new PillarInfo(nodeAccess.is3D(),
++                graphStorage.getDirectory());
+     }
+ 
+     @Override
+@@ -240,7 +243,9 @@
+             throw new IllegalStateException("No OS ITN file specified");
+ 
+         if (!routingFile.exists())
+-            throw new IllegalStateException("Your specified OS ITN file does not exist:" + routingFile.getAbsolutePath());
++            throw new IllegalStateException(
++                    "Your specified OS ITN file does not exist:"
++                            + routingFile.getAbsolutePath());
+ 
+         StopWatch sw1 = new StopWatch().start();
+         preProcess(routingFile);
+@@ -250,7 +255,9 @@
+         writeOsm2Graph(routingFile);
+         sw2.stop();
+ 
+-        logger.info(TIME_PASS1_PASS2_TOTAL_FORMAT, (int) sw1.getSeconds(), (int) sw2.getSeconds(), ((int) (sw1.getSeconds() + sw2.getSeconds())));
++        logger.info(TIME_PASS1_PASS2_TOTAL_FORMAT, (int) sw1.getSeconds(),
++                (int) sw2.getSeconds(),
++                ((int) (sw1.getSeconds() + sw2.getSeconds())));
+     }
+ 
+     /**
+@@ -265,7 +272,9 @@
+         }
+     }
+ 
+-    private void preProcessDirOrFile(File osmFile) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
++    private void preProcessDirOrFile(File osmFile) throws XMLStreamException,
++            IOException, MismatchedDimensionException, FactoryException,
++            TransformException {
+         if (osmFile.isDirectory()) {
+             String absolutePath = osmFile.getAbsolutePath();
+             String[] list = osmFile.list();
+@@ -278,18 +287,23 @@
+         }
+     }
+ 
+-    private void preProcessSingleFile(File osmFile) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
++    private void preProcessSingleFile(File osmFile) throws XMLStreamException,
++            IOException, MismatchedDimensionException, FactoryException,
++            TransformException {
+         OsItnInputFile in = null;
+         try {
+             logger.error(PREPROCESS_FORMAT, osmFile.getName());
+-            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads).open();
++            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
++                    .open();
+             preProcessSingleFile(in);
+         } finally {
+             Helper.close(in);
+         }
+     }
+ 
+-    private void preProcessSingleFile(OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++    private void preProcessSingleFile(OsItnInputFile in)
++            throws XMLStreamException, MismatchedDimensionException,
++            FactoryException, TransformException {
+         System.out.println("==== preProcessSingleFile");
+         long tmpWayCounter = 1;
+         long tmpRelationCounter = 1;
+@@ -297,7 +311,7 @@
+         while ((item = in.getNext()) != null) {
+             logger.info(OS_ITN_READER_PRE_PROCESS_FORMAT, item.getType());
+             if (item.isType(OSMElement.WAY)) {
+-                final Way way = (Way) item;
++                final OSITNWay way = (OSITNWay) item;
+                 boolean valid = filterWay(way);
+                 if (valid) {
+                     TLongList wayNodes = way.getNodes();
+@@ -307,7 +321,10 @@
+                     }
+ 
+                     if (++tmpWayCounter % 500000 == 0) {
+-                        logger.info(PREPROCESS_OSM_ID_MAP_MB_FORMAT, nf(tmpWayCounter), nf(getNodeMap().getSize()), getNodeMap().getMemoryUsage(), Helper.getMemInfo());
++                        logger.info(PREPROCESS_OSM_ID_MAP_MB_FORMAT,
++                                nf(tmpWayCounter), nf(getNodeMap().getSize()),
++                                getNodeMap().getMemoryUsage(),
++                                Helper.getMemInfo());
+                     }
+                 }
+             }
+@@ -316,19 +333,25 @@
+                 // logger.warn("RELATION :" + item.getClass() + " TYPE:" +
+                 // item.getTag(OSITNElement.TAG_KEY_TYPE) + " meta?" +
+                 // relation.isMetaRelation());
+-                if (!relation.isMetaRelation() && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
++                if (!relation.isMetaRelation()
++                        && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
+                     prepareWaysWithRelationInfo(relation);
+ 
+-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
++                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
++                        OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
+                     prepareRestrictionRelation(relation);
+ 
+-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_NOENTRY)) {
++                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
++                        OSITNElement.TAG_VALUE_TYPE_NOENTRY)) {
+                     prepareNoEntryRelation(relation);
+                 }
+ 
+                 // If this way is prohibited then we want to make a note of it
+                 // so we don't include it in later route generation
+-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED) || relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED)) {
++                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
++                        OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED)
++                        || relation.hasTag(OSITNElement.TAG_KEY_TYPE,
++                                OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED)) {
+                     prepareAccessProhibitedRelation(relation);
+                 }
+ 
+@@ -343,7 +366,10 @@
+                 }
+ 
+                 if (++tmpRelationCounter % 50000 == 0) {
+-                    logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size()) + " " + Helper.getMemInfo());
++                    logger.info(nf(tmpRelationCounter)
++                            + " (preprocess), osmWayMap:"
++                            + nf(getRelFlagsMap().size()) + " "
++                            + Helper.getMemInfo());
+                 }
+ 
+             }
+@@ -353,13 +379,14 @@
+     private void prepareRestrictionRelation(Relation relation) {
+         OSITNTurnRelation turnRelation = createTurnRelation(relation);
+         if (turnRelation != null) {
+-            getOsmIdStoreRequiredSet().add(((OSITNTurnRelation) turnRelation).getOsmIdFrom());
+-            getOsmIdStoreRequiredSet().add(((OSITNTurnRelation) turnRelation).getOsmIdTo());
++            getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdFrom());
++            getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdTo());
+         }
+     }
+ 
+     private void prepareAccessProhibitedRelation(Relation relation) {
+-        if (!encodingManager.isVehicleQualifierTypeExcluded(relation) && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
++        if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
++                && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+             ArrayList<? extends RelationMember> members = relation.getMembers();
+             // There will be only one
+             for (RelationMember relationMember : members) {
+@@ -398,9 +425,11 @@
+     private void prepareRoadDirectionRelation(Relation relation) {
+         // Check if this vehicle has an exception meaning we shouldn't handle
+         // one way
+-        if (!encodingManager.isVehicleQualifierTypeExcluded(relation) && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
++        if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
++                && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+             // This will be "-1" the first time this is called
+-            String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION);
++            String orientationIndicator = relation
++                    .getTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION);
+             TLongObjectMap<String> edgeIdToRoadDirectionMap = getEdgeRoadDirectionMap();
+             ArrayList<? extends RelationMember> members = relation.getMembers();
+             for (RelationMember relationMember : members) {
+@@ -418,9 +447,11 @@
+     private void prepareNoEntryRelation(Relation relation) {
+         // Check if this vehicle has an exception meaning we shouldn't handle no
+         // entry
+-        if (!encodingManager.isVehicleQualifierTypeExcluded(relation) && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
++        if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
++                && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+             long flags = 1l; // (+) orientation
+-            String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_NOENTRY_ORIENTATION);
++            String orientationIndicator = relation
++                    .getTag(OSITNElement.TAG_KEY_NOENTRY_ORIENTATION);
+             if ("-1".equals(orientationIndicator)) {
+                 flags = 0l; // (-) orientation
+             }
+@@ -435,7 +466,8 @@
+                 String[] coordParts = coords.split(",");
+                 double xCoord = Double.parseDouble(coordParts[0]);
+                 double yCoord = Double.parseDouble(coordParts[1]);
+-                TDoubleObjectMap<TDoubleLongMap> xCoordMap = edgeIdToXToYToNodeFlagsMap.get(wayId);
++                TDoubleObjectMap<TDoubleLongMap> xCoordMap = edgeIdToXToYToNodeFlagsMap
++                        .get(wayId);
+                 if (xCoordMap == null) {
+                     xCoordMap = new TDoubleObjectHashMap<TDoubleLongMap>();
+                     edgeIdToXToYToNodeFlagsMap.put(wayId, xCoordMap);
+@@ -446,7 +478,8 @@
+                     xCoordMap.put(xCoord, yCoordMap);
+                 }
+                 // now put the flag in there
+-                logger.info(EDGE_ID_COORDS_TO_NODE_FLAGS_MAP_PUT_FORMAT, wayId, xCoord, yCoord, flags);
++                logger.info(EDGE_ID_COORDS_TO_NODE_FLAGS_MAP_PUT_FORMAT, wayId,
++                        xCoord, yCoord, flags);
+ 
+                 yCoordMap.put(yCoord, flags);
+             }
+@@ -460,14 +493,16 @@
+     private TIntLongMap getEdgeIdToOsmidMap() {
+         logger.info(EDGE_ID_TO_OSMIDMAP_FORMAT, edgeIdToOsmIdMap);
+         if (edgeIdToOsmIdMap == null)
+-            edgeIdToOsmIdMap = new TIntLongHashMap(getOsmIdStoreRequiredSet().size());
++            edgeIdToOsmIdMap = new TIntLongHashMap(getOsmIdStoreRequiredSet()
++                    .size());
+ 
+         return edgeIdToOsmIdMap;
+     }
+ 
+     private TLongObjectMap<ItnNodePair> getNodeEdgeMap() {
+         if (edgeIdToNodeMap == null)
+-            edgeIdToNodeMap = new TLongObjectHashMap<ItnNodePair>(getOsmIdStoreRequiredSet().size());
++            edgeIdToNodeMap = new TLongObjectHashMap<ItnNodePair>(
++                    getOsmIdStoreRequiredSet().size());
+ 
+         return edgeIdToNodeMap;
+     }
+@@ -481,21 +516,24 @@
+ 
+     private TLongObjectMap<String> getEdgeNameMap() {
+         if (edgeNameMap == null)
+-            edgeNameMap = new TLongObjectHashMap<String>(getOsmIdStoreRequiredSet().size());
++            edgeNameMap = new TLongObjectHashMap<String>(
++                    getOsmIdStoreRequiredSet().size());
+ 
+         return edgeNameMap;
+     }
+ 
+     private TLongObjectMap<String> getEdgeRoadTypeMap() {
+         if (edgeRoadTypeMap == null)
+-            edgeRoadTypeMap = new TLongObjectHashMap<String>(getOsmIdStoreRequiredSet().size());
++            edgeRoadTypeMap = new TLongObjectHashMap<String>(
++                    getOsmIdStoreRequiredSet().size());
+ 
+         return edgeRoadTypeMap;
+     }
+ 
+     private TLongObjectMap<String> getEdgeRoadDirectionMap() {
+         if (edgeRoadDirectionMap == null)
+-            edgeRoadDirectionMap = new TLongObjectHashMap<String>(getOsmIdStoreRequiredSet().size());
++            edgeRoadDirectionMap = new TLongObjectHashMap<String>(
++                    getOsmIdStoreRequiredSet().size());
+ 
+         return edgeRoadDirectionMap;
+     }
+@@ -516,7 +554,7 @@
+      * 
+      * @return true the current xml entry is a way entry and has nodes
+      */
+-    boolean filterWay(Way way) {
++    boolean filterWay(OSITNWay way) {
+         // ignore broken geometry
+         if (way.getNodes().size() < 2)
+             return false;
+@@ -533,14 +571,18 @@
+      */
+     private void writeOsm2Graph(File osmFile) {
+         int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
+-        logger.error(CREATING_GRAPH_FOUND_NODES_PILLAR_TOWER_FORMAT, nf(getNodeMap().getSize()), Helper.getMemInfo());
++        logger.error(CREATING_GRAPH_FOUND_NODES_PILLAR_TOWER_FORMAT,
++                nf(getNodeMap().getSize()), Helper.getMemInfo());
+         graphStorage.create(tmp);
+ 
+         ProcessData processData = new ProcessData();
+         try {
+             ProcessVisitor processVisitor = new ProcessVisitor() {
+                 @Override
+-                public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++                public void process(ProcessData processData, OsItnInputFile in)
++                        throws XMLStreamException,
++                        MismatchedDimensionException, FactoryException,
++                        TransformException {
+                     logger.error("PROCESS STAGE 1");
+                     processStageOne(processData, in);
+                 }
+@@ -549,7 +591,10 @@
+             writeOsm2GraphFromDirOrFile(osmFile, processData, processVisitor);
+             processVisitor = new ProcessVisitor() {
+                 @Override
+-                public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++                public void process(ProcessData processData, OsItnInputFile in)
++                        throws XMLStreamException,
++                        MismatchedDimensionException, FactoryException,
++                        TransformException {
+                     logger.error("PROCESS STAGE 2");
+                     processStageTwo(processData, in);
+                 }
+@@ -558,7 +603,10 @@
+             writeOsm2GraphFromDirOrFile(osmFile, processData, processVisitor);
+             processVisitor = new ProcessVisitor() {
+                 @Override
+-                public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++                public void process(ProcessData processData, OsItnInputFile in)
++                        throws XMLStreamException,
++                        MismatchedDimensionException, FactoryException,
++                        TransformException {
+                     logger.error("PROCESS STAGE 3");
+                     processStageThree(processData, in);
+                 }
+@@ -572,27 +620,37 @@
+ 
+         finishedReading();
+         if (graphStorage.getNodes() == 0)
+-            throw new IllegalStateException("osm must not be empty. read " + processData.counter + " lines and " + locations + " locations");
++            throw new IllegalStateException("osm must not be empty. read "
++                    + processData.counter + " lines and " + locations
++                    + " locations");
+     }
+ 
+-    private void writeOsm2GraphFromDirOrFile(File osmFile, ProcessData processData, ProcessVisitor processVisitor) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
++    private void writeOsm2GraphFromDirOrFile(File osmFile,
++            ProcessData processData, ProcessVisitor processVisitor)
++            throws XMLStreamException, IOException,
++            MismatchedDimensionException, FactoryException, TransformException {
+         if (osmFile.isDirectory()) {
+             String absolutePath = osmFile.getAbsolutePath();
+             String[] list = osmFile.list();
+             for (String file : list) {
+                 File nextFile = new File(absolutePath + File.separator + file);
+-                writeOsm2GraphFromDirOrFile(nextFile, processData, processVisitor);
++                writeOsm2GraphFromDirOrFile(nextFile, processData,
++                        processVisitor);
+             }
+         } else {
+             writeOsm2GraphFromSingleFile(osmFile, processData, processVisitor);
+         }
+     }
+ 
+-    private void writeOsm2GraphFromSingleFile(File osmFile, ProcessData processData, ProcessVisitor processVisitor) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
++    private void writeOsm2GraphFromSingleFile(File osmFile,
++            ProcessData processData, ProcessVisitor processVisitor)
++            throws XMLStreamException, IOException,
++            MismatchedDimensionException, FactoryException, TransformException {
+         OsItnInputFile in = null;
+         try {
+             logger.error(PROCESS_FORMAT, osmFile.getName());
+-            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads).open();
++            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
++                    .open();
+             processVisitor.process(processData, in);
+             logger.info(STORAGE_NODES_FORMAT, graphStorage.getNodes());
+         } finally {
+@@ -601,62 +659,74 @@
+ 
+     }
+ 
+-    private void processStageOne(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++    private void processStageOne(ProcessData processData, OsItnInputFile in)
++            throws XMLStreamException, MismatchedDimensionException,
++            FactoryException, TransformException {
+         System.out.println("==== processStageOne");
+         RoutingElement item;
+         LongIntMap nodeFilter = getNodeMap();
+         while ((item = in.getNext()) != null) {
+             switch (item.getType()) {
+-            case OSMElement.NODE:
+-                long id = item.getId();
+-                logger.info(NODEITEMID_FORMAT, id);
+-                if (nodeFilter.get(id) != -1) {
+-                    OSITNNode nodeItem = (OSITNNode) item;
+-                    processNode(nodeItem);
++                case OSMElement.NODE:
++                    OSITNNode node = (OSITNNode) item;
++                    long id = node.getId();
++                    logger.info(NODEITEMID_FORMAT, id);
++                    if (nodeFilter.get(id) != -1) {
++                        OSITNNode nodeItem = (OSITNNode) item;
++                        processNode(nodeItem);
+ 
+-                    String strId = String.valueOf(id);
+-                    addGradeNodesIfRequired(nodeItem, strId, nodeFilter);
+-                }
+-                break;
++                        String strId = String.valueOf(id);
++                        addGradeNodesIfRequired(nodeItem, strId, nodeFilter);
++                    }
++                    break;
+ 
+             }
+             if (++processData.counter % 5000000 == 0) {
+-                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations), skippedLocations, Helper.getMemInfo());
++                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
++                        nf(locations), skippedLocations, Helper.getMemInfo());
+             }
+         }
+     }
+ 
+-    private void processStageTwo(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++    private void processStageTwo(ProcessData processData, OsItnInputFile in)
++            throws XMLStreamException, MismatchedDimensionException,
++            FactoryException, TransformException {
+         System.out.println("==== processStageTwo");
+         RoutingElement item;
+         LongIntMap nodeFilter = getNodeMap();
+         while ((item = in.getNext()) != null) {
+             switch (item.getType()) {
+-            case OSMElement.WAY:
+-                OSITNWay way = (OSITNWay) item;
+-                logger.info(WAY_FORMAT, way.getId(), processData.wayStart);
+-                if (processData.wayStart < 0) {
+-                    logger.info(NOW_PARSING_WAYS_FORMAT, nf(processData.counter));
+-                    processData.wayStart = processData.counter;
+-                }
+-                if (!way.hasTag("highway")) {
+-                    way.setTag("highway", "motorway");
+-                }
+-                // wayNodes will only contain the mid nodes and not the start or
+-                // end nodes.
+-                List<OSITNNode> wayNodes = prepareWaysNodes(way, nodeFilter);
+-                processWay(way, wayNodes);
+-                way.clearStoredCoords();
+-                break;
++                case OSMElement.WAY:
++                    OSITNWay way = (OSITNWay) item;
++                    logger.info(WAY_FORMAT, way.getId(), processData.wayStart);
++                    if (processData.wayStart < 0) {
++                        logger.info(NOW_PARSING_WAYS_FORMAT,
++                                nf(processData.counter));
++                        processData.wayStart = processData.counter;
++                    }
++                    if (!way.hasTag("highway")) {
++                        way.setTag("highway", "motorway");
++                    }
++                    // wayNodes will only contain the mid nodes and not the
++                    // start or
++                    // end nodes.
++                    List<OSITNNode> wayNodes = prepareWaysNodes(way, nodeFilter);
++                    processWay(way, wayNodes);
++                    way.clearStoredCoords();
++                    break;
+             }
+             if (++processData.counter % 5000000 == 0) {
+-                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations), skippedLocations, Helper.getMemInfo());
++                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
++                        nf(locations), skippedLocations, Helper.getMemInfo());
+             }
+         }
+     }
+ 
+-    private List<OSITNNode> prepareWaysNodes(RoutingElement item, LongIntMap nodeFilter) throws MismatchedDimensionException, FactoryException, TransformException {
+-        List<OSITNNode> evaluateWayNodes = ((OSITNWay) item).evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
++    private List<OSITNNode> prepareWaysNodes(RoutingElement item,
++            LongIntMap nodeFilter) throws MismatchedDimensionException,
++            FactoryException, TransformException {
++        List<OSITNNode> evaluateWayNodes = ((OSITNWay) item)
++                .evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
+         for (OSITNNode ositnNode : evaluateWayNodes) {
+             nodeFilter.put(ositnNode.getId(), PILLAR_NODE);
+             processNode(ositnNode);
+@@ -665,33 +735,38 @@
+         return evaluateWayNodes;
+     }
+ 
+-    private void processStageThree(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++    private void processStageThree(ProcessData processData, OsItnInputFile in)
++            throws XMLStreamException, MismatchedDimensionException,
++            FactoryException, TransformException {
+         System.out.println("==== processStageThree");
+         RoutingElement item;
+         while ((item = in.getNext()) != null) {
+             switch (item.getType()) {
+-            case OSMElement.RELATION:
+-                if (processData.relationStart < 0) {
+-                    logger.info(NOW_PARSING_RELATIONS_FORMAT, nf(processData.counter));
+-                    processData.relationStart = processData.counter;
+-                }
+-                processRelation((Relation) item);
+-                break;
++                case OSMElement.RELATION:
++                    if (processData.relationStart < 0) {
++                        logger.info(NOW_PARSING_RELATIONS_FORMAT,
++                                nf(processData.counter));
++                        processData.relationStart = processData.counter;
++                    }
++                    processRelation((Relation) item);
++                    break;
+             }
+             if (++processData.counter % 5000000 == 0) {
+-                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations), skippedLocations, Helper.getMemInfo());
++                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
++                        nf(locations), skippedLocations, Helper.getMemInfo());
+             }
+         }
+     }
+ 
+-    private void addGradeNodesIfRequired(OSITNNode item, String idStr, LongIntMap nodeFilter) {
++    private void addGradeNodesIfRequired(OSITNNode item, String idStr,
++            LongIntMap nodeFilter) {
+         String curId;
+         for (int i = 1; i <= MAX_GRADE_SEPARATION; i++) {
+             curId = i + idStr;
+             long parseInt = Long.parseLong(curId);
+             if (nodeFilter.get(parseInt) != -1) {
+                 OSITNNode gradeNode = item.gradeClone(parseInt);
+-                processNode((Node) gradeNode);
++                processNode(gradeNode);
+             }
+         }
+     }
+@@ -732,7 +807,8 @@
+ 
+         String wayDirection = getWayRoadDirection(way.getId());
+         // If the way is ONEWAY then set the direction
+-        if (null != wayDirection && !way.hasTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION)) {
++        if (null != wayDirection
++                && !way.hasTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION)) {
+             way.setTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION, wayDirection);
+         }
+         // TODO move this after we have created the edge and know the
+@@ -745,78 +821,87 @@
+             long lastItnNode = osmNodeIds.get(osmNodeIds.size() - 1);
+             int last = getNodeMap().get(lastItnNode);
+ 
+-            logger.info(WAYID_FIRST_LAST_FORMAT, wayOsmId, firstItnNode, lastItnNode);
+-            getNodeEdgeMap().put(wayOsmId, new ItnNodePair(firstItnNode, lastItnNode));
++            logger.info(WAYID_FIRST_LAST_FORMAT, wayOsmId, firstItnNode,
++                    lastItnNode);
++            getNodeEdgeMap().put(wayOsmId,
++                    new ItnNodePair(firstItnNode, lastItnNode));
+             double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+             double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+-            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
+-                double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
++            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon)
++                    && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
++                double estimatedDist = distCalc.calcDist(firstLat, firstLon,
++                        lastLat, lastLon);
+                 way.setTag("estimated_distance", estimatedDist);
+-                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
++                way.setTag("estimated_center", new GHPoint(
++                        (firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
+             }
+         }
+ 
+-        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
++        long wayFlags = encodingManager.handleWayTags(way, includeWay,
++                relationFlags);
+         if (wayFlags == 0)
+             return;
+         // logger.warn(ADDING_RELATION_TO_WAYS_FORMAT, wayFlags);
+-        
+-        // Check if we need to add additional TOWER nodes at the start and end locations to deal
+-        // with a routing algorithm bug which prevents turn restrictions from working when you start or finish on the 
++
++        // Check if we need to add additional TOWER nodes at the start and end
++        // locations to deal
++        // with a routing algorithm bug which prevents turn restrictions from
++        // working when you start or finish on the
+         // final edge of a way
+         boolean shouldAddStartEndTowers = true;
+-        //if (osmNodeIds)
+-        osmNodeIds = createStartTowerNodeAndEdge(osmNodeIds, way, wayNodes, wayFlags, wayOsmId);
++        // if (osmNodeIds)
++        osmNodeIds = createStartTowerNodeAndEdge(osmNodeIds, way, wayNodes,
++                wayFlags, wayOsmId);
+         // Process No Entry and then Barriers, and finally add the remaining way
+         processNoEntry(way, wayNodes, osmNodeIds, wayFlags, wayOsmId);
+ 
+     }
+ 
+-    private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way, List<OSITNNode> wayNodes, long wayFlags, long wayOsmId) {
+-        //if (osmNodeIds.size()>2) {
++    private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
++            OSITNWay way, List<OSITNNode> wayNodes, long wayFlags, long wayOsmId) {
++        // if (osmNodeIds.size()>2) {
+         List<EdgeIteratorState> startCreatedEdges = new ArrayList<EdgeIteratorState>();
+-        
++
+         // Get the node id of the first pillar node/way node
+-        
+-        long nodeId = osmNodeIds.get(0); 
+-        
+-        
+-        // Check if we have a pillar node at the start. If so we need to convert to a tower.
++
++        long nodeId = osmNodeIds.get(0);
++
++        // Check if we have a pillar node at the start. If so we need to convert
++        // to a tower.
+         int graphIndex = getNodeMap().get(nodeId);
+         if (graphIndex < TOWER_NODE) {
+-            
+-            OSMNode newNode = addBarrierNode(nodeId);
++
++            OSITNNode newNode = addBarrierNode(nodeId);
+             long newNodeId = newNode.getId();
+             int nodeType = getNodeMap().get(newNodeId);
+-            
++
+             // add way up to barrier shadow node
+             long transfer[] = osmNodeIds.toArray(0, 2); // From 0 for length
+                                                         // 2
+             transfer[transfer.length - 1] = newNodeId;
+             TLongList partIds = new TLongArrayList(transfer);
+-            Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
++            Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
++                    wayFlags, wayOsmId);
+             // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
+             startCreatedEdges.addAll(newWays);
+-    
+-    //      if (nodeType==PILLAR_NODE) {
+-            // Set this to be a TOWER node explicitly. This has to be after the edges are created
+-    //        getNodeMap().put(newNodeId, TOWER_NODE);
+-    //    }
+-    
+-            
++
++            // if (nodeType==PILLAR_NODE) {
++            // Set this to be a TOWER node explicitly. This has to be after the
++            // edges are created
++            // getNodeMap().put(newNodeId, TOWER_NODE);
++            // }
++
+             // Set the 0th node id to be our new node id
+             osmNodeIds.set(0, newNodeId);
+-    //        osmNodeIds.insert(1, newNodeId);
+-    
+-            
++            // osmNodeIds.insert(1, newNodeId);
++
+             for (EdgeIteratorState edge : startCreatedEdges) {
+                 encodingManager.applyWayTags(way, edge);
+             }
+         }
+         return osmNodeIds;
+     }
+-    
+-    
++
+     /**
+      * This method processes the list of NodeIds and checks if any nodes have a
+      * NoEntry Tag. If it does then it adds a shadow node and an extra way as a
+@@ -834,13 +919,16 @@
+      * @param wayOsmId
+      * @return
+      */
+-    private List<EdgeIteratorState> processNoEntry(OSITNWay way, List<OSITNNode> wayNodes, TLongList osmNodeIds, long wayFlags, long wayOsmId) {
++    private List<EdgeIteratorState> processNoEntry(OSITNWay way,
++            List<OSITNNode> wayNodes, TLongList osmNodeIds, long wayFlags,
++            long wayOsmId) {
+         List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
+         int lastNoEntry = -1;
+         List<EdgeIteratorState> noEntryCreatedEdges = new ArrayList<EdgeIteratorState>();
+         boolean modifiedWithNoEntry = false;
+         // Process Start Coordinate
+-        String startDirection = checkForNoEntryDirection(wayOsmId, way.getStartCoord());
++        String startDirection = checkForNoEntryDirection(wayOsmId,
++                way.getStartCoord());
+         if (startDirection != null) {
+             modifiedWithNoEntry = true;
+             lastNoEntry = 1; // This will set the index used for way nodes
+@@ -851,19 +939,21 @@
+             if (graphIndex != EMPTY) {
+ 
+                 long nodeFlags = getNodeFlagsMap().get(nodeId);
+-                OSMNode newNode = addBarrierNode(nodeId);
++                OSITNNode newNode = addBarrierNode(nodeId);
+                 long newNodeId = newNode.getId();
+                 // add way up to barrier shadow node
+                 long transfer[] = osmNodeIds.toArray(0, 2); // From 0 for length
+                                                             // 2
+                 transfer[transfer.length - 1] = newNodeId;
+                 TLongList partIds = new TLongArrayList(transfer);
+-                Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
++                Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
++                        wayFlags, wayOsmId);
+                 // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
+                 noEntryCreatedEdges.addAll(newWays);
+ 
+                 // create zero length edge for barrier to the next node
+-                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
++                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
++                        newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                 // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
+                 // newBarriers.size());
+                 noEntryCreatedEdges.addAll(newBarriers);
+@@ -871,21 +961,34 @@
+                 for (EdgeIteratorState edgeIteratorState : newWays) {
+                     boolean forwards = startDirection.equals("true");
+ 
+-                    long flags = encodingManager.flagsDefault(forwards, !forwards);
++                    long flags = encodingManager.flagsDefault(forwards,
++                            !forwards);
+                     // Set the flags on our new edge.
+                     edgeIteratorState.setFlags(flags);
+                 }
+                 successfulStartNoEntries++;
+             } else {
+                 failedStartNoEntries++;
+-                errors_logger.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId " + nodeId + " on way " + way.getId() + " for START Node " + osmNodeIds.toString() + " (" + successfulStartNoEntries + " succeeded, " + failedStartNoEntries + " failed)");
++                errors_logger
++                        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
++                                + nodeId
++                                + " on way "
++                                + way.getId()
++                                + " for START Node "
++                                + osmNodeIds.toString()
++                                + " ("
++                                + successfulStartNoEntries
++                                + " succeeded, "
++                                + failedStartNoEntries
++                                + " failed)");
+             }
+         }
+         // Process Way Nodes
+         final int size = osmNodeIds.size();
+         for (int i = 1, j = 0; j < wayNodes.size(); i++, j++) {
+             OSITNNode ositnNode = wayNodes.get(j);
+-            String direction = checkForNoEntryDirection(wayOsmId, way.getWayCoords()[j]);
++            String direction = checkForNoEntryDirection(wayOsmId,
++                    way.getWayCoords()[j]);
+             // If direction is null then there is no No Entry defined for this
+             // way node
+             if (direction != null) {
+@@ -894,7 +997,7 @@
+                 long nodeFlags = getNodeFlagsMap().get(nodeId);
+ 
+                 // create shadow node copy for zero length edge
+-                OSMNode newNode = addBarrierNode(nodeId);
++                OSITNNode newNode = addBarrierNode(nodeId);
+                 long newNodeId = newNode.getId();
+                 // Always > 0 as we start at index 1
+                 if (i > 0) {
+@@ -904,16 +1007,19 @@
+                     if (lastNoEntry < 0)
+                         lastNoEntry = 0;
+                     // add way up to barrier shadow node
+-                    long transfer[] = osmNodeIds.toArray(lastNoEntry, i - lastNoEntry + 1);
++                    long transfer[] = osmNodeIds.toArray(lastNoEntry, i
++                            - lastNoEntry + 1);
+                     transfer[transfer.length - 1] = newNodeId;
+                     TLongList partIds = new TLongArrayList(transfer);
+-                    Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
++                    Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
++                            wayFlags, wayOsmId);
+                     // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
+                     // newWays.size());
+                     noEntryCreatedEdges.addAll(newWays);
+ 
+                     // create zero length edge for barrier to the next node
+-                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
++                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
++                            newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                     // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
+                     // newBarriers.size());
+                     noEntryCreatedEdges.addAll(newBarriers);
+@@ -921,7 +1027,8 @@
+                     for (EdgeIteratorState edgeIteratorState : newBarriers) {
+                         boolean forwards = direction.equals("true");
+ 
+-                        long flags = encodingManager.flagsDefault(forwards, !forwards);
++                        long flags = encodingManager.flagsDefault(forwards,
++                                !forwards);
+                         // Set the flags on our new edge.
+                         edgeIteratorState.setFlags(flags);
+                     }
+@@ -930,7 +1037,8 @@
+                     // when the no entry is placed on either
+                     // TODO end of way we will have issues
+                     // run edge from real first node to shadow node
+-                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId);
++                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
++                            nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId);
+                     // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
+                     // newBarriers.size());
+                     noEntryCreatedEdges.addAll(newBarriers);
+@@ -945,7 +1053,8 @@
+         // Process the last coordinate
+         boolean processedEntireWay = false;
+         TLongList nodeIdsToCreateWaysFor = null;
+-        String endDirection = checkForNoEntryDirection(wayOsmId, way.getEndCoord());
++        String endDirection = checkForNoEntryDirection(wayOsmId,
++                way.getEndCoord());
+         if (endDirection != null) {
+             // Get the last node id
+             long nodeId = osmNodeIds.get(osmNodeIds.size() - 1);
+@@ -957,9 +1066,11 @@
+                 {
+                     if (lastNoEntry < 0)
+                         lastNoEntry = 0;
+-                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size - lastNoEntry - 1);
++                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size
++                            - lastNoEntry - 1);
+                     nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
+-                    Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
++                    Collection<EdgeIteratorState> newEdges = addOSMWay(
++                            nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
+                     // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
+                     // newEdges.size());
+                     createdEdges.addAll(newEdges);
+@@ -971,13 +1082,13 @@
+                 processedEntireWay = true;
+                 long nodeFlags = getNodeFlagsMap().get(nodeId);
+                 // create shadow node copy for zero length edge
+-                OSMNode newNode = addBarrierNode(nodeId);
++                OSITNNode newNode = addBarrierNode(nodeId);
+                 long newNodeId = newNode.getId();
+-                
+-                // Set this to be a TOWER node explicitly to overcome a limitation in the GraphHopper code for TurnRestrictions
+-                //getNodeMap().put(newNodeId, TOWER_NODE);
++
++                // Set this to be a TOWER node explicitly to overcome a
++                // limitation in the GraphHopper code for TurnRestrictions
++                // getNodeMap().put(newNodeId, TOWER_NODE);
+ 
+-                
+                 // add way up to barrier shadow node
+                 long transfer[] = osmNodeIds.toArray(osmNodeIds.size() - 2, 2); // From
+                                                                                 // 0
+@@ -986,19 +1097,22 @@
+                                                                                 // 2
+                 transfer[transfer.length - 1] = newNodeId;
+                 TLongList partIds = new TLongArrayList(transfer);
+-                Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
++                Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
++                        wayFlags, wayOsmId);
+                 // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
+                 noEntryCreatedEdges.addAll(newWays);
+ 
+                 // create zero length edge for barrier to the next node
+-                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
++                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
++                        newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                 // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
+                 // newBarriers.size());
+                 noEntryCreatedEdges.addAll(newBarriers);
+                 // Update the orientation of our little one way
+                 for (EdgeIteratorState edgeIteratorState : newBarriers) {
+                     boolean forwards = endDirection.equals("-1");
+-                    long flags = encodingManager.flagsDefault(forwards, !forwards);
++                    long flags = encodingManager.flagsDefault(forwards,
++                            !forwards);
+                     // Set the flags on our new edge.
+                     edgeIteratorState.setFlags(flags);
+                 }
+@@ -1007,7 +1121,18 @@
+                 failedEndNoEntries++;
+                 // TODO Figure out why there are some end nodes that don't have
+                 // internal node ids
+-                errors_logger.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId " + nodeId + " on way " + way.getId() + " for END Node " + osmNodeIds.toString() + " (" + successfulEndNoEntries + " succeeded, " + failedEndNoEntries + " failed)");
++                errors_logger
++                        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
++                                + nodeId
++                                + " on way "
++                                + way.getId()
++                                + " for END Node "
++                                + osmNodeIds.toString()
++                                + " ("
++                                + successfulEndNoEntries
++                                + " succeeded, "
++                                + failedEndNoEntries
++                                + " failed)");
+             }
+         }
+ 
+@@ -1018,7 +1143,8 @@
+             // node
+             if (modifiedWithNoEntry) {
+                 if (lastNoEntry < size - 1) {
+-                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size - lastNoEntry);
++                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size
++                            - lastNoEntry);
+                     nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
+                 }
+             } else {
+@@ -1051,7 +1177,8 @@
+         // Look for direction flags in edgeIdToXToYToNodeFlagsMap for the wayId,
+         // x, y combination
+         long key = wayId;
+-        TDoubleObjectMap<TDoubleLongMap> xToYToNodeFlagsMap = getEdgeIdToXToYToNodeFlagsMap().get(key);
++        TDoubleObjectMap<TDoubleLongMap> xToYToNodeFlagsMap = getEdgeIdToXToYToNodeFlagsMap()
++                .get(key);
+         if (xToYToNodeFlagsMap != null) {
+             String[] coordParts = wayCoord.split(",");
+             double xCoord = Double.parseDouble(coordParts[0]);
+@@ -1101,7 +1228,8 @@
+      * @param wayOsmId
+      * @return
+      */
+-    private List<EdgeIteratorState> processBarriers(Way way, TLongList osmNodeIds, long wayFlags, long wayOsmId) {
++    private List<EdgeIteratorState> processBarriers(Way way,
++            TLongList osmNodeIds, long wayFlags, long wayOsmId) {
+         List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
+         // look for barriers along the way
+         final int size = osmNodeIds.size();
+@@ -1121,7 +1249,7 @@
+                     getNodeFlagsMap().put(nodeId, 0);
+ 
+                     // create shadow node copy for zero length edge
+-                    OSMNode newNode = addBarrierNode(nodeId);
++                    OSITNNode newNode = addBarrierNode(nodeId);
+                     long newNodeId = newNode.getId();
+                     if (i > 0) {
+                         // start at beginning of array if there was no
+@@ -1131,22 +1259,28 @@
+                             lastBarrier = 0;
+ 
+                         // add way up to barrier shadow node
+-                        long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
++                        long transfer[] = osmNodeIds.toArray(lastBarrier, i
++                                - lastBarrier + 1);
+                         transfer[transfer.length - 1] = newNodeId;
+                         TLongList partIds = new TLongArrayList(transfer);
+-                        Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
++                        Collection<EdgeIteratorState> newWays = addOSMWay(
++                                partIds, wayFlags, wayOsmId);
+                         // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
+                         // newWays.size());
+                         createdEdges.addAll(newWays);
+ 
+                         // create zero length edge for barrier
+-                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
++                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
++                                newNodeId, nodeId, wayFlags, nodeFlags,
++                                wayOsmId);
+                         // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
+                         // newBarriers.size());
+                         createdEdges.addAll(newBarriers);
+                     } else {
+                         // run edge from real first node to shadow node
+-                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId);
++                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
++                                nodeId, newNodeId, wayFlags, nodeFlags,
++                                wayOsmId);
+                         // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
+                         // newBarriers.size());
+                         createdEdges.addAll(newBarriers);
+@@ -1166,7 +1300,8 @@
+         TLongList nodeIdsToCreateWaysFor = null;
+         if (lastBarrier >= 0) {
+             if (lastBarrier < size - 1) {
+-                long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
++                long transfer[] = osmNodeIds.toArray(lastBarrier, size
++                        - lastBarrier);
+                 nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
+             }
+         } else {
+@@ -1175,7 +1310,9 @@
+         }
+ 
+         if (nodeIdsToCreateWaysFor != null) {
+-            long lastNodeId = nodeIdsToCreateWaysFor.get(nodeIdsToCreateWaysFor.size()-1);;
++            long lastNodeId = nodeIdsToCreateWaysFor.get(nodeIdsToCreateWaysFor
++                    .size() - 1);
++            ;
+             long newNodeId = -1;
+ 
+             int graphIndex = getNodeMap().get(lastNodeId);
+@@ -1183,20 +1320,23 @@
+ 
+             // add end tower here
+             if (doInsertAdditionalTowerNodes) {
+-//                System.out.println("nodeIdsToCreateWaysFor.size() is " + nodeIdsToCreateWaysFor.size() + " lastNodeId is "+ lastNodeId);
+-                OSMNode newNode = addBarrierNode(lastNodeId);
++                // System.out.println("nodeIdsToCreateWaysFor.size() is " +
++                // nodeIdsToCreateWaysFor.size() + " lastNodeId is "+
++                // lastNodeId);
++                OSITNNode newNode = addBarrierNode(lastNodeId);
+                 newNodeId = newNode.getId();
+                 int nodeType = getNodeMap().get(newNodeId);
+-                
+-                nodeIdsToCreateWaysFor.set(nodeIdsToCreateWaysFor.size()-1, newNodeId);
++
++                nodeIdsToCreateWaysFor.set(nodeIdsToCreateWaysFor.size() - 1,
++                        newNodeId);
+             }
+-            
+ 
+-            Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
++            Collection<EdgeIteratorState> newEdges = addOSMWay(
++                    nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
+ 
+             createdEdges.addAll(newEdges);
+             if (doInsertAdditionalTowerNodes) {
+-                long transfer[] = {newNodeId, lastNodeId};
++                long transfer[] = { newNodeId, lastNodeId };
+                 TLongList partIds = new TLongArrayList(transfer);
+                 newEdges = addOSMWay(partIds, wayFlags, wayOsmId);
+                 createdEdges.addAll(newEdges);
+@@ -1228,23 +1368,30 @@
+      * @throws XMLStreamException
+      */
+     public void processRelation(Relation relation) throws XMLStreamException {
+-        if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_RESTRICTION)) {
++        if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
++                OSITNElement.TAG_VALUE_TYPE_RESTRICTION)) {
+             OSITNTurnRelation turnRelation = createTurnRelation(relation);
+             if (turnRelation != null) {
+-                long fromId = ((OSITNTurnRelation) turnRelation).getOsmIdFrom();
+-                long toId = ((OSITNTurnRelation) turnRelation).getOsmIdTo();
++                long fromId = turnRelation.getOsmIdFrom();
++                long toId = turnRelation.getOsmIdTo();
+                 // These were not originally added here. This could be used to
+                 // clean up getEdgeIdToOsmidMap() as it will now contain all
+                 // edgeIdToOsmId mappings
+                 getOsmIdStoreRequiredSet().add(fromId);
+                 getOsmIdStoreRequiredSet().add(toId);
+ 
+-                logger.info(TURN_FROM_TO_VIA_FORMAT, turnRelation.getOsmIdFrom(), turnRelation.getOsmIdTo(), turnRelation.getVia());
+-                ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage).getExtendedStorage();
++                logger.info(TURN_FROM_TO_VIA_FORMAT,
++                        turnRelation.getOsmIdFrom(), turnRelation.getOsmIdTo(),
++                        turnRelation.getVia());
++                ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
++                        .getExtendedStorage();
+                 if (extendedStorage instanceof TurnCostStorage) {
+-                    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(turnRelation, this);
++                    Collection<ITurnCostTableEntry> entries = encodingManager
++                            .analyzeTurnRelation(turnRelation, this);
+                     for (ITurnCostTableEntry entry : entries) {
+-                        ((TurnCostStorage) extendedStorage).addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(), (int) entry.getFlags());
++                        ((TurnCostStorage) extendedStorage).addTurnInfo(
++                                entry.getVia(), entry.getEdgeFrom(),
++                                entry.getEdgeTo(), (int) entry.getFlags());
+                     }
+                 }
+             }
+@@ -1255,7 +1402,8 @@
+         // }
+     }
+ 
+-    public long getOsmIdOfInternalEdge(int edgeId) {
++    @Override
++    public Long getOsmIdOfInternalEdge(int edgeId) {
+         return getEdgeIdToOsmidMap().get(edgeId);
+     }
+ 
+@@ -1263,7 +1411,8 @@
+         return getEdgeIdToOsmidMap().get(edgeId);
+     }
+ 
+-    public int getInternalNodeIdOfOsmNode(long nodeOsmId) {
++    @Override
++    public int getInternalNodeIdOfOsmNode(Long nodeOsmId) {
+         int id = getNodeMap().get(nodeOsmId);
+         if (id < TOWER_NODE)
+             return -id - 3;
+@@ -1307,7 +1456,7 @@
+             return Double.NaN;
+     }
+ 
+-    private void processNode(Node node) {
++    private void processNode(OSITNNode node) {
+         if (isInBounds(node)) {
+             addNode(node);
+ 
+@@ -1326,7 +1475,7 @@
+         }
+     }
+ 
+-    boolean addNode(Node node) {
++    boolean addNode(OSITNNode node) {
+         int nodeType = getNodeMap().get(node.getId());
+         if (nodeType == EMPTY) {
+             // logger.warn(MISSING_FROM_MAP_FORMAT, node.getId());
+@@ -1352,7 +1501,8 @@
+ 
+     void prepareWaysWithRelationInfo(Relation relation) {
+         // is there at least one tag interesting for the registered encoders?
+-        long handleRelationTags = encodingManager.handleRelationTags(relation, 0);
++        long handleRelationTags = encodingManager.handleRelationTags(relation,
++                0);
+         // logger.warn(PREPARE_ONE_WAY_FORMAT, handleRelationTags);
+         if (handleRelationTags == 0) {
+             return;
+@@ -1369,7 +1519,8 @@
+ 
+             // Check if our new relation data is better comparated to the the
+             // last one
+-            long newRelationFlags = encodingManager.handleRelationTags(relation, oldRelationFlags);
++            long newRelationFlags = encodingManager.handleRelationTags(
++                    relation, oldRelationFlags);
+             // logger.warn(APPLYING_RELATION_FORMAT, oldRelationFlags,
+             // newRelationFlags);
+             if (oldRelationFlags != newRelationFlags) {
+@@ -1382,11 +1533,13 @@
+         int tmpIndex = getNodeMap().get(osmId);
+         if (tmpIndex == EMPTY) {
+             // osmId is used exactly once
+-            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_EMPTY_PILLAR_FORMAT, osmId);
++            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_EMPTY_PILLAR_FORMAT,
++                    osmId);
+             getNodeMap().put(osmId, PILLAR_NODE);
+         } else if (tmpIndex > EMPTY) {
+             // mark node as tower node as it occured at least twice times
+-            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_PILLAR_TOWER_FORMAT, osmId);
++            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_PILLAR_TOWER_FORMAT,
++                    osmId);
+             getNodeMap().put(osmId, TOWER_NODE);
+         } else {
+             // tmpIndex is already negative (already tower node)
+@@ -1409,8 +1562,10 @@
+      * This method creates from an OSM way (via the osm ids) one or more edges
+      * in the graph.
+      */
+-    Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags, long wayOsmId) {
+-        PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
++    Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags,
++            long wayOsmId) {
++        PointList pointList = new PointList(osmNodeIds.size(),
++                nodeAccess.is3D());
+         List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
+         int firstNode = -1;
+         int lastIndex = osmNodeIds.size() - 1;
+@@ -1434,14 +1589,16 @@
+                     // current file.
+                     // => if the node before was a pillar node then convert into
+                     // to tower node (as it is also end-standing).
+-                    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE) {
++                    if (!pointList.isEmpty()
++                            && lastInBoundsPillarNode > -TOWER_NODE) {
+                         // transform the pillar node to a tower node
+                         tmpNode = lastInBoundsPillarNode;
+                         tmpNode = handlePillarNode(tmpNode, osmId, null, true);
+                         tmpNode = -tmpNode - 3;
+                         if (pointList.getSize() > 1 && firstNode >= 0) {
+                             // TOWER node
+-                            newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
++                            newEdges.add(addEdge(firstNode, tmpNode, pointList,
++                                    flags, wayOsmId));
+                             pointList.clear();
+                             pointList.add(nodeAccess, tmpNode);
+                         }
+@@ -1452,7 +1609,9 @@
+                 }
+ 
+                 if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
+-                    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", " + osmId);
++                    throw new AssertionError(
++                            "Mapped index not in correct bounds " + tmpNode
++                                    + ", " + osmId);
+ 
+                 if (tmpNode > -TOWER_NODE) {
+                     boolean convertToTowerNode = i == 0 || i == lastIndex;
+@@ -1461,7 +1620,8 @@
+                     }
+ 
+                     // PILLAR node, but convert to towerNode if end-standing
+-                    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
++                    tmpNode = handlePillarNode(tmpNode, osmId, pointList,
++                            convertToTowerNode);
+                 }
+ 
+                 if (tmpNode < TOWER_NODE) {
+@@ -1469,7 +1629,8 @@
+                     tmpNode = -tmpNode - 3;
+                     pointList.add(nodeAccess, tmpNode);
+                     if (firstNode >= 0) {
+-                        newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
++                        newEdges.add(addEdge(firstNode, tmpNode, pointList,
++                                flags, wayOsmId));
+                         pointList.clear();
+                         pointList.add(nodeAccess, tmpNode);
+                     }
+@@ -1477,26 +1638,35 @@
+                 }
+             }
+         } catch (RuntimeException ex) {
+-            logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
++            logger.error("Couldn't properly add edge with osm ids:"
++                    + osmNodeIds, ex);
+             if (exitOnlyPillarNodeException)
+                 throw ex;
+         }
+         return newEdges;
+     }
+ 
+-    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId) {
++    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
++            long flags, long wayOsmId) {
+         // sanity checks
+         if (fromIndex < 0 || toIndex < 0)
+-            throw new AssertionError("to or from index is invalid for this edge " + fromIndex + "->" + toIndex + ", points:" + pointList);
++            throw new AssertionError(
++                    "to or from index is invalid for this edge " + fromIndex
++                            + "->" + toIndex + ", points:" + pointList);
+         if (pointList.getDimension() != nodeAccess.getDimension())
+-            throw new AssertionError("Dimension does not match for pointList vs. nodeAccess " + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
++            throw new AssertionError(
++                    "Dimension does not match for pointList vs. nodeAccess "
++                            + pointList.getDimension() + " <-> "
++                            + nodeAccess.getDimension());
+ 
+         double towerNodeDistance = 0;
+         double prevLat = pointList.getLatitude(0);
+         double prevLon = pointList.getLongitude(0);
+-        double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
++        double prevEle = pointList.is3D() ? pointList.getElevation(0)
++                : Double.NaN;
+         double lat, lon, ele = Double.NaN;
+-        PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
++        PointList pillarNodes = new PointList(pointList.getSize() - 2,
++                nodeAccess.is3D());
+         int nodes = pointList.getSize();
+         for (int i = 1; i < nodes; i++) {
+             // we could save some lines if we would use
+@@ -1505,10 +1675,12 @@
+             lon = pointList.getLongitude(i);
+             if (pointList.is3D()) {
+                 ele = pointList.getElevation(i);
+-                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
++                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon,
++                        prevEle, lat, lon, ele);
+                 prevEle = ele;
+             } else
+-                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
++                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat,
++                        lon);
+             prevLat = lat;
+             prevLon = lon;
+             if (nodes > 2 && i < nodes - 1) {
+@@ -1526,7 +1698,8 @@
+             towerNodeDistance = 0.0001;
+         }
+         logger.info("Add edge flags:" + flags);
+-        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
++        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
++                .setDistance(towerNodeDistance).setFlags(flags);
+         if (nodes > 2) {
+             if (doSimplify)
+                 simplifyAlgo.simplify(pillarNodes);
+@@ -1555,18 +1728,23 @@
+     /**
+      * @return converted tower node
+      */
+-    private int handlePillarNode(int tmpNode, long osmId, PointList pointList, boolean convertToTowerNode) {
+-        logger.info(CONVERTING_PILLAR_TO_PILLAR_FORMAT, osmId, convertToTowerNode);
++    private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
++            boolean convertToTowerNode) {
++        logger.info(CONVERTING_PILLAR_TO_PILLAR_FORMAT, osmId,
++                convertToTowerNode);
+         tmpNode = tmpNode - 3;
+         double lat = pillarInfo.getLatitude(tmpNode);
+         double lon = pillarInfo.getLongitude(tmpNode);
+         double ele = pillarInfo.getElevation(tmpNode);
+         if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
+-            throw new RuntimeException("Conversion pillarNode to towerNode already happended!? " + "osmId:" + osmId + " pillarIndex:" + tmpNode);
++            throw new RuntimeException(
++                    "Conversion pillarNode to towerNode already happended!? "
++                            + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+ 
+         if (convertToTowerNode) {
+             // convert pillarNode type to towerNode, make pillar values invalid
+-            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
++            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE,
++                    Double.MAX_VALUE);
+             tmpNode = addTowerNode(osmId, lat, lon, ele);
+         } else {
+             if (pointList.is3D())
+@@ -1575,7 +1753,7 @@
+                 pointList.add(lat, lon);
+         }
+ 
+-        return (int) tmpNode;
++        return tmpNode;
+     }
+ 
+     protected void finishedReading() {
+@@ -1593,21 +1771,24 @@
+     /**
+      * Create a copy of the barrier node
+      */
+-    private OSMNode addBarrierNode(long nodeId) {
+-        OSMNode newNode = null;
++    private OSITNNode addBarrierNode(long nodeId) {
++        OSITNNode newNode = null;
+         int graphIndex = getNodeMap().get(nodeId);
+-//        System.out.println("graphIndex BEFORE is " + graphIndex);
++        // System.out.println("graphIndex BEFORE is " + graphIndex);
+ 
+         if (graphIndex < TOWER_NODE) {
+             graphIndex = -graphIndex - 3;
+-//            System.out.println("Create Tower node for nodeId " + nodeId + " graphIndex is " + graphIndex);
+-            newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
++            // System.out.println("Create Tower node for nodeId " + nodeId +
++            // " graphIndex is " + graphIndex);
++            newNode = new OSITNNode(createNewNodeId(), nodeAccess, graphIndex);
+         } else {
+             graphIndex = graphIndex - 3;
+             try {
+-//                System.out.println("Create Pillar node for nodeId " + nodeId + " graphIndex is " + graphIndex);
+-                newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
+-//                System.out.println("newNode is " + newNode);
++                // System.out.println("Create Pillar node for nodeId " + nodeId
++                // + " graphIndex is " + graphIndex);
++                newNode = new OSITNNode(createNewNodeId(), pillarInfo,
++                        graphIndex);
++                // System.out.println("newNode is " + newNode);
+             } catch (ArrayIndexOutOfBoundsException e) {
+                 e.printStackTrace();
+             }
+@@ -1618,12 +1799,13 @@
+         addNode(newNode);
+         return newNode;
+     }
++
+     /**
+      * Create a copy of the barrier node
+      */
+-    private OSMNode addBarrierNode(long nodeId, double lat, double lon) {
+-        OSMNode newNode = null;
+-        newNode = new OSMNode(createNewNodeId(), lat, lon);
++    private OSITNNode addBarrierNode(long nodeId, double lat, double lon) {
++        OSITNNode newNode = null;
++        newNode = new OSITNNode(createNewNodeId(), lat, lon);
+ 
+         final long id = newNode.getId();
+         prepareHighwayNode(id);
+@@ -1638,7 +1820,8 @@
+     /**
+      * Add a zero length edge with reduced routing options to the graph.
+      */
+-    private Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, long flags, long nodeFlags, long wayOsmId) {
++    private Collection<EdgeIteratorState> addBarrierEdge(long fromId,
++            long toId, long flags, long nodeFlags, long wayOsmId) {
+         // clear barred directions from routing flags
+         flags &= ~nodeFlags;
+         // add edge
+@@ -1656,7 +1839,9 @@
+      *         relation
+      */
+     OSITNTurnRelation createTurnRelation(Relation relation) {
+-        OSMTurnRelation.Type type = OSITNTurnRelation.getRestrictionType((String) relation.getTag(OSITNElement.TAG_KEY_RESTRICTION));
++        OSMTurnRelation.Type type = OSITNTurnRelation
++                .getRestrictionType(relation
++                        .getTag(OSITNElement.TAG_KEY_RESTRICTION));
+ 
+         // Handle No Turn and Mandatory Turn Exceptions. This is done by
+         // selectively ignoring restrictions based on excluded/included vehicle
+@@ -1675,7 +1860,8 @@
+             //
+             // }
+             // There is a no entry or mandatory turn
+-            if (encodingManager.isVehicleQualifierTypeExcluded(relation) || encodingManager.isVehicleQualifierTypeIncluded(relation)) {
++            if (encodingManager.isVehicleQualifierTypeExcluded(relation)
++                    || encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+                 // The current encoder vehicle is excluded from this restriction
+                 // so remove it OR (except buses=false)
+                 // The current encoder vehicle is included in the exception so
+@@ -1700,15 +1886,18 @@
+                     } else if ("to".equals(member.role())) {
+                         toWayID = ref;
+                     }
+-                } else if (OSMElement.NODE == member.type() && "via".equals(member.role())) {
++                } else if (OSMElement.NODE == member.type()
++                        && "via".equals(member.role())) {
+                     viaNodeID = ref;
+                 }
+             }
+ 
+-            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0 && toWayID >= 0) {
++            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0
++                    && toWayID >= 0) {
+                 long foundViaNode = findViaNode(fromWayID, toWayID);
+                 if (-1 < foundViaNode) {
+-                    OSITNTurnRelation osmTurnRelation = new OSITNTurnRelation(fromWayID, foundViaNode, toWayID, type);
++                    OSITNTurnRelation osmTurnRelation = new OSITNTurnRelation(
++                            fromWayID, foundViaNode, toWayID, type);
+                     return osmTurnRelation;
+                 }
+             }
+@@ -1741,40 +1930,50 @@
+     /**
+      * Specify the type of the path calculation (car, bike, ...).
+      */
++    @Override
+     public OsItnReader setEncodingManager(EncodingManager acceptWay) {
+         this.encodingManager = acceptWay;
+         return this;
+     }
+ 
++    @Override
+     public OsItnReader setWayPointMaxDistance(double maxDist) {
+         doSimplify = maxDist > 0;
+         simplifyAlgo.setMaxDistance(maxDist);
+         return this;
+     }
+ 
++    @Override
+     public OsItnReader setWorkerThreads(int numOfWorkers) {
+         this.workerThreads = numOfWorkers;
+         return this;
+     }
+ 
++    @Override
+     public OsItnReader setElevationProvider(ElevationProvider eleProvider) {
+         if (eleProvider == null)
+-            throw new IllegalStateException("Use the NOOP elevation provider instead of null or don't call setElevationProvider");
++            throw new IllegalStateException(
++                    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+ 
+         if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
+-            throw new IllegalStateException("Make sure you graph accepts 3D data");
++            throw new IllegalStateException(
++                    "Make sure you graph accepts 3D data");
+ 
+         this.eleProvider = eleProvider;
+         return this;
+     }
+ 
++    @Override
+     public OsItnReader setOSMFile(File osmFile) {
+         this.routingFile = osmFile;
+         return this;
+     }
+ 
+     private void printInfo(String str) {
+-        logger.info(PRINT_INFO_FORMAT, str, graphStorage.getNodes(), getNodeMap().getSize(), getNodeMap().getMemoryUsage(), getNodeFlagsMap().size(), getRelFlagsMap().size(), Helper.getMemInfo());
++        logger.info(PRINT_INFO_FORMAT, str, graphStorage.getNodes(),
++                getNodeMap().getSize(), getNodeMap().getMemoryUsage(),
++                getNodeFlagsMap().size(), getRelFlagsMap().size(),
++                Helper.getMemInfo());
+     }
+ 
+     @Override
+@@ -1782,6 +1981,7 @@
+         return getClass().getSimpleName();
+     }
+ 
++    @Override
+     public GraphStorage getGraphStorage() {
+         return graphStorage;
+     }
+Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java	(working copy)
+@@ -27,6 +27,9 @@
+ import javax.xml.stream.XMLStreamException;
+ import javax.xml.stream.XMLStreamReader;
+ 
++import org.opengis.geometry.MismatchedDimensionException;
++import org.opengis.referencing.FactoryException;
++import org.opengis.referencing.operation.TransformException;
+ import org.slf4j.Logger;
+ import org.slf4j.LoggerFactory;
+ 
+@@ -40,242 +43,277 @@
+  * @author Peter
+  */
+ public abstract class OsDpnElement implements RoutingElement {
+-	public static final int NODE = 0;
+-	public static final int WAY = 1;
+-	public static final int RELATION = 2;
+-	private final int type;
+-	private final long id;
+-	private final Map<String, Object> properties = new HashMap<String, Object>(
+-			5);
+-	private static final Logger logger = LoggerFactory
+-			.getLogger(OsDpnElement.class);
++    public static final int NODE = 0;
++    public static final int WAY = 1;
++    public static final int RELATION = 2;
++    private final int type;
++    private final String id;
++    private final Map<String, Object> properties = new HashMap<String, Object>(
++            5);
++    private static final Logger logger = LoggerFactory
++            .getLogger(OsDpnElement.class);
++
++    protected OsDpnElement(String id, int type) {
++        this.id = id;
++        this.type = type;
++    }
+ 
+-	protected OsDpnElement(long id, int type) {
+-		this.id = id;
+-		this.type = type;
+-	}
++    public String getId() {
++        return id;
++    }
+ 
+-	public long getId() {
+-		return id;
+-	}
++    protected void readTags(XMLStreamReader parser) throws XMLStreamException,
++            MismatchedDimensionException, FactoryException, TransformException {
++        int event = parser.getEventType();
++        while (event != XMLStreamConstants.END_DOCUMENT
++                && (event != XMLStreamConstants.END_ELEMENT || !exitElement(parser))) {
++            if (event == XMLStreamConstants.CHARACTERS) {
++                event = parser.next();
++            } else {
++                if (event == XMLStreamConstants.START_ELEMENT) {
++                    // logger.info("LOCALNAME: {}", parser.getLocalName());
++                    switch (parser.getLocalName()) {
++                        case "pos":
++                        case "coordinates": {
++                            event = handleCoordinates(parser);
++                            break;
++                        }
++                        case "networkMember": {
++                            event = handleNetworkMember(parser);
++                            break;
++                        }
++                        case "posList": {
++                            event = handleMultiDimensionCoords(parser);
++                            break;
++                        }
++                        case "startNode":
++                        case "endNode": {
++                            event = handleNode(parser);
++                            break;
++                        }
++                        case "directedLink": {
++                            event = handleDirectedLink(parser);
++                            break;
++                        }
++                        case "instruction": {
++                            System.err.println("INSTRUCTION:");
++                            setTag("type", "restriction");
++                            event = handleTag("restriction", parser);
++                            break;
++                        }
++                        case "descriptiveTerm": {
++                            event = handleDescriptiveTerm(parser);
++                            break;
++                        }
++                        case "name": {
++                            event = handleTag("name", parser);
++                            break;
++                        }
++                        default: {
++                            event = parser.next();
++                        }
++                    }
++                } else {
++                    // logger.trace("EVENT:" + event);
++                    event = parser.next();
++                }
++            }
++        }
++    }
+ 
+-	protected void readTags(XMLStreamReader parser) throws XMLStreamException {
+-		int event = parser.getEventType();
+-		while (event != XMLStreamConstants.END_DOCUMENT  && (event != XMLStreamConstants.END_ELEMENT || !exitElement(parser))) {
+-			if (event == XMLStreamConstants.CHARACTERS) {
+-				event = parser.next();
+-			} else {
+-				
+-			if (event == XMLStreamConstants.START_ELEMENT) {
+-				logger.info("LOCALNAME:"+parser.getLocalName());
+-				switch (parser.getLocalName()) {
+-				case "coordinates": {
+-						event = handleCoordinates(parser);
+-						break;
+-					}
+-				case "networkMember" : {
+-					event = handleNetworkMember(parser);
+-					break;
+-				}
+-				case "directedNode" : {
+-					event = handleDirectedNode(parser);
+-					break;
+-				}
+-				case "directedLink" : {
+-					event = handleDirectedLink(parser);
+-					break;
+-				}
+-				case "instruction" : {
+-					System.err.println("INSTRUCTION:");
+-					setTag("type", "restriction");
+-					event = handleTag("restriction",parser);
+-					break;
+-				}
+-				case "roadName" : {
+-					event = handleTag("name", parser);
+-					break;
+-				}
+-				default : {
+-						event = parser.next();
+-					}
+-				}
+-				
+-				
+-//				int attributeCount = parser.getAttributeCount();
+-//				for (int i = 0; i < attributeCount; i++) {
+-//					QName attributeName = parser.getAttributeName(i);
+-//					System.err.println("QNAME:" + attributeName);
+-//				}
+-				
+-				// read tag
+-				// String key = parser.getAttributeValue(null, "k");
+-				// String value = parser.getAttributeValue(null, "v");
+-				// // ignore tags with empty values
+-				// if (value != null && value.length() > 0)
+-				// setTag(key, value);
++    private int handleDescriptiveTerm(XMLStreamReader parser)
++            throws XMLStreamException {
++        String roadType = parser.getElementText();
++        setTag("type", "route");
++        setTag("highway", roadType);
++        setTag("name", roadType);
++        return parser.getEventType();
++    }
+ 
+-			}
+-			else {
+-				logger.info("EVENT:" + event);
+-				event = parser.next();
+-			}
+-			}
+-		}
+-	}
++    private int handleDirectedLink(XMLStreamReader parser)
++            throws XMLStreamException {
++        String orientation = parser.getAttributeValue(null, "orientation");
++        String nodeId = parser.getAttributeValue(
++                "http://www.w3.org/1999/xlink", "href");
++        addDirectedLink(nodeId, orientation);
++        return parser.next();
++    }
+ 
+-	private int handleDirectedLink(XMLStreamReader parser) throws XMLStreamException {
+-		String orientation = parser.getAttributeValue(null, "orientation");
+-		String nodeId = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
+-		addDirectedLink(nodeId, orientation);
+-		return parser.next();
+-	}
++    private int handleNode(XMLStreamReader parser) throws XMLStreamException {
++        String nodeId = parser.getAttributeValue(
++                "http://www.w3.org/1999/xlink", "href");
++        addNode(nodeId);
++        return parser.next();
++    }
+ 
+-	private int handleDirectedNode(XMLStreamReader parser) throws XMLStreamException {
+-		String orientation = parser.getAttributeValue(null, "orientation");
+-		String nodeId = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
+-		addDirectedNode(nodeId, orientation);
+-		return parser.next();
+-	}
++    private int handleTag(String key, XMLStreamReader parser)
++            throws XMLStreamException {
++        properties.put(key, parser.getElementText());
++        return parser.getEventType();
++    }
+ 
+-	private int handleTag(String key, XMLStreamReader parser) throws XMLStreamException {
+-		properties.put(key, parser.getElementText());
+-		return parser.getEventType();
+-	}
++    private int handleNetworkMember(XMLStreamReader parser)
++            throws XMLStreamException {
++        String elementText = parser.getAttributeValue(
++                "http://www.w3.org/1999/xlink", "href");
++        parseNetworkMember(elementText);
++        return parser.next();
++    }
+ 
+-	private int handleNetworkMember(XMLStreamReader parser) throws XMLStreamException {
+-		String elementText = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
+-		parseNetworkMember(elementText);
+-		return parser.next();
+-	}
++    private int handleCoordinates(XMLStreamReader parser)
++            throws XMLStreamException, MismatchedDimensionException,
++            FactoryException, TransformException {
++        String elementText = parser.getElementText();
++        parseCoords(elementText);
++        return parser.getEventType();
++    }
+ 
+-	private int handleCoordinates(XMLStreamReader parser)
+-			throws XMLStreamException {
+-		String elementText = parser.getElementText();
+-		parseCoords(elementText);
+-		return parser.getEventType();
+-	}
++    private int handleMultiDimensionCoords(XMLStreamReader parser)
++            throws XMLStreamException {
++        String dimensionality = parser.getAttributeValue(null, "srsDimension");
++        logger.info("Dimensions:" + dimensionality);
++        String elementText = parser.getElementText();
++        parseCoords(Integer.valueOf(dimensionality), elementText);
++        return parser.getEventType();
++    }
+ 
+-	protected abstract void parseCoords(String coordinates);
+-	
+-	protected abstract void addDirectedNode(String nodeId, String orientation);
+-	
+-	protected abstract void addDirectedLink(String nodeId, String orientation);
+-	
+-	protected abstract void parseNetworkMember(String elementText);
++    protected abstract void parseCoords(String coordinates)
++            throws MismatchedDimensionException, FactoryException,
++            TransformException;
+ 
+-	private boolean exitElement(XMLStreamReader parser) {
+-		switch(parser.getLocalName()) {
+-		case "RoadNode" : 
+-		case "RoadLink" :	return true;
+-		}
+-		return false;
+-	}
++    protected abstract void parseCoords(int dimensions, String lineDefinition);
+ 
+-	protected String tagsToString() {
+-		if (properties.isEmpty())
+-			return "<empty>";
++    protected abstract void addNode(String nodeId);
+ 
+-		StringBuilder tagTxt = new StringBuilder();
+-		for (Map.Entry<String, Object> entry : properties.entrySet()) {
+-			tagTxt.append(entry.getKey());
+-			tagTxt.append("=");
+-			tagTxt.append(entry.getValue());
+-			tagTxt.append("\n");
+-		}
+-		return tagTxt.toString();
+-	}
++    protected abstract void addDirectedLink(String nodeId, String orientation);
+ 
+-	protected Map<String, Object> getTags() {
+-		return properties;
+-	}
++    protected abstract void parseNetworkMember(String elementText);
+ 
+-	public void setTags(Map<String, String> newTags) {
+-		properties.clear();
+-		if (newTags != null)
+-			for (Entry<String, String> e : newTags.entrySet()) {
+-				setTag(e.getKey(), e.getValue());
+-			}
+-	}
++    private boolean exitElement(XMLStreamReader parser) {
++        switch (parser.getLocalName()) {
++            case "RouteNode":
++            case "RouteLink":
++            case "Route":
++                return true;
++        }
++        return false;
++    }
+ 
+-	public boolean hasTags() {
+-		return !properties.isEmpty();
+-	}
++    protected String tagsToString() {
++        if (properties.isEmpty())
++            return "<empty>";
+ 
+-	public String getTag(String name) {
+-		return (String) properties.get(name);
+-	}
++        StringBuilder tagTxt = new StringBuilder();
++        for (Map.Entry<String, Object> entry : properties.entrySet()) {
++            tagTxt.append(entry.getKey());
++            tagTxt.append("=");
++            tagTxt.append(entry.getValue());
++            tagTxt.append("\n");
++        }
++        return tagTxt.toString();
++    }
+ 
+-	@SuppressWarnings("unchecked")
+-	public <T> T getTag(String key, T defaultValue) {
+-		T val = (T) properties.get(key);
+-		if (val == null)
+-			return defaultValue;
+-		return val;
+-	}
++    protected Map<String, Object> getTags() {
++        return properties;
++    }
+ 
+-	public void setTag(String name, Object value) {
+-		properties.put(name, value);
+-	}
++    public void setTags(Map<String, String> newTags) {
++        properties.clear();
++        if (newTags != null)
++            for (Entry<String, String> e : newTags.entrySet()) {
++                setTag(e.getKey(), e.getValue());
++            }
++    }
+ 
+-	/**
+-	 * Chaeck that the object has a given tag with a given value.
+-	 */
+-	public boolean hasTag(String key, Object value) {
+-		return value.equals(properties.get(key));
+-	}
++    @Override
++    public boolean hasTags() {
++        return !properties.isEmpty();
++    }
+ 
+-	/**
+-	 * Check that a given tag has one of the specified values. If no values are
+-	 * given, just checks for presence of the tag
+-	 */
+-	public boolean hasTag(String key, String... values) {
+-		Object osmValue = properties.get(key);
+-		if (osmValue == null)
+-			return false;
++    @Override
++    public String getTag(String name) {
++        return (String) properties.get(name);
++    }
+ 
+-		// tag present, no values given: success
+-		if (values.length == 0)
+-			return true;
++    @Override
++    @SuppressWarnings("unchecked")
++    public <T> T getTag(String key, T defaultValue) {
++        T val = (T) properties.get(key);
++        if (val == null)
++            return defaultValue;
++        return val;
++    }
+ 
+-		for (String val : values) {
+-			if (val.equals(osmValue))
+-				return true;
+-		}
+-		return false;
+-	}
++    @Override
++    public void setTag(String name, Object value) {
++        properties.put(name, value);
++    }
+ 
+-	/**
+-	 * Check that a given tag has one of the specified values.
+-	 */
+-	public final boolean hasTag(String key, Set<String> values) {
+-		return values.contains(properties.get(key));
+-	}
++    /**
++     * Chaeck that the object has a given tag with a given value.
++     */
++    @Override
++    public boolean hasTag(String key, Object value) {
++        return value.equals(properties.get(key));
++    }
+ 
+-	/**
+-	 * Check a number of tags in the given order for the any of the given
+-	 * values. Used to parse hierarchical access restrictions
+-	 */
+-	public boolean hasTag(List<String> keyList, Set<String> values) {
+-		for (String key : keyList) {
+-			if (values.contains(properties.get(key)))
+-				return true;
+-		}
+-		return false;
+-	}
++    /**
++     * Check that a given tag has one of the specified values. If no values are
++     * given, just checks for presence of the tag
++     */
++    @Override
++    public boolean hasTag(String key, String... values) {
++        Object osmValue = properties.get(key);
++        if (osmValue == null)
++            return false;
+ 
+-	public void removeTag(String name) {
+-		properties.remove(name);
+-	}
++        // tag present, no values given: success
++        if (values.length == 0)
++            return true;
+ 
+-	public void clearTags() {
+-		properties.clear();
+-	}
++        for (String val : values) {
++            if (val.equals(osmValue))
++                return true;
++        }
++        return false;
++    }
+ 
+-	public int getType() {
+-		return type;
+-	}
++    /**
++     * Check that a given tag has one of the specified values.
++     */
++    @Override
++    public final boolean hasTag(String key, Set<String> values) {
++        return values.contains(properties.get(key));
++    }
+ 
+-	public boolean isType(int type) {
+-		return this.type == type;
+-	}
++    /**
++     * Check a number of tags in the given order for the any of the given
++     * values. Used to parse hierarchical access restrictions
++     */
++    @Override
++    public boolean hasTag(List<String> keyList, Set<String> values) {
++        for (String key : keyList) {
++            if (values.contains(properties.get(key)))
++                return true;
++        }
++        return false;
++    }
++
++    public void removeTag(String name) {
++        properties.remove(name);
++    }
++
++    public void clearTags() {
++        properties.clear();
++    }
++
++    @Override
++    public int getType() {
++        return type;
++    }
++
++    @Override
++    public boolean isType(int type) {
++        return this.type == type;
++    }
+ }
+Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java	(working copy)
+@@ -1,14 +1,13 @@
+ package com.graphhopper.reader.osgb.dpn;
+ 
+ import static com.graphhopper.util.Helper.nf;
+-import gnu.trove.list.TLongList;
+-import gnu.trove.list.array.TLongArrayList;
+-import gnu.trove.map.TIntLongMap;
+-import gnu.trove.map.TLongLongMap;
+-import gnu.trove.map.hash.TIntLongHashMap;
+-import gnu.trove.map.hash.TLongLongHashMap;
+-import gnu.trove.set.TLongSet;
+-import gnu.trove.set.hash.TLongHashSet;
++import gnu.trove.map.TLongObjectMap;
++import gnu.trove.map.TObjectIntMap;
++import gnu.trove.map.TObjectLongMap;
++import gnu.trove.map.hash.TLongObjectHashMap;
++import gnu.trove.map.hash.TObjectIntHashMap;
++import gnu.trove.map.hash.TObjectLongHashMap;
++import gnu.trove.set.hash.THashSet;
+ 
+ import java.io.File;
+ import java.io.IOException;
+@@ -22,31 +21,20 @@
+ import org.slf4j.Logger;
+ import org.slf4j.LoggerFactory;
+ 
+-import com.graphhopper.coll.GHLongIntBTree;
+-import com.graphhopper.coll.LongIntMap;
+ import com.graphhopper.reader.DataReader;
+-import com.graphhopper.reader.ITurnCostTableEntry;
+ import com.graphhopper.reader.Node;
+ import com.graphhopper.reader.OSMElement;
+-import com.graphhopper.reader.OSMNode;
+-import com.graphhopper.reader.OSMRelation;
+ import com.graphhopper.reader.OSMTurnRelation;
+ import com.graphhopper.reader.PillarInfo;
+ import com.graphhopper.reader.Relation;
+ import com.graphhopper.reader.RelationMember;
+ import com.graphhopper.reader.RoutingElement;
+ import com.graphhopper.reader.TurnRelation;
+-import com.graphhopper.reader.Way;
+ import com.graphhopper.reader.dem.ElevationProvider;
+ import com.graphhopper.reader.osgb.OSITNTurnRelation;
+-import com.graphhopper.reader.osgb.OSITNWay;
+-import com.graphhopper.reader.osgb.OsItnInputFile;
+ import com.graphhopper.routing.util.EncodingManager;
+-import com.graphhopper.storage.ExtendedStorage;
+-import com.graphhopper.storage.GraphHopperStorage;
+ import com.graphhopper.storage.GraphStorage;
+ import com.graphhopper.storage.NodeAccess;
+-import com.graphhopper.storage.TurnCostStorage;
+ import com.graphhopper.util.DistanceCalc;
+ import com.graphhopper.util.DistanceCalc3D;
+ import com.graphhopper.util.DistanceCalcEarth;
+@@ -101,870 +89,874 @@
+  * @author Peter Karich
+  */
+ 
+-public class OsDpnReader implements DataReader {
+-	private InputStream is;
+-
+-	protected static final int EMPTY = -1;
+-	// pillar node is >= 3
+-	protected static final int PILLAR_NODE = 1;
+-	// tower node is <= -3
+-	protected static final int TOWER_NODE = -2;
+-	private static final Logger logger = LoggerFactory
+-			.getLogger(OsDpnReader.class);
+-	private long locations;
+-	private long skippedLocations;
+-	private final GraphStorage graphStorage;
+-	private final NodeAccess nodeAccess;
+-	private EncodingManager encodingManager = null;
+-	private int workerThreads = -1;
+-	protected long zeroCounter = 0;
+-	// Using the correct Map<Long, Integer> is hard. We need a memory efficient
+-	// and fast solution for big data sets!
+-	//
+-	// very slow: new SparseLongLongArray
+-	// only append and update possible (no unordered storage like with this
+-	// doubleParse): new OSMIDMap
+-	// same here: not applicable as ways introduces the nodes in 'wrong' order:
+-	// new OSMIDSegmentedMap
+-	// memory overhead due to open addressing and full rehash:
+-	// nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
+-	// smaller memory overhead for bigger data sets because of avoiding a
+-	// "rehash"
+-	// remember how many times a node was used to identify tower nodes
+-	private LongIntMap osmNodeIdToInternalNodeMap;
+-	private TLongLongHashMap osmNodeIdToNodeFlagsMap;
+-	private TLongLongHashMap osmWayIdToRouteWeightMap;
+-	// stores osm way ids used by relations to identify which edge ids needs to
+-	// be mapped later
+-	private TLongHashSet osmIdStoreRequiredSet = new TLongHashSet();
+-	private TIntLongMap edgeIdToOsmIdMap;
+-	private final TLongList barrierNodeIds = new TLongArrayList();
+-	protected PillarInfo pillarInfo;
+-	private final DistanceCalc distCalc = new DistanceCalcEarth();
+-	private final DistanceCalc3D distCalc3D = new DistanceCalc3D();
+-	private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
+-	private boolean doSimplify = true;
+-	private int nextTowerId = 0;
+-	private int nextPillarId = 0;
+-	// negative but increasing to avoid clash with custom created OSM files
+-	private long newUniqueOsmId = -Long.MAX_VALUE;
+-	private ElevationProvider eleProvider = ElevationProvider.NOOP;
+-	private boolean exitOnlyPillarNodeException = true;
+-	private File routingFile;
+-
+-	public OsDpnReader(GraphStorage storage) {
+-		this.graphStorage = storage;
+-		this.nodeAccess = graphStorage.getNodeAccess();
+-
+-		osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
+-		osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
+-		osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
+-		pillarInfo = new PillarInfo(nodeAccess.is3D(),
+-				graphStorage.getDirectory());
+-	}
+-
+-	@Override
+-	public void readGraph() throws IOException {
+-		if (encodingManager == null)
+-			throw new IllegalStateException("Encoding manager was not set.");
++public class OsDpnReader implements DataReader<String> {
++    private InputStream is;
+ 
+-		if (routingFile == null)
+-			throw new IllegalStateException("No OS ITN file specified");
++    protected static final int EMPTY = -1;
++    // pillar node is >= 3
++    protected static final int PILLAR_NODE = 1;
++    // tower node is <= -3
++    protected static final int TOWER_NODE = -2;
++    private static final Logger logger = LoggerFactory
++            .getLogger(OsDpnReader.class);
++    private long locations;
++    private long skippedLocations;
++    private final GraphStorage graphStorage;
++    private final NodeAccess nodeAccess;
++    private EncodingManager encodingManager = null;
++    private int workerThreads = -1;
++    protected long zeroCounter = 0;
++    // Using the correct Map<Long, Integer> is hard. We need a memory efficient
++    // and fast solution for big data sets!
++    //
++    // very slow: new SparseLongLongArray
++    // only append and update possible (no unordered storage like with this
++    // doubleParse): new OSMIDMap
++    // same here: not applicable as ways introduces the nodes in 'wrong' order:
++    // new OSMIDSegmentedMap
++    // memory overhead due to open addressing and full rehash:
++    // nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
++    // smaller memory overhead for bigger data sets because of avoiding a
++    // "rehash"
++    // remember how many times a node was used to identify tower nodes
++    private TObjectIntMap<String> osmNodeIdToInternalNodeMap;
++    private TObjectLongMap<String> osmNodeIdToNodeFlagsMap;
++    private TObjectLongHashMap<String> osmWayIdToRouteWeightMap;
++    // stores osm way ids used by relations to identify which edge ids needs to
++    // be mapped later
++    private THashSet<String> osmIdStoreRequiredSet = new THashSet<String>();
++    private TLongObjectMap<String> edgeIdToOsmIdMap;
++    protected PillarInfo pillarInfo;
++    private final DistanceCalc distCalc = new DistanceCalcEarth();
++    private final DistanceCalc3D distCalc3D = new DistanceCalc3D();
++    private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
++    private boolean doSimplify = true;
++    private int nextTowerId = 0;
++    private int nextPillarId = 0;
++    // negative but increasing to avoid clash with custom created OSM files
++    private long newUniqueOsmId = -Long.MAX_VALUE;
++    private ElevationProvider eleProvider = ElevationProvider.NOOP;
++    private final boolean exitOnlyPillarNodeException = true;
++    private File routingFile;
+ 
+-		if (!routingFile.exists())
+-			throw new IllegalStateException(
+-					"Your specified OS ITN file does not exist:"
+-							+ routingFile.getAbsolutePath());
++    public OsDpnReader(GraphStorage storage) {
++        this.graphStorage = storage;
++        this.nodeAccess = graphStorage.getNodeAccess();
+ 
+-		StopWatch sw1 = new StopWatch().start();
+-		preProcess(routingFile);
+-		sw1.stop();
++        osmNodeIdToInternalNodeMap = new TObjectIntHashMap<String>(200, .5f, -1);
++        osmNodeIdToNodeFlagsMap = new TObjectLongHashMap<String>(200, .5f, 0);
++        osmWayIdToRouteWeightMap = new TObjectLongHashMap<String>(200, .5f, 0);
++        pillarInfo = new PillarInfo(nodeAccess.is3D(),
++                graphStorage.getDirectory());
++    }
+ 
+-		StopWatch sw2 = new StopWatch().start();
+-		writeOsm2Graph(routingFile);
+-		sw2.stop();
++    @Override
++    public void readGraph() throws IOException {
++        if (encodingManager == null)
++            throw new IllegalStateException("Encoding manager was not set.");
+ 
+-		logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: "
+-				+ (int) sw2.getSeconds() + " total:"
+-				+ ((int) (sw1.getSeconds() + sw2.getSeconds())));
+-	}
++        if (routingFile == null)
++            throw new IllegalStateException("No OS DPN file specified");
+ 
+-	/**
+-	 * Preprocessing of OSM file to select nodes which are used for highways.
+-	 * This allows a more compact graph data structure.
+-	 */
+-	void preProcess(File osmFile) {
+-		OsItnInputFile in = null;
+-		try {
+-			in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
+-					.open();
++        if (!routingFile.exists())
++            throw new IllegalStateException(
++                    "Your specified OS DPN file does not exist:"
++                            + routingFile.getAbsolutePath());
+ 
+-			long tmpWayCounter = 1;
+-			long tmpRelationCounter = 1;
+-			RoutingElement item;
+-			while ((item = in.getNext()) != null) {
+-				System.out.println("OsItnReader.preProcess( " + item.getType()
+-						+ " )");
+-				if (item.isType(OSMElement.WAY)) {
+-					final OSITNWay way = (OSITNWay) item;
+-					boolean valid = filterWay(way);
+-					if (valid) {
+-						TLongList wayNodes = way.getNodes();
+-						int s = wayNodes.size();
+-						for (int index = 0; index < s; index++) {
+-							prepareHighwayNode(wayNodes.get(index));
+-						}
++        StopWatch sw1 = new StopWatch().start();
++        preProcess(routingFile);
++        sw1.stop();
+ 
+-						if (++tmpWayCounter % 500000 == 0) {
+-							logger.info(nf(tmpWayCounter)
+-									+ " (preprocess), osmIdMap:"
+-									+ nf(getNodeMap().getSize()) + " ("
+-									+ getNodeMap().getMemoryUsage() + "MB) "
+-									+ Helper.getMemInfo());
+-						}
+-					}
+-				}
+-				if (item.isType(OSMElement.RELATION)) {
+-					final OSMRelation relation = (OSMRelation) item;
+-					if (!relation.isMetaRelation()
+-							&& relation.hasTag("type", "route"))
+-						prepareWaysWithRelationInfo(relation);
++        StopWatch sw2 = new StopWatch().start();
++        writeOsm2Graph(routingFile);
++        sw2.stop();
+ 
+-					if (relation.hasTag("type", "restriction"))
+-						prepareRestrictionRelation(relation);
++        logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: "
++                + (int) sw2.getSeconds() + " total:"
++                + ((int) (sw1.getSeconds() + sw2.getSeconds())));
++    }
+ 
+-					if (++tmpRelationCounter % 50000 == 0) {
+-						logger.info(nf(tmpRelationCounter)
+-								+ " (preprocess), osmWayMap:"
+-								+ nf(getRelFlagsMap().size()) + " "
+-								+ Helper.getMemInfo());
+-					}
++    /**
++     * Preprocessing of OSM file to select nodes which are used for highways.
++     * This allows a more compact graph data structure.
++     */
++    void preProcess(File osmFile) {
++        OsDpnInputFile in = null;
++        try {
++            in = new OsDpnInputFile(osmFile).setWorkerThreads(workerThreads)
++                    .open();
+ 
+-				}
+-			}
+-		} catch (Exception ex) {
+-			// throw new RuntimeException("Problem while parsing file", ex);
+-		} finally {
+-			Helper.close(in);
+-		}
+-	}
++            long tmpWayCounter = 1;
++            long tmpRelationCounter = 1;
++            RoutingElement item;
++            while ((item = in.getNext()) != null) {
++                System.out.println("OsItnReader.preProcess( " + item.getType()
++                        + " )");
++                if (item.isType(OSMElement.WAY)) {
++                    final OsDpnWay way = (OsDpnWay) item;
++                    boolean valid = filterWay(way);
++                    if (valid) {
++                        List<String> wayNodes = way.getNodes();
++                        int s = wayNodes.size();
++                        for (int index = 0; index < s; index++) {
++                            prepareHighwayNode(wayNodes.get(index));
++                        }
+ 
+-	private void prepareRestrictionRelation(OSMRelation relation) {
+-		TurnRelation turnRelation = createTurnRelation(relation);
+-		if (turnRelation != null) {
+-			getOsmIdStoreRequiredSet().add(
+-					((TurnRelation) turnRelation).getOsmIdFrom());
+-			getOsmIdStoreRequiredSet().add(
+-					((TurnRelation) turnRelation).getOsmIdTo());
+-		}
+-	}
++                        if (++tmpWayCounter % 500000 == 0) {
++                            logger.info(nf(tmpWayCounter)
++                                    + " (preprocess), osmIdMap:"
++                                    + nf(getNodeMap().size())
++                                    + Helper.getMemInfo());
++                        }
++                    }
++                }
++                // if (item.isType(OSMElement.RELATION)) {
++                // final OSMRelation relation = (OSMRelation) item;
++                // if (!relation.isMetaRelation()
++                // && relation.hasTag("type", "route"))
++                // prepareWaysWithRelationInfo(relation);
++                //
++                // if (relation.hasTag("type", "restriction"))
++                // prepareRestrictionRelation(relation);
++                //
++                // if (++tmpRelationCounter % 50000 == 0) {
++                // logger.info(nf(tmpRelationCounter)
++                // + " (preprocess), osmWayMap:"
++                // + nf(getRelFlagsMap().size()) + " "
++                // + Helper.getMemInfo());
++                // }
++                //
++                // }
++            }
++        } catch (Exception ex) {
++            throw new RuntimeException("Problem while parsing file", ex);
++        } finally {
++            Helper.close(in);
++        }
++    }
+ 
+-	private TLongSet getOsmIdStoreRequiredSet() {
+-		return osmIdStoreRequiredSet;
+-	}
++    /*
++     * private void prepareRestrictionRelation(OSMRelation relation) {
++     * TurnRelation turnRelation = createTurnRelation(relation); if
++     * (turnRelation != null) {
++     * getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdFrom());
++     * getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdTo()); } }
++     */
+ 
+-	private TIntLongMap getEdgeIdToOsmidMap() {
+-		if (edgeIdToOsmIdMap == null)
+-			edgeIdToOsmIdMap = new TIntLongHashMap(getOsmIdStoreRequiredSet()
+-					.size());
++    private THashSet<String> getOsmIdStoreRequiredSet() {
++        return osmIdStoreRequiredSet;
++    }
+ 
+-		return edgeIdToOsmIdMap;
+-	}
++    private TLongObjectMap<String> getEdgeIdToOsmidMap() {
++        if (edgeIdToOsmIdMap == null)
++            edgeIdToOsmIdMap = new TLongObjectHashMap<String>(
++                    getOsmIdStoreRequiredSet().size());
+ 
+-	/**
+-	 * Filter ways but do not analyze properties wayNodes will be filled with
+-	 * participating node ids.
+-	 * <p/>
+-	 * 
+-	 * @return true the current xml entry is a way entry and has nodes
+-	 */
+-	boolean filterWay(OSITNWay way) {
+-		// ignore broken geometry
+-		if (way.getNodes().size() < 2)
+-			return false;
++        return edgeIdToOsmIdMap;
++    }
+ 
+-		// ignore multipolygon geometry
+-		if (!way.hasTags())
+-			return false;
++    /**
++     * Filter ways but do not analyze properties wayNodes will be filled with
++     * participating node ids.
++     * <p/>
++     * 
++     * @return true the current xml entry is a way entry and has nodes
++     */
++    boolean filterWay(OsDpnWay way) {
++        // ignore broken geometry
++        if (way.getNodes().size() < 2)
++            return false;
+ 
+-		return encodingManager.acceptWay(way) > 0;
+-	}
++        // ignore multipolygon geometry
++        if (!way.hasTags())
++            return false;
+ 
+-	/**
+-	 * Creates the edges and nodes files from the specified osm file.
+-	 */
+-	private void writeOsm2Graph(File osmFile) {
+-		int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
+-		logger.info("creating graph. Found nodes (pillar+tower):"
+-				+ nf(getNodeMap().getSize()) + ", " + Helper.getMemInfo());
+-		graphStorage.create(tmp);
+-		long wayStart = -1;
+-		long relationStart = -1;
+-		long counter = 1;
+-		OsItnInputFile in = null;
+-		try {
+-			in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
+-					.open();
+-			LongIntMap nodeFilter = getNodeMap();
++        return encodingManager.acceptWay(way) > 0;
++    }
+ 
+-			RoutingElement item;
+-			while ((item = in.getNext()) != null) {
+-				switch (item.getType()) {
+-				case OSMElement.NODE:
+-					logger.info("NODEITEMID:" + item.getId());
+-					if (nodeFilter.get(item.getId()) != -1) {
+-						processNode((Node) item);
+-					}
+-					break;
++    /**
++     * Creates the edges and nodes files from the specified osm file.
++     */
++    private void writeOsm2Graph(File osmFile) {
++        int tmp = Math.max(getNodeMap().size() / 50, 100);
++        logger.info("creating graph. Found nodes (pillar+tower):"
++                + nf(getNodeMap().size()) + ", " + Helper.getMemInfo());
++        graphStorage.create(tmp);
++        long wayStart = -1;
++        long relationStart = -1;
++        long counter = 1;
++        OsDpnInputFile in = null;
++        try {
++            in = new OsDpnInputFile(osmFile).setWorkerThreads(workerThreads)
++                    .open();
++            TObjectIntMap<String> nodeFilter = getNodeMap();
+ 
+-				case OSMElement.WAY:
+-					logger.info("WAY:" + item.getId() + ":" + wayStart);
+-					if (wayStart < 0) {
+-						logger.info(nf(counter) + ", now parsing ways");
+-						wayStart = counter;
+-					}
+-					processWay((Way) item);
+-					break;
+-				case OSMElement.RELATION:
+-					if (relationStart < 0) {
+-						logger.info(nf(counter) + ", now parsing relations");
+-						relationStart = counter;
+-					}
+-					processRelation((Relation) item);
+-					break;
+-				}
+-				if (++counter % 5000000 == 0) {
+-					logger.info(nf(counter) + ", locs:" + nf(locations) + " ("
+-							+ skippedLocations + ") " + Helper.getMemInfo());
+-				}
+-			}
++            RoutingElement item;
++            while ((item = in.getNext()) != null) {
++                switch (item.getType()) {
++                    case OSMElement.NODE:
++                        OsDpnNode dpnNode = (OsDpnNode) item;
++                        String id = dpnNode.getId();
++                        logger.info("NODEITEMID:" + id);
++                        if (nodeFilter.get(id) != -1) {
++                            processNode(dpnNode);
++                        }
++                        break;
+ 
+-			// logger.info("storage nodes:" + graphStorage.getNodes());
+-		} catch (Exception ex) {
+-//			throw new RuntimeException("Couldn't process file " + osmFile, ex);
+-		} finally {
+-			Helper.close(in);
+-		}
++                    case OSMElement.WAY:
++                        OsDpnWay dpnWay = (OsDpnWay) item;
++                        logger.info("WAY:" + dpnWay.getId() + ":" + wayStart);
++                        if (wayStart < 0) {
++                            logger.info(nf(counter) + ", now parsing ways");
++                            wayStart = counter;
++                        }
++                        processWay(dpnWay);
++                        break;
++                    case OSMElement.RELATION:
++                        if (relationStart < 0) {
++                            logger.info(nf(counter) + ", now parsing relations");
++                            relationStart = counter;
++                        }
++                        processRelation((Relation) item);
++                        break;
++                }
++                if (++counter % 5000000 == 0) {
++                    logger.info(nf(counter) + ", locs:" + nf(locations) + " ("
++                            + skippedLocations + ") " + Helper.getMemInfo());
++                }
++            }
+ 
+-		finishedReading();
+-		if (graphStorage.getNodes() == 0)
+-			throw new IllegalStateException("osm must not be empty. read "
+-					+ counter + " lines and " + locations + " locations");
+-	}
++            // logger.info("storage nodes:" + graphStorage.getNodes());
++        } catch (Exception ex) {
++            System.out.println(ex.getClass());
++            // throw new RuntimeException("Couldn't process file " + osmFile,
++            // ex);
++        } finally {
++            Helper.close(in);
++        }
+ 
+-	/**
+-	 * Process properties, encode flags and create edges for the way.
+-	 */
+-	void processWay(Way way) {
+-		if (way.getNodes().size() < 2)
+-			return;
++        finishedReading();
++        if (graphStorage.getNodes() == 0)
++            throw new IllegalStateException("osm must not be empty. read "
++                    + counter + " lines and " + locations + " locations");
++    }
+ 
+-		// ignore multipolygon geometry
+-		if (!way.hasTags())
+-			return;
++    /**
++     * Process properties, encode flags and create edges for the way.
++     */
++    void processWay(OsDpnWay way) {
++        if (way.getNodes().size() < 2)
++            return;
+ 
+-		long wayOsmId = way.getId();
++        // ignore multipolygon geometry
++        if (!way.hasTags())
++            return;
+ 
+-		long includeWay = encodingManager.acceptWay(way);
+-		if (includeWay == 0)
+-			return;
++        String wayOsmId = way.getId();
+ 
+-		long relationFlags = getRelFlagsMap().get(way.getId());
++        long includeWay = encodingManager.acceptWay(way);
++        if (includeWay == 0)
++            return;
+ 
+-		// TODO move this after we have created the edge and know the
+-		// coordinates => encodingManager.applyWayTags
+-		// estimate length of the track e.g. for ferry speed calculation
+-		TLongList osmNodeIds = way.getNodes();
+-		if (osmNodeIds.size() > 1) {
+-			int first = getNodeMap().get(osmNodeIds.get(0));
+-			int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+-			double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+-			double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+-			if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon)
+-					&& !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
+-				double estimatedDist = distCalc.calcDist(firstLat, firstLon,
+-						lastLat, lastLon);
+-				way.setTag("estimated_distance", estimatedDist);
+-				way.setTag("estimated_center", new GHPoint(
+-						(firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
+-			}
+-		}
++        long relationFlags = getRelFlagsMap().get(way.getId());
+ 
+-		long wayFlags = encodingManager.handleWayTags(way, includeWay,
+-				relationFlags);
+-		if (wayFlags == 0)
+-			return;
++        // TODO move this after we have created the edge and know the
++        // coordinates => encodingManager.applyWayTags
++        // estimate length of the track e.g. for ferry speed calculation
++        List<String> osmNodeIds = way.getNodes();
++        if (osmNodeIds.size() > 1) {
++            int first = getNodeMap().get(osmNodeIds.get(0));
++            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
++            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
++            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
++            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon)
++                    && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
++                double estimatedDist = distCalc.calcDist(firstLat, firstLon,
++                        lastLat, lastLon);
++                way.setTag("estimated_distance", estimatedDist);
++                way.setTag("estimated_center", new GHPoint(
++                        (firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
++            }
++        }
+ 
+-		List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
+-		// look for barriers along the way
+-		final int size = osmNodeIds.size();
+-		int lastBarrier = -1;
+-		for (int i = 0; i < size; i++) {
+-			long nodeId = osmNodeIds.get(i);
+-			long nodeFlags = getNodeFlagsMap().get(nodeId);
+-			// barrier was spotted and way is otherwise passable for that mode
+-			// of travel
+-			if (nodeFlags > 0) {
+-				if ((nodeFlags & wayFlags) > 0) {
+-					// remove barrier to avoid duplicates
+-					getNodeFlagsMap().put(nodeId, 0);
++        long wayFlags = encodingManager.handleWayTags(way, includeWay,
++                relationFlags);
++        if (wayFlags == 0)
++            return;
+ 
+-					// create shadow node copy for zero length edge
+-					long newNodeId = addBarrierNode(nodeId);
+-					if (i > 0) {
+-						// start at beginning of array if there was no previous
+-						// barrier
+-						if (lastBarrier < 0)
+-							lastBarrier = 0;
++        List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
++        // look for barriers along the way
++        final int size = osmNodeIds.size();
++        int lastBarrier = -1;
++        for (int i = 0; i < size; i++) {
++            String nodeId = osmNodeIds.get(i);
++            long nodeFlags = getNodeFlagsMap().get(nodeId);
++            // barrier was spotted and way is otherwise passable for that mode
++            // of travel
++            if (nodeFlags > 0) {
++                if ((nodeFlags & wayFlags) > 0) {
++                    // remove barrier to avoid duplicates
++                    getNodeFlagsMap().put(nodeId, 0);
+ 
+-						// add way up to barrier shadow node
+-						long transfer[] = osmNodeIds.toArray(lastBarrier, i
+-								- lastBarrier + 1);
+-						transfer[transfer.length - 1] = newNodeId;
+-						TLongList partIds = new TLongArrayList(transfer);
+-						createdEdges.addAll(addOSMWay(partIds, wayFlags,
+-								wayOsmId));
++                    // create shadow node copy for zero length edge
++                    String newNodeId = addBarrierNode(nodeId);
++                    if (i > 0) {
++                        // start at beginning of array if there was no previous
++                        // barrier
++                        if (lastBarrier < 0)
++                            lastBarrier = 0;
+ 
+-						// create zero length edge for barrier
+-						createdEdges.addAll(addBarrierEdge(newNodeId, nodeId,
+-								wayFlags, nodeFlags, wayOsmId));
+-					} else {
+-						// run edge from real first node to shadow node
+-						createdEdges.addAll(addBarrierEdge(nodeId, newNodeId,
+-								wayFlags, nodeFlags, wayOsmId));
++                        // add way up to barrier shadow node
++                        String transfer[] = { "" };
++                        transfer = osmNodeIds.subList(lastBarrier,
++                                i - lastBarrier + 1).toArray(transfer);
++                        transfer[transfer.length - 1] = newNodeId;
++                        createdEdges.addAll(addOSMWay(transfer, wayFlags,
++                                wayOsmId));
+ 
+-						// exchange first node for created barrier node
+-						osmNodeIds.set(0, newNodeId);
+-					}
+-					// remember barrier for processing the way behind it
+-					lastBarrier = i;
+-				}
+-			}
+-		}
++                        // create zero length edge for barrier
++                        createdEdges.addAll(addBarrierEdge(newNodeId, nodeId,
++                                wayFlags, nodeFlags, wayOsmId));
++                    } else {
++                        // run edge from real first node to shadow node
++                        createdEdges.addAll(addBarrierEdge(nodeId, newNodeId,
++                                wayFlags, nodeFlags, wayOsmId));
+ 
+-		// just add remainder of way to graph if barrier was not the last node
+-		if (lastBarrier >= 0) {
+-			if (lastBarrier < size - 1) {
+-				long transfer[] = osmNodeIds.toArray(lastBarrier, size
+-						- lastBarrier);
+-				TLongList partNodeIds = new TLongArrayList(transfer);
+-				createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
+-			}
+-		} else {
+-			// no barriers - simply add the whole way
+-			createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
+-		}
++                        // exchange first node for created barrier node
++                        osmNodeIds.set(0, newNodeId);
++                    }
++                    // remember barrier for processing the way behind it
++                    lastBarrier = i;
++                }
++            }
++        }
+ 
+-		for (EdgeIteratorState edge : createdEdges) {
+-			encodingManager.applyWayTags(way, edge);
+-		}
+-	}
++        // just add remainder of way to graph if barrier was not the last node
++        if (lastBarrier >= 0) {
++            if (lastBarrier < size - 1) {
++                String transfer[] = { "" };
++                transfer = osmNodeIds.subList(lastBarrier, size - lastBarrier)
++                        .toArray(transfer);
++                createdEdges.addAll(addOSMWay(transfer, wayFlags, wayOsmId));
++            }
++        } else {
++            // no barriers - simply add the whole way
++            String transfer[] = { "" };
++            transfer = way.getNodes().toArray(transfer);
++            createdEdges.addAll(addOSMWay(transfer, wayFlags, wayOsmId));
++        }
+ 
+-	public void processRelation(Relation relation) throws XMLStreamException {
+-//		if (relation.hasTag("type", "restriction")) {
+-//			TurnRelation turnRelation = createTurnRelation(relation);
+-//			if (turnRelation != null) {
+-//				ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
+-//						.getExtendedStorage();
+-//				if (extendedStorage instanceof TurnCostStorage) {
+-//					Collection<ITurnCostTableEntry> entries = encodingManager
+-//							.analyzeTurnRelation(turnRelation, this);
+-//					for (ITurnCostTableEntry entry : entries) {
+-//						((TurnCostStorage) extendedStorage).setTurnCosts(
+-//								entry.nodeVia, entry.edgeFrom, entry.edgeTo,
+-//								(int) entry.flags);
+-//					}
+-//				}
+-//			}
+-//		}
+-	}
++        for (EdgeIteratorState edge : createdEdges) {
++            encodingManager.applyWayTags(way, edge);
++        }
++    }
+ 
+-	public long getOsmIdOfInternalEdge(int edgeId) {
+-		return getEdgeIdToOsmidMap().get(edgeId);
+-	}
++    public void processRelation(Relation relation) throws XMLStreamException {
++        // if (relation.hasTag("type", "restriction")) {
++        // TurnRelation turnRelation = createTurnRelation(relation);
++        // if (turnRelation != null) {
++        // ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
++        // .getExtendedStorage();
++        // if (extendedStorage instanceof TurnCostStorage) {
++        // Collection<ITurnCostTableEntry> entries = encodingManager
++        // .analyzeTurnRelation(turnRelation, this);
++        // for (ITurnCostTableEntry entry : entries) {
++        // ((TurnCostStorage) extendedStorage).setTurnCosts(
++        // entry.nodeVia, entry.edgeFrom, entry.edgeTo,
++        // (int) entry.flags);
++        // }
++        // }
++        // }
++        // }
++    }
+ 
+-	public int getInternalNodeIdOfOsmNode(long nodeOsmId) {
+-		int id = getNodeMap().get(nodeOsmId);
+-		if (id < TOWER_NODE)
+-			return -id - 3;
++    @Override
++    public String getOsmIdOfInternalEdge(int edgeId) {
++        return getEdgeIdToOsmidMap().get(edgeId);
++    }
+ 
+-		return EMPTY;
+-	}
++    @Override
++    public int getInternalNodeIdOfOsmNode(String nodeOsmId) {
++        int id = getNodeMap().get(nodeOsmId);
++        if (id < TOWER_NODE)
++            return -id - 3;
+ 
+-	// TODO remove this ugly stuff via better preparsing phase! E.g. putting
+-	// every tags etc into a helper file!
+-	double getTmpLatitude(int id) {
+-		if (id == EMPTY)
+-			return Double.NaN;
+-		if (id < TOWER_NODE) {
+-			// tower node
+-			id = -id - 3;
+-			return nodeAccess.getLatitude(id);
+-		} else if (id > -TOWER_NODE) {
+-			// pillar node
+-			id = id - 3;
+-			return pillarInfo.getLatitude(id);
+-		} else
+-			// e.g. if id is not handled from preparse (e.g. was ignored via
+-			// isInBounds)
+-			return Double.NaN;
+-	}
++        return EMPTY;
++    }
+ 
+-	double getTmpLongitude(int id) {
+-		if (id == EMPTY)
+-			return Double.NaN;
+-		if (id < TOWER_NODE) {
+-			// tower node
+-			id = -id - 3;
+-			return nodeAccess.getLongitude(id);
+-		} else if (id > -TOWER_NODE) {
+-			// pillar node
+-			id = id - 3;
+-			return pillarInfo.getLon(id);
+-		} else
+-			// e.g. if id is not handled from preparse (e.g. was ignored via
+-			// isInBounds)
+-			return Double.NaN;
+-	}
++    // TODO remove this ugly stuff via better preparsing phase! E.g. putting
++    // every tags etc into a helper file!
++    double getTmpLatitude(int id) {
++        if (id == EMPTY)
++            return Double.NaN;
++        if (id < TOWER_NODE) {
++            // tower node
++            id = -id - 3;
++            return nodeAccess.getLatitude(id);
++        } else if (id > -TOWER_NODE) {
++            // pillar node
++            id = id - 3;
++            return pillarInfo.getLatitude(id);
++        } else
++            // e.g. if id is not handled from preparse (e.g. was ignored via
++            // isInBounds)
++            return Double.NaN;
++    }
+ 
+-	private void processNode(Node node) {
+-		if (isInBounds(node)) {
+-			addNode(node);
++    double getTmpLongitude(int id) {
++        if (id == EMPTY)
++            return Double.NaN;
++        if (id < TOWER_NODE) {
++            // tower node
++            id = -id - 3;
++            return nodeAccess.getLongitude(id);
++        } else if (id > -TOWER_NODE) {
++            // pillar node
++            id = id - 3;
++            return pillarInfo.getLon(id);
++        } else
++            // e.g. if id is not handled from preparse (e.g. was ignored via
++            // isInBounds)
++            return Double.NaN;
++    }
+ 
+-			// analyze node tags for barriers
+-			if (node.hasTags()) {
+-				long nodeFlags = encodingManager.handleNodeTags(node);
+-				if (nodeFlags != 0)
+-					getNodeFlagsMap().put(node.getId(), nodeFlags);
+-			}
++    private void processNode(OsDpnNode node) {
++        if (isInBounds(node)) {
++            addNode(node);
+ 
+-			locations++;
+-		} else {
+-			skippedLocations++;
+-		}
+-	}
++            // analyze node tags for barriers
++            if (node.hasTags()) {
++                long nodeFlags = encodingManager.handleNodeTags(node);
++                if (nodeFlags != 0)
++                    getNodeFlagsMap().put(node.getId(), nodeFlags);
++            }
+ 
+-	boolean addNode(Node node) {
+-		int nodeType = getNodeMap().get(node.getId());
+-		if (nodeType == EMPTY)
+-			return false;
++            locations++;
++        } else {
++            skippedLocations++;
++        }
++    }
+ 
+-		double lat = node.getLat();
+-		double lon = node.getLon();
+-		double ele = getElevation(node);
+-		if (nodeType == TOWER_NODE) {
+-			addTowerNode(node.getId(), lat, lon, ele);
+-		} else if (nodeType == PILLAR_NODE) {
+-			pillarInfo.setNode(nextPillarId, lat, lon, ele);
+-			getNodeMap().put(node.getId(), nextPillarId + 3);
+-			nextPillarId++;
+-		}
+-		return true;
+-	}
++    boolean addNode(OsDpnNode node) {
++        int nodeType = getNodeMap().get(node.getId());
++        if (nodeType == EMPTY)
++            return false;
+ 
+-	private double getElevation(Node node) {
+-		return eleProvider.getEle(node.getLat(), node.getLon());
+-	}
++        double lat = node.getLat();
++        double lon = node.getLon();
++        double ele = getElevation(node);
++        if (nodeType == TOWER_NODE) {
++            addTowerNode(node.getId(), lat, lon, ele);
++        } else if (nodeType == PILLAR_NODE) {
++            pillarInfo.setNode(nextPillarId, lat, lon, ele);
++            getNodeMap().put(node.getId(), nextPillarId + 3);
++            nextPillarId++;
++        }
++        return true;
++    }
+ 
+-	void prepareWaysWithRelationInfo(OSMRelation osmRelation) {
+-		// is there at least one tag interesting for the registed encoders?
+-		if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
+-			return;
++    private double getElevation(Node node) {
++        return eleProvider.getEle(node.getLat(), node.getLon());
++    }
+ 
+-		int size = osmRelation.getMembers().size();
+-		for (int index = 0; index < size; index++) {
+-			OSMRelation.Member member = osmRelation.getMembers().get(index);
+-			if (member.type() != OSMRelation.Member.WAY)
+-				continue;
++    /*
++     * void prepareWaysWithRelationInfo(OSMRelation osmRelation) { // is there
++     * at least one tag interesting for the registed encoders? if
++     * (encodingManager.handleRelationTags(osmRelation, 0) == 0) return;
++     * 
++     * int size = osmRelation.getMembers().size(); for (int index = 0; index <
++     * size; index++) { OSMRelation.Member member =
++     * osmRelation.getMembers().get(index); if (member.type() !=
++     * OSMRelation.Member.WAY) continue;
++     * 
++     * long osmId = member.ref(); long oldRelationFlags =
++     * getRelFlagsMap().get(osmId);
++     * 
++     * // Check if our new relation data is better comparated to the the // last
++     * one long newRelationFlags = encodingManager.handleRelationTags(
++     * osmRelation, oldRelationFlags); if (oldRelationFlags != newRelationFlags)
++     * getRelFlagsMap().put(osmId, newRelationFlags); } }
++     */
+ 
+-			long osmId = member.ref();
+-			long oldRelationFlags = getRelFlagsMap().get(osmId);
++    void prepareHighwayNode(String idStr) {
++        int tmpIndex = getNodeMap().get(idStr);
++        if (tmpIndex == EMPTY) {
++            // osmId is used exactly once
++            logger.debug("OsDpnReader.prepareHighwayNode(EMPTY->PILLAR)");
++            getNodeMap().put(idStr, PILLAR_NODE);
++        } else if (tmpIndex > EMPTY) {
++            // mark node as tower node as it occured at least twice times
++            logger.debug("OsDpnReader.prepareHighwayNode(PILLAR->TOWER)");
++            getNodeMap().put(idStr, TOWER_NODE);
++        } else {
++            // tmpIndex is already negative (already tower node)
++        }
++    }
+ 
+-			// Check if our new relation data is better comparated to the the
+-			// last one
+-			long newRelationFlags = encodingManager.handleRelationTags(
+-					osmRelation, oldRelationFlags);
+-			if (oldRelationFlags != newRelationFlags)
+-				getRelFlagsMap().put(osmId, newRelationFlags);
+-		}
+-	}
++    int addTowerNode(String osmId, double lat, double lon, double ele) {
++        if (nodeAccess.is3D())
++            nodeAccess.setNode(nextTowerId, lat, lon, ele);
++        else
++            nodeAccess.setNode(nextTowerId, lat, lon);
+ 
+-	void prepareHighwayNode(long osmId) {
+-		int tmpIndex = getNodeMap().get(osmId);
+-		if (tmpIndex == EMPTY) {
+-			// osmId is used exactly once
+-			System.out.println("OsItnReader.prepareHighwayNode(EMPTY->PILLAR)");
+-			getNodeMap().put(osmId, PILLAR_NODE);
+-		} else if (tmpIndex > EMPTY) {
+-			// mark node as tower node as it occured at least twice times
+-			System.out.println("OsItnReader.prepareHighwayNode(PILLAR->TOWER)");
+-			getNodeMap().put(osmId, TOWER_NODE);
+-		} else {
+-			// tmpIndex is already negative (already tower node)
+-		}
+-	}
++        int id = -(nextTowerId + 3);
++        getNodeMap().put(osmId, id);
++        nextTowerId++;
++        return id;
++    }
+ 
+-	int addTowerNode(long osmId, double lat, double lon, double ele) {
+-		if (nodeAccess.is3D())
+-			nodeAccess.setNode(nextTowerId, lat, lon, ele);
+-		else
+-			nodeAccess.setNode(nextTowerId, lat, lon);
++    /**
++     * This method creates from an OSM way (via the osm ids) one or more edges
++     * in the graph.
++     */
++    Collection<EdgeIteratorState> addOSMWay(String[] osmNodeIds, long flags,
++            String wayOsmId) {
++        PointList pointList = new PointList(osmNodeIds.length,
++                nodeAccess.is3D());
++        List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
++        int firstNode = -1;
++        int lastIndex = osmNodeIds.length - 1;
++        int lastInBoundsPillarNode = -1;
++        try {
++            for (int i = 0; i < osmNodeIds.length; i++) {
++                String osmId = osmNodeIds[i];
++                int tmpNode = getNodeMap().get(osmId);
++                if (tmpNode == EMPTY)
++                    continue;
+ 
+-		int id = -(nextTowerId + 3);
+-		getNodeMap().put(osmId, id);
+-		nextTowerId++;
+-		return id;
+-	}
++                // skip osmIds with no associated pillar or tower id (e.g.
++                // !OSMReader.isBounds)
++                if (tmpNode == TOWER_NODE)
++                    continue;
+ 
+-	/**
+-	 * This method creates from an OSM way (via the osm ids) one or more edges
+-	 * in the graph.
+-	 */
+-	Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags,
+-			long wayOsmId) {
+-		PointList pointList = new PointList(osmNodeIds.size(),
+-				nodeAccess.is3D());
+-		List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
+-		int firstNode = -1;
+-		int lastIndex = osmNodeIds.size() - 1;
+-		int lastInBoundsPillarNode = -1;
+-		try {
+-			for (int i = 0; i < osmNodeIds.size(); i++) {
+-				long osmId = osmNodeIds.get(i);
+-				int tmpNode = getNodeMap().get(osmId);
+-				if (tmpNode == EMPTY)
+-					continue;
++                if (tmpNode == PILLAR_NODE) {
++                    // In some cases no node information is saved for the
++                    // specified osmId.
++                    // ie. a way references a <node> which does not exist in the
++                    // current file.
++                    // => if the node before was a pillar node then convert into
++                    // to tower node (as it is also end-standing).
++                    if (!pointList.isEmpty()
++                            && lastInBoundsPillarNode > -TOWER_NODE) {
++                        // transform the pillar node to a tower node
++                        tmpNode = lastInBoundsPillarNode;
++                        tmpNode = handlePillarNode(tmpNode, osmId, null, true);
++                        tmpNode = -tmpNode - 3;
++                        if (pointList.getSize() > 1 && firstNode >= 0) {
++                            // TOWER node
++                            newEdges.add(addEdge(firstNode, tmpNode, pointList,
++                                    flags, wayOsmId));
++                            pointList.clear();
++                            pointList.add(nodeAccess, tmpNode);
++                        }
++                        firstNode = tmpNode;
++                        lastInBoundsPillarNode = -1;
++                    }
++                    continue;
++                }
+ 
+-				// skip osmIds with no associated pillar or tower id (e.g.
+-				// !OSMReader.isBounds)
+-				if (tmpNode == TOWER_NODE)
+-					continue;
++                if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
++                    throw new AssertionError(
++                            "Mapped index not in correct bounds " + tmpNode
++                                    + ", " + osmId);
+ 
+-				if (tmpNode == PILLAR_NODE) {
+-					// In some cases no node information is saved for the
+-					// specified osmId.
+-					// ie. a way references a <node> which does not exist in the
+-					// current file.
+-					// => if the node before was a pillar node then convert into
+-					// to tower node (as it is also end-standing).
+-					if (!pointList.isEmpty()
+-							&& lastInBoundsPillarNode > -TOWER_NODE) {
+-						// transform the pillar node to a tower node
+-						tmpNode = lastInBoundsPillarNode;
+-						tmpNode = handlePillarNode(tmpNode, osmId, null, true);
+-						tmpNode = -tmpNode - 3;
+-						if (pointList.getSize() > 1 && firstNode >= 0) {
+-							// TOWER node
+-							newEdges.add(addEdge(firstNode, tmpNode, pointList,
+-									flags, wayOsmId));
+-							pointList.clear();
+-							pointList.add(nodeAccess, tmpNode);
+-						}
+-						firstNode = tmpNode;
+-						lastInBoundsPillarNode = -1;
+-					}
+-					continue;
+-				}
++                if (tmpNode > -TOWER_NODE) {
++                    boolean convertToTowerNode = i == 0 || i == lastIndex;
++                    if (!convertToTowerNode) {
++                        lastInBoundsPillarNode = tmpNode;
++                    }
+ 
+-				if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
+-					throw new AssertionError(
+-							"Mapped index not in correct bounds " + tmpNode
+-									+ ", " + osmId);
++                    // PILLAR node, but convert to towerNode if end-standing
++                    tmpNode = handlePillarNode(tmpNode, osmId, pointList,
++                            convertToTowerNode);
++                }
+ 
+-				if (tmpNode > -TOWER_NODE) {
+-					boolean convertToTowerNode = i == 0 || i == lastIndex;
+-					if (!convertToTowerNode) {
+-						lastInBoundsPillarNode = tmpNode;
+-					}
++                if (tmpNode < TOWER_NODE) {
++                    // TOWER node
++                    tmpNode = -tmpNode - 3;
++                    pointList.add(nodeAccess, tmpNode);
++                    if (firstNode >= 0) {
++                        newEdges.add(addEdge(firstNode, tmpNode, pointList,
++                                flags, wayOsmId));
++                        pointList.clear();
++                        pointList.add(nodeAccess, tmpNode);
++                    }
++                    firstNode = tmpNode;
++                }
++            }
++        } catch (RuntimeException ex) {
++            logger.error("Couldn't properly add edge with osm ids:"
++                    + osmNodeIds, ex);
++            if (exitOnlyPillarNodeException)
++                throw ex;
++        }
++        return newEdges;
++    }
+ 
+-					// PILLAR node, but convert to towerNode if end-standing
+-					tmpNode = handlePillarNode(tmpNode, osmId, pointList,
+-							convertToTowerNode);
+-				}
++    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
++            long flags, String wayOsmId) {
++        // sanity checks
++        if (fromIndex < 0 || toIndex < 0)
++            throw new AssertionError(
++                    "to or from index is invalid for this edge " + fromIndex
++                            + "->" + toIndex + ", points:" + pointList);
++        if (pointList.getDimension() != nodeAccess.getDimension())
++            throw new AssertionError(
++                    "Dimension does not match for pointList vs. nodeAccess "
++                            + pointList.getDimension() + " <-> "
++                            + nodeAccess.getDimension());
+ 
+-				if (tmpNode < TOWER_NODE) {
+-					// TOWER node
+-					tmpNode = -tmpNode - 3;
+-					pointList.add(nodeAccess, tmpNode);
+-					if (firstNode >= 0) {
+-						newEdges.add(addEdge(firstNode, tmpNode, pointList,
+-								flags, wayOsmId));
+-						pointList.clear();
+-						pointList.add(nodeAccess, tmpNode);
+-					}
+-					firstNode = tmpNode;
+-				}
+-			}
+-		} catch (RuntimeException ex) {
+-			logger.error("Couldn't properly add edge with osm ids:"
+-					+ osmNodeIds, ex);
+-			if (exitOnlyPillarNodeException)
+-				throw ex;
+-		}
+-		return newEdges;
+-	}
++        double towerNodeDistance = 0;
++        double prevLat = pointList.getLatitude(0);
++        double prevLon = pointList.getLongitude(0);
++        double prevEle = pointList.is3D() ? pointList.getElevation(0)
++                : Double.NaN;
++        double lat, lon, ele = Double.NaN;
++        PointList pillarNodes = new PointList(pointList.getSize() - 2,
++                nodeAccess.is3D());
++        int nodes = pointList.getSize();
++        for (int i = 1; i < nodes; i++) {
++            // we could save some lines if we would use
++            // pointList.calcDistance(distCalc);
++            lat = pointList.getLatitude(i);
++            lon = pointList.getLongitude(i);
++            if (pointList.is3D()) {
++                ele = pointList.getElevation(i);
++                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon,
++                        prevEle, lat, lon, ele);
++                prevEle = ele;
++            } else
++                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat,
++                        lon);
++            prevLat = lat;
++            prevLon = lon;
++            if (nodes > 2 && i < nodes - 1) {
++                if (pillarNodes.is3D())
++                    pillarNodes.add(lat, lon, ele);
++                else
++                    pillarNodes.add(lat, lon);
++            }
++        }
++        if (towerNodeDistance == 0) {
++            // As investigation shows often two paths should have crossed via
++            // one identical point
++            // but end up in two very release points.
++            zeroCounter++;
++            towerNodeDistance = 0.0001;
++        }
+ 
+-	EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
+-			long flags, long wayOsmId) {
+-		// sanity checks
+-		if (fromIndex < 0 || toIndex < 0)
+-			throw new AssertionError(
+-					"to or from index is invalid for this edge " + fromIndex
+-							+ "->" + toIndex + ", points:" + pointList);
+-		if (pointList.getDimension() != nodeAccess.getDimension())
+-			throw new AssertionError(
+-					"Dimension does not match for pointList vs. nodeAccess "
+-							+ pointList.getDimension() + " <-> "
+-							+ nodeAccess.getDimension());
++        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
++                .setDistance(towerNodeDistance).setFlags(flags);
++        if (nodes > 2) {
++            if (doSimplify)
++                simplifyAlgo.simplify(pillarNodes);
+ 
+-		double towerNodeDistance = 0;
+-		double prevLat = pointList.getLatitude(0);
+-		double prevLon = pointList.getLongitude(0);
+-		double prevEle = pointList.is3D() ? pointList.getElevation(0)
+-				: Double.NaN;
+-		double lat, lon, ele = Double.NaN;
+-		PointList pillarNodes = new PointList(pointList.getSize() - 2,
+-				nodeAccess.is3D());
+-		int nodes = pointList.getSize();
+-		for (int i = 1; i < nodes; i++) {
+-			// we could save some lines if we would use
+-			// pointList.calcDistance(distCalc);
+-			lat = pointList.getLatitude(i);
+-			lon = pointList.getLongitude(i);
+-			if (pointList.is3D()) {
+-				ele = pointList.getElevation(i);
+-				towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon,
+-						prevEle, lat, lon, ele);
+-				prevEle = ele;
+-			} else
+-				towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat,
+-						lon);
+-			prevLat = lat;
+-			prevLon = lon;
+-			if (nodes > 2 && i < nodes - 1) {
+-				if (pillarNodes.is3D())
+-					pillarNodes.add(lat, lon, ele);
+-				else
+-					pillarNodes.add(lat, lon);
+-			}
+-		}
+-		if (towerNodeDistance == 0) {
+-			// As investigation shows often two paths should have crossed via
+-			// one identical point
+-			// but end up in two very release points.
+-			zeroCounter++;
+-			towerNodeDistance = 0.0001;
+-		}
++            iter.setWayGeometry(pillarNodes);
++        }
++        storeOSMWayID(iter.getEdge(), wayOsmId);
++        return iter;
++    }
+ 
+-		EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
+-				.setDistance(towerNodeDistance).setFlags(flags);
+-		if (nodes > 2) {
+-			if (doSimplify)
+-				simplifyAlgo.simplify(pillarNodes);
++    private void storeOSMWayID(int edgeId, String osmWayID) {
++        if (getOsmIdStoreRequiredSet().contains(osmWayID)) {
++            getEdgeIdToOsmidMap().put(edgeId, osmWayID);
++        }
++    }
+ 
+-			iter.setWayGeometry(pillarNodes);
+-		}
+-		storeOSMWayID(iter.getEdge(), wayOsmId);
+-		return iter;
+-	}
++    /**
++     * @return converted tower node
++     */
++    private int handlePillarNode(int tmpNode, String osmId,
++            PointList pointList, boolean convertToTowerNode) {
++        logger.info("Converting Pillar " + osmId, " to pillar? "
++                + convertToTowerNode);
++        tmpNode = tmpNode - 3;
++        double lat = pillarInfo.getLatitude(tmpNode);
++        double lon = pillarInfo.getLongitude(tmpNode);
++        double ele = pillarInfo.getElevation(tmpNode);
++        if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
++            throw new RuntimeException(
++                    "Conversion pillarNode to towerNode already happended!? "
++                            + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+ 
+-	private void storeOSMWayID(int edgeId, long osmWayID) {
+-		if (getOsmIdStoreRequiredSet().contains(osmWayID)) {
+-			getEdgeIdToOsmidMap().put(edgeId, osmWayID);
+-		}
+-	}
++        if (convertToTowerNode) {
++            // convert pillarNode type to towerNode, make pillar values invalid
++            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE,
++                    Double.MAX_VALUE);
++            tmpNode = addTowerNode(osmId, lat, lon, ele);
++        } else {
++            if (pointList.is3D())
++                pointList.add(lat, lon, ele);
++            else
++                pointList.add(lat, lon);
++        }
+ 
+-	/**
+-	 * @return converted tower node
+-	 */
+-	private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
+-			boolean convertToTowerNode) {
+-		logger.info("Converting Pillar " + osmId, " to pillar? "
+-				+ convertToTowerNode);
+-		tmpNode = tmpNode - 3;
+-		double lat = pillarInfo.getLatitude(tmpNode);
+-		double lon = pillarInfo.getLongitude(tmpNode);
+-		double ele = pillarInfo.getElevation(tmpNode);
+-		if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
+-			throw new RuntimeException(
+-					"Conversion pillarNode to towerNode already happended!? "
+-							+ "osmId:" + osmId + " pillarIndex:" + tmpNode);
++        return tmpNode;
++    }
+ 
+-		if (convertToTowerNode) {
+-			// convert pillarNode type to towerNode, make pillar values invalid
+-			pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE,
+-					Double.MAX_VALUE);
+-			tmpNode = addTowerNode(osmId, lat, lon, ele);
+-		} else {
+-			if (pointList.is3D())
+-				pointList.add(lat, lon, ele);
+-			else
+-				pointList.add(lat, lon);
+-		}
++    protected void finishedReading() {
++        printInfo("way");
++        pillarInfo.clear();
++        eleProvider.release();
++        osmNodeIdToInternalNodeMap = null;
++        osmNodeIdToNodeFlagsMap = null;
++        osmWayIdToRouteWeightMap = null;
++        osmIdStoreRequiredSet = null;
++        edgeIdToOsmIdMap = null;
++    }
+ 
+-		return (int) tmpNode;
+-	}
++    /**
++     * Create a copy of the barrier node
++     */
++    String addBarrierNode(String nodeId) {
++        OsDpnNode newNode;
++        int graphIndex = getNodeMap().get(nodeId);
++        if (graphIndex < TOWER_NODE) {
++            graphIndex = -graphIndex - 3;
++            newNode = new OsDpnNode(createNewNodeId(), nodeAccess, graphIndex);
++        } else {
++            graphIndex = graphIndex - 3;
++            newNode = new OsDpnNode(createNewNodeId(), pillarInfo, graphIndex);
++        }
+ 
+-	protected void finishedReading() {
+-		printInfo("way");
+-		pillarInfo.clear();
+-		eleProvider.release();
+-		osmNodeIdToInternalNodeMap = null;
+-		osmNodeIdToNodeFlagsMap = null;
+-		osmWayIdToRouteWeightMap = null;
+-		osmIdStoreRequiredSet = null;
+-		edgeIdToOsmIdMap = null;
+-	}
++        final String id = newNode.getId();
++        prepareHighwayNode(id);
++        addNode(newNode);
++        return id;
++    }
+ 
+-	/**
+-	 * Create a copy of the barrier node
+-	 */
+-	long addBarrierNode(long nodeId) {
+-		OSMNode newNode;
+-		int graphIndex = getNodeMap().get(nodeId);
+-		if (graphIndex < TOWER_NODE) {
+-			graphIndex = -graphIndex - 3;
+-			newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
+-		} else {
+-			graphIndex = graphIndex - 3;
+-			newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
+-		}
++    private String createNewNodeId() {
++        return String.valueOf(newUniqueOsmId++);
++    }
+ 
+-		final long id = newNode.getId();
+-		prepareHighwayNode(id);
+-		addNode(newNode);
+-		return id;
+-	}
++    /**
++     * Add a zero length edge with reduced routing options to the graph.
++     */
++    Collection<EdgeIteratorState> addBarrierEdge(String fromId, String toId,
++            long flags, long nodeFlags, String wayOsmId) {
++        // clear barred directions from routing flags
++        flags &= ~nodeFlags;
++        // add edge
++        String barrierNodeIds[] = { fromId, toId };
++        return addOSMWay(barrierNodeIds, flags, wayOsmId);
++    }
+ 
+-	private long createNewNodeId() {
+-		return newUniqueOsmId++;
+-	}
++    /**
++     * Creates an OSM turn relation out of an unspecified OSM relation
++     * <p>
++     * 
++     * @return the OSM turn relation, <code>null</code>, if unsupported turn
++     *         relation
++     */
++    TurnRelation createTurnRelation(Relation relation) {
++        OSMTurnRelation.Type type = OSITNTurnRelation
++                .getRestrictionType(relation.getTag("restriction"));
++        if (type != OSMTurnRelation.Type.UNSUPPORTED) {
++            long fromWayID = -1;
++            long viaNodeID = -1;
++            long toWayID = -1;
+ 
+-	/**
+-	 * Add a zero length edge with reduced routing options to the graph.
+-	 */
+-	Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId,
+-			long flags, long nodeFlags, long wayOsmId) {
+-		// clear barred directions from routing flags
+-		flags &= ~nodeFlags;
+-		// add edge
+-		barrierNodeIds.clear();
+-		barrierNodeIds.add(fromId);
+-		barrierNodeIds.add(toId);
+-		return addOSMWay(barrierNodeIds, flags, wayOsmId);
+-	}
++            for (RelationMember member : relation.getMembers()) {
++                if (OSMElement.WAY == member.type()) {
++                    if ("from".equals(member.role())) {
++                        fromWayID = member.ref();
++                    } else if ("to".equals(member.role())) {
++                        toWayID = member.ref();
++                    }
++                } else if (OSMElement.NODE == member.type()
++                        && "via".equals(member.role())) {
++                    viaNodeID = member.ref();
++                }
++            }
++            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0
++                    && toWayID >= 0 && viaNodeID >= 0) {
++                return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
++            }
++        }
++        return null;
++    }
+ 
+-	/**
+-	 * Creates an OSM turn relation out of an unspecified OSM relation
+-	 * <p>
+-	 * 
+-	 * @return the OSM turn relation, <code>null</code>, if unsupported turn
+-	 *         relation
+-	 */
+-	TurnRelation createTurnRelation(Relation relation) {
+-		OSMTurnRelation.Type type = OSITNTurnRelation
+-				.getRestrictionType((String) relation.getTag("restriction"));
+-		if (type != OSMTurnRelation.Type.UNSUPPORTED) {
+-			long fromWayID = -1;
+-			long viaNodeID = -1;
+-			long toWayID = -1;
++    /**
++     * Filter method, override in subclass
++     */
++    boolean isInBounds(Node node) {
++        return true;
++    }
+ 
+-			for (RelationMember member : relation.getMembers()) {
+-				if (OSMElement.WAY == member.type()) {
+-					if ("from".equals(member.role())) {
+-						fromWayID = member.ref();
+-					} else if ("to".equals(member.role())) {
+-						toWayID = member.ref();
+-					}
+-				} else if (OSMElement.NODE == member.type()
+-						&& "via".equals(member.role())) {
+-					viaNodeID = member.ref();
+-				}
+-			}
+-			if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0
+-					&& toWayID >= 0 && viaNodeID >= 0) {
+-				return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
+-			}
+-		}
+-		return null;
+-	}
++    /**
++     * Maps OSM IDs (long) to internal node IDs (int)
++     */
++    protected TObjectIntMap<String> getNodeMap() {
++        return osmNodeIdToInternalNodeMap;
++    }
+ 
+-	/**
+-	 * Filter method, override in subclass
+-	 */
+-	boolean isInBounds(Node node) {
+-		return true;
+-	}
++    protected TObjectLongMap<String> getNodeFlagsMap() {
++        return osmNodeIdToNodeFlagsMap;
++    }
+ 
+-	/**
+-	 * Maps OSM IDs (long) to internal node IDs (int)
+-	 */
+-	protected LongIntMap getNodeMap() {
+-		return osmNodeIdToInternalNodeMap;
+-	}
++    TObjectLongHashMap<String> getRelFlagsMap() {
++        return osmWayIdToRouteWeightMap;
++    }
+ 
+-	protected TLongLongMap getNodeFlagsMap() {
+-		return osmNodeIdToNodeFlagsMap;
+-	}
++    /**
++     * Specify the type of the path calculation (car, bike, ...).
++     */
++    @Override
++    public OsDpnReader setEncodingManager(EncodingManager acceptWay) {
++        this.encodingManager = acceptWay;
++        return this;
++    }
+ 
+-	TLongLongHashMap getRelFlagsMap() {
+-		return osmWayIdToRouteWeightMap;
+-	}
++    @Override
++    public OsDpnReader setWayPointMaxDistance(double maxDist) {
++        doSimplify = maxDist > 0;
++        simplifyAlgo.setMaxDistance(maxDist);
++        return this;
++    }
+ 
+-	/**
+-	 * Specify the type of the path calculation (car, bike, ...).
+-	 */
+-	public OsDpnReader setEncodingManager(EncodingManager acceptWay) {
+-		this.encodingManager = acceptWay;
+-		return this;
+-	}
++    @Override
++    public OsDpnReader setWorkerThreads(int numOfWorkers) {
++        this.workerThreads = numOfWorkers;
++        return this;
++    }
+ 
+-	public OsDpnReader setWayPointMaxDistance(double maxDist) {
+-		doSimplify = maxDist > 0;
+-		simplifyAlgo.setMaxDistance(maxDist);
+-		return this;
+-	}
++    @Override
++    public OsDpnReader setElevationProvider(ElevationProvider eleProvider) {
++        if (eleProvider == null)
++            throw new IllegalStateException(
++                    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+ 
+-	public OsDpnReader setWorkerThreads(int numOfWorkers) {
+-		this.workerThreads = numOfWorkers;
+-		return this;
+-	}
++        if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
++            throw new IllegalStateException(
++                    "Make sure you graph accepts 3D data");
+ 
+-	public OsDpnReader setElevationProvider(ElevationProvider eleProvider) {
+-		if (eleProvider == null)
+-			throw new IllegalStateException(
+-					"Use the NOOP elevation provider instead of null or don't call setElevationProvider");
++        this.eleProvider = eleProvider;
++        return this;
++    }
+ 
+-		if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
+-			throw new IllegalStateException(
+-					"Make sure you graph accepts 3D data");
++    @Override
++    public OsDpnReader setOSMFile(File osmFile) {
++        this.routingFile = osmFile;
++        return this;
++    }
+ 
+-		this.eleProvider = eleProvider;
+-		return this;
+-	}
++    private void printInfo(String str) {
++        LoggerFactory.getLogger(getClass()).info(
++                "finished " + str + " processing." + " nodes: "
++                        + graphStorage.getNodes() + ", osmIdMap.size:"
++                        + getNodeMap().size() + ", osmIdMap:"
++                        + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
++                        + ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
++                        + Helper.getMemInfo());
++    }
+ 
+-	public OsDpnReader setOSMFile(File osmFile) {
+-		this.routingFile = osmFile;
+-		return this;
+-	}
++    @Override
++    public String toString() {
++        return getClass().getSimpleName();
++    }
+ 
+-	private void printInfo(String str) {
+-		LoggerFactory.getLogger(getClass()).info(
+-				"finished " + str + " processing." + " nodes: "
+-						+ graphStorage.getNodes() + ", osmIdMap.size:"
+-						+ getNodeMap().getSize() + ", osmIdMap:"
+-						+ getNodeMap().getMemoryUsage() + "MB"
+-						+ ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
+-						+ ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
+-						+ Helper.getMemInfo());
+-	}
+-
+-	@Override
+-	public String toString() {
+-		return getClass().getSimpleName();
+-	}
+-
+-	public GraphStorage getGraphStorage() {
+-		return graphStorage;
+-	}
++    @Override
++    public GraphStorage getGraphStorage() {
++        return graphStorage;
++    }
+ }
+Index: core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java	(working copy)
+@@ -1,13 +1,15 @@
+ package com.graphhopper.reader;
+ 
++import java.util.ArrayList;
+ import java.util.Collection;
++import java.util.Collections;
+ import java.util.HashMap;
+ import java.util.Map;
+ 
++import com.graphhopper.reader.osgb.OsItnReader;
+ import com.graphhopper.routing.util.TurnCostEncoder;
+ import com.graphhopper.util.EdgeExplorer;
+ import com.graphhopper.util.EdgeIterator;
+-import java.util.*;
+ 
+ /**
+  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
+@@ -18,30 +20,28 @@
+ {
+     public enum Type
+     {
+-        UNSUPPORTED, NOT, ONLY;
++	UNSUPPORTED, NOT, ONLY;
+ 
+-        private static final Map<String, Type> tags = new HashMap<String, Type>();
++	private static final Map<String, Type> tags = new HashMap<String, Type>();
+ 
+-        static
+-        {
+-            tags.put("no_left_turn", NOT);
+-            tags.put("no_right_turn", NOT);
+-            tags.put("no_straight_on", NOT);
+-            tags.put("no_u_turn", NOT);
+-            tags.put("only_right_turn", ONLY);
+-            tags.put("only_left_turn", ONLY);
+-            tags.put("only_straight_on", ONLY);
+-        }
++	static
++	{
++	    tags.put("no_left_turn", NOT);
++	    tags.put("no_right_turn", NOT);
++	    tags.put("no_straight_on", NOT);
++	    tags.put("no_u_turn", NOT);
++	    tags.put("only_right_turn", ONLY);
++	    tags.put("only_left_turn", ONLY);
++	    tags.put("only_straight_on", ONLY);
++	}
+ 
+-        public static Type getRestrictionType( String tag )
+-        {
+-            Type result = null;
+-            if (tag != null)
+-            {
+-                result = tags.get(tag);
+-            }
+-            return (result != null) ? result : UNSUPPORTED;
+-        }
++	public static Type getRestrictionType(String tag)
++	{
++	    Type result = null;
++	    if (tag != null)
++		result = tags.get(tag);
++	    return result != null ? result : UNSUPPORTED;
++	}
+     }
+ 
+     private final long fromOsmWayId;
+@@ -49,101 +49,114 @@
+     private final long toOsmWayId;
+     private final Type restriction;
+ 
+-    public OSMTurnRelation( long fromWayID, long viaNodeID, long toWayID, Type restrictionType )
++    public OSMTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType)
+     {
+-        this.fromOsmWayId = fromWayID;
+-        this.viaOsmNodeId = viaNodeID;
+-        this.toOsmWayId = toWayID;
+-        this.restriction = restrictionType;
++	this.fromOsmWayId = fromWayID;
++	this.viaOsmNodeId = viaNodeID;
++	this.toOsmWayId = toWayID;
++	this.restriction = restrictionType;
+     }
+ 
+-    /* (non-Javadoc)
+-	 * @see com.graphhopper.reader.TurnRelation#getOsmIdFrom()
+-	 */
++    /*
++     * (non-Javadoc)
++     * 
++     * @see com.graphhopper.reader.TurnRelation#getOsmIdFrom()
++     */
+     @Override
+-	public long getOsmIdFrom()
++    public long getOsmIdFrom()
+     {
+-        return fromOsmWayId;
++	return fromOsmWayId;
+     }
+ 
+-    /* (non-Javadoc)
+-	 * @see com.graphhopper.reader.TurnRelation#getOsmIdTo()
+-	 */
++    /*
++     * (non-Javadoc)
++     * 
++     * @see com.graphhopper.reader.TurnRelation#getOsmIdTo()
++     */
+     @Override
+-	public long getOsmIdTo()
++    public long getOsmIdTo()
+     {
+-        return toOsmWayId;
++	return toOsmWayId;
+     }
+ 
+     /**
+      * Transforms this relation into a collection of turn cost entries
+      * <p>
+-     * @param edgeOutExplorer an edge filter which only allows outgoing edges
+-     * @param edgeInExplorer an edge filter which only allows incoming edges
++     * 
++     * @param edgeOutExplorer
++     *            an edge filter which only allows outgoing edges
++     * @param edgeInExplorer
++     *            an edge filter which only allows incoming edges
+      * @return a collection of node cost entries which can be added to the graph later
+      */
+-    public Collection<ITurnCostTableEntry> getRestrictionAsEntries( TurnCostEncoder encoder,
+-            EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader osmReader )
++    @Override
++    public Collection<ITurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder,
++		    EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader dataReader)
+     {
+-        int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
++	OsItnReader itnReader = (OsItnReader) dataReader;
++	int viaNodeId = itnReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
+ 
+-        try
+-        {
+-            // street with restriction was not included (access or tag limits etc)
+-            if (viaNodeId == OSMReader.EMPTY)
+-                return Collections.emptyList();
++	try
++	{
++	    // street with restriction was not included (access or tag limits
++	    // etc)
++	    if (viaNodeId == OSMReader.EMPTY)
++		return Collections.emptyList();
+ 
+-            int edgeIdFrom = EdgeIterator.NO_EDGE;
++	    int edgeIdFrom = EdgeIterator.NO_EDGE;
+ 
+-            // get all incoming edges and receive the edge which is defined by fromOsm
+-            EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
++	    // get all incoming edges and receive the edge which is defined by
++	    // fromOsm
++	    EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
+ 
+-            while (iter.next())
+-            {
+-                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
+-                {
+-                    edgeIdFrom = iter.getEdge();
+-                    break;
+-                }
+-            }
++	    while (iter.next())
++		if (itnReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
++		{
++		    edgeIdFrom = iter.getEdge();
++		    break;
++		}
+ 
+-            if (edgeIdFrom == EdgeIterator.NO_EDGE)
+-                return Collections.emptyList();
++	    if (edgeIdFrom == EdgeIterator.NO_EDGE)
++		return Collections.emptyList();
+ 
+-            final Collection<ITurnCostTableEntry> entries = new ArrayList<ITurnCostTableEntry>();
+-            // get all outgoing edges of the via node 
+-            iter = edgeOutExplorer.setBaseNode(viaNodeId);
+-            // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
+-            // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
+-            while (iter.next())
+-            {
+-                int edgeId = iter.getEdge();
+-                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
+-                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId
+-                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0)
+-                {
+-                    final TurnCostTableEntry entry = new TurnCostTableEntry();
+-                    entry.nodeViaNode = viaNodeId;
+-                    entry.edgeFrom = edgeIdFrom;
+-                    entry.edgeTo = iter.getEdge();
+-                    entry.flags = encoder.getTurnFlags(true, 0);
+-                    entries.add(entry);
++	    final Collection<ITurnCostTableEntry> entries = new ArrayList<ITurnCostTableEntry>();
++	    // get all outgoing edges of the via node
++	    iter = edgeOutExplorer.setBaseNode(viaNodeId);
++	    // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT
++	    // the given turn
++	    // for TYPE_NOT_* we add ONE restriction (from, via, to)
++	    while (iter.next())
++	    {
++		int edgeId = iter.getEdge();
++		long wayId = itnReader.getOsmIdOfInternalEdge(edgeId);
++		if (edgeId != edgeIdFrom && this.restriction == Type.ONLY
++				&& wayId != this.toOsmWayId || this.restriction == Type.NOT
++				&& wayId == this.toOsmWayId && wayId >= 0)
++		{
++		    final TurnCostTableEntry entry = new TurnCostTableEntry();
++		    entry.nodeViaNode = viaNodeId;
++		    entry.edgeFrom = edgeIdFrom;
++		    entry.edgeTo = iter.getEdge();
++		    entry.flags = encoder.getTurnFlags(true, 0);
++		    entries.add(entry);
+ 
+-                    if (this.restriction == Type.NOT)
+-                        break;
+-                }
+-            }
+-            return entries;
+-        } catch (Exception e)
+-        {
+-            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
+-        }
++		    if (this.restriction == Type.NOT)
++			break;
++		}
++	    }
++	    return entries;
++	} catch (Exception e)
++	{
++	    throw new IllegalStateException(
++			    "Could not built turn table entry for relation of node with osmId:"
++					    + this.viaOsmNodeId, e);
++	}
+     }
+ 
+     @Override
+     public String toString()
+     {
+-        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
++	return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
+     }
+ 
+     /**
+@@ -151,50 +164,56 @@
+      */
+     public static class TurnCostTableEntry implements ITurnCostTableEntry
+     {
+-        public int edgeFrom;
+-        public int nodeViaNode;
+-        public int edgeTo;
+-        public long flags;
++	public int edgeFrom;
++	public int nodeViaNode;
++	public int edgeTo;
++	public long flags;
+ 
+-        /**
+-         * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
+-         * are involved.
+-         */
+-        public long getItemId()
+-        {
+-            return ((long) edgeFrom) << 32 | ((long) edgeTo);
+-        }
+-        
+-        @Override
+-		public int getEdgeFrom() {
+-			return edgeFrom;
+-		}
++	/**
++	 * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
++	 *         are involved.
++	 */
++	@Override
++	public long getItemId()
++	{
++	    return (long) edgeFrom << 32 | edgeTo;
++	}
+ 
+-		@Override
+-		public int getEdgeTo() {
+-			return edgeTo;
+-		}
++	@Override
++	public int getEdgeFrom()
++	{
++	    return edgeFrom;
++	}
+ 
+-		@Override
+-		public int getVia() {
+-			return nodeViaNode;
+-		}
++	@Override
++	public int getEdgeTo()
++	{
++	    return edgeTo;
++	}
+ 
+-		@Override
+-		public long getFlags() {
+-			return flags;
+-		}
++	@Override
++	public int getVia()
++	{
++	    return nodeViaNode;
++	}
+ 
+-		@Override
+-		public void setFlags(long flags) {
+-			this.flags = flags;
+-		}
++	@Override
++	public long getFlags()
++	{
++	    return flags;
++	}
+ 
+-        @Override
+-        public String toString()
+-        {
+-            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
+-        }
++	@Override
++	public void setFlags(long flags)
++	{
++	    this.flags = flags;
++	}
++
++	@Override
++	public String toString()
++	{
++	    return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
++	}
+     }
+ 
+ }
+Index: core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java	(working copy)
+@@ -220,10 +220,10 @@
+     private String resolveNature(String elementText) {
+         logger.info("OSITNElement.resolveNature( " + elementText + ")");
+         switch (elementText) {
+-        case "Single Carriageway":
+-        case "Dual Carriageway":
+-        case "Slip Road":
+-            return elementText;
++            case "Single Carriageway":
++            case "Dual Carriageway":
++            case "Slip Road":
++                return elementText;
+         }
+         return null;
+     }
+@@ -456,6 +456,7 @@
+         return (String) properties.get(name);
+     }
+ 
++    @Override
+     @SuppressWarnings("unchecked")
+     public <T> T getTag(String key, T defaultValue) {
+         T val = (T) properties.get(key);
+@@ -464,6 +465,7 @@
+         return val;
+     }
+ 
++    @Override
+     public void setTag(String name, Object value) {
+         // if(name.equals("highway")) {
+         // System.err.println("HIGHWAY:" + value);
+@@ -474,6 +476,7 @@
+     /**
+      * Chaeck that the object has a given tag with a given value.
+      */
++    @Override
+     public boolean hasTag(String key, Object value) {
+         return value.equals(properties.get(key));
+     }
+@@ -482,6 +485,7 @@
+      * Check that a given tag has one of the specified values. If no values are
+      * given, just checks for presence of the tag
+      */
++    @Override
+     public boolean hasTag(String key, String... values) {
+         Object osmValue = properties.get(key);
+         if (osmValue == null)
+@@ -501,6 +505,7 @@
+     /**
+      * Check that a given tag has one of the specified values.
+      */
++    @Override
+     public final boolean hasTag(String key, Set<String> values) {
+         return values.contains(properties.get(key));
+     }
+@@ -509,10 +514,10 @@
+      * Check a number of tags in the given order for the any of the given
+      * values. Used to parse hierarchical access restrictions
+      */
++    @Override
+     public boolean hasTag(List<String> keyList, Set<String> values) {
+         for (String key : keyList) {
+-            Object value = properties.get(key);
+-            if (values.contains(value))
++            if (values.contains(properties.get(key)))
+                 return true;
+         }
+         return false;
+@@ -526,10 +531,12 @@
+         properties.clear();
+     }
+ 
++    @Override
+     public int getType() {
+         return type;
+     }
+ 
++    @Override
+     public boolean isType(int type) {
+         return this.type == type;
+     }
+Index: core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
+===================================================================
+--- core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java	(revision 2400)
++++ core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java	(working copy)
+@@ -18,6 +18,15 @@
+  */
+ package com.graphhopper.reader;
+ 
++import static org.junit.Assert.assertEquals;
++
++import java.util.Collection;
++import java.util.HashMap;
++import java.util.Iterator;
++import java.util.Map;
++
++import org.junit.Test;
++
+ import com.graphhopper.reader.OSMTurnRelation.Type;
+ import com.graphhopper.routing.EdgeBasedRoutingAlgorithmTest;
+ import com.graphhopper.routing.util.CarFlagEncoder;
+@@ -25,15 +34,9 @@
+ import com.graphhopper.storage.GraphBuilder;
+ import com.graphhopper.storage.GraphStorage;
+ import com.graphhopper.util.EdgeExplorer;
+-import java.util.Collection;
+-import java.util.HashMap;
+-import java.util.Iterator;
+-import java.util.Map;
+-import org.junit.Test;
+-import static org.junit.Assert.*;
+ 
+ /**
+- *
++ * 
+  * @author Peter Karich
+  */
+ public class OSMTurnRelationTest
+@@ -44,29 +47,27 @@
+         CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 3);
+         final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
+         final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
+-                
++
+         osmNodeToInternal.put(3L, 3);
+         // edge ids are only stored if they occured before in an OSMRelation
+-        internalToOSMEdge.put(3, 3L);        
+-        internalToOSMEdge.put(4, 4L);        
++        internalToOSMEdge.put(3, 3L);
++        internalToOSMEdge.put(4, 4L);
+ 
+-        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder)).create();
++        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder))
++                .create();
+         EdgeBasedRoutingAlgorithmTest.initGraph(graph);
+-        OSMReader osmReader = new OSMReader(graph)
+-        {
++        OSMReader osmReader = new OSMReader(graph) {
+ 
+             @Override
+-            public int getInternalNodeIdOfOsmNode( long nodeOsmId )
+-            {
++            public int getInternalNodeIdOfOsmNode(Long nodeOsmId) {
+                 return osmNodeToInternal.get(nodeOsmId);
+             }
+ 
+             @Override
+-            public long getOsmIdOfInternalEdge( int edgeId )
+-            {
++            public Long getOsmIdOfInternalEdge(int edgeId) {
+                 Long l = internalToOSMEdge.get(edgeId);
+-                if(l == null)
+-                    return -1;
++                if (l == null)
++                    return -1L;
+                 return l;
+             }
+         };
+@@ -75,8 +76,9 @@
+ 
+         // TYPE == ONLY
+         OSMTurnRelation instance = new OSMTurnRelation(4, 3, 3, Type.ONLY);
+-        Collection<ITurnCostTableEntry> result
+-                = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
++        Collection<ITurnCostTableEntry> result = instance
++                .getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer,
++                        osmReader);
+ 
+         assertEquals(2, result.size());
+         Iterator<ITurnCostTableEntry> iter = result.iterator();
+@@ -84,23 +86,23 @@
+         assertEquals(4, entry.getEdgeFrom());
+         assertEquals(6, entry.getEdgeTo());
+         assertEquals(3, entry.getVia());
+-        
++
+         entry = iter.next();
+         assertEquals(4, entry.getEdgeFrom());
+         assertEquals(2, entry.getEdgeTo());
+         assertEquals(3, entry.getVia());
+-        
+-        
++
+         // TYPE == NOT
+         instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
+-        result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
++        result = instance.getRestrictionAsEntries(encoder, edgeExplorer,
++                edgeExplorer, osmReader);
+ 
+         assertEquals(1, result.size());
+         iter = result.iterator();
+         entry = iter.next();
+         assertEquals(4, entry.getEdgeFrom());
+         assertEquals(3, entry.getEdgeTo());
+-        assertEquals(3, entry.getVia());       
++        assertEquals(3, entry.getVia());
+     }
+ 
+ }
+Index: core/src/main/java/com/graphhopper/reader/DataReader.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/DataReader.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/DataReader.java	(working copy)
+@@ -29,25 +29,24 @@
+  * @author Peter Karich
+  * @author Stuart Adam
+  */
+-public interface DataReader
+-{
++public interface DataReader<E> {
+ 
+     void readGraph() throws IOException;
+ 
+     GraphStorage getGraphStorage();
+ 
+-	int getInternalNodeIdOfOsmNode(long viaOsm);
++    int getInternalNodeIdOfOsmNode(E viaOsm);
+ 
+-	long getOsmIdOfInternalEdge(int edge);
++    E getOsmIdOfInternalEdge(int edge);
+ 
+-	DataReader setOSMFile(File srcFile);
++    DataReader setOSMFile(File srcFile);
+ 
+-	DataReader setElevationProvider(ElevationProvider eleProvider);
++    DataReader setElevationProvider(ElevationProvider eleProvider);
+ 
+-	DataReader setWorkerThreads(int workerThreads);
++    DataReader setWorkerThreads(int workerThreads);
+ 
+-	DataReader setEncodingManager(EncodingManager encodingManager);
++    DataReader setEncodingManager(EncodingManager encodingManager);
+ 
+-	DataReader setWayPointMaxDistance(double wayPointMaxDistance);
++    DataReader setWayPointMaxDistance(double wayPointMaxDistance);
+ 
+ }
+Index: core/src/main/java/com/graphhopper/GraphHopper.java
+===================================================================
+--- core/src/main/java/com/graphhopper/GraphHopper.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/GraphHopper.java	(working copy)
+@@ -36,6 +36,7 @@
+ import com.graphhopper.reader.dem.ElevationProvider;
+ import com.graphhopper.reader.dem.SRTMProvider;
+ import com.graphhopper.reader.osgb.OsItnReader;
++import com.graphhopper.reader.osgb.dpn.OsDpnReader;
+ import com.graphhopper.routing.Path;
+ import com.graphhopper.routing.RoutingAlgorithm;
+ import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+@@ -89,7 +90,7 @@
+ public class GraphHopper implements GraphHopperAPI
+ {
+     private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM or OSITN";
+-	private final Logger logger = LoggerFactory.getLogger(getClass());
++    private final Logger logger = LoggerFactory.getLogger(getClass());
+     // for graph:
+     private GraphStorage graph;
+     private EncodingManager encodingManager;
+@@ -128,11 +129,11 @@
+     private double osmReaderWayPointMaxDistance = 1;
+     private int workerThreads = -1;
+     private boolean calcPoints = true;
+-    // utils    
++    // utils
+     private final TranslationMap trMap = new TranslationMap().doImport();
+     private ElevationProvider eleProvider = ElevationProvider.NOOP;
+     private final AtomicLong visitedSum = new AtomicLong(0);
+-	private String dataReader = "OSM";
++    private String dataReader = "OSM";
+ 
+     public GraphHopper()
+     {
+@@ -141,38 +142,38 @@
+     /**
+      * For testing only
+      */
+-    protected GraphHopper loadGraph( GraphStorage g )
++    protected GraphHopper loadGraph(GraphStorage g)
+     {
+-        this.graph = g;
+-        fullyLoaded = true;
+-        initLocationIndex();
+-        return this;
++	this.graph = g;
++	fullyLoaded = true;
++	initLocationIndex();
++	return this;
+     }
+ 
+     /**
+      * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
+      * how data from every vehicle is written (und read) into edges of the graph.
+      */
+-    public GraphHopper setEncodingManager( EncodingManager em )
++    public GraphHopper setEncodingManager(EncodingManager em)
+     {
+-        ensureNotLoaded();
+-        this.encodingManager = em;
+-        return this;
++	ensureNotLoaded();
++	this.encodingManager = em;
++	return this;
+     }
+ 
+     public EncodingManager getEncodingManager()
+     {
+-        return encodingManager;
++	return encodingManager;
+     }
+ 
+-    public GraphHopper setElevationProvider( ElevationProvider eleProvider )
++    public GraphHopper setElevationProvider(ElevationProvider eleProvider)
+     {
+-        if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
+-            setElevation(false);
+-        else
+-            setElevation(true);
+-        this.eleProvider = eleProvider;
+-        return this;
++	if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
++	    setElevation(false);
++	else
++	    setElevation(true);
++	this.eleProvider = eleProvider;
++	return this;
+     }
+ 
+     /**
+@@ -180,7 +181,7 @@
+      */
+     protected int getWorkerThreads()
+     {
+-        return workerThreads;
++	return workerThreads;
+     }
+ 
+     /**
+@@ -188,31 +189,31 @@
+      */
+     protected double getWayPointMaxDistance()
+     {
+-        return osmReaderWayPointMaxDistance;
++	return osmReaderWayPointMaxDistance;
+     }
+ 
+     /**
+      * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
+      * value means more details, unit is meter. Default is 1. Disable via 0.
+      */
+-    public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
++    public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance)
+     {
+-        this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
+-        return this;
++	this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
++	return this;
+     }
+ 
+     /**
+      * Sets the default traversal mode used for the algorithms and preparation.
+      */
+-    public GraphHopper setTraversalMode( TraversalMode traversalMode )
++    public GraphHopper setTraversalMode(TraversalMode traversalMode)
+     {
+-        this.traversalMode = traversalMode;
+-        return this;
++	this.traversalMode = traversalMode;
++	return this;
+     }
+ 
+     public TraversalMode getTraversalMode()
+     {
+-        return traversalMode;
++	return traversalMode;
+     }
+ 
+     /**
+@@ -220,9 +221,9 @@
+      */
+     public GraphHopper forServer()
+     {
+-        // simplify to reduce network IO
+-        setSimplifyResponse(true);
+-        return setInMemory();
++	// simplify to reduce network IO
++	setSimplifyResponse(true);
++	return setInMemory();
+     }
+ 
+     /**
+@@ -231,8 +232,8 @@
+      */
+     public GraphHopper forDesktop()
+     {
+-        setSimplifyResponse(false);
+-        return setInMemory();
++	setSimplifyResponse(false);
++	return setInMemory();
+     }
+ 
+     /**
+@@ -241,8 +242,8 @@
+      */
+     public GraphHopper forMobile()
+     {
+-        setSimplifyResponse(false);
+-        return setMemoryMapped();
++	setSimplifyResponse(false);
++	return setMemoryMapped();
+     }
+ 
+     /**
+@@ -250,11 +251,11 @@
+      * probably slower query times, which would be e.g. not suitable for Android. The resolution
+      * specifies the tile width (in meter).
+      */
+-    public GraphHopper setPreciseIndexResolution( int precision )
++    public GraphHopper setPreciseIndexResolution(int precision)
+     {
+-        ensureNotLoaded();
+-        preciseIndexResolution = precision;
+-        return this;
++	ensureNotLoaded();
++	preciseIndexResolution = precision;
++	return this;
+     }
+ 
+     /**
+@@ -262,9 +263,9 @@
+      */
+     public GraphHopper setInMemory()
+     {
+-        ensureNotLoaded();
+-        dataAccessType = DAType.RAM_STORE;
+-        return this;
++	ensureNotLoaded();
++	dataAccessType = DAType.RAM_STORE;
++	return this;
+     }
+ 
+     /**
+@@ -272,16 +273,17 @@
+      * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
+      * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
+      * <p>
+-     * @param storeOnFlush true by default
++     * @param storeOnFlush
++     *            true by default
+      */
+-    public GraphHopper setStoreOnFlush( boolean storeOnFlush )
++    public GraphHopper setStoreOnFlush(boolean storeOnFlush)
+     {
+-        ensureNotLoaded();
+-        if (storeOnFlush)
+-            dataAccessType = DAType.RAM_STORE;
+-        else
+-            dataAccessType = DAType.RAM;
+-        return this;
++	ensureNotLoaded();
++	if (storeOnFlush)
++	    dataAccessType = DAType.RAM_STORE;
++	else
++	    dataAccessType = DAType.RAM;
++	return this;
+     }
+ 
+     /**
+@@ -289,9 +291,9 @@
+      */
+     public GraphHopper setMemoryMapped()
+     {
+-        ensureNotLoaded();
+-        dataAccessType = DAType.MMAP;
+-        return this;
++	ensureNotLoaded();
++	dataAccessType = DAType.MMAP;
++	return this;
+     }
+ 
+     /**
+@@ -299,51 +301,52 @@
+      */
+     private GraphHopper setUnsafeMemory()
+     {
+-        ensureNotLoaded();
+-        dataAccessType = DAType.UNSAFE_STORE;
+-        return this;
++	ensureNotLoaded();
++	dataAccessType = DAType.UNSAFE_STORE;
++	return this;
+     }
+ 
+     /**
+      * Disables "CH-preparation". Use only if you know what you do.
+      */
+-    public GraphHopper setDoPrepare( boolean doPrepare )
++    public GraphHopper setDoPrepare(boolean doPrepare)
+     {
+-        this.doPrepare = doPrepare;
+-        return this;
++	this.doPrepare = doPrepare;
++	return this;
+     }
+ 
+     /**
+      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
+      * <p/>
+-     * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
++     * @param weighting
++     *            can be "fastest", "shortest" or your own weight-calculation type.
+      * @see #setCHEnable(boolean)
+      */
+-    public GraphHopper setCHWeighting( String weighting )
++    public GraphHopper setCHWeighting(String weighting)
+     {
+-        ensureNotLoaded();
+-        chWeighting = weighting;
+-        return this;
++	ensureNotLoaded();
++	chWeighting = weighting;
++	return this;
+     }
+ 
+     public String getCHWeighting()
+     {
+-        return chWeighting;
++	return chWeighting;
+     }
+ 
+     /**
+      * Enables or disables contraction hierarchies. Enabled by default.
+      */
+-    public GraphHopper setCHEnable( boolean enable )
++    public GraphHopper setCHEnable(boolean enable)
+     {
+-        ensureNotLoaded();
+-        chEnabled = enable;
+-        return this;
++	ensureNotLoaded();
++	chEnabled = enable;
++	return this;
+     }
+ 
+     public boolean isCHEnabled()
+     {
+-        return chEnabled;
++	return chEnabled;
+     }
+ 
+     /**
+@@ -351,154 +354,156 @@
+      */
+     public boolean hasElevation()
+     {
+-        return elevation;
++	return elevation;
+     }
+ 
+     /**
+      * Enable storing and fetching elevation data. Default is false
+      */
+-    public GraphHopper setElevation( boolean includeElevation )
++    public GraphHopper setElevation(boolean includeElevation)
+     {
+-        this.elevation = includeElevation;
+-        return this;
++	this.elevation = includeElevation;
++	return this;
+     }
+ 
+     /**
+      * This method specifies if the import should include way names to be able to return
+      * instructions for a route.
+      */
+-    public GraphHopper setEnableInstructions( boolean b )
++    public GraphHopper setEnableInstructions(boolean b)
+     {
+-        ensureNotLoaded();
+-        enableInstructions = b;
+-        return this;
++	ensureNotLoaded();
++	enableInstructions = b;
++	return this;
+     }
+ 
+     /**
+      * This methods enables gps point calculation. If disabled only distance will be calculated.
+      */
+-    public GraphHopper setEnableCalcPoints( boolean b )
++    public GraphHopper setEnableCalcPoints(boolean b)
+     {
+-        calcPoints = b;
+-        return this;
++	calcPoints = b;
++	return this;
+     }
+ 
+     /**
+      * This method specifies if the returned path should be simplified or not, via douglas-peucker
+      * or similar algorithm.
+      */
+-    private GraphHopper setSimplifyResponse( boolean doSimplify )
++    private GraphHopper setSimplifyResponse(boolean doSimplify)
+     {
+-        this.simplifyResponse = doSimplify;
+-        return this;
++	this.simplifyResponse = doSimplify;
++	return this;
+     }
+ 
+     /**
+      * Sets the graphhopper folder.
+      */
+-    public GraphHopper setGraphHopperLocation( String ghLocation )
++    public GraphHopper setGraphHopperLocation(String ghLocation)
+     {
+-        ensureNotLoaded();
+-        if (ghLocation == null)
+-            throw new IllegalArgumentException("graphhopper location cannot be null");
++	ensureNotLoaded();
++	if (ghLocation == null)
++	    throw new IllegalArgumentException("graphhopper location cannot be null");
+ 
+-        this.ghLocation = ghLocation;
+-        return this;
++	this.ghLocation = ghLocation;
++	return this;
+     }
+ 
+     public String getGraphHopperLocation()
+     {
+-        return ghLocation;
++	return ghLocation;
+     }
+ 
+     /**
+      * This file can be an osm xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file
+      * (.pbf).
+      */
+-    public GraphHopper setOSMFile( String osmFileStr )
++    public GraphHopper setOSMFile(String osmFileStr)
+     {
+-        ensureNotLoaded();
+-        if (Helper.isEmpty(osmFileStr))
+-            throw new IllegalArgumentException("OSM file cannot be empty.");
++	ensureNotLoaded();
++	if (Helper.isEmpty(osmFileStr))
++	    throw new IllegalArgumentException("OSM file cannot be empty.");
+ 
+-        osmFile = osmFileStr;
+-        return this;
++	osmFile = osmFileStr;
++	return this;
+     }
+ 
+     public String getOSMFile()
+     {
+-        return osmFile;
++	return osmFile;
+     }
+ 
+     /**
+      * The underlying graph used in algorithms.
+      * <p>
+-     * @throws IllegalStateException if graph is not instantiated.
++     * @throws IllegalStateException
++     *             if graph is not instantiated.
+      */
+     public GraphStorage getGraph()
+     {
+-        if (graph == null)
+-            throw new IllegalStateException("Graph not initialized");
++	if (graph == null)
++	    throw new IllegalStateException("Graph not initialized");
+ 
+-        return graph;
++	return graph;
+     }
+ 
+-    public void setGraph( GraphStorage graph )
++    public void setGraph(GraphStorage graph)
+     {
+-        this.graph = graph;
++	this.graph = graph;
+     }
+ 
+-    protected void setLocationIndex( LocationIndex locationIndex )
++    protected void setLocationIndex(LocationIndex locationIndex)
+     {
+-        this.locationIndex = locationIndex;
++	this.locationIndex = locationIndex;
+     }
+ 
+     /**
+      * The location index created from the graph.
+      * <p>
+-     * @throws IllegalStateException if index is not initialized
++     * @throws IllegalStateException
++     *             if index is not initialized
+      */
+     public LocationIndex getLocationIndex()
+     {
+-        if (locationIndex == null)
+-            throw new IllegalStateException("Location index not initialized");
++	if (locationIndex == null)
++	    throw new IllegalStateException("Location index not initialized");
+ 
+-        return locationIndex;
++	return locationIndex;
+     }
+ 
+     public AlgorithmPreparation getPreparation()
+     {
+-        return prepare;
++	return prepare;
+     }
+ 
+     /**
+      * Sorts the graph which requires more RAM while import. See #12
+      */
+-    public GraphHopper setSortGraph( boolean sortGraph )
++    public GraphHopper setSortGraph(boolean sortGraph)
+     {
+-        ensureNotLoaded();
+-        this.sortGraph = sortGraph;
+-        return this;
++	ensureNotLoaded();
++	this.sortGraph = sortGraph;
++	return this;
+     }
+ 
+     /**
+      * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
+      * possible to create a lock file and so we can avoid write locks.
+      */
+-    public GraphHopper setAllowWrites( boolean allowWrites )
++    public GraphHopper setAllowWrites(boolean allowWrites)
+     {
+-        this.allowWrites = allowWrites;
+-        return this;
++	this.allowWrites = allowWrites;
++	return this;
+     }
+ 
+     public boolean isAllowWrites()
+     {
+-        return allowWrites;
++	return allowWrites;
+     }
+ 
+     public TranslationMap getTranslationMap()
+     {
+-        return trMap;
++	return trMap;
+     }
+ 
+     /**
+@@ -506,99 +511,101 @@
+      * args) ala CmdArgs.read(args) or via configuration file ala
+      * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
+      */
+-    public GraphHopper init( CmdArgs args )
++    public GraphHopper init(CmdArgs args)
+     {
+-        args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
+-        String tmpOsmFile = args.get("osmreader.osm", "");
+-        if (!Helper.isEmpty(tmpOsmFile))
+-            osmFile = tmpOsmFile;
+-        
+-        dataReader = args.get("reader.implementation", dataReader);
++	args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
++	String tmpOsmFile = args.get("osmreader.osm", "");
++	if (!Helper.isEmpty(tmpOsmFile))
++	    osmFile = tmpOsmFile;
++
++	dataReader = args.get("reader.implementation", dataReader);
+ 
+-        String graphHopperFolder = args.get("graph.location", "");
+-        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
+-        {
+-            if (Helper.isEmpty(osmFile))
+-                throw new IllegalArgumentException("You need to specify an OSM file.");
++	String graphHopperFolder = args.get("graph.location", "");
++	if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
++	{
++	    if (Helper.isEmpty(osmFile))
++		throw new IllegalArgumentException("You need to specify an OSM file.");
+ 
+-            graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
+-        }
++	    graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
++	}
+ 
+-        // graph
+-        setGraphHopperLocation(graphHopperFolder);
+-        defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
++	// graph
++	setGraphHopperLocation(graphHopperFolder);
++	defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
+ 
+-        String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
+-        dataAccessType = DAType.fromString(graphDATypeStr);
++	String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
++	dataAccessType = DAType.fromString(graphDATypeStr);
+ 
+-        sortGraph = args.getBool("graph.doSort", sortGraph);
+-        removeZipped = args.getBool("graph.removeZipped", removeZipped);
+-        int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
+-        if (args.get("graph.locktype", "native").equals("simple"))
+-            lockFactory = new SimpleFSLockFactory();
+-        else
+-            lockFactory = new NativeFSLockFactory();
++	sortGraph = args.getBool("graph.doSort", sortGraph);
++	removeZipped = args.getBool("graph.removeZipped", removeZipped);
++	int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
++	if (args.get("graph.locktype", "native").equals("simple"))
++	    lockFactory = new SimpleFSLockFactory();
++	else
++	    lockFactory = new NativeFSLockFactory();
+ 
+-        // elevation
+-        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
+-        boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
+-        String cacheDirStr = args.get("graph.elevation.cachedir", "");
+-        String baseURL = args.get("graph.elevation.baseurl", "");
+-        DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
+-        ElevationProvider tmpProvider = ElevationProvider.NOOP;
+-        if (eleProviderStr.equalsIgnoreCase("srtm"))
+-        {
+-            tmpProvider = new SRTMProvider();
+-        } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
+-        {
+-            CGIARProvider cgiarProvider = new CGIARProvider();
+-            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
+-            tmpProvider = cgiarProvider;
+-        }
++	// elevation
++	String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
++	boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
++	String cacheDirStr = args.get("graph.elevation.cachedir", "");
++	String baseURL = args.get("graph.elevation.baseurl", "");
++	DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
++	ElevationProvider tmpProvider = ElevationProvider.NOOP;
++	if (eleProviderStr.equalsIgnoreCase("srtm"))
++	    tmpProvider = new SRTMProvider();
++	else if (eleProviderStr.equalsIgnoreCase("cgiar"))
++	{
++	    CGIARProvider cgiarProvider = new CGIARProvider();
++	    cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear",
++			    true));
++	    tmpProvider = cgiarProvider;
++	}
+ 
+-        tmpProvider.setCalcMean(eleCalcMean);
+-        tmpProvider.setCacheDir(new File(cacheDirStr));
+-        if (!baseURL.isEmpty())
+-            tmpProvider.setBaseURL(baseURL);
+-        tmpProvider.setDAType(elevationDAType);
+-        setElevationProvider(tmpProvider);
++	tmpProvider.setCalcMean(eleCalcMean);
++	tmpProvider.setCacheDir(new File(cacheDirStr));
++	if (!baseURL.isEmpty())
++	    tmpProvider.setBaseURL(baseURL);
++	tmpProvider.setDAType(elevationDAType);
++	setElevationProvider(tmpProvider);
+ 
+-        // optimizable prepare
+-        minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
+-        minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
++	// optimizable prepare
++	minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
++	minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
+ 
+-        // prepare CH
+-        doPrepare = args.getBool("prepare.doPrepare", doPrepare);
+-        String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
+-        chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
+-        if (chEnabled)
+-            setCHWeighting(tmpCHWeighting);
++	// prepare CH
++	doPrepare = args.getBool("prepare.doPrepare", doPrepare);
++	String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
++	chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
++	if (chEnabled)
++	    setCHWeighting(tmpCHWeighting);
+ 
+-        periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
+-        lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
+-        neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
+-        logMessages = args.getDouble("prepare.logmessages", logMessages);
++	periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
++	lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
++	neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
++	logMessages = args.getDouble("prepare.logmessages", logMessages);
+ 
+-        // osm import
+-        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
+-        String flagEncoders = args.get("graph.flagEncoders", "CAR");
+-        if (flagEncoders.toLowerCase().contains("turncosts=true"))
+-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
+-        encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
+-        workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
+-        enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
++	// osm import
++	osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance",
++			osmReaderWayPointMaxDistance);
++	String flagEncoders = args.get("graph.flagEncoders", "CAR");
++	if (flagEncoders.toLowerCase().contains("turncosts=true"))
++	    traversalMode = TraversalMode.EDGE_BASED_2DIR;
++	encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
++	workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
++	enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
+ 
+-        // index
+-        preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
+-        maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+-        return this;
++	// index
++	preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
++	maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
++	return this;
+     }
+ 
+     private void printInfo()
+     {
+-        logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
+-        if (graph != null)
+-            logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
++	logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " ("
++			+ Constants.getVersions() + ")");
++	if (graph != null)
++	    logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
+     }
+ 
+     /**
+@@ -608,186 +615,187 @@
+      */
+     public GraphHopper importOrLoad()
+     {
+-        if (!load(ghLocation))
+-        {
+-            printInfo();
+-            process(ghLocation);
+-        } else
+-        {
+-            printInfo();
+-        }
+-        return this;
++	if (!load(ghLocation))
++	{
++	    printInfo();
++	    process(ghLocation);
++	} else
++	    printInfo();
++	return this;
+     }
+ 
+     /**
+      * Creates the graph from OSM data.
+      */
+-    private GraphHopper process( String graphHopperLocation )
++    private GraphHopper process(String graphHopperLocation)
+     {
+-        setGraphHopperLocation(graphHopperLocation);
+-        Lock lock = null;
+-        try
+-        {
+-            if (graph.getDirectory().getDefaultType().isStoring())
+-            {
+-                lockFactory.setLockDir(new File(graphHopperLocation));
+-                lock = lockFactory.create(fileLockName, true);
+-                if (!lock.tryLock())
+-                    throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
+-            }
++	setGraphHopperLocation(graphHopperLocation);
++	Lock lock = null;
++	try
++	{
++	    if (graph.getDirectory().getDefaultType().isStoring())
++	    {
++		lockFactory.setLockDir(new File(graphHopperLocation));
++		lock = lockFactory.create(fileLockName, true);
++		if (!lock.tryLock())
++		    throw new RuntimeException(
++				    "To avoid multiple writers we need to obtain a write lock but it failed. In "
++						    + graphHopperLocation,
++				    lock.getObtainFailedReason());
++	    }
+ 
+-            try
+-            {
+-                importData();
+-                graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
+-            } catch (IOException ex)
+-            {
+-                throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
+-            }
+-            cleanUp();
+-            optimize();
+-            postProcessing();
+-            flush();
+-        } finally
+-        {
+-            if (lock != null)
+-                lock.release();
+-        }
+-        return this;
++	    try
++	    {
++		importData();
++		graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
++	    } catch (IOException ex)
++	    {
++		throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
++	    }
++	    cleanUp();
++	    optimize();
++	    postProcessing();
++	    flush();
++	} finally
++	{
++	    if (lock != null)
++		lock.release();
++	}
++	return this;
+     }
+ 
+     protected DataReader importData() throws IOException
+     {
+-        ensureWriteAccess();
+-        if (graph == null)
+-            throw new IllegalStateException("Load graph before importing OSM data");
++	ensureWriteAccess();
++	if (graph == null)
++	    throw new IllegalStateException("Load graph before importing OSM data");
+ 
+-        if (osmFile == null)
+-            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
+-                    + " but also cannot import from OSM file as it wasn't specified!");
++	if (osmFile == null)
++	    throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
++			    + " but also cannot import from OSM file as it wasn't specified!");
+ 
+-        encodingManager.setEnableInstructions(enableInstructions);
+-        DataReader reader = createReader(graph);
+-        logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
+-        reader.readGraph();
+-        return reader;
++	encodingManager.setEnableInstructions(enableInstructions);
++	DataReader reader = createReader(graph);
++	logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
++	reader.readGraph();
++	return reader;
+     }
+ 
+-    protected DataReader createReader( GraphStorage tmpGraph )
++    protected DataReader createReader(GraphStorage tmpGraph)
+     {
+-    	DataReader reader;
+-    	if ("OSM".equals(dataReader)) {
+-    		reader = new OSMReader(tmpGraph);
+-    	}
+-    	else if ("OSITN".equals(dataReader)) {
+-    		reader = new OsItnReader(tmpGraph);
+-    	} else {
+-    		String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
+-    		throw new IllegalArgumentException(exceptionMessage);
+-    	}
+-        return initReader(reader);
++	DataReader reader;
++	if ("OSM".equals(dataReader))
++	    reader = new OSMReader(tmpGraph);
++	else if ("OSITN".equals(dataReader))
++	    reader = new OsItnReader(tmpGraph);
++	else if ("OSDPN".equals(dataReader))
++	    reader = new OsDpnReader(tmpGraph);
++	else
++	{
++	    String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
++	    throw new IllegalArgumentException(exceptionMessage);
++	}
++	return initReader(reader);
+     }
+ 
+-    protected DataReader initReader(DataReader reader )
++    protected DataReader initReader(DataReader reader)
+     {
+-        if (osmFile == null)
+-            throw new IllegalArgumentException("No OSM file specified");
++	if (osmFile == null)
++	    throw new IllegalArgumentException("No OSM file specified");
+ 
+-        logger.info("start creating graph from " + osmFile);
+-        File osmTmpFile = new File(osmFile);
+-        return reader.setOSMFile(osmTmpFile).
+-                setElevationProvider(eleProvider).
+-                setWorkerThreads(workerThreads).
+-                setEncodingManager(encodingManager).
+-                setWayPointMaxDistance(osmReaderWayPointMaxDistance);
++	logger.info("start creating graph from " + osmFile);
++	File osmTmpFile = new File(osmFile);
++	return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider)
++			.setWorkerThreads(workerThreads).setEncodingManager(encodingManager)
++			.setWayPointMaxDistance(osmReaderWayPointMaxDistance);
+     }
+ 
+     /**
+      * Opens existing graph.
+      * <p/>
+-     * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
+-     * too)
++     * @param graphHopperFolder
++     *            is the folder containing graphhopper files (which can be compressed too)
+      */
+     @Override
+-    public boolean load( String graphHopperFolder )
++    public boolean load(String graphHopperFolder)
+     {
+-        if (Helper.isEmpty(graphHopperFolder))
+-            throw new IllegalStateException("graphHopperLocation is not specified. call init before");
++	if (Helper.isEmpty(graphHopperFolder))
++	    throw new IllegalStateException(
++			    "graphHopperLocation is not specified. call init before");
+ 
+-        if (fullyLoaded)
+-            throw new IllegalStateException("graph is already successfully loaded");
++	if (fullyLoaded)
++	    throw new IllegalStateException("graph is already successfully loaded");
+ 
+-        if (graphHopperFolder.endsWith("-gh"))
+-        {
+-            // do nothing  
+-        } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
+-        {
+-            throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
+-        } else if (!graphHopperFolder.contains("."))
+-        {
+-            if (new File(graphHopperFolder + "-gh").exists())
+-                graphHopperFolder += "-gh";
+-        } else
+-        {
+-            File compressed = new File(graphHopperFolder + ".ghz");
+-            if (compressed.exists() && !compressed.isDirectory())
+-            {
+-                try
+-                {
+-                    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
+-                } catch (IOException ex)
+-                {
+-                    throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath()
+-                            + " to " + graphHopperFolder, ex);
+-                }
+-            }
+-        }
++	if (graphHopperFolder.endsWith("-gh"))
++	{
++	    // do nothing
++	} else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
++	    throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
++	else if (!graphHopperFolder.contains("."))
++	{
++	    if (new File(graphHopperFolder + "-gh").exists())
++		graphHopperFolder += "-gh";
++	} else
++	{
++	    File compressed = new File(graphHopperFolder + ".ghz");
++	    if (compressed.exists() && !compressed.isDirectory())
++		try
++		{
++		    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder,
++				    removeZipped);
++		} catch (IOException ex)
++		{
++		    throw new RuntimeException("Couldn't extract file "
++				    + compressed.getAbsolutePath() + " to " + graphHopperFolder, ex);
++		}
++	}
+ 
+-        setGraphHopperLocation(graphHopperFolder);
++	setGraphHopperLocation(graphHopperFolder);
+ 
+-        if (encodingManager == null)
+-            encodingManager = EncodingManager.create(ghLocation);
++	if (encodingManager == null)
++	    encodingManager = EncodingManager.create(ghLocation);
+ 
+-        if (!allowWrites && dataAccessType.isMMap())
+-            dataAccessType = DAType.MMAP_RO;
++	if (!allowWrites && dataAccessType.isMMap())
++	    dataAccessType = DAType.MMAP_RO;
+ 
+-        GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
+-        if (chEnabled) {
+-            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
+-        }
+-        else if (encodingManager.needsTurnCostsSupport()) {
+-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostStorage());
+-        }
+-        else {
+-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
+-        }
+-        
+-        graph.setSegmentSize(defaultSegmentSize);
++	GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
++	if (chEnabled)
++	    graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
++	else if (encodingManager.needsTurnCostsSupport())
++	    graph = new GraphHopperStorage(dir, encodingManager, hasElevation(),
++			    new TurnCostStorage());
++	else
++	    graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
+ 
+-        Lock lock = null;
+-        try
+-        {
+-            // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
+-            // (e.g. on a read only filesystem locks would fail)
+-            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+-            {
+-                lockFactory.setLockDir(new File(ghLocation));
+-                lock = lockFactory.create(fileLockName, false);
+-                if (!lock.tryLock())
+-                    throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
+-            }
++	graph.setSegmentSize(defaultSegmentSize);
+ 
+-            if (!graph.loadExisting())
+-                return false;
++	Lock lock = null;
++	try
++	{
++	    // create locks only if writes are allowed, if they are not allowed
++	    // a lock cannot be created
++	    // (e.g. on a read only filesystem locks would fail)
++	    if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
++	    {
++		lockFactory.setLockDir(new File(ghLocation));
++		lock = lockFactory.create(fileLockName, false);
++		if (!lock.tryLock())
++		    throw new RuntimeException(
++				    "To avoid reading partial data we need to obtain the read lock but it failed. In "
++						    + ghLocation, lock.getObtainFailedReason());
++	    }
+ 
+-            postProcessing();
+-            fullyLoaded = true;
+-            return true;
+-        } finally
+-        {
+-            if (lock != null)
+-                lock.release();
+-        }
++	    if (!graph.loadExisting())
++		return false;
++
++	    postProcessing();
++	    fullyLoaded = true;
++	    return true;
++	} finally
++	{
++	    if (lock != null)
++		lock.release();
++	}
+     }
+ 
+     /**
+@@ -795,32 +803,30 @@
+      */
+     protected void postProcessing()
+     {
+-        encodingManager = graph.getEncodingManager();
+-        if (chEnabled)
+-            initCHPrepare();
++	encodingManager = graph.getEncodingManager();
++	if (chEnabled)
++	    initCHPrepare();
+ 
+-        if (!isPrepared())
+-            prepare();
+-        initLocationIndex();
++	if (!isPrepared())
++	    prepare();
++	initLocationIndex();
+     }
+ 
+     private boolean isPrepared()
+     {
+-        return "true".equals(graph.getProperties().get("prepare.done"));
++	return "true".equals(graph.getProperties().get("prepare.done"));
+     }
+ 
+     protected void initCHPrepare()
+     {
+-        FlagEncoder encoder = encodingManager.getSingle();
+-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
+-                createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
+-        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
+-                setLazyUpdates(lazyUpdates).
+-                setNeighborUpdates(neighborUpdates).
+-                setLogMessages(logMessages);
++	FlagEncoder encoder = encodingManager.getSingle();
++	PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
++			createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
++	tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
++			.setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
+ 
+-        prepare = tmpPrepareCH;
+-        prepare.setGraph(graph);
++	prepare = tmpPrepareCH;
++	prepare.setGraph(graph);
+     }
+ 
+     /**
+@@ -828,193 +834,196 @@
+      * created. Note that all URL parameters are available in the weightingParameters as String if
+      * you use the GraphHopper Web module.
+      * <p>
++     * 
+      * @see Weighting.Params.create
+-     * @param wMap all parameters influencing the weighting. E.g. URL parameters coming via
+-     * GHRequest
+-     * @param encoder the required vehicle
++     * @param wMap
++     *            all parameters influencing the weighting. E.g. URL parameters coming via GHRequest
++     * @param encoder
++     *            the required vehicle
+      * @return the weighting to be used for route calculation
+      */
+-    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )
++    public Weighting createWeighting(WeightingMap wMap, FlagEncoder encoder)
+     {
+-        String weighting = wMap.getWeighting();
+-        Weighting result;
++	String weighting = wMap.getWeighting();
++	Weighting result;
+ 
+-        if ("shortest".equalsIgnoreCase(weighting))
+-        {
+-            result = new ShortestWeighting();
+-        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
+-        {
+-            if (encoder.supports(PriorityWeighting.class))
+-                result = new PriorityWeighting(encoder);
+-            else
+-                result = new FastestWeighting(encoder);
+-        } else
+-        {
+-            throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+-        }
++	if ("shortest".equalsIgnoreCase(weighting))
++	    result = new ShortestWeighting();
++	else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
++	{
++	    if (encoder.supports(PriorityWeighting.class))
++		result = new PriorityWeighting(encoder);
++	    else
++		result = new FastestWeighting(encoder);
++	} else
++	    throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+ 
+-        if (encoder.supports(TurnWeighting.class))
+-        {
+-            result = new TurnWeighting(result, encoder, (TurnCostStorage) graph.getExtendedStorage());
+-        }
+-        return result;
++	if (encoder.supports(TurnWeighting.class))
++	    result = new TurnWeighting(result, encoder,
++			    (TurnCostStorage) graph.getExtendedStorage());
++	return result;
+     }
+ 
+     @Override
+-    public GHResponse route( GHRequest request )
++    public GHResponse route(GHRequest request)
+     {
+-        if (graph == null || !fullyLoaded)
+-            throw new IllegalStateException("Call load or importOrLoad before routing");
++	if (graph == null || !fullyLoaded)
++	    throw new IllegalStateException("Call load or importOrLoad before routing");
+ 
+-        if (graph.isClosed())
+-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
++	if (graph.isClosed())
++	    throw new IllegalStateException(
++			    "You need to create a new GraphHopper instance as it is already closed");
+ 
+-        GHResponse response = new GHResponse();
+-        List<Path> paths = getPaths(request, response);
+-        if (response.hasErrors())
+-            return response;
++	GHResponse response = new GHResponse();
++	List<Path> paths = getPaths(request, response);
++	if (response.hasErrors())
++	    return response;
+ 
+-        enableInstructions = request.getHints().getBool("instructions", enableInstructions);
+-        calcPoints = request.getHints().getBool("calcPoints", calcPoints);
+-        double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
+-        Locale locale = request.getLocale();
+-        DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
++	enableInstructions = request.getHints().getBool("instructions", enableInstructions);
++	calcPoints = request.getHints().getBool("calcPoints", calcPoints);
++	double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
++	Locale locale = request.getLocale();
++	DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
+ 
+-        new PathMerger().
+-                setCalcPoints(calcPoints).
+-                setDouglasPeucker(peucker).
+-                setEnableInstructions(enableInstructions).
+-                setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).
+-                doWork(response, paths, trMap.getWithFallBack(locale));
+-        return response;
++	new PathMerger().setCalcPoints(calcPoints).setDouglasPeucker(peucker)
++			.setEnableInstructions(enableInstructions)
++			.setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
++			.doWork(response, paths, trMap.getWithFallBack(locale));
++	return response;
+     }
+ 
+-    protected List<Path> getPaths( GHRequest request, GHResponse rsp )
++    protected List<Path> getPaths(GHRequest request, GHResponse rsp)
+     {
+-        String vehicle = request.getVehicle();
+-        if (vehicle.isEmpty())
+-            vehicle = encodingManager.getSingle().toString();
++	String vehicle = request.getVehicle();
++	if (vehicle.isEmpty())
++	    vehicle = encodingManager.getSingle().toString();
+ 
+-        if (!encodingManager.supports(vehicle))
+-        {
+-            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
+-                    + "Supported are: " + getEncodingManager()));
+-            return Collections.emptyList();
+-        }
++	if (!encodingManager.supports(vehicle))
++	{
++	    rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
++			    + "Supported are: " + getEncodingManager()));
++	    return Collections.emptyList();
++	}
+ 
+-        TraversalMode tMode;
+-        String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
+-        try
+-        {
+-            tMode = TraversalMode.fromString(tModeStr);
+-        } catch (Exception ex)
+-        {
+-            rsp.addError(ex);
+-            return Collections.emptyList();
+-        }
++	TraversalMode tMode;
++	String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
++	try
++	{
++	    tMode = TraversalMode.fromString(tModeStr);
++	} catch (Exception ex)
++	{
++	    rsp.addError(ex);
++	    return Collections.emptyList();
++	}
+ 
+-        List<GHPoint> points = request.getPoints();
+-        if (points.size() < 2)
+-        {
+-            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
+-            return Collections.emptyList();
+-        }
++	List<GHPoint> points = request.getPoints();
++	if (points.size() < 2)
++	{
++	    rsp.addError(new IllegalStateException(
++			    "At least 2 points has to be specified, but was:" + points.size()));
++	    return Collections.emptyList();
++	}
+ 
+-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+-        GHPoint startPoint = points.get(0);
+-        StopWatch sw = new StopWatch().start();
+-        QueryResult fromRes = locationIndex.findClosest(startPoint.lat, startPoint.lon, edgeFilter);
+-        String debug = "idLookup[0]:" + sw.stop().getSeconds() + "s";
+-        sw.stop();
+-        if (!fromRes.isValid())
+-        {
+-            rsp.addError(new IllegalArgumentException("Cannot find point 0: " + startPoint));
+-            return Collections.emptyList();
+-        }
++	FlagEncoder encoder = encodingManager.getEncoder(vehicle);
++	EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
++	GHPoint startPoint = points.get(0);
++	StopWatch sw = new StopWatch().start();
++	QueryResult fromRes = locationIndex.findClosest(startPoint.lat, startPoint.lon, edgeFilter);
++	String debug = "idLookup[0]:" + sw.stop().getSeconds() + "s";
++	sw.stop();
++	if (!fromRes.isValid())
++	{
++	    rsp.addError(new IllegalArgumentException("Cannot find point 0: " + startPoint));
++	    return Collections.emptyList();
++	}
+ 
+-        List<Path> paths = new ArrayList<Path>(points.size() - 1);
+-        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
+-        {
+-            GHPoint point = points.get(placeIndex);
+-            sw = new StopWatch().start();
+-            QueryResult toRes = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+-            debug += ", [" + placeIndex + "] idLookup:" + sw.stop().getSeconds() + "s";
+-            if (!toRes.isValid())
+-            {
+-                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
+-                break;
+-            }
++	List<Path> paths = new ArrayList<Path>(points.size() - 1);
++	for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
++	{
++	    GHPoint point = points.get(placeIndex);
++	    sw = new StopWatch().start();
++	    QueryResult toRes = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
++	    debug += ", [" + placeIndex + "] idLookup:" + sw.stop().getSeconds() + "s";
++	    if (!toRes.isValid())
++	    {
++		rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": "
++				+ point));
++		break;
++	    }
+ 
+-            sw = new StopWatch().start();
+-            String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi" : request.getAlgorithm();
+-            RoutingAlgorithm algo = null;
+-            if (chEnabled)
+-            {
+-                if (prepare == null)
+-                    throw new IllegalStateException("Preparation object is null. CH-preparation wasn't done or did you "
+-                            + "forget to call setCHEnable(false)?");
++	    sw = new StopWatch().start();
++	    String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi" : request
++			    .getAlgorithm();
++	    RoutingAlgorithm algo = null;
++	    if (chEnabled)
++	    {
++		if (prepare == null)
++		    throw new IllegalStateException(
++				    "Preparation object is null. CH-preparation wasn't done or did you "
++						    + "forget to call setCHEnable(false)?");
+ 
+-                if (algoStr.equals("dijkstrabi"))
+-                    algo = prepare.createAlgo();
+-                else if (algoStr.equals("astarbi"))
+-                    algo = ((PrepareContractionHierarchies) prepare).createAStar();
+-                else
+-                {
+-                    rsp.addError(new IllegalStateException(
+-                            "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
+-                    break;
+-                }
+-            } else
+-            {
+-                Weighting weighting = createWeighting(request.getHints(), encoder);
+-                prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, algoStr, encoder, weighting, tMode);
+-                algo = prepare.createAlgo();
+-            }
++		if (algoStr.equals("dijkstrabi"))
++		    algo = prepare.createAlgo();
++		else if (algoStr.equals("astarbi"))
++		    algo = ((PrepareContractionHierarchies) prepare).createAStar();
++		else
++		{
++		    rsp.addError(new IllegalStateException(
++				    "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
++		    break;
++		}
++	    } else
++	    {
++		Weighting weighting = createWeighting(request.getHints(), encoder);
++		prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, algoStr, encoder,
++				weighting, tMode);
++		algo = prepare.createAlgo();
++	    }
+ 
+-            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
+-            sw = new StopWatch().start();
++	    debug += ", algoInit:" + sw.stop().getSeconds() + "s";
++	    sw = new StopWatch().start();
+ 
+-            Path path = algo.calcPath(fromRes, toRes);
+-            if (path.getMillis() < 0)
+-                throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
++	    Path path = algo.calcPath(fromRes, toRes);
++	    if (path.getMillis() < 0)
++		throw new RuntimeException("Time was negative. Please report as bug and include:"
++				+ request);
+ 
+-            paths.add(path);
+-            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
+-            visitedSum.addAndGet(algo.getVisitedNodes());
+-            fromRes = toRes;
+-        }
++	    paths.add(path);
++	    debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, "
++			    + path.getDebugInfo();
++	    visitedSum.addAndGet(algo.getVisitedNodes());
++	    fromRes = toRes;
++	}
+ 
+-        if (rsp.hasErrors())
+-            return Collections.emptyList();
++	if (rsp.hasErrors())
++	    return Collections.emptyList();
+ 
+-        if (points.size() - 1 != paths.size())
+-            throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
++	if (points.size() - 1 != paths.size())
++	    throw new RuntimeException(
++			    "There should be exactly one more places than paths. places:"
++					    + points.size() + ", paths:" + paths.size());
+ 
+-        rsp.setDebugInfo(debug);
+-        return paths;
++	rsp.setDebugInfo(debug);
++	return paths;
+     }
+ 
+-    protected LocationIndex createLocationIndex( Directory dir )
++    protected LocationIndex createLocationIndex(Directory dir)
+     {
+-        LocationIndex tmpIndex;
+-        if (graph instanceof LevelGraph)
+-        {
+-            tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
+-        } else
+-        {
+-            tmpIndex = new LocationIndexTree(graph, dir);
+-        }
+-        tmpIndex.setResolution(preciseIndexResolution);
+-        ((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
++	LocationIndex tmpIndex;
++	if (graph instanceof LevelGraph)
++	    tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
++	else
++	    tmpIndex = new LocationIndexTree(graph, dir);
++	tmpIndex.setResolution(preciseIndexResolution);
++	((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
+ 
+-        if (!tmpIndex.loadExisting())
+-        {
+-            ensureWriteAccess();
+-            tmpIndex.prepareIndex();
+-        }
++	if (!tmpIndex.loadExisting())
++	{
++	    ensureWriteAccess();
++	    tmpIndex.prepareIndex();
++	}
+ 
+-        return tmpIndex;
++	return tmpIndex;
+     }
+ 
+     /**
+@@ -1025,69 +1034,77 @@
+      */
+     protected void initLocationIndex()
+     {
+-        if (locationIndex != null)
+-            throw new IllegalStateException("Cannot initialize locationIndex twice!");
++	if (locationIndex != null)
++	    throw new IllegalStateException("Cannot initialize locationIndex twice!");
+ 
+-        locationIndex = createLocationIndex(graph.getDirectory());
++	locationIndex = createLocationIndex(graph.getDirectory());
+     }
+ 
+     protected void optimize()
+     {
+-        logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
+-        graph.optimize();
+-        logger.info("finished optimize (" + Helper.getMemInfo() + ")");
++	logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
++	graph.optimize();
++	logger.info("finished optimize (" + Helper.getMemInfo() + ")");
+ 
+-        // Later: move this into the GraphStorage.optimize method
+-        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
+-        if (sortGraph)
+-        {
+-            if (graph instanceof LevelGraph && isPrepared())
+-                throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
++	// Later: move this into the GraphStorage.optimize method
++	// Or: Doing it after preparation to optimize shortcuts too. But not
++	// possible yet #12
++	if (sortGraph)
++	{
++	    if (graph instanceof LevelGraph && isPrepared())
++		throw new IllegalArgumentException(
++				"Sorting prepared LevelGraph is not possible yet. See #12");
+ 
+-            GraphStorage newGraph = GHUtility.newStorage(graph);
+-            GHUtility.sortDFS(graph, newGraph);
+-            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
+-            graph = newGraph;
+-        }
++	    GraphStorage newGraph = GHUtility.newStorage(graph);
++	    GHUtility.sortDFS(graph, newGraph);
++	    logger.info("graph sorted (" + Helper.getMemInfo() + ")");
++	    graph = newGraph;
++	}
+     }
+ 
+     protected void prepare()
+     {
+-        boolean tmpPrepare = doPrepare && prepare != null;
+-        if (tmpPrepare)
+-        {
+-            ensureWriteAccess();
+-            if (prepare instanceof PrepareContractionHierarchies && encodingManager.getVehicleCount() > 1)
+-                throw new IllegalArgumentException("Contraction hierarchies preparation "
+-                        + "requires (at the moment) only one vehicle. But was:" + encodingManager);
++	boolean tmpPrepare = doPrepare && prepare != null;
++	if (tmpPrepare)
++	{
++	    ensureWriteAccess();
++	    if (prepare instanceof PrepareContractionHierarchies
++			    && encodingManager.getVehicleCount() > 1)
++		throw new IllegalArgumentException("Contraction hierarchies preparation "
++				+ "requires (at the moment) only one vehicle. But was:"
++				+ encodingManager);
+ 
+-            logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... (" + Helper.getMemInfo() + ")");
+-            prepare.doWork();
+-            graph.getProperties().put("prepare.date", formatDateTime(new Date()));
+-        }
+-        graph.getProperties().put("prepare.done", tmpPrepare);
++	    logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... ("
++			    + Helper.getMemInfo() + ")");
++	    prepare.doWork();
++	    graph.getProperties().put("prepare.date", formatDateTime(new Date()));
++	}
++	graph.getProperties().put("prepare.done", tmpPrepare);
+     }
+ 
+     protected void cleanUp()
+     {
+-        int prev = graph.getNodes();
+-        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
+-        preparation.setMinNetworkSize(minNetworkSize);
+-        preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
+-        logger.info("start finding subnetworks, " + Helper.getMemInfo());
+-        preparation.doWork();
+-        int n = graph.getNodes();
+-        // calculate remaining subnetworks
+-        int remainingSubnetworks = preparation.findSubnetworks().size();
+-        logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
+-                + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
++	int prev = graph.getNodes();
++	PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph,
++			encodingManager);
++	preparation.setMinNetworkSize(minNetworkSize);
++	preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
++	logger.info("start finding subnetworks, " + Helper.getMemInfo());
++	preparation.doWork();
++	int n = graph.getNodes();
++	// calculate remaining subnetworks
++	int remainingSubnetworks = preparation.findSubnetworks().size();
++	logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were "
++			+ preparation.getSubNetworks() + " subnetworks. removed them => "
++			+ (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+     }
+ 
+     protected void flush()
+     {
+-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
+-        graph.flush();
+-        fullyLoaded = true;
++	logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString()
++			+ ", " + Helper.getMemInfo() + ")");
++	graph.flush();
++	fullyLoaded = true;
+     }
+ 
+     /**
+@@ -1096,19 +1113,20 @@
+      */
+     public void close()
+     {
+-        if (graph != null)
+-            graph.close();
++	if (graph != null)
++	    graph.close();
+ 
+-        if (locationIndex != null)
+-            locationIndex.close();
++	if (locationIndex != null)
++	    locationIndex.close();
+ 
+-        try
+-        {
+-            lockFactory.forceRemove(fileLockName, true);
+-        } catch (Exception ex)
+-        {
+-            // silently fail e.g. on Windows where we cannot remove an unreleased native lock
+-        }
++	try
++	{
++	    lockFactory.forceRemove(fileLockName, true);
++	} catch (Exception ex)
++	{
++	    // silently fail e.g. on Windows where we cannot remove an
++	    // unreleased native lock
++	}
+     }
+ 
+     /**
+@@ -1117,30 +1135,32 @@
+      */
+     public void clean()
+     {
+-        if (getGraphHopperLocation().isEmpty())
+-            throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
++	if (getGraphHopperLocation().isEmpty())
++	    throw new IllegalStateException(
++			    "Cannot clean GraphHopper without specified graphHopperLocation");
+ 
+-        File folder = new File(getGraphHopperLocation());
+-        Helper.removeDir(folder);
++	File folder = new File(getGraphHopperLocation());
++	Helper.removeDir(folder);
+     }
+ 
+     // make sure this is identical to buildDate used in pom.xml
+     // <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
+-    private String formatDateTime( Date date )
++    private String formatDateTime(Date date)
+     {
+-        return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
++	return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
+     }
+ 
+     protected void ensureNotLoaded()
+     {
+-        if (fullyLoaded)
+-            throw new IllegalStateException("No configuration changes are possible after loading the graph");
++	if (fullyLoaded)
++	    throw new IllegalStateException(
++			    "No configuration changes are possible after loading the graph");
+     }
+ 
+     protected void ensureWriteAccess()
+     {
+-        if (!allowWrites)
+-            throw new IllegalStateException("Writes are not allowed!");
++	if (!allowWrites)
++	    throw new IllegalStateException("Writes are not allowed!");
+     }
+ 
+     /**
+@@ -1149,6 +1169,6 @@
+      */
+     public long getVisitedSum()
+     {
+-        return visitedSum.get();
++	return visitedSum.get();
+     }
+ }
+Index: core/src/main/java/com/graphhopper/reader/Way.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/Way.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/Way.java	(working copy)
+@@ -1,11 +1,5 @@
+ package com.graphhopper.reader;
+ 
+-import gnu.trove.list.TLongList;
+-
+-
+ public interface Way extends RoutingElement {
+ 
+-	TLongList getNodes();
+-
+-
+ }
+Index: core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java	(working copy)
+@@ -17,8 +17,9 @@
+  */
+ package com.graphhopper.reader.osgb.dpn;
+ 
+-import gnu.trove.list.TLongList;
+-import gnu.trove.list.array.TLongArrayList;
++import gnu.trove.map.TDoubleLongMap;
++import gnu.trove.map.TDoubleObjectMap;
++import gnu.trove.map.TLongObjectMap;
+ 
+ import java.util.ArrayList;
+ import java.util.Arrays;
+@@ -34,8 +35,6 @@
+ import org.slf4j.LoggerFactory;
+ 
+ import com.graphhopper.reader.Way;
+-import com.graphhopper.reader.osgb.OSITNNode;
+-import com.graphhopper.reader.osgb.OSITNWay;
+ 
+ /**
+  * Represents an OSM Way
+@@ -43,111 +42,176 @@
+  * 
+  * @author Nop
+  */
+-public class OsDpnWay extends OSITNWay implements Way {
+-	private static final long WAY_NODE_PREFIX_MOD = 100000000000000000L;
+-	private long endNode;
+-	private static final Logger logger = LoggerFactory
+-			.getLogger(OsDpnWay.class);
++public class OsDpnWay extends OsDpnElement implements Way {
++    private static final long WAY_NODE_PREFIX_MOD = 100000000000000000L;
++    protected final List<String> nodes = new ArrayList<String>(5);
++    private String endNode;
++    protected String startCoord;
++    protected String endCoord;
++    private String[] wayCoords;
++    private static final Logger logger = LoggerFactory
++            .getLogger(OsDpnWay.class);
++
++    /**
++     * Constructor for XML Parser
++     * 
++     * @throws TransformException
++     * @throws FactoryException
++     * @throws MismatchedDimensionException
++     */
++    public static OsDpnWay create(String idStr, XMLStreamReader parser)
++            throws XMLStreamException, MismatchedDimensionException,
++            FactoryException, TransformException {
++        System.out.println("OsDpnWay.create()");
++        OsDpnWay way = new OsDpnWay(idStr);
++        parser.nextTag();
++        way.readTags(parser);
++        way.setTag("highway", "motorway");
++        logger.info(way.toString());
++        return way;
++    }
++
++    public OsDpnWay(String id) {
++        super(id, WAY);
++    }
++
++    public List<String> getNodes() {
++        return nodes;
++    }
+ 
+-	/**
+-	 * Constructor for XML Parser
+-	 * @throws TransformException 
+-	 * @throws FactoryException 
+-	 * @throws MismatchedDimensionException 
+-	 */
+-	public static OsDpnWay create(long id, XMLStreamReader parser)
+-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+-		OsDpnWay way = new OsDpnWay(id);
+-		parser.nextTag();
+-		way.readTags(parser);
+-		way.setTag("highway", "motorway");
+-		logger.info(way.toString());
+-		return way;
+-	}
++    @Override
++    protected void parseCoords(String lineDefinition) {
++        String[] lineSegments = lineDefinition.split(" ");
++        wayCoords = Arrays
++                .copyOfRange(lineSegments, 1, lineSegments.length - 1);
++        logger.info(toString() + " "
++                + ((wayCoords.length == 0) ? "0" : wayCoords[0]));
++    }
+ 
+-	public OsDpnWay(long id) {
+-		super(id);
+-	}
++    @Override
++    protected void parseCoords(int dimensions, String lineDefinition) {
++        String[] lineSegments = lineDefinition.split(" ");
++        wayCoords = new String[lineSegments.length / dimensions];
++        StringBuilder curString = null;
++        for (int i = 0; i < lineSegments.length; i++) {
++            String string = lineSegments[i];
++            switch (i % dimensions) {
++                case 0: {
++                    int coordNumber = i / dimensions;
++                    if (coordNumber > 0) {
++                        wayCoords[coordNumber - 1] = curString.toString();
++                    }
++                    curString = new StringBuilder();
++                    curString.append(string);
++                    break;
++                }
+ 
+-	@Override
+-	protected void parseCoords(String lineDefinition) {
+-		String[] lineSegments = lineDefinition.split(" ");
+-		wayCoords = Arrays
+-				.copyOfRange(lineSegments, 1, lineSegments.length -1);
+-		logger.info(toString() + " "  + ((wayCoords.length == 0)?"0":wayCoords[0]));
+-	}
+-	
+-	@Override
+-	protected void parseCoords(int dimensions, String lineDefinition) {
+-		String[] lineSegments = lineDefinition.split(" ");
+-		wayCoords = new String[lineSegments.length/dimensions];
+-		StringBuilder curString = null;
+-		for (int i = 0; i < lineSegments.length; i++) {
+-			String string = lineSegments[i];
+-			switch (i % dimensions) {
+-			case 0: {
+-				int coordNumber = i/dimensions;
+-				if(coordNumber >0) {
+-					wayCoords[coordNumber-1] = curString.toString();
+-				}
+-				curString = new StringBuilder();
+-				curString.append(string);
+-				break;
+-			}
+-					
+-			case 1:	
+-			case 2: {
+-				curString.append(',');
+-				curString.append(string); 
+-			}
+-			}
+-		}
+-		wayCoords[wayCoords.length-1] = curString.toString();
+-		addWayNodes();
+-		nodes.add(endNode);
+-		logger.info(toString() + " "  + ((wayCoords.length == 0)?"0":wayCoords[0]));
+-	}
+-	@Override
+-	protected void parseNetworkMember(String elementText) {
+-		throw new UnsupportedOperationException();
+-	}
++                case 1:
++                case 2: {
++                    curString.append(',');
++                    curString.append(string);
++                }
++            }
++        }
++        wayCoords[wayCoords.length - 1] = curString.toString();
++        addWayNodes();
++        nodes.add(endNode);
++        logger.info(toString() + " "
++                + ((wayCoords.length == 0) ? "0" : wayCoords[0]));
++    }
+ 
+-	@Override
+-	protected void addDirectedNode(String nodeId, String grade,
+-			String orientation) {
+-		String idStr = nodeId.substring(5);
+-		if (null != grade) {
+-			idStr = grade + idStr;
+-		}
+-		long id = Long.parseLong(idStr);
++    @Override
++    protected void parseNetworkMember(String elementText) {
++        throw new UnsupportedOperationException();
++    }
+ 
+-		if (0 == nodes.size()) {
+-			nodes.add(id);
+-		} else {
+-			endNode = id;
+-		}
+-	}
++    @Override
++    protected void addNode(String nodeId) {
++        String idStr = nodeId.substring(1);
++        if (0 == nodes.size()) {
++            nodes.add(idStr);
++        } else {
++            endNode = idStr;
++        }
++    }
+ 
+-	@Override
+-	protected void addDirectedLink(String nodeId, String orientation) {
+-		throw new UnsupportedOperationException();
+-	}
++    protected void addWayNodes() {
++        for (int i = 1; i <= wayCoords.length; i++) {
++            long idPrefix = i;
++            String extraId = idPrefix + getId();
++            nodes.add(extraId);
++        }
++    }
+ 
+-	public List<OSITNNode> evaluateWayNodes() throws MismatchedDimensionException, FactoryException, TransformException {
+-		List<OSITNNode> wayNodes = new ArrayList<OSITNNode>();
++    @Override
++    protected void addDirectedLink(String nodeId, String orientation) {
++        throw new UnsupportedOperationException();
++    }
+ 
+-		for (int i = 0; i < wayCoords.length; i++) {
+-			String wayCoord = wayCoords[i];
+-			long idPrefix = (i+1) * WAY_NODE_PREFIX_MOD;
+-			long id = idPrefix + getId();
+-			OSITNNode wayNode = new OSITNNode(id);
+-			wayNode.parseCoordinateString(wayCoord, ",");
+-			wayNodes.add(wayNode);
+-		}
+-		return wayNodes;
+-	}
++    /**
++     * Creates a new OsDpnNode for each wayCoord. This also Looks for direction
++     * flags in edgeIdToXToYToNodeFlagsMap for the wayId, x, y combination. If
++     * it exists then set the node tag TAG_KEY_NOENTRY_ORIENTATION to true and
++     * the TAG_KEY_ONEWAY_ORIENTATION node tag to -1 for one direction and true
++     * for the other.
++     * 
++     * @param edgeIdToXToYToNodeFlagsMap
++     * @return
++     * @throws TransformException
++     * @throws FactoryException
++     * @throws MismatchedDimensionException
++     */
++    public List<OsDpnNode> evaluateWayNodes(
++            TLongObjectMap<TDoubleObjectMap<TDoubleLongMap>> edgeIdToXToYToNodeFlagsMap)
++            throws MismatchedDimensionException, FactoryException,
++            TransformException {
++        List<OsDpnNode> wayNodes = new ArrayList<OsDpnNode>();
+ 
+-	public void clearWayNodes() {
+-		wayCoords = null;
+-	}
++        for (int i = 0; i < wayCoords.length; i++) {
++            String wayCoord = wayCoords[i];
++
++            long idPrefix = (i + 1) * WAY_NODE_PREFIX_MOD;
++            String id = idPrefix + getId();
++            OsDpnNode wayNode = new OsDpnNode(id);
++            wayNode.parseCoords(wayCoord);
++
++            logger.info("Node " + getId() + " coords: " + wayCoord + " tags: ");
++            for (String tagKey : wayNode.getTags().keySet()) {
++                logger.info("\t " + tagKey + " : " + wayNode.getTag(tagKey));
++            }
++
++            wayNodes.add(wayNode);
++        }
++        return wayNodes;
++    }
++
++    /**
++     * Memory management method. Once a way is processed the stored string
++     * coordinates are no longer required so set them to null so they can be
++     * garbage collected
++     */
++    public void clearStoredCoords() {
++        wayCoords = null;
++        startCoord = null;
++        endCoord = null;
++    }
++
++    public String[] getWayCoords() {
++        return wayCoords;
++    }
++
++    public String getStartCoord() {
++        return startCoord;
++    }
++
++    public String getEndCoord() {
++        return endCoord;
++    }
++
++    protected void parseCoordinateString(String elementText,
++            String elementSeparator) {
++        throw new UnsupportedOperationException();
++
++    }
++
+ }
+Index: core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java
+===================================================================
+--- core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java	(revision 2400)
++++ core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java	(working copy)
+@@ -43,7 +43,6 @@
+ import org.slf4j.LoggerFactory;
+ 
+ import com.graphhopper.reader.RoutingElement;
+-import com.graphhopper.reader.osgb.dpn.OsDpnWay;
+ import com.graphhopper.reader.pbf.Sink;
+ 
+ /**
+@@ -53,223 +52,222 @@
+  * @author Stuart Adam
+  */
+ public class OsItnInputFile implements Sink, Closeable {
+-	private boolean eof;
+-	private InputStream bis;
+-	// for xml parsing
+-	private XMLStreamReader parser;
+-	// for pbf parsing
+-	private boolean binary = false;
+-	private final BlockingQueue<RoutingElement> itemQueue;
+-	private boolean hasIncomingData;
+-	private int workerThreads = -1;
+-	private static final Logger logger = LoggerFactory
+-			.getLogger(OsItnInputFile.class);
+-	private String name;
++    private boolean eof;
++    private final InputStream bis;
++    // for xml parsing
++    private XMLStreamReader parser;
++    // for pbf parsing
++    private boolean binary = false;
++    private final BlockingQueue<RoutingElement> itemQueue;
++    private boolean hasIncomingData;
++    private int workerThreads = -1;
++    private static final Logger logger = LoggerFactory
++            .getLogger(OsItnInputFile.class);
++    private final String name;
++
++    public OsItnInputFile(File file) throws IOException {
++        name = file.getAbsolutePath();
++        bis = decode(file);
++        itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
++    }
+ 
+-	public OsItnInputFile(File file) throws IOException {
+-		name = file.getAbsolutePath();
+-		bis = decode(file);
+-		itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
+-	}
++    public OsItnInputFile open() throws XMLStreamException {
++        openXMLStream(bis);
++        return this;
++    }
+ 
+-	public OsItnInputFile open() throws XMLStreamException {
+-		openXMLStream(bis);
+-		return this;
+-	}
+-	
+-	public InputStream getInputStream() {
+-		return bis;
+-	}
++    public InputStream getInputStream() {
++        return bis;
++    }
+ 
+-	/**
+-	 * Currently on for pbf format. Default is number of cores.
+-	 */
+-	public OsItnInputFile setWorkerThreads(int num) {
+-		workerThreads = num;
+-		return this;
+-	}
++    /**
++     * Currently on for pbf format. Default is number of cores.
++     */
++    public OsItnInputFile setWorkerThreads(int num) {
++        workerThreads = num;
++        return this;
++    }
+ 
+-	@SuppressWarnings("unchecked")
+-	private InputStream decode(File file) throws IOException {
+-		final String name = file.getName();
++    @SuppressWarnings("unchecked")
++    private InputStream decode(File file) throws IOException {
++        final String name = file.getName();
+ 
+-		InputStream ips = null;
+-		try {
+-			ips = new BufferedInputStream(new FileInputStream(file), 50000);
+-		} catch (FileNotFoundException e) {
+-			throw new RuntimeException(e);
+-		}
+-		ips.mark(10);
++        InputStream ips = null;
++        try {
++            ips = new BufferedInputStream(new FileInputStream(file), 50000);
++        } catch (FileNotFoundException e) {
++            throw new RuntimeException(e);
++        }
++        ips.mark(10);
+ 
+-		// check file header
+-		byte header[] = new byte[6];
+-		ips.read(header);
++        // check file header
++        byte header[] = new byte[6];
++        ips.read(header);
+ 
+-		/*
+-		 * can parse bz2 directly with additional lib if (header[0] == 'B' &&
+-		 * header[1] == 'Z') { return new CBZip2InputStream(ips); }
+-		 */
+-		if (header[0] == 31 && header[1] == -117) {
+-			ips.reset();
+-			return new GZIPInputStream(ips, 50000);
+-		} else if (header[0] == 0 && header[1] == 0 && header[2] == 0
+-				&& header[4] == 10 && header[5] == 9
+-				&& (header[3] == 13 || header[3] == 14)) {
+-			ips.reset();
+-			binary = true;
+-			return ips;
+-		} else if (header[0] == 'P' && header[1] == 'K') {
+-			ips.reset();
+-			ZipInputStream zip = new ZipInputStream(ips);
+-			zip.getNextEntry();
++        /*
++         * can parse bz2 directly with additional lib if (header[0] == 'B' &&
++         * header[1] == 'Z') { return new CBZip2InputStream(ips); }
++         */
++        if (header[0] == 31 && header[1] == -117) {
++            ips.reset();
++            return new GZIPInputStream(ips, 50000);
++        } else if (header[0] == 0 && header[1] == 0 && header[2] == 0
++                && header[4] == 10 && header[5] == 9
++                && (header[3] == 13 || header[3] == 14)) {
++            ips.reset();
++            binary = true;
++            return ips;
++        } else if (header[0] == 'P' && header[1] == 'K') {
++            ips.reset();
++            ZipInputStream zip = new ZipInputStream(ips);
++            zip.getNextEntry();
+ 
+-			return zip;
+-		} else if (name.endsWith(".gml") || name.endsWith(".xml")) {
+-			ips.reset();
+-			return ips;
+-		} else if (header[0] == 60 && header[1] == 63 && header[3] == 120
+-				&& header[4] == 109 && header[5] == 108) {
+-			ips.reset();
+-			return ips;
+-		} else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
+-			String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
+-			try {
+-				Class clazz = Class.forName(clName);
+-				ips.reset();
+-				Constructor<InputStream> ctor = clazz.getConstructor(
+-						InputStream.class, boolean.class);
+-				return ctor.newInstance(ips, true);
+-			} catch (Exception e) {
+-				throw new IllegalArgumentException("Cannot instantiate "
+-						+ clName, e);
+-			}
+-		} else {
+-			throw new IllegalArgumentException(
+-					"Input file is not of valid type " + file.getPath());
+-		}
+-	}
++            return zip;
++        } else if (name.endsWith(".gml") || name.endsWith(".xml")) {
++            ips.reset();
++            return ips;
++        } else if (header[0] == 60 && header[1] == 63 && header[3] == 120
++                && header[4] == 109 && header[5] == 108) {
++            ips.reset();
++            return ips;
++        } else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
++            String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
++            try {
++                Class clazz = Class.forName(clName);
++                ips.reset();
++                Constructor<InputStream> ctor = clazz.getConstructor(
++                        InputStream.class, boolean.class);
++                return ctor.newInstance(ips, true);
++            } catch (Exception e) {
++                throw new IllegalArgumentException("Cannot instantiate "
++                        + clName, e);
++            }
++        } else {
++            throw new IllegalArgumentException(
++                    "Input file is not of valid type " + file.getPath());
++        }
++    }
+ 
+-	private void openXMLStream(InputStream in) throws XMLStreamException {
+-		XMLInputFactory factory = XMLInputFactory.newInstance();
+-		parser = factory.createXMLStreamReader(bis, "UTF-8");
+-		int event;
+-		do {
+-			event = parser.next();
+-		} while (event == XMLStreamConstants.COMMENT);
++    private void openXMLStream(InputStream in) throws XMLStreamException {
++        XMLInputFactory factory = XMLInputFactory.newInstance();
++        parser = factory.createXMLStreamReader(bis, "UTF-8");
++        int event;
++        do {
++            event = parser.next();
++        } while (event == XMLStreamConstants.COMMENT);
+ 
+-		if (event != XMLStreamConstants.START_ELEMENT
+-				|| !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
+-			throw new IllegalArgumentException(String.format(
+-					"File %s not a valid OS ITN stream", name));
+-		}
++        if (event != XMLStreamConstants.START_ELEMENT
++                || !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
++            throw new IllegalArgumentException(String.format(
++                    "File %s not a valid OS ITN stream", name));
++        }
+ 
+-		eof = false;
+-	}
++        eof = false;
++    }
+ 
+-	public RoutingElement getNext() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+-		if (eof)
+-			throw new IllegalStateException("EOF reached");
++    public RoutingElement getNext() throws XMLStreamException,
++            MismatchedDimensionException, FactoryException, TransformException {
++        if (eof)
++            throw new IllegalStateException("EOF reached");
+ 
+-		RoutingElement item;
+-		item = getNextXML();
++        RoutingElement item;
++        item = getNextXML();
+ 
+-		if (item != null)
+-			return item;
++        if (item != null)
++            return item;
+ 
+-		eof = true;
+-		return null;
+-	}
++        eof = true;
++        return null;
++    }
+ 
+-	private OSITNElement getNextXML() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
++    private OSITNElement getNextXML() throws XMLStreamException,
++            MismatchedDimensionException, FactoryException, TransformException {
+ 
+-		int event = parser.next();
+-		while (event != XMLStreamConstants.END_DOCUMENT) {
+-			if (event == XMLStreamConstants.START_ELEMENT) {
+-				String idStr = parser.getAttributeValue(null, "fid");
+-				if (null == idStr) {
+-					idStr = parser.getAttributeValue(
+-							"http://www.opengis.net/gml/3.2", "id");
+-				}
+-				if (idStr != null) {
+-					String name = parser.getLocalName();
+-					idStr = idStr.substring(4);
+-					logger.info(idStr + ":" + name + ":");
++        int event = parser.next();
++        while (event != XMLStreamConstants.END_DOCUMENT) {
++            if (event == XMLStreamConstants.START_ELEMENT) {
++                String idStr = parser.getAttributeValue(null, "fid");
++                if (null == idStr) {
++                    idStr = parser.getAttributeValue(
++                            "http://www.opengis.net/gml/3.2", "id");
++                }
++                if (idStr != null) {
++                    String name = parser.getLocalName();
++                    idStr = idStr.substring(4);
++                    logger.info(idStr + ":" + name + ":");
+ 
+-					long id;
+-					try {
+-						id = Long.parseLong(idStr);
+-					} catch (NumberFormatException nfe) {
+-						BigDecimal bd = new BigDecimal(idStr);
+-						id = bd.longValue();
+-					}
+-					logger.info(id + ":" + name + ":");
+-					switch (name) {
+-					case "RoadNode":
+-					case "RouteNode": {
+-						return OSITNNode.create(id, parser);
+-					}
+-					case "RoadLink": {
+-						return OSITNWay.create(id, parser);
+-					}
+-					case "RouteLink": {
+-						return OsDpnWay.create(id, parser);
+-					}
+-					case "RoadRouteInformation": {
+-						return OSITNRelation.create(id, parser);
+-					}
++                    long id;
++                    try {
++                        id = Long.parseLong(idStr);
++                    } catch (NumberFormatException nfe) {
++                        BigDecimal bd = new BigDecimal(idStr);
++                        id = bd.longValue();
++                    }
++                    logger.info(id + ":" + name + ":");
++                    switch (name) {
++                        case "RoadNode": {
++                            return OSITNNode.create(id, parser);
++                        }
++                        case "RoadLink": {
++                            return OSITNWay.create(id, parser);
++                        }
+ 
+-					case "Road": {
+-						return OsItnMetaData.create(id, parser);
+-					}
+-					case "RoadLinkInformation": {
+-					}
+-					case "RoadNodeInformation": {
+-					}
+-					default: {
++                        case "RoadRouteInformation": {
++                            return OSITNRelation.create(id, parser);
++                        }
+ 
+-					}
++                        case "Road": {
++                            return OsItnMetaData.create(id, parser);
++                        }
++                        case "RoadLinkInformation": {
++                        }
++                        case "RoadNodeInformation": {
++                        }
++                        default: {
+ 
+-					}
+-				}
+-			}
+-			event = parser.next();
+-		}
+-		parser.close();
+-		return null;
+-	}
++                        }
+ 
+-	public boolean isEOF() {
+-		return eof;
+-	}
++                    }
++                }
++            }
++            event = parser.next();
++        }
++        parser.close();
++        return null;
++    }
+ 
+-	@Override
+-	public void close() throws IOException {
+-		try {
+-			if (!binary)
+-				parser.close();
+-		} catch (XMLStreamException ex) {
+-			throw new IOException(ex);
+-		} finally {
+-			eof = true;
+-			bis.close();
+-		}
+-	}
++    public boolean isEOF() {
++        return eof;
++    }
+ 
+-	@Override
+-	public void process(RoutingElement item) {
+-		try {
+-			// blocks if full
+-			itemQueue.put(item);
+-		} catch (InterruptedException ex) {
+-			throw new RuntimeException(ex);
+-		}
++    @Override
++    public void close() throws IOException {
++        try {
++            if (!binary)
++                parser.close();
++        } catch (XMLStreamException ex) {
++            throw new IOException(ex);
++        } finally {
++            eof = true;
++            bis.close();
++        }
++    }
+ 
+-		// throw exception if full
+-		// itemQueue.add(item);
+-	}
++    @Override
++    public void process(RoutingElement item) {
++        try {
++            // blocks if full
++            itemQueue.put(item);
++        } catch (InterruptedException ex) {
++            throw new RuntimeException(ex);
++        }
+ 
+-	@Override
+-	public void complete() {
+-		hasIncomingData = false;
+-	}
++        // throw exception if full
++        // itemQueue.add(item);
++    }
++
++    @Override
++    public void complete() {
++        hasIncomingData = false;
++    }
+ }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 1ce62609a9..73367faffc 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -36,6 +36,7 @@
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.reader.osgb.OsItnReader;
+import com.graphhopper.reader.osgb.dpn.OsDpnReader;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.RoutingAlgorithm;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
@@ -89,7 +90,7 @@
 public class GraphHopper implements GraphHopperAPI
 {
     private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM or OSITN";
-	private final Logger logger = LoggerFactory.getLogger(getClass());
+    private final Logger logger = LoggerFactory.getLogger(getClass());
     // for graph:
     private GraphStorage graph;
     private EncodingManager encodingManager;
@@ -128,11 +129,11 @@
     private double osmReaderWayPointMaxDistance = 1;
     private int workerThreads = -1;
     private boolean calcPoints = true;
-    // utils    
+    // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private final AtomicLong visitedSum = new AtomicLong(0);
-	private String dataReader = "OSM";
+    private String dataReader = "OSM";
 
     public GraphHopper()
     {
@@ -141,38 +142,38 @@ public GraphHopper()
     /**
      * For testing only
      */
-    protected GraphHopper loadGraph( GraphStorage g )
+    protected GraphHopper loadGraph(GraphStorage g)
     {
-        this.graph = g;
-        fullyLoaded = true;
-        initLocationIndex();
-        return this;
+	this.graph = g;
+	fullyLoaded = true;
+	initLocationIndex();
+	return this;
     }
 
     /**
      * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
      * how data from every vehicle is written (und read) into edges of the graph.
      */
-    public GraphHopper setEncodingManager( EncodingManager em )
+    public GraphHopper setEncodingManager(EncodingManager em)
     {
-        ensureNotLoaded();
-        this.encodingManager = em;
-        return this;
+	ensureNotLoaded();
+	this.encodingManager = em;
+	return this;
     }
 
     public EncodingManager getEncodingManager()
     {
-        return encodingManager;
+	return encodingManager;
     }
 
-    public GraphHopper setElevationProvider( ElevationProvider eleProvider )
+    public GraphHopper setElevationProvider(ElevationProvider eleProvider)
     {
-        if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
-            setElevation(false);
-        else
-            setElevation(true);
-        this.eleProvider = eleProvider;
-        return this;
+	if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
+	    setElevation(false);
+	else
+	    setElevation(true);
+	this.eleProvider = eleProvider;
+	return this;
     }
 
     /**
@@ -180,7 +181,7 @@ public GraphHopper setElevationProvider( ElevationProvider eleProvider )
      */
     protected int getWorkerThreads()
     {
-        return workerThreads;
+	return workerThreads;
     }
 
     /**
@@ -188,31 +189,31 @@ protected int getWorkerThreads()
      */
     protected double getWayPointMaxDistance()
     {
-        return osmReaderWayPointMaxDistance;
+	return osmReaderWayPointMaxDistance;
     }
 
     /**
      * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
      * value means more details, unit is meter. Default is 1. Disable via 0.
      */
-    public GraphHopper setWayPointMaxDistance( double wayPointMaxDistance )
+    public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance)
     {
-        this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
-        return this;
+	this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
+	return this;
     }
 
     /**
      * Sets the default traversal mode used for the algorithms and preparation.
      */
-    public GraphHopper setTraversalMode( TraversalMode traversalMode )
+    public GraphHopper setTraversalMode(TraversalMode traversalMode)
     {
-        this.traversalMode = traversalMode;
-        return this;
+	this.traversalMode = traversalMode;
+	return this;
     }
 
     public TraversalMode getTraversalMode()
     {
-        return traversalMode;
+	return traversalMode;
     }
 
     /**
@@ -220,9 +221,9 @@ public TraversalMode getTraversalMode()
      */
     public GraphHopper forServer()
     {
-        // simplify to reduce network IO
-        setSimplifyResponse(true);
-        return setInMemory();
+	// simplify to reduce network IO
+	setSimplifyResponse(true);
+	return setInMemory();
     }
 
     /**
@@ -231,8 +232,8 @@ public GraphHopper forServer()
      */
     public GraphHopper forDesktop()
     {
-        setSimplifyResponse(false);
-        return setInMemory();
+	setSimplifyResponse(false);
+	return setInMemory();
     }
 
     /**
@@ -241,8 +242,8 @@ public GraphHopper forDesktop()
      */
     public GraphHopper forMobile()
     {
-        setSimplifyResponse(false);
-        return setMemoryMapped();
+	setSimplifyResponse(false);
+	return setMemoryMapped();
     }
 
     /**
@@ -250,11 +251,11 @@ public GraphHopper forMobile()
      * probably slower query times, which would be e.g. not suitable for Android. The resolution
      * specifies the tile width (in meter).
      */
-    public GraphHopper setPreciseIndexResolution( int precision )
+    public GraphHopper setPreciseIndexResolution(int precision)
     {
-        ensureNotLoaded();
-        preciseIndexResolution = precision;
-        return this;
+	ensureNotLoaded();
+	preciseIndexResolution = precision;
+	return this;
     }
 
     /**
@@ -262,9 +263,9 @@ public GraphHopper setPreciseIndexResolution( int precision )
      */
     public GraphHopper setInMemory()
     {
-        ensureNotLoaded();
-        dataAccessType = DAType.RAM_STORE;
-        return this;
+	ensureNotLoaded();
+	dataAccessType = DAType.RAM_STORE;
+	return this;
     }
 
     /**
@@ -272,16 +273,17 @@ public GraphHopper setInMemory()
      * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
      * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
      * <p>
-     * @param storeOnFlush true by default
+     * @param storeOnFlush
+     *            true by default
      */
-    public GraphHopper setStoreOnFlush( boolean storeOnFlush )
+    public GraphHopper setStoreOnFlush(boolean storeOnFlush)
     {
-        ensureNotLoaded();
-        if (storeOnFlush)
-            dataAccessType = DAType.RAM_STORE;
-        else
-            dataAccessType = DAType.RAM;
-        return this;
+	ensureNotLoaded();
+	if (storeOnFlush)
+	    dataAccessType = DAType.RAM_STORE;
+	else
+	    dataAccessType = DAType.RAM;
+	return this;
     }
 
     /**
@@ -289,9 +291,9 @@ public GraphHopper setStoreOnFlush( boolean storeOnFlush )
      */
     public GraphHopper setMemoryMapped()
     {
-        ensureNotLoaded();
-        dataAccessType = DAType.MMAP;
-        return this;
+	ensureNotLoaded();
+	dataAccessType = DAType.MMAP;
+	return this;
     }
 
     /**
@@ -299,51 +301,52 @@ public GraphHopper setMemoryMapped()
      */
     private GraphHopper setUnsafeMemory()
     {
-        ensureNotLoaded();
-        dataAccessType = DAType.UNSAFE_STORE;
-        return this;
+	ensureNotLoaded();
+	dataAccessType = DAType.UNSAFE_STORE;
+	return this;
     }
 
     /**
      * Disables "CH-preparation". Use only if you know what you do.
      */
-    public GraphHopper setDoPrepare( boolean doPrepare )
+    public GraphHopper setDoPrepare(boolean doPrepare)
     {
-        this.doPrepare = doPrepare;
-        return this;
+	this.doPrepare = doPrepare;
+	return this;
     }
 
     /**
      * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
      * <p/>
-     * @param weighting can be "fastest", "shortest" or your own weight-calculation type.
+     * @param weighting
+     *            can be "fastest", "shortest" or your own weight-calculation type.
      * @see #setCHEnable(boolean)
      */
-    public GraphHopper setCHWeighting( String weighting )
+    public GraphHopper setCHWeighting(String weighting)
     {
-        ensureNotLoaded();
-        chWeighting = weighting;
-        return this;
+	ensureNotLoaded();
+	chWeighting = weighting;
+	return this;
     }
 
     public String getCHWeighting()
     {
-        return chWeighting;
+	return chWeighting;
     }
 
     /**
      * Enables or disables contraction hierarchies. Enabled by default.
      */
-    public GraphHopper setCHEnable( boolean enable )
+    public GraphHopper setCHEnable(boolean enable)
     {
-        ensureNotLoaded();
-        chEnabled = enable;
-        return this;
+	ensureNotLoaded();
+	chEnabled = enable;
+	return this;
     }
 
     public boolean isCHEnabled()
     {
-        return chEnabled;
+	return chEnabled;
     }
 
     /**
@@ -351,154 +354,156 @@ public boolean isCHEnabled()
      */
     public boolean hasElevation()
     {
-        return elevation;
+	return elevation;
     }
 
     /**
      * Enable storing and fetching elevation data. Default is false
      */
-    public GraphHopper setElevation( boolean includeElevation )
+    public GraphHopper setElevation(boolean includeElevation)
     {
-        this.elevation = includeElevation;
-        return this;
+	this.elevation = includeElevation;
+	return this;
     }
 
     /**
      * This method specifies if the import should include way names to be able to return
      * instructions for a route.
      */
-    public GraphHopper setEnableInstructions( boolean b )
+    public GraphHopper setEnableInstructions(boolean b)
     {
-        ensureNotLoaded();
-        enableInstructions = b;
-        return this;
+	ensureNotLoaded();
+	enableInstructions = b;
+	return this;
     }
 
     /**
      * This methods enables gps point calculation. If disabled only distance will be calculated.
      */
-    public GraphHopper setEnableCalcPoints( boolean b )
+    public GraphHopper setEnableCalcPoints(boolean b)
     {
-        calcPoints = b;
-        return this;
+	calcPoints = b;
+	return this;
     }
 
     /**
      * This method specifies if the returned path should be simplified or not, via douglas-peucker
      * or similar algorithm.
      */
-    private GraphHopper setSimplifyResponse( boolean doSimplify )
+    private GraphHopper setSimplifyResponse(boolean doSimplify)
     {
-        this.simplifyResponse = doSimplify;
-        return this;
+	this.simplifyResponse = doSimplify;
+	return this;
     }
 
     /**
      * Sets the graphhopper folder.
      */
-    public GraphHopper setGraphHopperLocation( String ghLocation )
+    public GraphHopper setGraphHopperLocation(String ghLocation)
     {
-        ensureNotLoaded();
-        if (ghLocation == null)
-            throw new IllegalArgumentException("graphhopper location cannot be null");
+	ensureNotLoaded();
+	if (ghLocation == null)
+	    throw new IllegalArgumentException("graphhopper location cannot be null");
 
-        this.ghLocation = ghLocation;
-        return this;
+	this.ghLocation = ghLocation;
+	return this;
     }
 
     public String getGraphHopperLocation()
     {
-        return ghLocation;
+	return ghLocation;
     }
 
     /**
      * This file can be an osm xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file
      * (.pbf).
      */
-    public GraphHopper setOSMFile( String osmFileStr )
+    public GraphHopper setOSMFile(String osmFileStr)
     {
-        ensureNotLoaded();
-        if (Helper.isEmpty(osmFileStr))
-            throw new IllegalArgumentException("OSM file cannot be empty.");
+	ensureNotLoaded();
+	if (Helper.isEmpty(osmFileStr))
+	    throw new IllegalArgumentException("OSM file cannot be empty.");
 
-        osmFile = osmFileStr;
-        return this;
+	osmFile = osmFileStr;
+	return this;
     }
 
     public String getOSMFile()
     {
-        return osmFile;
+	return osmFile;
     }
 
     /**
      * The underlying graph used in algorithms.
      * <p>
-     * @throws IllegalStateException if graph is not instantiated.
+     * @throws IllegalStateException
+     *             if graph is not instantiated.
      */
     public GraphStorage getGraph()
     {
-        if (graph == null)
-            throw new IllegalStateException("Graph not initialized");
+	if (graph == null)
+	    throw new IllegalStateException("Graph not initialized");
 
-        return graph;
+	return graph;
     }
 
-    public void setGraph( GraphStorage graph )
+    public void setGraph(GraphStorage graph)
     {
-        this.graph = graph;
+	this.graph = graph;
     }
 
-    protected void setLocationIndex( LocationIndex locationIndex )
+    protected void setLocationIndex(LocationIndex locationIndex)
     {
-        this.locationIndex = locationIndex;
+	this.locationIndex = locationIndex;
     }
 
     /**
      * The location index created from the graph.
      * <p>
-     * @throws IllegalStateException if index is not initialized
+     * @throws IllegalStateException
+     *             if index is not initialized
      */
     public LocationIndex getLocationIndex()
     {
-        if (locationIndex == null)
-            throw new IllegalStateException("Location index not initialized");
+	if (locationIndex == null)
+	    throw new IllegalStateException("Location index not initialized");
 
-        return locationIndex;
+	return locationIndex;
     }
 
     public AlgorithmPreparation getPreparation()
     {
-        return prepare;
+	return prepare;
     }
 
     /**
      * Sorts the graph which requires more RAM while import. See #12
      */
-    public GraphHopper setSortGraph( boolean sortGraph )
+    public GraphHopper setSortGraph(boolean sortGraph)
     {
-        ensureNotLoaded();
-        this.sortGraph = sortGraph;
-        return this;
+	ensureNotLoaded();
+	this.sortGraph = sortGraph;
+	return this;
     }
 
     /**
      * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
      * possible to create a lock file and so we can avoid write locks.
      */
-    public GraphHopper setAllowWrites( boolean allowWrites )
+    public GraphHopper setAllowWrites(boolean allowWrites)
     {
-        this.allowWrites = allowWrites;
-        return this;
+	this.allowWrites = allowWrites;
+	return this;
     }
 
     public boolean isAllowWrites()
     {
-        return allowWrites;
+	return allowWrites;
     }
 
     public TranslationMap getTranslationMap()
     {
-        return trMap;
+	return trMap;
     }
 
     /**
@@ -506,99 +511,101 @@ public TranslationMap getTranslationMap()
      * args) ala CmdArgs.read(args) or via configuration file ala
      * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
      */
-    public GraphHopper init( CmdArgs args )
-    {
-        args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
-        String tmpOsmFile = args.get("osmreader.osm", "");
-        if (!Helper.isEmpty(tmpOsmFile))
-            osmFile = tmpOsmFile;
-        
-        dataReader = args.get("reader.implementation", dataReader);
-
-        String graphHopperFolder = args.get("graph.location", "");
-        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
-        {
-            if (Helper.isEmpty(osmFile))
-                throw new IllegalArgumentException("You need to specify an OSM file.");
-
-            graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
-        }
-
-        // graph
-        setGraphHopperLocation(graphHopperFolder);
-        defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
-
-        String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
-        dataAccessType = DAType.fromString(graphDATypeStr);
-
-        sortGraph = args.getBool("graph.doSort", sortGraph);
-        removeZipped = args.getBool("graph.removeZipped", removeZipped);
-        int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
-        if (args.get("graph.locktype", "native").equals("simple"))
-            lockFactory = new SimpleFSLockFactory();
-        else
-            lockFactory = new NativeFSLockFactory();
-
-        // elevation
-        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
-        boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
-        String cacheDirStr = args.get("graph.elevation.cachedir", "");
-        String baseURL = args.get("graph.elevation.baseurl", "");
-        DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
-        ElevationProvider tmpProvider = ElevationProvider.NOOP;
-        if (eleProviderStr.equalsIgnoreCase("srtm"))
-        {
-            tmpProvider = new SRTMProvider();
-        } else if (eleProviderStr.equalsIgnoreCase("cgiar"))
-        {
-            CGIARProvider cgiarProvider = new CGIARProvider();
-            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
-            tmpProvider = cgiarProvider;
-        }
-
-        tmpProvider.setCalcMean(eleCalcMean);
-        tmpProvider.setCacheDir(new File(cacheDirStr));
-        if (!baseURL.isEmpty())
-            tmpProvider.setBaseURL(baseURL);
-        tmpProvider.setDAType(elevationDAType);
-        setElevationProvider(tmpProvider);
-
-        // optimizable prepare
-        minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
-        minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
-
-        // prepare CH
-        doPrepare = args.getBool("prepare.doPrepare", doPrepare);
-        String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
-        chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
-        if (chEnabled)
-            setCHWeighting(tmpCHWeighting);
-
-        periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
-        lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
-        neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
-        logMessages = args.getDouble("prepare.logmessages", logMessages);
-
-        // osm import
-        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
-        String flagEncoders = args.get("graph.flagEncoders", "CAR");
-        if (flagEncoders.toLowerCase().contains("turncosts=true"))
-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
-        encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
-        workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
-        enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
-
-        // index
-        preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
-        maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
-        return this;
+    public GraphHopper init(CmdArgs args)
+    {
+	args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
+	String tmpOsmFile = args.get("osmreader.osm", "");
+	if (!Helper.isEmpty(tmpOsmFile))
+	    osmFile = tmpOsmFile;
+
+	dataReader = args.get("reader.implementation", dataReader);
+
+	String graphHopperFolder = args.get("graph.location", "");
+	if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
+	{
+	    if (Helper.isEmpty(osmFile))
+		throw new IllegalArgumentException("You need to specify an OSM file.");
+
+	    graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
+	}
+
+	// graph
+	setGraphHopperLocation(graphHopperFolder);
+	defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
+
+	String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
+	dataAccessType = DAType.fromString(graphDATypeStr);
+
+	sortGraph = args.getBool("graph.doSort", sortGraph);
+	removeZipped = args.getBool("graph.removeZipped", removeZipped);
+	int bytesForFlags = args.getInt("graph.bytesForFlags", 4);
+	if (args.get("graph.locktype", "native").equals("simple"))
+	    lockFactory = new SimpleFSLockFactory();
+	else
+	    lockFactory = new NativeFSLockFactory();
+
+	// elevation
+	String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
+	boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
+	String cacheDirStr = args.get("graph.elevation.cachedir", "");
+	String baseURL = args.get("graph.elevation.baseurl", "");
+	DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
+	ElevationProvider tmpProvider = ElevationProvider.NOOP;
+	if (eleProviderStr.equalsIgnoreCase("srtm"))
+	    tmpProvider = new SRTMProvider();
+	else if (eleProviderStr.equalsIgnoreCase("cgiar"))
+	{
+	    CGIARProvider cgiarProvider = new CGIARProvider();
+	    cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear",
+			    true));
+	    tmpProvider = cgiarProvider;
+	}
+
+	tmpProvider.setCalcMean(eleCalcMean);
+	tmpProvider.setCacheDir(new File(cacheDirStr));
+	if (!baseURL.isEmpty())
+	    tmpProvider.setBaseURL(baseURL);
+	tmpProvider.setDAType(elevationDAType);
+	setElevationProvider(tmpProvider);
+
+	// optimizable prepare
+	minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
+	minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
+
+	// prepare CH
+	doPrepare = args.getBool("prepare.doPrepare", doPrepare);
+	String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
+	chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
+	if (chEnabled)
+	    setCHWeighting(tmpCHWeighting);
+
+	periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
+	lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
+	neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
+	logMessages = args.getDouble("prepare.logmessages", logMessages);
+
+	// osm import
+	osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance",
+			osmReaderWayPointMaxDistance);
+	String flagEncoders = args.get("graph.flagEncoders", "CAR");
+	if (flagEncoders.toLowerCase().contains("turncosts=true"))
+	    traversalMode = TraversalMode.EDGE_BASED_2DIR;
+	encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
+	workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
+	enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
+
+	// index
+	preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
+	maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+	return this;
     }
 
     private void printInfo()
     {
-        logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        if (graph != null)
-            logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
+	logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " ("
+			+ Constants.getVersions() + ")");
+	if (graph != null)
+	    logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
     }
 
     /**
@@ -608,186 +615,187 @@ private void printInfo()
      */
     public GraphHopper importOrLoad()
     {
-        if (!load(ghLocation))
-        {
-            printInfo();
-            process(ghLocation);
-        } else
-        {
-            printInfo();
-        }
-        return this;
+	if (!load(ghLocation))
+	{
+	    printInfo();
+	    process(ghLocation);
+	} else
+	    printInfo();
+	return this;
     }
 
     /**
      * Creates the graph from OSM data.
      */
-    private GraphHopper process( String graphHopperLocation )
-    {
-        setGraphHopperLocation(graphHopperLocation);
-        Lock lock = null;
-        try
-        {
-            if (graph.getDirectory().getDefaultType().isStoring())
-            {
-                lockFactory.setLockDir(new File(graphHopperLocation));
-                lock = lockFactory.create(fileLockName, true);
-                if (!lock.tryLock())
-                    throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
-            }
-
-            try
-            {
-                importData();
-                graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
-            } catch (IOException ex)
-            {
-                throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
-            }
-            cleanUp();
-            optimize();
-            postProcessing();
-            flush();
-        } finally
-        {
-            if (lock != null)
-                lock.release();
-        }
-        return this;
+    private GraphHopper process(String graphHopperLocation)
+    {
+	setGraphHopperLocation(graphHopperLocation);
+	Lock lock = null;
+	try
+	{
+	    if (graph.getDirectory().getDefaultType().isStoring())
+	    {
+		lockFactory.setLockDir(new File(graphHopperLocation));
+		lock = lockFactory.create(fileLockName, true);
+		if (!lock.tryLock())
+		    throw new RuntimeException(
+				    "To avoid multiple writers we need to obtain a write lock but it failed. In "
+						    + graphHopperLocation,
+				    lock.getObtainFailedReason());
+	    }
+
+	    try
+	    {
+		importData();
+		graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
+	    } catch (IOException ex)
+	    {
+		throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
+	    }
+	    cleanUp();
+	    optimize();
+	    postProcessing();
+	    flush();
+	} finally
+	{
+	    if (lock != null)
+		lock.release();
+	}
+	return this;
     }
 
     protected DataReader importData() throws IOException
     {
-        ensureWriteAccess();
-        if (graph == null)
-            throw new IllegalStateException("Load graph before importing OSM data");
+	ensureWriteAccess();
+	if (graph == null)
+	    throw new IllegalStateException("Load graph before importing OSM data");
 
-        if (osmFile == null)
-            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
-                    + " but also cannot import from OSM file as it wasn't specified!");
+	if (osmFile == null)
+	    throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
+			    + " but also cannot import from OSM file as it wasn't specified!");
 
-        encodingManager.setEnableInstructions(enableInstructions);
-        DataReader reader = createReader(graph);
-        logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
-        reader.readGraph();
-        return reader;
+	encodingManager.setEnableInstructions(enableInstructions);
+	DataReader reader = createReader(graph);
+	logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
+	reader.readGraph();
+	return reader;
     }
 
-    protected DataReader createReader( GraphStorage tmpGraph )
+    protected DataReader createReader(GraphStorage tmpGraph)
     {
-    	DataReader reader;
-    	if ("OSM".equals(dataReader)) {
-    		reader = new OSMReader(tmpGraph);
-    	}
-    	else if ("OSITN".equals(dataReader)) {
-    		reader = new OsItnReader(tmpGraph);
-    	} else {
-    		String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
-    		throw new IllegalArgumentException(exceptionMessage);
-    	}
-        return initReader(reader);
+	DataReader reader;
+	if ("OSM".equals(dataReader))
+	    reader = new OSMReader(tmpGraph);
+	else if ("OSITN".equals(dataReader))
+	    reader = new OsItnReader(tmpGraph);
+	else if ("OSDPN".equals(dataReader))
+	    reader = new OsDpnReader(tmpGraph);
+	else
+	{
+	    String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
+	    throw new IllegalArgumentException(exceptionMessage);
+	}
+	return initReader(reader);
     }
 
-    protected DataReader initReader(DataReader reader )
+    protected DataReader initReader(DataReader reader)
     {
-        if (osmFile == null)
-            throw new IllegalArgumentException("No OSM file specified");
+	if (osmFile == null)
+	    throw new IllegalArgumentException("No OSM file specified");
 
-        logger.info("start creating graph from " + osmFile);
-        File osmTmpFile = new File(osmFile);
-        return reader.setOSMFile(osmTmpFile).
-                setElevationProvider(eleProvider).
-                setWorkerThreads(workerThreads).
-                setEncodingManager(encodingManager).
-                setWayPointMaxDistance(osmReaderWayPointMaxDistance);
+	logger.info("start creating graph from " + osmFile);
+	File osmTmpFile = new File(osmFile);
+	return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider)
+			.setWorkerThreads(workerThreads).setEncodingManager(encodingManager)
+			.setWayPointMaxDistance(osmReaderWayPointMaxDistance);
     }
 
     /**
      * Opens existing graph.
      * <p/>
-     * @param graphHopperFolder is the folder containing graphhopper files (which can be compressed
-     * too)
+     * @param graphHopperFolder
+     *            is the folder containing graphhopper files (which can be compressed too)
      */
     @Override
-    public boolean load( String graphHopperFolder )
-    {
-        if (Helper.isEmpty(graphHopperFolder))
-            throw new IllegalStateException("graphHopperLocation is not specified. call init before");
-
-        if (fullyLoaded)
-            throw new IllegalStateException("graph is already successfully loaded");
-
-        if (graphHopperFolder.endsWith("-gh"))
-        {
-            // do nothing  
-        } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
-        {
-            throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-        } else if (!graphHopperFolder.contains("."))
-        {
-            if (new File(graphHopperFolder + "-gh").exists())
-                graphHopperFolder += "-gh";
-        } else
-        {
-            File compressed = new File(graphHopperFolder + ".ghz");
-            if (compressed.exists() && !compressed.isDirectory())
-            {
-                try
-                {
-                    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
-                } catch (IOException ex)
-                {
-                    throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath()
-                            + " to " + graphHopperFolder, ex);
-                }
-            }
-        }
-
-        setGraphHopperLocation(graphHopperFolder);
-
-        if (encodingManager == null)
-            encodingManager = EncodingManager.create(ghLocation);
-
-        if (!allowWrites && dataAccessType.isMMap())
-            dataAccessType = DAType.MMAP_RO;
-
-        GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
-        if (chEnabled) {
-            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
-        }
-        else if (encodingManager.needsTurnCostsSupport()) {
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostStorage());
-        }
-        else {
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
-        }
-        
-        graph.setSegmentSize(defaultSegmentSize);
-
-        Lock lock = null;
-        try
-        {
-            // create locks only if writes are allowed, if they are not allowed a lock cannot be created 
-            // (e.g. on a read only filesystem locks would fail)
-            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
-            {
-                lockFactory.setLockDir(new File(ghLocation));
-                lock = lockFactory.create(fileLockName, false);
-                if (!lock.tryLock())
-                    throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
-            }
-
-            if (!graph.loadExisting())
-                return false;
-
-            postProcessing();
-            fullyLoaded = true;
-            return true;
-        } finally
-        {
-            if (lock != null)
-                lock.release();
-        }
+    public boolean load(String graphHopperFolder)
+    {
+	if (Helper.isEmpty(graphHopperFolder))
+	    throw new IllegalStateException(
+			    "graphHopperLocation is not specified. call init before");
+
+	if (fullyLoaded)
+	    throw new IllegalStateException("graph is already successfully loaded");
+
+	if (graphHopperFolder.endsWith("-gh"))
+	{
+	    // do nothing
+	} else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
+	    throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
+	else if (!graphHopperFolder.contains("."))
+	{
+	    if (new File(graphHopperFolder + "-gh").exists())
+		graphHopperFolder += "-gh";
+	} else
+	{
+	    File compressed = new File(graphHopperFolder + ".ghz");
+	    if (compressed.exists() && !compressed.isDirectory())
+		try
+		{
+		    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder,
+				    removeZipped);
+		} catch (IOException ex)
+		{
+		    throw new RuntimeException("Couldn't extract file "
+				    + compressed.getAbsolutePath() + " to " + graphHopperFolder, ex);
+		}
+	}
+
+	setGraphHopperLocation(graphHopperFolder);
+
+	if (encodingManager == null)
+	    encodingManager = EncodingManager.create(ghLocation);
+
+	if (!allowWrites && dataAccessType.isMMap())
+	    dataAccessType = DAType.MMAP_RO;
+
+	GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
+	if (chEnabled)
+	    graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
+	else if (encodingManager.needsTurnCostsSupport())
+	    graph = new GraphHopperStorage(dir, encodingManager, hasElevation(),
+			    new TurnCostStorage());
+	else
+	    graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
+
+	graph.setSegmentSize(defaultSegmentSize);
+
+	Lock lock = null;
+	try
+	{
+	    // create locks only if writes are allowed, if they are not allowed
+	    // a lock cannot be created
+	    // (e.g. on a read only filesystem locks would fail)
+	    if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
+	    {
+		lockFactory.setLockDir(new File(ghLocation));
+		lock = lockFactory.create(fileLockName, false);
+		if (!lock.tryLock())
+		    throw new RuntimeException(
+				    "To avoid reading partial data we need to obtain the read lock but it failed. In "
+						    + ghLocation, lock.getObtainFailedReason());
+	    }
+
+	    if (!graph.loadExisting())
+		return false;
+
+	    postProcessing();
+	    fullyLoaded = true;
+	    return true;
+	} finally
+	{
+	    if (lock != null)
+		lock.release();
+	}
     }
 
     /**
@@ -795,32 +803,30 @@ else if (encodingManager.needsTurnCostsSupport()) {
      */
     protected void postProcessing()
     {
-        encodingManager = graph.getEncodingManager();
-        if (chEnabled)
-            initCHPrepare();
+	encodingManager = graph.getEncodingManager();
+	if (chEnabled)
+	    initCHPrepare();
 
-        if (!isPrepared())
-            prepare();
-        initLocationIndex();
+	if (!isPrepared())
+	    prepare();
+	initLocationIndex();
     }
 
     private boolean isPrepared()
     {
-        return "true".equals(graph.getProperties().get("prepare.done"));
+	return "true".equals(graph.getProperties().get("prepare.done"));
     }
 
     protected void initCHPrepare()
     {
-        FlagEncoder encoder = encodingManager.getSingle();
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
-                createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
-        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).
-                setLazyUpdates(lazyUpdates).
-                setNeighborUpdates(neighborUpdates).
-                setLogMessages(logMessages);
+	FlagEncoder encoder = encodingManager.getSingle();
+	PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
+			createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
+	tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
+			.setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
 
-        prepare = tmpPrepareCH;
-        prepare.setGraph(graph);
+	prepare = tmpPrepareCH;
+	prepare.setGraph(graph);
     }
 
     /**
@@ -828,193 +834,196 @@ protected void initCHPrepare()
      * created. Note that all URL parameters are available in the weightingParameters as String if
      * you use the GraphHopper Web module.
      * <p>
+     * 
      * @see Weighting.Params.create
-     * @param wMap all parameters influencing the weighting. E.g. URL parameters coming via
-     * GHRequest
-     * @param encoder the required vehicle
+     * @param wMap
+     *            all parameters influencing the weighting. E.g. URL parameters coming via GHRequest
+     * @param encoder
+     *            the required vehicle
      * @return the weighting to be used for route calculation
      */
-    public Weighting createWeighting( WeightingMap wMap, FlagEncoder encoder )
-    {
-        String weighting = wMap.getWeighting();
-        Weighting result;
-
-        if ("shortest".equalsIgnoreCase(weighting))
-        {
-            result = new ShortestWeighting();
-        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
-        {
-            if (encoder.supports(PriorityWeighting.class))
-                result = new PriorityWeighting(encoder);
-            else
-                result = new FastestWeighting(encoder);
-        } else
-        {
-            throw new UnsupportedOperationException("weighting " + weighting + " not supported");
-        }
-
-        if (encoder.supports(TurnWeighting.class))
-        {
-            result = new TurnWeighting(result, encoder, (TurnCostStorage) graph.getExtendedStorage());
-        }
-        return result;
+    public Weighting createWeighting(WeightingMap wMap, FlagEncoder encoder)
+    {
+	String weighting = wMap.getWeighting();
+	Weighting result;
+
+	if ("shortest".equalsIgnoreCase(weighting))
+	    result = new ShortestWeighting();
+	else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
+	{
+	    if (encoder.supports(PriorityWeighting.class))
+		result = new PriorityWeighting(encoder);
+	    else
+		result = new FastestWeighting(encoder);
+	} else
+	    throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+
+	if (encoder.supports(TurnWeighting.class))
+	    result = new TurnWeighting(result, encoder,
+			    (TurnCostStorage) graph.getExtendedStorage());
+	return result;
     }
 
     @Override
-    public GHResponse route( GHRequest request )
-    {
-        if (graph == null || !fullyLoaded)
-            throw new IllegalStateException("Call load or importOrLoad before routing");
-
-        if (graph.isClosed())
-            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
-
-        GHResponse response = new GHResponse();
-        List<Path> paths = getPaths(request, response);
-        if (response.hasErrors())
-            return response;
-
-        enableInstructions = request.getHints().getBool("instructions", enableInstructions);
-        calcPoints = request.getHints().getBool("calcPoints", calcPoints);
-        double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
-        Locale locale = request.getLocale();
-        DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
-
-        new PathMerger().
-                setCalcPoints(calcPoints).
-                setDouglasPeucker(peucker).
-                setEnableInstructions(enableInstructions).
-                setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).
-                doWork(response, paths, trMap.getWithFallBack(locale));
-        return response;
-    }
-
-    protected List<Path> getPaths( GHRequest request, GHResponse rsp )
-    {
-        String vehicle = request.getVehicle();
-        if (vehicle.isEmpty())
-            vehicle = encodingManager.getSingle().toString();
-
-        if (!encodingManager.supports(vehicle))
-        {
-            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
-                    + "Supported are: " + getEncodingManager()));
-            return Collections.emptyList();
-        }
-
-        TraversalMode tMode;
-        String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
-        try
-        {
-            tMode = TraversalMode.fromString(tModeStr);
-        } catch (Exception ex)
-        {
-            rsp.addError(ex);
-            return Collections.emptyList();
-        }
-
-        List<GHPoint> points = request.getPoints();
-        if (points.size() < 2)
-        {
-            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
-            return Collections.emptyList();
-        }
-
-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-        GHPoint startPoint = points.get(0);
-        StopWatch sw = new StopWatch().start();
-        QueryResult fromRes = locationIndex.findClosest(startPoint.lat, startPoint.lon, edgeFilter);
-        String debug = "idLookup[0]:" + sw.stop().getSeconds() + "s";
-        sw.stop();
-        if (!fromRes.isValid())
-        {
-            rsp.addError(new IllegalArgumentException("Cannot find point 0: " + startPoint));
-            return Collections.emptyList();
-        }
-
-        List<Path> paths = new ArrayList<Path>(points.size() - 1);
-        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
-        {
-            GHPoint point = points.get(placeIndex);
-            sw = new StopWatch().start();
-            QueryResult toRes = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-            debug += ", [" + placeIndex + "] idLookup:" + sw.stop().getSeconds() + "s";
-            if (!toRes.isValid())
-            {
-                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
-                break;
-            }
-
-            sw = new StopWatch().start();
-            String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi" : request.getAlgorithm();
-            RoutingAlgorithm algo = null;
-            if (chEnabled)
-            {
-                if (prepare == null)
-                    throw new IllegalStateException("Preparation object is null. CH-preparation wasn't done or did you "
-                            + "forget to call setCHEnable(false)?");
-
-                if (algoStr.equals("dijkstrabi"))
-                    algo = prepare.createAlgo();
-                else if (algoStr.equals("astarbi"))
-                    algo = ((PrepareContractionHierarchies) prepare).createAStar();
-                else
-                {
-                    rsp.addError(new IllegalStateException(
-                            "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
-                    break;
-                }
-            } else
-            {
-                Weighting weighting = createWeighting(request.getHints(), encoder);
-                prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, algoStr, encoder, weighting, tMode);
-                algo = prepare.createAlgo();
-            }
-
-            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
-            sw = new StopWatch().start();
-
-            Path path = algo.calcPath(fromRes, toRes);
-            if (path.getMillis() < 0)
-                throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
-
-            paths.add(path);
-            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
-            visitedSum.addAndGet(algo.getVisitedNodes());
-            fromRes = toRes;
-        }
-
-        if (rsp.hasErrors())
-            return Collections.emptyList();
-
-        if (points.size() - 1 != paths.size())
-            throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
-
-        rsp.setDebugInfo(debug);
-        return paths;
-    }
-
-    protected LocationIndex createLocationIndex( Directory dir )
-    {
-        LocationIndex tmpIndex;
-        if (graph instanceof LevelGraph)
-        {
-            tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-        } else
-        {
-            tmpIndex = new LocationIndexTree(graph, dir);
-        }
-        tmpIndex.setResolution(preciseIndexResolution);
-        ((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
-
-        if (!tmpIndex.loadExisting())
-        {
-            ensureWriteAccess();
-            tmpIndex.prepareIndex();
-        }
-
-        return tmpIndex;
+    public GHResponse route(GHRequest request)
+    {
+	if (graph == null || !fullyLoaded)
+	    throw new IllegalStateException("Call load or importOrLoad before routing");
+
+	if (graph.isClosed())
+	    throw new IllegalStateException(
+			    "You need to create a new GraphHopper instance as it is already closed");
+
+	GHResponse response = new GHResponse();
+	List<Path> paths = getPaths(request, response);
+	if (response.hasErrors())
+	    return response;
+
+	enableInstructions = request.getHints().getBool("instructions", enableInstructions);
+	calcPoints = request.getHints().getBool("calcPoints", calcPoints);
+	double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
+	Locale locale = request.getLocale();
+	DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
+
+	new PathMerger().setCalcPoints(calcPoints).setDouglasPeucker(peucker)
+			.setEnableInstructions(enableInstructions)
+			.setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
+			.doWork(response, paths, trMap.getWithFallBack(locale));
+	return response;
+    }
+
+    protected List<Path> getPaths(GHRequest request, GHResponse rsp)
+    {
+	String vehicle = request.getVehicle();
+	if (vehicle.isEmpty())
+	    vehicle = encodingManager.getSingle().toString();
+
+	if (!encodingManager.supports(vehicle))
+	{
+	    rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
+			    + "Supported are: " + getEncodingManager()));
+	    return Collections.emptyList();
+	}
+
+	TraversalMode tMode;
+	String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
+	try
+	{
+	    tMode = TraversalMode.fromString(tModeStr);
+	} catch (Exception ex)
+	{
+	    rsp.addError(ex);
+	    return Collections.emptyList();
+	}
+
+	List<GHPoint> points = request.getPoints();
+	if (points.size() < 2)
+	{
+	    rsp.addError(new IllegalStateException(
+			    "At least 2 points has to be specified, but was:" + points.size()));
+	    return Collections.emptyList();
+	}
+
+	FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+	EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+	GHPoint startPoint = points.get(0);
+	StopWatch sw = new StopWatch().start();
+	QueryResult fromRes = locationIndex.findClosest(startPoint.lat, startPoint.lon, edgeFilter);
+	String debug = "idLookup[0]:" + sw.stop().getSeconds() + "s";
+	sw.stop();
+	if (!fromRes.isValid())
+	{
+	    rsp.addError(new IllegalArgumentException("Cannot find point 0: " + startPoint));
+	    return Collections.emptyList();
+	}
+
+	List<Path> paths = new ArrayList<Path>(points.size() - 1);
+	for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
+	{
+	    GHPoint point = points.get(placeIndex);
+	    sw = new StopWatch().start();
+	    QueryResult toRes = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+	    debug += ", [" + placeIndex + "] idLookup:" + sw.stop().getSeconds() + "s";
+	    if (!toRes.isValid())
+	    {
+		rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": "
+				+ point));
+		break;
+	    }
+
+	    sw = new StopWatch().start();
+	    String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi" : request
+			    .getAlgorithm();
+	    RoutingAlgorithm algo = null;
+	    if (chEnabled)
+	    {
+		if (prepare == null)
+		    throw new IllegalStateException(
+				    "Preparation object is null. CH-preparation wasn't done or did you "
+						    + "forget to call setCHEnable(false)?");
+
+		if (algoStr.equals("dijkstrabi"))
+		    algo = prepare.createAlgo();
+		else if (algoStr.equals("astarbi"))
+		    algo = ((PrepareContractionHierarchies) prepare).createAStar();
+		else
+		{
+		    rsp.addError(new IllegalStateException(
+				    "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
+		    break;
+		}
+	    } else
+	    {
+		Weighting weighting = createWeighting(request.getHints(), encoder);
+		prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, algoStr, encoder,
+				weighting, tMode);
+		algo = prepare.createAlgo();
+	    }
+
+	    debug += ", algoInit:" + sw.stop().getSeconds() + "s";
+	    sw = new StopWatch().start();
+
+	    Path path = algo.calcPath(fromRes, toRes);
+	    if (path.getMillis() < 0)
+		throw new RuntimeException("Time was negative. Please report as bug and include:"
+				+ request);
+
+	    paths.add(path);
+	    debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, "
+			    + path.getDebugInfo();
+	    visitedSum.addAndGet(algo.getVisitedNodes());
+	    fromRes = toRes;
+	}
+
+	if (rsp.hasErrors())
+	    return Collections.emptyList();
+
+	if (points.size() - 1 != paths.size())
+	    throw new RuntimeException(
+			    "There should be exactly one more places than paths. places:"
+					    + points.size() + ", paths:" + paths.size());
+
+	rsp.setDebugInfo(debug);
+	return paths;
+    }
+
+    protected LocationIndex createLocationIndex(Directory dir)
+    {
+	LocationIndex tmpIndex;
+	if (graph instanceof LevelGraph)
+	    tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
+	else
+	    tmpIndex = new LocationIndexTree(graph, dir);
+	tmpIndex.setResolution(preciseIndexResolution);
+	((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
+
+	if (!tmpIndex.loadExisting())
+	{
+	    ensureWriteAccess();
+	    tmpIndex.prepareIndex();
+	}
+
+	return tmpIndex;
     }
 
     /**
@@ -1025,69 +1034,77 @@ protected LocationIndex createLocationIndex( Directory dir )
      */
     protected void initLocationIndex()
     {
-        if (locationIndex != null)
-            throw new IllegalStateException("Cannot initialize locationIndex twice!");
+	if (locationIndex != null)
+	    throw new IllegalStateException("Cannot initialize locationIndex twice!");
 
-        locationIndex = createLocationIndex(graph.getDirectory());
+	locationIndex = createLocationIndex(graph.getDirectory());
     }
 
     protected void optimize()
     {
-        logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
-        graph.optimize();
-        logger.info("finished optimize (" + Helper.getMemInfo() + ")");
+	logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
+	graph.optimize();
+	logger.info("finished optimize (" + Helper.getMemInfo() + ")");
 
-        // Later: move this into the GraphStorage.optimize method
-        // Or: Doing it after preparation to optimize shortcuts too. But not possible yet #12
-        if (sortGraph)
-        {
-            if (graph instanceof LevelGraph && isPrepared())
-                throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
+	// Later: move this into the GraphStorage.optimize method
+	// Or: Doing it after preparation to optimize shortcuts too. But not
+	// possible yet #12
+	if (sortGraph)
+	{
+	    if (graph instanceof LevelGraph && isPrepared())
+		throw new IllegalArgumentException(
+				"Sorting prepared LevelGraph is not possible yet. See #12");
 
-            GraphStorage newGraph = GHUtility.newStorage(graph);
-            GHUtility.sortDFS(graph, newGraph);
-            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
-            graph = newGraph;
-        }
+	    GraphStorage newGraph = GHUtility.newStorage(graph);
+	    GHUtility.sortDFS(graph, newGraph);
+	    logger.info("graph sorted (" + Helper.getMemInfo() + ")");
+	    graph = newGraph;
+	}
     }
 
     protected void prepare()
     {
-        boolean tmpPrepare = doPrepare && prepare != null;
-        if (tmpPrepare)
-        {
-            ensureWriteAccess();
-            if (prepare instanceof PrepareContractionHierarchies && encodingManager.getVehicleCount() > 1)
-                throw new IllegalArgumentException("Contraction hierarchies preparation "
-                        + "requires (at the moment) only one vehicle. But was:" + encodingManager);
+	boolean tmpPrepare = doPrepare && prepare != null;
+	if (tmpPrepare)
+	{
+	    ensureWriteAccess();
+	    if (prepare instanceof PrepareContractionHierarchies
+			    && encodingManager.getVehicleCount() > 1)
+		throw new IllegalArgumentException("Contraction hierarchies preparation "
+				+ "requires (at the moment) only one vehicle. But was:"
+				+ encodingManager);
 
-            logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... (" + Helper.getMemInfo() + ")");
-            prepare.doWork();
-            graph.getProperties().put("prepare.date", formatDateTime(new Date()));
-        }
-        graph.getProperties().put("prepare.done", tmpPrepare);
+	    logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... ("
+			    + Helper.getMemInfo() + ")");
+	    prepare.doWork();
+	    graph.getProperties().put("prepare.date", formatDateTime(new Date()));
+	}
+	graph.getProperties().put("prepare.done", tmpPrepare);
     }
 
     protected void cleanUp()
     {
-        int prev = graph.getNodes();
-        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
-        preparation.setMinNetworkSize(minNetworkSize);
-        preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
-        logger.info("start finding subnetworks, " + Helper.getMemInfo());
-        preparation.doWork();
-        int n = graph.getNodes();
-        // calculate remaining subnetworks
-        int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were " + preparation.getSubNetworks()
-                + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+	int prev = graph.getNodes();
+	PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph,
+			encodingManager);
+	preparation.setMinNetworkSize(minNetworkSize);
+	preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
+	logger.info("start finding subnetworks, " + Helper.getMemInfo());
+	preparation.doWork();
+	int n = graph.getNodes();
+	// calculate remaining subnetworks
+	int remainingSubnetworks = preparation.findSubnetworks().size();
+	logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were "
+			+ preparation.getSubNetworks() + " subnetworks. removed them => "
+			+ (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
     }
 
     protected void flush()
     {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
-        graph.flush();
-        fullyLoaded = true;
+	logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString()
+			+ ", " + Helper.getMemInfo() + ")");
+	graph.flush();
+	fullyLoaded = true;
     }
 
     /**
@@ -1096,19 +1113,20 @@ protected void flush()
      */
     public void close()
     {
-        if (graph != null)
-            graph.close();
+	if (graph != null)
+	    graph.close();
 
-        if (locationIndex != null)
-            locationIndex.close();
+	if (locationIndex != null)
+	    locationIndex.close();
 
-        try
-        {
-            lockFactory.forceRemove(fileLockName, true);
-        } catch (Exception ex)
-        {
-            // silently fail e.g. on Windows where we cannot remove an unreleased native lock
-        }
+	try
+	{
+	    lockFactory.forceRemove(fileLockName, true);
+	} catch (Exception ex)
+	{
+	    // silently fail e.g. on Windows where we cannot remove an
+	    // unreleased native lock
+	}
     }
 
     /**
@@ -1117,30 +1135,32 @@ public void close()
      */
     public void clean()
     {
-        if (getGraphHopperLocation().isEmpty())
-            throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
+	if (getGraphHopperLocation().isEmpty())
+	    throw new IllegalStateException(
+			    "Cannot clean GraphHopper without specified graphHopperLocation");
 
-        File folder = new File(getGraphHopperLocation());
-        Helper.removeDir(folder);
+	File folder = new File(getGraphHopperLocation());
+	Helper.removeDir(folder);
     }
 
     // make sure this is identical to buildDate used in pom.xml
     // <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
-    private String formatDateTime( Date date )
+    private String formatDateTime(Date date)
     {
-        return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
+	return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
     }
 
     protected void ensureNotLoaded()
     {
-        if (fullyLoaded)
-            throw new IllegalStateException("No configuration changes are possible after loading the graph");
+	if (fullyLoaded)
+	    throw new IllegalStateException(
+			    "No configuration changes are possible after loading the graph");
     }
 
     protected void ensureWriteAccess()
     {
-        if (!allowWrites)
-            throw new IllegalStateException("Writes are not allowed!");
+	if (!allowWrites)
+	    throw new IllegalStateException("Writes are not allowed!");
     }
 
     /**
@@ -1149,6 +1169,6 @@ protected void ensureWriteAccess()
      */
     public long getVisitedSum()
     {
-        return visitedSum.get();
+	return visitedSum.get();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/DataReader.java b/core/src/main/java/com/graphhopper/reader/DataReader.java
index 6643624d3f..1c589b0b2e 100644
--- a/core/src/main/java/com/graphhopper/reader/DataReader.java
+++ b/core/src/main/java/com/graphhopper/reader/DataReader.java
@@ -29,25 +29,24 @@
  * @author Peter Karich
  * @author Stuart Adam
  */
-public interface DataReader
-{
+public interface DataReader<E> {
 
     void readGraph() throws IOException;
 
     GraphStorage getGraphStorage();
 
-	int getInternalNodeIdOfOsmNode(long viaOsm);
+    int getInternalNodeIdOfOsmNode(E viaOsm);
 
-	long getOsmIdOfInternalEdge(int edge);
+    E getOsmIdOfInternalEdge(int edge);
 
-	DataReader setOSMFile(File srcFile);
+    DataReader setOSMFile(File srcFile);
 
-	DataReader setElevationProvider(ElevationProvider eleProvider);
+    DataReader setElevationProvider(ElevationProvider eleProvider);
 
-	DataReader setWorkerThreads(int workerThreads);
+    DataReader setWorkerThreads(int workerThreads);
 
-	DataReader setEncodingManager(EncodingManager encodingManager);
+    DataReader setEncodingManager(EncodingManager encodingManager);
 
-	DataReader setWayPointMaxDistance(double wayPointMaxDistance);
+    DataReader setWayPointMaxDistance(double wayPointMaxDistance);
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index 3c93de903d..475f496b83 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -40,10 +40,12 @@
 
 import com.graphhopper.coll.GHLongIntBTree;
 import com.graphhopper.coll.LongIntMap;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.*;
+import com.graphhopper.storage.ExtendedStorage;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.TurnCostStorage;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalc3D;
 import com.graphhopper.util.DistanceCalcEarth;
@@ -74,10 +76,10 @@
  * 2.b) Reads ways OSM file and creates edges while calculating the speed etc from the OSM tags.
  * When creating an edge the pillar node information from the intermediate datastructure will be
  * stored in the way geometry of that edge.
- * <p/>
+ * <p/> 
  * @author Peter Karich
  */
-public class OSMReader implements DataReader
+public class OSMReader implements DataReader<Long>
 {
     protected static final int EMPTY = -1;
     // pillar node is >= 3
@@ -98,7 +100,7 @@
     // only append and update possible (no unordered storage like with this doubleParse): new OSMIDMap
     // same here: not applicable as ways introduces the nodes in 'wrong' order: new OSMIDSegmentedMap
     // memory overhead due to open addressing and full rehash:
-    //        nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
+    // nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
     // smaller memory overhead for bigger data sets because of avoiding a "rehash"
     // remember how many times a node was used to identify tower nodes
     private LongIntMap osmNodeIdToInternalNodeMap;
@@ -121,111 +123,113 @@
     private boolean exitOnlyPillarNodeException = true;
     private File osmFile;
 
-    public OSMReader( GraphStorage storage )
+    public OSMReader(GraphStorage storage)
     {
-        this.graphStorage = storage;
-        this.nodeAccess = graphStorage.getNodeAccess();
+	this.graphStorage = storage;
+	this.nodeAccess = graphStorage.getNodeAccess();
 
-        osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
-        osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
-        osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
+	osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
+	osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
+	osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
+	pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
     }
 
     @Override
     public void readGraph() throws IOException
     {
-        if (encodingManager == null)
-            throw new IllegalStateException("Encoding manager was not set.");
+	if (encodingManager == null)
+	    throw new IllegalStateException("Encoding manager was not set.");
 
-        if (osmFile == null)
-            throw new IllegalStateException("No OSM file specified");
+	if (osmFile == null)
+	    throw new IllegalStateException("No OSM file specified");
 
-        if (!osmFile.exists())
-            throw new IllegalStateException("Your specified OSM file does not exist:" + osmFile.getAbsolutePath());
+	if (!osmFile.exists())
+	    throw new IllegalStateException("Your specified OSM file does not exist:"
+			    + osmFile.getAbsolutePath());
 
-        StopWatch sw1 = new StopWatch().start();
-        preProcess(osmFile);
-        sw1.stop();
+	StopWatch sw1 = new StopWatch().start();
+	preProcess(osmFile);
+	sw1.stop();
 
-        StopWatch sw2 = new StopWatch().start();
-        writeOsm2Graph(osmFile);
-        sw2.stop();
+	StopWatch sw2 = new StopWatch().start();
+	writeOsm2Graph(osmFile);
+	sw2.stop();
 
-        logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: " + (int) sw2.getSeconds() + " total:"
-                + ((int) (sw1.getSeconds() + sw2.getSeconds())));
+	logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: " + (int) sw2.getSeconds()
+			+ " total:" + (int) (sw1.getSeconds() + sw2.getSeconds()));
     }
 
     /**
      * Preprocessing of OSM file to select nodes which are used for highways. This allows a more
      * compact graph data structure.
      */
-    void preProcess( File osmFile )
-    {
-        OSMInputFile in = null;
-        try
-        {
-            in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
-
-            long tmpWayCounter = 1;
-            long tmpRelationCounter = 1;
-            RoutingElement item;
-            while ((item = in.getNext()) != null)
-            {
-                if (item.isType(OSMElement.WAY))
-                {
-                    final OSMWay way = (OSMWay) item;
-                    boolean valid = filterWay(way);
-                    if (valid)
-                    {
-                        TLongList wayNodes = way.getNodes();
-                        int s = wayNodes.size();
-                        for (int index = 0; index < s; index++)
-                        {
-                            prepareHighwayNode(wayNodes.get(index));
-                        }
-
-                        if (++tmpWayCounter % 5000000 == 0)
-                        {
-                            logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:" + nf(getNodeMap().getSize()) + " ("
-                                    + getNodeMap().getMemoryUsage() + "MB) " + Helper.getMemInfo());
-                        }
-                    }
-                }
-                if (item.isType(OSMElement.RELATION))
-                {
-                    final OSMRelation relation = (OSMRelation) item;
-                    if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
-                        prepareWaysWithRelationInfo(relation);
-
-                    if (relation.hasTag("type", "restriction"))
-                        prepareRestrictionRelation(relation);
-
-                    if (++tmpRelationCounter % 50000 == 0)
-                    {
-                        logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size())
-                                + " " + Helper.getMemInfo());
-                    }
-
-                }
-            }
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("Problem while parsing file", ex);
-        } finally
-        {
-            Helper.close(in);
-        }
-    }
-
-    private void prepareRestrictionRelation( OSMRelation relation )
-    {
-        TurnRelation turnRelation = createTurnRelation(relation);
-        if (turnRelation != null)
-        {
-            getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
-            getOsmWayIdSet().add(turnRelation.getOsmIdTo());
-        }
+    void preProcess(File osmFile)
+    {
+	OSMInputFile in = null;
+	try
+	{
+	    in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
+
+	    long tmpWayCounter = 1;
+	    long tmpRelationCounter = 1;
+	    RoutingElement item;
+	    while ((item = in.getNext()) != null)
+	    {
+		if (item.isType(OSMElement.WAY))
+		{
+		    final OSMWay way = (OSMWay) item;
+		    boolean valid = filterWay(way);
+		    if (valid)
+		    {
+			TLongList wayNodes = way.getNodes();
+			int s = wayNodes.size();
+			for (int index = 0; index < s; index++)
+			{
+			    prepareHighwayNode(wayNodes.get(index));
+			}
+
+			if (++tmpWayCounter % 5000000 == 0)
+			{
+			    logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:"
+					    + nf(getNodeMap().getSize()) + " ("
+					    + getNodeMap().getMemoryUsage() + "MB) "
+					    + Helper.getMemInfo());
+			}
+		    }
+		}
+		if (item.isType(OSMElement.RELATION))
+		{
+		    final OSMRelation relation = (OSMRelation) item;
+		    if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
+			prepareWaysWithRelationInfo(relation);
+
+		    if (relation.hasTag("type", "restriction"))
+			prepareRestrictionRelation(relation);
+
+		    if (++tmpRelationCounter % 50000 == 0)
+		    {
+			logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:"
+					+ nf(getRelFlagsMap().size()) + " " + Helper.getMemInfo());
+		    }
+		}
+	    }
+	} catch (Exception ex)
+	{
+	    throw new RuntimeException("Problem while parsing file", ex);
+	} finally
+	{
+	    Helper.close(in);
+	}
+    }
+
+    private void prepareRestrictionRelation(OSMRelation relation)
+    {
+	TurnRelation turnRelation = createTurnRelation(relation);
+	if (turnRelation != null)
+	{
+	    getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
+	    getOsmWayIdSet().add(turnRelation.getOsmIdTo());
+	}
     }
 
     /**
@@ -233,15 +237,15 @@ private void prepareRestrictionRelation( OSMRelation relation )
      */
     private TLongSet getOsmWayIdSet()
     {
-        return osmWayIdSet;
+	return osmWayIdSet;
     }
 
     private TIntLongMap getEdgeIdToOsmWayIdMap()
     {
-        if (edgeIdToOsmWayIdMap == null)
-            edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
+	if (edgeIdToOsmWayIdMap == null)
+	    edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
 
-        return edgeIdToOsmWayIdMap;
+	return edgeIdToOsmWayIdMap;
     }
 
     /**
@@ -250,652 +254,661 @@ private TIntLongMap getEdgeIdToOsmWayIdMap()
      * <p/>
      * @return true the current xml entry is a way entry and has nodes
      */
-    boolean filterWay( OSMWay item )
+    boolean filterWay(OSMWay item)
     {
-        // ignore broken geometry
-        if (item.getNodes().size() < 2)
-            return false;
+	// ignore broken geometry
+	if (item.getNodes().size() < 2)
+	    return false;
 
-        // ignore multipolygon geometry
-        if (!item.hasTags())
-            return false;
+	// ignore multipolygon geometry
+	if (!item.hasTags())
+	    return false;
 
-        return encodingManager.acceptWay(item) > 0;
+	return encodingManager.acceptWay(item) > 0;
     }
 
     /**
      * Creates the edges and nodes files from the specified osm file.
      */
-    private void writeOsm2Graph( File osmFile )
-    {
-        int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
-        
-        logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize()) + ", " + Helper.getMemInfo());
-        graphStorage.create(tmp);
-        long wayStart = -1;
-        long relationStart = -1;
-        long counter = 1;
-        OSMInputFile in = null;
-        try
-        {
-            in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
-            LongIntMap nodeFilter = getNodeMap();
-
-            RoutingElement item;
-            while ((item = in.getNext()) != null)
-            {
-                switch (item.getType())
-                {
-                    case OSMElement.NODE:
-                        if (nodeFilter.get(item.getId()) != -1)
-                        {
-                            processNode((OSMNode) item);
-                        }
-                        break;
-
-                    case OSMElement.WAY:
-                        if (wayStart < 0)
-                        {
-                            logger.info(nf(counter) + ", now parsing ways");
-                            wayStart = counter;
-                        }
-                        processWay((OSMWay) item);
-                        break;
-                    case OSMElement.RELATION:
-                        if (relationStart < 0)
-                        {
-                            logger.info(nf(counter) + ", now parsing relations");
-                            relationStart = counter;
-                        }
-                        processRelation((OSMRelation) item);
-                        break;
-                }
-                if (++counter % 100000000 == 0)
-                {
-                    logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations + ") " + Helper.getMemInfo());
-                }
-            }
-
-            // logger.info("storage nodes:" + storage.nodes() + " vs. graph nodes:" + storage.getGraph().nodes());
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("Couldn't process file " + osmFile + ", error: " + ex.getMessage(), ex);
-        } finally
-        {
-            Helper.close(in);
-        }
-
-        finishedReading();
-        if (graphStorage.getNodes() == 0)
-            throw new IllegalStateException("osm must not be empty. read " + counter + " lines and " + locations + " locations");
+    private void writeOsm2Graph(File osmFile)
+    {
+	int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
+
+	logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize())
+			+ ", " + Helper.getMemInfo());
+	graphStorage.create(tmp);
+	long wayStart = -1;
+	long relationStart = -1;
+	long counter = 1;
+	OSMInputFile in = null;
+	try
+	{
+	    in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
+	    LongIntMap nodeFilter = getNodeMap();
+
+	    RoutingElement item;
+	    while ((item = in.getNext()) != null)
+	    {
+		switch (item.getType())
+		{
+		case OSMElement.NODE:
+		    OSMNode node = (OSMNode) item;
+		    if (nodeFilter.get(node.getId()) != -1)
+		    {
+			processNode((OSMNode) item);
+		    }
+		    break;
+
+		case OSMElement.WAY:
+		    if (wayStart < 0)
+		    {
+			logger.info(nf(counter) + ", now parsing ways");
+			wayStart = counter;
+		    }
+		    processWay((OSMWay) item);
+		    break;
+		case OSMElement.RELATION:
+		    if (relationStart < 0)
+		    {
+			logger.info(nf(counter) + ", now parsing relations");
+			relationStart = counter;
+		    }
+		    processRelation((OSMRelation) item);
+		    break;
+		}
+		if (++counter % 100000000 == 0)
+		{
+		    logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations
+				    + ") " + Helper.getMemInfo());
+		}
+	    }
+
+	    // logger.info("storage nodes:" + storage.nodes() +
+	    // " vs. graph nodes:" + storage.getGraph().nodes());
+	} catch (Exception ex)
+	{
+	    throw new RuntimeException("Couldn't process file " + osmFile + ", error: "
+			    + ex.getMessage(), ex);
+	} finally
+	{
+	    Helper.close(in);
+	}
+
+	finishedReading();
+	if (graphStorage.getNodes() == 0)
+	    throw new IllegalStateException("osm must not be empty. read " + counter
+			    + " lines and " + locations + " locations");
     }
 
     /**
      * Process properties, encode flags and create edges for the way.
      */
-    void processWay( OSMWay way )
-    {
-        if (way.getNodes().size() < 2)
-            return;
-
-        // ignore multipolygon geometry
-        if (!way.hasTags())
-            return;
-
-        long wayOsmId = way.getId();
-
-        long includeWay = encodingManager.acceptWay(way);
-        if (includeWay == 0)
-            return;
-
-        long relationFlags = getRelFlagsMap().get(way.getId());
-
-        // TODO move this after we have created the edge and know the coordinates => encodingManager.applyWayTags
-        // estimate length of the track e.g. for ferry speed calculation
-        TLongList osmNodeIds = way.getNodes();
-        if (osmNodeIds.size() > 1)
-        {
-            int first = getNodeMap().get(osmNodeIds.get(0));
-            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
-            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
-            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon))
-            {
-                double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
-                way.setTag("estimated_distance", estimatedDist);
-                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
-            }
-        }
-
-        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
-        if (wayFlags == 0)
-            return;
-
-        List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
-        // look for barriers along the way
-        final int size = osmNodeIds.size();
-        int lastBarrier = -1;
-        for (int i = 0; i < size; i++)
-        {
-            long nodeId = osmNodeIds.get(i);
-            long nodeFlags = getNodeFlagsMap().get(nodeId);
-            // barrier was spotted and way is otherwise passable for that mode of travel
-            if (nodeFlags > 0)
-            {
-                if ((nodeFlags & wayFlags) > 0)
-                {
-                    // remove barrier to avoid duplicates
-                    getNodeFlagsMap().put(nodeId, 0);
-
-                    // create shadow node copy for zero length edge
-                    long newNodeId = addBarrierNode(nodeId);
-                    if (i > 0)
-                    {
-                        // start at beginning of array if there was no previous barrier
-                        if (lastBarrier < 0)
-                            lastBarrier = 0;
-
-                        // add way up to barrier shadow node
-                        long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
-                        transfer[transfer.length - 1] = newNodeId;
-                        TLongList partIds = new TLongArrayList(transfer);
-                        createdEdges.addAll(addOSMWay(partIds, wayFlags, wayOsmId));
-
-                        // create zero length edge for barrier
-                        createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId));
-                    } else
-                    {
-                        // run edge from real first node to shadow node
-                        createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId));
-
-                        // exchange first node for created barrier node
-                        osmNodeIds.set(0, newNodeId);
-                    }
-                    // remember barrier for processing the way behind it
-                    lastBarrier = i;
-                }
-            }
-        }
-
-        // just add remainder of way to graph if barrier was not the last node
-        if (lastBarrier >= 0)
-        {
-            if (lastBarrier < size - 1)
-            {
-                long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
-                TLongList partNodeIds = new TLongArrayList(transfer);
-                createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
-            }
-        } else
-        {
-            // no barriers - simply add the whole way
-            createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
-        }
-
-        for (EdgeIteratorState edge : createdEdges)
-        {
-            encodingManager.applyWayTags(way, edge);
-        }
-    }
-
-    public void processRelation( OSMRelation relation ) throws XMLStreamException
-    {
-        if (relation.hasTag("type", "restriction"))
-        {
-            TurnRelation turnRelation = createTurnRelation(relation);
-            if (turnRelation != null)
-            {
-                ExtendedStorage extendedStorage = graphStorage.getExtendedStorage();
-                if (extendedStorage instanceof TurnCostStorage)
-                {
-                    TurnCostStorage tcs = (TurnCostStorage) extendedStorage;
-                    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(turnRelation, this);
-                    for (ITurnCostTableEntry entry : entries)
-                    {
-                        tcs.addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(), (int) entry.getFlags());
-                    }
-                }
-            }
-        }
+    void processWay(OSMWay way)
+    {
+	if (way.getNodes().size() < 2)
+	    return;
+
+	// ignore multipolygon geometry
+	if (!way.hasTags())
+	    return;
+
+	long wayOsmId = way.getId();
+
+	long includeWay = encodingManager.acceptWay(way);
+	if (includeWay == 0)
+	    return;
+
+	long relationFlags = getRelFlagsMap().get(way.getId());
+
+	// TODO move this after we have created the edge and know the
+	// coordinates => encodingManager.applyWayTags
+	// estimate length of the track e.g. for ferry speed calculation
+	TLongList osmNodeIds = way.getNodes();
+	if (osmNodeIds.size() > 1)
+	{
+	    int first = getNodeMap().get(osmNodeIds.get(0));
+	    int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+	    double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+	    double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+	    if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat)
+			    && !Double.isNaN(lastLon))
+	    {
+		double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
+		way.setTag("estimated_distance", estimatedDist);
+		way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2,
+				(firstLon + lastLon) / 2));
+	    }
+	}
+
+	long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
+	if (wayFlags == 0)
+	    return;
+
+	List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
+	// look for barriers along the way
+	final int size = osmNodeIds.size();
+	int lastBarrier = -1;
+	for (int i = 0; i < size; i++)
+	{
+	    long nodeId = osmNodeIds.get(i);
+	    long nodeFlags = getNodeFlagsMap().get(nodeId);
+	    // barrier was spotted and way is otherwise passable for that mode
+	    // of travel
+	    if (nodeFlags > 0)
+		if ((nodeFlags & wayFlags) > 0)
+		{
+		    // remove barrier to avoid duplicates
+		    getNodeFlagsMap().put(nodeId, 0);
+
+		    // create shadow node copy for zero length edge
+		    long newNodeId = addBarrierNode(nodeId);
+		    if (i > 0)
+		    {
+			// start at beginning of array if there was no previous
+			// barrier
+			if (lastBarrier < 0)
+			    lastBarrier = 0;
+
+			// add way up to barrier shadow node
+			long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
+			transfer[transfer.length - 1] = newNodeId;
+			TLongList partIds = new TLongArrayList(transfer);
+			createdEdges.addAll(addOSMWay(partIds, wayFlags, wayOsmId));
+
+			// create zero length edge for barrier
+			createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags,
+					wayOsmId));
+		    } else
+		    {
+			// run edge from real first node to shadow node
+			createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags,
+					wayOsmId));
+
+			// exchange first node for created barrier node
+			osmNodeIds.set(0, newNodeId);
+		    }
+		    // remember barrier for processing the way behind it
+		    lastBarrier = i;
+		}
+	}
+
+	// just add remainder of way to graph if barrier was not the last node
+	if (lastBarrier >= 0)
+	{
+	    if (lastBarrier < size - 1)
+	    {
+		long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
+		TLongList partNodeIds = new TLongArrayList(transfer);
+		createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
+	    }
+	} else
+	    // no barriers - simply add the whole way
+	    createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
+
+	for (EdgeIteratorState edge : createdEdges)
+	    encodingManager.applyWayTags(way, edge);
+    }
+
+    public void processRelation(OSMRelation relation) throws XMLStreamException
+    {
+	if (relation.hasTag("type", "restriction"))
+	{
+	    TurnRelation turnRelation = createTurnRelation(relation);
+	    if (turnRelation != null)
+	    {
+		ExtendedStorage extendedStorage = graphStorage.getExtendedStorage();
+		if (extendedStorage instanceof TurnCostStorage)
+		{
+		    TurnCostStorage tcs = (TurnCostStorage) extendedStorage;
+		    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(
+				    turnRelation, this);
+		    for (ITurnCostTableEntry entry : entries)
+			tcs.addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(),
+					(int) entry.getFlags());
+		}
+	    }
+	}
     }
 
     /**
      * @return OSM way ID from specified edgeId. Only previously stored OSM-way-IDs are returned in
-     * order to reduce memory overhead.
+     *         order to reduce memory overhead.
      */
-    public long getOsmIdOfInternalEdge( int edgeId )
-    {
-        return getEdgeIdToOsmWayIdMap().get(edgeId);
-    }
-
-    public int getInternalNodeIdOfOsmNode( long nodeOsmId )
-    {
-        int id = getNodeMap().get(nodeOsmId);
-        if (id < TOWER_NODE)
-            return -id - 3;
-
-        return EMPTY;
-    }
-
-    // TODO remove this ugly stuff via better preparsing phase! E.g. putting every tags etc into a helper file!
-    double getTmpLatitude( int id )
-    {
-        if (id == EMPTY)
-            return Double.NaN;
-        if (id < TOWER_NODE)
-        {
-            // tower node
-            id = -id - 3;
-            return nodeAccess.getLatitude(id);
-        } else if (id > -TOWER_NODE)
-        {
-            // pillar node
-            id = id - 3;
-            return pillarInfo.getLatitude(id);
-        } else
-            // e.g. if id is not handled from preparse (e.g. was ignored via isInBounds)
-            return Double.NaN;
-    }
-
-    double getTmpLongitude( int id )
-    {
-        if (id == EMPTY)
-            return Double.NaN;
-        if (id < TOWER_NODE)
-        {
-            // tower node
-            id = -id - 3;
-            return nodeAccess.getLongitude(id);
-        } else if (id > -TOWER_NODE)
-        {
-            // pillar node
-            id = id - 3;
-            return pillarInfo.getLon(id);
-        } else
-            // e.g. if id is not handled from preparse (e.g. was ignored via isInBounds)
-            return Double.NaN;
-    }
-
-    private void processNode( OSMNode node )
-    {
-        if (isInBounds(node))
-        {
-            addNode(node);
-
-            // analyze node tags for barriers
-            if (node.hasTags())
-            {
-                long nodeFlags = encodingManager.handleNodeTags(node);
-                if (nodeFlags != 0)
-                    getNodeFlagsMap().put(node.getId(), nodeFlags);
-            }
-
-            locations++;
-        } else
-        {
-            skippedLocations++;
-        }
-    }
-
-    boolean addNode( OSMNode node )
-    {
-        int nodeType = getNodeMap().get(node.getId());
-        if (nodeType == EMPTY)
-            return false;
-
-        double lat = node.getLat();
-        double lon = node.getLon();
-        double ele = getElevation(node);
-        if (nodeType == TOWER_NODE)
-        {
-            addTowerNode(node.getId(), lat, lon, ele);
-        } else if (nodeType == PILLAR_NODE)
-        {
-            pillarInfo.setNode(nextPillarId, lat, lon, ele);
-            getNodeMap().put(node.getId(), nextPillarId + 3);
-            nextPillarId++;
-        }
-        return true;
-    }
-
-    protected double getElevation( OSMNode node )
+    @Override
+    public Long getOsmIdOfInternalEdge(int edgeId)
     {
-        return eleProvider.getEle(node.getLat(), node.getLon());
+	return getEdgeIdToOsmWayIdMap().get(edgeId);
     }
 
-    void prepareWaysWithRelationInfo( OSMRelation osmRelation )
-    {
-        // is there at least one tag interesting for the registed encoders?
-        if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
-            return;
-
-        int size = osmRelation.getMembers().size();
-        for (int index = 0; index < size; index++)
-        {
-            OSMRelation.Member member = osmRelation.getMembers().get(index);
-            if (member.type() != OSMRelation.Member.WAY)
-                continue;
-
-            long osmId = member.ref();
-            long oldRelationFlags = getRelFlagsMap().get(osmId);
-
-            // Check if our new relation data is better comparated to the the last one
-            long newRelationFlags = encodingManager.handleRelationTags(osmRelation, oldRelationFlags);
-            if (oldRelationFlags != newRelationFlags)
-                getRelFlagsMap().put(osmId, newRelationFlags);
-        }
-    }
-
-    void prepareHighwayNode( long osmId )
-    {
-        int tmpIndex = getNodeMap().get(osmId);
-        if (tmpIndex == EMPTY)
-        {
-            // osmId is used exactly once
-            getNodeMap().put(osmId, PILLAR_NODE);
-        } else if (tmpIndex > EMPTY)
-        {
-            // mark node as tower node as it occured at least twice times
-            getNodeMap().put(osmId, TOWER_NODE);
-        } else
-        {
-            // tmpIndex is already negative (already tower node)
-        }
-    }
-
-    int addTowerNode( long osmId, double lat, double lon, double ele )
-    {
-        if (nodeAccess.is3D())
-            nodeAccess.setNode(nextTowerId, lat, lon, ele);
-        else
-            nodeAccess.setNode(nextTowerId, lat, lon);
+    @Override
+    public int getInternalNodeIdOfOsmNode(Long nodeOsmId)
+    {
+	int id = getNodeMap().get(nodeOsmId);
+	if (id < TOWER_NODE)
+	    return -id - 3;
+
+	return EMPTY;
+    }
+
+    // TODO remove this ugly stuff via better preparsing phase! E.g. putting
+    // every tags etc into a helper file!
+    double getTmpLatitude(int id)
+    {
+	if (id == EMPTY)
+	    return Double.NaN;
+	if (id < TOWER_NODE)
+	{
+	    // tower node
+	    id = -id - 3;
+	    return nodeAccess.getLatitude(id);
+	} else if (id > -TOWER_NODE)
+	{
+	    // pillar node
+	    id = id - 3;
+	    return pillarInfo.getLatitude(id);
+	} else
+	    // e.g. if id is not handled from preparse (e.g. was ignored via
+	    // isInBounds)
+	    return Double.NaN;
+    }
+
+    double getTmpLongitude(int id)
+    {
+	if (id == EMPTY)
+	    return Double.NaN;
+	if (id < TOWER_NODE)
+	{
+	    // tower node
+	    id = -id - 3;
+	    return nodeAccess.getLongitude(id);
+	} else if (id > -TOWER_NODE)
+	{
+	    // pillar node
+	    id = id - 3;
+	    return pillarInfo.getLon(id);
+	} else
+	    // e.g. if id is not handled from preparse (e.g. was ignored via
+	    // isInBounds)
+	    return Double.NaN;
+    }
+
+    private void processNode(OSMNode node)
+    {
+	if (isInBounds(node))
+	{
+	    addNode(node);
+
+	    // analyze node tags for barriers
+	    if (node.hasTags())
+	    {
+		long nodeFlags = encodingManager.handleNodeTags(node);
+		if (nodeFlags != 0)
+		    getNodeFlagsMap().put(node.getId(), nodeFlags);
+	    }
+
+	    locations++;
+	} else
+	    skippedLocations++;
+    }
+
+    boolean addNode(OSMNode node)
+    {
+	int nodeType = getNodeMap().get(node.getId());
+	if (nodeType == EMPTY)
+	    return false;
+
+	double lat = node.getLat();
+	double lon = node.getLon();
+	double ele = getElevation(node);
+	if (nodeType == TOWER_NODE)
+	    addTowerNode(node.getId(), lat, lon, ele);
+	else if (nodeType == PILLAR_NODE)
+	{
+	    pillarInfo.setNode(nextPillarId, lat, lon, ele);
+	    getNodeMap().put(node.getId(), nextPillarId + 3);
+	    nextPillarId++;
+	}
+	return true;
+    }
+
+    protected double getElevation(OSMNode node)
+    {
+	return eleProvider.getEle(node.getLat(), node.getLon());
+    }
+
+    void prepareWaysWithRelationInfo(OSMRelation osmRelation)
+    {
+	// is there at least one tag interesting for the registed encoders?
+	if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
+	    return;
+
+	int size = osmRelation.getMembers().size();
+	for (int index = 0; index < size; index++)
+	{
+	    OSMRelation.Member member = osmRelation.getMembers().get(index);
+	    if (member.type() != OSMRelation.Member.WAY)
+		continue;
+
+	    long osmId = member.ref();
+	    long oldRelationFlags = getRelFlagsMap().get(osmId);
+
+	    // Check if our new relation data is better comparated to the the
+	    // last one
+	    long newRelationFlags = encodingManager.handleRelationTags(osmRelation,
+			    oldRelationFlags);
+	    if (oldRelationFlags != newRelationFlags)
+		getRelFlagsMap().put(osmId, newRelationFlags);
+	}
+    }
+
+    void prepareHighwayNode(long osmId)
+    {
+	int tmpIndex = getNodeMap().get(osmId);
+	if (tmpIndex == EMPTY)
+	{
+	    // osmId is used exactly once
+	    getNodeMap().put(osmId, PILLAR_NODE);
+	} else if (tmpIndex > EMPTY)
+	{
+	    // mark node as tower node as it occured at least twice times
+	    getNodeMap().put(osmId, TOWER_NODE);
+	} else
+	{
+	    // tmpIndex is already negative (already tower node)
+	}
+    }
+
+    int addTowerNode(long osmId, double lat, double lon, double ele)
+    {
+	if (nodeAccess.is3D())
+	    nodeAccess.setNode(nextTowerId, lat, lon, ele);
+	else
+	    nodeAccess.setNode(nextTowerId, lat, lon);
 
-        int id = -(nextTowerId + 3);
-        getNodeMap().put(osmId, id);
-        nextTowerId++;
-        return id;
+	int id = -(nextTowerId + 3);
+	getNodeMap().put(osmId, id);
+	nextTowerId++;
+	return id;
     }
 
     /**
      * This method creates from an OSM way (via the osm ids) one or more edges in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long flags, long wayOsmId )
-    {
-        PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
-        List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
-        int firstNode = -1;
-        int lastIndex = osmNodeIds.size() - 1;
-        int lastInBoundsPillarNode = -1;
-        try
-        {
-            for (int i = 0; i < osmNodeIds.size(); i++)
-            {
-                long osmId = osmNodeIds.get(i);
-                int tmpNode = getNodeMap().get(osmId);
-                if (tmpNode == EMPTY)
-                    continue;
-
-                // skip osmIds with no associated pillar or tower id (e.g. !OSMReader.isBounds)
-                if (tmpNode == TOWER_NODE)
-                    continue;
-
-                if (tmpNode == PILLAR_NODE)
-                {
-                    // In some cases no node information is saved for the specified osmId.
-                    // ie. a way references a <node> which does not exist in the current file.
-                    // => if the node before was a pillar node then convert into to tower node (as it is also end-standing).
-                    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE)
-                    {
-                        // transform the pillar node to a tower node
-                        tmpNode = lastInBoundsPillarNode;
-                        tmpNode = handlePillarNode(tmpNode, osmId, null, true);
-                        tmpNode = -tmpNode - 3;
-                        if (pointList.getSize() > 1 && firstNode >= 0)
-                        {
-                            // TOWER node
-                            newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
-                            pointList.clear();
-                            pointList.add(nodeAccess, tmpNode);
-                        }
-                        firstNode = tmpNode;
-                        lastInBoundsPillarNode = -1;
-                    }
-                    continue;
-                }
-
-                if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
-                    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", " + osmId);
-
-                if (tmpNode > -TOWER_NODE)
-                {
-                    boolean convertToTowerNode = i == 0 || i == lastIndex;
-                    if (!convertToTowerNode)
-                    {
-                        lastInBoundsPillarNode = tmpNode;
-                    }
-
-                    // PILLAR node, but convert to towerNode if end-standing
-                    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
-                }
-
-                if (tmpNode < TOWER_NODE)
-                {
-                    // TOWER node
-                    tmpNode = -tmpNode - 3;
-                    pointList.add(nodeAccess, tmpNode);
-                    if (firstNode >= 0)
-                    {
-                        newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
-                        pointList.clear();
-                        pointList.add(nodeAccess, tmpNode);
-                    }
-                    firstNode = tmpNode;
-                }
-            }
-        } catch (RuntimeException ex)
-        {
-            logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
-            if (exitOnlyPillarNodeException)
-                throw ex;
-        }
-        return newEdges;
-    }
-
-    EdgeIteratorState addEdge( int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId )
-    {
-        // sanity checks
-        if (fromIndex < 0 || toIndex < 0)
-            throw new AssertionError("to or from index is invalid for this edge " + fromIndex + "->" + toIndex + ", points:" + pointList);
-        if (pointList.getDimension() != nodeAccess.getDimension())
-            throw new AssertionError("Dimension does not match for pointList vs. nodeAccess " + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
-
-        double towerNodeDistance = 0;
-        double prevLat = pointList.getLatitude(0);
-        double prevLon = pointList.getLongitude(0);
-        double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
-        double lat, lon, ele = Double.NaN;
-        PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
-        int nodes = pointList.getSize();
-        for (int i = 1; i < nodes; i++)
-        {
-            // we could save some lines if we would use pointList.calcDistance(distCalc);
-            lat = pointList.getLatitude(i);
-            lon = pointList.getLongitude(i);
-            if (pointList.is3D())
-            {
-                ele = pointList.getElevation(i);
-                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
-                prevEle = ele;
-            } else
-                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
-            prevLat = lat;
-            prevLon = lon;
-            if (nodes > 2 && i < nodes - 1)
-            {
-                if (pillarNodes.is3D())
-                    pillarNodes.add(lat, lon, ele);
-                else
-                    pillarNodes.add(lat, lon);
-            }
-        }
-        if (towerNodeDistance == 0)
-        {
-            // As investigation shows often two paths should have crossed via one identical point 
-            // but end up in two very release points.
-            zeroCounter++;
-            towerNodeDistance = 0.0001;
-        }
-
-        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
-        if (nodes > 2)
-        {
-            if (doSimplify)
-                simplifyAlgo.simplify(pillarNodes);
-
-            iter.setWayGeometry(pillarNodes);
-        }
-        storeOsmWayID(iter.getEdge(), wayOsmId);
-        return iter;
+    Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags, long wayOsmId)
+    {
+	PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
+	List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
+	int firstNode = -1;
+	int lastIndex = osmNodeIds.size() - 1;
+	int lastInBoundsPillarNode = -1;
+	try
+	{
+	    for (int i = 0; i < osmNodeIds.size(); i++)
+	    {
+		long osmId = osmNodeIds.get(i);
+		int tmpNode = getNodeMap().get(osmId);
+		if (tmpNode == EMPTY)
+		    continue;
+
+		// skip osmIds with no associated pillar or tower id (e.g.
+		// !OSMReader.isBounds)
+		if (tmpNode == TOWER_NODE)
+		    continue;
+
+		if (tmpNode == PILLAR_NODE)
+		{
+		    // In some cases no node information is saved for the
+		    // specified osmId.
+		    // ie. a way references a <node> which does not exist in the
+		    // current file.
+		    // => if the node before was a pillar node then convert into
+		    // to tower node (as it is also end-standing).
+		    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE)
+		    {
+			// transform the pillar node to a tower node
+			tmpNode = lastInBoundsPillarNode;
+			tmpNode = handlePillarNode(tmpNode, osmId, null, true);
+			tmpNode = -tmpNode - 3;
+			if (pointList.getSize() > 1 && firstNode >= 0)
+			{
+			    // TOWER node
+			    newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+			    pointList.clear();
+			    pointList.add(nodeAccess, tmpNode);
+			}
+			firstNode = tmpNode;
+			lastInBoundsPillarNode = -1;
+		    }
+		    continue;
+		}
+
+		if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
+		    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", "
+				    + osmId);
+
+		if (tmpNode > -TOWER_NODE)
+		{
+		    boolean convertToTowerNode = i == 0 || i == lastIndex;
+		    if (!convertToTowerNode)
+		    {
+			lastInBoundsPillarNode = tmpNode;
+		    }
+		    // PILLAR node, but convert to towerNode if end-standing
+		    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
+		}
+
+		if (tmpNode < TOWER_NODE)
+		{
+		    // TOWER node
+		    tmpNode = -tmpNode - 3;
+		    pointList.add(nodeAccess, tmpNode);
+		    if (firstNode >= 0)
+		    {
+			newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+			pointList.clear();
+			pointList.add(nodeAccess, tmpNode);
+		    }
+		    firstNode = tmpNode;
+		}
+	    }
+	} catch (RuntimeException ex)
+	{
+	    logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
+	    if (exitOnlyPillarNodeException)
+		throw ex;
+	}
+	return newEdges;
+    }
+
+    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long flags,
+		    long wayOsmId)
+    {
+	// sanity checks
+	if (fromIndex < 0 || toIndex < 0)
+	    throw new AssertionError("to or from index is invalid for this edge " + fromIndex
+			    + "->" + toIndex + ", points:" + pointList);
+	if (pointList.getDimension() != nodeAccess.getDimension())
+	    throw new AssertionError("Dimension does not match for pointList vs. nodeAccess "
+			    + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
+
+	double towerNodeDistance = 0;
+	double prevLat = pointList.getLatitude(0);
+	double prevLon = pointList.getLongitude(0);
+	double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
+	double lat, lon, ele = Double.NaN;
+	PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
+	int nodes = pointList.getSize();
+	for (int i = 1; i < nodes; i++)
+	{
+	    // we could save some lines if we would use
+	    // pointList.calcDistance(distCalc);
+	    lat = pointList.getLatitude(i);
+	    lon = pointList.getLongitude(i);
+	    if (pointList.is3D())
+	    {
+		ele = pointList.getElevation(i);
+		towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
+		prevEle = ele;
+	    } else
+		towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
+	    prevLat = lat;
+	    prevLon = lon;
+	    if (nodes > 2 && i < nodes - 1)
+		if (pillarNodes.is3D())
+		    pillarNodes.add(lat, lon, ele);
+		else
+		    pillarNodes.add(lat, lon);
+	}
+	if (towerNodeDistance == 0)
+	{
+	    // As investigation shows often two paths should have crossed via
+	    // one identical point
+	    // but end up in two very release points.
+	    zeroCounter++;
+	    towerNodeDistance = 0.0001;
+	}
+
+	EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
+			.setDistance(towerNodeDistance).setFlags(flags);
+	if (nodes > 2)
+	{
+	    if (doSimplify)
+		simplifyAlgo.simplify(pillarNodes);
+
+	    iter.setWayGeometry(pillarNodes);
+	}
+	storeOsmWayID(iter.getEdge(), wayOsmId);
+	return iter;
     }
 
     /**
      * Stores only osmWayIds which are required for relations
      */
-    private void storeOsmWayID( int edgeId, long osmWayId )
+    private void storeOsmWayID(int edgeId, long osmWayId)
     {
-        if (getOsmWayIdSet().contains(osmWayId))
-        {
-            getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
-        }
+	if (getOsmWayIdSet().contains(osmWayId))
+	    getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
     }
 
     /**
      * @return converted tower node
      */
-    private int handlePillarNode( int tmpNode, long osmId, PointList pointList, boolean convertToTowerNode )
-    {
-        tmpNode = tmpNode - 3;
-        double lat = pillarInfo.getLatitude(tmpNode);
-        double lon = pillarInfo.getLongitude(tmpNode);
-        double ele = pillarInfo.getElevation(tmpNode);
-        if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
-            throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
-                    + "osmId:" + osmId + " pillarIndex:" + tmpNode);
-
-        if (convertToTowerNode)
-        {
-            // convert pillarNode type to towerNode, make pillar values invalid
-            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
-            tmpNode = addTowerNode(osmId, lat, lon, ele);
-        } else
-        {
-            if (pointList.is3D())
-                pointList.add(lat, lon, ele);
-            else
-                pointList.add(lat, lon);
-        }
-
-        return (int) tmpNode;
+    private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
+		    boolean convertToTowerNode)
+    {
+	tmpNode = tmpNode - 3;
+	double lat = pillarInfo.getLatitude(tmpNode);
+	double lon = pillarInfo.getLongitude(tmpNode);
+	double ele = pillarInfo.getElevation(tmpNode);
+	if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
+	    throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
+			    + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+
+	if (convertToTowerNode)
+	{
+	    // convert pillarNode type to towerNode, make pillar values invalid
+	    pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
+	    tmpNode = addTowerNode(osmId, lat, lon, ele);
+	} else if (pointList.is3D())
+	    pointList.add(lat, lon, ele);
+	else
+	    pointList.add(lat, lon);
+
+	return tmpNode;
     }
 
     protected void finishedReading()
     {
-        printInfo("way");
-        pillarInfo.clear();
-        eleProvider.release();
-        osmNodeIdToInternalNodeMap = null;
-        osmNodeIdToNodeFlagsMap = null;
-        osmWayIdToRouteWeightMap = null;
-        osmWayIdSet = null;
-        edgeIdToOsmWayIdMap = null;
+	printInfo("way");
+	pillarInfo.clear();
+	eleProvider.release();
+	osmNodeIdToInternalNodeMap = null;
+	osmNodeIdToNodeFlagsMap = null;
+	osmWayIdToRouteWeightMap = null;
+	osmWayIdSet = null;
+	edgeIdToOsmWayIdMap = null;
     }
 
     /**
      * Create a copy of the barrier node
      */
-    long addBarrierNode( long nodeId )
-    {
-        OSMNode newNode;
-        int graphIndex = getNodeMap().get(nodeId);
-        if (graphIndex < TOWER_NODE)
-        {
-            graphIndex = -graphIndex - 3;
-            newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
-        } else
-        {
-            graphIndex = graphIndex - 3;
-            newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
-        }
-
-        final long id = newNode.getId();
-        prepareHighwayNode(id);
-        addNode(newNode);
-        return id;
+    long addBarrierNode(long nodeId)
+    {
+	OSMNode newNode;
+	int graphIndex = getNodeMap().get(nodeId);
+	if (graphIndex < TOWER_NODE)
+	{
+	    graphIndex = -graphIndex - 3;
+	    newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
+	} else
+	{
+	    graphIndex = graphIndex - 3;
+	    newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
+	}
+
+	final long id = newNode.getId();
+	prepareHighwayNode(id);
+	addNode(newNode);
+	return id;
     }
 
     private long createNewNodeId()
     {
-        return newUniqueOsmId++;
+	return newUniqueOsmId++;
     }
 
     /**
      * Add a zero length edge with reduced routing options to the graph.
      */
-    Collection<EdgeIteratorState> addBarrierEdge( long fromId, long toId, long flags, long nodeFlags, long wayOsmId )
+    Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, long flags,
+		    long nodeFlags, long wayOsmId)
     {
-        // clear barred directions from routing flags
-        flags &= ~nodeFlags;
-        // add edge
-        barrierNodeIds.clear();
-        barrierNodeIds.add(fromId);
-        barrierNodeIds.add(toId);
-        return addOSMWay(barrierNodeIds, flags, wayOsmId);
+	// clear barred directions from routing flags
+	flags &= ~nodeFlags;
+	// add edge
+	barrierNodeIds.clear();
+	barrierNodeIds.add(fromId);
+	barrierNodeIds.add(toId);
+	return addOSMWay(barrierNodeIds, flags, wayOsmId);
     }
 
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
      * <p>
+     * 
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
-    TurnRelation createTurnRelation( OSMRelation relation )
-    {
-        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation.getTag("restriction"));
-        if (type != OSMTurnRelation.Type.UNSUPPORTED)
-        {
-            long fromWayID = -1;
-            long viaNodeID = -1;
-            long toWayID = -1;
-
-            for (OSMRelation.Member member : relation.getMembers())
-            {
-                if (OSMElement.WAY == member.type())
-                {
-                    if ("from".equals(member.role()))
-                    {
-                        fromWayID = member.ref();
-                    } else if ("to".equals(member.role()))
-                    {
-                        toWayID = member.ref();
-                    }
-                } else if (OSMElement.NODE == member.type() && "via".equals(member.role()))
-                {
-                    viaNodeID = member.ref();
-                }
-            }
-            if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
-            {
-                return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
-            }
-        }
-        return null;
+    TurnRelation createTurnRelation(OSMRelation relation)
+    {
+	OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation
+			.getTag("restriction"));
+	if (type != OSMTurnRelation.Type.UNSUPPORTED)
+	{
+	    long fromWayID = -1;
+	    long viaNodeID = -1;
+	    long toWayID = -1;
+
+	    for (OSMRelation.Member member : relation.getMembers())
+		if (OSMElement.WAY == member.type())
+		{
+		    if ("from".equals(member.role()))
+			fromWayID = member.ref();
+		    else if ("to".equals(member.role()))
+			toWayID = member.ref();
+		} else if (OSMElement.NODE == member.type() && "via".equals(member.role()))
+		    viaNodeID = member.ref();
+	    if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
+		return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
+	}
+	return null;
     }
 
     /**
      * Filter method, override in subclass
      */
-    boolean isInBounds( OSMNode node )
+    boolean isInBounds(OSMNode node)
     {
-        return true;
+	return true;
     }
 
     /**
@@ -903,76 +916,86 @@ boolean isInBounds( OSMNode node )
      */
     protected LongIntMap getNodeMap()
     {
-        return osmNodeIdToInternalNodeMap;
+	return osmNodeIdToInternalNodeMap;
     }
 
     protected TLongLongMap getNodeFlagsMap()
     {
-        return osmNodeIdToNodeFlagsMap;
+	return osmNodeIdToNodeFlagsMap;
     }
 
     TLongLongHashMap getRelFlagsMap()
     {
-        return osmWayIdToRouteWeightMap;
+	return osmWayIdToRouteWeightMap;
     }
 
     /**
      * Specify the type of the path calculation (car, bike, ...).
      */
-    public OSMReader setEncodingManager( EncodingManager em )
+    @Override
+    public OSMReader setEncodingManager(EncodingManager em)
     {
-        this.encodingManager = em;
-        return this;
+	this.encodingManager = em;
+	return this;
     }
 
-    public OSMReader setWayPointMaxDistance( double maxDist )
+    @Override
+    public OSMReader setWayPointMaxDistance(double maxDist)
     {
-        doSimplify = maxDist > 0;
-        simplifyAlgo.setMaxDistance(maxDist);
-        return this;
+	doSimplify = maxDist > 0;
+	simplifyAlgo.setMaxDistance(maxDist);
+	return this;
     }
 
-    public OSMReader setWorkerThreads( int numOfWorkers )
+    @Override
+    public OSMReader setWorkerThreads(int numOfWorkers)
     {
-        this.workerThreads = numOfWorkers;
-        return this;
+	this.workerThreads = numOfWorkers;
+	return this;
     }
 
-    public OSMReader setElevationProvider( ElevationProvider eleProvider )
+    @Override
+    public OSMReader setElevationProvider(ElevationProvider eleProvider)
     {
-        if (eleProvider == null)
-            throw new IllegalStateException("Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+	if (eleProvider == null)
+	    throw new IllegalStateException(
+			    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
 
-        if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
-            throw new IllegalStateException("Make sure you graph accepts 3D data");
+	if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
+	    throw new IllegalStateException("Make sure you graph accepts 3D data");
 
-        this.eleProvider = eleProvider;
-        return this;
+	this.eleProvider = eleProvider;
+	return this;
     }
 
-    public DataReader setOSMFile( File osmFile )
+    @Override
+    public DataReader setOSMFile(File osmFile)
     {
-        this.osmFile = osmFile;
-        return this;
+	this.osmFile = osmFile;
+	return this;
     }
 
-    private void printInfo( String str )
+    private void printInfo(String str)
     {
-        LoggerFactory.getLogger(getClass()).info(
-                "finished " + str + " processing." + " nodes: " + graphStorage.getNodes() + ", osmIdMap.size:" + getNodeMap().getSize()
-                + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB" + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
-                + ", relFlagsMap.size:" + getRelFlagsMap().size() + " " + Helper.getMemInfo());
+	LoggerFactory.getLogger(getClass()).info(
+			"finished " + str + " processing." + " nodes: " + graphStorage.getNodes()
+					+ ", osmIdMap.size:" + getNodeMap().getSize()
+					+ ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
+					+ ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
+					+ ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
+					+ Helper.getMemInfo());
     }
 
     @Override
     public String toString()
     {
-        return getClass().getSimpleName();
+	return getClass().getSimpleName();
     }
 
+    @Override
     public GraphStorage getGraphStorage()
     {
-        return graphStorage;
+	return graphStorage;
     }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
index 333b8d60d5..c8c262622d 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -1,13 +1,15 @@
 package com.graphhopper.reader;
 
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
+import com.graphhopper.reader.osgb.OsItnReader;
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
-import java.util.*;
 
 /**
  * Helper object which gives node cost entries for a given OSM-relation of type "restriction"
@@ -18,30 +20,28 @@
 {
     public enum Type
     {
-        UNSUPPORTED, NOT, ONLY;
-
-        private static final Map<String, Type> tags = new HashMap<String, Type>();
-
-        static
-        {
-            tags.put("no_left_turn", NOT);
-            tags.put("no_right_turn", NOT);
-            tags.put("no_straight_on", NOT);
-            tags.put("no_u_turn", NOT);
-            tags.put("only_right_turn", ONLY);
-            tags.put("only_left_turn", ONLY);
-            tags.put("only_straight_on", ONLY);
-        }
-
-        public static Type getRestrictionType( String tag )
-        {
-            Type result = null;
-            if (tag != null)
-            {
-                result = tags.get(tag);
-            }
-            return (result != null) ? result : UNSUPPORTED;
-        }
+	UNSUPPORTED, NOT, ONLY;
+
+	private static final Map<String, Type> tags = new HashMap<String, Type>();
+
+	static
+	{
+	    tags.put("no_left_turn", NOT);
+	    tags.put("no_right_turn", NOT);
+	    tags.put("no_straight_on", NOT);
+	    tags.put("no_u_turn", NOT);
+	    tags.put("only_right_turn", ONLY);
+	    tags.put("only_left_turn", ONLY);
+	    tags.put("only_straight_on", ONLY);
+	}
+
+	public static Type getRestrictionType(String tag)
+	{
+	    Type result = null;
+	    if (tag != null)
+		result = tags.get(tag);
+	    return result != null ? result : UNSUPPORTED;
+	}
     }
 
     private final long fromOsmWayId;
@@ -49,101 +49,114 @@ public static Type getRestrictionType( String tag )
     private final long toOsmWayId;
     private final Type restriction;
 
-    public OSMTurnRelation( long fromWayID, long viaNodeID, long toWayID, Type restrictionType )
+    public OSMTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType)
     {
-        this.fromOsmWayId = fromWayID;
-        this.viaOsmNodeId = viaNodeID;
-        this.toOsmWayId = toWayID;
-        this.restriction = restrictionType;
+	this.fromOsmWayId = fromWayID;
+	this.viaOsmNodeId = viaNodeID;
+	this.toOsmWayId = toWayID;
+	this.restriction = restrictionType;
     }
 
-    /* (non-Javadoc)
-	 * @see com.graphhopper.reader.TurnRelation#getOsmIdFrom()
-	 */
+    /*
+     * (non-Javadoc)
+     * 
+     * @see com.graphhopper.reader.TurnRelation#getOsmIdFrom()
+     */
     @Override
-	public long getOsmIdFrom()
+    public long getOsmIdFrom()
     {
-        return fromOsmWayId;
+	return fromOsmWayId;
     }
 
-    /* (non-Javadoc)
-	 * @see com.graphhopper.reader.TurnRelation#getOsmIdTo()
-	 */
+    /*
+     * (non-Javadoc)
+     * 
+     * @see com.graphhopper.reader.TurnRelation#getOsmIdTo()
+     */
     @Override
-	public long getOsmIdTo()
+    public long getOsmIdTo()
     {
-        return toOsmWayId;
+	return toOsmWayId;
     }
 
     /**
      * Transforms this relation into a collection of turn cost entries
      * <p>
-     * @param edgeOutExplorer an edge filter which only allows outgoing edges
-     * @param edgeInExplorer an edge filter which only allows incoming edges
+     * 
+     * @param edgeOutExplorer
+     *            an edge filter which only allows outgoing edges
+     * @param edgeInExplorer
+     *            an edge filter which only allows incoming edges
      * @return a collection of node cost entries which can be added to the graph later
      */
-    public Collection<ITurnCostTableEntry> getRestrictionAsEntries( TurnCostEncoder encoder,
-            EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader osmReader )
+    @Override
+    public Collection<ITurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder,
+		    EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader dataReader)
     {
-        int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
-
-        try
-        {
-            // street with restriction was not included (access or tag limits etc)
-            if (viaNodeId == OSMReader.EMPTY)
-                return Collections.emptyList();
-
-            int edgeIdFrom = EdgeIterator.NO_EDGE;
-
-            // get all incoming edges and receive the edge which is defined by fromOsm
-            EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
-
-            while (iter.next())
-            {
-                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
-                {
-                    edgeIdFrom = iter.getEdge();
-                    break;
-                }
-            }
-
-            if (edgeIdFrom == EdgeIterator.NO_EDGE)
-                return Collections.emptyList();
-
-            final Collection<ITurnCostTableEntry> entries = new ArrayList<ITurnCostTableEntry>();
-            // get all outgoing edges of the via node 
-            iter = edgeOutExplorer.setBaseNode(viaNodeId);
-            // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
-            // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
-            while (iter.next())
-            {
-                int edgeId = iter.getEdge();
-                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
-                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId
-                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0)
-                {
-                    final TurnCostTableEntry entry = new TurnCostTableEntry();
-                    entry.nodeViaNode = viaNodeId;
-                    entry.edgeFrom = edgeIdFrom;
-                    entry.edgeTo = iter.getEdge();
-                    entry.flags = encoder.getTurnFlags(true, 0);
-                    entries.add(entry);
-
-                    if (this.restriction == Type.NOT)
-                        break;
-                }
-            }
-            return entries;
-        } catch (Exception e)
-        {
-            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
-        }
+	OsItnReader itnReader = (OsItnReader) dataReader;
+	int viaNodeId = itnReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
+
+	try
+	{
+	    // street with restriction was not included (access or tag limits
+	    // etc)
+	    if (viaNodeId == OSMReader.EMPTY)
+		return Collections.emptyList();
+
+	    int edgeIdFrom = EdgeIterator.NO_EDGE;
+
+	    // get all incoming edges and receive the edge which is defined by
+	    // fromOsm
+	    EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
+
+	    while (iter.next())
+		if (itnReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
+		{
+		    edgeIdFrom = iter.getEdge();
+		    break;
+		}
+
+	    if (edgeIdFrom == EdgeIterator.NO_EDGE)
+		return Collections.emptyList();
+
+	    final Collection<ITurnCostTableEntry> entries = new ArrayList<ITurnCostTableEntry>();
+	    // get all outgoing edges of the via node
+	    iter = edgeOutExplorer.setBaseNode(viaNodeId);
+	    // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT
+	    // the given turn
+	    // for TYPE_NOT_* we add ONE restriction (from, via, to)
+	    while (iter.next())
+	    {
+		int edgeId = iter.getEdge();
+		long wayId = itnReader.getOsmIdOfInternalEdge(edgeId);
+		if (edgeId != edgeIdFrom && this.restriction == Type.ONLY
+				&& wayId != this.toOsmWayId || this.restriction == Type.NOT
+				&& wayId == this.toOsmWayId && wayId >= 0)
+		{
+		    final TurnCostTableEntry entry = new TurnCostTableEntry();
+		    entry.nodeViaNode = viaNodeId;
+		    entry.edgeFrom = edgeIdFrom;
+		    entry.edgeTo = iter.getEdge();
+		    entry.flags = encoder.getTurnFlags(true, 0);
+		    entries.add(entry);
+
+		    if (this.restriction == Type.NOT)
+			break;
+		}
+	    }
+	    return entries;
+	} catch (Exception e)
+	{
+	    throw new IllegalStateException(
+			    "Could not built turn table entry for relation of node with osmId:"
+					    + this.viaOsmNodeId, e);
+	}
     }
 
     @Override
     public String toString()
     {
-        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
+	return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
     }
 
     /**
@@ -151,50 +164,56 @@ public String toString()
      */
     public static class TurnCostTableEntry implements ITurnCostTableEntry
     {
-        public int edgeFrom;
-        public int nodeViaNode;
-        public int edgeTo;
-        public long flags;
-
-        /**
-         * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
-         * are involved.
-         */
-        public long getItemId()
-        {
-            return ((long) edgeFrom) << 32 | ((long) edgeTo);
-        }
-        
-        @Override
-		public int getEdgeFrom() {
-			return edgeFrom;
-		}
-
-		@Override
-		public int getEdgeTo() {
-			return edgeTo;
-		}
-
-		@Override
-		public int getVia() {
-			return nodeViaNode;
-		}
-
-		@Override
-		public long getFlags() {
-			return flags;
-		}
-
-		@Override
-		public void setFlags(long flags) {
-			this.flags = flags;
-		}
-
-        @Override
-        public String toString()
-        {
-            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
-        }
+	public int edgeFrom;
+	public int nodeViaNode;
+	public int edgeTo;
+	public long flags;
+
+	/**
+	 * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
+	 *         are involved.
+	 */
+	@Override
+	public long getItemId()
+	{
+	    return (long) edgeFrom << 32 | edgeTo;
+	}
+
+	@Override
+	public int getEdgeFrom()
+	{
+	    return edgeFrom;
+	}
+
+	@Override
+	public int getEdgeTo()
+	{
+	    return edgeTo;
+	}
+
+	@Override
+	public int getVia()
+	{
+	    return nodeViaNode;
+	}
+
+	@Override
+	public long getFlags()
+	{
+	    return flags;
+	}
+
+	@Override
+	public void setFlags(long flags)
+	{
+	    this.flags = flags;
+	}
+
+	@Override
+	public String toString()
+	{
+	    return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
+	}
     }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/RoutingElement.java b/core/src/main/java/com/graphhopper/reader/RoutingElement.java
index a9e1299f46..7977716d31 100644
--- a/core/src/main/java/com/graphhopper/reader/RoutingElement.java
+++ b/core/src/main/java/com/graphhopper/reader/RoutingElement.java
@@ -5,26 +5,24 @@
 
 public interface RoutingElement {
 
-	void setTag(String name, Object value);
+    void setTag(String name, Object value);
 
-	String getTag(String string);
-	
-	<T> T getTag( String key, T defaultValue );
+    String getTag(String string);
 
-	boolean hasTags();
+    <T> T getTag(String key, T defaultValue);
 
-	boolean hasTag(String key, String... values);
+    boolean hasTags();
 
-	boolean hasTag(String key, Object value);
+    boolean hasTag(String key, String... values);
 
-	boolean hasTag(String key, Set<String> values);
+    boolean hasTag(String key, Object value);
 
-	boolean hasTag(List<String> keyList, Set<String> values);
+    boolean hasTag(String key, Set<String> values);
 
-	int getType();
+    boolean hasTag(List<String> keyList, Set<String> values);
 
-	boolean isType(int way);
+    int getType();
 
-	long getId();
+    boolean isType(int way);
 
 }
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/reader/Way.java b/core/src/main/java/com/graphhopper/reader/Way.java
index 7187882a68..563c8fe5fa 100644
--- a/core/src/main/java/com/graphhopper/reader/Way.java
+++ b/core/src/main/java/com/graphhopper/reader/Way.java
@@ -1,11 +1,5 @@
 package com.graphhopper.reader;
 
-import gnu.trove.list.TLongList;
-
-
 public interface Way extends RoutingElement {
 
-	TLongList getNodes();
-
-
 }
diff --git a/core/src/main/java/com/graphhopper/reader/WayWithNodes.java b/core/src/main/java/com/graphhopper/reader/WayWithNodes.java
new file mode 100644
index 0000000000..f6d657d9f6
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/reader/WayWithNodes.java
@@ -0,0 +1,9 @@
+package com.graphhopper.reader;
+
+import gnu.trove.list.TLongList;
+
+public interface WayWithNodes extends Way {
+
+    TLongList getNodes();
+
+}
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java b/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
index 65dc6ff772..b1766ff3e8 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OSITNElement.java
@@ -216,10 +216,10 @@ private String resolveHighway(String elementText) {
     private String resolveNature(String elementText) {
         logger.info("OSITNElement.resolveNature( " + elementText + ")");
         switch (elementText) {
-        case "Single Carriageway":
-        case "Dual Carriageway":
-        case "Slip Road":
-            return elementText;
+            case "Single Carriageway":
+            case "Dual Carriageway":
+            case "Slip Road":
+                return elementText;
         }
         return null;
     }
@@ -448,6 +448,7 @@ public String getTag(String name) {
         return (String) properties.get(name);
     }
 
+    @Override
     @SuppressWarnings("unchecked")
     public <T> T getTag(String key, T defaultValue) {
         T val = (T) properties.get(key);
@@ -456,6 +457,7 @@ public String getTag(String name) {
         return val;
     }
 
+    @Override
     public void setTag(String name, Object value) {
         properties.put(name, value);
     }
@@ -463,6 +465,7 @@ public void setTag(String name, Object value) {
     /**
      * Chaeck that the object has a given tag with a given value.
      */
+    @Override
     public boolean hasTag(String key, Object value) {
         return value.equals(properties.get(key));
     }
@@ -471,6 +474,7 @@ public boolean hasTag(String key, Object value) {
      * Check that a given tag has one of the specified values. If no values are
      * given, just checks for presence of the tag
      */
+    @Override
     public boolean hasTag(String key, String... values) {
         Object osmValue = properties.get(key);
         if (osmValue == null)
@@ -490,6 +494,7 @@ public boolean hasTag(String key, String... values) {
     /**
      * Check that a given tag has one of the specified values.
      */
+    @Override
     public final boolean hasTag(String key, Set<String> values) {
         return values.contains(properties.get(key));
     }
@@ -498,10 +503,10 @@ public final boolean hasTag(String key, Set<String> values) {
      * Check a number of tags in the given order for the any of the given
      * values. Used to parse hierarchical access restrictions
      */
+    @Override
     public boolean hasTag(List<String> keyList, Set<String> values) {
         for (String key : keyList) {
-            Object value = properties.get(key);
-            if (values.contains(value))
+            if (values.contains(properties.get(key)))
                 return true;
         }
         return false;
@@ -515,10 +520,12 @@ public void clearTags() {
         properties.clear();
     }
 
+    @Override
     public int getType() {
         return type;
     }
 
+    @Override
     public boolean isType(int type) {
         return this.type == type;
     }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java b/core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java
index d28072d978..21327d543d 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OSITNNode.java
@@ -41,140 +41,156 @@
  * @author Nop
  */
 public class OSITNNode extends OSITNElement implements Node {
-	private double lat;
-	private double lon;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OSITNNode.class);
-	private boolean[] clones = {false,false,false,false};
-
-	public static OSITNNode create(long id, XMLStreamReader parser)
-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		OSITNNode node = new OSITNNode(id);
-
-		parser.nextTag();
-		node.readTags(parser);
-		return node;
-	}
-
-	public OSITNNode(long id, PointAccess pointAccess, int accessId) {
-		super(id, NODE);
-
-		this.lat = pointAccess.getLatitude(accessId);
-		this.lon = pointAccess.getLongitude(accessId);
-		if (pointAccess.is3D())
-			setTag("ele", pointAccess.getElevation(accessId));
-	}
-	
-	public OSITNNode(long id) {
-		super(id, NODE);
-
-	}
-
-	public double getLat() {
-		return lat;
-	}
-
-	public double getLon() {
-		return lon;
-	}
-
-	public double getEle() {
-		Object ele = getTags().get("ele");
-		if (ele == null)
-			// return Double.NaN;
-			return 1d;
-		return (Double) ele;
-	}
-
-	@Override
-	public void setTag(String name, Object value) {
-		if ("ele".equals(name)) {
-			if (value == null)
-				value = null;
-			else if (value instanceof String) {
-				String str = (String) value;
-				str = str.trim().replaceAll("\\,", ".");
-				if (str.isEmpty())
-					value = null;
-				else
-					try {
-						value = Double.parseDouble(str);
-					} catch (NumberFormatException ex) {
-						return;
-					}
-			} else
-				// force cast
-				value = ((Number) value).doubleValue();
-		}
-		super.setTag(name, value);
-	}
-
-	@Override
-	public String toString() {
-		StringBuilder txt = new StringBuilder();
-		txt.append("Node: ");
-		txt.append(getId());
-		txt.append(" lat=");
-		txt.append(getLat());
-		txt.append(" lon=");
-		txt.append(getLon());
-		if (!getTags().isEmpty()) {
-			txt.append("\n");
-			txt.append(tagsToString());
-		}
-		return txt.toString();
-	}
-
-	@Override
-	public void parseCoords(String elementText) throws MismatchedDimensionException, FactoryException, TransformException {
-		String elementSeparator = ",";
-		parseCoordinateString(elementText, elementSeparator);
-	}
-
-	public void parseCoordinateString(String elementText,
-			String elementSeparator) throws MismatchedDimensionException, FactoryException, TransformException {
-		String[] split = elementText.split(elementSeparator);
-
-		if(3==split.length) {
-			setTag("ele", split[2]);
-		}
-		Double easting = Double.parseDouble(split[0]);
-		Double northing = Double.parseDouble(split[1]);
-		LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
-		lat = wgs84.getLatAngle();
-		lon = wgs84.getLongAngle();
-		if (logger.isDebugEnabled()) logger.debug(toString());
-	}
-
-	@Override
-	protected void parseNetworkMember(String elementText) {
-		throw new UnsupportedOperationException("Nodes should not have members");
-	}
-
-	@Override
-	protected void addDirectedNode(String nodeId, String grade, String orientation) {
-		throw new UnsupportedOperationException(
-				"Nodes should not have directed nodes");
-	}
-	
-	@Override
-	protected void addDirectedLink(String nodeId, String orientation) {
-		throw new UnsupportedOperationException(
-				"Nodes should not have directed links");
-	}
-	
-	public OSITNNode gradeClone(long nodeId) {
-		OSITNNode clone = new OSITNNode(nodeId);
-		Map<String, Object> tags = this.getTags();
-		clone.setTags(tags);
-		clone.lat = this.lat;
-		clone.lon = this.lon;
-		return clone;
-	}
-
-	@Override
-	protected void parseCoords(int dimensions, String lineDefinition) {
-		throw new UnsupportedOperationException();
-	}
+    private double lat;
+    private double lon;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OSITNNode.class);
+    private final boolean[] clones = { false, false, false, false };
+
+    public static OSITNNode create(long id, XMLStreamReader parser)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
+        OSITNNode node = new OSITNNode(id);
+
+        parser.nextTag();
+        node.readTags(parser);
+        return node;
+    }
+
+    public OSITNNode(long id, PointAccess pointAccess, int accessId) {
+        super(id, NODE);
+
+        this.lat = pointAccess.getLatitude(accessId);
+        this.lon = pointAccess.getLongitude(accessId);
+        if (pointAccess.is3D())
+            setTag("ele", pointAccess.getElevation(accessId));
+    }
+
+    public OSITNNode(long id, double lat, double lon) {
+        super(id, NODE);
+
+        this.lat = lat;
+        this.lon = lon;
+    }
+
+    public OSITNNode(long id) {
+        super(id, NODE);
+
+    }
+
+    @Override
+    public double getLat() {
+        return lat;
+    }
+
+    @Override
+    public double getLon() {
+        return lon;
+    }
+
+    public double getEle() {
+        Object ele = getTags().get("ele");
+        if (ele == null)
+            // return Double.NaN;
+            return 1d;
+        return (Double) ele;
+    }
+
+    @Override
+    public void setTag(String name, Object value) {
+        if ("ele".equals(name)) {
+            if (value == null)
+                value = null;
+            else if (value instanceof String) {
+                String str = (String) value;
+                str = str.trim().replaceAll("\\,", ".");
+                if (str.isEmpty())
+                    value = null;
+                else
+                    try {
+                        value = Double.parseDouble(str);
+                    } catch (NumberFormatException ex) {
+                        return;
+                    }
+            } else
+                // force cast
+                value = ((Number) value).doubleValue();
+        }
+        super.setTag(name, value);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder txt = new StringBuilder();
+        txt.append("Node: ");
+        txt.append(getId());
+        txt.append(" lat=");
+        txt.append(getLat());
+        txt.append(" lon=");
+        txt.append(getLon());
+        if (!getTags().isEmpty()) {
+            txt.append("\n");
+            txt.append(tagsToString());
+        }
+        return txt.toString();
+    }
+
+    @Override
+    public void parseCoords(String elementText)
+            throws MismatchedDimensionException, FactoryException,
+            TransformException {
+        String elementSeparator = ",";
+        parseCoordinateString(elementText, elementSeparator);
+    }
+
+    @Override
+    public void parseCoordinateString(String elementText,
+            String elementSeparator) throws MismatchedDimensionException,
+            FactoryException, TransformException {
+        String[] split = elementText.split(elementSeparator);
+
+        if (3 == split.length) {
+            setTag("ele", split[2]);
+        }
+        Double easting = Double.parseDouble(split[0]);
+        Double northing = Double.parseDouble(split[1]);
+        LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
+        lat = wgs84.getLatAngle();
+        lon = wgs84.getLongAngle();
+        if (logger.isDebugEnabled())
+            logger.debug(toString());
+    }
+
+    @Override
+    protected void parseNetworkMember(String elementText) {
+        throw new UnsupportedOperationException("Nodes should not have members");
+    }
+
+    @Override
+    protected void addDirectedNode(String nodeId, String grade,
+            String orientation) {
+        throw new UnsupportedOperationException(
+                "Nodes should not have directed nodes");
+    }
+
+    @Override
+    protected void addDirectedLink(String nodeId, String orientation) {
+        throw new UnsupportedOperationException(
+                "Nodes should not have directed links");
+    }
+
+    public OSITNNode gradeClone(long nodeId) {
+        OSITNNode clone = new OSITNNode(nodeId);
+        Map<String, Object> tags = this.getTags();
+        clone.setTags(tags);
+        clone.lat = this.lat;
+        clone.lon = this.lon;
+        return clone;
+    }
+
+    @Override
+    protected void parseCoords(int dimensions, String lineDefinition) {
+        throw new UnsupportedOperationException();
+    }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java b/core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java
index 0acb47fb89..5e26885088 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java
@@ -4,20 +4,15 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Map;
-import java.util.Set;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.ITurnCostTableEntry;
-import com.graphhopper.reader.OSMReader;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMTurnRelation.Type;
 import com.graphhopper.reader.TurnRelation;
-import com.graphhopper.routing.util.AbstractFlagEncoder;
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
@@ -30,7 +25,8 @@
  * @author Stuart Adam
  */
 public class OSITNTurnRelation implements TurnRelation {
-    private static final Logger logger = LoggerFactory.getLogger(OSITNTurnRelation.class);
+    private static final Logger logger = LoggerFactory
+            .getLogger(OSITNTurnRelation.class);
 
     private static Map<String, Type> tags = new HashMap<String, Type>();
 
@@ -52,7 +48,8 @@ public static Type getRestrictionType(String tag) {
     private final long toOsmWayId;
     private final Type restriction;
 
-    public OSITNTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType) {
+    public OSITNTurnRelation(long fromWayID, long viaNodeID, long toWayID,
+            Type restrictionType) {
         this.fromOsmWayId = fromWayID;
         this.viaOsmNodeId = viaNodeID;
         this.toOsmWayId = toWayID;
@@ -90,7 +87,11 @@ public long getOsmIdTo() {
      * @return a collection of node cost entries which can be added to the graph
      *         later
      */
-    public Collection<ITurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder, EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader osmReader) {
+    @Override
+    public Collection<ITurnCostTableEntry> getRestrictionAsEntries(
+            TurnCostEncoder encoder, EdgeExplorer edgeOutExplorer,
+            EdgeExplorer edgeInExplorer, DataReader dataReader) {
+        DataReader<Long> osmReader = dataReader;
         int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
 
         try {
@@ -124,7 +125,10 @@ public long getOsmIdTo() {
             while (iter.next()) {
                 int edgeId = iter.getEdge();
                 long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
-                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0) {
+                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY
+                        && wayId != this.toOsmWayId
+                        || this.restriction == Type.NOT
+                        && wayId == this.toOsmWayId && wayId >= 0) {
                     final TurnCostTableEntry entry = new TurnCostTableEntry();
                     entry.nodeViaNode = viaNodeId;
                     entry.edgeFrom = edgeIdFrom;
@@ -138,13 +142,16 @@ public long getOsmIdTo() {
             }
             return entries;
         } catch (Exception e) {
-            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
+            throw new IllegalStateException(
+                    "Could not built turn table entry for relation of node with osmId:"
+                            + this.viaOsmNodeId, e);
         }
     }
 
     @Override
     public String toString() {
-        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
+        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId
+                + ")->*";
     }
 
     /**
@@ -160,8 +167,9 @@ public String toString() {
          * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if
          *         multiple encoders are involved.
          */
+        @Override
         public long getItemId() {
-            return ((long) edgeFrom) << 32 | ((long) edgeTo);
+            return ((long) edgeFrom) << 32 | (edgeTo);
         }
 
         @Override
@@ -192,7 +200,8 @@ public void setFlags(long flags) {
 
         @Override
         public String toString() {
-            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
+            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo
+                    + ")->*";
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java b/core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java
index eec4d575ad..4b7ecc176d 100755
--- a/core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OsItnInputFile.java
@@ -43,7 +43,6 @@
 import org.slf4j.LoggerFactory;
 
 import com.graphhopper.reader.RoutingElement;
-import com.graphhopper.reader.osgb.dpn.OsDpnWay;
 import com.graphhopper.reader.pbf.Sink;
 
 /**
@@ -53,223 +52,222 @@
  * @author Stuart Adam
  */
 public class OsItnInputFile implements Sink, Closeable {
-	private boolean eof;
-	private InputStream bis;
-	// for xml parsing
-	private XMLStreamReader parser;
-	// for pbf parsing
-	private boolean binary = false;
-	private final BlockingQueue<RoutingElement> itemQueue;
-	private boolean hasIncomingData;
-	private int workerThreads = -1;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsItnInputFile.class);
-	private String name;
-
-	public OsItnInputFile(File file) throws IOException {
-		name = file.getAbsolutePath();
-		bis = decode(file);
-		itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
-	}
-
-	public OsItnInputFile open() throws XMLStreamException {
-		openXMLStream(bis);
-		return this;
-	}
-	
-	public InputStream getInputStream() {
-		return bis;
-	}
-
-	/**
-	 * Currently on for pbf format. Default is number of cores.
-	 */
-	public OsItnInputFile setWorkerThreads(int num) {
-		workerThreads = num;
-		return this;
-	}
-
-	@SuppressWarnings("unchecked")
-	private InputStream decode(File file) throws IOException {
-		final String name = file.getName();
-
-		InputStream ips = null;
-		try {
-			ips = new BufferedInputStream(new FileInputStream(file), 50000);
-		} catch (FileNotFoundException e) {
-			throw new RuntimeException(e);
-		}
-		ips.mark(10);
-
-		// check file header
-		byte header[] = new byte[6];
-		ips.read(header);
-
-		/*
-		 * can parse bz2 directly with additional lib if (header[0] == 'B' &&
-		 * header[1] == 'Z') { return new CBZip2InputStream(ips); }
-		 */
-		if (header[0] == 31 && header[1] == -117) {
-			ips.reset();
-			return new GZIPInputStream(ips, 50000);
-		} else if (header[0] == 0 && header[1] == 0 && header[2] == 0
-				&& header[4] == 10 && header[5] == 9
-				&& (header[3] == 13 || header[3] == 14)) {
-			ips.reset();
-			binary = true;
-			return ips;
-		} else if (header[0] == 'P' && header[1] == 'K') {
-			ips.reset();
-			ZipInputStream zip = new ZipInputStream(ips);
-			zip.getNextEntry();
-
-			return zip;
-		} else if (name.endsWith(".gml") || name.endsWith(".xml")) {
-			ips.reset();
-			return ips;
-		} else if (header[0] == 60 && header[1] == 63 && header[3] == 120
-				&& header[4] == 109 && header[5] == 108) {
-			ips.reset();
-			return ips;
-		} else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
-			String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
-			try {
-				Class clazz = Class.forName(clName);
-				ips.reset();
-				Constructor<InputStream> ctor = clazz.getConstructor(
-						InputStream.class, boolean.class);
-				return ctor.newInstance(ips, true);
-			} catch (Exception e) {
-				throw new IllegalArgumentException("Cannot instantiate "
-						+ clName, e);
-			}
-		} else {
-			throw new IllegalArgumentException(
-					"Input file is not of valid type " + file.getPath());
-		}
-	}
-
-	private void openXMLStream(InputStream in) throws XMLStreamException {
-		XMLInputFactory factory = XMLInputFactory.newInstance();
-		parser = factory.createXMLStreamReader(bis, "UTF-8");
-		int event;
-		do {
-			event = parser.next();
-		} while (event == XMLStreamConstants.COMMENT);
-
-		if (event != XMLStreamConstants.START_ELEMENT
-				|| !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
-			throw new IllegalArgumentException(String.format(
-					"File %s not a valid OS ITN stream", name));
-		}
-
-		eof = false;
-	}
-
-	public RoutingElement getNext() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		if (eof)
-			throw new IllegalStateException("EOF reached");
-
-		RoutingElement item;
-		item = getNextXML();
-
-		if (item != null)
-			return item;
-
-		eof = true;
-		return null;
-	}
-
-	private OSITNElement getNextXML() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-
-		int event = parser.next();
-		while (event != XMLStreamConstants.END_DOCUMENT) {
-			if (event == XMLStreamConstants.START_ELEMENT) {
-				String idStr = parser.getAttributeValue(null, "fid");
-				if (null == idStr) {
-					idStr = parser.getAttributeValue(
-							"http://www.opengis.net/gml/3.2", "id");
-				}
-				if (idStr != null) {
-					String name = parser.getLocalName();
-					idStr = idStr.substring(4);
-					logger.info(idStr + ":" + name + ":");
-
-					long id;
-					try {
-						id = Long.parseLong(idStr);
-					} catch (NumberFormatException nfe) {
-						BigDecimal bd = new BigDecimal(idStr);
-						id = bd.longValue();
-					}
-					logger.info(id + ":" + name + ":");
-					switch (name) {
-					case "RoadNode":
-					case "RouteNode": {
-						return OSITNNode.create(id, parser);
-					}
-					case "RoadLink": {
-						return OSITNWay.create(id, parser);
-					}
-					case "RouteLink": {
-						return OsDpnWay.create(id, parser);
-					}
-					case "RoadRouteInformation": {
-						return OSITNRelation.create(id, parser);
-					}
-
-					case "Road": {
-						return OsItnMetaData.create(id, parser);
-					}
-					case "RoadLinkInformation": {
-					}
-					case "RoadNodeInformation": {
-					}
-					default: {
-
-					}
-
-					}
-				}
-			}
-			event = parser.next();
-		}
-		parser.close();
-		return null;
-	}
-
-	public boolean isEOF() {
-		return eof;
-	}
-
-	@Override
-	public void close() throws IOException {
-		try {
-			if (!binary)
-				parser.close();
-		} catch (XMLStreamException ex) {
-			throw new IOException(ex);
-		} finally {
-			eof = true;
-			bis.close();
-		}
-	}
-
-	@Override
-	public void process(RoutingElement item) {
-		try {
-			// blocks if full
-			itemQueue.put(item);
-		} catch (InterruptedException ex) {
-			throw new RuntimeException(ex);
-		}
-
-		// throw exception if full
-		// itemQueue.add(item);
-	}
-
-	@Override
-	public void complete() {
-		hasIncomingData = false;
-	}
+    private boolean eof;
+    private final InputStream bis;
+    // for xml parsing
+    private XMLStreamReader parser;
+    // for pbf parsing
+    private boolean binary = false;
+    private final BlockingQueue<RoutingElement> itemQueue;
+    private boolean hasIncomingData;
+    private int workerThreads = -1;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsItnInputFile.class);
+    private final String name;
+
+    public OsItnInputFile(File file) throws IOException {
+        name = file.getAbsolutePath();
+        bis = decode(file);
+        itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
+    }
+
+    public OsItnInputFile open() throws XMLStreamException {
+        openXMLStream(bis);
+        return this;
+    }
+
+    public InputStream getInputStream() {
+        return bis;
+    }
+
+    /**
+     * Currently on for pbf format. Default is number of cores.
+     */
+    public OsItnInputFile setWorkerThreads(int num) {
+        workerThreads = num;
+        return this;
+    }
+
+    @SuppressWarnings("unchecked")
+    private InputStream decode(File file) throws IOException {
+        final String name = file.getName();
+
+        InputStream ips = null;
+        try {
+            ips = new BufferedInputStream(new FileInputStream(file), 50000);
+        } catch (FileNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+        ips.mark(10);
+
+        // check file header
+        byte header[] = new byte[6];
+        ips.read(header);
+
+        /*
+         * can parse bz2 directly with additional lib if (header[0] == 'B' &&
+         * header[1] == 'Z') { return new CBZip2InputStream(ips); }
+         */
+        if (header[0] == 31 && header[1] == -117) {
+            ips.reset();
+            return new GZIPInputStream(ips, 50000);
+        } else if (header[0] == 0 && header[1] == 0 && header[2] == 0
+                && header[4] == 10 && header[5] == 9
+                && (header[3] == 13 || header[3] == 14)) {
+            ips.reset();
+            binary = true;
+            return ips;
+        } else if (header[0] == 'P' && header[1] == 'K') {
+            ips.reset();
+            ZipInputStream zip = new ZipInputStream(ips);
+            zip.getNextEntry();
+
+            return zip;
+        } else if (name.endsWith(".gml") || name.endsWith(".xml")) {
+            ips.reset();
+            return ips;
+        } else if (header[0] == 60 && header[1] == 63 && header[3] == 120
+                && header[4] == 109 && header[5] == 108) {
+            ips.reset();
+            return ips;
+        } else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
+            String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
+            try {
+                Class clazz = Class.forName(clName);
+                ips.reset();
+                Constructor<InputStream> ctor = clazz.getConstructor(
+                        InputStream.class, boolean.class);
+                return ctor.newInstance(ips, true);
+            } catch (Exception e) {
+                throw new IllegalArgumentException("Cannot instantiate "
+                        + clName, e);
+            }
+        } else {
+            throw new IllegalArgumentException(
+                    "Input file is not of valid type " + file.getPath());
+        }
+    }
+
+    private void openXMLStream(InputStream in) throws XMLStreamException {
+        XMLInputFactory factory = XMLInputFactory.newInstance();
+        parser = factory.createXMLStreamReader(bis, "UTF-8");
+        int event;
+        do {
+            event = parser.next();
+        } while (event == XMLStreamConstants.COMMENT);
+
+        if (event != XMLStreamConstants.START_ELEMENT
+                || !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
+            throw new IllegalArgumentException(String.format(
+                    "File %s not a valid OS ITN stream", name));
+        }
+
+        eof = false;
+    }
+
+    public RoutingElement getNext() throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
+        if (eof)
+            throw new IllegalStateException("EOF reached");
+
+        RoutingElement item;
+        item = getNextXML();
+
+        if (item != null)
+            return item;
+
+        eof = true;
+        return null;
+    }
+
+    private OSITNElement getNextXML() throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
+
+        int event = parser.next();
+        while (event != XMLStreamConstants.END_DOCUMENT) {
+            if (event == XMLStreamConstants.START_ELEMENT) {
+                String idStr = parser.getAttributeValue(null, "fid");
+                if (null == idStr) {
+                    idStr = parser.getAttributeValue(
+                            "http://www.opengis.net/gml/3.2", "id");
+                }
+                if (idStr != null) {
+                    String name = parser.getLocalName();
+                    idStr = idStr.substring(4);
+                    logger.info(idStr + ":" + name + ":");
+
+                    long id;
+                    try {
+                        id = Long.parseLong(idStr);
+                    } catch (NumberFormatException nfe) {
+                        BigDecimal bd = new BigDecimal(idStr);
+                        id = bd.longValue();
+                    }
+                    logger.info(id + ":" + name + ":");
+                    switch (name) {
+                        case "RoadNode": {
+                            return OSITNNode.create(id, parser);
+                        }
+                        case "RoadLink": {
+                            return OSITNWay.create(id, parser);
+                        }
+
+                        case "RoadRouteInformation": {
+                            return OSITNRelation.create(id, parser);
+                        }
+
+                        case "Road": {
+                            return OsItnMetaData.create(id, parser);
+                        }
+                        case "RoadLinkInformation": {
+                        }
+                        case "RoadNodeInformation": {
+                        }
+                        default: {
+
+                        }
+
+                    }
+                }
+            }
+            event = parser.next();
+        }
+        parser.close();
+        return null;
+    }
+
+    public boolean isEOF() {
+        return eof;
+    }
+
+    @Override
+    public void close() throws IOException {
+        try {
+            if (!binary)
+                parser.close();
+        } catch (XMLStreamException ex) {
+            throw new IOException(ex);
+        } finally {
+            eof = true;
+            bis.close();
+        }
+    }
+
+    @Override
+    public void process(RoutingElement item) {
+        try {
+            // blocks if full
+            itemQueue.put(item);
+        } catch (InterruptedException ex) {
+            throw new RuntimeException(ex);
+        }
+
+        // throw exception if full
+        // itemQueue.add(item);
+    }
+
+    @Override
+    public void complete() {
+        hasIncomingData = false;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java b/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
index 2e3f2a6214..0b0a1e1e93 100755
--- a/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
@@ -37,7 +37,6 @@
 import com.graphhopper.reader.ITurnCostTableEntry;
 import com.graphhopper.reader.Node;
 import com.graphhopper.reader.OSMElement;
-import com.graphhopper.reader.OSMNode;
 import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.OSMTurnRelation.Type;
@@ -107,7 +106,7 @@
  * @author Peter Karich
  */
 
-public class OsItnReader implements DataReader {
+public class OsItnReader implements DataReader<Long> {
 
     private static final String TURN_FROM_TO_VIA_FORMAT = "Turn from:{} to:{} via:{}";
     private static final String PRINT_INFO_FORMAT = "finished {}  processing. nodes:{}, osmIdMap.size:{}, osmIdMap:{}MB, nodeFlagsMap.size:{}, relFlagsMap.size:{} {}";
@@ -144,7 +143,9 @@
     private static final String EDGE_ID_TO_OSMIDMAP_FORMAT = "edgeIdTOOsmidmap: {}";
 
     public class ProcessVisitor {
-        public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+        public void process(ProcessData processData, OsItnInputFile in)
+                throws XMLStreamException, MismatchedDimensionException,
+                FactoryException, TransformException {
         }
     }
 
@@ -160,8 +161,10 @@ public void process(ProcessData processData, OsItnInputFile in) throws XMLStream
     protected static final int PILLAR_NODE = 1;
     // tower node is <= -3
     protected static final int TOWER_NODE = -2;
-    private static final Logger logger = LoggerFactory.getLogger(OsItnReader.class);
-    private static final Logger errors_logger = LoggerFactory.getLogger("ingestionerrors");
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsItnReader.class);
+    private static final Logger errors_logger = LoggerFactory
+            .getLogger("ingestionerrors");
 
     private static final int MAX_GRADE_SEPARATION = 4;
     private long locations;
@@ -190,7 +193,7 @@ public void process(ProcessData processData, OsItnInputFile in) throws XMLStream
     // smaller memory overhead for bigger data sets because of avoiding a
     // "rehash"
     // remember how many times a node was used to identify tower nodes
-    private LongIntMap osmNodeIdToInternalNodeMap;
+    private final LongIntMap osmNodeIdToInternalNodeMap;
     private TLongLongHashMap osmNodeIdToNodeFlagsMap;
     private TLongLongHashMap osmWayIdToRouteWeightMap;
     // stores osm way ids used by relations to identify which edge ids needs to
@@ -208,7 +211,7 @@ public void process(ProcessData processData, OsItnInputFile in) throws XMLStream
     // negative but increasing to avoid clash with custom created OSM files
     private long newUniqueOsmId = -Long.MAX_VALUE;
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private boolean exitOnlyPillarNodeException = true;
+    private final boolean exitOnlyPillarNodeException = true;
     private File routingFile;
 
     private TLongObjectMap<ItnNodePair> edgeIdToNodeMap;
@@ -227,7 +230,8 @@ public OsItnReader(GraphStorage storage) {
         osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
         osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
         osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
+        pillarInfo = new PillarInfo(nodeAccess.is3D(),
+                graphStorage.getDirectory());
     }
 
     @Override
@@ -239,7 +243,9 @@ public void readGraph() throws IOException {
             throw new IllegalStateException("No OS ITN file specified");
 
         if (!routingFile.exists())
-            throw new IllegalStateException("Your specified OS ITN file does not exist:" + routingFile.getAbsolutePath());
+            throw new IllegalStateException(
+                    "Your specified OS ITN file does not exist:"
+                            + routingFile.getAbsolutePath());
 
         StopWatch sw1 = new StopWatch().start();
         preProcess(routingFile);
@@ -249,7 +255,9 @@ public void readGraph() throws IOException {
         writeOsm2Graph(routingFile);
         sw2.stop();
 
-        logger.info(TIME_PASS1_PASS2_TOTAL_FORMAT, (int) sw1.getSeconds(), (int) sw2.getSeconds(), ((int) (sw1.getSeconds() + sw2.getSeconds())));
+        logger.info(TIME_PASS1_PASS2_TOTAL_FORMAT, (int) sw1.getSeconds(),
+                (int) sw2.getSeconds(),
+                ((int) (sw1.getSeconds() + sw2.getSeconds())));
     }
 
     /**
@@ -264,7 +272,9 @@ void preProcess(File itnFile) {
         }
     }
 
-    private void preProcessDirOrFile(File osmFile) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+    private void preProcessDirOrFile(File osmFile) throws XMLStreamException,
+            IOException, MismatchedDimensionException, FactoryException,
+            TransformException {
         if (osmFile.isDirectory()) {
             String absolutePath = osmFile.getAbsolutePath();
             String[] list = osmFile.list();
@@ -277,18 +287,23 @@ private void preProcessDirOrFile(File osmFile) throws XMLStreamException, IOExce
         }
     }
 
-    private void preProcessSingleFile(File osmFile) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+    private void preProcessSingleFile(File osmFile) throws XMLStreamException,
+            IOException, MismatchedDimensionException, FactoryException,
+            TransformException {
         OsItnInputFile in = null;
         try {
             logger.error(PREPROCESS_FORMAT, osmFile.getName());
-            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads).open();
+            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
+                    .open();
             preProcessSingleFile(in);
         } finally {
             Helper.close(in);
         }
     }
 
-    private void preProcessSingleFile(OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+    private void preProcessSingleFile(OsItnInputFile in)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
         System.out.println("==== preProcessSingleFile");
         long tmpWayCounter = 1;
         long tmpRelationCounter = 1;
@@ -296,7 +311,7 @@ private void preProcessSingleFile(OsItnInputFile in) throws XMLStreamException,
         while ((item = in.getNext()) != null) {
             logger.info(OS_ITN_READER_PRE_PROCESS_FORMAT, item.getType());
             if (item.isType(OSMElement.WAY)) {
-                final Way way = (Way) item;
+                final OSITNWay way = (OSITNWay) item;
                 boolean valid = filterWay(way);
                 if (valid) {
                     TLongList wayNodes = way.getNodes();
@@ -306,7 +321,10 @@ private void preProcessSingleFile(OsItnInputFile in) throws XMLStreamException,
                     }
 
                     if (++tmpWayCounter % 500000 == 0) {
-                        logger.info(PREPROCESS_OSM_ID_MAP_MB_FORMAT, nf(tmpWayCounter), nf(getNodeMap().getSize()), getNodeMap().getMemoryUsage(), Helper.getMemInfo());
+                        logger.info(PREPROCESS_OSM_ID_MAP_MB_FORMAT,
+                                nf(tmpWayCounter), nf(getNodeMap().getSize()),
+                                getNodeMap().getMemoryUsage(),
+                                Helper.getMemInfo());
                     }
                 }
             }
@@ -315,19 +333,25 @@ private void preProcessSingleFile(OsItnInputFile in) throws XMLStreamException,
                 // logger.warn("RELATION :" + item.getClass() + " TYPE:" +
                 // item.getTag(OSITNElement.TAG_KEY_TYPE) + " meta?" +
                 // relation.isMetaRelation());
-                if (!relation.isMetaRelation() && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
+                if (!relation.isMetaRelation()
+                        && relation.hasTag(OSITNElement.TAG_KEY_TYPE, "route"))
                     prepareWaysWithRelationInfo(relation);
 
-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
+                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                        OSITNElement.TAG_VALUE_TYPE_RESTRICTION))
                     prepareRestrictionRelation(relation);
 
-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_NOENTRY)) {
+                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                        OSITNElement.TAG_VALUE_TYPE_NOENTRY)) {
                     prepareNoEntryRelation(relation);
                 }
 
                 // If this way is prohibited then we want to make a note of it
                 // so we don't include it in later route generation
-                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED) || relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED)) {
+                if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                        OSITNElement.TAG_VALUE_TYPE_ACCESS_LIMITED)
+                        || relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                                OSITNElement.TAG_VALUE_TYPE_ACCESS_PROHIBITED)) {
                     prepareAccessProhibitedRelation(relation);
                 }
 
@@ -342,7 +366,10 @@ private void preProcessSingleFile(OsItnInputFile in) throws XMLStreamException,
                 }
 
                 if (++tmpRelationCounter % 50000 == 0) {
-                    logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:" + nf(getRelFlagsMap().size()) + " " + Helper.getMemInfo());
+                    logger.info(nf(tmpRelationCounter)
+                            + " (preprocess), osmWayMap:"
+                            + nf(getRelFlagsMap().size()) + " "
+                            + Helper.getMemInfo());
                 }
 
             }
@@ -352,13 +379,14 @@ private void preProcessSingleFile(OsItnInputFile in) throws XMLStreamException,
     private void prepareRestrictionRelation(Relation relation) {
         OSITNTurnRelation turnRelation = createTurnRelation(relation);
         if (turnRelation != null) {
-            getOsmIdStoreRequiredSet().add(((OSITNTurnRelation) turnRelation).getOsmIdFrom());
-            getOsmIdStoreRequiredSet().add(((OSITNTurnRelation) turnRelation).getOsmIdTo());
+            getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdFrom());
+            getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdTo());
         }
     }
 
     private void prepareAccessProhibitedRelation(Relation relation) {
-        if (!encodingManager.isVehicleQualifierTypeExcluded(relation) && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+        if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
+                && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
             ArrayList<? extends RelationMember> members = relation.getMembers();
             // There will be only one
             for (RelationMember relationMember : members) {
@@ -397,9 +425,11 @@ private void prepareRoadTypeRelation(Relation relation) {
     private void prepareRoadDirectionRelation(Relation relation) {
         // Check if this vehicle has an exception meaning we shouldn't handle
         // one way
-        if (!encodingManager.isVehicleQualifierTypeExcluded(relation) && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+        if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
+                && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
             // This will be "-1" the first time this is called
-            String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION);
+            String orientationIndicator = relation
+                    .getTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION);
             TLongObjectMap<String> edgeIdToRoadDirectionMap = getEdgeRoadDirectionMap();
             ArrayList<? extends RelationMember> members = relation.getMembers();
             for (RelationMember relationMember : members) {
@@ -417,9 +447,11 @@ private void prepareRoadDirectionRelation(Relation relation) {
     private void prepareNoEntryRelation(Relation relation) {
         // Check if this vehicle has an exception meaning we shouldn't handle no
         // entry
-        if (!encodingManager.isVehicleQualifierTypeExcluded(relation) && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+        if (!encodingManager.isVehicleQualifierTypeExcluded(relation)
+                && !encodingManager.isVehicleQualifierTypeIncluded(relation)) {
             long flags = 1l; // (+) orientation
-            String orientationIndicator = relation.getTag(OSITNElement.TAG_KEY_NOENTRY_ORIENTATION);
+            String orientationIndicator = relation
+                    .getTag(OSITNElement.TAG_KEY_NOENTRY_ORIENTATION);
             if ("-1".equals(orientationIndicator)) {
                 flags = 0l; // (-) orientation
             }
@@ -434,7 +466,8 @@ private void prepareNoEntryRelation(Relation relation) {
                 String[] coordParts = coords.split(",");
                 double xCoord = Double.parseDouble(coordParts[0]);
                 double yCoord = Double.parseDouble(coordParts[1]);
-                TDoubleObjectMap<TDoubleLongMap> xCoordMap = edgeIdToXToYToNodeFlagsMap.get(wayId);
+                TDoubleObjectMap<TDoubleLongMap> xCoordMap = edgeIdToXToYToNodeFlagsMap
+                        .get(wayId);
                 if (xCoordMap == null) {
                     xCoordMap = new TDoubleObjectHashMap<TDoubleLongMap>();
                     edgeIdToXToYToNodeFlagsMap.put(wayId, xCoordMap);
@@ -445,7 +478,8 @@ private void prepareNoEntryRelation(Relation relation) {
                     xCoordMap.put(xCoord, yCoordMap);
                 }
                 // now put the flag in there
-                logger.info(EDGE_ID_COORDS_TO_NODE_FLAGS_MAP_PUT_FORMAT, wayId, xCoord, yCoord, flags);
+                logger.info(EDGE_ID_COORDS_TO_NODE_FLAGS_MAP_PUT_FORMAT, wayId,
+                        xCoord, yCoord, flags);
 
                 yCoordMap.put(yCoord, flags);
             }
@@ -459,14 +493,16 @@ private TLongSet getOsmIdStoreRequiredSet() {
     private TIntLongMap getEdgeIdToOsmidMap() {
         logger.info(EDGE_ID_TO_OSMIDMAP_FORMAT, edgeIdToOsmIdMap);
         if (edgeIdToOsmIdMap == null)
-            edgeIdToOsmIdMap = new TIntLongHashMap(getOsmIdStoreRequiredSet().size());
+            edgeIdToOsmIdMap = new TIntLongHashMap(getOsmIdStoreRequiredSet()
+                    .size());
 
         return edgeIdToOsmIdMap;
     }
 
     private TLongObjectMap<ItnNodePair> getNodeEdgeMap() {
         if (edgeIdToNodeMap == null)
-            edgeIdToNodeMap = new TLongObjectHashMap<ItnNodePair>(getOsmIdStoreRequiredSet().size());
+            edgeIdToNodeMap = new TLongObjectHashMap<ItnNodePair>(
+                    getOsmIdStoreRequiredSet().size());
 
         return edgeIdToNodeMap;
     }
@@ -480,21 +516,24 @@ private TLongSet getProhibitedWayIds() {
 
     private TLongObjectMap<String> getEdgeNameMap() {
         if (edgeNameMap == null)
-            edgeNameMap = new TLongObjectHashMap<String>(getOsmIdStoreRequiredSet().size());
+            edgeNameMap = new TLongObjectHashMap<String>(
+                    getOsmIdStoreRequiredSet().size());
 
         return edgeNameMap;
     }
 
     private TLongObjectMap<String> getEdgeRoadTypeMap() {
         if (edgeRoadTypeMap == null)
-            edgeRoadTypeMap = new TLongObjectHashMap<String>(getOsmIdStoreRequiredSet().size());
+            edgeRoadTypeMap = new TLongObjectHashMap<String>(
+                    getOsmIdStoreRequiredSet().size());
 
         return edgeRoadTypeMap;
     }
 
     private TLongObjectMap<String> getEdgeRoadDirectionMap() {
         if (edgeRoadDirectionMap == null)
-            edgeRoadDirectionMap = new TLongObjectHashMap<String>(getOsmIdStoreRequiredSet().size());
+            edgeRoadDirectionMap = new TLongObjectHashMap<String>(
+                    getOsmIdStoreRequiredSet().size());
 
         return edgeRoadDirectionMap;
     }
@@ -515,7 +554,7 @@ private TLongSet getProhibitedWayIds() {
      * 
      * @return true the current xml entry is a way entry and has nodes
      */
-    boolean filterWay(Way way) {
+    boolean filterWay(OSITNWay way) {
         // ignore broken geometry
         if (way.getNodes().size() < 2)
             return false;
@@ -532,14 +571,18 @@ boolean filterWay(Way way) {
      */
     private void writeOsm2Graph(File osmFile) {
         int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
-        logger.error(CREATING_GRAPH_FOUND_NODES_PILLAR_TOWER_FORMAT, nf(getNodeMap().getSize()), Helper.getMemInfo());
+        logger.error(CREATING_GRAPH_FOUND_NODES_PILLAR_TOWER_FORMAT,
+                nf(getNodeMap().getSize()), Helper.getMemInfo());
         graphStorage.create(tmp);
 
         ProcessData processData = new ProcessData();
         try {
             ProcessVisitor processVisitor = new ProcessVisitor() {
                 @Override
-                public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+                public void process(ProcessData processData, OsItnInputFile in)
+                        throws XMLStreamException,
+                        MismatchedDimensionException, FactoryException,
+                        TransformException {
                     logger.error("PROCESS STAGE 1");
                     processStageOne(processData, in);
                 }
@@ -548,7 +591,10 @@ public void process(ProcessData processData, OsItnInputFile in) throws XMLStream
             writeOsm2GraphFromDirOrFile(osmFile, processData, processVisitor);
             processVisitor = new ProcessVisitor() {
                 @Override
-                public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+                public void process(ProcessData processData, OsItnInputFile in)
+                        throws XMLStreamException,
+                        MismatchedDimensionException, FactoryException,
+                        TransformException {
                     logger.error("PROCESS STAGE 2");
                     processStageTwo(processData, in);
                 }
@@ -557,7 +603,10 @@ public void process(ProcessData processData, OsItnInputFile in) throws XMLStream
             writeOsm2GraphFromDirOrFile(osmFile, processData, processVisitor);
             processVisitor = new ProcessVisitor() {
                 @Override
-                public void process(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+                public void process(ProcessData processData, OsItnInputFile in)
+                        throws XMLStreamException,
+                        MismatchedDimensionException, FactoryException,
+                        TransformException {
                     logger.error("PROCESS STAGE 3");
                     processStageThree(processData, in);
                 }
@@ -571,27 +620,37 @@ public void process(ProcessData processData, OsItnInputFile in) throws XMLStream
 
         finishedReading();
         if (graphStorage.getNodes() == 0)
-            throw new IllegalStateException("osm must not be empty. read " + processData.counter + " lines and " + locations + " locations");
+            throw new IllegalStateException("osm must not be empty. read "
+                    + processData.counter + " lines and " + locations
+                    + " locations");
     }
 
-    private void writeOsm2GraphFromDirOrFile(File osmFile, ProcessData processData, ProcessVisitor processVisitor) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+    private void writeOsm2GraphFromDirOrFile(File osmFile,
+            ProcessData processData, ProcessVisitor processVisitor)
+            throws XMLStreamException, IOException,
+            MismatchedDimensionException, FactoryException, TransformException {
         if (osmFile.isDirectory()) {
             String absolutePath = osmFile.getAbsolutePath();
             String[] list = osmFile.list();
             for (String file : list) {
                 File nextFile = new File(absolutePath + File.separator + file);
-                writeOsm2GraphFromDirOrFile(nextFile, processData, processVisitor);
+                writeOsm2GraphFromDirOrFile(nextFile, processData,
+                        processVisitor);
             }
         } else {
             writeOsm2GraphFromSingleFile(osmFile, processData, processVisitor);
         }
     }
 
-    private void writeOsm2GraphFromSingleFile(File osmFile, ProcessData processData, ProcessVisitor processVisitor) throws XMLStreamException, IOException, MismatchedDimensionException, FactoryException, TransformException {
+    private void writeOsm2GraphFromSingleFile(File osmFile,
+            ProcessData processData, ProcessVisitor processVisitor)
+            throws XMLStreamException, IOException,
+            MismatchedDimensionException, FactoryException, TransformException {
         OsItnInputFile in = null;
         try {
             logger.error(PROCESS_FORMAT, osmFile.getName());
-            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads).open();
+            in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
+                    .open();
             processVisitor.process(processData, in);
             logger.info(STORAGE_NODES_FORMAT, graphStorage.getNodes());
         } finally {
@@ -600,14 +659,17 @@ private void writeOsm2GraphFromSingleFile(File osmFile, ProcessData processData,
 
     }
 
-    private void processStageOne(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+    private void processStageOne(ProcessData processData, OsItnInputFile in)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
         System.out.println("==== processStageOne");
         RoutingElement item;
         LongIntMap nodeFilter = getNodeMap();
         while ((item = in.getNext()) != null) {
             switch (item.getType()) {
             case OSMElement.NODE:
-                long id = item.getId();
+                OSITNNode node = (OSITNNode) item;
+                long id = node.getId();
                 logger.info(NODEITEMID_FORMAT, id);
                 if (nodeFilter.get(id) != -1) {
                     OSITNNode nodeItem = (OSITNNode) item;
@@ -626,15 +688,17 @@ private void processStageOne(ProcessData processData, OsItnInputFile in) throws
                     addGradeNodesIfRequired(nodeItem, strId, nodeFilter);
                 }
                 break;
-
             }
             if (++processData.counter % 5000000 == 0) {
-                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations), skippedLocations, Helper.getMemInfo());
+                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
+                        nf(locations), skippedLocations, Helper.getMemInfo());
             }
         }
     }
 
-    private void processStageTwo(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+    private void processStageTwo(ProcessData processData, OsItnInputFile in)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
         System.out.println("==== processStageTwo");
         RoutingElement item;
         LongIntMap nodeFilter = getNodeMap();
@@ -654,13 +718,17 @@ private void processStageTwo(ProcessData processData, OsItnInputFile in) throws
                 break;
             }
             if (++processData.counter % 5000000 == 0) {
-                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations), skippedLocations, Helper.getMemInfo());
+                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
+                        nf(locations), skippedLocations, Helper.getMemInfo());
             }
         }
     }
 
-    private List<OSITNNode> prepareWaysNodes(RoutingElement item, LongIntMap nodeFilter) throws MismatchedDimensionException, FactoryException, TransformException {
-        List<OSITNNode> evaluateWayNodes = ((OSITNWay) item).evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
+    private List<OSITNNode> prepareWaysNodes(RoutingElement item,
+            LongIntMap nodeFilter) throws MismatchedDimensionException,
+            FactoryException, TransformException {
+        List<OSITNNode> evaluateWayNodes = ((OSITNWay) item)
+                .evaluateWayNodes(getEdgeIdToXToYToNodeFlagsMap());
         for (OSITNNode ositnNode : evaluateWayNodes) {
             nodeFilter.put(ositnNode.getId(), PILLAR_NODE);
             processNode(ositnNode);
@@ -669,33 +737,38 @@ private void processStageTwo(ProcessData processData, OsItnInputFile in) throws
         return evaluateWayNodes;
     }
 
-    private void processStageThree(ProcessData processData, OsItnInputFile in) throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
+    private void processStageThree(ProcessData processData, OsItnInputFile in)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
         System.out.println("==== processStageThree");
         RoutingElement item;
         while ((item = in.getNext()) != null) {
             switch (item.getType()) {
-            case OSMElement.RELATION:
-                if (processData.relationStart < 0) {
-                    logger.info(NOW_PARSING_RELATIONS_FORMAT, nf(processData.counter));
-                    processData.relationStart = processData.counter;
-                }
-                processRelation((Relation) item);
-                break;
+                case OSMElement.RELATION:
+                    if (processData.relationStart < 0) {
+                        logger.info(NOW_PARSING_RELATIONS_FORMAT,
+                                nf(processData.counter));
+                        processData.relationStart = processData.counter;
+                    }
+                    processRelation((Relation) item);
+                    break;
             }
             if (++processData.counter % 5000000 == 0) {
-                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter), nf(locations), skippedLocations, Helper.getMemInfo());
+                logger.info(PROCESSING_LOCS_FORMAT, nf(processData.counter),
+                        nf(locations), skippedLocations, Helper.getMemInfo());
             }
         }
     }
 
-    private void addGradeNodesIfRequired(OSITNNode item, String idStr, LongIntMap nodeFilter) {
+    private void addGradeNodesIfRequired(OSITNNode item, String idStr,
+            LongIntMap nodeFilter) {
         String curId;
         for (int i = 1; i <= MAX_GRADE_SEPARATION; i++) {
             curId = i + idStr;
             long parseInt = Long.parseLong(curId);
             if (nodeFilter.get(parseInt) != -1) {
                 OSITNNode gradeNode = item.gradeClone(parseInt);
-                processNode((Node) gradeNode);
+                processNode(gradeNode);
             }
         }
     }
@@ -740,7 +813,8 @@ void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
 
         String wayDirection = getWayRoadDirection(way.getId());
         // If the way is ONEWAY then set the direction
-        if (null != wayDirection && !way.hasTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION)) {
+        if (null != wayDirection
+                && !way.hasTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION)) {
             way.setTag(OSITNElement.TAG_KEY_ONEWAY_ORIENTATION, wayDirection);
         }
         // TODO move this after we have created the edge and know the
@@ -753,14 +827,19 @@ void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
             long lastItnNode = osmNodeIds.get(osmNodeIds.size() - 1);
             int last = getNodeMap().get(lastItnNode);
 
-            logger.info(WAYID_FIRST_LAST_FORMAT, wayOsmId, firstItnNode, lastItnNode);
-            getNodeEdgeMap().put(wayOsmId, new ItnNodePair(firstItnNode, lastItnNode));
+            logger.info(WAYID_FIRST_LAST_FORMAT, wayOsmId, firstItnNode,
+                    lastItnNode);
+            getNodeEdgeMap().put(wayOsmId,
+                    new ItnNodePair(firstItnNode, lastItnNode));
             double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
             double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
-                double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
+            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon)
+                    && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
+                double estimatedDist = distCalc.calcDist(firstLat, firstLon,
+                        lastLat, lastLon);
                 way.setTag("estimated_distance", estimatedDist);
-                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
+                way.setTag("estimated_center", new GHPoint(
+                        (firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
             }
         }
 
@@ -769,55 +848,58 @@ void processWay(OSITNWay way, List<OSITNNode> wayNodes) {
             return;
         }
         // logger.warn(ADDING_RELATION_TO_WAYS_FORMAT, wayFlags);
-        
-        // Check if we need to add additional TOWER nodes at the start and end locations to deal
-        // with a routing algorithm bug which prevents turn restrictions from working when you start or finish on the 
+
+        // Check if we need to add additional TOWER nodes at the start and end
+        // locations to deal
+        // with a routing algorithm bug which prevents turn restrictions from
+        // working when you start or finish on the
         // final edge of a way
         boolean shouldAddStartEndTowers = true;
-        //if (osmNodeIds)
-        osmNodeIds = createStartTowerNodeAndEdge(osmNodeIds, way, wayNodes, wayFlags, wayOsmId);
+        // if (osmNodeIds)
+        osmNodeIds = createStartTowerNodeAndEdge(osmNodeIds, way, wayNodes,
+                wayFlags, wayOsmId);
         // Process No Entry and then Barriers, and finally add the remaining way
         processNoEntry(way, wayNodes, osmNodeIds, wayFlags, wayOsmId);
 
     }
 
-    private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way, List<OSITNNode> wayNodes, long wayFlags, long wayOsmId) {
-        //if (osmNodeIds.size()>2) {
+    private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds,
+            OSITNWay way, List<OSITNNode> wayNodes, long wayFlags, long wayOsmId) {
+        // if (osmNodeIds.size()>2) {
         List<EdgeIteratorState> startCreatedEdges = new ArrayList<EdgeIteratorState>();
-        
+
         // Get the node id of the first pillar node/way node
-        
-        long nodeId = osmNodeIds.get(0); 
-        
-        
-        // Check if we have a pillar node at the start. If so we need to convert to a tower.
+
+        long nodeId = osmNodeIds.get(0);
+
+        // Check if we have a pillar node at the start. If so we need to convert
+        // to a tower.
         int graphIndex = getNodeMap().get(nodeId);
         if (graphIndex < TOWER_NODE) {
-            OSMNode newNode = addBarrierNode(nodeId);
+            OSITNNode newNode = addBarrierNode(nodeId);
             long newNodeId = newNode.getId();
             int nodeType = getNodeMap().get(newNodeId);
-            
+
             // add way up to barrier shadow node
             long transfer[] = osmNodeIds.toArray(0, 2); // From 0 for length
                                                         // 2
             transfer[transfer.length - 1] = newNodeId;
             TLongList partIds = new TLongArrayList(transfer);
-            Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+            Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
+                    wayFlags, wayOsmId);
             // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
             startCreatedEdges.addAll(newWays);
             
             // Set the 0th node id to be our new node id
             osmNodeIds.set(0, newNodeId);
     
-            
             for (EdgeIteratorState edge : startCreatedEdges) {
                 encodingManager.applyWayTags(way, edge);
             }
         }
         return osmNodeIds;
     }
-    
-    
+
     /**
      * This method processes the list of NodeIds and checks if any nodes have a
      * NoEntry Tag. If it does then it adds a shadow node and an extra way as a
@@ -835,13 +917,16 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
      * @param wayOsmId
      * @return
      */
-    private List<EdgeIteratorState> processNoEntry(OSITNWay way, List<OSITNNode> wayNodes, TLongList osmNodeIds, long wayFlags, long wayOsmId) {
+    private List<EdgeIteratorState> processNoEntry(OSITNWay way,
+            List<OSITNNode> wayNodes, TLongList osmNodeIds, long wayFlags,
+            long wayOsmId) {
         List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
         int lastNoEntry = -1;
         List<EdgeIteratorState> noEntryCreatedEdges = new ArrayList<EdgeIteratorState>();
         boolean modifiedWithNoEntry = false;
         // Process Start Coordinate
-        String startDirection = checkForNoEntryDirection(wayOsmId, way.getStartCoord());
+        String startDirection = checkForNoEntryDirection(wayOsmId,
+                way.getStartCoord());
         if (startDirection != null) {
             modifiedWithNoEntry = true;
             lastNoEntry = 1; // This will set the index used for way nodes
@@ -852,19 +937,21 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
             if (graphIndex != EMPTY) {
 
                 long nodeFlags = getNodeFlagsMap().get(nodeId);
-                OSMNode newNode = addBarrierNode(nodeId);
+                OSITNNode newNode = addBarrierNode(nodeId);
                 long newNodeId = newNode.getId();
                 // add way up to barrier shadow node
                 long transfer[] = osmNodeIds.toArray(0, 2); // From 0 for length
                                                             // 2
                 transfer[transfer.length - 1] = newNodeId;
                 TLongList partIds = new TLongArrayList(transfer);
-                Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+                Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
+                        wayFlags, wayOsmId);
                 // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
                 noEntryCreatedEdges.addAll(newWays);
 
                 // create zero length edge for barrier to the next node
-                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                        newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
                 // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                 // newBarriers.size());
                 noEntryCreatedEdges.addAll(newBarriers);
@@ -872,21 +959,34 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
                 for (EdgeIteratorState edgeIteratorState : newWays) {
                     boolean forwards = startDirection.equals("true");
 
-                    long flags = encodingManager.flagsDefault(forwards, !forwards);
+                    long flags = encodingManager.flagsDefault(forwards,
+                            !forwards);
                     // Set the flags on our new edge.
                     edgeIteratorState.setFlags(flags);
                 }
                 successfulStartNoEntries++;
             } else {
                 failedStartNoEntries++;
-                errors_logger.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId " + nodeId + " on way " + way.getId() + " for START Node " + osmNodeIds.toString() + " (" + successfulStartNoEntries + " succeeded, " + failedStartNoEntries + " failed)");
+                errors_logger
+                        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+                                + nodeId
+                                + " on way "
+                                + way.getId()
+                                + " for START Node "
+                                + osmNodeIds.toString()
+                                + " ("
+                                + successfulStartNoEntries
+                                + " succeeded, "
+                                + failedStartNoEntries
+                                + " failed)");
             }
         }
         // Process Way Nodes
         final int size = osmNodeIds.size();
         for (int i = 1, j = 0; j < wayNodes.size(); i++, j++) {
             OSITNNode ositnNode = wayNodes.get(j);
-            String direction = checkForNoEntryDirection(wayOsmId, way.getWayCoords()[j]);
+            String direction = checkForNoEntryDirection(wayOsmId,
+                    way.getWayCoords()[j]);
             // If direction is null then there is no No Entry defined for this
             // way node
             if (direction != null) {
@@ -895,7 +995,7 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
                 long nodeFlags = getNodeFlagsMap().get(nodeId);
 
                 // create shadow node copy for zero length edge
-                OSMNode newNode = addBarrierNode(nodeId);
+                OSITNNode newNode = addBarrierNode(nodeId);
                 long newNodeId = newNode.getId();
                 // Always > 0 as we start at index 1
                 if (i > 0) {
@@ -905,16 +1005,19 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
                     if (lastNoEntry < 0)
                         lastNoEntry = 0;
                     // add way up to barrier shadow node
-                    long transfer[] = osmNodeIds.toArray(lastNoEntry, i - lastNoEntry + 1);
+                    long transfer[] = osmNodeIds.toArray(lastNoEntry, i
+                            - lastNoEntry + 1);
                     transfer[transfer.length - 1] = newNodeId;
                     TLongList partIds = new TLongArrayList(transfer);
-                    Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+                    Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
+                            wayFlags, wayOsmId);
                     // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
                     // newWays.size());
                     noEntryCreatedEdges.addAll(newWays);
 
                     // create zero length edge for barrier to the next node
-                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                            newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
                     // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                     // newBarriers.size());
                     noEntryCreatedEdges.addAll(newBarriers);
@@ -922,7 +1025,8 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
                     for (EdgeIteratorState edgeIteratorState : newBarriers) {
                         boolean forwards = direction.equals("true");
 
-                        long flags = encodingManager.flagsDefault(forwards, !forwards);
+                        long flags = encodingManager.flagsDefault(forwards,
+                                !forwards);
                         // Set the flags on our new edge.
                         edgeIteratorState.setFlags(flags);
                     }
@@ -931,7 +1035,8 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
                     // when the no entry is placed on either
                     // TODO end of way we will have issues
                     // run edge from real first node to shadow node
-                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId);
+                    Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                            nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId);
                     // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                     // newBarriers.size());
                     noEntryCreatedEdges.addAll(newBarriers);
@@ -946,7 +1051,8 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
         // Process the last coordinate
         boolean processedEntireWay = false;
         TLongList nodeIdsToCreateWaysFor = null;
-        String endDirection = checkForNoEntryDirection(wayOsmId, way.getEndCoord());
+        String endDirection = checkForNoEntryDirection(wayOsmId,
+                way.getEndCoord());
         if (endDirection != null) {
             // Get the last node id
             long nodeId = osmNodeIds.get(osmNodeIds.size() - 1);
@@ -958,9 +1064,11 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
                 {
                     if (lastNoEntry < 0)
                         lastNoEntry = 0;
-                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size - lastNoEntry - 1);
+                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size
+                            - lastNoEntry - 1);
                     nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
-                    Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
+                    Collection<EdgeIteratorState> newEdges = addOSMWay(
+                            nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
                     // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
                     // newEdges.size());
                     createdEdges.addAll(newEdges);
@@ -972,13 +1080,13 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
                 processedEntireWay = true;
                 long nodeFlags = getNodeFlagsMap().get(nodeId);
                 // create shadow node copy for zero length edge
-                OSMNode newNode = addBarrierNode(nodeId);
+                OSITNNode newNode = addBarrierNode(nodeId);
                 long newNodeId = newNode.getId();
-                
-                // Set this to be a TOWER node explicitly to overcome a limitation in the GraphHopper code for TurnRestrictions
-                //getNodeMap().put(newNodeId, TOWER_NODE);
 
-                
+                // Set this to be a TOWER node explicitly to overcome a
+                // limitation in the GraphHopper code for TurnRestrictions
+                // getNodeMap().put(newNodeId, TOWER_NODE);
+
                 // add way up to barrier shadow node
                 long transfer[] = osmNodeIds.toArray(osmNodeIds.size() - 2, 2); // From
                                                                                 // 0
@@ -987,19 +1095,22 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
                                                                                 // 2
                 transfer[transfer.length - 1] = newNodeId;
                 TLongList partIds = new TLongArrayList(transfer);
-                Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+                Collection<EdgeIteratorState> newWays = addOSMWay(partIds,
+                        wayFlags, wayOsmId);
                 // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId, newWays.size());
                 noEntryCreatedEdges.addAll(newWays);
 
                 // create zero length edge for barrier to the next node
-                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                        newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
                 // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                 // newBarriers.size());
                 noEntryCreatedEdges.addAll(newBarriers);
                 // Update the orientation of our little one way
                 for (EdgeIteratorState edgeIteratorState : newBarriers) {
                     boolean forwards = endDirection.equals("-1");
-                    long flags = encodingManager.flagsDefault(forwards, !forwards);
+                    long flags = encodingManager.flagsDefault(forwards,
+                            !forwards);
                     // Set the flags on our new edge.
                     edgeIteratorState.setFlags(flags);
                 }
@@ -1008,7 +1119,18 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
                 failedEndNoEntries++;
                 // TODO Figure out why there are some end nodes that don't have
                 // internal node ids
-                errors_logger.error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId " + nodeId + " on way " + way.getId() + " for END Node " + osmNodeIds.toString() + " (" + successfulEndNoEntries + " succeeded, " + failedEndNoEntries + " failed)");
+                errors_logger
+                        .error("MISSING NODE: osmNodeIdToInternalNodeMap returned -1 for nodeId "
+                                + nodeId
+                                + " on way "
+                                + way.getId()
+                                + " for END Node "
+                                + osmNodeIds.toString()
+                                + " ("
+                                + successfulEndNoEntries
+                                + " succeeded, "
+                                + failedEndNoEntries
+                                + " failed)");
             }
         }
 
@@ -1019,7 +1141,8 @@ private TLongList createStartTowerNodeAndEdge(TLongList osmNodeIds, OSITNWay way
             // node
             if (modifiedWithNoEntry) {
                 if (lastNoEntry < size - 1) {
-                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size - lastNoEntry);
+                    long transfer[] = osmNodeIds.toArray(lastNoEntry, size
+                            - lastNoEntry);
                     nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
                 }
             } else {
@@ -1052,7 +1175,8 @@ private String checkForNoEntryDirection(long wayId, String wayCoord) {
         // Look for direction flags in edgeIdToXToYToNodeFlagsMap for the wayId,
         // x, y combination
         long key = wayId;
-        TDoubleObjectMap<TDoubleLongMap> xToYToNodeFlagsMap = getEdgeIdToXToYToNodeFlagsMap().get(key);
+        TDoubleObjectMap<TDoubleLongMap> xToYToNodeFlagsMap = getEdgeIdToXToYToNodeFlagsMap()
+                .get(key);
         if (xToYToNodeFlagsMap != null) {
             String[] coordParts = wayCoord.split(",");
             double xCoord = Double.parseDouble(coordParts[0]);
@@ -1102,7 +1226,8 @@ private String checkForNoEntryDirection(long wayId, String wayCoord) {
      * @param wayOsmId
      * @return
      */
-    private List<EdgeIteratorState> processBarriers(Way way, TLongList osmNodeIds, long wayFlags, long wayOsmId) {
+    private List<EdgeIteratorState> processBarriers(Way way,
+            TLongList osmNodeIds, long wayFlags, long wayOsmId) {
         List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
         // look for barriers along the way
         final int size = osmNodeIds.size();
@@ -1122,7 +1247,7 @@ private String checkForNoEntryDirection(long wayId, String wayCoord) {
                     getNodeFlagsMap().put(nodeId, 0);
 
                     // create shadow node copy for zero length edge
-                    OSMNode newNode = addBarrierNode(nodeId);
+                    OSITNNode newNode = addBarrierNode(nodeId);
                     long newNodeId = newNode.getId();
                     if (i > 0) {
                         // start at beginning of array if there was no
@@ -1132,22 +1257,28 @@ private String checkForNoEntryDirection(long wayId, String wayCoord) {
                             lastBarrier = 0;
 
                         // add way up to barrier shadow node
-                        long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
+                        long transfer[] = osmNodeIds.toArray(lastBarrier, i
+                                - lastBarrier + 1);
                         transfer[transfer.length - 1] = newNodeId;
                         TLongList partIds = new TLongArrayList(transfer);
-                        Collection<EdgeIteratorState> newWays = addOSMWay(partIds, wayFlags, wayOsmId);
+                        Collection<EdgeIteratorState> newWays = addOSMWay(
+                                partIds, wayFlags, wayOsmId);
                         // logger.warn(WAY_ADDS_EDGES_FORMAT, wayOsmId,
                         // newWays.size());
                         createdEdges.addAll(newWays);
 
                         // create zero length edge for barrier
-                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId);
+                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                                newNodeId, nodeId, wayFlags, nodeFlags,
+                                wayOsmId);
                         // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                         // newBarriers.size());
                         createdEdges.addAll(newBarriers);
                     } else {
                         // run edge from real first node to shadow node
-                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId);
+                        Collection<EdgeIteratorState> newBarriers = addBarrierEdge(
+                                nodeId, newNodeId, wayFlags, nodeFlags,
+                                wayOsmId);
                         // logger.warn(WAY_ADDS_BARRIER_EDGES_FORMAT, wayOsmId,
                         // newBarriers.size());
                         createdEdges.addAll(newBarriers);
@@ -1167,7 +1298,8 @@ private String checkForNoEntryDirection(long wayId, String wayCoord) {
         TLongList nodeIdsToCreateWaysFor = null;
         if (lastBarrier >= 0) {
             if (lastBarrier < size - 1) {
-                long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
+                long transfer[] = osmNodeIds.toArray(lastBarrier, size
+                        - lastBarrier);
                 nodeIdsToCreateWaysFor = new TLongArrayList(transfer);
             }
         } else {
@@ -1176,7 +1308,9 @@ private String checkForNoEntryDirection(long wayId, String wayCoord) {
         }
 
         if (nodeIdsToCreateWaysFor != null) {
-            long lastNodeId = nodeIdsToCreateWaysFor.get(nodeIdsToCreateWaysFor.size()-1);;
+            long lastNodeId = nodeIdsToCreateWaysFor.get(nodeIdsToCreateWaysFor
+                    .size() - 1);
+            ;
             long newNodeId = -1;
 
             int graphIndex = getNodeMap().get(lastNodeId);// -4 for wayOsmId 4000000025288017
@@ -1186,18 +1320,19 @@ private String checkForNoEntryDirection(long wayId, String wayCoord) {
 
             // add end tower here
             if (doInsertAdditionalTowerNodes) {
-                OSMNode newNode = addBarrierNode(lastNodeId);
+                OSITNNode newNode = addBarrierNode(lastNodeId);
                 newNodeId = newNode.getId();
-                int nodeType = getNodeMap().get(newNodeId);
-                
-                nodeIdsToCreateWaysFor.set(nodeIdsToCreateWaysFor.size()-1, newNodeId);
-            }            
 
-            Collection<EdgeIteratorState> newEdges = addOSMWay(nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
+                nodeIdsToCreateWaysFor.set(nodeIdsToCreateWaysFor.size() - 1,
+                        newNodeId);
+            }
+
+            Collection<EdgeIteratorState> newEdges = addOSMWay(
+                    nodeIdsToCreateWaysFor, wayFlags, wayOsmId);
 
             createdEdges.addAll(newEdges);
             if (doInsertAdditionalTowerNodes) {
-                long transfer[] = {newNodeId, lastNodeId};
+                long transfer[] = { newNodeId, lastNodeId };
                 TLongList partIds = new TLongArrayList(transfer);
                 newEdges = addOSMWay(partIds, wayFlags, wayOsmId);
                 createdEdges.addAll(newEdges);
@@ -1229,23 +1364,30 @@ private String getWayRoadDirection(long id) {
      * @throws XMLStreamException
      */
     public void processRelation(Relation relation) throws XMLStreamException {
-        if (relation.hasTag(OSITNElement.TAG_KEY_TYPE, OSITNElement.TAG_VALUE_TYPE_RESTRICTION)) {
+        if (relation.hasTag(OSITNElement.TAG_KEY_TYPE,
+                OSITNElement.TAG_VALUE_TYPE_RESTRICTION)) {
             OSITNTurnRelation turnRelation = createTurnRelation(relation);
             if (turnRelation != null) {
-                long fromId = ((OSITNTurnRelation) turnRelation).getOsmIdFrom();
-                long toId = ((OSITNTurnRelation) turnRelation).getOsmIdTo();
+                long fromId = turnRelation.getOsmIdFrom();
+                long toId = turnRelation.getOsmIdTo();
                 // These were not originally added here. This could be used to
                 // clean up getEdgeIdToOsmidMap() as it will now contain all
                 // edgeIdToOsmId mappings
                 getOsmIdStoreRequiredSet().add(fromId);
                 getOsmIdStoreRequiredSet().add(toId);
 
-                logger.info(TURN_FROM_TO_VIA_FORMAT, turnRelation.getOsmIdFrom(), turnRelation.getOsmIdTo(), turnRelation.getVia());
-                ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage).getExtendedStorage();
+                logger.info(TURN_FROM_TO_VIA_FORMAT,
+                        turnRelation.getOsmIdFrom(), turnRelation.getOsmIdTo(),
+                        turnRelation.getVia());
+                ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
+                        .getExtendedStorage();
                 if (extendedStorage instanceof TurnCostStorage) {
-                    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(turnRelation, this);
+                    Collection<ITurnCostTableEntry> entries = encodingManager
+                            .analyzeTurnRelation(turnRelation, this);
                     for (ITurnCostTableEntry entry : entries) {
-                        ((TurnCostStorage) extendedStorage).addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(), (int) entry.getFlags());
+                        ((TurnCostStorage) extendedStorage).addTurnInfo(
+                                entry.getVia(), entry.getEdgeFrom(),
+                                entry.getEdgeTo(), (int) entry.getFlags());
                     }
                 }
             }
@@ -1256,7 +1398,8 @@ public void processRelation(Relation relation) throws XMLStreamException {
         // }
     }
 
-    public long getOsmIdOfInternalEdge(int edgeId) {
+    @Override
+    public Long getOsmIdOfInternalEdge(int edgeId) {
         return getEdgeIdToOsmidMap().get(edgeId);
     }
 
@@ -1264,7 +1407,8 @@ public long getInternalIdOfOsmEdge(int edgeId) {
         return getEdgeIdToOsmidMap().get(edgeId);
     }
 
-    public int getInternalNodeIdOfOsmNode(long nodeOsmId) {
+    @Override
+    public int getInternalNodeIdOfOsmNode(Long nodeOsmId) {
         int id = getNodeMap().get(nodeOsmId);
         if (id < TOWER_NODE)
             return -id - 3;
@@ -1308,7 +1452,7 @@ public int getInternalNodeIdOfOsmNode(long nodeOsmId) {
             return Double.NaN;
     }
 
-    private void processNode(Node node) {
+    private void processNode(OSITNNode node) {
         if (isInBounds(node)) {
             addNode(node);
 
@@ -1327,7 +1471,7 @@ private void processNode(Node node) {
         }
     }
 
-    boolean addNode(Node node) {
+    boolean addNode(OSITNNode node) {
         int nodeType = getNodeMap().get(node.getId());
         if (nodeType == EMPTY) {
             // logger.warn(MISSING_FROM_MAP_FORMAT, node.getId());
@@ -1353,7 +1497,8 @@ private double getElevation(Node node) {
 
     void prepareWaysWithRelationInfo(Relation relation) {
         // is there at least one tag interesting for the registered encoders?
-        long handleRelationTags = encodingManager.handleRelationTags(relation, 0);
+        long handleRelationTags = encodingManager.handleRelationTags(relation,
+                0);
         // logger.warn(PREPARE_ONE_WAY_FORMAT, handleRelationTags);
         if (handleRelationTags == 0) {
             return;
@@ -1370,7 +1515,8 @@ void prepareWaysWithRelationInfo(Relation relation) {
 
             // Check if our new relation data is better comparated to the the
             // last one
-            long newRelationFlags = encodingManager.handleRelationTags(relation, oldRelationFlags);
+            long newRelationFlags = encodingManager.handleRelationTags(
+                    relation, oldRelationFlags);
             // logger.warn(APPLYING_RELATION_FORMAT, oldRelationFlags,
             // newRelationFlags);
             if (oldRelationFlags != newRelationFlags) {
@@ -1383,11 +1529,13 @@ void prepareHighwayNode(long osmId) {
         int tmpIndex = getNodeMap().get(osmId);
         if (tmpIndex == EMPTY) {
             // osmId is used exactly once
-            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_EMPTY_PILLAR_FORMAT, osmId);
+            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_EMPTY_PILLAR_FORMAT,
+                    osmId);
             getNodeMap().put(osmId, PILLAR_NODE);
         } else if (tmpIndex > EMPTY) {
             // mark node as tower node as it occured at least twice times
-            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_PILLAR_TOWER_FORMAT, osmId);
+            logger.info(OS_ITN_READER_PREPARE_HIGHWAY_NODE_PILLAR_TOWER_FORMAT,
+                    osmId);
             getNodeMap().put(osmId, TOWER_NODE);
         } else {
             // tmpIndex is already negative (already tower node)
@@ -1410,8 +1558,10 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
      * This method creates from an OSM way (via the osm ids) one or more edges
      * in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags, long wayOsmId) {
-        PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
+    Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags,
+            long wayOsmId) {
+        PointList pointList = new PointList(osmNodeIds.size(),
+                nodeAccess.is3D());
         List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
         int firstNode = -1;
         int lastIndex = osmNodeIds.size() - 1;
@@ -1435,14 +1585,16 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
                     // current file.
                     // => if the node before was a pillar node then convert into
                     // to tower node (as it is also end-standing).
-                    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE) {
+                    if (!pointList.isEmpty()
+                            && lastInBoundsPillarNode > -TOWER_NODE) {
                         // transform the pillar node to a tower node
                         tmpNode = lastInBoundsPillarNode;
                         tmpNode = handlePillarNode(tmpNode, osmId, null, true);
                         tmpNode = -tmpNode - 3;
                         if (pointList.getSize() > 1 && firstNode >= 0) {
                             // TOWER node
-                            newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+                            newEdges.add(addEdge(firstNode, tmpNode, pointList,
+                                    flags, wayOsmId));
                             pointList.clear();
                             pointList.add(nodeAccess, tmpNode);
                         }
@@ -1453,7 +1605,9 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
                 }
 
                 if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
-                    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", " + osmId);
+                    throw new AssertionError(
+                            "Mapped index not in correct bounds " + tmpNode
+                                    + ", " + osmId);
 
                 if (tmpNode > -TOWER_NODE) {
                     boolean convertToTowerNode = i == 0 || i == lastIndex;
@@ -1462,7 +1616,8 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
                     }
 
                     // PILLAR node, but convert to towerNode if end-standing
-                    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
+                    tmpNode = handlePillarNode(tmpNode, osmId, pointList,
+                            convertToTowerNode);
                 }
 
                 if (tmpNode < TOWER_NODE) {
@@ -1470,7 +1625,8 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
                     tmpNode = -tmpNode - 3;
                     pointList.add(nodeAccess, tmpNode);
                     if (firstNode >= 0) {
-                        newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+                        newEdges.add(addEdge(firstNode, tmpNode, pointList,
+                                flags, wayOsmId));
                         pointList.clear();
                         pointList.add(nodeAccess, tmpNode);
                     }
@@ -1478,26 +1634,35 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
                 }
             }
         } catch (RuntimeException ex) {
-            logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
+            logger.error("Couldn't properly add edge with osm ids:"
+                    + osmNodeIds, ex);
             if (exitOnlyPillarNodeException)
                 throw ex;
         }
         return newEdges;
     }
 
-    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId) {
+    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
+            long flags, long wayOsmId) {
         // sanity checks
         if (fromIndex < 0 || toIndex < 0)
-            throw new AssertionError("to or from index is invalid for this edge " + fromIndex + "->" + toIndex + ", points:" + pointList);
+            throw new AssertionError(
+                    "to or from index is invalid for this edge " + fromIndex
+                            + "->" + toIndex + ", points:" + pointList);
         if (pointList.getDimension() != nodeAccess.getDimension())
-            throw new AssertionError("Dimension does not match for pointList vs. nodeAccess " + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
+            throw new AssertionError(
+                    "Dimension does not match for pointList vs. nodeAccess "
+                            + pointList.getDimension() + " <-> "
+                            + nodeAccess.getDimension());
 
         double towerNodeDistance = 0;
         double prevLat = pointList.getLatitude(0);
         double prevLon = pointList.getLongitude(0);
-        double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
+        double prevEle = pointList.is3D() ? pointList.getElevation(0)
+                : Double.NaN;
         double lat, lon, ele = Double.NaN;
-        PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
+        PointList pillarNodes = new PointList(pointList.getSize() - 2,
+                nodeAccess.is3D());
         int nodes = pointList.getSize();
         for (int i = 1; i < nodes; i++) {
             // we could save some lines if we would use
@@ -1506,10 +1671,12 @@ EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long
             lon = pointList.getLongitude(i);
             if (pointList.is3D()) {
                 ele = pointList.getElevation(i);
-                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
+                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon,
+                        prevEle, lat, lon, ele);
                 prevEle = ele;
             } else
-                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
+                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat,
+                        lon);
             prevLat = lat;
             prevLon = lon;
             if (nodes > 2 && i < nodes - 1) {
@@ -1527,7 +1694,8 @@ EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long
             towerNodeDistance = 0.0001;
         }
         logger.info("Add edge flags:" + flags);
-        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex).setDistance(towerNodeDistance).setFlags(flags);
+        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
+                .setDistance(towerNodeDistance).setFlags(flags);
         if (nodes > 2) {
             if (doSimplify)
                 simplifyAlgo.simplify(pillarNodes);
@@ -1556,18 +1724,23 @@ private void storeOSMWayID(int edgeId, long osmWayID) {
     /**
      * @return converted tower node
      */
-    private int handlePillarNode(int tmpNode, long osmId, PointList pointList, boolean convertToTowerNode) {
-        logger.info(CONVERTING_PILLAR_TO_PILLAR_FORMAT, osmId, convertToTowerNode);
+    private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
+            boolean convertToTowerNode) {
+        logger.info(CONVERTING_PILLAR_TO_PILLAR_FORMAT, osmId,
+                convertToTowerNode);
         tmpNode = tmpNode - 3;
         double lat = pillarInfo.getLatitude(tmpNode);
         double lon = pillarInfo.getLongitude(tmpNode);
         double ele = pillarInfo.getElevation(tmpNode);
         if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
-            throw new RuntimeException("Conversion pillarNode to towerNode already happended!? " + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+            throw new RuntimeException(
+                    "Conversion pillarNode to towerNode already happended!? "
+                            + "osmId:" + osmId + " pillarIndex:" + tmpNode);
 
         if (convertToTowerNode) {
             // convert pillarNode type to towerNode, make pillar values invalid
-            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
+            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE,
+                    Double.MAX_VALUE);
             tmpNode = addTowerNode(osmId, lat, lon, ele);
         } else {
             if (pointList.is3D())
@@ -1576,7 +1749,7 @@ private int handlePillarNode(int tmpNode, long osmId, PointList pointList, boole
                 pointList.add(lat, lon);
         }
 
-        return (int) tmpNode;
+        return tmpNode;
     }
 
     protected void finishedReading() {
@@ -1594,17 +1767,24 @@ protected void finishedReading() {
     /**
      * Create a copy of the barrier node
      */
-    private OSMNode addBarrierNode(long nodeId) {
-        OSMNode newNode = null;
+    private OSITNNode addBarrierNode(long nodeId) {
+        OSITNNode newNode = null;
         int graphIndex = getNodeMap().get(nodeId);
+        // System.out.println("graphIndex BEFORE is " + graphIndex);
 
         if (graphIndex < TOWER_NODE) {
             graphIndex = -graphIndex - 3;
-            newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
+            // System.out.println("Create Tower node for nodeId " + nodeId +
+            // " graphIndex is " + graphIndex);
+            newNode = new OSITNNode(createNewNodeId(), nodeAccess, graphIndex);
         } else {
             graphIndex = graphIndex - 3;
             try {
-                newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
+                // System.out.println("Create Pillar node for nodeId " + nodeId
+                // + " graphIndex is " + graphIndex);
+                newNode = new OSITNNode(createNewNodeId(), pillarInfo,
+                        graphIndex);
+                // System.out.println("newNode is " + newNode);
             } catch (ArrayIndexOutOfBoundsException e) {
                 e.printStackTrace();
             }
@@ -1615,12 +1795,13 @@ private OSMNode addBarrierNode(long nodeId) {
         addNode(newNode);
         return newNode;
     }
+
     /**
      * Create a copy of the barrier node
      */
-    private OSMNode addBarrierNode(long nodeId, double lat, double lon) {
-        OSMNode newNode = null;
-        newNode = new OSMNode(createNewNodeId(), lat, lon);
+    private OSITNNode addBarrierNode(long nodeId, double lat, double lon) {
+        OSITNNode newNode = null;
+        newNode = new OSITNNode(createNewNodeId(), lat, lon);
 
         final long id = newNode.getId();
         prepareHighwayNode(id);
@@ -1635,7 +1816,8 @@ private long createNewNodeId() {
     /**
      * Add a zero length edge with reduced routing options to the graph.
      */
-    private Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, long flags, long nodeFlags, long wayOsmId) {
+    private Collection<EdgeIteratorState> addBarrierEdge(long fromId,
+            long toId, long flags, long nodeFlags, long wayOsmId) {
         // clear barred directions from routing flags
         flags &= ~nodeFlags;
         // add edge
@@ -1653,7 +1835,9 @@ private long createNewNodeId() {
      *         relation
      */
     OSITNTurnRelation createTurnRelation(Relation relation) {
-        OSMTurnRelation.Type type = OSITNTurnRelation.getRestrictionType((String) relation.getTag(OSITNElement.TAG_KEY_RESTRICTION));
+        OSMTurnRelation.Type type = OSITNTurnRelation
+                .getRestrictionType(relation
+                        .getTag(OSITNElement.TAG_KEY_RESTRICTION));
 
         // Handle No Turn and Mandatory Turn Exceptions. This is done by
         // selectively ignoring restrictions based on excluded/included vehicle
@@ -1667,7 +1851,8 @@ OSITNTurnRelation createTurnRelation(Relation relation) {
         // if (no turn (Type.NOT) except buses=false) remove the restriction
         if (type == Type.NOT || type == Type.ONLY) {
             // There is a no entry or mandatory turn
-            if (encodingManager.isVehicleQualifierTypeExcluded(relation) || encodingManager.isVehicleQualifierTypeIncluded(relation)) {
+            if (encodingManager.isVehicleQualifierTypeExcluded(relation)
+                    || encodingManager.isVehicleQualifierTypeIncluded(relation)) {
                 // The current encoder vehicle is excluded from this restriction
                 // so remove it OR (except buses=false)
                 // The current encoder vehicle is included in the exception so
@@ -1691,15 +1876,18 @@ OSITNTurnRelation createTurnRelation(Relation relation) {
                     } else if ("to".equals(member.role())) {
                         toWayID = ref;
                     }
-                } else if (OSMElement.NODE == member.type() && "via".equals(member.role())) {
+                } else if (OSMElement.NODE == member.type()
+                        && "via".equals(member.role())) {
                     viaNodeID = ref;
                 }
             }
 
-            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0 && toWayID >= 0) {
+            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0
+                    && toWayID >= 0) {
                 long foundViaNode = findViaNode(fromWayID, toWayID);
                 if (-1 < foundViaNode) {
-                    OSITNTurnRelation osmTurnRelation = new OSITNTurnRelation(fromWayID, foundViaNode, toWayID, type);
+                    OSITNTurnRelation osmTurnRelation = new OSITNTurnRelation(
+                            fromWayID, foundViaNode, toWayID, type);
                     return osmTurnRelation;
                 }
             }
@@ -1732,40 +1920,50 @@ TLongLongHashMap getRelFlagsMap() {
     /**
      * Specify the type of the path calculation (car, bike, ...).
      */
+    @Override
     public OsItnReader setEncodingManager(EncodingManager acceptWay) {
         this.encodingManager = acceptWay;
         return this;
     }
 
+    @Override
     public OsItnReader setWayPointMaxDistance(double maxDist) {
         doSimplify = maxDist > 0;
         simplifyAlgo.setMaxDistance(maxDist);
         return this;
     }
 
+    @Override
     public OsItnReader setWorkerThreads(int numOfWorkers) {
         this.workerThreads = numOfWorkers;
         return this;
     }
 
+    @Override
     public OsItnReader setElevationProvider(ElevationProvider eleProvider) {
         if (eleProvider == null)
-            throw new IllegalStateException("Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+            throw new IllegalStateException(
+                    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
 
         if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
-            throw new IllegalStateException("Make sure you graph accepts 3D data");
+            throw new IllegalStateException(
+                    "Make sure you graph accepts 3D data");
 
         this.eleProvider = eleProvider;
         return this;
     }
 
+    @Override
     public OsItnReader setOSMFile(File osmFile) {
         this.routingFile = osmFile;
         return this;
     }
 
     private void printInfo(String str) {
-        logger.info(PRINT_INFO_FORMAT, str, graphStorage.getNodes(), getNodeMap().getSize(), getNodeMap().getMemoryUsage(), getNodeFlagsMap().size(), getRelFlagsMap().size(), Helper.getMemInfo());
+        logger.info(PRINT_INFO_FORMAT, str, graphStorage.getNodes(),
+                getNodeMap().getSize(), getNodeMap().getMemoryUsage(),
+                getNodeFlagsMap().size(), getRelFlagsMap().size(),
+                Helper.getMemInfo());
     }
 
     @Override
@@ -1773,6 +1971,7 @@ public String toString() {
         return getClass().getSimpleName();
     }
 
+    @Override
     public GraphStorage getGraphStorage() {
         return graphStorage;
     }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
index 87cb976ef8..ef4526d9de 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
@@ -27,6 +27,9 @@
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
+import org.opengis.geometry.MismatchedDimensionException;
+import org.opengis.referencing.FactoryException;
+import org.opengis.referencing.operation.TransformException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -40,242 +43,277 @@
  * @author Peter
  */
 public abstract class OsDpnElement implements RoutingElement {
-	public static final int NODE = 0;
-	public static final int WAY = 1;
-	public static final int RELATION = 2;
-	private final int type;
-	private final long id;
-	private final Map<String, Object> properties = new HashMap<String, Object>(
-			5);
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsDpnElement.class);
-
-	protected OsDpnElement(long id, int type) {
-		this.id = id;
-		this.type = type;
-	}
-
-	public long getId() {
-		return id;
-	}
-
-	protected void readTags(XMLStreamReader parser) throws XMLStreamException {
-		int event = parser.getEventType();
-		while (event != XMLStreamConstants.END_DOCUMENT  && (event != XMLStreamConstants.END_ELEMENT || !exitElement(parser))) {
-			if (event == XMLStreamConstants.CHARACTERS) {
-				event = parser.next();
-			} else {
-				
-			if (event == XMLStreamConstants.START_ELEMENT) {
-				logger.info("LOCALNAME:"+parser.getLocalName());
-				switch (parser.getLocalName()) {
-				case "coordinates": {
-						event = handleCoordinates(parser);
-						break;
-					}
-				case "networkMember" : {
-					event = handleNetworkMember(parser);
-					break;
-				}
-				case "directedNode" : {
-					event = handleDirectedNode(parser);
-					break;
-				}
-				case "directedLink" : {
-					event = handleDirectedLink(parser);
-					break;
-				}
-				case "instruction" : {
-					System.err.println("INSTRUCTION:");
-					setTag("type", "restriction");
-					event = handleTag("restriction",parser);
-					break;
-				}
-				case "roadName" : {
-					event = handleTag("name", parser);
-					break;
-				}
-				default : {
-						event = parser.next();
-					}
-				}
-				
-				
-//				int attributeCount = parser.getAttributeCount();
-//				for (int i = 0; i < attributeCount; i++) {
-//					QName attributeName = parser.getAttributeName(i);
-//					System.err.println("QNAME:" + attributeName);
-//				}
-				
-				// read tag
-				// String key = parser.getAttributeValue(null, "k");
-				// String value = parser.getAttributeValue(null, "v");
-				// // ignore tags with empty values
-				// if (value != null && value.length() > 0)
-				// setTag(key, value);
-
-			}
-			else {
-				logger.info("EVENT:" + event);
-				event = parser.next();
-			}
-			}
-		}
-	}
-
-	private int handleDirectedLink(XMLStreamReader parser) throws XMLStreamException {
-		String orientation = parser.getAttributeValue(null, "orientation");
-		String nodeId = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
-		addDirectedLink(nodeId, orientation);
-		return parser.next();
-	}
-
-	private int handleDirectedNode(XMLStreamReader parser) throws XMLStreamException {
-		String orientation = parser.getAttributeValue(null, "orientation");
-		String nodeId = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
-		addDirectedNode(nodeId, orientation);
-		return parser.next();
-	}
-
-	private int handleTag(String key, XMLStreamReader parser) throws XMLStreamException {
-		properties.put(key, parser.getElementText());
-		return parser.getEventType();
-	}
-
-	private int handleNetworkMember(XMLStreamReader parser) throws XMLStreamException {
-		String elementText = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
-		parseNetworkMember(elementText);
-		return parser.next();
-	}
-
-	private int handleCoordinates(XMLStreamReader parser)
-			throws XMLStreamException {
-		String elementText = parser.getElementText();
-		parseCoords(elementText);
-		return parser.getEventType();
-	}
-
-	protected abstract void parseCoords(String coordinates);
-	
-	protected abstract void addDirectedNode(String nodeId, String orientation);
-	
-	protected abstract void addDirectedLink(String nodeId, String orientation);
-	
-	protected abstract void parseNetworkMember(String elementText);
-
-	private boolean exitElement(XMLStreamReader parser) {
-		switch(parser.getLocalName()) {
-		case "RoadNode" : 
-		case "RoadLink" :	return true;
-		}
-		return false;
-	}
-
-	protected String tagsToString() {
-		if (properties.isEmpty())
-			return "<empty>";
-
-		StringBuilder tagTxt = new StringBuilder();
-		for (Map.Entry<String, Object> entry : properties.entrySet()) {
-			tagTxt.append(entry.getKey());
-			tagTxt.append("=");
-			tagTxt.append(entry.getValue());
-			tagTxt.append("\n");
-		}
-		return tagTxt.toString();
-	}
-
-	protected Map<String, Object> getTags() {
-		return properties;
-	}
-
-	public void setTags(Map<String, String> newTags) {
-		properties.clear();
-		if (newTags != null)
-			for (Entry<String, String> e : newTags.entrySet()) {
-				setTag(e.getKey(), e.getValue());
-			}
-	}
-
-	public boolean hasTags() {
-		return !properties.isEmpty();
-	}
-
-	public String getTag(String name) {
-		return (String) properties.get(name);
-	}
-
-	@SuppressWarnings("unchecked")
-	public <T> T getTag(String key, T defaultValue) {
-		T val = (T) properties.get(key);
-		if (val == null)
-			return defaultValue;
-		return val;
-	}
-
-	public void setTag(String name, Object value) {
-		properties.put(name, value);
-	}
-
-	/**
-	 * Chaeck that the object has a given tag with a given value.
-	 */
-	public boolean hasTag(String key, Object value) {
-		return value.equals(properties.get(key));
-	}
-
-	/**
-	 * Check that a given tag has one of the specified values. If no values are
-	 * given, just checks for presence of the tag
-	 */
-	public boolean hasTag(String key, String... values) {
-		Object osmValue = properties.get(key);
-		if (osmValue == null)
-			return false;
-
-		// tag present, no values given: success
-		if (values.length == 0)
-			return true;
-
-		for (String val : values) {
-			if (val.equals(osmValue))
-				return true;
-		}
-		return false;
-	}
-
-	/**
-	 * Check that a given tag has one of the specified values.
-	 */
-	public final boolean hasTag(String key, Set<String> values) {
-		return values.contains(properties.get(key));
-	}
-
-	/**
-	 * Check a number of tags in the given order for the any of the given
-	 * values. Used to parse hierarchical access restrictions
-	 */
-	public boolean hasTag(List<String> keyList, Set<String> values) {
-		for (String key : keyList) {
-			if (values.contains(properties.get(key)))
-				return true;
-		}
-		return false;
-	}
-
-	public void removeTag(String name) {
-		properties.remove(name);
-	}
-
-	public void clearTags() {
-		properties.clear();
-	}
-
-	public int getType() {
-		return type;
-	}
-
-	public boolean isType(int type) {
-		return this.type == type;
-	}
+    public static final int NODE = 0;
+    public static final int WAY = 1;
+    public static final int RELATION = 2;
+    private final int type;
+    private final String id;
+    private final Map<String, Object> properties = new HashMap<String, Object>(
+            5);
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnElement.class);
+
+    protected OsDpnElement(String id, int type) {
+        this.id = id;
+        this.type = type;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    protected void readTags(XMLStreamReader parser) throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
+        int event = parser.getEventType();
+        while (event != XMLStreamConstants.END_DOCUMENT
+                && (event != XMLStreamConstants.END_ELEMENT || !exitElement(parser))) {
+            if (event == XMLStreamConstants.CHARACTERS) {
+                event = parser.next();
+            } else {
+                if (event == XMLStreamConstants.START_ELEMENT) {
+                    // logger.info("LOCALNAME: {}", parser.getLocalName());
+                    switch (parser.getLocalName()) {
+                        case "pos":
+                        case "coordinates": {
+                            event = handleCoordinates(parser);
+                            break;
+                        }
+                        case "networkMember": {
+                            event = handleNetworkMember(parser);
+                            break;
+                        }
+                        case "posList": {
+                            event = handleMultiDimensionCoords(parser);
+                            break;
+                        }
+                        case "startNode":
+                        case "endNode": {
+                            event = handleNode(parser);
+                            break;
+                        }
+                        case "directedLink": {
+                            event = handleDirectedLink(parser);
+                            break;
+                        }
+                        case "instruction": {
+                            System.err.println("INSTRUCTION:");
+                            setTag("type", "restriction");
+                            event = handleTag("restriction", parser);
+                            break;
+                        }
+                        case "descriptiveTerm": {
+                            event = handleDescriptiveTerm(parser);
+                            break;
+                        }
+                        case "name": {
+                            event = handleTag("name", parser);
+                            break;
+                        }
+                        default: {
+                            event = parser.next();
+                        }
+                    }
+                } else {
+                    // logger.trace("EVENT:" + event);
+                    event = parser.next();
+                }
+            }
+        }
+    }
+
+    private int handleDescriptiveTerm(XMLStreamReader parser)
+            throws XMLStreamException {
+        String roadType = parser.getElementText();
+        setTag("type", "route");
+        setTag("highway", roadType);
+        setTag("name", roadType);
+        return parser.getEventType();
+    }
+
+    private int handleDirectedLink(XMLStreamReader parser)
+            throws XMLStreamException {
+        String orientation = parser.getAttributeValue(null, "orientation");
+        String nodeId = parser.getAttributeValue(
+                "http://www.w3.org/1999/xlink", "href");
+        addDirectedLink(nodeId, orientation);
+        return parser.next();
+    }
+
+    private int handleNode(XMLStreamReader parser) throws XMLStreamException {
+        String nodeId = parser.getAttributeValue(
+                "http://www.w3.org/1999/xlink", "href");
+        addNode(nodeId);
+        return parser.next();
+    }
+
+    private int handleTag(String key, XMLStreamReader parser)
+            throws XMLStreamException {
+        properties.put(key, parser.getElementText());
+        return parser.getEventType();
+    }
+
+    private int handleNetworkMember(XMLStreamReader parser)
+            throws XMLStreamException {
+        String elementText = parser.getAttributeValue(
+                "http://www.w3.org/1999/xlink", "href");
+        parseNetworkMember(elementText);
+        return parser.next();
+    }
+
+    private int handleCoordinates(XMLStreamReader parser)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
+        String elementText = parser.getElementText();
+        parseCoords(elementText);
+        return parser.getEventType();
+    }
+
+    private int handleMultiDimensionCoords(XMLStreamReader parser)
+            throws XMLStreamException {
+        String dimensionality = parser.getAttributeValue(null, "srsDimension");
+        logger.info("Dimensions:" + dimensionality);
+        String elementText = parser.getElementText();
+        parseCoords(Integer.valueOf(dimensionality), elementText);
+        return parser.getEventType();
+    }
+
+    protected abstract void parseCoords(String coordinates)
+            throws MismatchedDimensionException, FactoryException,
+            TransformException;
+
+    protected abstract void parseCoords(int dimensions, String lineDefinition);
+
+    protected abstract void addNode(String nodeId);
+
+    protected abstract void addDirectedLink(String nodeId, String orientation);
+
+    protected abstract void parseNetworkMember(String elementText);
+
+    private boolean exitElement(XMLStreamReader parser) {
+        switch (parser.getLocalName()) {
+            case "RouteNode":
+            case "RouteLink":
+            case "Route":
+                return true;
+        }
+        return false;
+    }
+
+    protected String tagsToString() {
+        if (properties.isEmpty())
+            return "<empty>";
+
+        StringBuilder tagTxt = new StringBuilder();
+        for (Map.Entry<String, Object> entry : properties.entrySet()) {
+            tagTxt.append(entry.getKey());
+            tagTxt.append("=");
+            tagTxt.append(entry.getValue());
+            tagTxt.append("\n");
+        }
+        return tagTxt.toString();
+    }
+
+    protected Map<String, Object> getTags() {
+        return properties;
+    }
+
+    public void setTags(Map<String, String> newTags) {
+        properties.clear();
+        if (newTags != null)
+            for (Entry<String, String> e : newTags.entrySet()) {
+                setTag(e.getKey(), e.getValue());
+            }
+    }
+
+    @Override
+    public boolean hasTags() {
+        return !properties.isEmpty();
+    }
+
+    @Override
+    public String getTag(String name) {
+        return (String) properties.get(name);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T> T getTag(String key, T defaultValue) {
+        T val = (T) properties.get(key);
+        if (val == null)
+            return defaultValue;
+        return val;
+    }
+
+    @Override
+    public void setTag(String name, Object value) {
+        properties.put(name, value);
+    }
+
+    /**
+     * Chaeck that the object has a given tag with a given value.
+     */
+    @Override
+    public boolean hasTag(String key, Object value) {
+        return value.equals(properties.get(key));
+    }
+
+    /**
+     * Check that a given tag has one of the specified values. If no values are
+     * given, just checks for presence of the tag
+     */
+    @Override
+    public boolean hasTag(String key, String... values) {
+        Object osmValue = properties.get(key);
+        if (osmValue == null)
+            return false;
+
+        // tag present, no values given: success
+        if (values.length == 0)
+            return true;
+
+        for (String val : values) {
+            if (val.equals(osmValue))
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * Check that a given tag has one of the specified values.
+     */
+    @Override
+    public final boolean hasTag(String key, Set<String> values) {
+        return values.contains(properties.get(key));
+    }
+
+    /**
+     * Check a number of tags in the given order for the any of the given
+     * values. Used to parse hierarchical access restrictions
+     */
+    @Override
+    public boolean hasTag(List<String> keyList, Set<String> values) {
+        for (String key : keyList) {
+            if (values.contains(properties.get(key)))
+                return true;
+        }
+        return false;
+    }
+
+    public void removeTag(String name) {
+        properties.remove(name);
+    }
+
+    public void clearTags() {
+        properties.clear();
+    }
+
+    @Override
+    public int getType() {
+        return type;
+    }
+
+    @Override
+    public boolean isType(int type) {
+        return this.type == type;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java
index f116a9bae0..c4ad7fdccf 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnInputFile.java
@@ -27,7 +27,6 @@
 import java.lang.reflect.Constructor;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.ZipInputStream;
 
@@ -52,231 +51,198 @@
  * @author Nop
  */
 public class OsDpnInputFile implements Sink, Closeable {
-	private boolean eof;
-	private InputStream bis;
-	// for xml parsing
-	private XMLStreamReader parser;
-	// for pbf parsing
-	private boolean binary = false;
-	private final BlockingQueue<RoutingElement> itemQueue;
-	private boolean hasIncomingData;
-	private int workerThreads = -1;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsDpnInputFile.class);
-
-	public OsDpnInputFile(File file) throws IOException {
-		bis = decode(file);
-		itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
-	}
-
-	public OsDpnInputFile open() throws XMLStreamException {
-		if (binary) {
-			// openPBFReader(bis);
-		} else {
-			openXMLStream(bis);
-		}
-		return this;
-	}
-
-	/**
-	 * Currently on for pbf format. Default is number of cores.
-	 */
-	public OsDpnInputFile setWorkerThreads(int num) {
-		workerThreads = num;
-		return this;
-	}
-
-	@SuppressWarnings("unchecked")
-	private InputStream decode(File file) throws IOException {
-		final String name = file.getName();
-
-		InputStream ips = null;
-		try {
-			ips = new BufferedInputStream(new FileInputStream(file), 50000);
-		} catch (FileNotFoundException e) {
-			throw new RuntimeException(e);
-		}
-		ips.mark(10);
-
-		// check file header
-		byte header[] = new byte[6];
-		ips.read(header);
-
-		/*
-		 * can parse bz2 directly with additional lib if (header[0] == 'B' &&
-		 * header[1] == 'Z') { return new CBZip2InputStream(ips); }
-		 */
-		if (header[0] == 31 && header[1] == -117) {
-			ips.reset();
-			return new GZIPInputStream(ips, 50000);
-		} else if (header[0] == 0 && header[1] == 0 && header[2] == 0
-				&& header[4] == 10 && header[5] == 9
-				&& (header[3] == 13 || header[3] == 14)) {
-			ips.reset();
-			binary = true;
-			return ips;
-		} else if (header[0] == 'P' && header[1] == 'K') {
-			ips.reset();
-			ZipInputStream zip = new ZipInputStream(ips);
-			zip.getNextEntry();
-
-			return zip;
-		} else if (name.endsWith(".osm") || name.endsWith(".xml")) {
-			ips.reset();
-			return ips;
-		} else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
-			String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
-			try {
-				Class clazz = Class.forName(clName);
-				ips.reset();
-				Constructor<InputStream> ctor = clazz.getConstructor(
-						InputStream.class, boolean.class);
-				return ctor.newInstance(ips, true);
-			} catch (Exception e) {
-				throw new IllegalArgumentException("Cannot instantiate "
-						+ clName, e);
-			}
-		} else {
-			throw new IllegalArgumentException(
-					"Input file is not of valid type " + file.getPath());
-		}
-	}
-
-	private void openXMLStream(InputStream in) throws XMLStreamException {
-		XMLInputFactory factory = XMLInputFactory.newInstance();
-		parser = factory.createXMLStreamReader(bis, "UTF-8");
-
-		int event = parser.next();
-		if (event != XMLStreamConstants.START_ELEMENT
-				|| !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
-			throw new IllegalArgumentException(
-					"File is not a valid OS ITN stream");
-		}
-
-		eof = false;
-	}
-
-	public RoutingElement getNext() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		if (eof)
-			throw new IllegalStateException("EOF reached");
-
-		RoutingElement item;
-		if (binary)
-			item = getNextPBF();
-		else
-			item = getNextXML();
-
-		if (item != null)
-			return item;
-
-		eof = true;
-		return null;
-	}
-
-	private RoutingElement getNextXML() throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-
-		int event = parser.next();
-		while (event != XMLStreamConstants.END_DOCUMENT) {
-			if (event == XMLStreamConstants.START_ELEMENT) {
-				String idStr = parser.getAttributeValue("gml", "id");
-				if (idStr != null) {
-					String name = parser.getLocalName();
-					idStr = idStr.substring(4);
-					long id = Long.parseLong(idStr);
-
-					logger.info(":" + name + ":");
-					switch (name) {
-					case "RouteNode": {
-						return OsDpnNode.create(id, parser);
-					}
-					case "RouteLink": {
-						return OsDpnWay.create(id, parser);
-					}
-					case "Route": {
-						//TODO grouped features
-					}
-					default: {
-						
-					}
-
-					}
-				}
-			}
-			event = parser.next();
-		}
-		parser.close();
-		return null;
-	}
-
-	public boolean isEOF() {
-		return eof;
-	}
-
-	@Override
-	public void close() throws IOException {
-		try {
-			if (!binary)
-				parser.close();
-		} catch (XMLStreamException ex) {
-			throw new IOException(ex);
-		} finally {
-			eof = true;
-			bis.close();
-			// if exception happend on OSMInputFile-thread we need to shutdown
-			// the pbf handling
-			if (pbfReaderThread != null && pbfReaderThread.isAlive())
-				pbfReaderThread.interrupt();
-		}
-	}
-
-	Thread pbfReaderThread;
-
-	// private void openPBFReader(InputStream stream) {
-	// hasIncomingData = true;
-	// if (workerThreads <= 0)
-	// workerThreads = 2;
-	//
-	// PbfReader reader = new PbfReader(stream, this, workerThreads);
-	// pbfReaderThread = new Thread(reader, "PBF Reader");
-	// pbfReaderThread.start();
-	// }
-
-	@Override
-	public void process(RoutingElement item) {
-		try {
-			// blocks if full
-			itemQueue.put(item);
-		} catch (InterruptedException ex) {
-			throw new RuntimeException(ex);
-		}
-
-		// throw exception if full
-		// itemQueue.add(item);
-	}
-
-	@Override
-	public void complete() {
-		hasIncomingData = false;
-	}
-
-	private RoutingElement getNextPBF() {
-		RoutingElement next = null;
-		while (next == null) {
-			if (!hasIncomingData && itemQueue.isEmpty()) {
-				// we are done, stop polling
-				eof = true;
-				break;
-			}
-
-			try {
-				// we cannot use "itemQueue.take()" as it blocks and
-				// hasIncomingData can change
-				next = itemQueue.poll(10, TimeUnit.MILLISECONDS);
-			} catch (InterruptedException ex) {
-				eof = true;
-				break;
-			}
-		}
-		return next;
-	}
+    private boolean eof;
+    private final InputStream bis;
+    // for xml parsing
+    private XMLStreamReader parser;
+    // for pbf parsing
+    private boolean binary = false;
+    private final BlockingQueue<RoutingElement> itemQueue;
+    private boolean hasIncomingData;
+    private int workerThreads = -1;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnInputFile.class);
+
+    public OsDpnInputFile(File file) throws IOException {
+        bis = decode(file);
+        itemQueue = new LinkedBlockingQueue<RoutingElement>(50000);
+    }
+
+    public OsDpnInputFile open() throws XMLStreamException {
+        if (binary) {
+            // openPBFReader(bis);
+        } else {
+            openXMLStream(bis);
+        }
+        return this;
+    }
+
+    /**
+     * Currently on for pbf format. Default is number of cores.
+     */
+    public OsDpnInputFile setWorkerThreads(int num) {
+        workerThreads = num;
+        return this;
+    }
+
+    @SuppressWarnings("unchecked")
+    private InputStream decode(File file) throws IOException {
+        final String name = file.getName();
+
+        InputStream ips = null;
+        try {
+            ips = new BufferedInputStream(new FileInputStream(file), 50000);
+        } catch (FileNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+        ips.mark(10);
+
+        // check file header
+        byte header[] = new byte[6];
+        ips.read(header);
+
+        /*
+         * can parse bz2 directly with additional lib if (header[0] == 'B' &&
+         * header[1] == 'Z') { return new CBZip2InputStream(ips); }
+         */
+        if (header[0] == 31 && header[1] == -117) {
+            ips.reset();
+            return new GZIPInputStream(ips, 50000);
+        } else if (header[0] == 0 && header[1] == 0 && header[2] == 0
+                && header[4] == 10 && header[5] == 9
+                && (header[3] == 13 || header[3] == 14)) {
+            ips.reset();
+            binary = true;
+            return ips;
+        } else if (header[0] == 'P' && header[1] == 'K') {
+            ips.reset();
+            ZipInputStream zip = new ZipInputStream(ips);
+            zip.getNextEntry();
+
+            return zip;
+        } else if (name.endsWith(".gml") || name.endsWith(".xml")) {
+            ips.reset();
+            return ips;
+        } else if (name.endsWith(".bz2") || name.endsWith(".bzip2")) {
+            String clName = "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream";
+            try {
+                Class clazz = Class.forName(clName);
+                ips.reset();
+                Constructor<InputStream> ctor = clazz.getConstructor(
+                        InputStream.class, boolean.class);
+                return ctor.newInstance(ips, true);
+            } catch (Exception e) {
+                throw new IllegalArgumentException("Cannot instantiate "
+                        + clName, e);
+            }
+        } else {
+            throw new IllegalArgumentException(
+                    "Input file is not of valid type " + file.getPath());
+        }
+    }
+
+    private void openXMLStream(InputStream in) throws XMLStreamException {
+        XMLInputFactory factory = XMLInputFactory.newInstance();
+        parser = factory.createXMLStreamReader(bis, "UTF-8");
+
+        int event = parser.next();
+        if (event != XMLStreamConstants.START_ELEMENT
+                || !parser.getLocalName().equalsIgnoreCase("FeatureCollection")) {
+            throw new IllegalArgumentException(
+                    "File is not a valid OS ITN stream");
+        }
+
+        eof = false;
+    }
+
+    public RoutingElement getNext() throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
+        if (eof)
+            throw new IllegalStateException("EOF reached");
+
+        RoutingElement item;
+        item = getNextXML();
+
+        if (item != null)
+            return item;
+
+        eof = true;
+        return null;
+    }
+
+    private RoutingElement getNextXML() throws XMLStreamException,
+            MismatchedDimensionException, FactoryException, TransformException {
+
+        int event = parser.next();
+        while (event != XMLStreamConstants.END_DOCUMENT) {
+            if (event == XMLStreamConstants.START_ELEMENT) {
+                String idStr = parser.getAttributeValue(null, "id");
+                if (idStr != null) {
+                    String name = parser.getLocalName();
+                    idStr = idStr.substring(4);
+
+                    logger.info(":" + name + ":");
+                    switch (name) {
+                        case "RouteNode": {
+                            return OsDpnNode.create(idStr, parser);
+                        }
+                        case "RouteLink": {
+                            return OsDpnWay.create(idStr, parser);
+                        }
+                        case "Route": {
+                            // TODO grouped features
+                        }
+                        default: {
+
+                        }
+
+                    }
+                }
+            }
+            event = parser.next();
+        }
+        parser.close();
+        return null;
+    }
+
+    public boolean isEOF() {
+        return eof;
+    }
+
+    @Override
+    public void close() throws IOException {
+        try {
+            if (!binary)
+                parser.close();
+        } catch (XMLStreamException ex) {
+            throw new IOException(ex);
+        } finally {
+            eof = true;
+            bis.close();
+            // if exception happend on OSMInputFile-thread we need to shutdown
+            // the pbf handling
+            if (pbfReaderThread != null && pbfReaderThread.isAlive())
+                pbfReaderThread.interrupt();
+        }
+    }
+
+    Thread pbfReaderThread;
+
+    @Override
+    public void process(RoutingElement item) {
+        try {
+            // blocks if full
+            itemQueue.put(item);
+        } catch (InterruptedException ex) {
+            throw new RuntimeException(ex);
+        }
+
+        // throw exception if full
+        // itemQueue.add(item);
+    }
+
+    @Override
+    public void complete() {
+        hasIncomingData = false;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java
index 42de20a18e..c08b01dc26 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnNode.java
@@ -23,12 +23,13 @@
 import org.opengis.geometry.MismatchedDimensionException;
 import org.opengis.referencing.FactoryException;
 import org.opengis.referencing.operation.TransformException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import uk.co.ordnancesurvey.api.srs.LatLong;
 import uk.co.ordnancesurvey.api.srs.OpenCoordConverter;
 
 import com.graphhopper.reader.Node;
-import com.graphhopper.reader.osgb.OSITNElement;
 import com.graphhopper.util.PointAccess;
 
 /**
@@ -37,132 +38,144 @@
  * 
  * @author Nop
  */
-public class OsDpnNode extends OSITNElement implements Node {
-	private double lat;
-	private double lon;
-
-	public static OsDpnNode create(long id, XMLStreamReader parser)
-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		// int attributeCount = parser.getAttributeCount();
-		// for (int i = 0; i < attributeCount; i++) {
-		// QName attributeName = parser.getAttributeName(i);
-		// System.err.println("QName:" + attributeName);
-		// }
-		OsDpnNode node = new OsDpnNode(id);
-
-		parser.nextTag();
-		node.readTags(parser);
-		return node;
-	}
-
-	public OsDpnNode(long id, PointAccess pointAccess, int accessId) {
-		super(id, NODE);
-
-		this.lat = pointAccess.getLatitude(accessId);
-		this.lon = pointAccess.getLongitude(accessId);
-		if (pointAccess.is3D())
-			setTag("ele", pointAccess.getElevation(accessId));
-	}
-
-	public OsDpnNode(long id) {
-		super(id, NODE);
-
-	}
-
-	public double getLat() {
-		return lat;
-	}
-
-	public double getLon() {
-		return lon;
-	}
-
-	public double getEle() {
-		Object ele = getTags().get("ele");
-		if (ele == null)
-			// return Double.NaN;
-			return 1d;
-		return (Double) ele;
-	}
-
-	@Override
-	public void setTag(String name, Object value) {
-		if ("ele".equals(name)) {
-			if (value == null)
-				value = null;
-			else if (value instanceof String) {
-				String str = (String) value;
-				str = str.trim().replaceAll("\\,", ".");
-				if (str.isEmpty())
-					value = null;
-				else
-					try {
-						value = Double.parseDouble(str);
-					} catch (NumberFormatException ex) {
-						return;
-					}
-			} else
-				// force cast
-				value = ((Number) value).doubleValue();
-		}
-		super.setTag(name, value);
-	}
-
-	@Override
-	public String toString() {
-		StringBuilder txt = new StringBuilder();
-		txt.append("Node: ");
-		txt.append(getId());
-		txt.append(" lat=");
-		txt.append(getLat());
-		txt.append(" lon=");
-		txt.append(getLon());
-		if (!getTags().isEmpty()) {
-			txt.append("\n");
-			txt.append(tagsToString());
-		}
-		return txt.toString();
-	}
-
-	@Override
-	protected void parseCoords(String elementText) throws MismatchedDimensionException, FactoryException, TransformException {
-		String[] split = elementText.split(",");
-
-		Double easting = Double.parseDouble(split[0]);
-		Double northing = Double.parseDouble(split[1]);
-		LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
-		lat = wgs84.getLatAngle();
-		lon = wgs84.getLongAngle();
-		System.err.println(toString());
-	}
-
-	@Override
-	protected void parseNetworkMember(String elementText) {
-		throw new UnsupportedOperationException("Nodes should not have members");
-	}
-
-	@Override
-	protected void addDirectedNode(String nodeId, String grade, String orientation) {
-		throw new UnsupportedOperationException(
-				"Nodes should not have directed nodes");
-	}
-	
-	@Override
-	protected void addDirectedLink(String nodeId, String orientation) {
-		throw new UnsupportedOperationException(
-				"Nodes should not have directed links");
-	}
-
-	@Override
-	protected void parseCoordinateString(String elementText,
-			String elementSeparator) {
-		throw new UnsupportedOperationException();
-		
-	}
-
-	@Override
-	protected void parseCoords(int dimensions, String lineDefinition) {
-		throw new UnsupportedOperationException();
-	}
+public class OsDpnNode extends OsDpnElement implements Node {
+    private double lat;
+    private double lon;
+
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnElement.class);
+
+    public static OsDpnNode create(String id, XMLStreamReader parser)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
+        // int attributeCount = parser.getAttributeCount();
+        // for (int i = 0; i < attributeCount; i++) {
+        // QName attributeName = parser.getAttributeName(i);
+        // System.err.println("QName:" + attributeName);
+        // }
+        System.out.println("OsDpnNode.create()");
+        OsDpnNode node = new OsDpnNode(id);
+
+        parser.nextTag();
+        node.readTags(parser);
+        return node;
+    }
+
+    public OsDpnNode(String id, PointAccess pointAccess, int accessId) {
+        super(id, NODE);
+
+        this.lat = pointAccess.getLatitude(accessId);
+        this.lon = pointAccess.getLongitude(accessId);
+        if (pointAccess.is3D())
+            setTag("ele", pointAccess.getElevation(accessId));
+    }
+
+    public OsDpnNode(String id) {
+        super(id, NODE);
+
+    }
+
+    @Override
+    public double getLat() {
+        return lat;
+    }
+
+    @Override
+    public double getLon() {
+        return lon;
+    }
+
+    public double getEle() {
+        Object ele = getTags().get("ele");
+        if (ele == null)
+            // return Double.NaN;
+            return 1d;
+        return (Double) ele;
+    }
+
+    @Override
+    public void setTag(String name, Object value) {
+        if ("ele".equals(name)) {
+            if (value == null)
+                value = null;
+            else if (value instanceof String) {
+                String str = (String) value;
+                str = str.trim().replaceAll("\\,", ".");
+                if (str.isEmpty())
+                    value = null;
+                else
+                    try {
+                        value = Double.parseDouble(str);
+                    } catch (NumberFormatException ex) {
+                        return;
+                    }
+            } else
+                // force cast
+                value = ((Number) value).doubleValue();
+        }
+        super.setTag(name, value);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder txt = new StringBuilder();
+        txt.append("Node: ");
+        txt.append(getId());
+        txt.append(" lat=");
+        txt.append(getLat());
+        txt.append(" lon=");
+        txt.append(getLon());
+        if (!getTags().isEmpty()) {
+            txt.append("\n");
+            txt.append(tagsToString());
+        }
+        return txt.toString();
+    }
+
+    @Override
+    public void parseCoords(String elementText)
+            throws MismatchedDimensionException, FactoryException,
+            TransformException {
+        String elementSeparator = " ";
+        parseCoordinateString(elementText, elementSeparator);
+    }
+
+    public void parseCoordinateString(String elementText,
+            String elementSeparator) throws MismatchedDimensionException,
+            FactoryException, TransformException {
+        String[] split = elementText.split(elementSeparator);
+
+        if (3 == split.length) {
+            setTag("ele", split[2]);
+        }
+        Double easting = Double.parseDouble(split[0]);
+        Double northing = Double.parseDouble(split[1]);
+        LatLong wgs84 = OpenCoordConverter.toWGS84(easting, northing);
+        lat = wgs84.getLatAngle();
+        lon = wgs84.getLongAngle();
+        if (logger.isDebugEnabled())
+            logger.debug(toString());
+    }
+
+    @Override
+    protected void parseNetworkMember(String elementText) {
+        throw new UnsupportedOperationException("Nodes should not have members");
+    }
+
+    @Override
+    protected void addNode(String nodeId) {
+        throw new UnsupportedOperationException(
+                "Nodes should not have directed nodes");
+    }
+
+    @Override
+    protected void addDirectedLink(String nodeId, String orientation) {
+        throw new UnsupportedOperationException(
+                "Nodes should not have directed links");
+    }
+
+    protected void parseCoords(int dimensions, String lineDefinition) {
+        throw new UnsupportedOperationException();
+    }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
index 0e4888f03f..8d12c5d50b 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
@@ -1,14 +1,13 @@
 package com.graphhopper.reader.osgb.dpn;
 
 import static com.graphhopper.util.Helper.nf;
-import gnu.trove.list.TLongList;
-import gnu.trove.list.array.TLongArrayList;
-import gnu.trove.map.TIntLongMap;
-import gnu.trove.map.TLongLongMap;
-import gnu.trove.map.hash.TIntLongHashMap;
-import gnu.trove.map.hash.TLongLongHashMap;
-import gnu.trove.set.TLongSet;
-import gnu.trove.set.hash.TLongHashSet;
+import gnu.trove.map.TLongObjectMap;
+import gnu.trove.map.TObjectIntMap;
+import gnu.trove.map.TObjectLongMap;
+import gnu.trove.map.hash.TLongObjectHashMap;
+import gnu.trove.map.hash.TObjectIntHashMap;
+import gnu.trove.map.hash.TObjectLongHashMap;
+import gnu.trove.set.hash.THashSet;
 
 import java.io.File;
 import java.io.IOException;
@@ -22,31 +21,20 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.graphhopper.coll.GHLongIntBTree;
-import com.graphhopper.coll.LongIntMap;
 import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.ITurnCostTableEntry;
 import com.graphhopper.reader.Node;
 import com.graphhopper.reader.OSMElement;
-import com.graphhopper.reader.OSMNode;
-import com.graphhopper.reader.OSMRelation;
 import com.graphhopper.reader.OSMTurnRelation;
 import com.graphhopper.reader.PillarInfo;
 import com.graphhopper.reader.Relation;
 import com.graphhopper.reader.RelationMember;
 import com.graphhopper.reader.RoutingElement;
 import com.graphhopper.reader.TurnRelation;
-import com.graphhopper.reader.Way;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.osgb.OSITNTurnRelation;
-import com.graphhopper.reader.osgb.OSITNWay;
-import com.graphhopper.reader.osgb.OsItnInputFile;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.ExtendedStorage;
-import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.TurnCostStorage;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalc3D;
 import com.graphhopper.util.DistanceCalcEarth;
@@ -101,870 +89,874 @@
  * @author Peter Karich
  */
 
-public class OsDpnReader implements DataReader {
-	private InputStream is;
-
-	protected static final int EMPTY = -1;
-	// pillar node is >= 3
-	protected static final int PILLAR_NODE = 1;
-	// tower node is <= -3
-	protected static final int TOWER_NODE = -2;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsDpnReader.class);
-	private long locations;
-	private long skippedLocations;
-	private final GraphStorage graphStorage;
-	private final NodeAccess nodeAccess;
-	private EncodingManager encodingManager = null;
-	private int workerThreads = -1;
-	protected long zeroCounter = 0;
-	// Using the correct Map<Long, Integer> is hard. We need a memory efficient
-	// and fast solution for big data sets!
-	//
-	// very slow: new SparseLongLongArray
-	// only append and update possible (no unordered storage like with this
-	// doubleParse): new OSMIDMap
-	// same here: not applicable as ways introduces the nodes in 'wrong' order:
-	// new OSMIDSegmentedMap
-	// memory overhead due to open addressing and full rehash:
-	// nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
-	// smaller memory overhead for bigger data sets because of avoiding a
-	// "rehash"
-	// remember how many times a node was used to identify tower nodes
-	private LongIntMap osmNodeIdToInternalNodeMap;
-	private TLongLongHashMap osmNodeIdToNodeFlagsMap;
-	private TLongLongHashMap osmWayIdToRouteWeightMap;
-	// stores osm way ids used by relations to identify which edge ids needs to
-	// be mapped later
-	private TLongHashSet osmIdStoreRequiredSet = new TLongHashSet();
-	private TIntLongMap edgeIdToOsmIdMap;
-	private final TLongList barrierNodeIds = new TLongArrayList();
-	protected PillarInfo pillarInfo;
-	private final DistanceCalc distCalc = new DistanceCalcEarth();
-	private final DistanceCalc3D distCalc3D = new DistanceCalc3D();
-	private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
-	private boolean doSimplify = true;
-	private int nextTowerId = 0;
-	private int nextPillarId = 0;
-	// negative but increasing to avoid clash with custom created OSM files
-	private long newUniqueOsmId = -Long.MAX_VALUE;
-	private ElevationProvider eleProvider = ElevationProvider.NOOP;
-	private boolean exitOnlyPillarNodeException = true;
-	private File routingFile;
-
-	public OsDpnReader(GraphStorage storage) {
-		this.graphStorage = storage;
-		this.nodeAccess = graphStorage.getNodeAccess();
-
-		osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
-		osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
-		osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-		pillarInfo = new PillarInfo(nodeAccess.is3D(),
-				graphStorage.getDirectory());
-	}
-
-	@Override
-	public void readGraph() throws IOException {
-		if (encodingManager == null)
-			throw new IllegalStateException("Encoding manager was not set.");
-
-		if (routingFile == null)
-			throw new IllegalStateException("No OS ITN file specified");
-
-		if (!routingFile.exists())
-			throw new IllegalStateException(
-					"Your specified OS ITN file does not exist:"
-							+ routingFile.getAbsolutePath());
-
-		StopWatch sw1 = new StopWatch().start();
-		preProcess(routingFile);
-		sw1.stop();
-
-		StopWatch sw2 = new StopWatch().start();
-		writeOsm2Graph(routingFile);
-		sw2.stop();
-
-		logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: "
-				+ (int) sw2.getSeconds() + " total:"
-				+ ((int) (sw1.getSeconds() + sw2.getSeconds())));
-	}
-
-	/**
-	 * Preprocessing of OSM file to select nodes which are used for highways.
-	 * This allows a more compact graph data structure.
-	 */
-	void preProcess(File osmFile) {
-		OsItnInputFile in = null;
-		try {
-			in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
-					.open();
-
-			long tmpWayCounter = 1;
-			long tmpRelationCounter = 1;
-			RoutingElement item;
-			while ((item = in.getNext()) != null) {
-				System.out.println("OsItnReader.preProcess( " + item.getType()
-						+ " )");
-				if (item.isType(OSMElement.WAY)) {
-					final OSITNWay way = (OSITNWay) item;
-					boolean valid = filterWay(way);
-					if (valid) {
-						TLongList wayNodes = way.getNodes();
-						int s = wayNodes.size();
-						for (int index = 0; index < s; index++) {
-							prepareHighwayNode(wayNodes.get(index));
-						}
-
-						if (++tmpWayCounter % 500000 == 0) {
-							logger.info(nf(tmpWayCounter)
-									+ " (preprocess), osmIdMap:"
-									+ nf(getNodeMap().getSize()) + " ("
-									+ getNodeMap().getMemoryUsage() + "MB) "
-									+ Helper.getMemInfo());
-						}
-					}
-				}
-				if (item.isType(OSMElement.RELATION)) {
-					final OSMRelation relation = (OSMRelation) item;
-					if (!relation.isMetaRelation()
-							&& relation.hasTag("type", "route"))
-						prepareWaysWithRelationInfo(relation);
-
-					if (relation.hasTag("type", "restriction"))
-						prepareRestrictionRelation(relation);
-
-					if (++tmpRelationCounter % 50000 == 0) {
-						logger.info(nf(tmpRelationCounter)
-								+ " (preprocess), osmWayMap:"
-								+ nf(getRelFlagsMap().size()) + " "
-								+ Helper.getMemInfo());
-					}
-
-				}
-			}
-		} catch (Exception ex) {
-			// throw new RuntimeException("Problem while parsing file", ex);
-		} finally {
-			Helper.close(in);
-		}
-	}
-
-	private void prepareRestrictionRelation(OSMRelation relation) {
-		TurnRelation turnRelation = createTurnRelation(relation);
-		if (turnRelation != null) {
-			getOsmIdStoreRequiredSet().add(
-					((TurnRelation) turnRelation).getOsmIdFrom());
-			getOsmIdStoreRequiredSet().add(
-					((TurnRelation) turnRelation).getOsmIdTo());
-		}
-	}
-
-	private TLongSet getOsmIdStoreRequiredSet() {
-		return osmIdStoreRequiredSet;
-	}
-
-	private TIntLongMap getEdgeIdToOsmidMap() {
-		if (edgeIdToOsmIdMap == null)
-			edgeIdToOsmIdMap = new TIntLongHashMap(getOsmIdStoreRequiredSet()
-					.size());
-
-		return edgeIdToOsmIdMap;
-	}
-
-	/**
-	 * Filter ways but do not analyze properties wayNodes will be filled with
-	 * participating node ids.
-	 * <p/>
-	 * 
-	 * @return true the current xml entry is a way entry and has nodes
-	 */
-	boolean filterWay(OSITNWay way) {
-		// ignore broken geometry
-		if (way.getNodes().size() < 2)
-			return false;
-
-		// ignore multipolygon geometry
-		if (!way.hasTags())
-			return false;
-
-		return encodingManager.acceptWay(way) > 0;
-	}
-
-	/**
-	 * Creates the edges and nodes files from the specified osm file.
-	 */
-	private void writeOsm2Graph(File osmFile) {
-		int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
-		logger.info("creating graph. Found nodes (pillar+tower):"
-				+ nf(getNodeMap().getSize()) + ", " + Helper.getMemInfo());
-		graphStorage.create(tmp);
-		long wayStart = -1;
-		long relationStart = -1;
-		long counter = 1;
-		OsItnInputFile in = null;
-		try {
-			in = new OsItnInputFile(osmFile).setWorkerThreads(workerThreads)
-					.open();
-			LongIntMap nodeFilter = getNodeMap();
-
-			RoutingElement item;
-			while ((item = in.getNext()) != null) {
-				switch (item.getType()) {
-				case OSMElement.NODE:
-					logger.info("NODEITEMID:" + item.getId());
-					if (nodeFilter.get(item.getId()) != -1) {
-						processNode((Node) item);
-					}
-					break;
-
-				case OSMElement.WAY:
-					logger.info("WAY:" + item.getId() + ":" + wayStart);
-					if (wayStart < 0) {
-						logger.info(nf(counter) + ", now parsing ways");
-						wayStart = counter;
-					}
-					processWay((Way) item);
-					break;
-				case OSMElement.RELATION:
-					if (relationStart < 0) {
-						logger.info(nf(counter) + ", now parsing relations");
-						relationStart = counter;
-					}
-					processRelation((Relation) item);
-					break;
-				}
-				if (++counter % 5000000 == 0) {
-					logger.info(nf(counter) + ", locs:" + nf(locations) + " ("
-							+ skippedLocations + ") " + Helper.getMemInfo());
-				}
-			}
-
-			// logger.info("storage nodes:" + graphStorage.getNodes());
-		} catch (Exception ex) {
-//			throw new RuntimeException("Couldn't process file " + osmFile, ex);
-		} finally {
-			Helper.close(in);
-		}
-
-		finishedReading();
-		if (graphStorage.getNodes() == 0)
-			throw new IllegalStateException("osm must not be empty. read "
-					+ counter + " lines and " + locations + " locations");
-	}
-
-	/**
-	 * Process properties, encode flags and create edges for the way.
-	 */
-	void processWay(Way way) {
-		if (way.getNodes().size() < 2)
-			return;
-
-		// ignore multipolygon geometry
-		if (!way.hasTags())
-			return;
-
-		long wayOsmId = way.getId();
-
-		long includeWay = encodingManager.acceptWay(way);
-		if (includeWay == 0)
-			return;
-
-		long relationFlags = getRelFlagsMap().get(way.getId());
-
-		// TODO move this after we have created the edge and know the
-		// coordinates => encodingManager.applyWayTags
-		// estimate length of the track e.g. for ferry speed calculation
-		TLongList osmNodeIds = way.getNodes();
-		if (osmNodeIds.size() > 1) {
-			int first = getNodeMap().get(osmNodeIds.get(0));
-			int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
-			double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
-			double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-			if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon)
-					&& !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
-				double estimatedDist = distCalc.calcDist(firstLat, firstLon,
-						lastLat, lastLon);
-				way.setTag("estimated_distance", estimatedDist);
-				way.setTag("estimated_center", new GHPoint(
-						(firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
-			}
-		}
-
-		long wayFlags = encodingManager.handleWayTags(way, includeWay,
-				relationFlags);
-		if (wayFlags == 0)
-			return;
-
-		List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
-		// look for barriers along the way
-		final int size = osmNodeIds.size();
-		int lastBarrier = -1;
-		for (int i = 0; i < size; i++) {
-			long nodeId = osmNodeIds.get(i);
-			long nodeFlags = getNodeFlagsMap().get(nodeId);
-			// barrier was spotted and way is otherwise passable for that mode
-			// of travel
-			if (nodeFlags > 0) {
-				if ((nodeFlags & wayFlags) > 0) {
-					// remove barrier to avoid duplicates
-					getNodeFlagsMap().put(nodeId, 0);
-
-					// create shadow node copy for zero length edge
-					long newNodeId = addBarrierNode(nodeId);
-					if (i > 0) {
-						// start at beginning of array if there was no previous
-						// barrier
-						if (lastBarrier < 0)
-							lastBarrier = 0;
-
-						// add way up to barrier shadow node
-						long transfer[] = osmNodeIds.toArray(lastBarrier, i
-								- lastBarrier + 1);
-						transfer[transfer.length - 1] = newNodeId;
-						TLongList partIds = new TLongArrayList(transfer);
-						createdEdges.addAll(addOSMWay(partIds, wayFlags,
-								wayOsmId));
-
-						// create zero length edge for barrier
-						createdEdges.addAll(addBarrierEdge(newNodeId, nodeId,
-								wayFlags, nodeFlags, wayOsmId));
-					} else {
-						// run edge from real first node to shadow node
-						createdEdges.addAll(addBarrierEdge(nodeId, newNodeId,
-								wayFlags, nodeFlags, wayOsmId));
-
-						// exchange first node for created barrier node
-						osmNodeIds.set(0, newNodeId);
-					}
-					// remember barrier for processing the way behind it
-					lastBarrier = i;
-				}
-			}
-		}
-
-		// just add remainder of way to graph if barrier was not the last node
-		if (lastBarrier >= 0) {
-			if (lastBarrier < size - 1) {
-				long transfer[] = osmNodeIds.toArray(lastBarrier, size
-						- lastBarrier);
-				TLongList partNodeIds = new TLongArrayList(transfer);
-				createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
-			}
-		} else {
-			// no barriers - simply add the whole way
-			createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
-		}
-
-		for (EdgeIteratorState edge : createdEdges) {
-			encodingManager.applyWayTags(way, edge);
-		}
-	}
-
-	public void processRelation(Relation relation) throws XMLStreamException {
-//		if (relation.hasTag("type", "restriction")) {
-//			TurnRelation turnRelation = createTurnRelation(relation);
-//			if (turnRelation != null) {
-//				ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
-//						.getExtendedStorage();
-//				if (extendedStorage instanceof TurnCostStorage) {
-//					Collection<ITurnCostTableEntry> entries = encodingManager
-//							.analyzeTurnRelation(turnRelation, this);
-//					for (ITurnCostTableEntry entry : entries) {
-//						((TurnCostStorage) extendedStorage).setTurnCosts(
-//								entry.nodeVia, entry.edgeFrom, entry.edgeTo,
-//								(int) entry.flags);
-//					}
-//				}
-//			}
-//		}
-	}
-
-	public long getOsmIdOfInternalEdge(int edgeId) {
-		return getEdgeIdToOsmidMap().get(edgeId);
-	}
-
-	public int getInternalNodeIdOfOsmNode(long nodeOsmId) {
-		int id = getNodeMap().get(nodeOsmId);
-		if (id < TOWER_NODE)
-			return -id - 3;
-
-		return EMPTY;
-	}
-
-	// TODO remove this ugly stuff via better preparsing phase! E.g. putting
-	// every tags etc into a helper file!
-	double getTmpLatitude(int id) {
-		if (id == EMPTY)
-			return Double.NaN;
-		if (id < TOWER_NODE) {
-			// tower node
-			id = -id - 3;
-			return nodeAccess.getLatitude(id);
-		} else if (id > -TOWER_NODE) {
-			// pillar node
-			id = id - 3;
-			return pillarInfo.getLatitude(id);
-		} else
-			// e.g. if id is not handled from preparse (e.g. was ignored via
-			// isInBounds)
-			return Double.NaN;
-	}
-
-	double getTmpLongitude(int id) {
-		if (id == EMPTY)
-			return Double.NaN;
-		if (id < TOWER_NODE) {
-			// tower node
-			id = -id - 3;
-			return nodeAccess.getLongitude(id);
-		} else if (id > -TOWER_NODE) {
-			// pillar node
-			id = id - 3;
-			return pillarInfo.getLon(id);
-		} else
-			// e.g. if id is not handled from preparse (e.g. was ignored via
-			// isInBounds)
-			return Double.NaN;
-	}
-
-	private void processNode(Node node) {
-		if (isInBounds(node)) {
-			addNode(node);
-
-			// analyze node tags for barriers
-			if (node.hasTags()) {
-				long nodeFlags = encodingManager.handleNodeTags(node);
-				if (nodeFlags != 0)
-					getNodeFlagsMap().put(node.getId(), nodeFlags);
-			}
-
-			locations++;
-		} else {
-			skippedLocations++;
-		}
-	}
-
-	boolean addNode(Node node) {
-		int nodeType = getNodeMap().get(node.getId());
-		if (nodeType == EMPTY)
-			return false;
-
-		double lat = node.getLat();
-		double lon = node.getLon();
-		double ele = getElevation(node);
-		if (nodeType == TOWER_NODE) {
-			addTowerNode(node.getId(), lat, lon, ele);
-		} else if (nodeType == PILLAR_NODE) {
-			pillarInfo.setNode(nextPillarId, lat, lon, ele);
-			getNodeMap().put(node.getId(), nextPillarId + 3);
-			nextPillarId++;
-		}
-		return true;
-	}
-
-	private double getElevation(Node node) {
-		return eleProvider.getEle(node.getLat(), node.getLon());
-	}
-
-	void prepareWaysWithRelationInfo(OSMRelation osmRelation) {
-		// is there at least one tag interesting for the registed encoders?
-		if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
-			return;
-
-		int size = osmRelation.getMembers().size();
-		for (int index = 0; index < size; index++) {
-			OSMRelation.Member member = osmRelation.getMembers().get(index);
-			if (member.type() != OSMRelation.Member.WAY)
-				continue;
-
-			long osmId = member.ref();
-			long oldRelationFlags = getRelFlagsMap().get(osmId);
-
-			// Check if our new relation data is better comparated to the the
-			// last one
-			long newRelationFlags = encodingManager.handleRelationTags(
-					osmRelation, oldRelationFlags);
-			if (oldRelationFlags != newRelationFlags)
-				getRelFlagsMap().put(osmId, newRelationFlags);
-		}
-	}
-
-	void prepareHighwayNode(long osmId) {
-		int tmpIndex = getNodeMap().get(osmId);
-		if (tmpIndex == EMPTY) {
-			// osmId is used exactly once
-			System.out.println("OsItnReader.prepareHighwayNode(EMPTY->PILLAR)");
-			getNodeMap().put(osmId, PILLAR_NODE);
-		} else if (tmpIndex > EMPTY) {
-			// mark node as tower node as it occured at least twice times
-			System.out.println("OsItnReader.prepareHighwayNode(PILLAR->TOWER)");
-			getNodeMap().put(osmId, TOWER_NODE);
-		} else {
-			// tmpIndex is already negative (already tower node)
-		}
-	}
-
-	int addTowerNode(long osmId, double lat, double lon, double ele) {
-		if (nodeAccess.is3D())
-			nodeAccess.setNode(nextTowerId, lat, lon, ele);
-		else
-			nodeAccess.setNode(nextTowerId, lat, lon);
-
-		int id = -(nextTowerId + 3);
-		getNodeMap().put(osmId, id);
-		nextTowerId++;
-		return id;
-	}
-
-	/**
-	 * This method creates from an OSM way (via the osm ids) one or more edges
-	 * in the graph.
-	 */
-	Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags,
-			long wayOsmId) {
-		PointList pointList = new PointList(osmNodeIds.size(),
-				nodeAccess.is3D());
-		List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
-		int firstNode = -1;
-		int lastIndex = osmNodeIds.size() - 1;
-		int lastInBoundsPillarNode = -1;
-		try {
-			for (int i = 0; i < osmNodeIds.size(); i++) {
-				long osmId = osmNodeIds.get(i);
-				int tmpNode = getNodeMap().get(osmId);
-				if (tmpNode == EMPTY)
-					continue;
-
-				// skip osmIds with no associated pillar or tower id (e.g.
-				// !OSMReader.isBounds)
-				if (tmpNode == TOWER_NODE)
-					continue;
-
-				if (tmpNode == PILLAR_NODE) {
-					// In some cases no node information is saved for the
-					// specified osmId.
-					// ie. a way references a <node> which does not exist in the
-					// current file.
-					// => if the node before was a pillar node then convert into
-					// to tower node (as it is also end-standing).
-					if (!pointList.isEmpty()
-							&& lastInBoundsPillarNode > -TOWER_NODE) {
-						// transform the pillar node to a tower node
-						tmpNode = lastInBoundsPillarNode;
-						tmpNode = handlePillarNode(tmpNode, osmId, null, true);
-						tmpNode = -tmpNode - 3;
-						if (pointList.getSize() > 1 && firstNode >= 0) {
-							// TOWER node
-							newEdges.add(addEdge(firstNode, tmpNode, pointList,
-									flags, wayOsmId));
-							pointList.clear();
-							pointList.add(nodeAccess, tmpNode);
-						}
-						firstNode = tmpNode;
-						lastInBoundsPillarNode = -1;
-					}
-					continue;
-				}
-
-				if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
-					throw new AssertionError(
-							"Mapped index not in correct bounds " + tmpNode
-									+ ", " + osmId);
-
-				if (tmpNode > -TOWER_NODE) {
-					boolean convertToTowerNode = i == 0 || i == lastIndex;
-					if (!convertToTowerNode) {
-						lastInBoundsPillarNode = tmpNode;
-					}
-
-					// PILLAR node, but convert to towerNode if end-standing
-					tmpNode = handlePillarNode(tmpNode, osmId, pointList,
-							convertToTowerNode);
-				}
-
-				if (tmpNode < TOWER_NODE) {
-					// TOWER node
-					tmpNode = -tmpNode - 3;
-					pointList.add(nodeAccess, tmpNode);
-					if (firstNode >= 0) {
-						newEdges.add(addEdge(firstNode, tmpNode, pointList,
-								flags, wayOsmId));
-						pointList.clear();
-						pointList.add(nodeAccess, tmpNode);
-					}
-					firstNode = tmpNode;
-				}
-			}
-		} catch (RuntimeException ex) {
-			logger.error("Couldn't properly add edge with osm ids:"
-					+ osmNodeIds, ex);
-			if (exitOnlyPillarNodeException)
-				throw ex;
-		}
-		return newEdges;
-	}
-
-	EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
-			long flags, long wayOsmId) {
-		// sanity checks
-		if (fromIndex < 0 || toIndex < 0)
-			throw new AssertionError(
-					"to or from index is invalid for this edge " + fromIndex
-							+ "->" + toIndex + ", points:" + pointList);
-		if (pointList.getDimension() != nodeAccess.getDimension())
-			throw new AssertionError(
-					"Dimension does not match for pointList vs. nodeAccess "
-							+ pointList.getDimension() + " <-> "
-							+ nodeAccess.getDimension());
-
-		double towerNodeDistance = 0;
-		double prevLat = pointList.getLatitude(0);
-		double prevLon = pointList.getLongitude(0);
-		double prevEle = pointList.is3D() ? pointList.getElevation(0)
-				: Double.NaN;
-		double lat, lon, ele = Double.NaN;
-		PointList pillarNodes = new PointList(pointList.getSize() - 2,
-				nodeAccess.is3D());
-		int nodes = pointList.getSize();
-		for (int i = 1; i < nodes; i++) {
-			// we could save some lines if we would use
-			// pointList.calcDistance(distCalc);
-			lat = pointList.getLatitude(i);
-			lon = pointList.getLongitude(i);
-			if (pointList.is3D()) {
-				ele = pointList.getElevation(i);
-				towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon,
-						prevEle, lat, lon, ele);
-				prevEle = ele;
-			} else
-				towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat,
-						lon);
-			prevLat = lat;
-			prevLon = lon;
-			if (nodes > 2 && i < nodes - 1) {
-				if (pillarNodes.is3D())
-					pillarNodes.add(lat, lon, ele);
-				else
-					pillarNodes.add(lat, lon);
-			}
-		}
-		if (towerNodeDistance == 0) {
-			// As investigation shows often two paths should have crossed via
-			// one identical point
-			// but end up in two very release points.
-			zeroCounter++;
-			towerNodeDistance = 0.0001;
-		}
-
-		EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
-				.setDistance(towerNodeDistance).setFlags(flags);
-		if (nodes > 2) {
-			if (doSimplify)
-				simplifyAlgo.simplify(pillarNodes);
-
-			iter.setWayGeometry(pillarNodes);
-		}
-		storeOSMWayID(iter.getEdge(), wayOsmId);
-		return iter;
-	}
-
-	private void storeOSMWayID(int edgeId, long osmWayID) {
-		if (getOsmIdStoreRequiredSet().contains(osmWayID)) {
-			getEdgeIdToOsmidMap().put(edgeId, osmWayID);
-		}
-	}
-
-	/**
-	 * @return converted tower node
-	 */
-	private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
-			boolean convertToTowerNode) {
-		logger.info("Converting Pillar " + osmId, " to pillar? "
-				+ convertToTowerNode);
-		tmpNode = tmpNode - 3;
-		double lat = pillarInfo.getLatitude(tmpNode);
-		double lon = pillarInfo.getLongitude(tmpNode);
-		double ele = pillarInfo.getElevation(tmpNode);
-		if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
-			throw new RuntimeException(
-					"Conversion pillarNode to towerNode already happended!? "
-							+ "osmId:" + osmId + " pillarIndex:" + tmpNode);
-
-		if (convertToTowerNode) {
-			// convert pillarNode type to towerNode, make pillar values invalid
-			pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE,
-					Double.MAX_VALUE);
-			tmpNode = addTowerNode(osmId, lat, lon, ele);
-		} else {
-			if (pointList.is3D())
-				pointList.add(lat, lon, ele);
-			else
-				pointList.add(lat, lon);
-		}
-
-		return (int) tmpNode;
-	}
-
-	protected void finishedReading() {
-		printInfo("way");
-		pillarInfo.clear();
-		eleProvider.release();
-		osmNodeIdToInternalNodeMap = null;
-		osmNodeIdToNodeFlagsMap = null;
-		osmWayIdToRouteWeightMap = null;
-		osmIdStoreRequiredSet = null;
-		edgeIdToOsmIdMap = null;
-	}
-
-	/**
-	 * Create a copy of the barrier node
-	 */
-	long addBarrierNode(long nodeId) {
-		OSMNode newNode;
-		int graphIndex = getNodeMap().get(nodeId);
-		if (graphIndex < TOWER_NODE) {
-			graphIndex = -graphIndex - 3;
-			newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
-		} else {
-			graphIndex = graphIndex - 3;
-			newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
-		}
-
-		final long id = newNode.getId();
-		prepareHighwayNode(id);
-		addNode(newNode);
-		return id;
-	}
-
-	private long createNewNodeId() {
-		return newUniqueOsmId++;
-	}
-
-	/**
-	 * Add a zero length edge with reduced routing options to the graph.
-	 */
-	Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId,
-			long flags, long nodeFlags, long wayOsmId) {
-		// clear barred directions from routing flags
-		flags &= ~nodeFlags;
-		// add edge
-		barrierNodeIds.clear();
-		barrierNodeIds.add(fromId);
-		barrierNodeIds.add(toId);
-		return addOSMWay(barrierNodeIds, flags, wayOsmId);
-	}
-
-	/**
-	 * Creates an OSM turn relation out of an unspecified OSM relation
-	 * <p>
-	 * 
-	 * @return the OSM turn relation, <code>null</code>, if unsupported turn
-	 *         relation
-	 */
-	TurnRelation createTurnRelation(Relation relation) {
-		OSMTurnRelation.Type type = OSITNTurnRelation
-				.getRestrictionType((String) relation.getTag("restriction"));
-		if (type != OSMTurnRelation.Type.UNSUPPORTED) {
-			long fromWayID = -1;
-			long viaNodeID = -1;
-			long toWayID = -1;
-
-			for (RelationMember member : relation.getMembers()) {
-				if (OSMElement.WAY == member.type()) {
-					if ("from".equals(member.role())) {
-						fromWayID = member.ref();
-					} else if ("to".equals(member.role())) {
-						toWayID = member.ref();
-					}
-				} else if (OSMElement.NODE == member.type()
-						&& "via".equals(member.role())) {
-					viaNodeID = member.ref();
-				}
-			}
-			if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0
-					&& toWayID >= 0 && viaNodeID >= 0) {
-				return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
-			}
-		}
-		return null;
-	}
-
-	/**
-	 * Filter method, override in subclass
-	 */
-	boolean isInBounds(Node node) {
-		return true;
-	}
-
-	/**
-	 * Maps OSM IDs (long) to internal node IDs (int)
-	 */
-	protected LongIntMap getNodeMap() {
-		return osmNodeIdToInternalNodeMap;
-	}
-
-	protected TLongLongMap getNodeFlagsMap() {
-		return osmNodeIdToNodeFlagsMap;
-	}
-
-	TLongLongHashMap getRelFlagsMap() {
-		return osmWayIdToRouteWeightMap;
-	}
-
-	/**
-	 * Specify the type of the path calculation (car, bike, ...).
-	 */
-	public OsDpnReader setEncodingManager(EncodingManager acceptWay) {
-		this.encodingManager = acceptWay;
-		return this;
-	}
-
-	public OsDpnReader setWayPointMaxDistance(double maxDist) {
-		doSimplify = maxDist > 0;
-		simplifyAlgo.setMaxDistance(maxDist);
-		return this;
-	}
-
-	public OsDpnReader setWorkerThreads(int numOfWorkers) {
-		this.workerThreads = numOfWorkers;
-		return this;
-	}
-
-	public OsDpnReader setElevationProvider(ElevationProvider eleProvider) {
-		if (eleProvider == null)
-			throw new IllegalStateException(
-					"Use the NOOP elevation provider instead of null or don't call setElevationProvider");
-
-		if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
-			throw new IllegalStateException(
-					"Make sure you graph accepts 3D data");
-
-		this.eleProvider = eleProvider;
-		return this;
-	}
-
-	public OsDpnReader setOSMFile(File osmFile) {
-		this.routingFile = osmFile;
-		return this;
-	}
-
-	private void printInfo(String str) {
-		LoggerFactory.getLogger(getClass()).info(
-				"finished " + str + " processing." + " nodes: "
-						+ graphStorage.getNodes() + ", osmIdMap.size:"
-						+ getNodeMap().getSize() + ", osmIdMap:"
-						+ getNodeMap().getMemoryUsage() + "MB"
-						+ ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
-						+ ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
-						+ Helper.getMemInfo());
-	}
-
-	@Override
-	public String toString() {
-		return getClass().getSimpleName();
-	}
-
-	public GraphStorage getGraphStorage() {
-		return graphStorage;
-	}
+public class OsDpnReader implements DataReader<String> {
+    private InputStream is;
+
+    protected static final int EMPTY = -1;
+    // pillar node is >= 3
+    protected static final int PILLAR_NODE = 1;
+    // tower node is <= -3
+    protected static final int TOWER_NODE = -2;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnReader.class);
+    private long locations;
+    private long skippedLocations;
+    private final GraphStorage graphStorage;
+    private final NodeAccess nodeAccess;
+    private EncodingManager encodingManager = null;
+    private int workerThreads = -1;
+    protected long zeroCounter = 0;
+    // Using the correct Map<Long, Integer> is hard. We need a memory efficient
+    // and fast solution for big data sets!
+    //
+    // very slow: new SparseLongLongArray
+    // only append and update possible (no unordered storage like with this
+    // doubleParse): new OSMIDMap
+    // same here: not applicable as ways introduces the nodes in 'wrong' order:
+    // new OSMIDSegmentedMap
+    // memory overhead due to open addressing and full rehash:
+    // nodeOsmIdToIndexMap = new BigLongIntMap(expectedNodes, EMPTY);
+    // smaller memory overhead for bigger data sets because of avoiding a
+    // "rehash"
+    // remember how many times a node was used to identify tower nodes
+    private TObjectIntMap<String> osmNodeIdToInternalNodeMap;
+    private TObjectLongMap<String> osmNodeIdToNodeFlagsMap;
+    private TObjectLongHashMap<String> osmWayIdToRouteWeightMap;
+    // stores osm way ids used by relations to identify which edge ids needs to
+    // be mapped later
+    private THashSet<String> osmIdStoreRequiredSet = new THashSet<String>();
+    private TLongObjectMap<String> edgeIdToOsmIdMap;
+    protected PillarInfo pillarInfo;
+    private final DistanceCalc distCalc = new DistanceCalcEarth();
+    private final DistanceCalc3D distCalc3D = new DistanceCalc3D();
+    private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
+    private boolean doSimplify = true;
+    private int nextTowerId = 0;
+    private int nextPillarId = 0;
+    // negative but increasing to avoid clash with custom created OSM files
+    private long newUniqueOsmId = -Long.MAX_VALUE;
+    private ElevationProvider eleProvider = ElevationProvider.NOOP;
+    private final boolean exitOnlyPillarNodeException = true;
+    private File routingFile;
+
+    public OsDpnReader(GraphStorage storage) {
+        this.graphStorage = storage;
+        this.nodeAccess = graphStorage.getNodeAccess();
+
+        osmNodeIdToInternalNodeMap = new TObjectIntHashMap<String>(200, .5f, -1);
+        osmNodeIdToNodeFlagsMap = new TObjectLongHashMap<String>(200, .5f, 0);
+        osmWayIdToRouteWeightMap = new TObjectLongHashMap<String>(200, .5f, 0);
+        pillarInfo = new PillarInfo(nodeAccess.is3D(),
+                graphStorage.getDirectory());
+    }
+
+    @Override
+    public void readGraph() throws IOException {
+        if (encodingManager == null)
+            throw new IllegalStateException("Encoding manager was not set.");
+
+        if (routingFile == null)
+            throw new IllegalStateException("No OS DPN file specified");
+
+        if (!routingFile.exists())
+            throw new IllegalStateException(
+                    "Your specified OS DPN file does not exist:"
+                            + routingFile.getAbsolutePath());
+
+        StopWatch sw1 = new StopWatch().start();
+        preProcess(routingFile);
+        sw1.stop();
+
+        StopWatch sw2 = new StopWatch().start();
+        writeOsm2Graph(routingFile);
+        sw2.stop();
+
+        logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: "
+                + (int) sw2.getSeconds() + " total:"
+                + ((int) (sw1.getSeconds() + sw2.getSeconds())));
+    }
+
+    /**
+     * Preprocessing of OSM file to select nodes which are used for highways.
+     * This allows a more compact graph data structure.
+     */
+    void preProcess(File osmFile) {
+        OsDpnInputFile in = null;
+        try {
+            in = new OsDpnInputFile(osmFile).setWorkerThreads(workerThreads)
+                    .open();
+
+            long tmpWayCounter = 1;
+            long tmpRelationCounter = 1;
+            RoutingElement item;
+            while ((item = in.getNext()) != null) {
+                System.out.println("OsItnReader.preProcess( " + item.getType()
+                        + " )");
+                if (item.isType(OSMElement.WAY)) {
+                    final OsDpnWay way = (OsDpnWay) item;
+                    boolean valid = filterWay(way);
+                    if (valid) {
+                        List<String> wayNodes = way.getNodes();
+                        int s = wayNodes.size();
+                        for (int index = 0; index < s; index++) {
+                            prepareHighwayNode(wayNodes.get(index));
+                        }
+
+                        if (++tmpWayCounter % 500000 == 0) {
+                            logger.info(nf(tmpWayCounter)
+                                    + " (preprocess), osmIdMap:"
+                                    + nf(getNodeMap().size())
+                                    + Helper.getMemInfo());
+                        }
+                    }
+                }
+                // if (item.isType(OSMElement.RELATION)) {
+                // final OSMRelation relation = (OSMRelation) item;
+                // if (!relation.isMetaRelation()
+                // && relation.hasTag("type", "route"))
+                // prepareWaysWithRelationInfo(relation);
+                //
+                // if (relation.hasTag("type", "restriction"))
+                // prepareRestrictionRelation(relation);
+                //
+                // if (++tmpRelationCounter % 50000 == 0) {
+                // logger.info(nf(tmpRelationCounter)
+                // + " (preprocess), osmWayMap:"
+                // + nf(getRelFlagsMap().size()) + " "
+                // + Helper.getMemInfo());
+                // }
+                //
+                // }
+            }
+        } catch (Exception ex) {
+            throw new RuntimeException("Problem while parsing file", ex);
+        } finally {
+            Helper.close(in);
+        }
+    }
+
+    /*
+     * private void prepareRestrictionRelation(OSMRelation relation) {
+     * TurnRelation turnRelation = createTurnRelation(relation); if
+     * (turnRelation != null) {
+     * getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdFrom());
+     * getOsmIdStoreRequiredSet().add(turnRelation.getOsmIdTo()); } }
+     */
+
+    private THashSet<String> getOsmIdStoreRequiredSet() {
+        return osmIdStoreRequiredSet;
+    }
+
+    private TLongObjectMap<String> getEdgeIdToOsmidMap() {
+        if (edgeIdToOsmIdMap == null)
+            edgeIdToOsmIdMap = new TLongObjectHashMap<String>(
+                    getOsmIdStoreRequiredSet().size());
+
+        return edgeIdToOsmIdMap;
+    }
+
+    /**
+     * Filter ways but do not analyze properties wayNodes will be filled with
+     * participating node ids.
+     * <p/>
+     * 
+     * @return true the current xml entry is a way entry and has nodes
+     */
+    boolean filterWay(OsDpnWay way) {
+        // ignore broken geometry
+        if (way.getNodes().size() < 2)
+            return false;
+
+        // ignore multipolygon geometry
+        if (!way.hasTags())
+            return false;
+
+        return encodingManager.acceptWay(way) > 0;
+    }
+
+    /**
+     * Creates the edges and nodes files from the specified osm file.
+     */
+    private void writeOsm2Graph(File osmFile) {
+        int tmp = Math.max(getNodeMap().size() / 50, 100);
+        logger.info("creating graph. Found nodes (pillar+tower):"
+                + nf(getNodeMap().size()) + ", " + Helper.getMemInfo());
+        graphStorage.create(tmp);
+        long wayStart = -1;
+        long relationStart = -1;
+        long counter = 1;
+        OsDpnInputFile in = null;
+        try {
+            in = new OsDpnInputFile(osmFile).setWorkerThreads(workerThreads)
+                    .open();
+            TObjectIntMap<String> nodeFilter = getNodeMap();
+
+            RoutingElement item;
+            while ((item = in.getNext()) != null) {
+                switch (item.getType()) {
+                    case OSMElement.NODE:
+                        OsDpnNode dpnNode = (OsDpnNode) item;
+                        String id = dpnNode.getId();
+                        logger.info("NODEITEMID:" + id);
+                        if (nodeFilter.get(id) != -1) {
+                            processNode(dpnNode);
+                        }
+                        break;
+
+                    case OSMElement.WAY:
+                        OsDpnWay dpnWay = (OsDpnWay) item;
+                        logger.info("WAY:" + dpnWay.getId() + ":" + wayStart);
+                        if (wayStart < 0) {
+                            logger.info(nf(counter) + ", now parsing ways");
+                            wayStart = counter;
+                        }
+                        processWay(dpnWay);
+                        break;
+                    case OSMElement.RELATION:
+                        if (relationStart < 0) {
+                            logger.info(nf(counter) + ", now parsing relations");
+                            relationStart = counter;
+                        }
+                        processRelation((Relation) item);
+                        break;
+                }
+                if (++counter % 5000000 == 0) {
+                    logger.info(nf(counter) + ", locs:" + nf(locations) + " ("
+                            + skippedLocations + ") " + Helper.getMemInfo());
+                }
+            }
+
+            // logger.info("storage nodes:" + graphStorage.getNodes());
+        } catch (Exception ex) {
+            System.out.println(ex.getClass());
+            // throw new RuntimeException("Couldn't process file " + osmFile,
+            // ex);
+        } finally {
+            Helper.close(in);
+        }
+
+        finishedReading();
+        if (graphStorage.getNodes() == 0)
+            throw new IllegalStateException("osm must not be empty. read "
+                    + counter + " lines and " + locations + " locations");
+    }
+
+    /**
+     * Process properties, encode flags and create edges for the way.
+     */
+    void processWay(OsDpnWay way) {
+        if (way.getNodes().size() < 2)
+            return;
+
+        // ignore multipolygon geometry
+        if (!way.hasTags())
+            return;
+
+        String wayOsmId = way.getId();
+
+        long includeWay = encodingManager.acceptWay(way);
+        if (includeWay == 0)
+            return;
+
+        long relationFlags = getRelFlagsMap().get(way.getId());
+
+        // TODO move this after we have created the edge and know the
+        // coordinates => encodingManager.applyWayTags
+        // estimate length of the track e.g. for ferry speed calculation
+        List<String> osmNodeIds = way.getNodes();
+        if (osmNodeIds.size() > 1) {
+            int first = getNodeMap().get(osmNodeIds.get(0));
+            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon)
+                    && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
+                double estimatedDist = distCalc.calcDist(firstLat, firstLon,
+                        lastLat, lastLon);
+                way.setTag("estimated_distance", estimatedDist);
+                way.setTag("estimated_center", new GHPoint(
+                        (firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
+            }
+        }
+
+        long wayFlags = encodingManager.handleWayTags(way, includeWay,
+                relationFlags);
+        if (wayFlags == 0)
+            return;
+
+        List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
+        // look for barriers along the way
+        final int size = osmNodeIds.size();
+        int lastBarrier = -1;
+        for (int i = 0; i < size; i++) {
+            String nodeId = osmNodeIds.get(i);
+            long nodeFlags = getNodeFlagsMap().get(nodeId);
+            // barrier was spotted and way is otherwise passable for that mode
+            // of travel
+            if (nodeFlags > 0) {
+                if ((nodeFlags & wayFlags) > 0) {
+                    // remove barrier to avoid duplicates
+                    getNodeFlagsMap().put(nodeId, 0);
+
+                    // create shadow node copy for zero length edge
+                    String newNodeId = addBarrierNode(nodeId);
+                    if (i > 0) {
+                        // start at beginning of array if there was no previous
+                        // barrier
+                        if (lastBarrier < 0)
+                            lastBarrier = 0;
+
+                        // add way up to barrier shadow node
+                        String transfer[] = { "" };
+                        transfer = osmNodeIds.subList(lastBarrier,
+                                i - lastBarrier + 1).toArray(transfer);
+                        transfer[transfer.length - 1] = newNodeId;
+                        createdEdges.addAll(addOSMWay(transfer, wayFlags,
+                                wayOsmId));
+
+                        // create zero length edge for barrier
+                        createdEdges.addAll(addBarrierEdge(newNodeId, nodeId,
+                                wayFlags, nodeFlags, wayOsmId));
+                    } else {
+                        // run edge from real first node to shadow node
+                        createdEdges.addAll(addBarrierEdge(nodeId, newNodeId,
+                                wayFlags, nodeFlags, wayOsmId));
+
+                        // exchange first node for created barrier node
+                        osmNodeIds.set(0, newNodeId);
+                    }
+                    // remember barrier for processing the way behind it
+                    lastBarrier = i;
+                }
+            }
+        }
+
+        // just add remainder of way to graph if barrier was not the last node
+        if (lastBarrier >= 0) {
+            if (lastBarrier < size - 1) {
+                String transfer[] = { "" };
+                transfer = osmNodeIds.subList(lastBarrier, size - lastBarrier)
+                        .toArray(transfer);
+                createdEdges.addAll(addOSMWay(transfer, wayFlags, wayOsmId));
+            }
+        } else {
+            // no barriers - simply add the whole way
+            String transfer[] = { "" };
+            transfer = way.getNodes().toArray(transfer);
+            createdEdges.addAll(addOSMWay(transfer, wayFlags, wayOsmId));
+        }
+
+        for (EdgeIteratorState edge : createdEdges) {
+            encodingManager.applyWayTags(way, edge);
+        }
+    }
+
+    public void processRelation(Relation relation) throws XMLStreamException {
+        // if (relation.hasTag("type", "restriction")) {
+        // TurnRelation turnRelation = createTurnRelation(relation);
+        // if (turnRelation != null) {
+        // ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
+        // .getExtendedStorage();
+        // if (extendedStorage instanceof TurnCostStorage) {
+        // Collection<ITurnCostTableEntry> entries = encodingManager
+        // .analyzeTurnRelation(turnRelation, this);
+        // for (ITurnCostTableEntry entry : entries) {
+        // ((TurnCostStorage) extendedStorage).setTurnCosts(
+        // entry.nodeVia, entry.edgeFrom, entry.edgeTo,
+        // (int) entry.flags);
+        // }
+        // }
+        // }
+        // }
+    }
+
+    @Override
+    public String getOsmIdOfInternalEdge(int edgeId) {
+        return getEdgeIdToOsmidMap().get(edgeId);
+    }
+
+    @Override
+    public int getInternalNodeIdOfOsmNode(String nodeOsmId) {
+        int id = getNodeMap().get(nodeOsmId);
+        if (id < TOWER_NODE)
+            return -id - 3;
+
+        return EMPTY;
+    }
+
+    // TODO remove this ugly stuff via better preparsing phase! E.g. putting
+    // every tags etc into a helper file!
+    double getTmpLatitude(int id) {
+        if (id == EMPTY)
+            return Double.NaN;
+        if (id < TOWER_NODE) {
+            // tower node
+            id = -id - 3;
+            return nodeAccess.getLatitude(id);
+        } else if (id > -TOWER_NODE) {
+            // pillar node
+            id = id - 3;
+            return pillarInfo.getLatitude(id);
+        } else
+            // e.g. if id is not handled from preparse (e.g. was ignored via
+            // isInBounds)
+            return Double.NaN;
+    }
+
+    double getTmpLongitude(int id) {
+        if (id == EMPTY)
+            return Double.NaN;
+        if (id < TOWER_NODE) {
+            // tower node
+            id = -id - 3;
+            return nodeAccess.getLongitude(id);
+        } else if (id > -TOWER_NODE) {
+            // pillar node
+            id = id - 3;
+            return pillarInfo.getLon(id);
+        } else
+            // e.g. if id is not handled from preparse (e.g. was ignored via
+            // isInBounds)
+            return Double.NaN;
+    }
+
+    private void processNode(OsDpnNode node) {
+        if (isInBounds(node)) {
+            addNode(node);
+
+            // analyze node tags for barriers
+            if (node.hasTags()) {
+                long nodeFlags = encodingManager.handleNodeTags(node);
+                if (nodeFlags != 0)
+                    getNodeFlagsMap().put(node.getId(), nodeFlags);
+            }
+
+            locations++;
+        } else {
+            skippedLocations++;
+        }
+    }
+
+    boolean addNode(OsDpnNode node) {
+        int nodeType = getNodeMap().get(node.getId());
+        if (nodeType == EMPTY)
+            return false;
+
+        double lat = node.getLat();
+        double lon = node.getLon();
+        double ele = getElevation(node);
+        if (nodeType == TOWER_NODE) {
+            addTowerNode(node.getId(), lat, lon, ele);
+        } else if (nodeType == PILLAR_NODE) {
+            pillarInfo.setNode(nextPillarId, lat, lon, ele);
+            getNodeMap().put(node.getId(), nextPillarId + 3);
+            nextPillarId++;
+        }
+        return true;
+    }
+
+    private double getElevation(Node node) {
+        return eleProvider.getEle(node.getLat(), node.getLon());
+    }
+
+    /*
+     * void prepareWaysWithRelationInfo(OSMRelation osmRelation) { // is there
+     * at least one tag interesting for the registed encoders? if
+     * (encodingManager.handleRelationTags(osmRelation, 0) == 0) return;
+     * 
+     * int size = osmRelation.getMembers().size(); for (int index = 0; index <
+     * size; index++) { OSMRelation.Member member =
+     * osmRelation.getMembers().get(index); if (member.type() !=
+     * OSMRelation.Member.WAY) continue;
+     * 
+     * long osmId = member.ref(); long oldRelationFlags =
+     * getRelFlagsMap().get(osmId);
+     * 
+     * // Check if our new relation data is better comparated to the the // last
+     * one long newRelationFlags = encodingManager.handleRelationTags(
+     * osmRelation, oldRelationFlags); if (oldRelationFlags != newRelationFlags)
+     * getRelFlagsMap().put(osmId, newRelationFlags); } }
+     */
+
+    void prepareHighwayNode(String idStr) {
+        int tmpIndex = getNodeMap().get(idStr);
+        if (tmpIndex == EMPTY) {
+            // osmId is used exactly once
+            logger.debug("OsDpnReader.prepareHighwayNode(EMPTY->PILLAR)");
+            getNodeMap().put(idStr, PILLAR_NODE);
+        } else if (tmpIndex > EMPTY) {
+            // mark node as tower node as it occured at least twice times
+            logger.debug("OsDpnReader.prepareHighwayNode(PILLAR->TOWER)");
+            getNodeMap().put(idStr, TOWER_NODE);
+        } else {
+            // tmpIndex is already negative (already tower node)
+        }
+    }
+
+    int addTowerNode(String osmId, double lat, double lon, double ele) {
+        if (nodeAccess.is3D())
+            nodeAccess.setNode(nextTowerId, lat, lon, ele);
+        else
+            nodeAccess.setNode(nextTowerId, lat, lon);
+
+        int id = -(nextTowerId + 3);
+        getNodeMap().put(osmId, id);
+        nextTowerId++;
+        return id;
+    }
+
+    /**
+     * This method creates from an OSM way (via the osm ids) one or more edges
+     * in the graph.
+     */
+    Collection<EdgeIteratorState> addOSMWay(String[] osmNodeIds, long flags,
+            String wayOsmId) {
+        PointList pointList = new PointList(osmNodeIds.length,
+                nodeAccess.is3D());
+        List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
+        int firstNode = -1;
+        int lastIndex = osmNodeIds.length - 1;
+        int lastInBoundsPillarNode = -1;
+        try {
+            for (int i = 0; i < osmNodeIds.length; i++) {
+                String osmId = osmNodeIds[i];
+                int tmpNode = getNodeMap().get(osmId);
+                if (tmpNode == EMPTY)
+                    continue;
+
+                // skip osmIds with no associated pillar or tower id (e.g.
+                // !OSMReader.isBounds)
+                if (tmpNode == TOWER_NODE)
+                    continue;
+
+                if (tmpNode == PILLAR_NODE) {
+                    // In some cases no node information is saved for the
+                    // specified osmId.
+                    // ie. a way references a <node> which does not exist in the
+                    // current file.
+                    // => if the node before was a pillar node then convert into
+                    // to tower node (as it is also end-standing).
+                    if (!pointList.isEmpty()
+                            && lastInBoundsPillarNode > -TOWER_NODE) {
+                        // transform the pillar node to a tower node
+                        tmpNode = lastInBoundsPillarNode;
+                        tmpNode = handlePillarNode(tmpNode, osmId, null, true);
+                        tmpNode = -tmpNode - 3;
+                        if (pointList.getSize() > 1 && firstNode >= 0) {
+                            // TOWER node
+                            newEdges.add(addEdge(firstNode, tmpNode, pointList,
+                                    flags, wayOsmId));
+                            pointList.clear();
+                            pointList.add(nodeAccess, tmpNode);
+                        }
+                        firstNode = tmpNode;
+                        lastInBoundsPillarNode = -1;
+                    }
+                    continue;
+                }
+
+                if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
+                    throw new AssertionError(
+                            "Mapped index not in correct bounds " + tmpNode
+                                    + ", " + osmId);
+
+                if (tmpNode > -TOWER_NODE) {
+                    boolean convertToTowerNode = i == 0 || i == lastIndex;
+                    if (!convertToTowerNode) {
+                        lastInBoundsPillarNode = tmpNode;
+                    }
+
+                    // PILLAR node, but convert to towerNode if end-standing
+                    tmpNode = handlePillarNode(tmpNode, osmId, pointList,
+                            convertToTowerNode);
+                }
+
+                if (tmpNode < TOWER_NODE) {
+                    // TOWER node
+                    tmpNode = -tmpNode - 3;
+                    pointList.add(nodeAccess, tmpNode);
+                    if (firstNode >= 0) {
+                        newEdges.add(addEdge(firstNode, tmpNode, pointList,
+                                flags, wayOsmId));
+                        pointList.clear();
+                        pointList.add(nodeAccess, tmpNode);
+                    }
+                    firstNode = tmpNode;
+                }
+            }
+        } catch (RuntimeException ex) {
+            logger.error("Couldn't properly add edge with osm ids:"
+                    + osmNodeIds, ex);
+            if (exitOnlyPillarNodeException)
+                throw ex;
+        }
+        return newEdges;
+    }
+
+    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList,
+            long flags, String wayOsmId) {
+        // sanity checks
+        if (fromIndex < 0 || toIndex < 0)
+            throw new AssertionError(
+                    "to or from index is invalid for this edge " + fromIndex
+                            + "->" + toIndex + ", points:" + pointList);
+        if (pointList.getDimension() != nodeAccess.getDimension())
+            throw new AssertionError(
+                    "Dimension does not match for pointList vs. nodeAccess "
+                            + pointList.getDimension() + " <-> "
+                            + nodeAccess.getDimension());
+
+        double towerNodeDistance = 0;
+        double prevLat = pointList.getLatitude(0);
+        double prevLon = pointList.getLongitude(0);
+        double prevEle = pointList.is3D() ? pointList.getElevation(0)
+                : Double.NaN;
+        double lat, lon, ele = Double.NaN;
+        PointList pillarNodes = new PointList(pointList.getSize() - 2,
+                nodeAccess.is3D());
+        int nodes = pointList.getSize();
+        for (int i = 1; i < nodes; i++) {
+            // we could save some lines if we would use
+            // pointList.calcDistance(distCalc);
+            lat = pointList.getLatitude(i);
+            lon = pointList.getLongitude(i);
+            if (pointList.is3D()) {
+                ele = pointList.getElevation(i);
+                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon,
+                        prevEle, lat, lon, ele);
+                prevEle = ele;
+            } else
+                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat,
+                        lon);
+            prevLat = lat;
+            prevLon = lon;
+            if (nodes > 2 && i < nodes - 1) {
+                if (pillarNodes.is3D())
+                    pillarNodes.add(lat, lon, ele);
+                else
+                    pillarNodes.add(lat, lon);
+            }
+        }
+        if (towerNodeDistance == 0) {
+            // As investigation shows often two paths should have crossed via
+            // one identical point
+            // but end up in two very release points.
+            zeroCounter++;
+            towerNodeDistance = 0.0001;
+        }
+
+        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
+                .setDistance(towerNodeDistance).setFlags(flags);
+        if (nodes > 2) {
+            if (doSimplify)
+                simplifyAlgo.simplify(pillarNodes);
+
+            iter.setWayGeometry(pillarNodes);
+        }
+        storeOSMWayID(iter.getEdge(), wayOsmId);
+        return iter;
+    }
+
+    private void storeOSMWayID(int edgeId, String osmWayID) {
+        if (getOsmIdStoreRequiredSet().contains(osmWayID)) {
+            getEdgeIdToOsmidMap().put(edgeId, osmWayID);
+        }
+    }
+
+    /**
+     * @return converted tower node
+     */
+    private int handlePillarNode(int tmpNode, String osmId,
+            PointList pointList, boolean convertToTowerNode) {
+        logger.info("Converting Pillar " + osmId, " to pillar? "
+                + convertToTowerNode);
+        tmpNode = tmpNode - 3;
+        double lat = pillarInfo.getLatitude(tmpNode);
+        double lon = pillarInfo.getLongitude(tmpNode);
+        double ele = pillarInfo.getElevation(tmpNode);
+        if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
+            throw new RuntimeException(
+                    "Conversion pillarNode to towerNode already happended!? "
+                            + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+
+        if (convertToTowerNode) {
+            // convert pillarNode type to towerNode, make pillar values invalid
+            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE,
+                    Double.MAX_VALUE);
+            tmpNode = addTowerNode(osmId, lat, lon, ele);
+        } else {
+            if (pointList.is3D())
+                pointList.add(lat, lon, ele);
+            else
+                pointList.add(lat, lon);
+        }
+
+        return tmpNode;
+    }
+
+    protected void finishedReading() {
+        printInfo("way");
+        pillarInfo.clear();
+        eleProvider.release();
+        osmNodeIdToInternalNodeMap = null;
+        osmNodeIdToNodeFlagsMap = null;
+        osmWayIdToRouteWeightMap = null;
+        osmIdStoreRequiredSet = null;
+        edgeIdToOsmIdMap = null;
+    }
+
+    /**
+     * Create a copy of the barrier node
+     */
+    String addBarrierNode(String nodeId) {
+        OsDpnNode newNode;
+        int graphIndex = getNodeMap().get(nodeId);
+        if (graphIndex < TOWER_NODE) {
+            graphIndex = -graphIndex - 3;
+            newNode = new OsDpnNode(createNewNodeId(), nodeAccess, graphIndex);
+        } else {
+            graphIndex = graphIndex - 3;
+            newNode = new OsDpnNode(createNewNodeId(), pillarInfo, graphIndex);
+        }
+
+        final String id = newNode.getId();
+        prepareHighwayNode(id);
+        addNode(newNode);
+        return id;
+    }
+
+    private String createNewNodeId() {
+        return String.valueOf(newUniqueOsmId++);
+    }
+
+    /**
+     * Add a zero length edge with reduced routing options to the graph.
+     */
+    Collection<EdgeIteratorState> addBarrierEdge(String fromId, String toId,
+            long flags, long nodeFlags, String wayOsmId) {
+        // clear barred directions from routing flags
+        flags &= ~nodeFlags;
+        // add edge
+        String barrierNodeIds[] = { fromId, toId };
+        return addOSMWay(barrierNodeIds, flags, wayOsmId);
+    }
+
+    /**
+     * Creates an OSM turn relation out of an unspecified OSM relation
+     * <p>
+     * 
+     * @return the OSM turn relation, <code>null</code>, if unsupported turn
+     *         relation
+     */
+    TurnRelation createTurnRelation(Relation relation) {
+        OSMTurnRelation.Type type = OSITNTurnRelation
+                .getRestrictionType(relation.getTag("restriction"));
+        if (type != OSMTurnRelation.Type.UNSUPPORTED) {
+            long fromWayID = -1;
+            long viaNodeID = -1;
+            long toWayID = -1;
+
+            for (RelationMember member : relation.getMembers()) {
+                if (OSMElement.WAY == member.type()) {
+                    if ("from".equals(member.role())) {
+                        fromWayID = member.ref();
+                    } else if ("to".equals(member.role())) {
+                        toWayID = member.ref();
+                    }
+                } else if (OSMElement.NODE == member.type()
+                        && "via".equals(member.role())) {
+                    viaNodeID = member.ref();
+                }
+            }
+            if (type != OSMTurnRelation.Type.UNSUPPORTED && fromWayID >= 0
+                    && toWayID >= 0 && viaNodeID >= 0) {
+                return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Filter method, override in subclass
+     */
+    boolean isInBounds(Node node) {
+        return true;
+    }
+
+    /**
+     * Maps OSM IDs (long) to internal node IDs (int)
+     */
+    protected TObjectIntMap<String> getNodeMap() {
+        return osmNodeIdToInternalNodeMap;
+    }
+
+    protected TObjectLongMap<String> getNodeFlagsMap() {
+        return osmNodeIdToNodeFlagsMap;
+    }
+
+    TObjectLongHashMap<String> getRelFlagsMap() {
+        return osmWayIdToRouteWeightMap;
+    }
+
+    /**
+     * Specify the type of the path calculation (car, bike, ...).
+     */
+    @Override
+    public OsDpnReader setEncodingManager(EncodingManager acceptWay) {
+        this.encodingManager = acceptWay;
+        return this;
+    }
+
+    @Override
+    public OsDpnReader setWayPointMaxDistance(double maxDist) {
+        doSimplify = maxDist > 0;
+        simplifyAlgo.setMaxDistance(maxDist);
+        return this;
+    }
+
+    @Override
+    public OsDpnReader setWorkerThreads(int numOfWorkers) {
+        this.workerThreads = numOfWorkers;
+        return this;
+    }
+
+    @Override
+    public OsDpnReader setElevationProvider(ElevationProvider eleProvider) {
+        if (eleProvider == null)
+            throw new IllegalStateException(
+                    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+
+        if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
+            throw new IllegalStateException(
+                    "Make sure you graph accepts 3D data");
+
+        this.eleProvider = eleProvider;
+        return this;
+    }
+
+    @Override
+    public OsDpnReader setOSMFile(File osmFile) {
+        this.routingFile = osmFile;
+        return this;
+    }
+
+    private void printInfo(String str) {
+        LoggerFactory.getLogger(getClass()).info(
+                "finished " + str + " processing." + " nodes: "
+                        + graphStorage.getNodes() + ", osmIdMap.size:"
+                        + getNodeMap().size() + ", osmIdMap:"
+                        + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
+                        + ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
+                        + Helper.getMemInfo());
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName();
+    }
+
+    @Override
+    public GraphStorage getGraphStorage() {
+        return graphStorage;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java
index 8a48addfc2..69a3777ffd 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnWay.java
@@ -17,8 +17,9 @@
  */
 package com.graphhopper.reader.osgb.dpn;
 
-import gnu.trove.list.TLongList;
-import gnu.trove.list.array.TLongArrayList;
+import gnu.trove.map.TDoubleLongMap;
+import gnu.trove.map.TDoubleObjectMap;
+import gnu.trove.map.TLongObjectMap;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -34,8 +35,6 @@
 import org.slf4j.LoggerFactory;
 
 import com.graphhopper.reader.Way;
-import com.graphhopper.reader.osgb.OSITNNode;
-import com.graphhopper.reader.osgb.OSITNWay;
 
 /**
  * Represents an OSM Way
@@ -43,111 +42,176 @@
  * 
  * @author Nop
  */
-public class OsDpnWay extends OSITNWay implements Way {
-	private static final long WAY_NODE_PREFIX_MOD = 100000000000000000L;
-	private long endNode;
-	private static final Logger logger = LoggerFactory
-			.getLogger(OsDpnWay.class);
-
-	/**
-	 * Constructor for XML Parser
-	 * @throws TransformException 
-	 * @throws FactoryException 
-	 * @throws MismatchedDimensionException 
-	 */
-	public static OsDpnWay create(long id, XMLStreamReader parser)
-			throws XMLStreamException, MismatchedDimensionException, FactoryException, TransformException {
-		OsDpnWay way = new OsDpnWay(id);
-		parser.nextTag();
-		way.readTags(parser);
-		way.setTag("highway", "motorway");
-		logger.info(way.toString());
-		return way;
-	}
-
-	public OsDpnWay(long id) {
-		super(id);
-	}
-
-	@Override
-	protected void parseCoords(String lineDefinition) {
-		String[] lineSegments = lineDefinition.split(" ");
-		wayCoords = Arrays
-				.copyOfRange(lineSegments, 1, lineSegments.length -1);
-		logger.info(toString() + " "  + ((wayCoords.length == 0)?"0":wayCoords[0]));
-	}
-	
-	@Override
-	protected void parseCoords(int dimensions, String lineDefinition) {
-		String[] lineSegments = lineDefinition.split(" ");
-		wayCoords = new String[lineSegments.length/dimensions];
-		StringBuilder curString = null;
-		for (int i = 0; i < lineSegments.length; i++) {
-			String string = lineSegments[i];
-			switch (i % dimensions) {
-			case 0: {
-				int coordNumber = i/dimensions;
-				if(coordNumber >0) {
-					wayCoords[coordNumber-1] = curString.toString();
-				}
-				curString = new StringBuilder();
-				curString.append(string);
-				break;
-			}
-					
-			case 1:	
-			case 2: {
-				curString.append(',');
-				curString.append(string); 
-			}
-			}
-		}
-		wayCoords[wayCoords.length-1] = curString.toString();
-		addWayNodes();
-		nodes.add(endNode);
-		logger.info(toString() + " "  + ((wayCoords.length == 0)?"0":wayCoords[0]));
-	}
-	@Override
-	protected void parseNetworkMember(String elementText) {
-		throw new UnsupportedOperationException();
-	}
-
-	@Override
-	protected void addDirectedNode(String nodeId, String grade,
-			String orientation) {
-		String idStr = nodeId.substring(5);
-		if (null != grade) {
-			idStr = grade + idStr;
-		}
-		long id = Long.parseLong(idStr);
-
-		if (0 == nodes.size()) {
-			nodes.add(id);
-		} else {
-			endNode = id;
-		}
-	}
-
-	@Override
-	protected void addDirectedLink(String nodeId, String orientation) {
-		throw new UnsupportedOperationException();
-	}
-
-	public List<OSITNNode> evaluateWayNodes() throws MismatchedDimensionException, FactoryException, TransformException {
-		List<OSITNNode> wayNodes = new ArrayList<OSITNNode>();
-
-		for (int i = 0; i < wayCoords.length; i++) {
-			String wayCoord = wayCoords[i];
-			long idPrefix = (i+1) * WAY_NODE_PREFIX_MOD;
-			long id = idPrefix + getId();
-			OSITNNode wayNode = new OSITNNode(id);
-			wayNode.parseCoordinateString(wayCoord, ",");
-			wayNodes.add(wayNode);
-		}
-		return wayNodes;
-	}
-
-	public void clearWayNodes() {
-		wayCoords = null;
-	}
+public class OsDpnWay extends OsDpnElement implements Way {
+    private static final long WAY_NODE_PREFIX_MOD = 100000000000000000L;
+    protected final List<String> nodes = new ArrayList<String>(5);
+    private String endNode;
+    protected String startCoord;
+    protected String endCoord;
+    private String[] wayCoords;
+    private static final Logger logger = LoggerFactory
+            .getLogger(OsDpnWay.class);
+
+    /**
+     * Constructor for XML Parser
+     * 
+     * @throws TransformException
+     * @throws FactoryException
+     * @throws MismatchedDimensionException
+     */
+    public static OsDpnWay create(String idStr, XMLStreamReader parser)
+            throws XMLStreamException, MismatchedDimensionException,
+            FactoryException, TransformException {
+        System.out.println("OsDpnWay.create()");
+        OsDpnWay way = new OsDpnWay(idStr);
+        parser.nextTag();
+        way.readTags(parser);
+        way.setTag("highway", "motorway");
+        logger.info(way.toString());
+        return way;
+    }
+
+    public OsDpnWay(String id) {
+        super(id, WAY);
+    }
+
+    public List<String> getNodes() {
+        return nodes;
+    }
+
+    @Override
+    protected void parseCoords(String lineDefinition) {
+        String[] lineSegments = lineDefinition.split(" ");
+        wayCoords = Arrays
+                .copyOfRange(lineSegments, 1, lineSegments.length - 1);
+        logger.info(toString() + " "
+                + ((wayCoords.length == 0) ? "0" : wayCoords[0]));
+    }
+
+    @Override
+    protected void parseCoords(int dimensions, String lineDefinition) {
+        String[] lineSegments = lineDefinition.split(" ");
+        wayCoords = new String[lineSegments.length / dimensions];
+        StringBuilder curString = null;
+        for (int i = 0; i < lineSegments.length; i++) {
+            String string = lineSegments[i];
+            switch (i % dimensions) {
+                case 0: {
+                    int coordNumber = i / dimensions;
+                    if (coordNumber > 0) {
+                        wayCoords[coordNumber - 1] = curString.toString();
+                    }
+                    curString = new StringBuilder();
+                    curString.append(string);
+                    break;
+                }
+
+                case 1:
+                case 2: {
+                    curString.append(',');
+                    curString.append(string);
+                }
+            }
+        }
+        wayCoords[wayCoords.length - 1] = curString.toString();
+        addWayNodes();
+        nodes.add(endNode);
+        logger.info(toString() + " "
+                + ((wayCoords.length == 0) ? "0" : wayCoords[0]));
+    }
+
+    @Override
+    protected void parseNetworkMember(String elementText) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected void addNode(String nodeId) {
+        String idStr = nodeId.substring(1);
+        if (0 == nodes.size()) {
+            nodes.add(idStr);
+        } else {
+            endNode = idStr;
+        }
+    }
+
+    protected void addWayNodes() {
+        for (int i = 1; i <= wayCoords.length; i++) {
+            long idPrefix = i;
+            String extraId = idPrefix + getId();
+            nodes.add(extraId);
+        }
+    }
+
+    @Override
+    protected void addDirectedLink(String nodeId, String orientation) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Creates a new OsDpnNode for each wayCoord. This also Looks for direction
+     * flags in edgeIdToXToYToNodeFlagsMap for the wayId, x, y combination. If
+     * it exists then set the node tag TAG_KEY_NOENTRY_ORIENTATION to true and
+     * the TAG_KEY_ONEWAY_ORIENTATION node tag to -1 for one direction and true
+     * for the other.
+     * 
+     * @param edgeIdToXToYToNodeFlagsMap
+     * @return
+     * @throws TransformException
+     * @throws FactoryException
+     * @throws MismatchedDimensionException
+     */
+    public List<OsDpnNode> evaluateWayNodes(
+            TLongObjectMap<TDoubleObjectMap<TDoubleLongMap>> edgeIdToXToYToNodeFlagsMap)
+            throws MismatchedDimensionException, FactoryException,
+            TransformException {
+        List<OsDpnNode> wayNodes = new ArrayList<OsDpnNode>();
+
+        for (int i = 0; i < wayCoords.length; i++) {
+            String wayCoord = wayCoords[i];
+
+            long idPrefix = (i + 1) * WAY_NODE_PREFIX_MOD;
+            String id = idPrefix + getId();
+            OsDpnNode wayNode = new OsDpnNode(id);
+            wayNode.parseCoords(wayCoord);
+
+            logger.info("Node " + getId() + " coords: " + wayCoord + " tags: ");
+            for (String tagKey : wayNode.getTags().keySet()) {
+                logger.info("\t " + tagKey + " : " + wayNode.getTag(tagKey));
+            }
+
+            wayNodes.add(wayNode);
+        }
+        return wayNodes;
+    }
+
+    /**
+     * Memory management method. Once a way is processed the stored string
+     * coordinates are no longer required so set them to null so they can be
+     * garbage collected
+     */
+    public void clearStoredCoords() {
+        wayCoords = null;
+        startCoord = null;
+        endCoord = null;
+    }
+
+    public String[] getWayCoords() {
+        return wayCoords;
+    }
+
+    public String getStartCoord() {
+        return startCoord;
+    }
+
+    public String getEndCoord() {
+        return endCoord;
+    }
+
+    protected void parseCoordinateString(String elementText,
+            String elementSeparator) {
+        throw new UnsupportedOperationException();
+
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
index 5a893b7ba4..b0c2880235 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
@@ -18,6 +18,15 @@
  */
 package com.graphhopper.reader;
 
+import static org.junit.Assert.assertEquals;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.junit.Test;
+
 import com.graphhopper.reader.OSMTurnRelation.Type;
 import com.graphhopper.routing.EdgeBasedRoutingAlgorithmTest;
 import com.graphhopper.routing.util.CarFlagEncoder;
@@ -25,15 +34,9 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.EdgeExplorer;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import org.junit.Test;
-import static org.junit.Assert.*;
 
 /**
- *
+ * 
  * @author Peter Karich
  */
 public class OSMTurnRelationTest
@@ -44,29 +47,27 @@ public void testGetRestrictionAsEntries()
         CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 3);
         final Map<Long, Integer> osmNodeToInternal = new HashMap<Long, Integer>();
         final Map<Integer, Long> internalToOSMEdge = new HashMap<Integer, Long>();
-                
+
         osmNodeToInternal.put(3L, 3);
         // edge ids are only stored if they occured before in an OSMRelation
-        internalToOSMEdge.put(3, 3L);        
-        internalToOSMEdge.put(4, 4L);        
+        internalToOSMEdge.put(3, 3L);
+        internalToOSMEdge.put(4, 4L);
 
-        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder)).create();
+        GraphStorage graph = new GraphBuilder(new EncodingManager(encoder))
+                .create();
         EdgeBasedRoutingAlgorithmTest.initGraph(graph);
-        OSMReader osmReader = new OSMReader(graph)
-        {
+        OSMReader osmReader = new OSMReader(graph) {
 
             @Override
-            public int getInternalNodeIdOfOsmNode( long nodeOsmId )
-            {
+            public int getInternalNodeIdOfOsmNode(Long nodeOsmId) {
                 return osmNodeToInternal.get(nodeOsmId);
             }
 
             @Override
-            public long getOsmIdOfInternalEdge( int edgeId )
-            {
+            public Long getOsmIdOfInternalEdge(int edgeId) {
                 Long l = internalToOSMEdge.get(edgeId);
-                if(l == null)
-                    return -1;
+                if (l == null)
+                    return -1L;
                 return l;
             }
         };
@@ -75,8 +76,9 @@ public long getOsmIdOfInternalEdge( int edgeId )
 
         // TYPE == ONLY
         OSMTurnRelation instance = new OSMTurnRelation(4, 3, 3, Type.ONLY);
-        Collection<ITurnCostTableEntry> result
-                = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+        Collection<ITurnCostTableEntry> result = instance
+                .getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer,
+                        osmReader);
 
         assertEquals(2, result.size());
         Iterator<ITurnCostTableEntry> iter = result.iterator();
@@ -84,23 +86,23 @@ public long getOsmIdOfInternalEdge( int edgeId )
         assertEquals(4, entry.getEdgeFrom());
         assertEquals(6, entry.getEdgeTo());
         assertEquals(3, entry.getVia());
-        
+
         entry = iter.next();
         assertEquals(4, entry.getEdgeFrom());
         assertEquals(2, entry.getEdgeTo());
         assertEquals(3, entry.getVia());
-        
-        
+
         // TYPE == NOT
         instance = new OSMTurnRelation(4, 3, 3, Type.NOT);
-        result = instance.getRestrictionAsEntries(encoder, edgeExplorer, edgeExplorer, osmReader);
+        result = instance.getRestrictionAsEntries(encoder, edgeExplorer,
+                edgeExplorer, osmReader);
 
         assertEquals(1, result.size());
         iter = result.iterator();
         entry = iter.next();
         assertEquals(4, entry.getEdgeFrom());
         assertEquals(3, entry.getEdgeTo());
-        assertEquals(3, entry.getVia());       
+        assertEquals(3, entry.getVia());
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java
index c24a072320..08b114469d 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java
@@ -19,7 +19,6 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.FootFlagEncoder;
-import com.graphhopper.routing.util.RelationCarFlagEncoder;
 import com.graphhopper.storage.ExtendedStorage;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.RAMDirectory;
@@ -33,10 +32,10 @@
     // EncodingManager("CAR");//"car:com.graphhopper.routing.util.RelationCarFlagEncoder");
     protected CarFlagEncoder carEncoder;// = (RelationCarFlagEncoder)
     protected BusFlagEncoder busEncoder;// = (RelationCarFlagEncoder)
-      // encodingManager
-// .getEncoder("CAR");
+    // encodingManager
+    // .getEncoder("CAR");
     protected EdgeFilter carOutEdges;// = new DefaultEdgeFilter(
-// carEncoder, false, true);
+    // carEncoder, false, true);
     protected EdgeFilter carInEdges;
     protected boolean turnCosts = true;
     protected EdgeExplorer carOutExplorer;
@@ -44,57 +43,60 @@
     protected BikeFlagEncoder bikeEncoder;
     protected FootFlagEncoder footEncoder;
 
-    //RoadNode 880
+    // RoadNode 880
     protected static double node0Lat = 50.6992070044d;
     protected static double node0Lon = -3.55893724720532d;
 
-    //RoadNode 881
+    // RoadNode 881
     protected static double node1Lat = 50.6972276414d;
     protected static double node1Lon = -3.70047108174d;
 
-    //RoadNode 882
+    // RoadNode 882
     protected static double node2Lat = 50.6950765311d;
     protected static double node2Lon = -3.84198830979d;
 
-    //RoadNode 883
+    // RoadNode 883
     protected static double node3Lat = 50.6522837438d;
     protected static double node3Lon = -3.69884731399d;
 
-    //RoadNode 884
+    // RoadNode 884
     protected static double node4Lat = 50.7421711523d;
     protected static double node4Lon = -3.70209900111d;
-    
+
     @Before
     public void initEncoding() {
         if (turnCosts) {
             carEncoder = new CarFlagEncoder(5, 5, 3);
             busEncoder = new BusFlagEncoder(5, 5, 3);
-//            carEncoder = new RelationCarFlagEncoder(5, 5, 3);
+            // carEncoder = new RelationCarFlagEncoder(5, 5, 3);
             bikeEncoder = new BikeFlagEncoder(4, 2, 3);
         } else {
             carEncoder = new CarFlagEncoder();
             busEncoder = new BusFlagEncoder();
-//            carEncoder = new RelationCarFlagEncoder();
+            // carEncoder = new RelationCarFlagEncoder();
             bikeEncoder = new BikeFlagEncoder();
         }
 
         footEncoder = new FootFlagEncoder();
         carOutEdges = new DefaultEdgeFilter(carEncoder, false, true);
-        carInEdges  = new DefaultEdgeFilter(carEncoder, true, false);
-//        encodingManager = new EncodingManager(footEncoder, carEncoder, bikeEncoder);
+        carInEdges = new DefaultEdgeFilter(carEncoder, true, false);
+        // encodingManager = new EncodingManager(footEncoder, carEncoder,
+        // bikeEncoder);
         encodingManager = createEncodingManager();
-//        encodingManager = new EncodingManager("car|turnCosts=true");
+        // encodingManager = new EncodingManager("car|turnCosts=true");
     }
-    
+
     /**
      * So we can create a specific encoding manager in subclasses
+     * 
      * @return
      */
     protected EncodingManager createEncodingManager() {
         return new EncodingManager(footEncoder, carEncoder, bikeEncoder);
     }
-    
-    protected OsItnReader readGraphFile(GraphHopperStorage graph, File file) throws IOException {
+
+    protected OsItnReader readGraphFile(GraphHopperStorage graph, File file)
+            throws IOException {
         OsItnReader osItnReader = new OsItnReader(graph);
         System.out.println("Read " + file.getAbsolutePath());
         osItnReader.setOSMFile(file);
@@ -103,10 +105,13 @@ protected OsItnReader readGraphFile(GraphHopperStorage graph, File file) throws
         return osItnReader;
     }
 
-    protected GraphHopperStorage configureStorage(boolean turnRestrictionsImport, boolean is3D) {
+    protected GraphHopperStorage configureStorage(
+            boolean turnRestrictionsImport, boolean is3D) {
         String directory = "/tmp";
-        ExtendedStorage extendedStorage = turnRestrictionsImport ? new TurnCostStorage() : new ExtendedStorage.NoExtendedStorage();
-        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager, is3D, extendedStorage);
+        ExtendedStorage extendedStorage = turnRestrictionsImport ? new TurnCostStorage()
+                : new ExtendedStorage.NoExtendedStorage();
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(
+                directory, false), encodingManager, is3D, extendedStorage);
         return graph;
     }
 
@@ -129,6 +134,7 @@ protected void checkSimpleNodeNetwork(GraphHopperStorage graph) {
         assertEquals("BONHAY ROAD", iter.getName());
         assertFalse(iter.next());
     }
+
     protected int getEdge(int from, int to) {
         EdgeIterator iter = carOutExplorer.setBaseNode(from);
         while (iter.next()) {
@@ -138,27 +144,38 @@ protected int getEdge(int from, int to) {
         }
         return EdgeIterator.NO_EDGE;
     }
-    protected void evaluateRouting(final EdgeIterator iter, final int node, final boolean forward, final boolean backward, final boolean finished) {
+
+    protected void evaluateRouting(final EdgeIterator iter, final int node,
+            final boolean forward, final boolean backward,
+            final boolean finished) {
         evaluateRouting(iter, node, forward, backward, finished, carEncoder);
     }
-    protected void evaluateRouting(final EdgeIterator iter, final int node, final boolean forward, final boolean backward, final boolean finished, AbstractFlagEncoder flagEncoder) {
+
+    protected void evaluateRouting(final EdgeIterator iter, final int node,
+            final boolean forward, final boolean backward,
+            final boolean finished, AbstractFlagEncoder flagEncoder) {
         assertEquals("Incorrect adjacent node", node, iter.getAdjNode());
-        assertEquals("Incorrect forward instructions", forward, flagEncoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
-        assertEquals("Incorrect backward instructions", backward, flagEncoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertEquals("Incorrect forward instructions", forward,
+                flagEncoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertEquals("Incorrect backward instructions", backward,
+                flagEncoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
         assertEquals(!finished, iter.next());
     }
+
     protected void printNodes(EdgeExplorer outExplorer, int numNodes) {
         for (int i = 0; i < numNodes; i++) {
-//            logger.info("Node " + i + " " + count(outExplorer.setBaseNode(i)));
-            System.out.println("Node " + i + " " + count(outExplorer.setBaseNode(i)));
+            // logger.info("Node " + i + " " +
+            // count(outExplorer.setBaseNode(i)));
+            System.out.println("Node " + i + " "
+                    + count(outExplorer.setBaseNode(i)));
         }
 
-        EdgeIterator iter = null; 
+        EdgeIterator iter = null;
         for (int i = 0; i < numNodes; i++) {
             iter = outExplorer.setBaseNode(i);
             while (iter.next()) {
-//                logger.info(i+" Adj node is " + iter.getAdjNode());
-                System.out.println(i+" Adj node is " + iter.getAdjNode());
+                // logger.info(i+" Adj node is " + iter.getAdjNode());
+                System.out.println(i + " Adj node is " + iter.getAdjNode());
             }
         }
     }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
new file mode 100644
index 0000000000..66535dcf04
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
@@ -0,0 +1,155 @@
+package com.graphhopper.reader.osgb.dpn;
+
+import static com.graphhopper.util.GHUtility.count;
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.junit.Before;
+
+import com.graphhopper.routing.util.AbstractFlagEncoder;
+import com.graphhopper.routing.util.BikeFlagEncoder;
+import com.graphhopper.routing.util.BusFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.ExtendedStorage;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+
+public abstract class AbstractOsDpnReaderTest {
+
+    protected EncodingManager encodingManager;// = new
+    // EncodingManager("CAR");//"car:com.graphhopper.routing.util.RelationCarFlagEncoder");
+    protected CarFlagEncoder carEncoder;// = (RelationCarFlagEncoder)
+    protected BusFlagEncoder busEncoder;// = (RelationCarFlagEncoder)
+    // encodingManager
+    // .getEncoder("CAR");
+    protected EdgeFilter carOutEdges;// = new DefaultEdgeFilter(
+    // carEncoder, false, true);
+    protected EdgeFilter carInEdges;
+    protected boolean turnCosts = true;
+    protected EdgeExplorer carOutExplorer;
+    protected EdgeExplorer carAllExplorer;
+    protected BikeFlagEncoder bikeEncoder;
+    protected FootFlagEncoder footEncoder;
+
+    // RoadNode 880
+    protected static double node0Lat = 50.6992070044d;
+    protected static double node0Lon = -3.55893724720532d;
+
+    // RoadNode 881
+    protected static double node1Lat = 50.6972276414d;
+    protected static double node1Lon = -3.70047108174d;
+
+    // RoadNode 882
+    protected static double node2Lat = 50.6950765311d;
+    protected static double node2Lon = -3.84198830979d;
+
+    // RoadNode 883
+    protected static double node3Lat = 50.6522837438d;
+    protected static double node3Lon = -3.69884731399d;
+
+    // RoadNode 884
+    protected static double node4Lat = 50.7421711523d;
+    protected static double node4Lon = -3.70209900111d;
+
+    @Before
+    public void initEncoding() {
+        if (turnCosts) {
+            carEncoder = new CarFlagEncoder(5, 5, 3);
+            busEncoder = new BusFlagEncoder(5, 5, 3);
+            bikeEncoder = new BikeFlagEncoder(4, 2, 3);
+        } else {
+            carEncoder = new CarFlagEncoder();
+            busEncoder = new BusFlagEncoder();
+            bikeEncoder = new BikeFlagEncoder();
+        }
+
+        footEncoder = new FootFlagEncoder();
+        carOutEdges = new DefaultEdgeFilter(carEncoder, false, true);
+        carInEdges = new DefaultEdgeFilter(carEncoder, true, false);
+        encodingManager = createEncodingManager();
+    }
+
+    /**
+     * So we can create a specific encoding manager in subclasses
+     * 
+     * @return
+     */
+    protected EncodingManager createEncodingManager() {
+        return new EncodingManager(footEncoder, carEncoder, bikeEncoder);
+    }
+
+    protected OsDpnReader readGraphFile(GraphHopperStorage graph, File file)
+            throws IOException {
+        OsDpnReader osItnReader = new OsDpnReader(graph);
+        System.out.println("Read " + file.getAbsolutePath());
+        osItnReader.setOSMFile(file);
+        osItnReader.setEncodingManager(encodingManager);
+        osItnReader.readGraph();
+        return osItnReader;
+    }
+
+    protected GraphHopperStorage configureStorage(
+            boolean turnRestrictionsImport, boolean is3D) {
+        String directory = "/tmp";
+        ExtendedStorage extendedStorage = turnRestrictionsImport ? new TurnCostStorage()
+                : new ExtendedStorage.NoExtendedStorage();
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(
+                directory, false), encodingManager, is3D, extendedStorage);
+        return graph;
+    }
+
+    protected int getEdge(int from, int to) {
+        EdgeIterator iter = carOutExplorer.setBaseNode(from);
+        while (iter.next()) {
+            if (iter.getAdjNode() == to) {
+                return iter.getEdge();
+            }
+        }
+        return EdgeIterator.NO_EDGE;
+    }
+
+    protected void evaluateRouting(final EdgeIterator iter, final int node,
+            final boolean forward, final boolean backward,
+            final boolean finished) {
+        evaluateRouting(iter, node, forward, backward, finished, carEncoder);
+    }
+
+    protected void evaluateRouting(final EdgeIterator iter, final int node,
+            final boolean forward, final boolean backward,
+            final boolean finished, AbstractFlagEncoder flagEncoder) {
+        assertEquals("Incorrect adjacent node", node, iter.getAdjNode());
+        assertEquals("Incorrect forward instructions", forward,
+                flagEncoder.isBool(iter.getFlags(), FlagEncoder.K_FORWARD));
+        assertEquals("Incorrect backward instructions", backward,
+                flagEncoder.isBool(iter.getFlags(), FlagEncoder.K_BACKWARD));
+        assertEquals(!finished, iter.next());
+    }
+
+    protected void printNodes(EdgeExplorer outExplorer, int numNodes) {
+        for (int i = 0; i < numNodes; i++) {
+            // logger.info("Node " + i + " " +
+            // count(outExplorer.setBaseNode(i)));
+            System.out.println("Node " + i + " "
+                    + count(outExplorer.setBaseNode(i)));
+        }
+
+        EdgeIterator iter = null;
+        for (int i = 0; i < numNodes; i++) {
+            iter = outExplorer.setBaseNode(i);
+            while (iter.next()) {
+                // logger.info(i+" Adj node is " + iter.getAdjNode());
+                System.out.println(i + " Adj node is " + iter.getAdjNode());
+            }
+        }
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/dpn/OsDpnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/dpn/OsDpnReaderTest.java
new file mode 100644
index 0000000000..0f649b48b1
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/reader/osgb/dpn/OsDpnReaderTest.java
@@ -0,0 +1,31 @@
+package com.graphhopper.reader.osgb.dpn;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.junit.Test;
+
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.GHUtility;
+
+public class OsDpnReaderTest extends AbstractOsDpnReaderTest {
+
+    @Test
+    public void testReadDpnSample() throws IOException {
+        final boolean turnRestrictionsImport = true;
+        final boolean is3D = false;
+        final GraphHopperStorage graph = configureStorage(
+                turnRestrictionsImport, is3D);
+
+        final File file = new File(
+                "./src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml");
+        readGraphFile(graph, file);
+        GHUtility.printInfo(graph, 0, 30, EdgeFilter.ALL_EDGES);
+        carAllExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(
+                carEncoder, true, true));
+        printNodes(carAllExplorer, 30);
+    }
+
+}
diff --git a/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml
new file mode 100644
index 0000000000..74ae816596
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml
@@ -0,0 +1,200 @@
+<?xml version="1.0" encoding="UTF-8"?><gml:FeatureCollection xmlns:gml="http://www.opengis.net/gml/3.2" xsi:schemaLocation="http://namespaces.ordnancesurvey.co.uk/networks/detailedPathNetwork/1.0 detailedPathNetwork.xsd http://www.opengis.net/gml/3.2 gml/3.2.1/gml.xsd" gml:id="DPN" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:dpn="http://namespaces.ordnancesurvey.co.uk/networks/detailedPathNetwork/1.0" xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:gss="http://www.isotc211.org/2005/gss" xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gmlxbt="http://www.opengis.net/gml/3.3/xbt">
+  <gml:featureMember>
+    <dpn:RouteNode gml:id="osgbdf162dd8-c284-469b-81d6-d63105a39c7f">
+      <dpn:featureID>df162dd8-c284-469b-81d6-d63105a39c7f</dpn:featureID>
+      <dpn:versionID>1</dpn:versionID>
+      <dpn:versionDate>2014-12-12</dpn:versionDate>
+      <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
+      <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteNodeDescriptiveTermValue#Pseudo">Pseudo</dpn:descriptiveTerm>
+      <dpn:geometry>
+        <gml:Point srsName="urn:ogc:def:crs:EPSG::7405" gml:id="LOCAL_ID_0">
+          <gml:pos>427974.346 380503.251 362.62</gml:pos>
+        </gml:Point>
+      </dpn:geometry>
+    </dpn:RouteNode>
+  </gml:featureMember>
+  <gml:featureMember>
+    <dpn:RouteNode gml:id="osgb2357d994-6688-44b1-8769-6466ffdd69dd">
+      <dpn:featureID>2357d994-6688-44b1-8769-6466ffdd69dd</dpn:featureID>
+      <dpn:versionID>1</dpn:versionID>
+      <dpn:versionDate>2014-12-12</dpn:versionDate>
+      <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
+      <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteNodeDescriptiveTermValue#Junction">Junction</dpn:descriptiveTerm>
+      <dpn:geometry>
+        <gml:Point srsName="urn:ogc:def:crs:EPSG::7405" gml:id="LOCAL_ID_1">
+          <gml:pos>427006.894 380515.857000001 370.2</gml:pos>
+        </gml:Point>
+      </dpn:geometry>
+    </dpn:RouteNode>
+  </gml:featureMember>
+  <gml:featureMember>
+    <dpn:RouteNode gml:id="osgba1d8f9ca-33f8-4875-bd61-fa9097c44e4c">
+      <dpn:featureID>a1d8f9ca-33f8-4875-bd61-fa9097c44e4c</dpn:featureID>
+      <dpn:versionID>1</dpn:versionID>
+      <dpn:versionDate>2014-12-12</dpn:versionDate>
+      <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
+      <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteNodeDescriptiveTermValue#Junction">Junction</dpn:descriptiveTerm>
+      <dpn:geometry>
+        <gml:Point srsName="urn:ogc:def:crs:EPSG::7405" gml:id="LOCAL_ID_2">
+          <gml:pos>427587.116 380549.403999999 382.11</gml:pos>
+        </gml:Point>
+      </dpn:geometry>
+    </dpn:RouteNode>
+  </gml:featureMember>
+  <gml:featureMember>
+    <dpn:RouteNode gml:id="osgb39e9eba8-4500-44cb-88c8-4f450bf7da14">
+      <dpn:featureID>39e9eba8-4500-44cb-88c8-4f450bf7da14</dpn:featureID>
+      <dpn:versionID>1</dpn:versionID>
+      <dpn:versionDate>2014-12-12</dpn:versionDate>
+      <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
+      <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteNodeDescriptiveTermValue#Junction">Junction</dpn:descriptiveTerm>
+      <dpn:geometry>
+        <gml:Point srsName="urn:ogc:def:crs:EPSG::7405" gml:id="LOCAL_ID_3">
+          <gml:pos>427759.043 380573.641000001 375.8</gml:pos>
+        </gml:Point>
+      </dpn:geometry>
+    </dpn:RouteNode>
+  </gml:featureMember>
+  <gml:featureMember>
+    <dpn:RouteNode gml:id="osgb56dc4c0b-0586-4849-b3e2-1e00ee149429">
+      <dpn:featureID>56dc4c0b-0586-4849-b3e2-1e00ee149429</dpn:featureID>
+      <dpn:versionID>1</dpn:versionID>
+      <dpn:versionDate>2014-12-12</dpn:versionDate>
+      <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
+      <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteNodeDescriptiveTermValue#Junction">Junction</dpn:descriptiveTerm>
+      <dpn:geometry>
+        <gml:Point srsName="urn:ogc:def:crs:EPSG::7405" gml:id="LOCAL_ID_4">
+          <gml:pos>427272.14 380580.807 379.03</gml:pos>
+        </gml:Point>
+      </dpn:geometry>
+    </dpn:RouteNode>
+  </gml:featureMember>
+  <gml:featureMember>
+    <dpn:RouteLink gml:id="osgb35cff694-c2a8-461e-9540-730e3ae11a7a">
+      <dpn:featureID>35cff694-c2a8-461e-9540-730e3ae11a7a</dpn:featureID>
+      <dpn:versionID>1</dpn:versionID>
+      <dpn:versionDate>2014-12-12</dpn:versionDate>
+      <dpn:startNode xlink:href="#df162dd8-c284-469b-81d6-d63105a39c7f"/>
+      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
+      <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
+      <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#Unmade">Unmade</dpn:surfaceType>
+      <dpn:physicalLevel codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/LevelCodeValue#SurfaceLevel">Surface Level</dpn:physicalLevel>
+      <dpn:adoptedByNationalCycleRoute>false</dpn:adoptedByNationalCycleRoute>
+      <dpn:adoptedByRecreationalRoute>false</dpn:adoptedByRecreationalRoute>
+      <dpn:adoptedByOtherCycleRoute>false</dpn:adoptedByOtherCycleRoute>
+      <dpn:withinAccessLand>true</dpn:withinAccessLand>
+      <dpn:crossesDangerArea>false</dpn:crossesDangerArea>
+      <dpn:verticalGain>
+        <dpn:VerticalGainType>
+          <dpn:inDirection uom="m">9</dpn:inDirection>
+          <dpn:againstDirection uom="m">2</dpn:againstDirection>
+        </dpn:VerticalGainType>
+      </dpn:verticalGain>
+      <dpn:planimetricLength uom="m">85</dpn:planimetricLength>
+      <dpn:surfaceLength uom="m">86</dpn:surfaceLength>
+      <dpn:geometry>
+        <gml:LineString srsName="urn:ogc:def:crs:EPSG::7405" gml:id="LOCAL_ID_29519">
+          <gml:posList srsDimension="3" count="10">428672.241 380372.608999999 299.7 428653.822 380372.229 302.5 428647.49 380373.239 303.29 428645.296 380374.958000001 303.36 428638.156 380386.505000001 302.3 428635.625 380389.073999999 301.89 428631.214 380390.913000001 301.39 428628.625 380390.854 301.44 428622.598 380388.684 302.44 428598.489 380377.006999999 306.36</gml:posList>
+        </gml:LineString>
+      </dpn:geometry>
+    </dpn:RouteLink>
+  </gml:featureMember>
+  <gml:featureMember>
+    <dpn:RouteLink gml:id="osgb34dd4b18-ade0-48ea-9a34-e567107bd061">
+      <dpn:featureID>34dd4b18-ade0-48ea-9a34-e567107bd061</dpn:featureID>
+      <dpn:versionID>1</dpn:versionID>
+      <dpn:versionDate>2014-12-12</dpn:versionDate>
+      <dpn:startNode xlink:href="#2357d994-6688-44b1-8769-6466ffdd69dd"/>
+      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
+      <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#Cableway">Cableway</dpn:descriptiveTerm>
+      <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#"/>
+      <dpn:physicalLevel codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/LevelCodeValue#SurfaceLevel">Surface Level</dpn:physicalLevel>
+      <dpn:rightOfUse codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RightOfWayValue#Footpath">Footpath</dpn:rightOfUse>
+      <dpn:adoptedByNationalCycleRoute>false</dpn:adoptedByNationalCycleRoute>
+      <dpn:adoptedByRecreationalRoute>false</dpn:adoptedByRecreationalRoute>
+      <dpn:adoptedByOtherCycleRoute>false</dpn:adoptedByOtherCycleRoute>
+      <dpn:withinAccessLand>true</dpn:withinAccessLand>
+      <dpn:crossesDangerArea>false</dpn:crossesDangerArea>
+      <dpn:verticalGain>
+        <dpn:VerticalGainType>
+          <dpn:inDirection uom="m">0</dpn:inDirection>
+          <dpn:againstDirection uom="m">13</dpn:againstDirection>
+        </dpn:VerticalGainType>
+      </dpn:verticalGain>
+      <dpn:planimetricLength uom="m">146</dpn:planimetricLength>
+      <dpn:surfaceLength uom="m">146</dpn:surfaceLength>
+      <dpn:geometry>
+        <gml:LineString srsName="urn:ogc:def:crs:EPSG::7405" gml:id="LOCAL_ID_29520">
+          <gml:posList srsDimension="3" count="7">428599.756 379896.501 328.75 428601.06 379899.210999999 328.64 428607.078 379918.685000001 328.36 428614.969 379924.207 327.59 428645.017 379945.234999999 323.68 428705.048 379981.904999999 315.9 428709.584 379985.062999999 315.34</gml:posList>
+        </gml:LineString>
+      </dpn:geometry>
+    </dpn:RouteLink>
+  </gml:featureMember>
+  <gml:featureMember>
+    <dpn:RouteLink gml:id="osgb016c1a07-6bfa-4e52-91f2-d894a6873313">
+      <dpn:featureID>016c1a07-6bfa-4e52-91f2-d894a6873313</dpn:featureID>
+      <dpn:versionID>1</dpn:versionID>
+      <dpn:versionDate>2014-12-12</dpn:versionDate>
+      <dpn:startNode xlink:href="#a1d8f9ca-33f8-4875-bd61-fa9097c44e4c"/>
+      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
+      <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
+      <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#Unmade">Unmade</dpn:surfaceType>
+      <dpn:physicalLevel codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/LevelCodeValue#SurfaceLevel">Surface Level</dpn:physicalLevel>
+      <dpn:rightOfUse codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RightOfWayValue#Bridleway">Bridleway</dpn:rightOfUse>
+      <dpn:adoptedByNationalCycleRoute>false</dpn:adoptedByNationalCycleRoute>
+      <dpn:adoptedByRecreationalRoute>false</dpn:adoptedByRecreationalRoute>
+      <dpn:adoptedByOtherCycleRoute>false</dpn:adoptedByOtherCycleRoute>
+      <dpn:withinAccessLand>true</dpn:withinAccessLand>
+      <dpn:crossesDangerArea>false</dpn:crossesDangerArea>
+      <dpn:verticalGain>
+        <dpn:VerticalGainType>
+          <dpn:inDirection uom="m">9</dpn:inDirection>
+          <dpn:againstDirection uom="m">0</dpn:againstDirection>
+        </dpn:VerticalGainType>
+      </dpn:verticalGain>
+      <dpn:planimetricLength uom="m">87</dpn:planimetricLength>
+      <dpn:surfaceLength uom="m">88</dpn:surfaceLength>
+      <dpn:geometry>
+        <gml:LineString srsName="urn:ogc:def:crs:EPSG::7405" gml:id="LOCAL_ID_29521">
+          <gml:posList srsDimension="3" count="3">428671.969 379945.721000001 319.83 428657.598 379936.514 321.96 428599.756 379896.501 328.75</gml:posList>
+        </gml:LineString>
+      </dpn:geometry>
+    </dpn:RouteLink>
+  </gml:featureMember>
+  <gml:featureMember>
+    <dpn:RouteLink gml:id="osgbcc33c9f4-ff8e-41fb-86b3-3fd9daa8a6e0">
+      <dpn:featureID>cc33c9f4-ff8e-41fb-86b3-3fd9daa8a6e0</dpn:featureID>
+      <dpn:versionID>1</dpn:versionID>
+      <dpn:versionDate>2014-12-12</dpn:versionDate>
+      <dpn:startNode xlink:href="#39e9eba8-4500-44cb-88c8-4f450bf7da14"/>
+      <dpn:endNode xlink:href="#56dc4c0b-0586-4849-b3e2-1e00ee149429"/>
+      <dpn:descriptiveGroup codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteDescriptiveGroupValue#NonMotorisedVehicularRouteNetwork">Non Motorised Vehicular Route Network</dpn:descriptiveGroup>
+      <dpn:descriptiveTerm codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RouteLinkDescriptiveTermValue#NoPhysicalManifestation">No Physical Manifestation</dpn:descriptiveTerm>
+      <dpn:surfaceType codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/SurfaceTypeValue#Unmade">Unmade</dpn:surfaceType>
+      <dpn:physicalLevel codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/LevelCodeValue#SurfaceLevel">Surface Level</dpn:physicalLevel>
+      <dpn:rightOfUse codeSpace="http://www.ordnancesurvey.co.uk/xml/codelists/RightOfWayValue#Bridleway">Bridleway</dpn:rightOfUse>
+      <dpn:adoptedByNationalCycleRoute>false</dpn:adoptedByNationalCycleRoute>
+      <dpn:adoptedByRecreationalRoute>false</dpn:adoptedByRecreationalRoute>
+      <dpn:adoptedByOtherCycleRoute>false</dpn:adoptedByOtherCycleRoute>
+      <dpn:withinAccessLand>true</dpn:withinAccessLand>
+      <dpn:crossesDangerArea>false</dpn:crossesDangerArea>
+      <dpn:potentialHazardCrossed>Boulders</dpn:potentialHazardCrossed>
+      <dpn:verticalGain>
+        <dpn:VerticalGainType>
+          <dpn:inDirection uom="m">7</dpn:inDirection>
+          <dpn:againstDirection uom="m">0</dpn:againstDirection>
+        </dpn:VerticalGainType>
+      </dpn:verticalGain>
+      <dpn:planimetricLength uom="m">61</dpn:planimetricLength>
+      <dpn:surfaceLength uom="m">62</dpn:surfaceLength>
+      <dpn:geometry>
+        <gml:LineString srsName="urn:ogc:def:crs:EPSG::7405" gml:id="LOCAL_ID_29522">
+          <gml:posList srsDimension="3" count="3">428725.224 379975.602 312.5 428698.988 379962.476 316.06 428671.969 379945.721000001 319.83</gml:posList>
+        </gml:LineString>
+      </dpn:geometry>
+    </dpn:RouteLink>
+  </gml:featureMember>
+</gml:FeatureCollection>
