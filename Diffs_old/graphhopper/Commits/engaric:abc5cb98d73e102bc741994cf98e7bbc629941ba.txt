diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
index 96273a8d83..ec01d532ec 100644
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -69,5 +69,7 @@ protected void configureServlets()
         	serve("/update*").with(UpdateServlet.class);
         	bind(UpdateServlet.class).in(Singleton.class);
         }
+        serve("/nearest*").with(NearestServlet.class);
+        bind(NearestServlet.class).in(Singleton.class);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index e4dd2bc3f1..3c30178ff5 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -82,7 +82,9 @@ void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exc
         boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
         boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
         boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
-        boolean elevation = getBooleanParam(httpReq, "elevation", false);
+        boolean enableElevation = getBooleanParam(httpReq, "elevation", false);
+        boolean pointsEncoded = getBooleanParam(httpReq, "points_encoded", true);
+
         String vehicleStr = getParam(httpReq, "vehicle", "car");
         String weighting = getParam(httpReq, "weighting", "fastest");
         String algoStr = getParam(httpReq, "algorithm", "");
@@ -93,7 +95,7 @@ void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exc
         if (!hopper.getEncodingManager().supports(vehicleStr))
         {
             ghRsp = new GHResponse().addError(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
-        } else if (elevation && !hopper.hasElevation())
+        } else if (enableElevation && !hopper.hasElevation())
         {
             ghRsp = new GHResponse().addError(new IllegalArgumentException("Elevation not supported!"));
         } else
@@ -123,13 +125,22 @@ void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exc
             logger.error(logStr + ", errors:" + ghRsp.getErrors());
         else
             logger.info(logStr + ", distance: " + ghRsp.getDistance()
-                    + ", time:" + Math.round(ghRsp.getMillis() / 60000f)
+                    + ", time:" + Math.round(ghRsp.getTime() / 60000f)
                     + "min, points:" + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
 
         if (writeGPX)
+        {
             writeResponse(res, createGPXString(httpReq, res, ghRsp));
-        else
-            writeJson(httpReq, res, new JSONObject(createJson(httpReq, ghRsp, took)));
+        } else
+        {
+            Map<String, Object> map = createJson(ghRsp,
+                    calcPoints, pointsEncoded, enableElevation, enableInstructions);
+            Object infoMap = map.get("info");
+            if (infoMap != null)
+                ((Map) infoMap).put("took", Math.round(took * 1000));
+
+            writeJson(httpReq, res, new JSONObject(map));
+        }
     }
 
     protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
@@ -140,12 +151,11 @@ protected String createGPXString( HttpServletRequest req, HttpServletResponse re
         res.setContentType("application/xml");
         String trackName = getParam(req, "track", "GraphHopper Track");
         res.setHeader("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
-        String timeZone = getParam(req, "timezone", "GMT");
         long time = getLongParam(req, "millis", System.currentTimeMillis());
         if (rsp.hasErrors())
             return errorsToXML(rsp.getErrors());
         else
-            return rsp.getInstructions().createGPX(trackName, time, timeZone, includeElevation);
+            return rsp.getInstructions().createGPX(trackName, time, includeElevation);
     }
 
     String errorsToXML( List<Throwable> list ) throws Exception
@@ -178,12 +188,12 @@ String errorsToXML( List<Throwable> list ) throws Exception
         return writer.toString();
     }
 
-    protected Map<String, Object> createJson( HttpServletRequest req, GHResponse rsp, float took )
+    protected Map<String, Object> createJson( GHResponse rsp,
+            boolean calcPoints,
+            boolean pointsEncoded,
+            boolean includeElevation,
+            boolean enableInstructions )
     {
-        boolean enableInstructions = getBooleanParam(req, "instructions", true);
-        boolean pointsEncoded = getBooleanParam(req, "points_encoded", true);
-        boolean calcPoints = getBooleanParam(req, "calc_points", true);
-        boolean includeElevation = getBooleanParam(req, "elevation", false);
         Map<String, Object> json = new HashMap<String, Object>();
         Map<String, Object> jsonInfo = new HashMap<String, Object>();
         json.put("info", jsonInfo);
@@ -202,11 +212,10 @@ String errorsToXML( List<Throwable> list ) throws Exception
             jsonInfo.put("errors", list);
         } else
         {
-            jsonInfo.put("took", Math.round(took * 1000));
             Map<String, Object> jsonPath = new HashMap<String, Object>();
             jsonPath.put("distance", Helper.round(rsp.getDistance(), 3));
             jsonPath.put("weight", Helper.round6(rsp.getDistance()));
-            jsonPath.put("time", rsp.getMillis());
+            jsonPath.put("time", rsp.getTime());
 
             if (calcPoints)
             {
@@ -244,7 +253,7 @@ protected Object createPoints( PointList points, boolean pointsEncoded, boolean
         return jsonPoints;
     }
 
-    protected List<GHPoint> getPoints( HttpServletRequest req, String key ) throws IOException
+    protected List<GHPoint> getPoints( HttpServletRequest req, String key )
     {
         String[] pointsAsStr = getParams(req, key);
         final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 0e9b5e951d..5d0e60d8e0 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -22,6 +22,7 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import java.util.List;
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -36,7 +37,7 @@
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private Downloader downloader = new Downloader("GraphHopper Java Client");
-    private String serviceUrl = "https://graphhopper.com/api/1/route";
+    private String routeServiceUrl = "https://graphhopper.com/api/1/route";
     private String key = "";
     private boolean instructions = true;
     private boolean calcPoints = true;
@@ -54,7 +55,7 @@ public void setDownloader( Downloader downloader )
     @Override
     public boolean load( String serviceUrl )
     {
-        this.serviceUrl = serviceUrl;
+        this.routeServiceUrl = serviceUrl;
         return true;
     }
 
@@ -108,7 +109,7 @@ public GHResponse route( GHRequest request )
             boolean tmpElevation = request.getHints().getBool("elevation", elevation);
             String tmpKey = request.getHints().get("key", key);
 
-            String url = serviceUrl
+            String url = routeServiceUrl
                     + "?"
                     + places
                     + "&type=json"
@@ -127,115 +128,138 @@ public GHResponse route( GHRequest request )
 
             String str = downloader.downloadAsString(url);
             JSONObject json = new JSONObject(str);
+
+            if (json.has("message"))
+                throw new RuntimeException(json.getString("message") + ", code:" + json.getInt("code"));
+
             GHResponse res = new GHResponse();
 
             if (json.getJSONObject("info").has("errors"))
             {
                 JSONArray errors = json.getJSONObject("info").getJSONArray("errors");
+                readErrors(res.getErrors(), errors);
+                return res;
 
-                for (int i = 0; i < errors.length(); i++)
+            } else
+            {
+                took = json.getJSONObject("info").getDouble("took");
+                JSONArray paths = json.getJSONArray("paths");
+                JSONObject firstPath = paths.getJSONObject(0);
+                readPath(res, firstPath, tmpCalcPoints, tmpInstructions, tmpElevation);
+                return res;
+            }
+        } catch (Exception ex)
+        {
+            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
+        } finally
+        {
+            logger.debug("Full request took:" + sw.stop().getSeconds() + ", API took:" + took);
+        }
+    }
+
+    public static void readPath( GHResponse res, JSONObject firstPath,
+            boolean tmpCalcPoints,
+            boolean tmpInstructions,
+            boolean tmpElevation )
+    {
+        double distance = firstPath.getDouble("distance");
+        long time = firstPath.getLong("time");
+        if (tmpCalcPoints)
+        {
+            String pointStr = firstPath.getString("points");
+            PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
+            res.setPoints(pointList);
+
+            if (tmpInstructions)
+            {
+                JSONArray instrArr = firstPath.getJSONArray("instructions");
+
+                InstructionList il = new InstructionList(null);
+                int viaCount = 1;
+                for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
                 {
-                    JSONObject error = errors.getJSONObject(i);
-                    String exClass = error.getString("details");
-                    String exMessage = error.getString("message");
+                    JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
+                    double instDist = jsonObj.getDouble("distance");
+                    String text = jsonObj.getString("text");
+                    long instTime = jsonObj.getLong("time");
+                    int sign = jsonObj.getInt("sign");
+                    JSONArray iv = jsonObj.getJSONArray("interval");
+                    int from = iv.getInt(0);
+                    int to = iv.getInt(1);
+                    PointList instPL = new PointList(to - from, tmpElevation);
+                    for (int j = from; j <= to; j++)
+                    {
+                        instPL.add(pointList, j);
+                    }
 
-                    if (exClass.equals(UnsupportedOperationException.class.getName()))
+                    InstructionAnnotation ia = InstructionAnnotation.EMPTY;
+                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text"))
                     {
-                        res.addError(new UnsupportedOperationException(exMessage));
-                    } else if (exClass.equals(IllegalStateException.class.getName()))
+                        ia = new InstructionAnnotation(jsonObj.getInt("annotation_importance"), jsonObj.getString("annotation_text"));
+                    }
+
+                    Instruction instr;
+                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT)
                     {
-                        res.addError(new IllegalStateException(exMessage));
-                    } else if (exClass.equals(RuntimeException.class.getName()))
+                        instr = new RoundaboutInstruction(sign, text, ia, instPL);
+                    } else if (sign == Instruction.REACHED_VIA)
                     {
-                        res.addError(new RuntimeException(exMessage));
-                    } else if (exClass.equals(IllegalArgumentException.class.getName()))
+                        ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
+                        tmpInstr.setViaCount(viaCount);
+                        viaCount++;
+                        instr = tmpInstr;
+                    } else if (sign == Instruction.FINISH)
                     {
-                        res.addError(new IllegalArgumentException(exMessage));
+                        instr = new FinishInstruction(instPL, 0);
                     } else
                     {
-                        res.addError(new Exception(exClass + " " + exMessage));
+                        instr = new Instruction(sign, text, ia, instPL);
                     }
+
+                    // The translation is done from the routing service so just use the provided string
+                    // instead of creating a combination with sign and name etc
+                    instr.setUseRawName();
+
+                    instr.setDistance(instDist).setTime(instTime);
+                    il.add(instr);
                 }
+                res.setInstructions(il);
+            }
+        }
+        res.setDistance(distance).setTime(time);
+    }
 
-                return res;
+    public static void readErrors( List<Throwable> errors, JSONArray errorJson )
+    {
+        for (int i = 0; i < errorJson.length(); i++)
+        {
+            JSONObject error = errorJson.getJSONObject(i);
+            String exClass = "";
+            if (error.has("details"))
+            {
+                exClass = error.getString("details");
+            }
+            String exMessage = error.getString("message");
 
+            if (exClass.equals(UnsupportedOperationException.class.getName()))
+            {
+                errors.add(new UnsupportedOperationException(exMessage));
+            } else if (exClass.equals(IllegalStateException.class.getName()))
+            {
+                errors.add(new IllegalStateException(exMessage));
+            } else if (exClass.equals(RuntimeException.class.getName()))
+            {
+                errors.add(new RuntimeException(exMessage));
+            } else if (exClass.equals(IllegalArgumentException.class.getName()))
+            {
+                errors.add(new IllegalArgumentException(exMessage));
+            } else if (exClass.isEmpty())
+            {
+                errors.add(new Exception(exMessage));
             } else
             {
-                took = json.getJSONObject("info").getDouble("took");
-                JSONArray paths = json.getJSONArray("paths");
-                JSONObject firstPath = paths.getJSONObject(0);
-                double distance = firstPath.getDouble("distance");
-                int time = firstPath.getInt("time");
-                if (tmpCalcPoints)
-                {
-                    String pointStr = firstPath.getString("points");
-                    PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
-                    res.setPoints(pointList);
-
-                    if (tmpInstructions)
-                    {
-                        JSONArray instrArr = firstPath.getJSONArray("instructions");
-
-                        InstructionList il = new InstructionList(null);
-                        int viaCount = 1;
-                        for (int instrIndex = 0; instrIndex < instrArr.length(); instrIndex++)
-                        {
-                            JSONObject jsonObj = instrArr.getJSONObject(instrIndex);
-                            double instDist = jsonObj.getDouble("distance");
-                            String text = jsonObj.getString("text");
-                            long instTime = jsonObj.getLong("time");
-                            int sign = jsonObj.getInt("sign");
-                            JSONArray iv = jsonObj.getJSONArray("interval");
-                            int from = iv.getInt(0);
-                            int to = iv.getInt(1);
-                            PointList instPL = new PointList(to - from, tmpElevation);
-                            for (int j = from; j <= to; j++)
-                            {
-                                instPL.add(pointList, j);
-                            }
-
-                            InstructionAnnotation ia = InstructionAnnotation.EMPTY;
-                            if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text"))
-                            {
-                                ia = new InstructionAnnotation(jsonObj.getInt("annotation_importance"), jsonObj.getString("annotation_text"));
-                            }
-
-                            Instruction instr;
-                            if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT)
-                            {
-                                instr = new RoundaboutInstruction(sign, text, ia, instPL);
-                            } else if (sign == Instruction.REACHED_VIA)
-                            {
-                                ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
-                                tmpInstr.setViaCount(viaCount);
-                                viaCount++;
-                                instr = tmpInstr;
-                            } else if (sign == Instruction.FINISH)
-                            {
-                                instr = new FinishInstruction(instPL, 0);
-                            } else
-                            {
-                                instr = new Instruction(sign, text, ia, instPL);
-                            }
-
-                            // The translation is done from the routing service so just use the provided string
-                            // instead of creating a combination with sign and name etc
-                            instr.setUseRawName();
-
-                            instr.setDistance(instDist).setTime(instTime);
-                            il.add(instr);
-                        }
-                        res.setInstructions(il);
-                    }
-                }
-                return res.setDistance(distance).setMillis(time);
+                errors.add(new Exception(exClass + " " + exMessage));
             }
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
-        } finally
-        {
-            logger.debug("Full request took:" + sw.stop().getSeconds() + ", API took:" + took);
         }
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/NearestServlet.java b/web/src/main/java/com/graphhopper/http/NearestServlet.java
new file mode 100644
index 0000000000..0fcb4eaa3a
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/NearestServlet.java
@@ -0,0 +1,105 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
+import java.io.IOException;
+import javax.inject.Inject;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+/**
+ * @author svantulden
+ */
+public class NearestServlet extends GHBaseServlet
+{
+    @Inject
+    private GraphHopper hopper;
+
+    @Override
+    public void doGet( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
+    {
+        try
+        {
+            writeNearest(req, res);
+        } catch (IllegalArgumentException ex)
+        {
+            writeError(res, SC_BAD_REQUEST, ex.getMessage());
+        } catch (Exception ex)
+        {
+            logger.error("Error while executing request: " + req.getQueryString(), ex);
+            writeError(res, SC_INTERNAL_SERVER_ERROR, "Problem occured:" + ex.getMessage());
+        }
+    }
+
+    void writeNearest( HttpServletRequest req, HttpServletResponse res ) throws Exception
+    {
+        String pointStr = getParam(req, "point", null);
+        boolean enableElevation = getBooleanParam(req, "elevation", false);
+        
+        JSONObject result = new JSONObject();
+        if (pointStr != null && !pointStr.equalsIgnoreCase("")) {
+            GHPoint place = GHPoint.parse(pointStr);
+            
+            LocationIndex index = hopper.getLocationIndex();
+            QueryResult qr = index.findClosest( place.lat, place.lon, EdgeFilter.ALL_EDGES );
+            
+            GHPoint3D snappedPoint = null;
+            try {
+                snappedPoint = qr.getSnappedPoint();
+            } catch (IllegalStateException ex) {
+                result.put("error", "Nearest point cannot be found!");
+            }
+            
+            if (snappedPoint != null) {
+                result.put("type", "Point");
+                
+                JSONArray coord = new JSONArray();
+                coord.put(snappedPoint.lon);
+                coord.put(snappedPoint.lat);
+                
+                if (hopper.hasElevation() && enableElevation) {
+                    coord.put(snappedPoint.ele);
+                }
+
+                result.put("coordinates", coord);
+                
+                DistanceCalcEarth calc = new DistanceCalcEarth();
+                double distance = calc.calcDist(place.lat, place.lon, snappedPoint.lat, snappedPoint.lon);
+                
+                // Distance from input to snapped point in meters
+                result.put("distance", distance);
+            }
+        } else {
+            result.put("error", "No lat/lon specified!");
+        }  
+        
+        writeJson(req, res, result);
+    }
+}
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index 30203034fe..41217c50de 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -335,6 +335,8 @@ GHRequest.prototype.init = function (params) {
         this.algorithm = params.algorithm;
     if (params.locale)
         this.locale = params.locale;
+    if (params.key)
+        this.key = params.key;
 
     if ('do_zoom' in params)
         this.do_zoom = params.do_zoom;
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index 3e7bf456c9..f483ad51d3 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -29,7 +29,7 @@ var defaultTranslationMap = null;
 var enTranslationMap = null;
 var routeSegmentPopup = null;
 var elevationControl = null;
-var activeLayer = 'Lyrk';
+var activeLayer = '';
 var i18nIsInitialized;
 
 var iconFrom = L.icon({
@@ -318,7 +318,12 @@ function initMap(selectLayer) {
         attribution: osmAttr + ', <a href="https://geodienste.lyrk.de/">Lyrk</a>',
         subdomains: ['a', 'b', 'c']
     });
-
+        
+    var omniscale = L.tileLayer.wms('https://maps.omniscale.net/v1/mapsgraph-bf48cc0b/tile', {
+            layers: 'osm',
+        attribution: osmAttr + ', &copy; <a href="http://maps.omniscale.com/">Omniscale</a>'
+    });
+            
     var mapquest = L.tileLayer('http://{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png', {
         attribution: osmAttr + ', <a href="http://open.mapquest.co.uk" target="_blank">MapQuest</a>',
         subdomains: ['otile1', 'otile2', 'otile3', 'otile4']
@@ -333,6 +338,15 @@ function initMap(selectLayer) {
         attribution: osmAttr + ', <a href="http://openmapsurfer.uni-hd.de/contact.html">GIScience Heidelberg</a>'
     });
 
+    // not an option as too fast over limit
+//    var mapbox= L.tileLayer('https://{s}.tiles.mapbox.com/v4/peterk.map-vkt0kusv/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoicGV0ZXJrIiwiYSI6IkdFc2FJd2MifQ.YUd7dS_gOpT3xrQnB8_K-w', {
+//        attribution: osmAttr + ', <a href="https://www.mapbox.com/about/maps/">&copy; MapBox</a>'
+//    });
+
+    var sorbianLang = L.tileLayer('http://map.dgpsonline.eu/osmsb/{z}/{x}/{y}.png', {
+        attribution: osmAttr + ', <a href="http://www.alberding.eu/">&copy; Alberding GmbH, CC-BY-SA</a>'
+    });
+
     var thunderTransport = L.tileLayer('http://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png', {
         attribution: osmAttr + ', <a href="http://www.thunderforest.com/transport/" target="_blank">Thunderforest Transport</a>',
         subdomains: ['a', 'b', 'c']
@@ -371,6 +385,7 @@ function initMap(selectLayer) {
 
     var baseMaps = {
         "Lyrk": lyrk,
+        "Omniscale" : omniscale,
         "MapQuest": mapquest,
         "MapQuest Aerial": mapquestAerial,
         "Esri Aerial": esriAerial,
@@ -380,7 +395,8 @@ function initMap(selectLayer) {
         "TF Outdoors": thunderOutdoors,
         "WanderReitKarte": wrk,
         "OpenStreetMap": osm,
-        "OpenStreetMap.de": osmde
+        "OpenStreetMap.de": osmde,
+        "Sorbian Language": sorbianLang
     };
 
     var defaultLayer = baseMaps[selectLayer];
@@ -457,8 +473,12 @@ function initMap(selectLayer) {
     L.control.layers(baseMaps/*, overlays*/).addTo(map);
 
     map.on('baselayerchange', function (a) {
-        if (a.name)
+        if (a.name) {
             activeLayer = a.name;
+            $("#export-link a").attr('href', function (i, v) {
+                return v.replace(/(layer=)([\w\s]+)/, '$1' + activeLayer);
+            });
+        }
     });
 
     L.control.scale().addTo(map);
diff --git a/web/src/test/java/com/graphhopper/http/BaseServletTester.java b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
index b1c47148fe..2669c2e3e9 100644
--- a/web/src/test/java/com/graphhopper/http/BaseServletTester.java
+++ b/web/src/test/java/com/graphhopper/http/BaseServletTester.java
@@ -95,12 +95,18 @@ public static void shutdownJetty( boolean force )
         server = null;
     }
 
-    protected String getTestAPIUrl()
+    protected String getTestRouteAPIUrl()
     {
         String host = "localhost";
         return "http://" + host + ":" + port + "/route";
     }
-
+    
+    protected String getTestNearestAPIUrl()
+    {
+        String host = "localhost";
+        return "http://" + host + ":" + port + "/nearest";
+    }
+    
     protected JSONObject query( String query ) throws Exception
     {
         String resQuery = "";
@@ -114,8 +120,26 @@ protected JSONObject query( String query ) throws Exception
 
             resQuery += "&";
         }
-        String url = getTestAPIUrl() + "?" + resQuery;
+        String url = getTestRouteAPIUrl() + "?" + resQuery;
+        Downloader downloader = new Downloader("web integration tester");
+        return new JSONObject(downloader.downloadAsString(url));
+    } 
+    
+    protected JSONObject nearestQuery( String query ) throws Exception
+    {
+        String resQuery = "";
+        for (String q : query.split("\\&"))
+        {
+            int index = q.indexOf("=");
+            if (index > 0)
+                resQuery += q.substring(0, index + 1) + WebHelper.encodeURL(q.substring(index + 1));
+            else
+                resQuery += WebHelper.encodeURL(q);
+
+            resQuery += "&";
+        }
+        String url = getTestNearestAPIUrl() + "?" + resQuery;
         Downloader downloader = new Downloader("web integration tester");
         return new JSONObject(downloader.downloadAsString(url));
-    }    
+    } 
 }
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
index 6f74987210..140ef8bc42 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletIT.java
@@ -89,7 +89,7 @@ public void testFailIfElevationRequestedButNotIncluded() throws Exception
     public void testGraphHopperWeb() throws Exception
     {
         GraphHopperAPI hopper = new GraphHopperWeb();
-        assertTrue(hopper.load(getTestAPIUrl()));
+        assertTrue(hopper.load(getTestRouteAPIUrl()));
         GHResponse rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128));
         assertTrue(rsp.getErrors().toString(), rsp.getErrors().isEmpty());
         assertTrue("distance wasn't correct:" + rsp.getDistance(), rsp.getDistance() > 9000);
@@ -116,7 +116,7 @@ public void testGraphHopperWebRealExceptions()
         Throwable ex;
 
         GraphHopperAPI hopper = new GraphHopperWeb();
-        assertTrue(hopper.load(getTestAPIUrl()));
+        assertTrue(hopper.load(getTestRouteAPIUrl()));
 
         // IllegalStateException (Wrong Request)
         rsp = hopper.route(new GHRequest());
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletIT.java b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
new file mode 100644
index 0000000000..74956eb9f6
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/NearestServletIT.java
@@ -0,0 +1,66 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import static com.graphhopper.http.BaseServletTester.shutdownJetty;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import java.io.File;
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ * @author svantulden
+ */
+public class NearestServletIT extends BaseServletTester
+{
+    private static final String dir = "./target/andorra-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
+
+    @Before
+    public void setUp()
+    {
+        CmdArgs args = new CmdArgs().
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/andorra.osm.pbf").
+                put("graph.location", dir);
+        setUpJetty(args);
+    }
+
+    @Test
+    public void testBasicNearestQuery() throws Exception
+    {
+        JSONObject json = nearestQuery("point=42.554851,1.536198");
+        assertFalse(json.has("error"));
+        JSONArray point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.length() == 2);
+        double lon = point.getDouble(0);
+        double lat = point.getDouble(1);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 42.55483907636756 && lon == 1.5363742288086868);
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
new file mode 100644
index 0000000000..d271db8457
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/NearestServletWithEleIT.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http;
+
+import static com.graphhopper.http.BaseServletTester.shutdownJetty;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import java.io.File;
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ * @author svantulden
+ */
+public class NearestServletWithEleIT extends BaseServletTester
+{
+    private static final String dir = "./target/monaco-gh/";
+
+    @AfterClass
+    public static void cleanUp()
+    {
+        Helper.removeDir(new File(dir));
+        shutdownJetty(true);
+    }
+
+    @Before
+    public void setUp()
+    {
+        CmdArgs args = new CmdArgs().
+                put("graph.elevation.provider", "srtm").
+                put("graph.elevation.cachedir", "../core/files/").
+                put("prepare.chWeighting", "no").
+                put("config", "../config-example.properties").
+                put("osmreader.osm", "../core/files/monaco.osm.gz").
+                put("graph.location", dir);
+        setUpJetty(args);
+    }
+
+    @Test
+    public void testWithEleQuery() throws Exception
+    {
+        JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=true");
+        assertFalse(json.has("error"));
+        JSONArray point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 3D: " + point, point.length() == 3);
+        double lon = point.getDouble(0);
+        double lat = point.getDouble(1);
+        double ele = point.getDouble(2);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon + ", ele=" + ele, lat == 43.73070006215647 && lon == 7.421392181993846 && ele == 66.0);
+    }
+    
+    @Test
+    public void testWithoutEleQuery() throws Exception
+    {
+        JSONObject json = nearestQuery("point=43.730864,7.420771&elevation=false");
+        assertFalse(json.has("error"));
+        JSONArray point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.length() == 2);
+        double lon = point.getDouble(0);
+        double lat = point.getDouble(1);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 43.73070006215647 && lon == 7.421392181993846);
+        
+        // Default elevation is false        
+        json = nearestQuery("point=43.730864,7.420771");
+        assertFalse(json.has("error"));
+        point = json.getJSONArray("coordinates");
+        assertTrue("returned point is not 2D: " + point, point.length() == 2);
+        lon = point.getDouble(0);
+        lat = point.getDouble(1);
+        assertTrue("nearest point wasn't correct: lat=" + lat + ", lon=" + lon, lat == 43.73070006215647 && lon == 7.421392181993846);
+    }
+}
