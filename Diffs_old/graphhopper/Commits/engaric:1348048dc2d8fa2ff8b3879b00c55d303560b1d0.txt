diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
index 200b80d358..b959293b50 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
@@ -343,6 +343,9 @@ public boolean isWayPointonRouteMap(String wayPointIndex,
 					wayPointDescription, avoidance);
 			break;
 		case "SERVICE":
+			
+			
+	
 			if (requestParameters.get("type").get(0).equals(
 					"gpx")) {
 				wp = buildWayPoint(wayPoint_Coordinates, wayPointDescription,
@@ -834,6 +837,25 @@ public void getRouteFromUI() {
 		String vehicle = requestParameters.get("vehicle").get(0);
 
 		ArrayList<String> points = requestParameters.get("point");
+		
+		if (!requestParameters.containsKey("type") )
+		{			
+			ArrayList<String> responseType = new ArrayList<String>();
+			responseType.add(IntegrationTestProperties
+					.getTestProperty("routeType"));
+			requestParameters.put("type",responseType);
+		
+		}
+		else
+			if (requestParameters.get("type").get(0).isEmpty()){
+		
+			requestParameters.remove("type");
+			ArrayList<String> responseType = new ArrayList<String>();
+			responseType.add(IntegrationTestProperties
+					.getTestProperty("routeType"));
+			requestParameters.put("type", responseType);
+			}
+		
 		switch (vehicle) {
 		case "car":
 			clickElement(ROUTE_TYPE_CAR);
@@ -947,6 +969,8 @@ public void getRouteFromUI() {
 		clickElement(ROUTE_SEARCH);
 
 		waitFor(INSTRUCTIONS);
+		
+		
 
 	}
 
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 21ffa3f9e6..f1d7256b66 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -60,6 +60,7 @@
 import com.graphhopper.routing.util.TurnWeighting;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.routing.util.WeightingMap;
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.storage.DAType;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.GHDirectory;
@@ -95,1069 +96,1081 @@
  * @author Peter Karich
  */
 public class GraphHopper implements GraphHopperAPI {
-    private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM, OSITN or OSDPN";
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    // for graph:
-    private GraphStorage graph;
-    private EncodingManager encodingManager;
-    private int defaultSegmentSize = -1;
-    private String ghLocation = "";
-    private DAType dataAccessType = DAType.RAM_STORE;
-    private boolean sortGraph = false;
-    boolean removeZipped = true;
-    private boolean elevation = false;
-    private LockFactory lockFactory = new NativeFSLockFactory();
-    private final String fileLockName = "gh.lock";
-    private boolean allowWrites = true;
-    boolean enableInstructions = true;
-    private boolean fullyLoaded = false;
-    // for routing
-    private double defaultWeightLimit = Double.MAX_VALUE;
-    private boolean simplifyResponse = true;
-    private TraversalMode traversalMode = TraversalMode.NODE_BASED;
-    private RoutingAlgorithmFactory algoFactory;
-    // for index
-    private LocationIndex locationIndex;
-    private int preciseIndexResolution = 300;
-    private int maxRegionSearch = 4;
-    // for prepare
-    private int minNetworkSize = 200;
-    private int minOneWayNetworkSize = 0;
-    // for CH prepare
-    private boolean doPrepare = true;
-    private boolean chEnabled = true;
-    private String chWeightingStr = "fastest";
-    private int periodicUpdates = -1;
-    private int lazyUpdates = -1;
-    private int neighborUpdates = -1;
-    private double logMessages = -1;
-    // for OSM import
-    private String dataReader = "OSM";
-    private String osmFile;
-    private double osmReaderWayPointMaxDistance = 1;
-    private int workerThreads = -1;
-    private boolean calcPoints = true;
-    // utils
-    private final TranslationMap trMap = new TranslationMap().doImport();
-    private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private final AtomicLong visitedSum = new AtomicLong(0);
-
-    /**
-     * Certain readers require additional arguments so this can be passed to
-     * them as a constructor parameter
-     */
-    private CmdArgs args;
-
-    public GraphHopper() {
-    }
-
-    /**
-     * For testing only
-     */
-    protected GraphHopper loadGraph(GraphStorage g) {
-        this.graph = g;
-        fullyLoaded = true;
-        initLocationIndex();
-        return this;
-    }
-
-    /**
-     * Specify which vehicles can be read by this GraphHopper instance. An
-     * encoding manager defines how data from every vehicle is written (und
-     * read) into edges of the graph.
-     */
-    public GraphHopper setEncodingManager(EncodingManager em) {
-        ensureNotLoaded();
-        this.encodingManager = em;
-        if (em.needsTurnCostsSupport())
-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
-
-        return this;
-    }
-
-    FlagEncoder getDefaultVehicle() {
-        if (encodingManager == null) {
-            throw new IllegalStateException("No encoding manager specified or loaded");
-        }
-
-        return encodingManager.fetchEdgeEncoders().get(0);
-    }
-
-    public EncodingManager getEncodingManager() {
-        return encodingManager;
-    }
-
-    public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
-        if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
-            setElevation(false);
-        else
-            setElevation(true);
-        this.eleProvider = eleProvider;
-        return this;
-    }
-
-    /**
-     * Threads for data reading.
-     */
-    protected int getWorkerThreads() {
-        return workerThreads;
-    }
-
-    /**
-     * Return maximum distance (in meter) to reduce points via douglas peucker
-     * while OSM import.
-     */
-    protected double getWayPointMaxDistance() {
-        return osmReaderWayPointMaxDistance;
-    }
-
-    /**
-     * This parameter specifies how to reduce points via douglas peucker while
-     * OSM import. Higher value means more details, unit is meter. Default is 1.
-     * Disable via 0.
-     */
-    public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
-        this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
-        return this;
-    }
-
-    /**
-     * Sets the default traversal mode used for the algorithms and preparation.
-     */
-    public GraphHopper setTraversalMode(TraversalMode traversalMode) {
-        this.traversalMode = traversalMode;
-        return this;
-    }
-
-    public TraversalMode getTraversalMode() {
-        return traversalMode;
-    }
-
-    /**
-     * Configures the underlying storage and response to be used on a well
-     * equipped server. Result also optimized for usage in the web module i.e.
-     * try reduce network IO.
-     */
-    public GraphHopper forServer() {
-        setSimplifyResponse(true);
-        return setInMemory();
-    }
-
-    /**
-     * Configures the underlying storage to be used on a Desktop computer or
-     * within another Java application with enough RAM but no network latency.
-     */
-    public GraphHopper forDesktop() {
-        setSimplifyResponse(false);
-        return setInMemory();
-    }
-
-    /**
-     * Configures the underlying storage to be used on a less powerful machine
-     * like Android or Raspberry Pi with only few MB of RAM.
-     */
-    public GraphHopper forMobile() {
-        setSimplifyResponse(false);
-        return setMemoryMapped();
-    }
-
-    /**
-     * Precise location resolution index means also more space (disc/RAM) could
-     * be consumed and probably slower query times, which would be e.g. not
-     * suitable for Android. The resolution specifies the tile width (in meter).
-     */
-    public GraphHopper setPreciseIndexResolution(int precision) {
-        ensureNotLoaded();
-        preciseIndexResolution = precision;
-        return this;
-    }
-
-    public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
-        this.minNetworkSize = minNetworkSize;
-        this.minOneWayNetworkSize = minOneWayNetworkSize;
-    }
-
-    /**
-     * This method call results in an in-memory graph.
-     */
-    public GraphHopper setInMemory() {
-        ensureNotLoaded();
-        dataAccessType = DAType.RAM_STORE;
-        return this;
-    }
-
-    /**
-     * Only valid option for in-memory graph and if you e.g. want to disable
-     * store on flush for unit tests. Specify storeOnFlush to true if you want
-     * that existing data will be loaded FROM disc and all in-memory data will
-     * be flushed TO disc after flush is called e.g. while OSM import.
-     * <p>
-     * 
-     * @param storeOnFlush
-     *            true by default
-     */
-    public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
-        ensureNotLoaded();
-        if (storeOnFlush)
-            dataAccessType = DAType.RAM_STORE;
-        else
-            dataAccessType = DAType.RAM;
-        return this;
-    }
-
-    /**
-     * Enable memory mapped configuration if not enough memory is available on
-     * the target platform.
-     */
-    public GraphHopper setMemoryMapped() {
-        ensureNotLoaded();
-        dataAccessType = DAType.MMAP;
-        return this;
-    }
-
-    /**
-     * Not yet stable enough to offer it for everyone
-     */
-    private GraphHopper setUnsafeMemory() {
-        ensureNotLoaded();
-        dataAccessType = DAType.UNSAFE_STORE;
-        return this;
-    }
-
-    /**
-     * Enables the use of contraction hierarchies to reduce query times. Enabled
-     * by default.
-     * <p/>
-     * 
-     * @param weighting
-     *            can be "fastest", "shortest" or your own weight-calculation
-     *            type.
-     * @see #setCHEnable(boolean)
-     */
-    public GraphHopper setCHWeighting(String weighting) {
-        ensureNotLoaded();
-        chWeightingStr = weighting;
-        return this;
-    }
-
-    public String getCHWeighting() {
-        return chWeightingStr;
-    }
-
-    /**
-     * Disables the "CH-preparation" preparation only. Use only if you know what
-     * you do. To disable the full usage of CH use setCHEnable(false) instead.
-     */
-    public GraphHopper setDoPrepare(boolean doPrepare) {
-        this.doPrepare = doPrepare;
-        return this;
-    }
-
-    /**
-     * Enables or disables contraction hierarchies (CH). This speed-up mode is
-     * enabled by default. Disabling CH is only recommended for short routes or
-     * in combination with setDefaultWeightLimit and called flexibility mode
-     * <p>
-     * 
-     * @see #setDefaultWeightLimit(double)
-     */
-    public GraphHopper setCHEnable(boolean enable) {
-        ensureNotLoaded();
-        algoFactory = null;
-        chEnabled = enable;
-        return this;
-    }
-
-    /**
-     * This methods stops the algorithm from searching further if the resulting
-     * path would go over specified weight, important if CH is disabled. The
-     * unit is defined by the used weighting created from createWeighting, e.g.
-     * distance for shortest or seconds for the standard FastestWeighting
-     * implementation.
-     */
-    public void setDefaultWeightLimit(double defaultWeightLimit) {
-        this.defaultWeightLimit = defaultWeightLimit;
-    }
-
-    public boolean isCHEnabled() {
-        return chEnabled;
-    }
-
-    /**
-     * @return true if storing and fetching elevation data is enabled. Default
-     *         is false
-     */
-    public boolean hasElevation() {
-        return elevation;
-    }
-
-    /**
-     * Enable storing and fetching elevation data. Default is false
-     */
-    public GraphHopper setElevation(boolean includeElevation) {
-        this.elevation = includeElevation;
-        return this;
-    }
-
-    /**
-     * This method specifies if the import should include way names to be able
-     * to return instructions for a route.
-     */
-    public GraphHopper setEnableInstructions(boolean b) {
-        ensureNotLoaded();
-        enableInstructions = b;
-        return this;
-    }
-
-    /**
-     * This methods enables gps point calculation. If disabled only distance
-     * will be calculated.
-     */
-    public GraphHopper setEnableCalcPoints(boolean b) {
-        calcPoints = b;
-        return this;
-    }
-
-    /**
-     * This method specifies if the returned path should be simplified or not,
-     * via douglas-peucker or similar algorithm.
-     */
-    private GraphHopper setSimplifyResponse(boolean doSimplify) {
-        this.simplifyResponse = doSimplify;
-        return this;
-    }
-
-    /**
-     * Sets the graphhopper folder.
-     */
-    public GraphHopper setGraphHopperLocation(String ghLocation) {
-        ensureNotLoaded();
-        if (ghLocation == null)
-            throw new IllegalArgumentException("graphhopper location cannot be null");
-
-        this.ghLocation = ghLocation;
-        return this;
-    }
-
-    public String getGraphHopperLocation() {
-        return ghLocation;
-    }
-
-    /**
-     * This file can be an osm xml (.osm), a compressed xml (.osm.zip or
-     * .osm.gz) or a protobuf file (.pbf).
-     */
-    public GraphHopper setOSMFile(String osmFileStr) {
-        ensureNotLoaded();
-        if (Helper.isEmpty(osmFileStr))
-            throw new IllegalArgumentException("OSM file cannot be empty.");
-
-        osmFile = osmFileStr;
-        return this;
-    }
-
-    public String getOSMFile() {
-        return osmFile;
-    }
-
-    /**
-     * The underlying graph used in algorithms.
-     * <p>
-     * 
-     * @throws IllegalStateException
-     *             if graph is not instantiated.
-     */
-    public GraphStorage getGraph() {
-        if (graph == null)
-            throw new IllegalStateException("Graph not initialized");
-
-        return graph;
-    }
-
-    public void setGraph(GraphStorage graph) {
-        this.graph = graph;
-    }
-
-    protected void setLocationIndex(LocationIndex locationIndex) {
-        this.locationIndex = locationIndex;
-    }
-
-    /**
-     * The location index created from the graph.
-     * <p>
-     * 
-     * @throws IllegalStateException
-     *             if index is not initialized
-     */
-    public LocationIndex getLocationIndex() {
-        if (locationIndex == null)
-            throw new IllegalStateException("Location index not initialized");
-
-        return locationIndex;
-    }
-
-    /**
-     * Sorts the graph which requires more RAM while import. See #12
-     */
-    public GraphHopper setSortGraph(boolean sortGraph) {
-        ensureNotLoaded();
-        this.sortGraph = sortGraph;
-        return this;
-    }
-
-    /**
-     * Specifies if it is allowed for GraphHopper to write. E.g. for read only
-     * filesystems it is not possible to create a lock file and so we can avoid
-     * write locks.
-     */
-    public GraphHopper setAllowWrites(boolean allowWrites) {
-        this.allowWrites = allowWrites;
-        return this;
-    }
-
-    public boolean isAllowWrites() {
-        return allowWrites;
-    }
-
-    public TranslationMap getTranslationMap() {
-        return trMap;
-    }
-
-    /**
-     * Reads configuration from a CmdArgs object. Which can be manually filled,
-     * or via main(String[] args) ala CmdArgs.read(args) or via configuration
-     * file ala CmdArgs.readFromConfig("config.properties",
-     * "graphhopper.config")
-     */
-    public GraphHopper init(CmdArgs args) {
-        args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
-        this.args = args;
-        String tmpOsmFile = args.get("osmreader.osm", "");
-        if (!Helper.isEmpty(tmpOsmFile))
-            osmFile = tmpOsmFile;
-
-        dataReader = args.get("reader.implementation", dataReader);
-
-        String graphHopperFolder = args.get("graph.location", "");
-        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
-            if (Helper.isEmpty(osmFile))
-                throw new IllegalArgumentException("You need to specify an OSM file.");
-
-            graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
-        }
-
-        // graph
-        setGraphHopperLocation(graphHopperFolder);
-        defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
-
-        String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
-        dataAccessType = DAType.fromString(graphDATypeStr);
-
-        sortGraph = args.getBool("graph.doSort", sortGraph);
-        removeZipped = args.getBool("graph.removeZipped", removeZipped);
-        int bytesForFlags = args.getInt("graph.bytesForFlags", 8);
-        if (args.get("graph.locktype", "native").equals("simple"))
-            lockFactory = new SimpleFSLockFactory();
-        else
-            lockFactory = new NativeFSLockFactory();
-
-        // elevation
-        String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
-        boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
-        String cacheDirStr = args.get("graph.elevation.cachedir", "");
-        String baseURL = args.get("graph.elevation.baseurl", "");
-        DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
-        ElevationProvider tmpProvider = ElevationProvider.NOOP;
-        if (eleProviderStr.equalsIgnoreCase("srtm")) {
-            tmpProvider = new SRTMProvider();
-        } else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
-            CGIARProvider cgiarProvider = new CGIARProvider();
+	private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM, OSITN or OSDPN";
+	private final Logger logger = LoggerFactory.getLogger(getClass());
+	// for graph:
+	private GraphStorage graph;
+	private EncodingManager encodingManager;
+	private int defaultSegmentSize = -1;
+	private String ghLocation = "";
+	private DAType dataAccessType = DAType.RAM_STORE;
+	private boolean sortGraph = false;
+	boolean removeZipped = true;
+	private boolean elevation = false;
+	private LockFactory lockFactory = new NativeFSLockFactory();
+	private final String fileLockName = "gh.lock";
+	private boolean allowWrites = true;
+	boolean enableInstructions = true;
+	private boolean fullyLoaded = false;
+	// for routing
+	private double defaultWeightLimit = Double.MAX_VALUE;
+	private boolean simplifyResponse = true;
+	private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+	private RoutingAlgorithmFactory algoFactory;
+	// for index
+	private LocationIndex locationIndex;
+	private int preciseIndexResolution = 300;
+	private int maxRegionSearch = 4;
+	// for prepare
+	private int minNetworkSize = 200;
+	private int minOneWayNetworkSize = 0;
+	// for CH prepare
+	private boolean doPrepare = true;
+	private boolean chEnabled = true;
+	private String chWeightingStr = "fastest";
+	private int periodicUpdates = -1;
+	private int lazyUpdates = -1;
+	private int neighborUpdates = -1;
+	private double logMessages = -1;
+	// for OSM import
+	private String dataReader = "OSM";
+	private String osmFile;
+	private double osmReaderWayPointMaxDistance = 1;
+	private int workerThreads = -1;
+	private boolean calcPoints = true;
+	// utils
+	private final TranslationMap trMap = new TranslationMap().doImport();
+	private ElevationProvider eleProvider = ElevationProvider.NOOP;
+	private final AtomicLong visitedSum = new AtomicLong(0);
+
+	/**
+	 * Certain readers require additional arguments so this can be passed to
+	 * them as a constructor parameter
+	 */
+	private CmdArgs args;
+
+	public GraphHopper() {
+	}
+
+	/**
+	 * For testing only
+	 */
+	protected GraphHopper loadGraph(GraphStorage g) {
+		this.graph = g;
+		fullyLoaded = true;
+		initLocationIndex();
+		return this;
+	}
+
+	/**
+	 * Specify which vehicles can be read by this GraphHopper instance. An
+	 * encoding manager defines how data from every vehicle is written (und
+	 * read) into edges of the graph.
+	 */
+	public GraphHopper setEncodingManager(EncodingManager em) {
+		ensureNotLoaded();
+		this.encodingManager = em;
+		if (em.needsTurnCostsSupport())
+			traversalMode = TraversalMode.EDGE_BASED_2DIR;
+
+		return this;
+	}
+
+	FlagEncoder getDefaultVehicle() {
+		if (encodingManager == null) {
+			throw new IllegalStateException("No encoding manager specified or loaded");
+		}
+
+		return encodingManager.fetchEdgeEncoders().get(0);
+	}
+
+	public EncodingManager getEncodingManager() {
+		return encodingManager;
+	}
+
+	public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
+		if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
+			setElevation(false);
+		else
+			setElevation(true);
+		this.eleProvider = eleProvider;
+		return this;
+	}
+
+	/**
+	 * Threads for data reading.
+	 */
+	protected int getWorkerThreads() {
+		return workerThreads;
+	}
+
+	/**
+	 * Return maximum distance (in meter) to reduce points via douglas peucker
+	 * while OSM import.
+	 */
+	protected double getWayPointMaxDistance() {
+		return osmReaderWayPointMaxDistance;
+	}
+
+	/**
+	 * This parameter specifies how to reduce points via douglas peucker while
+	 * OSM import. Higher value means more details, unit is meter. Default is 1.
+	 * Disable via 0.
+	 */
+	public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
+		this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
+		return this;
+	}
+
+	/**
+	 * Sets the default traversal mode used for the algorithms and preparation.
+	 */
+	public GraphHopper setTraversalMode(TraversalMode traversalMode) {
+		this.traversalMode = traversalMode;
+		return this;
+	}
+
+	public TraversalMode getTraversalMode() {
+		return traversalMode;
+	}
+
+	/**
+	 * Configures the underlying storage and response to be used on a well
+	 * equipped server. Result also optimized for usage in the web module i.e.
+	 * try reduce network IO.
+	 */
+	public GraphHopper forServer() {
+		setSimplifyResponse(true);
+		return setInMemory();
+	}
+
+	/**
+	 * Configures the underlying storage to be used on a Desktop computer or
+	 * within another Java application with enough RAM but no network latency.
+	 */
+	public GraphHopper forDesktop() {
+		setSimplifyResponse(false);
+		return setInMemory();
+	}
+
+	/**
+	 * Configures the underlying storage to be used on a less powerful machine
+	 * like Android or Raspberry Pi with only few MB of RAM.
+	 */
+	public GraphHopper forMobile() {
+		setSimplifyResponse(false);
+		return setMemoryMapped();
+	}
+
+	/**
+	 * Precise location resolution index means also more space (disc/RAM) could
+	 * be consumed and probably slower query times, which would be e.g. not
+	 * suitable for Android. The resolution specifies the tile width (in meter).
+	 */
+	public GraphHopper setPreciseIndexResolution(int precision) {
+		ensureNotLoaded();
+		preciseIndexResolution = precision;
+		return this;
+	}
+
+	public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
+		this.minNetworkSize = minNetworkSize;
+		this.minOneWayNetworkSize = minOneWayNetworkSize;
+	}
+
+	/**
+	 * This method call results in an in-memory graph.
+	 */
+	public GraphHopper setInMemory() {
+		ensureNotLoaded();
+		dataAccessType = DAType.RAM_STORE;
+		return this;
+	}
+
+	/**
+	 * Only valid option for in-memory graph and if you e.g. want to disable
+	 * store on flush for unit tests. Specify storeOnFlush to true if you want
+	 * that existing data will be loaded FROM disc and all in-memory data will
+	 * be flushed TO disc after flush is called e.g. while OSM import.
+	 * <p>
+	 * 
+	 * @param storeOnFlush
+	 *            true by default
+	 */
+	public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
+		ensureNotLoaded();
+		if (storeOnFlush)
+			dataAccessType = DAType.RAM_STORE;
+		else
+			dataAccessType = DAType.RAM;
+		return this;
+	}
+
+	/**
+	 * Enable memory mapped configuration if not enough memory is available on
+	 * the target platform.
+	 */
+	public GraphHopper setMemoryMapped() {
+		ensureNotLoaded();
+		dataAccessType = DAType.MMAP;
+		return this;
+	}
+
+	/**
+	 * Not yet stable enough to offer it for everyone
+	 */
+	private GraphHopper setUnsafeMemory() {
+		ensureNotLoaded();
+		dataAccessType = DAType.UNSAFE_STORE;
+		return this;
+	}
+
+	/**
+	 * Enables the use of contraction hierarchies to reduce query times. Enabled
+	 * by default.
+	 * <p/>
+	 * 
+	 * @param weighting
+	 *            can be "fastest", "shortest" or your own weight-calculation
+	 *            type.
+	 * @see #setCHEnable(boolean)
+	 */
+	public GraphHopper setCHWeighting(String weighting) {
+		ensureNotLoaded();
+		chWeightingStr = weighting;
+		return this;
+	}
+
+	public String getCHWeighting() {
+		return chWeightingStr;
+	}
+
+	/**
+	 * Disables the "CH-preparation" preparation only. Use only if you know what
+	 * you do. To disable the full usage of CH use setCHEnable(false) instead.
+	 */
+	public GraphHopper setDoPrepare(boolean doPrepare) {
+		this.doPrepare = doPrepare;
+		return this;
+	}
+
+	/**
+	 * Enables or disables contraction hierarchies (CH). This speed-up mode is
+	 * enabled by default. Disabling CH is only recommended for short routes or
+	 * in combination with setDefaultWeightLimit and called flexibility mode
+	 * <p>
+	 * 
+	 * @see #setDefaultWeightLimit(double)
+	 */
+	public GraphHopper setCHEnable(boolean enable) {
+		ensureNotLoaded();
+		algoFactory = null;
+		chEnabled = enable;
+		return this;
+	}
+
+	/**
+	 * This methods stops the algorithm from searching further if the resulting
+	 * path would go over specified weight, important if CH is disabled. The
+	 * unit is defined by the used weighting created from createWeighting, e.g.
+	 * distance for shortest or seconds for the standard FastestWeighting
+	 * implementation.
+	 */
+	public void setDefaultWeightLimit(double defaultWeightLimit) {
+		this.defaultWeightLimit = defaultWeightLimit;
+	}
+
+	public boolean isCHEnabled() {
+		return chEnabled;
+	}
+
+	/**
+	 * @return true if storing and fetching elevation data is enabled. Default
+	 *         is false
+	 */
+	public boolean hasElevation() {
+		return elevation;
+	}
+
+	/**
+	 * Enable storing and fetching elevation data. Default is false
+	 */
+	public GraphHopper setElevation(boolean includeElevation) {
+		this.elevation = includeElevation;
+		return this;
+	}
+
+	/**
+	 * This method specifies if the import should include way names to be able
+	 * to return instructions for a route.
+	 */
+	public GraphHopper setEnableInstructions(boolean b) {
+		ensureNotLoaded();
+		enableInstructions = b;
+		return this;
+	}
+
+	/**
+	 * This methods enables gps point calculation. If disabled only distance
+	 * will be calculated.
+	 */
+	public GraphHopper setEnableCalcPoints(boolean b) {
+		calcPoints = b;
+		return this;
+	}
+
+	/**
+	 * This method specifies if the returned path should be simplified or not,
+	 * via douglas-peucker or similar algorithm.
+	 */
+	private GraphHopper setSimplifyResponse(boolean doSimplify) {
+		this.simplifyResponse = doSimplify;
+		return this;
+	}
+
+	/**
+	 * Sets the graphhopper folder.
+	 */
+	public GraphHopper setGraphHopperLocation(String ghLocation) {
+		ensureNotLoaded();
+		if (ghLocation == null)
+			throw new IllegalArgumentException("graphhopper location cannot be null");
+
+		this.ghLocation = ghLocation;
+		return this;
+	}
+
+	public String getGraphHopperLocation() {
+		return ghLocation;
+	}
+
+	/**
+	 * This file can be an osm xml (.osm), a compressed xml (.osm.zip or
+	 * .osm.gz) or a protobuf file (.pbf).
+	 */
+	public GraphHopper setOSMFile(String osmFileStr) {
+		ensureNotLoaded();
+		if (Helper.isEmpty(osmFileStr))
+			throw new IllegalArgumentException("OSM file cannot be empty.");
+
+		osmFile = osmFileStr;
+		return this;
+	}
+
+	public String getOSMFile() {
+		return osmFile;
+	}
+
+	/**
+	 * The underlying graph used in algorithms.
+	 * <p>
+	 * 
+	 * @throws IllegalStateException
+	 *             if graph is not instantiated.
+	 */
+	public GraphStorage getGraph() {
+		if (graph == null)
+			throw new IllegalStateException("Graph not initialized");
+
+		return graph;
+	}
+
+	public void setGraph(GraphStorage graph) {
+		this.graph = graph;
+	}
+
+	protected void setLocationIndex(LocationIndex locationIndex) {
+		this.locationIndex = locationIndex;
+	}
+
+	/**
+	 * The location index created from the graph.
+	 * <p>
+	 * 
+	 * @throws IllegalStateException
+	 *             if index is not initialized
+	 */
+	public LocationIndex getLocationIndex() {
+		if (locationIndex == null)
+			throw new IllegalStateException("Location index not initialized");
+
+		return locationIndex;
+	}
+
+	/**
+	 * Sorts the graph which requires more RAM while import. See #12
+	 */
+	public GraphHopper setSortGraph(boolean sortGraph) {
+		ensureNotLoaded();
+		this.sortGraph = sortGraph;
+		return this;
+	}
+
+	/**
+	 * Specifies if it is allowed for GraphHopper to write. E.g. for read only
+	 * filesystems it is not possible to create a lock file and so we can avoid
+	 * write locks.
+	 */
+	public GraphHopper setAllowWrites(boolean allowWrites) {
+		this.allowWrites = allowWrites;
+		return this;
+	}
+
+	public boolean isAllowWrites() {
+		return allowWrites;
+	}
+
+	public TranslationMap getTranslationMap() {
+		return trMap;
+	}
+
+	/**
+	 * Reads configuration from a CmdArgs object. Which can be manually filled,
+	 * or via main(String[] args) ala CmdArgs.read(args) or via configuration
+	 * file ala CmdArgs.readFromConfig("config.properties",
+	 * "graphhopper.config")
+	 */
+	public GraphHopper init(CmdArgs args) {
+		args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
+		this.args = args;
+		String tmpOsmFile = args.get("osmreader.osm", "");
+		if (!Helper.isEmpty(tmpOsmFile))
+			osmFile = tmpOsmFile;
+
+		dataReader = args.get("reader.implementation", dataReader);
+
+		String graphHopperFolder = args.get("graph.location", "");
+		if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
+			if (Helper.isEmpty(osmFile))
+				throw new IllegalArgumentException("You need to specify an OSM file.");
+
+			graphHopperFolder = Helper.pruneFileEnd(osmFile) + "-gh";
+		}
+
+		// graph
+		setGraphHopperLocation(graphHopperFolder);
+		defaultSegmentSize = args.getInt("graph.dataaccess.segmentSize", defaultSegmentSize);
+
+		String graphDATypeStr = args.get("graph.dataaccess", "RAM_STORE");
+		dataAccessType = DAType.fromString(graphDATypeStr);
+
+		sortGraph = args.getBool("graph.doSort", sortGraph);
+		removeZipped = args.getBool("graph.removeZipped", removeZipped);
+		int bytesForFlags = args.getInt("graph.bytesForFlags", 8);
+		if (args.get("graph.locktype", "native").equals("simple"))
+			lockFactory = new SimpleFSLockFactory();
+		else
+			lockFactory = new NativeFSLockFactory();
+
+		// elevation
+		String eleProviderStr = args.get("graph.elevation.provider", "noop").toLowerCase();
+		boolean eleCalcMean = args.getBool("graph.elevation.calcmean", false);
+		String cacheDirStr = args.get("graph.elevation.cachedir", "");
+		String baseURL = args.get("graph.elevation.baseurl", "");
+		DAType elevationDAType = DAType.fromString(args.get("graph.elevation.dataaccess", "MMAP"));
+		ElevationProvider tmpProvider = ElevationProvider.NOOP;
+		if (eleProviderStr.equalsIgnoreCase("srtm")) {
+			tmpProvider = new SRTMProvider();
+		} else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
+			CGIARProvider cgiarProvider = new CGIARProvider();
             cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
-            tmpProvider = cgiarProvider;
-        }
-
-        tmpProvider.setCalcMean(eleCalcMean);
-        tmpProvider.setCacheDir(new File(cacheDirStr));
-        if (!baseURL.isEmpty())
-            tmpProvider.setBaseURL(baseURL);
-        tmpProvider.setDAType(elevationDAType);
-        setElevationProvider(tmpProvider);
-
-        // optimizable prepare
-        minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
-        minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
-
-        // prepare CH
-        doPrepare = args.getBool("prepare.doPrepare", doPrepare);
-        String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
-        chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
-        if (chEnabled)
-            setCHWeighting(tmpCHWeighting);
-
-        periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
-        lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
-        neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
-        logMessages = args.getDouble("prepare.logmessages", logMessages);
-
-        // osm import
+			tmpProvider = cgiarProvider;
+		}
+
+		tmpProvider.setCalcMean(eleCalcMean);
+		tmpProvider.setCacheDir(new File(cacheDirStr));
+		if (!baseURL.isEmpty())
+			tmpProvider.setBaseURL(baseURL);
+		tmpProvider.setDAType(elevationDAType);
+		setElevationProvider(tmpProvider);
+
+		// optimizable prepare
+		minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
+		minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
+
+		// prepare CH
+		doPrepare = args.getBool("prepare.doPrepare", doPrepare);
+		String tmpCHWeighting = args.get("prepare.chWeighting", "fastest");
+		chEnabled = "fastest".equals(tmpCHWeighting) || "shortest".equals(tmpCHWeighting);
+		if (chEnabled)
+			setCHWeighting(tmpCHWeighting);
+
+		periodicUpdates = args.getInt("prepare.updates.periodic", periodicUpdates);
+		lazyUpdates = args.getInt("prepare.updates.lazy", lazyUpdates);
+		neighborUpdates = args.getInt("prepare.updates.neighbor", neighborUpdates);
+		logMessages = args.getDouble("prepare.logmessages", logMessages);
+
+		// osm import
         osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
-        String flagEncoders = args.get("graph.flagEncoders", "");
-        if (!flagEncoders.isEmpty())
-            setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
+		String flagEncoders = args.get("graph.flagEncoders", "");
+		if (!flagEncoders.isEmpty())
+			setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
 
-        workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
-        enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
+		workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
+		enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
-        // index
-        preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
-        maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+		// index
+		preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
+		maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
 
-        // routing
-        defaultWeightLimit = args.getDouble("routing.defaultWeightLimit", defaultWeightLimit);
-        return this;
-    }
+		// routing
+		defaultWeightLimit = args.getDouble("routing.defaultWeightLimit", defaultWeightLimit);
+		return this;
+	}
 
-    private void printInfo() {
+	private void printInfo() {
         logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
-        if (graph != null)
-            logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
-    }
-
-    /**
-     * Imports provided data from disc and creates graph. Depending on the
-     * settings the resulting graph will be stored to disc so on a second call
-     * this method will only load the graph from disc which is usually a lot
-     * faster.
-     */
-    public GraphHopper importOrLoad() {
-        if (!load(ghLocation)) {
-            printInfo();
-            process(ghLocation);
-        } else {
-            printInfo();
-        }
-        return this;
-    }
-
-    /**
-     * Creates the graph from OSM data.
-     */
-    private GraphHopper process(String graphHopperLocation) {
-        setGraphHopperLocation(graphHopperLocation);
-        Lock lock = null;
-        try {
-            if (graph.getDirectory().getDefaultType().isStoring()) {
-                lockFactory.setLockDir(new File(graphHopperLocation));
-                lock = lockFactory.create(fileLockName, true);
-                if (!lock.tryLock())
-                    throw new RuntimeException(
-                            "To avoid multiple writers we need to obtain a write lock but it failed. In "
-                                    + graphHopperLocation, lock.getObtainFailedReason());
-            }
-
-            try {
-                importData();
-                graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
-            } catch (IOException ex) {
-                throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
-            }
-            cleanUp();
-            optimize();
-            postProcessing();
-            flush();
-        } finally {
-            if (lock != null)
-                lock.release();
-        }
-        return this;
-    }
-
-    protected DataReader importData() throws IOException {
-        ensureWriteAccess();
-        if (graph == null)
-            throw new IllegalStateException("Load graph before importing OSM data");
-
-        if (osmFile == null)
-            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
-                    + " but also cannot import from OSM file as it wasn't specified!");
-
-        encodingManager.setEnableInstructions(enableInstructions);
-        DataReader reader = createReader(graph);
-        logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
-        reader.readGraph();
-        return reader;
-    }
-
-    protected DataReader createReader(GraphStorage tmpGraph) {
-        DataReader reader;
-        if ("OSM".equals(dataReader))
-            reader = new OSMReader(tmpGraph);
-        else if ("OSITN".equals(dataReader))
-            reader = new OsItnReader(tmpGraph, args);
-        else if ("OSDPN".equals(dataReader))
-            reader = new OsDpnReader(tmpGraph, args);
-        else if ("OSHN".equals(dataReader))
-            reader = new OsHnReader(tmpGraph);
-        else {
-            String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
-            throw new IllegalArgumentException(exceptionMessage);
-        }
-        return initReader(reader);
-    }
-
-    protected DataReader initReader(DataReader reader) {
-        if (osmFile == null)
-            throw new IllegalArgumentException("No OSM file specified");
-
-        logger.info("start creating graph from " + osmFile);
-        File osmTmpFile = new File(osmFile);
+		if (graph != null)
+			logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
+	}
+
+	/**
+	 * Imports provided data from disc and creates graph. Depending on the
+	 * settings the resulting graph will be stored to disc so on a second call
+	 * this method will only load the graph from disc which is usually a lot
+	 * faster.
+	 */
+	public GraphHopper importOrLoad() {
+		if (!load(ghLocation)) {
+			printInfo();
+			process(ghLocation);
+		} else {
+			printInfo();
+		}
+		return this;
+	}
+
+	/**
+	 * Creates the graph from OSM data.
+	 */
+	private GraphHopper process(String graphHopperLocation) {
+		setGraphHopperLocation(graphHopperLocation);
+		Lock lock = null;
+		try {
+			if (graph.getDirectory().getDefaultType().isStoring()) {
+				lockFactory.setLockDir(new File(graphHopperLocation));
+				lock = lockFactory.create(fileLockName, true);
+				if (!lock.tryLock())
+					throw new RuntimeException(
+							"To avoid multiple writers we need to obtain a write lock but it failed. In "
+									+ graphHopperLocation, lock.getObtainFailedReason());
+			}
+
+			try {
+				importData();
+				graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
+			} catch (IOException ex) {
+				throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
+			}
+			cleanUp();
+			optimize();
+			postProcessing();
+			flush();
+		} finally {
+			if (lock != null)
+				lock.release();
+		}
+		return this;
+	}
+
+	protected DataReader importData() throws IOException {
+		ensureWriteAccess();
+		if (graph == null)
+			throw new IllegalStateException("Load graph before importing OSM data");
+
+		if (osmFile == null)
+			throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
+					+ " but also cannot import from OSM file as it wasn't specified!");
+
+		encodingManager.setEnableInstructions(enableInstructions);
+		DataReader reader = createReader(graph);
+		logger.info("using " + graph.toString() + ", memory:" + Helper.getMemInfo());
+		reader.readGraph();
+		return reader;
+	}
+
+	protected DataReader createReader(GraphStorage tmpGraph) {
+		DataReader reader;
+		if ("OSM".equals(dataReader))
+			reader = new OSMReader(tmpGraph);
+		else if ("OSITN".equals(dataReader))
+			reader = new OsItnReader(tmpGraph, args);
+		else if ("OSDPN".equals(dataReader))
+			reader = new OsDpnReader(tmpGraph, args);
+		else if ("OSHN".equals(dataReader))
+			reader = new OsHnReader(tmpGraph);
+		else {
+			String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
+			throw new IllegalArgumentException(exceptionMessage);
+		}
+		return initReader(reader);
+	}
+
+	protected DataReader initReader(DataReader reader) {
+		if (osmFile == null)
+			throw new IllegalArgumentException("No OSM file specified");
+
+		logger.info("start creating graph from " + osmFile);
+		File osmTmpFile = new File(osmFile);
         return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider).setWorkerThreads(workerThreads)
                 .setEncodingManager(encodingManager).setWayPointMaxDistance(osmReaderWayPointMaxDistance);
-    }
-
-    /**
-     * Opens existing graph.
-     * <p/>
-     * 
-     * @param graphHopperFolder
-     *            is the folder containing graphhopper files (which can be
-     *            compressed too)
-     */
-    @Override
-    public boolean load(String graphHopperFolder) {
-        if (Helper.isEmpty(graphHopperFolder))
+	}
+
+	/**
+	 * Opens existing graph.
+	 * <p/>
+	 * 
+	 * @param graphHopperFolder
+	 *            is the folder containing graphhopper files (which can be
+	 *            compressed too)
+	 */
+	@Override
+	public boolean load(String graphHopperFolder) {
+		if (Helper.isEmpty(graphHopperFolder))
             throw new IllegalStateException("graphHopperLocation is not specified. call init before");
 
-        if (fullyLoaded)
-            throw new IllegalStateException("graph is already successfully loaded");
-
-        if (graphHopperFolder.endsWith("-gh")) {
-            // do nothing
-        } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml")) {
-            throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-        } else if (!graphHopperFolder.contains(".")) {
-            if (new File(graphHopperFolder + "-gh").exists())
-                graphHopperFolder += "-gh";
-        } else {
-            File compressed = new File(graphHopperFolder + ".ghz");
-            if (compressed.exists() && !compressed.isDirectory()) {
-                try {
+		if (fullyLoaded)
+			throw new IllegalStateException("graph is already successfully loaded");
+
+		if (graphHopperFolder.endsWith("-gh")) {
+			// do nothing
+		} else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml")) {
+			throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
+		} else if (!graphHopperFolder.contains(".")) {
+			if (new File(graphHopperFolder + "-gh").exists())
+				graphHopperFolder += "-gh";
+		} else {
+			File compressed = new File(graphHopperFolder + ".ghz");
+			if (compressed.exists() && !compressed.isDirectory()) {
+				try {
                     new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
-                } catch (IOException ex) {
+				} catch (IOException ex) {
                     throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath() + " to "
                             + graphHopperFolder, ex);
-                }
-            }
-        }
-
-        setGraphHopperLocation(graphHopperFolder);
-
-        if (encodingManager == null)
-            setEncodingManager(EncodingManager.create(ghLocation));
-
-        if (!allowWrites && dataAccessType.isMMap())
-            dataAccessType = DAType.MMAP_RO;
-
-        GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
-        if (chEnabled)
-            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
-        else if (encodingManager.needsTurnCostsSupport())
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
-        else
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
-
-        graph.setSegmentSize(defaultSegmentSize);
-
-        Lock lock = null;
-        try {
-            // create locks only if writes are allowed, if they are not allowed
-            // a lock cannot be created
-            // (e.g. on a read only filesystem locks would fail)
-            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
-                lockFactory.setLockDir(new File(ghLocation));
-                lock = lockFactory.create(fileLockName, false);
-                if (!lock.tryLock())
-                    throw new RuntimeException(
-                            "To avoid reading partial data we need to obtain the read lock but it failed. In "
-                                    + ghLocation, lock.getObtainFailedReason());
-            }
-
-            if (!graph.loadExisting())
-                return false;
-
-            postProcessing();
-            fullyLoaded = true;
-            return true;
-        } finally {
-            if (lock != null)
-                lock.release();
-        }
-    }
-
-    public RoutingAlgorithmFactory getAlgorithmFactory() {
-        if (algoFactory == null)
-            this.algoFactory = new RoutingAlgorithmFactorySimple();
-
-        return algoFactory;
-    }
-
-    public void setAlgorithmFactory(RoutingAlgorithmFactory algoFactory) {
-        this.algoFactory = algoFactory;
-    }
-
-    /**
-     * Sets EncodingManager, does the preparation and creates the locationIndex
-     */
-    protected void postProcessing() {
-        initLocationIndex();
-        if (chEnabled)
-            algoFactory = createPrepare();
-        else
-            algoFactory = new RoutingAlgorithmFactorySimple();
-
-        if (!isPrepared())
-            prepare();
-    }
-
-    private boolean isPrepared() {
-        return "true".equals(graph.getProperties().get("prepare.done"));
-    }
-
-    protected RoutingAlgorithmFactory createPrepare() {
-        FlagEncoder defaultVehicle = getDefaultVehicle();
-        Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
+				}
+			}
+		}
+
+		setGraphHopperLocation(graphHopperFolder);
+
+		if (encodingManager == null)
+			setEncodingManager(EncodingManager.create(ghLocation));
+
+		if (!allowWrites && dataAccessType.isMMap())
+			dataAccessType = DAType.MMAP_RO;
+
+		GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
+		if (chEnabled)
+			graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
+		else if (encodingManager.needsTurnCostsSupport())
+			graph = new GraphHopperStorage(dir, encodingManager, hasElevation(),
+					new TurnCostExtension());
+		else if (encodingManager.needsAttributeStorageSupport())
+			graph = new GraphHopperStorage(dir, encodingManager, hasElevation(),
+					new AvoidanceAttributeExtension());
+		else
+			graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
+
+		graph.setSegmentSize(defaultSegmentSize);
+
+		Lock lock = null;
+		try {
+			// create locks only if writes are allowed, if they are not allowed
+			// a lock cannot be created
+			// (e.g. on a read only filesystem locks would fail)
+			if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
+				lockFactory.setLockDir(new File(ghLocation));
+				lock = lockFactory.create(fileLockName, false);
+				if (!lock.tryLock())
+					throw new RuntimeException(
+							"To avoid reading partial data we need to obtain the read lock but it failed. In "
+									+ ghLocation, lock.getObtainFailedReason());
+			}
+
+			if (!graph.loadExisting())
+				return false;
+
+			postProcessing();
+			fullyLoaded = true;
+			return true;
+		} finally {
+			if (lock != null)
+				lock.release();
+		}
+	}
+
+	public RoutingAlgorithmFactory getAlgorithmFactory() {
+		if (algoFactory == null)
+			this.algoFactory = new RoutingAlgorithmFactorySimple();
+
+		return algoFactory;
+	}
+
+	public void setAlgorithmFactory(RoutingAlgorithmFactory algoFactory) {
+		this.algoFactory = algoFactory;
+	}
+
+	/**
+	 * Sets EncodingManager, does the preparation and creates the locationIndex
+	 */
+	protected void postProcessing() {
+		initLocationIndex();
+		if (chEnabled)
+			algoFactory = createPrepare();
+		else
+			algoFactory = new RoutingAlgorithmFactorySimple();
+
+		if (!isPrepared())
+			prepare();
+	}
+
+	private boolean isPrepared() {
+		return "true".equals(graph.getProperties().get("prepare.done"));
+	}
+
+	protected RoutingAlgorithmFactory createPrepare() {
+		FlagEncoder defaultVehicle = getDefaultVehicle();
+		Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
         PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(new GHDirectory("",
                 DAType.RAM_INT), (LevelGraph) graph, defaultVehicle, weighting, traversalMode);
-        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
-                .setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
-
-        return tmpPrepareCH;
-    }
-
-    /**
-     * Based on the weightingParameters and the specified vehicle a Weighting
-     * instance can be created. Note that all URL parameters are available in
-     * the weightingParameters as String if you use the GraphHopper Web module.
-     * <p>
-     * 
-     * @see WeightingMap
-     * @param weightingMap
-     *            all parameters influencing the weighting. E.g. parameters
-     *            coming via GHRequest.getHints or directly via "&api.xy=" from
-     *            the URL of the web UI
-     * @param encoder
-     *            the required vehicle
-     * @return the weighting to be used for route calculation
-     */
-    public Weighting createWeighting(WeightingMap weightingMap, FlagEncoder encoder) {
-        String weighting = weightingMap.getWeighting();
-        Weighting result;
-
-        if ("shortest".equalsIgnoreCase(weighting)) {
-            result = new ShortestWeighting();
-        } else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty()) {
-            if (encoder.supports(PriorityWeighting.class))
-                result = new PriorityWeighting(encoder);
-            else
-                result = new FastestWeighting(encoder);
-        } else if ("fastavoid".equalsIgnoreCase(weighting)) {
-            String avoidanceString = weightingMap.get("avoidances", "cliff");
-            String[] avoidances = avoidanceString.split(",");
-            if (encoder.supports(PriorityWeighting.class))
-                result = new PriorityWithAvoidancesWeighting(encoder, avoidances);
-            else
-                result = new FastestWithAvoidancesWeighting(encoder, avoidances);
-        } else if ("shortavoid".equalsIgnoreCase(weighting)) {
-            String avoidanceString = weightingMap.get("avoidances", "cliff");
-            String[] avoidances = avoidanceString.split(",");
-            result = new ShortestWithAvoidancesWeighting(encoder, avoidances);
-        } else {
-            throw new UnsupportedOperationException("weighting " + weighting + " not supported");
-        }
-        return result;
-    }
-
-    /**
-     * Potentially wraps the specified weighting into a TurnWeighting instance.
-     */
-    public Weighting createTurnWeighting(Weighting weighting, Graph graph, FlagEncoder encoder) {
-        if (encoder.supports(TurnWeighting.class))
-            return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
-        return weighting;
-    }
-
-    @Override
-    public GHResponse route(GHRequest request) {
-        GHResponse response = new GHResponse();
-        List<Path> paths = getPaths(request, response);
-        if (response.hasErrors())
-            return response;
+		tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
+				.setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
+
+		return tmpPrepareCH;
+	}
+
+	/**
+	 * Based on the weightingParameters and the specified vehicle a Weighting
+	 * instance can be created. Note that all URL parameters are available in
+	 * the weightingParameters as String if you use the GraphHopper Web module.
+	 * <p>
+	 * 
+	 * @see WeightingMap
+	 * @param weightingMap
+	 *            all parameters influencing the weighting. E.g. parameters
+	 *            coming via GHRequest.getHints or directly via "&api.xy=" from
+	 *            the URL of the web UI
+	 * @param encoder
+	 *            the required vehicle
+	 * @return the weighting to be used for route calculation
+	 */
+	public Weighting createWeighting(WeightingMap weightingMap, FlagEncoder encoder) {
+		String weighting = weightingMap.getWeighting();
+		Weighting result;
+
+		if ("shortest".equalsIgnoreCase(weighting)) {
+			result = new ShortestWeighting();
+		} else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty()) {
+			if (encoder.supports(PriorityWeighting.class))
+				result = new PriorityWeighting(encoder);
+			else
+				result = new FastestWeighting(encoder);
+		} else if ("fastavoid".equalsIgnoreCase(weighting)) {
+			String avoidanceString = weightingMap.get("avoidances", "cliff");
+			String[] avoidances = avoidanceString.split(",");
+			if (encoder.supports(PriorityWeighting.class)) {
+				AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
+						.getExtension();
+				result = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension,
+						avoidances);
+			} else {
+				AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
+						.getExtension();
+				result = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
+			}
+		} else if ("shortavoid".equalsIgnoreCase(weighting)) {
+			AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension) graph
+					.getExtension();
+			String avoidanceString = weightingMap.get("avoidances", "cliff");
+			String[] avoidances = avoidanceString.split(",");
+			result = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, avoidances);
+		} else {
+			throw new UnsupportedOperationException("weighting " + weighting + " not supported");
+		}
+		return result;
+	}
+
+	/**
+	 * Potentially wraps the specified weighting into a TurnWeighting instance.
+	 */
+	public Weighting createTurnWeighting(Weighting weighting, Graph graph, FlagEncoder encoder) {
+		if (encoder.supports(TurnWeighting.class))
+			return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
+		return weighting;
+	}
+
+	@Override
+	public GHResponse route(GHRequest request) {
+		GHResponse response = new GHResponse();
+		List<Path> paths = getPaths(request, response);
+		if (response.hasErrors())
+			return response;
 
         boolean tmpEnableInstructions = request.getHints().getBool("instructions", enableInstructions);
-        boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
-        double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
-        Locale locale = request.getLocale();
-        DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
-
-        new PathMerger().setCalcPoints(tmpCalcPoints).setDouglasPeucker(peucker)
-                .setEnableInstructions(tmpEnableInstructions)
-                .setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
-                .doWork(response, paths, trMap.getWithFallBack(locale));
-        return response;
-    }
-
-    protected List<Path> getPaths(GHRequest request, GHResponse rsp) {
-        if (graph == null || !fullyLoaded)
-            throw new IllegalStateException("Call load or importOrLoad before routing");
-
-        if (graph.isClosed())
+		boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
+		double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
+		Locale locale = request.getLocale();
+		DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
+
+		new PathMerger().setCalcPoints(tmpCalcPoints).setDouglasPeucker(peucker)
+				.setEnableInstructions(tmpEnableInstructions)
+				.setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
+				.doWork(response, paths, trMap.getWithFallBack(locale));
+		return response;
+	}
+
+	protected List<Path> getPaths(GHRequest request, GHResponse rsp) {
+		if (graph == null || !fullyLoaded)
+			throw new IllegalStateException("Call load or importOrLoad before routing");
+
+		if (graph.isClosed())
             throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
 
-        String vehicle = request.getVehicle();
-        if (vehicle.isEmpty())
-            vehicle = getDefaultVehicle().toString();
+		String vehicle = request.getVehicle();
+		if (vehicle.isEmpty())
+			vehicle = getDefaultVehicle().toString();
 
-        if (!encodingManager.supports(vehicle)) {
+		if (!encodingManager.supports(vehicle)) {
             rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. " + "Supported are: "
                     + getEncodingManager()));
-            return Collections.emptyList();
-        }
-
-        TraversalMode tMode;
-        String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
-        try {
-            tMode = TraversalMode.fromString(tModeStr);
-        } catch (Exception ex) {
-            rsp.addError(ex);
-            return Collections.emptyList();
-        }
-
-        List<GHPoint> points = request.getPoints();
-        if (points.size() < 2) {
+			return Collections.emptyList();
+		}
+
+		TraversalMode tMode;
+		String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
+		try {
+			tMode = TraversalMode.fromString(tModeStr);
+		} catch (Exception ex) {
+			rsp.addError(ex);
+			return Collections.emptyList();
+		}
+
+		List<GHPoint> points = request.getPoints();
+		if (points.size() < 2) {
             rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
-            return Collections.emptyList();
-        }
+			return Collections.emptyList();
+		}
 
-        visitedSum.set(0);
+		visitedSum.set(0);
 
-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
-        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+		FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+		EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
 
-        StopWatch sw = new StopWatch().start();
-        List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
-        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
-            GHPoint point = points.get(placeIndex);
-            QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-            if (!res.isValid())
+		StopWatch sw = new StopWatch().start();
+		List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
+		for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
+			GHPoint point = points.get(placeIndex);
+			QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+			if (!res.isValid())
                 rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
 
-            qResults.add(res);
-        }
+			qResults.add(res);
+		}
 
-        if (rsp.hasErrors())
-            return Collections.emptyList();
+		if (rsp.hasErrors())
+			return Collections.emptyList();
 
-        String debug = "idLookup:" + sw.stop().getSeconds() + "s";
+		String debug = "idLookup:" + sw.stop().getSeconds() + "s";
 
-        QueryGraph queryGraph;
-        RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
-        if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString())) {
-            // fall back to normal traversing
-            tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
-            queryGraph = new QueryGraph(graph.getBaseGraph());
-        } else {
-            queryGraph = new QueryGraph(graph);
-        }
+		QueryGraph queryGraph;
+		RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
+		if (chEnabled && !vehicle.equalsIgnoreCase(getDefaultVehicle().toString())) {
+			// fall back to normal traversing
+			tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
+			queryGraph = new QueryGraph(graph.getBaseGraph());
+		} else {
+			queryGraph = new QueryGraph(graph);
+		}
 
-        queryGraph.lookup(qResults);
+		queryGraph.lookup(qResults);
 
-        List<Path> paths = new ArrayList<Path>(points.size() - 1);
-        QueryResult fromQResult = qResults.get(0);
-        Weighting weighting = createWeighting(request.getHints(), encoder);
-        weighting = createTurnWeighting(weighting, queryGraph, encoder);
+		List<Path> paths = new ArrayList<Path>(points.size() - 1);
+		QueryResult fromQResult = qResults.get(0);
+		Weighting weighting = createWeighting(request.getHints(), encoder);
+		weighting = createTurnWeighting(weighting, queryGraph, encoder);
 
-        double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
+		double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
         String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
         AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode)
                 .flagEncoder(encoder).weighting(weighting).build();
 
-        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++) {
-            QueryResult toQResult = qResults.get(placeIndex);
-            sw = new StopWatch().start();
-            RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
-            algo.setWeightLimit(weightLimit);
-            debug += ", algoInit:" + sw.stop().getSeconds() + "s";
+		for (int placeIndex = 1; placeIndex < points.size(); placeIndex++) {
+			QueryResult toQResult = qResults.get(placeIndex);
+			sw = new StopWatch().start();
+			RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
+			algo.setWeightLimit(weightLimit);
+			debug += ", algoInit:" + sw.stop().getSeconds() + "s";
 
-            sw = new StopWatch().start();
-            Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
-            if (path.getTime() < 0)
+			sw = new StopWatch().start();
+			Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
+			if (path.getTime() < 0)
                 throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
 
-            paths.add(path);
+			paths.add(path);
             debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
 
-            visitedSum.addAndGet(algo.getVisitedNodes());
-            fromQResult = toQResult;
-        }
+			visitedSum.addAndGet(algo.getVisitedNodes());
+			fromQResult = toQResult;
+		}
 
-        if (rsp.hasErrors())
-            return Collections.emptyList();
+		if (rsp.hasErrors())
+			return Collections.emptyList();
 
-        if (points.size() - 1 != paths.size())
+		if (points.size() - 1 != paths.size())
             throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size()
-                    + ", paths:" + paths.size());
-
-        rsp.setDebugInfo(debug);
-        return paths;
-    }
-
-    protected LocationIndex createLocationIndex(Directory dir) {
-        LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
-        tmpIndex.setResolution(preciseIndexResolution);
-        tmpIndex.setMaxRegionSearch(maxRegionSearch);
-        if (!tmpIndex.loadExisting()) {
-            ensureWriteAccess();
-            tmpIndex.prepareIndex();
-        }
-
-        return tmpIndex;
-    }
-
-    /**
-     * Initializes the location index after the import is done.
-     */
-    protected void initLocationIndex() {
-        if (locationIndex != null)
-            throw new IllegalStateException("Cannot initialize locationIndex twice!");
-
-        locationIndex = createLocationIndex(graph.getDirectory());
-    }
-
-    protected void optimize() {
-        logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
-        graph.optimize();
-        logger.info("finished optimize (" + Helper.getMemInfo() + ")");
-
-        // Later: move this into the GraphStorage.optimize method
-        // Or: Doing it after preparation to optimize shortcuts too. But not
-        // possible yet #12
-        if (sortGraph) {
-            if (graph instanceof LevelGraph && isPrepared())
+							+ ", paths:" + paths.size());
+
+		rsp.setDebugInfo(debug);
+		return paths;
+	}
+
+	protected LocationIndex createLocationIndex(Directory dir) {
+		LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
+		tmpIndex.setResolution(preciseIndexResolution);
+		tmpIndex.setMaxRegionSearch(maxRegionSearch);
+		if (!tmpIndex.loadExisting()) {
+			ensureWriteAccess();
+			tmpIndex.prepareIndex();
+		}
+
+		return tmpIndex;
+	}
+
+	/**
+	 * Initializes the location index after the import is done.
+	 */
+	protected void initLocationIndex() {
+		if (locationIndex != null)
+			throw new IllegalStateException("Cannot initialize locationIndex twice!");
+
+		locationIndex = createLocationIndex(graph.getDirectory());
+	}
+
+	protected void optimize() {
+		logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
+		graph.optimize();
+		logger.info("finished optimize (" + Helper.getMemInfo() + ")");
+
+		// Later: move this into the GraphStorage.optimize method
+		// Or: Doing it after preparation to optimize shortcuts too. But not
+		// possible yet #12
+		if (sortGraph) {
+			if (graph instanceof LevelGraph && isPrepared())
                 throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
 
-            GraphStorage newGraph = GHUtility.newStorage(graph);
-            GHUtility.sortDFS(graph, newGraph);
-            logger.info("graph sorted (" + Helper.getMemInfo() + ")");
-            graph = newGraph;
-        }
-    }
-
-    protected void prepare() {
-        boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
-        if (tmpPrepare) {
-            ensureWriteAccess();
+			GraphStorage newGraph = GHUtility.newStorage(graph);
+			GHUtility.sortDFS(graph, newGraph);
+			logger.info("graph sorted (" + Helper.getMemInfo() + ")");
+			graph = newGraph;
+		}
+	}
+
+	protected void prepare() {
+		boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
+		if (tmpPrepare) {
+			ensureWriteAccess();
             logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
-            ((PrepareContractionHierarchies) algoFactory).doWork();
-            graph.getProperties().put("prepare.date", formatDateTime(new Date()));
-        }
-        graph.getProperties().put("prepare.done", tmpPrepare);
-    }
-
-    protected void cleanUp() {
-        int prev = graph.getNodes();
+			((PrepareContractionHierarchies) algoFactory).doWork();
+			graph.getProperties().put("prepare.date", formatDateTime(new Date()));
+		}
+		graph.getProperties().put("prepare.done", tmpPrepare);
+	}
+
+	protected void cleanUp() {
+		int prev = graph.getNodes();
         PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
-        preparation.setMinNetworkSize(minNetworkSize);
-        preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
-        logger.info("start finding subnetworks, " + Helper.getMemInfo());
-        preparation.doWork();
-        int n = graph.getNodes();
-        // calculate remaining subnetworks
-        int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were "
-                + preparation.getSubNetworks() + " subnetworks. removed them => " + (prev - n)
-                + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
-    }
-
-    protected void flush() {
+		preparation.setMinNetworkSize(minNetworkSize);
+		preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
+		logger.info("start finding subnetworks, " + Helper.getMemInfo());
+		preparation.doWork();
+		int n = graph.getNodes();
+		// calculate remaining subnetworks
+		int remainingSubnetworks = preparation.findSubnetworks().size();
+		logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were "
+				+ preparation.getSubNetworks() + " subnetworks. removed them => " + (prev - n)
+				+ " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+	}
+
+	protected void flush() {
         logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", "
                 + Helper.getMemInfo() + ")");
-        graph.flush();
-        fullyLoaded = true;
-    }
-
-    /**
-     * Releases all associated resources like memory or files. But it does not
-     * remove them. To remove the files created in graphhopperLocation you have
-     * to call clean().
-     */
-    public void close() {
-        if (graph != null)
-            graph.close();
-
-        if (locationIndex != null)
-            locationIndex.close();
-
-        try {
-            lockFactory.forceRemove(fileLockName, true);
-        } catch (Exception ex) {
-            // silently fail e.g. on Windows where we cannot remove an
-            // unreleased native lock
-        }
-    }
-
-    /**
-     * Removes the on-disc routing files. Call only after calling close or
-     * before importOrLoad or load
-     */
-    public void clean() {
-        if (getGraphHopperLocation().isEmpty())
+		graph.flush();
+		fullyLoaded = true;
+	}
+
+	/**
+	 * Releases all associated resources like memory or files. But it does not
+	 * remove them. To remove the files created in graphhopperLocation you have
+	 * to call clean().
+	 */
+	public void close() {
+		if (graph != null)
+			graph.close();
+
+		if (locationIndex != null)
+			locationIndex.close();
+
+		try {
+			lockFactory.forceRemove(fileLockName, true);
+		} catch (Exception ex) {
+			// silently fail e.g. on Windows where we cannot remove an
+			// unreleased native lock
+		}
+	}
+
+	/**
+	 * Removes the on-disc routing files. Call only after calling close or
+	 * before importOrLoad or load
+	 */
+	public void clean() {
+		if (getGraphHopperLocation().isEmpty())
             throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
 
-        File folder = new File(getGraphHopperLocation());
-        Helper.removeDir(folder);
-    }
+		File folder = new File(getGraphHopperLocation());
+		Helper.removeDir(folder);
+	}
 
-    // make sure this is identical to buildDate used in pom.xml
-    // <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
-    private String formatDateTime(Date date) {
-        return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
-    }
+	// make sure this is identical to buildDate used in pom.xml
+	// <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
+	private String formatDateTime(Date date) {
+		return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
+	}
 
-    protected void ensureNotLoaded() {
-        if (fullyLoaded)
+	protected void ensureNotLoaded() {
+		if (fullyLoaded)
             throw new IllegalStateException("No configuration changes are possible after loading the graph");
-    }
-
-    protected void ensureWriteAccess() {
-        if (!allowWrites)
-            throw new IllegalStateException("Writes are not allowed!");
-    }
-
-    /**
-     * Returns the current sum of the visited nodes while routing. Mainly for
-     * statistic and debugging purposes.
-     */
-    public long getVisitedSum() {
-        return visitedSum.get();
-    }
-
-    public GraphHopper setAsOSMReader() {
-        dataReader = "OSM";
-        return this;
-    }
-
-    public GraphHopper setAsItnReader() {
-        dataReader = "OSITN";
-        return this;
-    }
-
-    public GraphHopper setAsHnReader() {
-        dataReader = "OSHN";
-        return this;
-    }
-
-    public GraphHopper setAsDpnReader() {
-        dataReader = "OSDPN";
-        return this;
-    }
+	}
+
+	protected void ensureWriteAccess() {
+		if (!allowWrites)
+			throw new IllegalStateException("Writes are not allowed!");
+	}
+
+	/**
+	 * Returns the current sum of the visited nodes while routing. Mainly for
+	 * statistic and debugging purposes.
+	 */
+	public long getVisitedSum() {
+		return visitedSum.get();
+	}
+
+	public GraphHopper setAsOSMReader() {
+		dataReader = "OSM";
+		return this;
+	}
+
+	public GraphHopper setAsItnReader() {
+		dataReader = "OSITN";
+		return this;
+	}
+
+	public GraphHopper setAsHnReader() {
+		dataReader = "OSHN";
+		return this;
+	}
+
+	public GraphHopper setAsDpnReader() {
+		dataReader = "OSDPN";
+		return this;
+	}
 }
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
index 7dfd9d4a00..c23f4b43c2 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnReader.java
@@ -32,8 +32,12 @@
 import com.graphhopper.reader.RelationMember;
 import com.graphhopper.reader.RoutingElement;
 import com.graphhopper.reader.TurnRelation;
+import com.graphhopper.reader.Way;
 import com.graphhopper.reader.osgb.AbstractOsReader;
 import com.graphhopper.reader.osgb.itn.OSITNTurnRelation;
+import com.graphhopper.routing.util.EncoderDecorator;
+import com.graphhopper.storage.AvoidanceAttributeExtension;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.DistanceCalc;
@@ -356,7 +360,7 @@ void processWay(OsDpnWay way) {
         long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
         if (wayFlags == 0)
             return;
-
+       
         List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
         // look for barriers along the way
         final int size = osmNodeIds.size();
@@ -414,10 +418,33 @@ void processWay(OsDpnWay way) {
             createdEdges.addAll(addOSMWay(transfer, wayFlags, wayOsmId));
         }
 
-        for (EdgeIteratorState edge : createdEdges) {
+        long configureEdgeAvoidance = configureEdgeAvoidance(way);
+        applyAvoidanceAttributes(way, createdEdges, configureEdgeAvoidance);
+    }
+
+	private void applyAvoidanceAttributes(OsDpnWay way, List<EdgeIteratorState> createdEdges,
+			long configureEdgeAvoidance) {
+		for (EdgeIteratorState edge : createdEdges) {
             encodingManager.applyWayTags(way, edge);
+            if(0<configureEdgeAvoidance) {
+            	AvoidanceAttributeExtension avoidanceExtension = (AvoidanceAttributeExtension)graphStorage.getExtension();
+            	avoidanceExtension.addEdgeInfo(edge.getEdge(), edge.getAdjNode(), configureEdgeAvoidance);
+            }
         }
-    }
+	}
+
+	private long configureEdgeAvoidance(Way way) {
+		 GraphExtension extendedStorage = graphStorage.getExtension();
+		 long handleWayTags=0;
+         if (extendedStorage instanceof AvoidanceAttributeExtension)
+         {
+        	 List<EncoderDecorator> decorators = encodingManager.getDecorators();
+        	 for (EncoderDecorator encoderDecorator : decorators) {
+        		 handleWayTags += encoderDecorator.handleWayTags(way);
+        	 }
+         }
+         return handleWayTags;
+	}
 
     public void processRelation(Relation relation) throws XMLStreamException {
         // if (relation.hasTag("type", "restriction")) {
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 793fc153c2..4158f43850 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -21,10 +21,13 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
+
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -54,6 +57,7 @@
     private TIntList edgeIds;
     private double weight;
     private NodeAccess nodeAccess;
+	private GraphExtension extraInfo;
 
     public Path( Graph graph, FlagEncoder encoder )
     {
@@ -62,6 +66,7 @@ public Path( Graph graph, FlagEncoder encoder )
         this.nodeAccess = graph.getNodeAccess();
         this.encoder = encoder;
         this.edgeIds = new TIntArrayList();
+        this.extraInfo = graph.getExtension();
     }
 
     /**
@@ -415,13 +420,17 @@ public void next( EdgeIteratorState edge, int index )
                 // we will skip zero length edges. Unfortunately there is a loss
                 // of precision in Lat/Lon calculations in GHNodeAccess so we
                 // have to handle <=0.1 as zero length.
-//                if (edge.getDistance() > 0.1) {
+                if (edge.getDistance() > 0.1) {
                     // baseNode is the current node and adjNode is the next
                     int adjNode = edge.getAdjNode();
                     int baseNode = edge.getBaseNode();
+                    
                     long flags = edge.getFlags();
                     double adjLat = nodeAccess.getLatitude(adjNode);
                     double adjLon = nodeAccess.getLongitude(adjNode);
+                    if(nodeAccess.getDimension()==1) {
+                    	
+                    }
                     double latitude, longitude;
 
                     PointList wayGeo = edge.fetchWayGeometry(3);
@@ -438,8 +447,18 @@ public void next( EdgeIteratorState edge, int index )
                     }
 
                     name = edge.getName();
-                    annotation = encoder.getAnnotation(flags, tr);
-
+                    
+                    try {
+                    	if(graph.getExtension().isRequireEdgeField()) {
+                    		int additionalField = edge.getAdditionalField();
+                    		annotation = encoder.getAnnotation(flags, tr, additionalField, extraInfo);
+                    	}
+                    	else {
+                    		annotation = encoder.getAnnotation(flags, tr);
+                    	}
+                    } catch (UnsupportedOperationException uoe) {
+                    	annotation = encoder.getAnnotation(flags, tr);
+                    }
                     if ((prevName == null) && (!isRoundabout)) // very first instruction (if not in Roundabout)
                     {
                         int sign = Instruction.CONTINUE_ON_STREET;
@@ -590,7 +609,7 @@ public void next( EdgeIteratorState edge, int index )
                         }
                         ways.add(new FinishInstruction(nodeAccess, adjNode));
                     }
-//                }
+                }
             }
 
             private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 883554e47f..df429d01b3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -33,6 +33,8 @@
 import com.graphhopper.reader.RoutingElement;
 import com.graphhopper.reader.TurnRelation;
 import com.graphhopper.reader.Way;
+import com.graphhopper.storage.AvoidanceAttributeExtension;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.EdgeExplorer;
@@ -51,10 +53,8 @@
  * @author Nop
  * @see EncodingManager
  */
-public abstract class AbstractFlagEncoder implements FlagEncoder,
-		TurnCostEncoder {
-	private final static Logger logger = LoggerFactory
-			.getLogger(AbstractFlagEncoder.class);
+public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder {
+	private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
 	private final static int K_FORWARD = 0, K_BACKWARD = 1;
 	/* Edge Flag Encoder fields */
 	private long nodeBitMask;
@@ -68,8 +68,9 @@
 	// bit to signal that way is accepted
 	protected long acceptBit;
 	protected long ferryBit;
-	
-	// This value determines the maximal possible speed of any road regardless the maxspeed value
+
+	// This value determines the maximal possible speed of any road regardless
+	// the maxspeed value
 	// lower values allow more compact representation of the routing graph
 	protected int maxPossibleSpeed;
 
@@ -95,10 +96,8 @@
 	/**
 	 * Used to hold type exclusions
 	 */
-	protected final List<String> vehicleQualifierTypeExclusions = new ArrayList<String>(
-			5);
-	protected final List<String> vehicleQualifierTypeInclusions = new ArrayList<String>(
-			5);
+	protected final List<String> vehicleQualifierTypeExclusions = new ArrayList<String>(5);
+	protected final List<String> vehicleQualifierTypeInclusions = new ArrayList<String>(5);
 	private boolean blockByDefault = true;
 	private boolean blockFords = true;
 	protected final int speedBits;
@@ -116,8 +115,7 @@
 	 *            is reached a turn is forbidden and results in costs of
 	 *            positive infinity.
 	 */
-	protected AbstractFlagEncoder(int speedBits, double speedFactor,
-			int maxTurnCosts) {
+	protected AbstractFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
 		this.maxTurnCosts = maxTurnCosts <= 0 ? 0 : maxTurnCosts;
 		this.speedBits = speedBits;
 		this.speedFactor = speedFactor;
@@ -162,6 +160,14 @@ public boolean isBlockFords() {
 		return blockFords;
 	}
 
+	public List<EncoderDecorator> getEncoderDecorators() {
+		return encoderDecorators;
+	}
+
+	public void setEncoderDecorators(List<EncoderDecorator> encoderDecorators) {
+		this.encoderDecorators = encoderDecorators;
+	}
+
 	/**
 	 * Defines the bits for the node flags, which are currently used for
 	 * barriers only.
@@ -184,9 +190,8 @@ public int defineNodeBits(int index, int shift) {
 	 */
 	public int defineWayBits(int index, int shift) {
 		if (forwardBit != 0)
-			throw new IllegalStateException(
-					"You must not register a FlagEncoder (" + toString()
-							+ ") twice!");
+			throw new IllegalStateException("You must not register a FlagEncoder (" + toString()
+					+ ") twice!");
 
 		// define the first 2 speedBits in flags for routing
 		forwardBit = 1L << shift;
@@ -225,8 +230,7 @@ public int defineRelationBits(int index, int shift) {
 	 * determine the useful relation tags.
 	 * <p/>
 	 */
-	public abstract long handleRelationTags(Relation relation,
-			long oldRelationFlags);
+	public abstract long handleRelationTags(Relation relation, long oldRelationFlags);
 
 	/**
 	 * Decide whether a way is routable for a given mode of travel. This skips
@@ -242,18 +246,7 @@ public abstract long handleRelationTags(Relation relation,
 	 * Analyze properties of a way and create the routing flags. This method is
 	 * called in the second parsing step.
 	 */
-	public abstract long handleWayTags( Way way, long allowed, long relationFlags );
-	
-	
-	public long handleWayTagsDecorators(Way way) {
-		long flags = 0;
-		if (null != encoderDecorators) {
-			for (EncoderDecorator decorator : encoderDecorators) {
-				flags |= decorator.handleWayTags(way);
-			}
-		}
-		return flags;
-	};
+	public abstract long handleWayTags(Way way, long allowed, long relationFlags);
 
 	/**
 	 * Parse tags on nodes. Node tags can add to speed (like traffic_signals)
@@ -284,8 +277,7 @@ public long handleNodeTags(Node node) {
 				return directionBitMask;
 		}
 
-		if (blockFords
-				&& (node.hasTag("highway", "ford") || node.hasTag("ford"))
+		if (blockFords && (node.hasTag("highway", "ford") || node.hasTag("ford"))
 				&& !node.hasTag(restrictions, intendedValues))
 			return directionBitMask;
 
@@ -294,15 +286,22 @@ public long handleNodeTags(Node node) {
 
 	@Override
 	public InstructionAnnotation getAnnotation(long flags, Translation tr) {
-		if (null != encoderDecorators) {
+		return InstructionAnnotation.EMPTY;
+	}
+
+	@Override
+	public InstructionAnnotation getAnnotation(long flags, Translation tr, int extraField, GraphExtension extraInfo) {
+		//TODO composite annotations (Raise importance to highest value, append message if newest message is higher importance prepend)
+		if (extraField > -1 && null != encoderDecorators) {
+			long avoidanceFlags = ((AvoidanceAttributeExtension)extraInfo).getAvoidanceFlags(extraField);
 			for (EncoderDecorator decorator : encoderDecorators) {
-				InstructionAnnotation anno = decorator.getAnnotation(flags, tr);
+				InstructionAnnotation anno = decorator.getAnnotation(avoidanceFlags, tr);
 				if (!anno.isEmpty()) {
 					return anno;
 				}
 			}
 		}
-		return InstructionAnnotation.EMPTY;
+		return getAnnotation(flags, tr);
 	}
 
 	/**
@@ -335,8 +334,8 @@ public long setAccess(long flags, boolean forward, boolean backward) {
 	@Override
 	public long setSpeed(long flags, double speed) {
 		if (speed < 0)
-			throw new IllegalArgumentException("Speed cannot be negative: "
-					+ speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
+			throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:"
+					+ BitUtil.LITTLE.toBitString(flags));
 
 		if (speed > getMaxSpeed())
 			speed = getMaxSpeed();
@@ -512,8 +511,8 @@ public void applyWayTags(Way way, EdgeIteratorState edge) {
 	/**
 	 * Special handling for ferry ways.
 	 */
-	protected long handleFerryTags(Way way, double unknownSpeed,
-			double shortTripsSpeed, double longTripsSpeed) {
+	protected long handleFerryTags(Way way, double unknownSpeed, double shortTripsSpeed,
+			double longTripsSpeed) {
 		// to hours
 		double durationInHours = parseDuration(way.getTag("duration")) / 60d;
 		if (durationInHours > 0)
@@ -591,8 +590,7 @@ else if (maxTurnCosts == 1) {
 		}
 
 		int turnBits = Helper.countBitValue(maxTurnCosts);
-		turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0,
-				maxTurnCosts) {
+		turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0, maxTurnCosts) {
 			// override to avoid expensive Math.round
 			@Override
 			public final long getValue(long flags) {
@@ -622,8 +620,7 @@ public double getTurnCost(long flags) {
 			return 0;
 
 		else if (maxTurnCosts == 1)
-			return ((flags & turnRestrictionBit) == 0) ? 0
-					: Double.POSITIVE_INFINITY;
+			return ((flags & turnRestrictionBit) == 0) ? 0 : Double.POSITIVE_INFINITY;
 
 		long cost = turnCostEncoder.getValue(flags);
 		if (cost == maxTurnCosts)
@@ -639,8 +636,7 @@ public long getTurnFlags(boolean restricted, double costs) {
 
 		else if (maxTurnCosts == 1) {
 			if (costs != 0)
-				throw new IllegalArgumentException(
-						"Only restrictions are supported");
+				throw new IllegalArgumentException("Only restrictions are supported");
 
 			return restricted ? turnRestrictionBit : 0;
 		}
@@ -663,8 +659,8 @@ else if (maxTurnCosts == 1) {
 		return turnCostEncoder.setValue(0L, (int) costs);
 	}
 
-	public Collection<ITurnCostTableEntry> analyzeTurnRelation(
-			TurnRelation turnRelation, DataReader osmReader) {
+	public Collection<ITurnCostTableEntry> analyzeTurnRelation(TurnRelation turnRelation,
+			DataReader osmReader) {
 		if (!supports(TurnWeighting.class))
 			return Collections.emptyList();
 
@@ -674,8 +670,8 @@ else if (maxTurnCosts == 1) {
 			edgeInExplorer = osmReader.getGraphStorage().createEdgeExplorer(
 					new DefaultEdgeFilter(this, true, false));
 		}
-		return turnRelation.getRestrictionAsEntries(this, edgeOutExplorer,
-				edgeInExplorer, osmReader);
+		return turnRelation.getRestrictionAsEntries(this, edgeOutExplorer, edgeInExplorer,
+				osmReader);
 	}
 
 	protected boolean isFerry(long internalFlags) {
@@ -699,15 +695,14 @@ public boolean isForward(long flags) {
 	@Override
 	public long setBool(long flags, int key, boolean value) {
 		switch (key) {
-		case K_FORWARD:
-			return value ? flags | forwardBit : flags & ~forwardBit;
-		case K_BACKWARD:
-			return value ? flags | backwardBit : flags & ~backwardBit;
-		case K_ROUNDABOUT:
-			return value ? flags | roundaboutBit : flags & ~roundaboutBit;
-		default:
-			throw new IllegalArgumentException("Unknown key " + key
-					+ " for boolean value");
+			case K_FORWARD:
+				return value ? flags | forwardBit : flags & ~forwardBit;
+			case K_BACKWARD:
+				return value ? flags | backwardBit : flags & ~backwardBit;
+			case K_ROUNDABOUT:
+				return value ? flags | roundaboutBit : flags & ~roundaboutBit;
+			default:
+				throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
 		}
 	}
 
@@ -715,41 +710,37 @@ public long setBool(long flags, int key, boolean value) {
 	public boolean isBool(long flags, int key) {
 		switch (key) {
 
-		case K_FORWARD:
-			return isForward(flags);
-		case K_BACKWARD:
-			return isBackward(flags);
-		case K_ROUNDABOUT:
-			return (flags & roundaboutBit) != 0;
-		default:
-			throw new IllegalArgumentException("Unknown key " + key
-					+ " for boolean value");
+			case K_FORWARD:
+				return isForward(flags);
+			case K_BACKWARD:
+				return isBackward(flags);
+			case K_ROUNDABOUT:
+				return (flags & roundaboutBit) != 0;
+			default:
+				throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
 		}
 	}
 
 	@Override
 	public long setLong(long flags, int key, long value) {
-		throw new UnsupportedOperationException("Unknown key " + key
-				+ " for long value.");
+		throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
 	}
 
 	@Override
 	public long getLong(long flags, int key) {
-        if(null!=encoderDecorators) {
-            for (EncoderDecorator decorator : encoderDecorators) {
-                if (decorator.supports(key)) {
-                    return decorator.getLong(flags);
-                }
-            }
-        }
-		throw new UnsupportedOperationException("Unknown key " + key
-				+ " for long value.");
+		if (null != encoderDecorators) {
+			for (EncoderDecorator decorator : encoderDecorators) {
+				if (decorator.supports(key)) {
+					return decorator.getLong(flags);
+				}
+			}
+		}
+		throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
 	}
 
 	@Override
 	public long setDouble(long flags, int key, double value) {
-		throw new UnsupportedOperationException("Unknown key " + key
-				+ " for double value.");
+		throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
 	}
 
 	@Override
@@ -759,8 +750,7 @@ public double getDouble(long flags, int key) {
 				return decorator.getDouble(flags);
 			}
 		}
-		throw new UnsupportedOperationException("Unknown key " + key
-				+ " for double value.");
+		throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
 	}
 
 	protected static double parseDouble(String str, String key, double defaultD) {
@@ -777,8 +767,7 @@ protected static long parseLong(String str, String key, long defaultL) {
 		return Long.parseLong(val);
 	}
 
-	protected static boolean parseBoolean(String str, String key,
-			boolean defaultB) {
+	protected static boolean parseBoolean(String str, String key, boolean defaultB) {
 		String val = getStr(str, key);
 		if (val.isEmpty())
 			return defaultB;
@@ -817,8 +806,8 @@ protected double applyMaxSpeed(Way way, double speed, boolean force) {
 	}
 
 	protected String getPropertiesString() {
-		return "speedFactor=" + speedFactor + "|speedBits=" + speedBits
-				+ "|turnCosts=" + (maxTurnCosts > 0);
+		return "speedFactor=" + speedFactor + "|speedBits=" + speedBits + "|turnCosts="
+				+ (maxTurnCosts > 0);
 	}
 
 	@Override
@@ -837,8 +826,7 @@ public boolean supports(Class<?> feature) {
 	 * @return
 	 */
 	public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
-		if (routingElement.hasTag(vehicleQualifierTypeInclusions,
-				intendedValues)) {
+		if (routingElement.hasTag(vehicleQualifierTypeInclusions, intendedValues)) {
 			// It is specifically included
 			return true;
 		}
@@ -853,8 +841,7 @@ public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
 	 * @return
 	 */
 	public boolean isVehicleQualifierTypeExcluded(RoutingElement routingElement) {
-		if (routingElement.hasTag(vehicleQualifierTypeExclusions,
-				excludedValues)) {
+		if (routingElement.hasTag(vehicleQualifierTypeExclusions, excludedValues)) {
 			// It is specifically excluded
 			return true;
 		}
@@ -866,7 +853,7 @@ public long getBitMask(String[] attributes, int key) {
 		long bitMask = 0;
 		if (null != encoderDecorators) {// BIT SHIFT FIRST
 			for (EncoderDecorator decorator : encoderDecorators) {
-				if(decorator.supports(key)) {
+				if (decorator.supports(key)) {
 					return decorator.getBitMask(attributes);
 				}
 			}
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 5ef12abd87..7085eb4317 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -21,7 +21,6 @@
 
 import com.graphhopper.reader.Relation;
 import com.graphhopper.reader.Way;
-
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
@@ -688,6 +687,6 @@ public boolean supports( Class<?> feature )
         if (super.supports(feature))
             return true;
 
-        return PriorityWeighting.class.isAssignableFrom(feature);
+        return PriorityWeighting.class.isAssignableFrom(feature)  && !PriorityWithAvoidancesWeighting.class.isAssignableFrom(feature);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 2b908b2a07..3d73ad867b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -369,8 +369,7 @@ public long handleWayTags( Way way, long allowed, long relationFlags )
             encoded = handleFerryTags(way, defaultSpeedMap.get("living_street"), defaultSpeedMap.get("service"), defaultSpeedMap.get("residential"));
             encoded |= directionBitMask;
         }
-        long anno = super.handleWayTagsDecorators(way);
-        return encoded |= anno;
+        return encoded;
     }
 
     public String getWayInfo(Way way )
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 252608a207..94a4ce3a64 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -23,7 +23,9 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.reader.ITurnCostTableEntry;
@@ -39,479 +41,512 @@
 import com.graphhopper.util.Helper;
 
 /**
- * Manager class to register encoder, assign their flag values and check objects with all encoders
- * during parsing.
+ * Manager class to register encoder, assign their flag values and check objects
+ * with all encoders during parsing.
  * <p/>
  * @author Peter Karich
  * @author Nop
  */
-public class EncodingManager
-{
-    public static final String CAR = "car";
-    public static final String BIKE = "bike";
-    public static final String BIKE2 = "bike2";
-    public static final String RACINGBIKE = "racingbike";
-    public static final String MOUNTAINBIKE = "mtb";
-    public static final String FOOT = "foot";
-    public static final String FOOT2 = "foot2";
-    public static final String MOTORCYCLE = "motorcycle";
-
-    private final List<AbstractFlagEncoder> edgeEncoders = new ArrayList<AbstractFlagEncoder>();
-
-    private int nextWayBit = 0;
-    private int nextNodeBit = 0;
-    private int nextRelBit = 0;
-    private int nextTurnBit = 0;
-    private final int bitsForEdgeFlags;
-    private final int bitsForTurnFlags = 8 * 4;
-    private boolean enableInstructions = true;
-
-    /**
+public class EncodingManager {
+	public static final String CAR = "car";
+	public static final String BIKE = "bike";
+	public static final String BIKE2 = "bike2";
+	public static final String RACINGBIKE = "racingbike";
+	public static final String MOUNTAINBIKE = "mtb";
+	public static final String FOOT = "foot";
+	public static final String FOOT2 = "foot2";
+	public static final String MOTORCYCLE = "motorcycle";
+	private static final String ERR = "Encoders are requesting more than %s bits of %s flags. ";
+	private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via osmreader.bytesForFlags=8";
+
+	private List<EncoderDecorator> decorators;
+
+	private final List<AbstractFlagEncoder> edgeEncoders = new ArrayList<AbstractFlagEncoder>();
+
+	private int nextWayBit = 0;
+	private int nextNodeBit = 0;
+	private int nextRelBit = 0;
+	private int nextTurnBit = 0;
+	private final int bitsForEdgeFlags;
+	private final int bitsForTurnFlags = 8 * 4;
+	private boolean enableInstructions = true;
+
+	/**
      * Instantiate manager with the given list of encoders. The manager knows the default encoders:
      * CAR, FOOT and BIKE (ignoring the case). Custom encoders can be specified by giving a full
      * class name e.g. "car:com.graphhopper.myproject.MyCarEncoder"
-     * <p/>
+	 * <p/>
      * @param flagEncodersStr comma delimited list of encoders. The order does not matter.
-     */
+	 */
     public EncodingManager( String flagEncodersStr )
     {
-        this(flagEncodersStr, 4);
-    }
+		this(flagEncodersStr, 4);
+	}
 
     public EncodingManager( String flagEncodersStr, int bytesForFlags )
     {
-        this(parseEncoderString(flagEncodersStr), bytesForFlags);
-    }
+		this(parseEncoderString(flagEncodersStr), bytesForFlags);
+	}
 
-    /**
-     * Instantiate manager with the given list of encoders.
-     * <p/>
+	/**
+	 * Instantiate manager with the given list of encoders.
+	 * <p/>
      * @param flagEncoders comma delimited list of encoders. The order does not matter.
-     */
+	 */
     public EncodingManager( FlagEncoder... flagEncoders )
     {
-        this(Arrays.asList(flagEncoders));
-    }
+		this(Arrays.asList(flagEncoders));
+	}
 
-    /**
-     * Instantiate manager with the given list of encoders.
-     * <p/>
+	/**
+	 * Instantiate manager with the given list of encoders.
+	 * <p/>
      * @param flagEncoders comma delimited list of encoders. The order does not matter.
-     */
+	 */
     public EncodingManager( List<? extends FlagEncoder> flagEncoders )
     {
-        this(flagEncoders, 4);
-    }
+		this(flagEncoders, 4);
+	}
 
     public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags )
     {
-        if (bytesForEdgeFlags != 4 && bytesForEdgeFlags != 8)
+		if (bytesForEdgeFlags != 4 && bytesForEdgeFlags != 8)
             throw new IllegalStateException("For 'edge flags' currently only 4 or 8 bytes supported");
 
-        this.bitsForEdgeFlags = bytesForEdgeFlags * 8;
+		this.bitsForEdgeFlags = bytesForEdgeFlags * 8;
         for (FlagEncoder flagEncoder : flagEncoders)
         {
-            registerEncoder((AbstractFlagEncoder) flagEncoder);
-        }
+			registerEncoder((AbstractFlagEncoder) flagEncoder);
+		}
 
-        if (edgeEncoders.isEmpty())
-            throw new IllegalStateException("No vehicles found");
-    }
+		if (edgeEncoders.isEmpty())
+			throw new IllegalStateException("No vehicles found");
+		configureDecoratorSet();
+	}
 
     public int getBytesForFlags()
     {
-        return bitsForEdgeFlags / 8;
-    }
+		return bitsForEdgeFlags / 8;
+	}
 
     static List<FlagEncoder> parseEncoderString( String encoderList )
     {
-        if (encoderList.contains(":"))
+		if (encoderList.contains(":"))
             throw new IllegalArgumentException("EncodingManager does no longer use reflection instantiate encoders directly.");
 
-        String[] entries = encoderList.split(",");
-        List<FlagEncoder> resultEncoders = new ArrayList<FlagEncoder>();
+		String[] entries = encoderList.split(",");
+		List<FlagEncoder> resultEncoders = new ArrayList<FlagEncoder>();
 
         for (String entry : entries)
         {
-            entry = entry.trim().toLowerCase();
-            if (entry.isEmpty())
-                continue;
+			entry = entry.trim().toLowerCase();
+			if (entry.isEmpty())
+				continue;
 
-            String entryVal = "";
+			String entryVal = "";
             if (entry.contains("|"))
             {
-                entryVal = entry;
-                entry = entry.split("\\|")[0];
-            }
+				entryVal = entry;
+				entry = entry.split("\\|")[0];
+			}
 
-            AbstractFlagEncoder fe;
-            if (entry.equals(CAR))
-                fe = new CarFlagEncoder(entryVal);
+			AbstractFlagEncoder fe;
+			if (entry.equals(CAR))
+				fe = new CarFlagEncoder(entryVal);
 
-            else if (entry.equals(BIKE))
-                fe = new BikeFlagEncoder(entryVal);
+			else if (entry.equals(BIKE))
+				fe = new BikeFlagEncoder(entryVal);
 
-            else if (entry.equals(BIKE2))
-                fe = new Bike2WeightFlagEncoder(entryVal);
+			else if (entry.equals(BIKE2))
+				fe = new Bike2WeightFlagEncoder(entryVal);
 
-            else if (entry.equals(RACINGBIKE))
-                fe = new RacingBikeFlagEncoder(entryVal);
+			else if (entry.equals(RACINGBIKE))
+				fe = new RacingBikeFlagEncoder(entryVal);
 
-            else if (entry.equals(MOUNTAINBIKE))
-                fe = new MountainBikeFlagEncoder(entryVal);
+			else if (entry.equals(MOUNTAINBIKE))
+				fe = new MountainBikeFlagEncoder(entryVal);
 
-            else if (entry.equals(FOOT))
-                fe = new FootFlagEncoder(entryVal);
+			else if (entry.equals(FOOT))
+				fe = new FootFlagEncoder(entryVal);
 
-            else if (entry.equals(FOOT2))
-                fe = new OsFootFlagEncoder(entryVal);
+			else if (entry.equals(FOOT2))
+				fe = new OsFootFlagEncoder(entryVal);
 
-            else if (entry.equals(MOTORCYCLE))
-                fe = new MotorcycleFlagEncoder(entryVal);
+			else if (entry.equals(MOTORCYCLE))
+				fe = new MotorcycleFlagEncoder(entryVal);
 
-            else
-                throw new IllegalArgumentException("entry in encoder list not supported " + entry);
+			else
+				throw new IllegalArgumentException("entry in encoder list not supported " + entry);
 
-            resultEncoders.add(fe);
-        }
-        return resultEncoders;
-    }
+			resultEncoders.add(fe);
+		}
+		return resultEncoders;
+	}
 
-    private static final String ERR = "Encoders are requesting more than %s bits of %s flags. ";
-    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via osmreader.bytesForFlags=8";
+	private void registerEncoder(AbstractFlagEncoder encoder) {
+		int encoderCount = edgeEncoders.size();
+		int usedBits = encoder.defineNodeBits(encoderCount, nextNodeBit);
+		if (usedBits > bitsForEdgeFlags)
+			throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "node"));
+		encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
+		nextNodeBit = usedBits;
 
-    private void registerEncoder( AbstractFlagEncoder encoder )
-    {
-        int encoderCount = edgeEncoders.size();
-        int usedBits = encoder.defineNodeBits(encoderCount, nextNodeBit);
-        if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "node"));
-        encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
-        nextNodeBit = usedBits;
-
-        usedBits = encoder.defineWayBits(encoderCount, nextWayBit);
-        if (usedBits > bitsForEdgeFlags)
+		usedBits = encoder.defineWayBits(encoderCount, nextWayBit);
+		if (usedBits > bitsForEdgeFlags)
             throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "way") + WAY_ERR);
-        encoder.setWayBitMask(usedBits - nextWayBit, nextWayBit);
-        nextWayBit = usedBits;
-
-        usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
-        if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "relation"));
-        encoder.setRelBitMask(usedBits - nextRelBit, nextRelBit);
-        nextRelBit = usedBits;
-
-        // turn flag bits are independent from edge encoder bits
-        usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit);
-        if (usedBits > bitsForTurnFlags)
-            throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "turn"));
-        nextTurnBit = usedBits;
-
-        edgeEncoders.add(encoder);
-    }
-
-    /**
-     * @return true if the specified encoder is found
-     */
+		encoder.setWayBitMask(usedBits - nextWayBit, nextWayBit);
+		nextWayBit = usedBits;
+
+		usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
+		if (usedBits > bitsForEdgeFlags)
+			throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "relation"));
+		encoder.setRelBitMask(usedBits - nextRelBit, nextRelBit);
+		nextRelBit = usedBits;
+
+		// turn flag bits are independent from edge encoder bits
+		usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit);
+		if (usedBits > bitsForTurnFlags)
+			throw new IllegalArgumentException(String.format(ERR, bitsForEdgeFlags, "turn"));
+		nextTurnBit = usedBits;
+
+		edgeEncoders.add(encoder);
+	}
+
+	/**
+	 * @return true if the specified encoder is found
+	 */
     public boolean supports( String encoder )
     {
-        return getEncoder(encoder, false) != null;
-    }
+		return getEncoder(encoder, false) != null;
+	}
 
     public FlagEncoder getEncoder( String name )
     {
-        return getEncoder(name, true);
-    }
+		return getEncoder(name, true);
+	}
 
     private FlagEncoder getEncoder( String name, boolean throwExc )
     {
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            if (name.equalsIgnoreCase(encoder.toString()))
-                return encoder;
-        }
-        if (throwExc)
+			if (name.equalsIgnoreCase(encoder.toString()))
+				return encoder;
+		}
+		if (throwExc)
             throw new IllegalArgumentException("Encoder for " + name + " not found. Existing: " + toDetailsString());
-        return null;
-    }
+		return null;
+	}
 
-    /**
-     * Determine whether an osm way is a routable way for one of its encoders.
-     */
+	/**
+	 * Determine whether an osm way is a routable way for one of its encoders.
+	 */
     public long acceptWay( Way way )
     {
-        long includeWay = 0;
+		long includeWay = 0;
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            includeWay |= encoder.acceptWay(way);
-        }
+			includeWay |= encoder.acceptWay(way);
+		}
 
-        return includeWay;
-    }
+		return includeWay;
+	}
 
     public long handleRelationTags( Relation relation, long oldRelationFlags )
     {
-        long flags = 0;
+		long flags = 0;
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            flags |= encoder.handleRelationTags(relation, oldRelationFlags);
-        }
+			flags |= encoder.handleRelationTags(relation, oldRelationFlags);
+		}
 
-        return flags;
-    }
+		return flags;
+	}
 
-    /**
+	/**
      * Processes way properties of different kind to determine speed and direction. Properties are
      * directly encoded in 8 bytes.
-     * <p/>
+	 * <p/>
      * @param relationFlags The preprocessed relation flags is used to influence the way properties.
-     * @return the encoded flags
-     */
+	 * @return the encoded flags
+	 */
     public long handleWayTags( Way way, long includeWay, long relationFlags )
     {
-        long flags = 0;
+		long flags = 0;
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
             flags |= encoder.handleWayTags(way, includeWay, relationFlags & encoder.getRelBitMask());
-        }
+		}
 
-        return flags;
-    }
+		for (EncoderDecorator encoderDecorator : decorators) {
+			encoderDecorator.handleWayTags(way);
+		}
+		return flags;
+	}
 
-    @Override
+	@Override
     public String toString()
     {
-        StringBuilder str = new StringBuilder();
+		StringBuilder str = new StringBuilder();
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            if (str.length() > 0)
-                str.append(",");
+			if (str.length() > 0)
+				str.append(",");
 
-            str.append(encoder.toString());
-        }
+			str.append(encoder.toString());
+		}
 
-        return str.toString();
-    }
+		return str.toString();
+	}
 
     public String toDetailsString()
     {
-        StringBuilder str = new StringBuilder();
+		StringBuilder str = new StringBuilder();
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            if (str.length() > 0)
-                str.append(",");
+			if (str.length() > 0)
+				str.append(",");
 
-            str.append(encoder.toString());
-            str.append("|");
-            str.append(encoder.getPropertiesString());
-        }
+			str.append(encoder.toString());
+			str.append("|");
+			str.append(encoder.getPropertiesString());
+		}
 
-        return str.toString();
-    }
+		return str.toString();
+	}
 
     public long flagsDefault( boolean forward, boolean backward )
     {
-        long flags = 0;
+		long flags = 0;
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            flags |= encoder.flagsDefault(forward, backward);
-        }
-        return flags;
-    }
-
-    /**
-     * Reverse flags, to do so all encoders are called.
-     */
+			flags |= encoder.flagsDefault(forward, backward);
+		}
+		return flags;
+	}
+
+	/**
+	 * Reverse flags, to do so all encoders are called.
+	 */
     public long reverseFlags( long flags )
     {
-        // performance critical
-        int len = edgeEncoders.size();
+		// performance critical
+		int len = edgeEncoders.size();
         for (int i = 0; i < len; i++)
         {
-            flags = edgeEncoders.get(i).reverseFlags(flags);
-        }
-        return flags;
-    }
+			flags = edgeEncoders.get(i).reverseFlags(flags);
+		}
+		return flags;
+	}
 
-    @Override
+	@Override
     public int hashCode()
     {
-        int hash = 5;
-        hash = 53 * hash + (this.edgeEncoders != null ? this.edgeEncoders.hashCode() : 0);
-        return hash;
-    }
+		int hash = 5;
+		hash = 53 * hash + (this.edgeEncoders != null ? this.edgeEncoders.hashCode() : 0);
+		return hash;
+	}
 
-    @Override
+	@Override
     public boolean equals( Object obj )
     {
-        if (obj == null)
-            return false;
+		if (obj == null)
+			return false;
 
-        if (getClass() != obj.getClass())
-            return false;
+		if (getClass() != obj.getClass())
+			return false;
 
-        final EncodingManager other = (EncodingManager) obj;
+		final EncodingManager other = (EncodingManager) obj;
         if (this.edgeEncoders != other.edgeEncoders && (this.edgeEncoders == null || !this.edgeEncoders.equals(other.edgeEncoders)))
         {
-            return false;
-        }
-        return true;
-    }
+			return false;
+		}
+		return true;
+	}
 
-    /**
+	/**
      * Analyze tags on osm node. Store node tags (barriers etc) for later usage while parsing way.
-     */
+	 */
     public long handleNodeTags( Node node )
     {
-        long flags = 0;
+		long flags = 0;
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            flags |= encoder.handleNodeTags(node);
-        }
+			flags |= encoder.handleNodeTags(node);
+		}
 
-        return flags;
-    }
+		return flags;
+	}
 
     private static int determineRequiredBits( int value )
     {
-        int numberOfBits = 0;
+		int numberOfBits = 0;
         while (value > 0)
         {
-            value = value >> 1;
-            numberOfBits++;
-        }
-        return numberOfBits;
-    }
+			value = value >> 1;
+			numberOfBits++;
+		}
+		return numberOfBits;
+	}
 
     public Collection<ITurnCostTableEntry> analyzeTurnRelation( TurnRelation turnRelation, DataReader osmReader )
     {
-        TLongObjectMap<ITurnCostTableEntry> entries = new TLongObjectHashMap<ITurnCostTableEntry>();
+		TLongObjectMap<ITurnCostTableEntry> entries = new TLongObjectHashMap<ITurnCostTableEntry>();
 
-        int encoderCount = edgeEncoders.size();
+		int encoderCount = edgeEncoders.size();
         for (int i = 0; i < encoderCount; i++)
         {
-            AbstractFlagEncoder encoder = edgeEncoders.get(i);
+			AbstractFlagEncoder encoder = edgeEncoders.get(i);
             for (ITurnCostTableEntry entry : encoder.analyzeTurnRelation(turnRelation, osmReader))
             {
-                ITurnCostTableEntry oldEntry = entries.get(entry.getItemId());
+				ITurnCostTableEntry oldEntry = entries.get(entry.getItemId());
                 if (oldEntry != null)
                 {
-                    // merging different encoders
-                    long oldFlags = oldEntry.getFlags();
-                    long flags = entry.getFlags();
-                    oldFlags |= flags;
-                    oldEntry.setFlags(oldFlags);
+					// merging different encoders
+					long oldFlags = oldEntry.getFlags();
+					long flags = entry.getFlags();
+					oldFlags |= flags;
+					oldEntry.setFlags(oldFlags);
                 } else
                 {
-                    entries.put(entry.getItemId(), entry);
-                }
-            }
-        }
+					entries.put(entry.getItemId(), entry);
+				}
+			}
+		}
 
-        return entries.valueCollection();
-    }
+		return entries.valueCollection();
+	}
 
     public EncodingManager setEnableInstructions( boolean enableInstructions )
     {
-        this.enableInstructions = enableInstructions;
-        return this;
-    }
+		this.enableInstructions = enableInstructions;
+		return this;
+	}
 
     public void applyWayTags( Way way, EdgeIteratorState edge )
     {
         // storing the road name does not yet depend on the flagEncoder so manage it directly
         if (enableInstructions)
         {
-            // String wayInfo = carFlagEncoder.getWayInfo(way);
-            // http://wiki.openstreetmap.org/wiki/Key:name
-            String name = fixWayName(way.getTag("name"));
-            // http://wiki.openstreetmap.org/wiki/Key:ref
-            String refName = fixWayName(way.getTag("ref"));
+			// String wayInfo = carFlagEncoder.getWayInfo(way);
+			// http://wiki.openstreetmap.org/wiki/Key:name
+			String name = fixWayName(way.getTag("name"));
+			// http://wiki.openstreetmap.org/wiki/Key:ref
+			String refName = fixWayName(way.getTag("ref"));
             if (!Helper.isEmpty(refName))
             {
-                if (Helper.isEmpty(name))
-                    name = refName;
-                else
-                    name += ", " + refName;
-            }
+				if (Helper.isEmpty(name))
+					name = refName;
+				else
+					name += ", " + refName;
+			}
 
-            edge.setName(name);
-        }
+			edge.setName(name);
+		}
 
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            encoder.applyWayTags(way, edge);
-        }
-    }
-
-    /**
-     * The returned list is never empty.
-     */
+			encoder.applyWayTags(way, edge);
+		}
+	}
+
+	/**
+	 * Each encoder decorator should be used only once and in a defined order
+	 */
+	private void configureDecoratorSet() {
+		Map<Class, EncoderDecorator> decoratorMap = new HashMap<Class, EncoderDecorator>();
+		for (AbstractFlagEncoder encoder : edgeEncoders) {
+			List<EncoderDecorator> decoratorList = encoder.getEncoderDecorators();
+			if (null != decoratorList) {
+				for (EncoderDecorator encoderDecorator : decoratorList) {
+					decoratorMap.put(encoderDecorator.getClass(), encoderDecorator);
+				}
+			}
+		}
+		decorators = new ArrayList<EncoderDecorator>();
+		decorators.addAll(decoratorMap.values());
+	}
+
+	public List<EncoderDecorator> getDecorators() {
+		return decorators;
+	}
+
+	/**
+	 * The returned list is never empty.
+	 */
     public List<FlagEncoder> fetchEdgeEncoders()
     {
-        List<FlagEncoder> list = new ArrayList<FlagEncoder>();
-        list.addAll(edgeEncoders);
-        return list;
-    }
+		List<FlagEncoder> list = new ArrayList<FlagEncoder>();
+		list.addAll(edgeEncoders);
+		return list;
+	}
 
     static String fixWayName( String str )
     {
-        if (str == null)
-            return "";
-        return str.replaceAll(";[ ]*", ", ");
-    }
+		if (str == null)
+			return "";
+		return str.replaceAll(";[ ]*", ", ");
+	}
 
     public boolean needsTurnCostsSupport()
     {
         for (FlagEncoder encoder : edgeEncoders)
         {
-            if (encoder.supports(TurnWeighting.class))
-                return true;
-        }
-        return false;
-    }
-
-    /**
+			if (encoder.supports(TurnWeighting.class))
+				return true;
+		}
+		return false;
+	}
+
+	public boolean needsAttributeStorageSupport() {
+		for (FlagEncoder encoder : edgeEncoders) {
+			if (encoder.supports(PriorityWithAvoidancesWeighting.class))
+				return true;
+		}
+		return false;
+	}
+
+	/**
      * Create the EncodingManager from the provided GraphHopper location. Throws an
      * IllegalStateException if it fails.
-     */
+	 */
     public static EncodingManager create( String ghLoc )
     {
-        Directory dir = new RAMDirectory(ghLoc, true);
-        StorableProperties properties = new StorableProperties(dir);
-        if (!properties.loadExisting())
+		Directory dir = new RAMDirectory(ghLoc, true);
+		StorableProperties properties = new StorableProperties(dir);
+		if (!properties.loadExisting())
             throw new IllegalStateException("Cannot load properties to fetch EncodingManager configuration at: "
-                    + dir.getLocation());
+							+ dir.getLocation());
 
-        // check encoding for compatiblity
-        properties.checkVersions(false);
-        String acceptStr = properties.get("graph.flagEncoders");
+		// check encoding for compatiblity
+		properties.checkVersions(false);
+		String acceptStr = properties.get("graph.flagEncoders");
 
-        if (acceptStr.isEmpty())
+		if (acceptStr.isEmpty())
             throw new IllegalStateException("EncodingManager was not configured. And no one was found in the graph: "
-                    + dir.getLocation());
+							+ dir.getLocation());
 
-        int bytesForFlags = 4;
-        if ("8".equals(properties.get("graph.bytesForFlags")))
-            bytesForFlags = 8;
-        return new EncodingManager(acceptStr, bytesForFlags);
-    }
+		int bytesForFlags = 4;
+		if ("8".equals(properties.get("graph.bytesForFlags")))
+			bytesForFlags = 8;
+		return new EncodingManager(acceptStr, bytesForFlags);
+	}
 
-    public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
+	public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            if (encoder.isVehicleQualifierTypeIncluded(routingElement))
-                return true;
-        }
-        return false;
-    }
-    public boolean isVehicleQualifierTypeExcluded(RoutingElement routingElement) {
+			if (encoder.isVehicleQualifierTypeIncluded(routingElement))
+				return true;
+		}
+		return false;
+	}
+
+	public boolean isVehicleQualifierTypeExcluded(RoutingElement routingElement) {
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
-            if (encoder.isVehicleQualifierTypeExcluded(routingElement))
-                return true;
-        }
-        return false;
-    }
+			if (encoder.isVehicleQualifierTypeExcluded(routingElement))
+				return true;
+		}
+		return false;
+	}
 
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
index f2cca8dfe2..0ed49d2d6f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWithAvoidancesWeighting.java
@@ -1,13 +1,17 @@
 package com.graphhopper.routing.util;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class FastestWithAvoidancesWeighting extends FastestWeighting {
 
 	private long bitMask;
+	private AvoidanceAttributeExtension extension;
 
-	public FastestWithAvoidancesWeighting(FlagEncoder encoder, String... avoidances) {
+
+	public FastestWithAvoidancesWeighting(FlagEncoder encoder, AvoidanceAttributeExtension extension, String... avoidances) {
 		super(encoder);
+		this.extension = extension;
 		configureAvoidances(avoidances);
 	}
 
@@ -18,11 +22,15 @@ private void configureAvoidances(String[] avoidances) {
 	@Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
     {
-        long wayType = edge.getFlags();
-        wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
-            return Double.POSITIVE_INFINITY;
-        }
+		try {
+			long extensionPointer = edge.getAdditionalField();
+			long wayType = extension.getAvoidanceFlags(extensionPointer);
+			if(bitMask!=0 && ((wayType & bitMask) > 0)) {
+				return Double.POSITIVE_INFINITY;
+			}
+		} catch (UnsupportedOperationException onse) {
+			System.err.println(onse);
+		}
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 7d4076b851..4c3d8edfcf 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
 
@@ -121,6 +122,9 @@
      * @return additional cost or warning information for an instruction like ferry or road charges.
      */
     InstructionAnnotation getAnnotation( long flags, Translation tr );
+    InstructionAnnotation getAnnotation(long flags, Translation tr, int additionalField, GraphExtension extraInfo);
+
 
 	long getBitMask(String[] avoidances, int key);
-}
+
+	}
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 0ad02dd6f2..6af527fc46 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -295,9 +295,8 @@ public long handleWayTags(Way way, long allowed, long relationFlags) {
             encoded = handleFerryTags(way, SLOW_SPEED, MEAN_SPEED, FERRY_SPEED);
             encoded |= directionBitMask;
         }
-        long anno = super.handleWayTagsDecorators(way);
 
-        return encoded |= anno;
+        return encoded;
     }
 
     @Override
@@ -386,7 +385,7 @@ public boolean supports(Class<?> feature) {
         if (super.supports(feature))
             return true;
 
-        return PriorityWeighting.class.isAssignableFrom(feature);
+        return PriorityWeighting.class.isAssignableFrom(feature)  && !PriorityWithAvoidancesWeighting.class.isAssignableFrom(feature);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/OsBikeFlagEncoder.java
index 11946aefba..9cd1ba57c8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsBikeFlagEncoder.java
@@ -2,7 +2,7 @@
 
 import java.util.ArrayList;
 
-public class OsBikeFlagEncoder extends BikeFlagEncoder {
+public class OsBikeFlagEncoder extends MountainBikeFlagEncoder {
 	
 		public OsBikeFlagEncoder() {
 	        super(4, 2, 0);
@@ -28,4 +28,12 @@ private void setOsAvoidanceDecorator() {
 			}
 			encoderDecorators.add(new OsAvoidanceDecorator());
 		}
+		
+		@Override
+		public boolean supports(Class<?> feature) {
+			 if (super.supports(feature))
+		            return true;
+			 
+			 return (PriorityWithAvoidancesWeighting.class.isAssignableFrom(feature));
+		}
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java
index c192d8b539..8e09019e3a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsCarFlagEncoder.java
@@ -25,5 +25,13 @@ private void setOsAvoidanceDecorator() {
 		}
 		encoderDecorators.add(new OsVehicleAvoidanceDecorator());
 	}
+	
+	@Override
+	public boolean supports(Class<?> feature) {
+		 if (super.supports(feature))
+	            return true;
+		 
+		 return (PriorityWithAvoidancesWeighting.class.isAssignableFrom(feature));
+	}
 
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/OsFootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/OsFootFlagEncoder.java
index f4ade0b8a7..17185abfc0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/OsFootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/OsFootFlagEncoder.java
@@ -27,5 +27,13 @@ private void setOsAvoidanceDecorator() {
 		}
 		encoderDecorators.add(new OsAvoidanceDecorator());
 	}
+	
+	@Override
+	public boolean supports(Class<?> feature) {
+		 if (super.supports(feature))
+	            return true;
+		 
+		 return (PriorityWithAvoidancesWeighting.class.isAssignableFrom(feature));
+	}
 
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
index b621e7474b..e7cefcf704 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeighting.java
@@ -1,13 +1,16 @@
 package com.graphhopper.routing.util;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class PriorityWithAvoidancesWeighting extends PriorityWeighting {
 
 	private long bitMask;
+	private AvoidanceAttributeExtension extension;
 
-	public PriorityWithAvoidancesWeighting(FlagEncoder encoder, String... avoidances) {
+	public PriorityWithAvoidancesWeighting(FlagEncoder encoder, AvoidanceAttributeExtension extension, String... avoidances) {
 		super(encoder);
+		this.extension = extension;
 		configureAvoidances(avoidances);
 	}
 
@@ -18,11 +21,16 @@ private void configureAvoidances(String[] avoidances) {
 	@Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
     {
-        long wayType = edge.getFlags();
-        wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
-            return Double.POSITIVE_INFINITY;
-        }
+		try {
+			long extensionPointer = edge.getAdditionalField();
+			long wayType = extension.getAvoidanceFlags(extensionPointer);
+			if(bitMask!=0 && ((wayType & bitMask) > 0)) {
+				return Double.POSITIVE_INFINITY;
+			}
+		} catch (UnsupportedOperationException onse) {
+			System.err.println(onse);
+		}
+		
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
index 74bfed8399..dd317cea79 100644
--- a/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeighting.java
@@ -1,14 +1,17 @@
 package com.graphhopper.routing.util;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class ShortestWithAvoidancesWeighting extends ShortestWeighting {
 
 	private long bitMask;
 	private FlagEncoder encoder;
+	private AvoidanceAttributeExtension extension;
 
-	public ShortestWithAvoidancesWeighting(FlagEncoder encoder, String... avoidances) {
+	public ShortestWithAvoidancesWeighting(FlagEncoder encoder, AvoidanceAttributeExtension extension, String... avoidances) {
 		super();
+		this.extension = extension;
 		this.encoder = encoder;
 		configureAvoidances(avoidances);
 	}
@@ -20,11 +23,15 @@ private void configureAvoidances(String[] avoidances) {
 	@Override
     public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId )
     {
-        long wayType = edge.getFlags();
-        wayType = encoder.getLong(wayType, AbstractAvoidanceDecorator.KEY);
-        if(bitMask!=0 && ((wayType & bitMask) > 0)) {
-            return Double.POSITIVE_INFINITY;
-        }
+		try {
+			long extensionPointer = edge.getAdditionalField();
+			long wayType = extension.getAvoidanceFlags(extensionPointer);
+			if(bitMask!=0 && ((wayType & bitMask) > 0)) {
+				return Double.POSITIVE_INFINITY;
+			}
+		} catch (UnsupportedOperationException onse) {
+			System.err.println(onse);
+		}
         return super.calcWeight(edge, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/AvoidanceAttributeExtension.java b/core/src/main/java/com/graphhopper/storage/AvoidanceAttributeExtension.java
new file mode 100644
index 0000000000..119504eb27
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/AvoidanceAttributeExtension.java
@@ -0,0 +1,227 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * Holds avoidance attribute table for each edge. The additional field of an edge will be used to point
+ * towards an entry within an edge attribute table to identify additional edge attributes.
+ * <p>
+ * @author Stuart Adam
+ * @author Peter Karich
+ */
+public class AvoidanceAttributeExtension implements GraphExtension
+{
+    /* pointer for no cost entry */
+    private final int NO_TURN_ENTRY = -1;
+    private final long EMPTY_FLAGS = 0L;
+
+  
+
+    private DataAccess avoidanceFlags;
+    private int avoidanceFlagEntryIndex = -4;
+    private int avoidanceAttributeFlagBytes;
+    private int attributeCount;
+
+    private GraphStorage graph;
+
+    public AvoidanceAttributeExtension()
+    {
+        avoidanceAttributeFlagBytes = avoidanceFlagEntryIndex + 4;
+        attributeCount = 0;
+    }
+
+    @Override
+    public void init( GraphStorage graph )
+    {
+        if (attributeCount > 0)
+            throw new AssertionError("The avoidance attribute storage must be initialized only once.");
+
+        this.graph = graph;
+        this.avoidanceFlags = this.graph.getDirectory().find("avoidance_flags");
+    }
+
+    private int nextAttributeFlagIndex()
+    {
+        avoidanceFlagEntryIndex += 4;
+        return avoidanceFlagEntryIndex;
+    }
+
+    @Override
+    public void setSegmentSize( int bytes )
+    {
+        avoidanceFlags.setSegmentSize(bytes);
+    }
+
+    @Override
+    public AvoidanceAttributeExtension create( long initBytes )
+    {
+        avoidanceFlags.create((long) initBytes * avoidanceAttributeFlagBytes);
+        return this;
+    }
+
+    @Override
+    public void flush()
+    {
+        avoidanceFlags.setHeader(0, avoidanceAttributeFlagBytes);
+        avoidanceFlags.setHeader(1 * 4, attributeCount);
+        avoidanceFlags.flush();
+    }
+
+    @Override
+    public void close()
+    {
+        avoidanceFlags.close();
+    }
+
+    @Override
+    public long getCapacity()
+    {
+        return avoidanceFlags.getCapacity();
+    }
+
+    @Override
+    public boolean loadExisting()
+    {
+        if (!avoidanceFlags.loadExisting())
+            return false;
+
+        avoidanceAttributeFlagBytes = avoidanceFlags.getHeader(0);
+        attributeCount = avoidanceFlags.getHeader(4);
+        return true;
+    }
+
+    /**
+     * This method adds a new entry which is an edge attribute flags.
+     * Check if there is actually a value to set and if so configure and set the appropriate storage.
+     */
+    public void addEdgeInfo( int edge, int adjNode, long attributeFlag )
+    {
+        
+        if (attributeFlag == EMPTY_FLAGS)
+            return;
+
+        EdgeIteratorState edgeProps = graph.getEdgeProps(edge, adjNode);
+		int previousEntryIndex = edgeProps.getAdditionalField();
+        if (previousEntryIndex == NO_TURN_ENTRY)
+        {
+        	int newEntryIndex = createNewEntry(edgeProps);
+            setAttributeEntry(attributeFlag, newEntryIndex);
+        } else
+        {
+        	setAttributeEntry(attributeFlag, previousEntryIndex);
+        }
+    }
+
+    /**
+     * Ensure sufficient space for new attribute entry
+     * set edge attribute-pointer to this new entry
+     * @param edgeProps edgeReference for this attribute set.
+     * @return
+     */
+	private int createNewEntry(EdgeIteratorState edgeProps) {
+		int newEntryIndex = nextAttributeFlagIndex();
+		ensureAttributeIndex(newEntryIndex);
+		edgeProps.setAdditionalField(newEntryIndex);
+		return newEntryIndex;
+	}
+
+	private void setAttributeEntry(long attributeFlag, int newEntryIndex) {
+		avoidanceFlags.setInt(newEntryIndex, (int)attributeFlag);
+	}
+    
+    public long getAvoidanceFlags(long extensionPointer) {
+    	if (extensionPointer > NO_TURN_ENTRY) {
+        	return avoidanceFlags.getInt(extensionPointer);
+        }
+        return EMPTY_FLAGS;
+	}
+
+    private long nextCostFlags( int edgeId, int adjNode)
+    {
+    	EdgeIteratorState edgeProps = graph.getEdgeProps(edgeId, adjNode);
+        int extensionPointer = edgeProps.getAdditionalField();
+        return getAvoidanceFlags(extensionPointer);
+    }
+
+    private void ensureAttributeIndex( int nodeIndex )
+    {
+        avoidanceFlags.ensureCapacity(((long) nodeIndex + 4) * avoidanceAttributeFlagBytes);
+    }
+
+    @Override
+    public boolean isRequireNodeField()
+    {
+        return false;
+    }
+
+    @Override
+    /**
+     * We require the additional field in the graph to point to the first entry in the edge table
+     */
+    public boolean isRequireEdgeField()
+    {
+        return true;
+    }
+
+    @Override
+    /**
+     * Avoidances are properties of edges so no node entries
+     */
+    public int getDefaultNodeFieldValue()
+    {
+    	throw new UnsupportedOperationException("Not supported by this storage");
+    }
+
+    @Override
+    public int getDefaultEdgeFieldValue()
+    {
+    	return NO_TURN_ENTRY;
+    }
+
+    @Override
+    public GraphExtension copyTo( GraphExtension clonedStorage )
+    {
+        if (!(clonedStorage instanceof AvoidanceAttributeExtension))
+        {
+            throw new IllegalStateException("the extended storage to clone must be the same");
+        }
+
+        AvoidanceAttributeExtension clonedTC = (AvoidanceAttributeExtension) clonedStorage;
+
+        avoidanceFlags.copyTo(clonedTC.avoidanceFlags);
+        clonedTC.attributeCount = attributeCount;
+
+        return clonedStorage;
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return avoidanceFlags.isClosed();
+    }
+
+    @Override
+    public String toString()
+    {
+        return "avoidance";
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java
index 81b5e30c5a..b92196497a 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FastestWithAvoidancesWeightingTest.java
@@ -10,7 +10,9 @@
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.mockito.stubbing.OngoingStubbing;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class FastestWithAvoidancesWeightingTest {
@@ -20,6 +22,9 @@
 	@Mock
 	EdgeIteratorState edge;
 	
+	@Mock
+	AvoidanceAttributeExtension avoidanceExtension;
+	
 	@Before
 	public void configureMocks() {
 		MockitoAnnotations.initMocks(this);
@@ -30,19 +35,19 @@ public void configureMocks() {
 	public void testSingleAvoidWhenMatches() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(4L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
 	}
-	
+
 	@Test
 	public void testSingleAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(1L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension,  "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -52,8 +57,8 @@ public void testSingleAvoidWhenNoMatch() {
 	public void testMultiAvoidWhenRouteIsExactMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(5L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension,  "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -63,8 +68,8 @@ public void testMultiAvoidWhenRouteIsExactMatch() {
 	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(4L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension,  "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -74,8 +79,8 @@ public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 	public void testMultiAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
-		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(2L);
+		FastestWithAvoidancesWeighting weighting = new FastestWithAvoidancesWeighting(encoder, avoidanceExtension,  "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -90,5 +95,9 @@ private void configureSpeeds() {
 		when(encoder.getMaxSpeed()).thenReturn(100D);
 		when(encoder.getSpeed(anyLong())).thenReturn(50D);
 	}
+	
+	private OngoingStubbing<Long> expectStoredAvoidance() {
+		return when(avoidanceExtension.getAvoidanceFlags(anyLong()));
+	}
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
index c6e303c645..f39dc09163 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PriorityWithAvoidancesWeightingTest.java
@@ -10,7 +10,9 @@
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.mockito.stubbing.OngoingStubbing;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class PriorityWithAvoidancesWeightingTest {
@@ -20,6 +22,9 @@
 	@Mock
 	EdgeIteratorState edge;
 	
+	@Mock
+	AvoidanceAttributeExtension avoidanceExtension;
+	
 	@Before
 	public void configureMocks() {
 		MockitoAnnotations.initMocks(this);
@@ -30,19 +35,19 @@ public void configureMocks() {
 	public void testSingleAvoidWhenMatches() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(4L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
 	}
-	
+
 	@Test
 	public void testSingleAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(1L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -52,8 +57,8 @@ public void testSingleAvoidWhenNoMatch() {
 	public void testMultiAvoidWhenRouteIsExactMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(5L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -63,8 +68,8 @@ public void testMultiAvoidWhenRouteIsExactMatch() {
 	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(4L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -74,8 +79,8 @@ public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 	public void testMultiAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
-		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(2L);
+		PriorityWithAvoidancesWeighting weighting = new PriorityWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -92,5 +97,10 @@ private void configureSpeedsAndPriority() {
 		when(encoder.getSpeed(anyLong())).thenReturn(50D);
 		when(encoder.getDouble(anyLong(), eq(101))).thenReturn(10D);
 	}
+	
+	private OngoingStubbing<Long> expectStoredAvoidance() {
+		return when(avoidanceExtension.getAvoidanceFlags(anyLong()));
+	}
+	
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java b/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java
index 6cd618de38..ac48627677 100644
--- a/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/ShortestWithAvoidancesWeightingTest.java
@@ -10,7 +10,9 @@
 import org.junit.Test;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.mockito.stubbing.OngoingStubbing;
 
+import com.graphhopper.storage.AvoidanceAttributeExtension;
 import com.graphhopper.util.EdgeIteratorState;
 
 public class ShortestWithAvoidancesWeightingTest {
@@ -20,6 +22,9 @@
 	@Mock
 	EdgeIteratorState edge;
 	
+	@Mock
+	AvoidanceAttributeExtension avoidanceExtension;
+	
 	@Before
 	public void configureMocks() {
 		MockitoAnnotations.initMocks(this);
@@ -30,19 +35,19 @@ public void configureMocks() {
 	public void testSingleAvoidWhenMatches() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(4L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
 	}
-	
+
 	@Test
 	public void testSingleAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(4L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(1L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff");
+		expectStoredAvoidance().thenReturn(1L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -52,8 +57,8 @@ public void testSingleAvoidWhenNoMatch() {
 	public void testMultiAvoidWhenRouteIsExactMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(5L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(5L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -63,8 +68,8 @@ public void testMultiAvoidWhenRouteIsExactMatch() {
 	public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(4L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(4L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertTrue("Avoidable Edges should have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -74,8 +79,8 @@ public void testMultiAvoidWhenRouteContainsOneOfTheAvoidances() {
 	public void testMultiAvoidWhenNoMatch() {
 		String[] avoidances = {"cliff","aroad"};
 		when(encoder.getBitMask(avoidances, AbstractAvoidanceDecorator.KEY)).thenReturn(5L);
-		when(encoder.getLong(anyLong(), eq(AbstractAvoidanceDecorator.KEY))).thenReturn(2L);
-		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, "cliff", "aroad");
+		expectStoredAvoidance().thenReturn(2L);
+		ShortestWithAvoidancesWeighting weighting = new ShortestWithAvoidancesWeighting(encoder, avoidanceExtension, "cliff", "aroad");
 		int prevOrNextEdgeId=1;
 		boolean reverse = false;
 		assertFalse("Routable Edges should not have maximum weight", Double.isInfinite(weighting.calcWeight(edge, reverse , prevOrNextEdgeId)));
@@ -91,5 +96,9 @@ private void configureSpeeds() {
 		when(encoder.getMaxSpeed()).thenReturn(100D);
 		when(encoder.getSpeed(anyLong())).thenReturn(50D);
 	}
+	
+	private OngoingStubbing<Long> expectStoredAvoidance() {
+		return when(avoidanceExtension.getAvoidanceFlags(anyLong()));
+	}
 
 }
diff --git a/core/src/test/java/com/graphhopper/storage/AvoidanceAttributeExtensionTest.java b/core/src/test/java/com/graphhopper/storage/AvoidanceAttributeExtensionTest.java
new file mode 100644
index 0000000000..0d3424919c
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/AvoidanceAttributeExtensionTest.java
@@ -0,0 +1,54 @@
+package com.graphhopper.storage;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import java.nio.ByteOrder;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+public class AvoidanceAttributeExtensionTest {
+	DataAccess dataAccess;
+
+	@Mock
+	GraphHopperStorage graph;
+	@Mock
+	Directory directory;
+	@Mock
+	EdgeIteratorState edgeOne;
+	@Mock
+	EdgeIteratorState edgeTwo;
+	
+	@Before
+	public void init() {
+		dataAccess = new RAMDataAccess("","", false, ByteOrder.LITTLE_ENDIAN);
+		MockitoAnnotations.initMocks(this);
+		Mockito.when(graph.getDirectory()).thenReturn(directory);
+		Mockito.when(directory.find("avoidance_flags")).thenReturn(dataAccess);
+	}
+
+	@Test
+	public void testAddEdgeInfo() {
+		Mockito.when(graph.getEdgeProps(0, 1)).thenReturn(edgeOne);
+		Mockito.when(graph.getEdgeProps(1, 5)).thenReturn(edgeTwo);
+		Mockito.when(edgeOne.getAdditionalField()).thenReturn(-1).thenReturn(0);
+		Mockito.when(edgeTwo.getAdditionalField()).thenReturn(-1).thenReturn(4);
+		
+		AvoidanceAttributeExtension extension = new AvoidanceAttributeExtension();
+		extension.init(graph);
+		extension.create(4);
+		extension.addEdgeInfo(0, 1, 100);
+		extension.addEdgeInfo(1, 5, 200);
+		assertEquals("Retrieved value should match stored", 200, extension.getAvoidanceFlags(edgeTwo.getAdditionalField()));
+		assertEquals("Retrieved value should match stored", 100, extension.getAvoidanceFlags(edgeOne.getAdditionalField()));
+		extension.close();
+	}
+
+}
